{"id": "wdGcDt", "name": "Jzazbz", "author": "thepheer", "description": "Jzazbz uniform color space implementation.\n\nhttps://observablehq.com/@jrus/jzazbz\nhttps://doi.org/10.1364/OE.25.015131", "tags": ["jzazbz"], "likes": 2, "viewed": 355, "published": 3, "date": "1604158979", "time_retrieved": "2024-07-30T20:37:18.368273", "image_code": "#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(x, a, b) ((a) <= (x) && (x) < (b))\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n    \n\tfloat tau = radians(360.0);\n    float J = 0.50 + 0.49*sin(tau*(0.2*uv.x - 0.1*iTime));\n    float C = J*(1.0 - J);\n    float h = tau*(fract(uv.x + 0.5*iTime) - 0.5);\n\n    // JzCzhz → Jzazbz → sRGB → Jzazbz → sRGB\n    vec3 Jab1 = JCh_to_Jab(vec3(0.167*J, 0.15*C, h));\n    vec3 sRGB1 = XYZ_D65_TO_sRGB*Jab_to_XYZ_D65(Jab1);\n    vec3 Jab2 = XYZ_D65_to_Jab(sRGB_TO_XYZ_D65*sRGB1);\n    vec3 sRGB2 = XYZ_D65_TO_sRGB*Jab_to_XYZ_D65(Jab2);\n\n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    vec3 split = 0.025*vec3(-1.0, 0.0, 1.0);\n    \n    vec3 plots =\n        plot(px.y, uv.y, 0.500)*dotted*0.1 +\n        plot(px.y, uv.y, 0.100)*dotted*0.1 +\n        plot(px.y, uv.y, 0.775 + 5e2*(Jab2 - Jab1) - split) +\n       \tplot(px.y, uv.y, 0.625 + 5e1*(sRGB2 - sRGB1) - split) +\n        plot(px.y, uv.y, 0.100 + 0.4*sRGB1)*0.5 +\n        plot(px.y, uv.y, 0.100 + 0.4*sRGB2)*0.5*dashed;\n\n    vec3 rgb =\n        range(uv.y, px.y + 0.95, 1.00) ? sRGB1 :\n        range(uv.y, px.y + 0.90, 0.95) ? sRGB2 :\n    \tplots;\n\n    rgba = vec4(sRGB_OETF(rgb), 1.0);\n}", "image_inputs": [], "common_code": "#define diag3(v) mat3((v).x, 0.0, 0.0, 0.0, (v).y, 0.0, 0.0, 0.0, (v).z)\n#define xy_to_XYZ(x, y) vec3(x/y, 1.0, (1.0 - x - y)/y)\n\nconst vec3 D65 = xy_to_XYZ(0.31271, 0.32902);\nconst mat3 sRGB = mat3(xy_to_XYZ(0.64, 0.33), xy_to_XYZ(0.30, 0.60), xy_to_XYZ(0.15, 0.06));\nconst mat3 sRGB_TO_XYZ_D65 = sRGB*diag3(inverse(sRGB)*D65);\nconst mat3 XYZ_D65_TO_sRGB = inverse(sRGB_TO_XYZ_D65);\n\nvec3 sRGB_OETF(vec3 c) {\n    vec3 a = 12.92*c;\n    vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));\n}\n\nvec3 sRGB_EOTF(vec3 c) {\n    vec3 a = c/12.92;\n    vec3 b = pow((c + 0.055)/1.055, vec3(2.4));\n    return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));\n}\n\nconst float b = 1.15;\nconst float g = 0.66;\nconst float c1 = 3424.0/exp2(12.0);\nconst float c2 = 2413.0/exp2(7.0);\nconst float c3 = 2392.0/exp2(7.0);\nconst float n = 2610.0/exp2(14.0);\nconst float p = 1.7*2523.0/exp2(5.0);\nconst float d = -0.56;\nconst float d0 = 1.6295499532821566e-11;\n\nconst mat3 XYZ_D65_TO_LMS = 1e2/1e4*mat3(\n    +0.41478972, -0.20151000, -0.01660080,\n    +0.57999900, +1.12064900, +0.26480000,\n    +0.01464800, +0.05310080, +0.66847990\n)*mat3(b, 1.0-g, 0.0, 0.0, g, 0.0, 1.0-b, 0.0, 1.0);\n\nconst mat3 LMS_TO_Iab = mat3(\n    +0.5, +3.524000, +0.199076,\n    +0.5, -4.066708, +1.096799,\n    +0.0, +0.542708, -1.295875\n);\n\nvec3 XYZ_D65_to_Jab(vec3 XYZ) {\n    vec3 LMS = XYZ_D65_TO_LMS*XYZ;\n    vec3 LMSpp = pow(LMS, vec3(n));\n    vec3 LMSp = pow((c1 + c2*LMSpp)/(1.0 + c3*LMSpp), vec3(p));\n    vec3 Iab = LMS_TO_Iab*LMSp;\n    float J = (1.0 + d)*Iab.x/(1.0 + d*Iab.x) - d0;\n    return vec3(J, Iab.yz);\n}\n\nvec3 Jab_to_XYZ_D65(vec3 Jab) {\n    float I = (Jab.x + d0)/(1.0 + d - d*(Jab.x + d0));\n    vec3 LMSp = inverse(LMS_TO_Iab)*vec3(I, Jab.yz);\n    vec3 LMSpp = pow(LMSp, vec3(1.0/p));\n    vec3 LMS = pow((c1 - LMSpp)/(c3*LMSpp - c2), vec3(1.0/n));\n    return inverse(XYZ_D65_TO_LMS)*LMS;\n}\n\nvec3 JCh_to_Jab(vec3 JCh) {\n    return vec3(JCh.x, JCh.y*vec2(cos(JCh.z), sin(JCh.z)));\n}\n\nvec3 Jab_to_JCh(vec3 Jab) {\n    return vec3(Jab.x, length(Jab.yz), atan(Jab.z, Jab.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 223, 223, 1386]], "test": "untested"}
{"id": "WscBzr", "name": "puerta se abre", "author": "jorge2017a1", "description": "puerta se abre", "tags": ["puertaseabre"], "likes": 1, "viewed": 284, "published": 3, "date": "1604150803", "time_retrieved": "2024-07-30T20:37:19.413478", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    float planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n   \n    p.y=p.y-5.0;\n    \n    \n\tvec3 q=p;  //repetir\n    float cz=34.0;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t\n    float anchox=19.0;\n    float anchoz=17.0;\n    float gruesopared=0.4;\n    float sdbLatIzq= sdBox(p-vec3(-anchox,0.0,0.0), vec3(gruesopared,22.0,22.0) );\n    float sdbLatDer= sdBox(p-vec3( anchox,0.0,0.0), vec3(gruesopared,22.0,22.0) );\n    float sdbParedAtras=    sdBox(p-vec3(0.0,0.0,-anchoz), vec3(22.0,22.0,gruesopared) );\n    float sdbParedAdelante= sdBox(p-vec3(0.0,0.0, anchoz), vec3(22.0,22.0,gruesopared) );\n    \n    float sdbPuertaDif= sdBox(p-vec3(0.0,0.0, 0.0), vec3(5.0,10.0,anchoz+2.0) );\n    sdbParedAtras= differenceSDF(sdbParedAtras,sdbPuertaDif);\n    sdbParedAdelante= differenceSDF(sdbParedAdelante,sdbPuertaDif);\n\n    float posxmov;\n    //control de puerta\n    if (mod(itime, 20.0) <11.0)\n     posxmov=mod(iTime,11.0)+1.5;\n    \n    float sdbPuertaAbreA= sdBox(p-vec3(posxmov,0.0, anchoz), vec3(5.0,10.0,0.05) );\n    float sdbPuertaAbreB= sdBox(p-vec3(posxmov,0.0, -anchoz), vec3(5.0,10.0,0.05) );\n    \n    res =opU3(res, vec3( sdbLatIzq,-1.0,6.0)); \n    res =opU3(res, vec3( sdbLatDer,-1.0,6.0)); \n\tres =opU3(res, vec3( sdbParedAtras,-1.0,5.0)); \n\tres =opU3(res, vec3( sdbParedAdelante,-1.0,5.0)); \n    res =opU3(res, vec3( sdbPuertaAbreA,-1.0,9.0)); \n    res =opU3(res, vec3( sdbPuertaAbreB,-1.0,9.0)); \n   \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*color;  //corregido por shane\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n       \n        if(dO>MAX_DIST )\n        {\t\n            mObj.dist = -1.0;\n    \t\tmObj.id_color = -1.0;\n    \t\tmObj.marchCount=marchCount;\n    \t\tmObj.id_material=-1.0;\n            //return -1.0;\n            break;\n        }\n        \n        if (abs(dS.x)<MIN_DIST) \n        { break;  }\n        dO += dS.x;\n        marchCount++;       \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 64.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    \n    vec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n     }\n    else\n    {  return result; }\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n        \n    if (id_material==5.0)\n    {   vec2 uv;\n\t\tuv=(p.xy)*17.0;\n     \treturn  Ladrillos(uv )*0.8;\n    }\n    \n    if (id_material==6.0)\n    { \n     vec2 uv=p.zy*17.0; return  Ladrillos(uv )*0.8;\n    }\n    \n    if (id_material==7.0)\n    { \n     vec2 uv=p.zx*20.0; return pisov2(uv );\n    }\n    \n    if (id_material==8.0)\n    { \n     vec2 uv=p.xy*10.0;\n     return colorfmb(uv);\n    }\n     \n    \n    if (id_material==9.0)\n    { \n      vec2 uv=p.xy*5.0;\n      return  mix (vec3 (0.9, 0.4, 0.2), vec3 (0.55, 0.25, 0.1),fbm2 (p.xy));\n        \n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n   \tfloat  posxmov;\n     posxmov=iTime*2.0;\n    \n    vec3 ro=vec3(0.0,7.0,-40.0+posxmov);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n    \n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n//------------ooooooooooo-------------------\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nconst vec2 bricksize = vec2(96., 64.);\nconst vec2 brickspace = vec2(10., 10.);\n\n\n//-Referencia Dr2\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 1; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\n//------------ooooooooooo-------------------\n\nvec4 heightmap(vec2 position)\n{\n\tfloat height = 0.0;\n\tvec3 color = vec3(0.85,0.125,0.125);\n\t\n\tfloat row = floor(position.y/bricksize.y);\n\t\n\tif (mod(row, 2.0) < 1.0)\n\t\tposition.x += bricksize.x/2.;\n\t\n\theight = min(fbm2(position*0.125)-0.45,0.0);\n\t\n\tcolor *= fbm2(position*0.0625)*0.5+0.75;\n\t\n\tif(mod(position.x,bricksize.x) < brickspace.x || mod(position.y,bricksize.y) < brickspace.y)\n\t{\n\t\theight = -2.0+fbm2(position)*0.5;\n\t\tcolor = vec3(fbm2(position)*0.75);\n\t}\n\n\treturn vec4(color,height);\n}\n\t\nfloat n1,n2,n3,n4;\nvec2 size = vec2(-0.4,0.0);\n\n\n\nvec3 thing(vec2 pos) \n{\n\tfloat row = floor((pos.y)/80.);\n\tif (mod(row, 2.0) < 1.0)\n\t\tpos.x += 40.;\n\t\n\tvec2 p = pos*0.0125;\n\tfloat n1 = fbm2(p * 4.0);\n\tp.x = fract(p.x+.5)-0.5;\n\tp.y = fract(p.y+.5)-0.5;\n\tp = abs(p);\n   \tfloat a = atan(p.y, p.x);\n\tfloat b = atan(p.x, p.y);\n\tfloat n2 = fbm2(p * 1.5) * (a * b);\n\tfloat n3 = n1 * 0.15 / n2 * .75;\n\tfloat s = min(p.x,p.y) - n3;\n\tfloat f = mix(s, 1.-n1, 0.5);\n\treturn vec3(p, f);\n}\nvec3 m1,m2,m3,m4;\nvec2 sizem = vec2(-0.2,0.0);\n\n\nvec3 pisov2( vec2 puv )\n{\n\tvec2 p = puv;\n    \n\tvec3 color = vec3(0.0);\n\tvec2 off = vec2(p.x,p.y-1.0);\n\tm1 = thing(off);\n\toff = vec2(p.x-1.0,p.y);\n\tm2 = thing(off);\n\toff = vec2(p.x+1.0,p.y);\n\tm3 = thing(off);\n\toff = vec2(p.x,p.y+1.0);\n\tm4 = thing(off);\n\t\n\tvec3 va = normalize(vec3(sizem.xy,m2.z-m3.z));\n\tvec3 vb = normalize(vec3(sizem.yx,m1.z-m4.z));\n\t\n    vec3 p2m = vec3(0.5);\t\n\tvec3 normal = vec3(cross(va,vb));\n\t\n\tcolor = vec3(dot(normal.xyz, p2m)/96.0);\n\t\n\treturn  pow( color,vec3(0.2545));\n}\n\n\n\nvec3 Ladrillos( vec2 puv )\n{\n\tvec2 pos = puv;\n\tvec2 off = vec2(pos.x,pos.y-1.0);\n\tvec3 col = heightmap(pos).xyz;\n\t\n\tn1 = heightmap(off).w;\n\toff = vec2(pos.x-1.0,pos.y);\n\tn2 = heightmap(off).w;\n\toff = vec2(pos.x+1.0,pos.y);\n\tn3 = heightmap(off).w;\n\toff = vec2(pos.x,pos.y+1.0);\n\tn4 = heightmap(off).w;\n\t\n\tvec3 va = normalize(vec3(size.xy,n2-n3));\n\tvec3 vb = normalize(vec3(size.yx,n1-n4));\n\t\n\t\n    vec3 p2m = vec3(1.0);\t\t\n\tvec3 normal = vec3(cross(va,vb));\n\t\n\tfloat color = dot(normal.xyz, normalize(p2m))*.5+.5;\n\tvec3 colorvec = vec3(pow(color,1.0),pow(color,1.0),pow(color,1.0));\n\t\n    float brightness = 1./sqrt(1.+pow(distance(puv,pos)/puv.x*4.,2.));\n\t\n\treturn  vec3( col+((colorvec*brightness)-0.5)*2.0 );\n}\n\nvec3 colorfmb(vec2 p)\n{\n    vec3 color = vec3(fbm2(p)*0.75);\n    return color;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 290, 290, 374], [376, 420, 467, 467, 494], [496, 496, 539, 539, 566], [568, 568, 616, 616, 644], [692, 732, 766, 766, 863], [864, 904, 929, 929, 2555], [2557, 2602, 2669, 2669, 2965], [2966, 3017, 3041, 3041, 3229], [3230, 3293, 3326, 3326, 4005], [4006, 4060, 4096, 4096, 4330], [4332, 4366, 4446, 4446, 4877], [4878, 4929, 4976, 4976, 5572], [5626, 5626, 5719, 5719, 5990], [5995, 6044, 6101, 6101, 7336]], "test": "untested"}
{"id": "WdcBzr", "name": "Another bad floating point hash", "author": "public_int_i", "description": "Attempt at making a hash using only floating points which keeps quality at different scales. Quality begins to break down when sampled in steps smaller then 6e-6 or larger then 2e7.", "tags": ["hash", "scale", "point", "floating", "large"], "likes": 3, "viewed": 308, "published": 3, "date": "1604150297", "time_retrieved": "2024-07-30T20:37:20.245254", "image_code": "\n/*returns psuedo random value from 0 to 1\nbased on seed value x\nx must be positive*/\nfloat hash(float x) {\n    float r = max(fract(x*1e-6),fract(x*1e3));\n    for (float i = r; i < 2.; i += .217) {//change i step size for quality/performance ratio\n     \tr += fract((x+i)*fract(r+i));\n    }\n    return fract(r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat scale = 1.;\n    fragColor = vec4(hash((fragCoord.x+fragCoord.y*iResolution.x)*scale));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 86, 107, 107, 312], [314, 314, 371, 371, 470]], "test": "untested"}
{"id": "WdGcDt", "name": "Desert Passage II", "author": "Shane", "description": "Encoding precalculated functions into the cube map faces to create a rocky landscape tunnel flythrough.", "tags": ["voronoi", "tunnel", "texture", "rock", "sand", "desert"], "likes": 65, "viewed": 1465, "published": 3, "date": "1604146670", "time_retrieved": "2024-07-30T20:37:21.476960", "image_code": "/*\n\n\tDesert Passage II\n\t-----------------\n\n\tEncoding precalculated functions into the cube map faces to create a rocky landscape \n    tunnel flythrough. This has been sitting in my account for a while, but I was too lazy\n\tto tidy the code up and post it until now. :)\n\n    To be honest, I find wrapped texture precalculation, packing and subsequent unpacking a\n\tlittle on the laborious side, so I wouldn't expect anyone to want to try to sift through\n\tthe code in order to decipher it. Regardless, this is just a proof of concept to show\n    that it's possible to encode more interesting surfaces (2D or 3D) into textures for \n    realtime use.\n\n    The surfaces themselves are just layers of 3D Voronoi and noise, which are pretty easy \n    to produce, but prohibitively expensive to construct on the fly in realtime. The sand\n    pattern comes from another example of mine.\n\n\tEncoding 3D information into textures isn't new, and has been performed by myself and \n\tothers on Shadertoy a few times. This version is unique in the sense that neighboring\n\tvalues are packed into all four channels in order to reduce the total number of texture\n\tcalls required for smooth interpolation -- Down from 8 to 2, which is obviously quicker.\n\tHowever, as mentioned previously, how well your machine handles this will depend on its\n\tability to deal with textures in memory and other things.\n\n\tMy machine can almost run this in fullscreen at full efficiency. However, if you have a \n    system that doesn't enjoy this, I apologize in advance, but will add that texture\n\tprecalculation is still worth the effort.\n\t\n\n\n\tRelated examples:\n\n\t// It won Breakpoint way back in 2009. For anyone not familiar with the demoscene, \n    // it's a big deal. :)\n\tElevated - IQ\n\thttps://www.shadertoy.com/view/MdX3Rr\n\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 100.\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n*/\n\n/* \n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(113, 1)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n\n}\n*/\n\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec2 to vec2.\nvec2 hash22(vec2 p){\n\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 42.123);\n    p = fract((p3.xx + p3.yz)*p3.zy)*2. - 1.;\n    return p;\n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = r2(mod(iTime, 6.2831853)); \n\t//p.xy = m * p.xy;//rotate gradient vector\n  \t//return p;\n}\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f){\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p){\n    \n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n    \n}\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n\n\n\n\n// Repeat gradient lines. How you produce these depends on the effect you're after. I've used a smoothed\n// triangle gradient mixed with a custom smoothed gradient to effect a little sharpness. It was produced\n// by trial and error. If you're not sure what it does, just call it individually, and you'll see.\nfloat grad(float x, float offs){\n    \n    // Repeat triangle wave. The tau factor and \".25\" factor aren't necessary, but I wanted its frequency\n    // to overlap a sine function.\n    x = abs(fract(x/6.283 + offs - .25) - .5)*2.;\n    \n    float x2 = clamp(x*x*(-1. + 2.*x), 0., 1.); // Customed smoothed, peaky triangle wave.\n    //x *= x*x*(x*(x*6. - 15.) + 10.); // Extra smooth.\n    x = smoothstep(0., 1., x); // Basic smoothing - Equivalent to: x*x*(3. - 2.*x).\n    return mix(x, x2, .15);\n    \n/*    \n    // Repeat sine gradient.\n    float s = sin(x + 6.283*offs + 0.);\n    return s*.5 + .5;\n    // Sine mixed with an absolute sine wave.\n    //float sa = sin((x +  6.283*offs)/2.);\n    //return mix(s*.5 + .5, 1. - abs(sa), .5);\n    \n*/\n}\n\n// One sand function layer... which is comprised of two mixed, rotated layers of repeat gradients lines.\nfloat sandL(vec2 p){\n    \n    // Layer one. \n    vec2 q = rot2(3.14159/18.)*p; // Rotate the layer, but not too much.\n    q.y += (gradN2D(q*18.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad1 = grad(q.y*80., 0.); // Repeat gradient lines.\n   \n    q = rot2(-3.14159/20.)*p; // Rotate the layer back the other way, but not too much.\n    q.y += (gradN2D(q*12.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad2 = grad(q.y*80., .5); // Repeat gradient lines.\n      \n    \n    // Mix the two layers above with an underlying 2D function. The function you choose is up to you,\n    // but it's customary to use noise functions. However, in this case, I used a transcendental \n    // combination, because I like the way it looked better.\n    // \n    // I feel that rotating the underlying mixing layers adds a little variety. Although, it's not\n    // completely necessary.\n    q = rot2(3.14159/4.)*p;\n    //float c = mix(grad1, grad2, smoothstep(.1, .9, n2D(q*vec2(8))));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, n2D(q*vec2(6)));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5);//smoothstep(.2, .8, n2D(q*8.))\n    \n    // The mixes above will work, but I wanted to use a subtle screen blend of grad1 and grad2.\n    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5;\n    float a1 = 1. - a2;\n    \n    // Screen blend.\n    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);\n    \n    // Smooth max\\min\n    //float c = smax(grad1*a1, grad2*a2, .5);\n   \n    return c;\n    \n    \n}\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\nfloat sand(vec2 p){\n    \n    // Rotating by 45 degrees. I thought it looked a little better this way. Not sure why.\n    // I've also zoomed in by a factor of 4.\n    p = vec2(p.y - p.x, p.x + p.y)*.7071/4.;\n    \n    // Sand layer 1.\n    float c1 = sandL(p);\n    \n    // Second layer.\n    // Rotate, then increase the frequency -- The latter is optional.\n    vec2 q = rot2(3.14159/12.)*p;\n    float c2 = sandL(q*1.25);\n    \n    // Mix the two layers with some underlying gradient noise.\n    c1 = mix(c1, c2, smoothstep(.1, .9, gradN2D(p*vec2(4))));\n    \n/*   \n\t// Optional screen blending of the layers. I preferred the mix method above.\n    float a2 = gradN2D(p*vec2(4));\n    float a1 = 1. - a2;\n    \n    // Screen blend.\n    c1 = 1. - (1. - c1*a1)*(1. - c2*a2);\n*/    \n    \n    // Extra grit. Not really necessary.\n    //c1 = .7 + fBm(p*128.)*.3;\n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took me far too long before it hit me. :)\n    return c1/(1. + gT*gT*.015);\n}\n\n/////////\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\n\n/*\n// Based on the triangle function that Shadertoy user Nimitz has used in various triangle noise \n// demonstrations. See Xyptonjtroz - Very cool.\n// https://www.shadertoy.com/view/4ts3z2\n// Anyway, these have been modified slightly to emulate the sin and cos waves.\nvec3 triS(in vec3 x){ return 1. - abs(fract(x/6.283185307 + .25) - .5)*4.; } // Triangle function.\nvec3 triC(in vec3 x){ return 1. - abs(fract(x/6.283185307 + .5) - .5)*4.; } // Triangle function.\nvec2 triS(in vec2 x){ return 1. - abs(fract(x/6.283185307 + .25) - .5)*4.; } // Triangle function.\nvec2 triC(in vec2 x){ return 1. - abs(fract(x/6.283185307 + .5) - .5)*4.; } // Triangle function.\nfloat triS(in float x){ return (1. - abs(fract(x/6.283185307 + .25) - .5)*4.); } // Triangle function.\nfloat triC(in float x){ return (1. - abs(fract(x/6.283185307 + .5) - .5)*4.); } // Triangle function.\n\n// Quantized version of the path below.\nvec2 path(in float z){ \n    //return vec2(0);\n    return vec2(triC(z*.18/1.)*2. - triS(z*.1/1.)*4., triS(z*.12/1.)*3. - 1.);\n}\n*/\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0);\n    return vec2(cos(z*.18/1.)*2. - sin(z*.1/1.)*4., sin(z*.12/1.)*3. - 1.);\n}\n\n\n// A 2D texture lookup: GPUs don't make it easy for you. If wrapping wasn't a concern,\n// you could get away with just one GPU-filtered filtered texel read. However, there\n// are seam line issues, which means you need to interpolate by hand, so to speak.\n// Thankfully, you can at least store the four neighboring values in one pixel channel,\n// so you're left with one texel read and some simple interpolation.\n//\n// By the way, I've included the standard noninterpolated option for comparisson.\nfloat txFace1(in samplerCube tx, in vec2 p){\n   \n    \n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    \n    #if 0\n    \n    // The standard noninterpolated option. It's faster, but doesn't look very nice.\n    // You could change the texture filtering to \"mipmap,\" but that introduces seam\n    // lines at the borders -- which is fine, if they're out of site, but not when you\n    // want to wrap things, which is almost always.\n    return texture(tx, vec3(.5, uv.y, -uv.x)).x; \n    \n    #else\n    \n    // Smooth 2D texture interpolation using just one lookup. The pixels and\n    // its three neighbors are stored in each channel, then interpolated using\n    // the usual methods -- similar to the way in which smooth 2D noise is\n    // created.\n    vec4 p4 = texture(tx, vec3(.5, uv.y, -uv.x)); \n\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n    \n    // Returning the average of the neighboring pixels, for curiosity sake.\n    // Yeah, not great. :)\n    //return dot(p4, vec4(.25));\n    \n    #endif\n/*   \n    // Four texture looks ups. I realized later that I could precalculate all four of \n    // these, pack them into the individual channels of one pixel, then read them\n    // all back in one hit, which is much faster.\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    vec4 x = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 0)+ .5)/cubemapRes) - .5;\n    vec4 y = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(0, 1)+ .5)/cubemapRes) - .5;\n    vec4 z = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 1)+ .5)/cubemapRes) - .5;\n    vec4 w = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n\n    return mix(mix(x, y, p.x), mix(z, w, p.x), p.y);\n*/  \n    \n}\n\n// 2D Surface function.\nfloat surfFunc2D(in vec3 p){\n    \n     return txFace1(iChannel0, p.xz/64.);\n}\n\n\n// The 3D surface function. This one converts the 3D position to a 3D voxel \n// position in the cubemap, then reads the isovalue. Actually, one option does\n// that, and the other is forced to read out eight neighboring values to \n// produce a smooth interpolated value. As in real life, it looks nicer, but \n// costs more. :)\nfloat txFace0(in vec3 p){\n    \n    #if 0\n    \n    // One sample... Ouch. :D It's a shame this doesn't work, because it's \n    // clearly faster. Unfortunately, it's virtually pointless from an aesthetic\n    // aspect, as you can see, but there'd be times when you could get away with it.\n    vec3 col = texMapCh(iChannel0, p).xyz;\n    \n    #else\n    \n    // Eight samples, for smooth interpolation. Still not as good as the real \n    // thing -- and by that, I mean, calculating on the fly. However, it's \n    // good enough. I'd need to think about it, but I'm wondering whether a\n    // four or five point tetrahedral interpolation would work? It makes my\n    // head hurt thinking about it right now, but it might. :)\n    vec3 col = texMapSmoothCh(iChannel0, p).xyz;\n    \n    #endif\n    \n    return col.x;\n    \n}\n\n\n// 3D surface function.\nfloat surfFunc3D(in vec3 p){ return txFace0(p/8.); }\n    \n\n// Tunnel cross sectional distance.\nfloat dist(in vec2 p){\n    \n    return length(p);\n    //p = abs(p);\n    //return max((p.x + p.y)*.7071, max(p.x, p.y));\n    \n}\n\n// Rock and object ID holders.\nint rID = 0;\nint svRID;\nvec2 vRID;\nvec2 svVRID;\n\n// The desert scene. Adding a heightmap to an XZ plane. Not a complicated distance function. :)\nfloat map(vec3 p){\n    \n    // Retrieve the 3D surface value. Note (in the function) that the 3D value has been \n    // normalized. That way, everything points toward the center.\n    float sf3D = surfFunc3D(p);\n    \n    // Retrieve the 2D surface value from another cube map face.\n    float sf2D = surfFunc2D(p);\n     \n    // Path function.\n    vec2 pth = path(p.z); \n\n    \n    // The tunnel itself.\n    float tun = 2. - dist((p.xy - pth)*vec2(.7, 1));\n\n    // Second tunnel --- Needs work, so not used here.\n    //tun = smax(tun, 2. - dist((p.xy - path(p.z*1.5 + .5)*1.35)), 4.);\n    \n    \n    // Terrain.\n    float ter = p.y + (.5 - sf2D)*4. - sf2D*2.75;\n \n    // Hollowing the tunnel out of the terrain.\n    ter = smax(ter, tun, 3.);\n     \n    // Adding a bit more of the 2D texture and 3D texture.\n    ter += (.5 - sf2D) +  (.5 - sf3D); \n\n    \n    // The sand layer upon which the sand pattern sits -- The \n    // sand pattern itself is added later via bump mapping.\n    float snd = p.y - pth.y - sf2D*2. + 2.65; \n\n    // Storing the terrain and sand layer distance for later usage.\n    vRID = vec2(ter, snd);\n\n    // Return the minimum distance.\n    return min(ter, snd);\n \n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<120; i++){\n    \n        h = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<.001*(t*.05 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += h*.85; \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved \n// make a difference. Also because of the random nature of the scene, the tetrahedral normal \n// has the same aesthetic effect as the regular - but more expensive - one, so it's an easy \n// decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n \n// Standard normal function. It's not as fast as the tetrahedral calculation, \n// but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\t\n    vec2 e = vec2(.001, 0); // .001*ef\n\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n  \n// Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n    \n    float n = 0.;\n    // Mixing the sand and rock normals at the borders.\n    float bordCol0Col1 = svVRID.x - svVRID.y;\n    const float bordW = .05;\n    \n    // Rocks.\n    if(svRID==0){\n        n = txFace0(p/8.);\n        n = mix(n, 1.-txFace0(p/2.), .25);\n        n = mix(n, txFace0(p*1.5), .1);\n        \n        n = mix(.5, n, smoothstep(0., bordW, -(bordCol0Col1)));\n    }\n    else{\n        \n        // Sand.\n        n = sand(p.xz*1.25);\n        n = mix(.5, n, smoothstep(0., bordW, (bordCol0Col1)));\n       \n/*       \n        // Sand pattern alternative.\n        p *= vec3(1.65, 2.2, 3.85)/1.25;\n        //float ns = n2D(p.xz)*.57 + n2D(p.xz*2.)*.28 + n2D(p.xz*4.)*.15;\n        float ns = n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n\n        // vec2 q = rot2(-3.14159/5.)*p.xz;\n        // float ns1 = grad(p.z*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n        // float ns2 = grad(q.y*32., 0.);//*clamp(p.y*5., 0., 1.);//smoothstep(0., .1, p.y);//\n        // ns = mix(ns1, ns2, ns);\n\n        ns = (1. - abs(smoothstep(0., 1., ns) - .5)*2.);\n        ns = mix(ns, smoothstep(0., 1., ns), .65);\n\n        // Use the height to taper off the sand edges, before returning.\n        //ns = ns*smoothstep(0., .2, p.y - .075);\n    \n\n        // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n        // formed in the distance. Simply lessen the value when it's further away. Most people would\n        // figure this out pretty quickly, but it took far too long before it hit me. :)\n        n = ns/(1. + gT*gT*.015);\n*/        \n        \n        \n    }\n    \n    \n    \n    \n    //return mix(min(n*n*2., 1.), surfFunc3D(p*2.), .35);\n    return n;//min(n*n*2., 1.);\n    \n    /*\n    // Obtaining some terrain samples in order to produce a gradient\n    // with which to distort the sand. Basically, it'll make it look\n    // like the underlying terrain it effecting the sand. The downside\n    // is the three extra taps per bump tap... Ouch. :) Actually, it's\n    // not that bad, but I might attempt to come up with a better way.\n    float n = txFace0(p);\n    vec3 px = p + vec3(.001, 0, 0);\n    float nx = txFace0(px);\n    vec3 pz = p + vec3(0, 0, .001);\n    float nz = txFace0(pz);\n    \n    // The wavy sand, that has been perturbed by the underlying terrain.\n    return sand(p.xz + vec2(n - nx, n - nz)/.001*1.);\n    */\n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n   \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */ \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.2/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .035, .5); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n \n// Standard sky routine: Gradient with sun and overhead cloud plane. I debated over whether to put more \n// effort in, but the dust is there and I'm saving cycles. I originally included sun flares, but wasn't \n// feeling it, so took them out. I might tweak them later, and see if I can make them work with the scene.\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld){ \n    \n    // Sky color gradients.\n    vec3 col = vec3(.8, .7, .5), col2 = vec3(.4, .6, .9);\n    \n    //return mix(col, col2, pow(max(rd.y*.5 + .9, 0.), 5.));  // Probably a little too simplistic. :)\n     \n    // Mix the gradients using the Y value of the unit direction ray. \n    vec3 sky = mix(col, col2, pow(max(rd.y + .15, 0.), .5));\n      \n    // Adding the sun.\n    float sun = clamp(dot(ld, rd), 0., 1.);\n    sky += vec3(1, .7, .4)*vec3(pow(sun, 16.))*.2; // Sun flare, of sorts.\n    sun = pow(sun, 32.); // Not sure how well GPUs handle really high powers, so I'm doing it in two steps.\n    sky += vec3(1.6, 1, .5)*vec3(pow(sun, 32.))*.35; // Sun.\n    \n     // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.15;\n    rd = normalize(rd);\n   \n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float t = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) sky =  mix(sky, vec3(2), smoothstep(.45, 1., fBm(1.5*uv/SC))*\n                        smoothstep(.45, .55, rd.y*.5 + .5)*.4);\n    \n    // Return the sky color.\n    return sky*vec3(1.1, 1, .9);\n}\n\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n// hash based 3d value noise\nvec4 hash41(vec4 p){\n    return fract(sin(mod(p, 6.2831589))*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41(mod(h, 6.2831)), hash41(mod(h + s.x, 6.2831)), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(in vec3 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n3D(p*3.)*.57 + n3D(p*7.)*.28 + n3D(p*15.)*.15;\n   \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.25, .115, .02), vec3(.35, .5, .65), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n3D(p*vec3(150., 150., 150.))*.5 + .5; \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.1), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n3D(p*8. + .5)*.7 + n3D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.     \n\tvec3 ro = vec3(0, 4.*0. - .5, iTime*5.); // Camera position, doubling as the ray origin.\n    vec3 lookAt = ro + vec3(0, -.2*0., .5);  // \"Look At\" position.\n    \n    //vec3 lp = vec3(0, 0, ro.z + 8.);\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(0, 0, ro.z) + vec3(FAR*.125, FAR*.35, FAR);\n\t\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n    //lp.xy += path(lp.z);\n \n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/32.)*rd.xy;\n    \n  \n\n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n    gT = t;\n    \n    svVRID = vRID;\n    svRID = vRID[0]<vRID[1]? 0 : 1;\n    \n   \n    // Sky. Only retrieving a single color this time.\n    //vec3 sky = getSky(rd);\n    \n    // The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = vec3(0);\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy postion outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y;//surfFunc(sp);// - path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal(sp, 1.); // Surface normal. //*(1. + t*.125)\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), 0.001);\n        ld /= lDist; // Normalize the light direct vector.\n        \n        lDist /= FAR; // Scaling down the distance to something workable for calculations.\n        float atten = 1./(1. + lDist*lDist*.025);\n\n        \n        // Texture scale factor.        \n        const float tSize = 1./8.;\n        \n        // Extra shading in the sand crevices.\n        float bSurf = bumpSurf3D(sp);\n        \n        vec3 oSn = sn;\n        \n        float bf = svRID == 0? .5 : .05;\n        sn = doBumpMap(sp, sn, bf);\n         \n        \n        // Soft shadows and occlusion.\n        float sh = softShadow(sp, lp, sn, 8.); \n        float ao = calcAO(sp, sn); // Amb, 6.ient occlusion.\n \n        \n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 32.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Dirt... or close enough.\n       \n        // Overal global ambience. Attempting to at apply some science to it, by using\n        // Blackle's more thought out ambient lighting, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //float amb = pow(length(sin(sn*2.)*.45 + .5)/sqrt(3.), 2.)*.25; // Studio.\n        float amb = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*smoothstep(-1.5, 1.5, sn.y)*.25; // Outdoor.\n \n        \n\n        // 3D surface function.\n        float sf3D = surfFunc3D(sp);\n        \n         \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp(mix(vec3(1.2, .75, .5)*vec3(1, .9, .8), vec3(.7, .5, .25), (sp.y - 1.)*.15), \n                vec3(.5, .25, .125), vec3(1));\n          \n        //col = min(vec3(1.2, .75, .5)*vec3(1, .9, .8), 1.);\n    \n         \n        // Setting the terrain color and sand color. \n        vec3 col0 = col, col1 = col;\n        \n        // Trick to mix things at the borders for a less brutal transition.\n        float bordCol0Col1 = svVRID.x - svVRID.y;\n        const float bordW = .1;\n        /*\n        if(svRID==0 || abs(bordCol0Col1)<bordW){\n \n            // Coloring the soil.\n        \tvec3 colR = mix(vec3(1, .8, .5), vec3(.5, .25, .125), clamp((sp.y + 2.)*.5, 0., 1.));\n        \tcol0 = mix(col0, colR, .5);\n            \n        }\n        */\n        \n        if(svRID==1 || abs(bordCol0Col1)<bordW){\n            col1 = mix(col1*vec3(1.5), vec3(1, .9, .8), .2);\n        }        \n        // Return the color, which is either the sandy terrain color, the object color,\n    \t// or if we're in the vicinity of both, make it a mixture of the two.\n    \tcol = mix(col0, col1, smoothstep(-bordW, bordW, bordCol0Col1));\n        \n         \n       \n        // Finer details.\n        col = mix(col*vec3(1.05, 1, 1.2)/4., col, smoothstep(0., 1., sf3D));\n        col = mix(col/1.35, col*1.35, bSurf);\n        \n        // Grungey overlay: Add more to the rock surface than the sand.\n        // Surface texel.\n        vec3 tx = GrungeTex(sp/4.);//*vec3(1.2, 1.15, 1.05);//\n        col = mix(col, col*tx*3., mix(.5, .25, smoothstep(-bordW, bordW, bordCol0Col1))); \n        \n        \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        vec3 refSky = getSky(sp, reflect(rd, sn), ld);\n        col += col*refSky*.05 + refSky*fre*fre2*.15; \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = col*(dif*sh + amb + vec3(1, .97, .92)*spe*fre2*sh);\n        \n        \n        \n        \n \n        // Applying the shadows and ambient occlusion.\n        col = col*ao*atten;\n \n    }\n    \n  \n    // Combine the scene with the sky using some cheap volumetric substance.\n    vec3 gLD = normalize(lp - vec3(0, 0, ro.z));\n    vec3 sky = getSky(ro, rd, gLD);\n    \n    // Simulating sun scatter over the sky and terrain: IQ uses it in his Elevated example.\n    sky += vec3(1., .6, .2)*pow(max(dot(rd, gLD), 0.), 16.)*.25;\n    sky = min(sky, 1.);\n    \n    //col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    col = mix(col, sky, smoothstep(0., .99, t/FAR)); // Linear fade. Much dustier. I kind of like it.\n    \n    \n    // Greyish tone.\n    //col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5);\n    \n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col = min(col, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n\n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace0(vec3 p){\n   \n    \n    //vec3 pix = vec3(1./4./dims.x, 0, 0);\n    vec3 pix = vec3(1./1./dims.x, 0, 0);\n \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n        \n        vec3 q = p + vec3(0, i&1, i>>1)/dims.x;\n        \n        vec3 rotF = vec3(0); // Rotation factor - Range: [0, 1].\n        \n        // Wrapped multilayer tertiary order Voronoi.\n        gSc = vec3(4);\n        vec3 sc = vec3(1, 1, 1);\n        vec3 v = Voronoi(q*gSc, sc, rotF, 1./1., 1);\n        float res = max(1.-v.x, 0.);// mix(max(1. - v.x, 0.), (v.y - v.x), .0);\n        gSc = vec3(8);\n        sc = vec3(1, 1, 1);\n        v = Voronoi((q - .0)*gSc, sc, rotF, 1., 1);\n        res = mix(res, 1. - max(1. - v.x, 0.), .125); \n        //res = min(res, max((1. - v.x)/2., 0.));\n        gSc = vec3(16);\n        sc = vec3(1, 1, 1);\n        rotF = vec3(1);\n        v = Voronoi((q - .0)*gSc, sc, rotF, 1., 1);\n        res = mix(res, max(v.y - v.x, 0.), .0625); \n        \n    \n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        col[i] = res;//max(1. - res*.85 - res*res*.15, 0.);\n         \n        //p += pix;\n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace1(vec2 uv){\n    \n    // It's a 2D conversion, but we're using a 3D function with constant Z value.\n    vec3 p;\n    // Just choose any Z value you like. You could actually set \"p.z\" to any constant,\n    // or whatever, but I'm keeping things consistant.\n    p.z = floor(.0*cubemapRes.x)/cubemapRes.x; \n       \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n\n        // Since we're performing our own 2D interpolation, it makes sense to store\n        // neighboring values in the other pixel channels. It makes things slightly\n        // more confusing, but saves four texel lookups -- usually in the middel of\n        // a raymarching loop -- later on.\n        \n        // The neighboring position for each pixel channel.\n        p.xy = mod(floor(uv*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n\n        // Individual Voronoi cell scaling.\n        vec3 sc = vec3(1);\n        vec3 rotF = vec3(0); // Rotation factor.\n        \n        // Put whatever function you want here. In this case, it's Voronoi.\n        gSc = vec3(8);\n        vec3 v = Voronoi(p*gSc, sc, rotF, 1., 0);\n        float res = 1. - v.x;\n        //gSc = vec3(16);\n        //v = Voronoi(p*gSc, sc, rotF, 1., 1);\n        //res = mix(res, v.y - v.x, .333);\n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        \n        // Layering in some noise as well. This is all precalculated, so speed isn't\n        // the primary concern... Compiler time still needs to be considered though.\n        gSc = vec3(4);\n        float res2 = n3DT(p*gSc);\n        gSc = vec3(8);\n        res2 = mix(res2, n3DT(p*gSc), .333);\n        gSc = vec3(16);\n        res2 = mix(res2, n3DT(p*gSc), .333);\n        //gSc = vec3(16);\n        //res2 = mix(res2, n3DT(p*gSc), .333);\n        \n        // Mix in the Voronoi and the noise.\n        col[i] =  mix(res, res2, .5);\n\n    }\n    \n    return col;\n}\n\n// Converting your UV coordinates to 3D coordinates. I've seen some pretty longwinded\n// obfuscated conversions out there, but it shouldn't require anything more than \n// the following. By the way, the figure \"dims.x\" is factored down by four to account\n// for the four pixel channels being utilized, but the logic is the same.\nvec3 convert2DTo3D(vec2 uv){\n    \n    // Converting the fract(uv) coordinates from the zero to one range to the whole\n    // number, zero to... 1023 range.\n    uv = floor(uv*cubemapRes);\n    \n    // Converting the UV coordinate to a linear representation. The idea is to convert the\n    // 2D UV coordinates to a linear value, then use that to represent the 3D coordinates.\n    // This way, you can effectively fit all kinds of 3D dimensions into a 2D texture array\n    // without having to concern yourself with 2D texture wrapping issues. In theory, so \n    // long as the dimensions fit, and the X dimension is a multiple of four, then anything\n    // goes. As mentioned, the maximum cubic dimension allowable for one cube face is \n    // 160 cubed. In that respect, rectangular dimensions, like vec3(160, 80, 320), etc, \n    // would also fit.\n    //\n    // For instance, the 137th pixel in the third row on a 1024 by 1024 cubemap face texture \n    // would be the number 2185 (2*1024 + 137).\n    float iPos = dot(uv, vec2(1, cubemapRes.x));\n    \n    // In this case the XY slices comprise of 160 pixels (or whatever number we choose) along \n    // X and Y, so the pixel position in any block would be modulo 160*160. The xyBlock position \n    // would have to be converted to X and Y positions, which would be xyBlock mod dimX, and \n    // floor(xyBlock/dimX) mod dimY respectively. The Z position would depend on how many \n    // 160 by 160 blocks deep we're in, which translates to floor(iPos/(dimX*dimY)).\n    //\n    // Anyway, that's what the following lines represent.\n    \n    // XY block (or slice) linear position.\n    float xyBlock = mod(iPos, dims.x*dims.y);\n    \n    // Converting to X, Y and Z position.\n    vec3 p = vec3(mod(floor(vec3(xyBlock, xyBlock, iPos)/vec3(1, dims.x, dims.x*dims.y)), dims));\n    \n    //vec3 p = vec3(mod(xySlice, dims.x), mod(floor((xySlice)/dims.x), dims.y),\n                  //floor((iPos)/(dims.x*dims.y)));\n    \n    // It's not necessary, but I'm converting the 3D coordinates back to the zero to one\n    // range... There'd be nothing stopping you from centralizing things (p/dims - .5), but \n    // this will do.\n    return p/dims;\n}\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    // Pixel storage.\n    vec4 col;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n        \n        // This is part of an ugly hack that attempts to force the GPU compiler\n        // to not unroll the Voronoi loops. Not sure if it'll work, but I'm \n        // trying it anyway, in the hope to get compiler times down on some\n        // machines. For the record, this takes about 3 seconds to compile on \n        // my machine.\n        gIFrame = iFrame;\n        \n        \n        /*\n        // Debug information for testing individual cubeface access.\n        if(faceID==0) col = vec4(0, 1, 0, 1);\n        else if(faceID==1) col = vec4(0, .5, 1, 1);\n        else if(faceID==2) col = vec4(1, 1, 0, 1);\n        else if(faceID==3) col = vec4(1, 0, 0, 1);\n        else if(faceID==4) col = vec4(.5, .5, .5, 1);\n        else col = vec4(1, 1, 1, 1);\n        */\n        \n        \n        // Fill the first cube face with a custum 3D function.\n        if(faceID==0){\n            \n            vec3 p = convert2DTo3D(uv);\n            \n            col = funcFace0(p);\n           \n        }\n        \n        // Fill the second cube face with a custom 2D function... We're actually\n        // reusing a 3D function, but it's in slice form, which essentially makes\n        // it a 2D function.\n        if(faceID==1){\n\n            col = funcFace1(uv);\n            \n        }\n        \n        \n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    else {\n        \t\n        // The cube faces have already been initialized with values, so from this point,\n        // read the values out... There's probably a way to bypass this by using the \n        // \"discard\" operation, but this isn't too expensive, so I'll leave it for now.\n        col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n// If you use all four channels of one 1024 by 1024 cube face, that would be\n// 4096000 storage slots (1024*1024*4), which just so happens be 160 cubed.\n// In other words, you can store the isosurface values of a 160 voxel per side\n// cube into one cube face of the cubemap.\n//\n// The voxel cube dimensions: That's the one you'd change, but I don't really\n// see the point, since setting it to the maximum resolution makes the most\n// sense. For demonstrative purposes, dropping it to say, vec3(80), will show\n// how a decrease in resolution will affect things. Increasing it to above the\n// allowable resolution (for one cube face) to say, vec3(200), will display the\n// wrapping issues.\n//\n// On a side note, I'm going to put up an example later that uses four of the \n// cubemap faces, which should boost the resolution to 256... and hopefully,\n// not add too much to the complexity, and consequent lag that would follow.\nconst vec3 dimsVox = vec3(100); \nconst vec3 scale = vec3(1, 1, 1);\nconst vec3 dims = dimsVox/scale;\n\n\n\n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n\n\nvec4 texMapCh(samplerCube tx, vec3 p){\n    \n    p *= dims;\n    int ch = (int(p.x*4.)&3);\n    p = mod(floor(p), dims);\n    float offset = dot(p, vec3(1, dims.x, dims.x*dims.y));\n    vec2 uv = mod(floor(offset/vec2(1, cubemapRes.x)), cubemapRes);\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    uv = fract((uv + .5)/cubemapRes) - .5;\n    return vec4(1)*texture(tx, vec3(-.5, uv.yx))[ch];\n    \n}\n\n// Used in conjunction with the function below. When doing things eight times over, any \n// saving is important. If I could trim this down more, I would, but there's wrapping\n// and pixel snapping to consider. Having said that, I might take another look at it,\n// at some stage.\nvec4 txChSm(samplerCube tx, in vec3 p){\n   \n    p = mod(floor(p), dims);\n    //vec2 uv = mod(floor(dot(p, vec3(1, dims.x, dims.x*dims.y))/vec2(1, cubemapRes.x)), cubemapRes);\n    vec2 uv = floor(dot(p, vec3(1, dims.x, dims.x*dims.y))/vec2(1, cubemapRes.x));\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably... definitely not doing this. :)\n    uv = fract((uv + .5)/cubemapRes) - .5;\n    return texture(tx, vec3(-.5, uv.yx));\n    \n}\n\n// Smooth texture interpolation that access individual channels: You really need this -- I \n// wish you didn't, but you do. I wrote it a while ago, and I'm pretty confident that it works. \n// The smoothing factor isn't helpful at all, which surprises me -- I'm guessing it molds things \n// to the shape of a cube. Anyway, it's written in the same way that you'd write any cubic \n// interpolation: 8 corners, then a linear interpolation using the corners as boundaries.\n//\n// It's possible to use more sophisticated techniques to achieve better smoothing, but as you \n// could imagine, they require more samples, and are more expensive, so you'd have to think about \n// it before heading in that direction -- Perhaps for texturing and bump mapping.\nvec4 texMapSmoothCh(samplerCube tx, vec3 p){\n\n    // Voxel corner helper vector.\n\t//const vec3 e = vec3(0, 1, 1./4.);\n\tconst vec2 e = vec2(0, 1);\n\n    // Technically, this will center things, but it's relative, and not necessary here.\n    //p -= .5/dimsVox.x;\n    \n    p *= dimsVox;\n    vec3 ip = floor(p);\n    p -= ip;\n\n    \n    //int ch = (int(ip.x)&3), chNxt = ((ch + 1)&3);  //int(mod(ip.x, 4.))\n    //ip.x /= 4.;\n/*\n    float c = mix(mix(mix(txChSm(tx, ip + e.xxx, ch).x, txChSm(tx, ip + e.yxx, chNxt).x, p.x),\n                     mix(txChSm(tx, ip + e.xyx, ch).x, txChSm(tx, ip + e.yyx, chNxt).x, p.x), p.y),\n                 mix(mix(txChSm(tx, ip + e.xxy, ch).x, txChSm(tx, ip + e.yxy, chNxt).x, p.x),\n                     mix(txChSm(tx, ip + e.xyy, ch).x, txChSm(tx, ip + e.yyy, chNxt).x, p.x), p.y), p.z);\n*/\n    \n     vec4 txA = txChSm(tx, ip + e.xxx);\n     vec4 txB = txChSm(tx, ip + e.yxx);\n\n     float c = mix(mix(mix(txA.x, txB.x, p.x), mix(txA.y, txB.y, p.x), p.y),\n                   mix(mix(txA.z, txB.z, p.x), mix(txA.w, txB.w, p.x), p.y), p.z);\n\n \n \t/*   \n    // For fun, I tried a straight up average. It didn't work. :)\n    vec4 c = (txChSm(tx, ip + e.xxx*sc, ch) + txChSm(tx, ip + e.yxx*sc, chNxt) +\n             txChSm(tx, ip + e.xyx*sc, ch) + txChSm(tx, ip + e.yyx*sc, chNxt) +\n             txChSm(tx, ip + e.xxy*sc, ch) + txChSm(tx, ip + e.yxy*sc, chNxt) +\n             txChSm(tx, ip + e.xyy*sc, ch) + txChSm(tx, ip + e.yyy*sc, chNxt) + txChSm(tx, ip + e.yyy*.5, ch))/9.;\n \t*/\n    \n    return vec4(c);\n\n}\n\n\n\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nvec3 gSc;\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n\n// 3x1 hash function.\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(21.71, 157.97, 113.43)))*45758.5453); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    return fract(sin(mod(dot(p, vec2(27.609, 157.583)), 6.2831589))*43758.5453); \n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n// smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)/k;\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n    \n    p = mod(p, gSc);\n\tp = fract(p * vec3(.10313, .10307, .09731));\n    p += dot(p, p.yxz + 19.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n   \n    /*\n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n    */\n\n}\n\n/*\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33(vec3 p){ \n   \n    \n    p = mod(p, gSc);\n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = rot2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    float n = sin(dot(p, vec3(57, 113, 27)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;  \n\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*6.2831853 + iTime)*.5; \n}\n*/\n\n// hash based 3d value noise\nvec4 hash41T(vec4 p){\n    p = mod(p, vec4(gSc, gSc));\n    return fract(sin(mod(p, 6.2831589))*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// David_Hoskins puts together some pretty reliable hash functions. This is \n// his unsigned integer based vec3 to vec3 version.\nvec3 hash33(vec3 p)\n{\n    p = mod(p, gSc);\n\tuvec3 q = uvec3(ivec3(p))*uvec3(1597334673U, 3812015801U, 2798796415U);\n\tq = (q.x ^ q.y ^ q.z)*uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn -1. + 2. * vec3(q) * (1. / float(0xffffffffU));\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .002;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n//\n//\nvec3 cellID;\nint gIFrame;\n\nivec4 gID;\n\n// Distance metric: Put whatever you want here.\nfloat distMetric(vec3 p, vec3 b, int id){\n    \n    \n    if(id==0){\n    \treturn (dot(p, p));///2.; // Sphere squared.\n    }\n    else {\n        \n        //float d2 = sBoxS(p.xy, b.xy, 0.);\n        float d2 = sdHexagon(p.xy, min(b.x, b.y));\n        return opExtrusion(d2, p.z, b.z);\n\n        \n        //return (dot(p, p));\n        //return length(p); // Standard spherical Euclidean distance.\n\n        //return max(max(length(p.xy), length(p.yz)), length(p.xz)); // Cylinder cross.\n\n        //p = max(abs(p)*.8660254 + p.yzx*.5, -p);\n        //return max(max(p.x, p.y), p.z); // Triangular.\n\n        // Uncomment this for all metrics below.\n        p = abs(p) - b;\n        \n        \n        //p = (p + p.yzx)*.7071;\n        //return max(max(p.x, p.y), p.z); // Can't remember -- Diamond related. :)\n\n\n        return max(max(p.x, p.y), p.z); // Cube.\n        //return (p.x + p.y + p.z)*.5;//7735; // Octahedron.\n\n        //p = p*.8660254 + p.yzx*.5;\n        //return max(max(p.x, p.y), p.z); // Hex.\n\n/*        \n        float taper = (p.x + p.y + p.z)/3.*2.*.65 + .35; // Linear gradient of sorts.\n        //float taper = p.y + .5; // Original.\n        //taper = mix(taper, max(taper, .5), .35); // Flattening the sharp edge a bit.\n\n        p = abs(p)*2.;\n        //p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; // Used with triangle.\n\n        float shape = max(max(p.x, p.y), p.z); // Square.\n        //float shape = max(p.x*.866025 - p.y*.5, p.y); // Triangle.\n        //float shape = max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n        //float shape = max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.\n        //float shape = length(p); // Circle.\n        //float shape = dot(p, p); // Circle squared.\n\n\n        //shape = (shape - .125)/(1. - .125);\n        //shape = smoothstep(0., 1., shape);\n\n\n        //return shape;\n        return max(shape, taper);\n*/\n    }\n    \n}\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if\" statements.\n//\nvec3 Voronoi(in vec3 q, in vec3 sc, in vec3 rotF, float offsF, int id){\n    \n    \n\t//const vec3 sc = vec3(1, 2, 1);\n    gSc /= sc;\n \tvec3 d = vec3(1e5); // 1.4, etc.\n    \n    float r;\n    \n    // Widen or tighten the grid coverage, depending on the situation. Note the huge (5x5x5 tap) \n    // spread. That's to cover the third order distances. In a lot of cases, (3x3x3) is enough,\n    // but in some, 64 taps (4x4x4), or even more, might be necessary.\n    //\n    // Either way, this is fine for static imagery, but needs to be reined in for realtime use.\n    for(int z = -2; z <= 2; z++){ \n        for(int y = -2; y <= 2; y++){ \n            for(int x =-2; x <= 2; x++){\n\n                vec3 cntr = vec3(x, y, z) - .5;\n                vec3 p = q;\n\t\t\t\tvec3 ip = floor(p/sc) + .5; \n                p -= (ip + cntr)*sc;\n                ip += cntr;\n                \n                // Random position and rotation vectors.\n                vec3 rndP = hash33(ip);\n                vec3 rndR = hash33(ip + 3.)*6.2831*rotF;\n\n                // Rotate.\n                p = rot(rndR)*p;\n                //p.xy *= rot2(rndR.x);\n                //p.yz *= rot2(rndR.y);\n                //p.zx *= rot2(rndR.z);\n               \n                // Postional offset.\n                p -= rndP*offsF*sc;\n                \n                \n                // Scale -- Redundant here.\n\t\t\t\tvec3 b = sc/2.*vec3(1, 1, 1.5);\n                // Distance metric.\n                r = distMetric(p, b, id);\n\n                // 1st, 2nd and 3rd nearest distance metrics.\n                d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n                d.y = max(d.x, min(d.y, r)); // 2nd.\n                d.x = min(d.x, r);//smin(d.x, r, .2); // Closest.\n                \n                // Redundant break in an attempt to ensure no unrolling.\n                // No idea whether it works or not.\n                if(d.x>1e5) break; \n\n            }\n        }\n    }\n\n    \n    return min(d, 1.);\n    \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3115, 3357, 3377, 3377, 3724], [3726, 4024, 4049, 4141, 5595], [5597, 5620, 5641, 5641, 5720], [5724, 5993, 6012, 6012, 6261], [6268, 6577, 6609, 6755, 7319], [7321, 7426, 7446, 7470, 9033], [9401, 9401, 9420, 9561, 10568], [11725, 11828, 11850, 11873, 11951], [11954, 12451, 12495, 12495, 14233], [14235, 14259, 14287, 14287, 14336], [14339, 14665, 14690, 14690, 15480], [15483, 15507, 15535, 15535, 15559], [15566, 15602, 15624, 15624, 15728], [15810, 15906, 15924, 16084, 17086], [17090, 17111, 17147, 17147, 17586], [18947, 18974, 19003, 19003, 21381], [21383, 21574, 21631, 21732, 22717], [22721, 22873, 22909, 22909, 23157], [23159, 23350, 23402, 23519, 24838], [24842, 25159, 25198, 25232, 26532], [26536, 26562, 26594, 26594, 26658], [26660, 26689, 26709, 26709, 26764], [26766, 26834, 26852, 26852, 27197], [27199, 27459, 27485, 27558, 28310], [28315, 28315, 28371, 28400, 36241]], "test": "untested"}
{"id": "3d3fRr", "name": "Fab31 #inktober2020 \"crawl\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nRef image: [url] https://www.youtube.com/watch?v=UVNpc9tM2LQ [/url]", "tags": ["2d", "short", "reproduction", "inktober2020"], "likes": 14, "viewed": 371, "published": 3, "date": "1604141922", "time_retrieved": "2024-07-30T20:37:22.325691", "image_code": "// maths: tried hard, ...  https://www.desmos.com/calculator/pixe2ayhtt\n//    ... finally opted for simple: https://www.desmos.com/calculator/nyhvir7uj2\n\nfloat line(vec2 p, vec2 a,vec2 b) {                              // https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;  \n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );\n}\n\n#define M(v)   d = min(d, line(U,p,p+v)), p+=v;                  // move pencil by v\n#define S(v)   smoothstep( 3./R.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y, c, p;\n    float t = 4.*iTime, L = 1.,                                  // L: worm arc-length\n          a = .5+.5*(.5+.5*cos(t)), l = a*L,                     // l: worm projected length\n          g = l/2.-L/4., A = L/2.*sqrt(a-a*a),                   // (g,±A) = sloppy worm segment\n          r = 1.2*R.x/R.y,\n          d = L;\n    c = vec2( L/8. ,0 );\n    p = vec2( mod(   L/2.* ceil(t/6.2832),2.15*r ) -r            // by-cycle advance\n                  + ( sin(t)>0.?-l:-L/2. ) , -.5 );              // in-cycle advance\n    \n    M(c) M(vec2(g,A)) M(c) M(vec2(g,-A)) M(c)                    // draw body: 5 segments\n        \n    O = U.y < p.y ? texture(iChannel0, U) : vec4(.8,1,.8,1);     // background\n    O = mix( O*(U*U).y,  vec4( 0,.5,0,1), S(abs(d)-.05) );       // compose body on background\n    \n    t = sin(t);                                                  // draw eyes\n#define E \\\n        g = S(length( ( U -p-vec2(0,.04) ) * vec2(1.5,1) ) - .04 );        \\\n        a = S(length( U -p -.03* vec2(max(.0,t), 2.-.5*abs(t) ) ) - .01 ); \\\n        O = mix(O, vec4(1.-a) ,g);\n    E \n    p -= .01*vec2(3,1); E\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 189, 259, 349]], "test": "untested"}
{"id": "tsVyDt", "name": "Asanoha", "author": "Catzpaw", "description": "Asanoha pattern", "tags": ["texture", "pattern"], "likes": 7, "viewed": 415, "published": 3, "date": "1604135666", "time_retrieved": "2024-07-30T20:37:23.337985", "image_code": "//---Asanoha\n// by Catzpaw 2020\n\n//UDF\nfloat udSegment(vec2 p,vec2 a,vec2 b){\n    p-=a,b-=a;return length(p-b*clamp(dot(p,b)/dot(b,b),0.,1.));\n}\nfloat udAsanoha(vec2 p){\n    const float SR3=sqrt(3.);\n    const vec2 p0=vec2(    0.,.0),\n               p1=vec2(    0.,.5),\n               p2=vec2(SR3/6.,.5),\n               p3=vec2(SR3/2.,.5),\n               p4=vec2(SR3/2.,.0),\n               p5=vec2(SR3/3.,.0);\n    p=abs(mod(p,vec2(SR3,1))-p3);\n    return min(udSegment(p,p0,p1),\n           min(udSegment(p,p0,p2),\n           min(udSegment(p,p2,p3),\n           min(udSegment(p,p0,p3),\n           min(udSegment(p,p3,p4),\n           min(udSegment(p,p3,p5),\n               udSegment(p,p5,p0)))))));\n}\n\n//TEXTURE\nconst vec3 C1=vec3(0.4, 0.1, 0.2),\n           C2=vec3(1.0, 0.6, 0.7);\nvec4 txAsanoha(vec2 uv,float bold){\n    return vec4(mix(C1,C2,smoothstep(.005*bold,.03*bold,udAsanoha(uv))),1);\n}\n\n//MAIN\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 p=uv*rot(sin(iTime*.02)*13.);\n    float s=7.+sin(iTime*.17)*4.;\n    fragColor=txAsanoha(p*s,log(s)*.5);\n    fragColor.xyz*=1.-smoothstep(.2,1.3,length(uv));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 39, 77, 77, 144], [145, 145, 169, 169, 696], [778, 778, 813, 813, 891], [893, 900, 918, 918, 965], [966, 966, 1019, 1019, 1247]], "test": "untested"}
{"id": "3s3Bzn", "name": "Broken chains", "author": "jarble", "description": "This fractal resembles a rusted or corroded chain-like structure.", "tags": ["fractal", "chain", "bones"], "likes": 5, "viewed": 363, "published": 3, "date": "1604113752", "time_retrieved": "2024-07-30T20:37:24.316369", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)+cos(p))-.6);\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result = sceneSDF1(p);\n    for(float i = 3.0; i < 81.0; i *= -3.0){\n        result = min(result, sceneSDF1(p/i)*i);\n    }\n    return -result;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 50.0;\n    return sin(vec3(sceneSDF1(p/7.0),sceneSDF1(p/11.0),sceneSDF1(p/13.0)));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Bzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 422, 447, 447, 492], [494, 494, 517, 517, 668], [670, 670, 698, 698, 791], [793, 1214, 1305, 1305, 1611], [1626, 1880, 1945, 1945, 2077], [2079, 2168, 2197, 2197, 2507], [2509, 3001, 3141, 3141, 3731], [3733, 4103, 4188, 4188, 4946], [4948, 5275, 5324, 5359, 5490], [5492, 5492, 5549, 5549, 6409]], "test": "untested"}
{"id": "3d3BRn", "name": "Distorted Checkerboard", "author": "tombla", "description": "A simple checkerboard distorted by sine.", "tags": ["2d", "checkerboard"], "likes": 13, "viewed": 386, "published": 3, "date": "1604098277", "time_retrieved": "2024-07-30T20:37:25.158118", "image_code": "#define R                       (iResolution.xy)\n#define MR                      min(R.x, R.y)\n#define VERTICAL_CHECKERS       22.\n#define CHECKERS_DIFF           6.5\n// Suggestion from FabriceNeyret2:\n#define CHECKER_BORDER\t        (1.7 * VERTICAL_CHECKERS / MR)\n#define S(B, v)                 smoothstep(B, 0., min(v.x, v.y))\n#define BORDER_COLOR            vec3(0.1, 0.1, 0.1)\n\n#define ANGULAR_SPEED 0.2\n#define ANGULAR_ADD   0.5\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),\n                             6.0) -3.0 ) -1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 rot(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 toCheckers(in vec2 p) {\n    // Distort\n    p += 0.05 * sin(p *12.);\n    // Tiles\n    p *= VERTICAL_CHECKERS + CHECKERS_DIFF * sin(iTime);\n    p *= rot(iTime * ANGULAR_SPEED + sin(iTime * ANGULAR_ADD));\n    \n    return vec4(\n        fract(p.x),\n        fract(p.y),\n        floor(p.x),\n        floor(p.y));\n}\n\nvoid mainImage(out vec4 O, in vec2 u) {\n    // Normalize to -0.5 ... 0.5 on the shorter axis.\n    u = (u - 0.5 * R) / MR;\n    vec4 c = toCheckers(u);\n    \n    // Simplification of:\n    //   float lb = smoothstep(CHECKER_BORDER, 0.0, min(c.x, c.y));\n    //   float ur = smoothstep(1.0 - CHECKER_BORDER, 1.0, max(c.x, c.y));\n    //   float borderFactor = max(lb, ur);\n    // Suggestion from FabriceNeyret2:\n    float borderFactor = S(CHECKER_BORDER, min(c.xy, 1. - c.xy));\n    // light or dark?\n    float isLight = mod(c.z + c.w, 2.);\n    // Inner color\n    vec3 innerColor = hsb2rgb(vec3(\n        mod((c.z + c.w + iTime * 4.)/22., 3.),\n        smoothstep(-1.6, 1., sin((c.z + c.w) / 12.1 + iTime * 1.3)),\n        .7 + 0.3 * sin(c.z - c.w + iTime * 3.7)));\n    \n    O = vec4(\n        mix(innerColor, BORDER_COLOR, borderFactor),\n        1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 509, 534, 534, 781], [783, 783, 805, 805, 881], [883, 883, 911, 926, 1194], [1196, 1196, 1235, 1289, 2038]], "test": "untested"}
{"id": "tsVcDt", "name": "Spooky Nebula", "author": "Zi7ar21", "description": "POV: It is a Friday (the day before Halloween) and you are struck inside the last period of school and have literally nothing else to do because you are done. Was gonna enable shading but the school computer couldn't compile it in the required 2 seconds.", "tags": ["raymarch", "dither", "volumetric", "volumetric", "raymarcher", "nebula", "halloween", "spooky", "slow", "multipass", "nonrealtime"], "likes": 5, "viewed": 428, "published": 3, "date": "1604089953", "time_retrieved": "2024-07-30T20:37:26.027793", "image_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// Buffer A is Rendering and Settings\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Spooky Nebula --- October 30th, 2020\n// Happy Halloween!\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tsVcDt\n// Fork of \"Starry Nebula\" by Zi7ar21. https://www.shadertoy.com/view/tsGyRm\n// October 10th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- 2020-09-08 19:37:55\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- 2020-10-11\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// This is for Rendering and Settings\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 64\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 6.0\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 12\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.1\n\n// Camera's FOV\n#define FOV 2.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n//#define ROTATION_MATRIX\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again.\n#define DENSITY 0.25\n\n// Tiles, more means easier on the Hardware\n#if HW_PERFORMANCE==0\n#define TILES 15\n#else\n#define TILES 5 // Set to 1 if you have a computer that can handle it so it will render faster\n#endif          // (most shouldn't time out, except for like Intel HD Graphics)\n// So kindly made by LoicVDB uwu\n\n// Amount of distortion to apply\n#define DISTORT_AMOUNT 2.5\n\n// Oof ugly mess below watch out lol\n\nbool isKeyPressed(int KEY){\n    return texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\n// ##### NOISE #####\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// 2D Noise for Dithering\nfloat hash13(vec3 p3){\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < NUM_OCTAVES; ++i){\n        v += a * noise(x);\n        x = x * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Colors\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float mainnoise = fbm(raypos+(fbm(raypos+vec3(1.0, 0.0, 0.0))*DISTORT_AMOUNT));\n    float subnoise = fbm(raypos+vec3(1.0, 0.0, 0.0));\n    float density = clamp(((mainnoise*12.0)-(subnoise*8.0))-pow(distance(vec3(0.0),raypos),2.0), 0.0, 1.0);\n    vec3 rgb = hsv2rgb(rgb2hsv(vec3(density))+vec3((mainnoise/1.35)+0.6, 0.85, 0.0));\n    return rgb;\n}\n\n// ##### RAYMARCHING #####\n\n/*vec3 directLight(vec3 raypos){\n    vec3 LightColor = vec3(1.0);\n    vec3 LightDirection = normalize(vec3(0.5));\n    float distorigin=0.0;\n    vec3 density=vec3(0.0);\n    vec3 raydirmod = LightDirection;\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<4; i++) {\n        raypos = raypos + raydirmod;\n        density = nebulanoise(raypos)*DENSITY*2.0;\n        vec3 absorbance = exp(-hsv2rgb(rgb2hsv(density)+vec3(0.5, 0.0, 0.0)));\n        attenuation *= absorbance;\n    }\n    return LightColor*attenuation;\n}*/\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin=0.0;\n    vec3 densityadd=vec3(0.0);\n    vec3 density=vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = (raydir*(hash13(vec3(coord, iFrame))+1.0))*STEP_SIZE;\n    vec3 outCol = vec3(0.);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++) {\n        raypos = raypos + raydirmod;\n        densityadd = nebulanoise(raypos)*DENSITY;\n        density = vec3(density+densityadd);\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.-absorbance;\n        outCol += attenuation * transmittance; //* directLight(raypos); // For now we'll just consider that the\n        attenuation *= absorbance;                                    // volume recieves light in all cases\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol+vec3(texture(iChannel1, coord/iResolution.xy))*attenuation;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Camera Orientation\n    //vec3 camerapos = vec3((iMouse.x/iResolution.x)-0.5, (iMouse.y/iResolution.y)-0.5, -3.0);\n    vec3 camerapos = vec3(0.0, 0.0, -4.0);\n    #ifdef ROTATION_MATRIX\n        // Torture courtesey of Michael0884, Can someone make the Z axis \"up\" like in Blender\n        float xrot = 0.0;\n        float yrot = 0.0;\n        float zrot = 0.0;\n        vec3 xdir = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n        vec3 ydir = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),\n                         cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n        vec3 zdir = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),\n                         sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n    \n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    \n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    vec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // LoicVDB: add the color and increase the sample count\n    fragColor += vec4(raymarched, 1.0);\n    if(isKeyPressed(32)){\n        fragColor.rgba = vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(acesFilm(color), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Star Background\n// This is to render stars\n\n// Blackbody Coloration from http://glslsandbox.com/e#40525.0\nvec3 blackbody(float Temp){\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n    col.y = 100.04 * log(Temp) - 623.6;\n    if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n        col.z = 194.18 * log(Temp) - 1448.6;\n        col = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n        return col;\n}\n\n// Noise\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4((vec3(clamp(hash12(fragCoord)-0.95, 0.0, 1.0))*blackbody((hash12(fragCoord)-0.99)*1000000.0))*(hash12(fragCoord*2.0)*8.0), 1.0);\n}", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1038, 1038, 1094, 1144, 1251]], "test": "untested"}
{"id": "wdVcDt", "name": "Hexagon SDF Study 3", "author": "bunnybones", "description": "Based on the really excellent shader https://www.shadertoy.com/view/Md2GDz by tnlogy", "tags": ["hexagonsdf"], "likes": 3, "viewed": 448, "published": 3, "date": "1604087255", "time_retrieved": "2024-07-30T20:37:26.857574", "image_code": "uniform float time;\nuniform float resolution ;\n\nfloat hexSdf(vec2 p) {\n        p.x *= 0.57735*2.0;\n        p.y += mod(floor(p.x), 2.0)*0.5;\n        p = abs((mod(p, 1.0) - 0.5));\n        return abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);\n}\n\n\nvec3 palette(float i) {\n        return vec3(1.0, 1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n\t\tfloat d = 1.0-hexSdf(fragCoord.xy/100.0);\n        fragColor.rgb = vec3(d);\n        fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 70, 70, 234], [237, 237, 260, 260, 298], [300, 300, 357, 357, 464]], "test": "untested"}
{"id": "3dVcWd", "name": "Fab30 #inktober2020 \"ominious\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nRef image: [url] https://i.imgur.com/GY5QSpC.png [/url]", "tags": ["2d", "short", "reproduction", "inktober2020"], "likes": 8, "viewed": 316, "published": 3, "date": "1604055446", "time_retrieved": "2024-07-30T20:37:27.813020", "image_code": "//           smoothstep(1.5,0., (v)/fwidth(v) ) * float//\n#define S(v) smoothstep(6./R.y,0.,v) * float//\nvoid mainImage(out vec4 O, vec2 u) { O-=O; O.a++;\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,\n          V = U * mat2(3,1,-6,18) / 1.6, E = vec2(1,2);\n    float x = abs(U.x), y = U.y, Y = y-.5;\n    O+= 1.-\n        S(  abs( V.x -.2*sin(V.y+1.) +.74 ) +.12*y-.02 )(abs(y+.2) < .3)/* tail */\n      - S( length( U/E -.42*O.xw ) - .2 ) (y<.75)  /* head */\n       +S( length( U*E -1.5*O.xw ) - .2 ) (y<.75)  /* ears */\n      - S( x - Y*Y*(3.+Y+Y) /5. )       (y*y<.25)  /* body */\n      - S( x*.3 -U.y -.557 )              (y<-.5);}/* arms */  /*\n\n\n\n\n\n// --- 397 chars\n\n#define S(v) smoothstep(6./R.y,0.,v)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y, \n          V = U * mat2(3,1,-1,3) / 3.2,\n          X = vec2(0,1);\n    float x = abs(U.x), y = U.y-.5;\n    O = vec4(1);\n    if ( abs(U.y+.2) < .3)                                     // tail\n        O -= S(  abs( 2.*V.x -.2*sin(12.*V.y+1.) +.74 ) +.12*U.y-.02 );\n\n    if (U.y<.75) O -= S( length(U/vec2(1,2)-.42*X) - .2 )      // head\n                     -S( length(U*vec2(1,2)-1.5*X) - .2 );     // ears\n    if (abs(U.y)<.5) O -= S(x-y*y*(3.+y+y)/5.);                // body\n    if (U.y<-.5) O -= S(.3*x-U.y-.557);                        // arms\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 141, 141, 649]], "test": "untested"}
{"id": "WdKcWd", "name": "Truchet Passages", "author": "dr2", "description": "Starting from a hexagonal truchet tiling...", "tags": ["truchet", "architecture"], "likes": 14, "viewed": 397, "published": 3, "date": "1604051524", "time_retrieved": "2024-07-30T20:37:28.916070", "image_code": "// \"Truchet Passages\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nvec2 gId, cMid;\nfloat tCur, dstFar, hgSize, cDir, trWidf;\nint idObj;\nconst int idPath = 1, idRail = 2, idBod = 3, idSup = 4, idBas = 5, idCone = 6,\n   idRfC = 7, idRfT = 8, idGrnd = 9;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 qa, qb;\n  float dMin, d, wThk, r, s1, s2;\n  dMin = dstFar;\n  wThk = 0.005;\n  p.xz -= cMid;\n  p /= hgSize;\n  p.xz = Rot2D (p.xz, cDir * pi / 6.);\n  p.xz = Rot2D (p.xz, 2. * pi * floor (3. * atan (p.z, - p.x) / (2. * pi) + 0.5) / 3.);\n  q = p;\n  q.x += 1.;\n  r = length (q.xz);\n  d = max (abs (r - 0.5) - trWidf, abs (q.y - 0.1) - 0.02);\n  DMIN (idPath);\n  d = length (vec2 (abs (r - 0.5) - trWidf + 0.02, q.y - 0.27)) - 0.007;\n  DMIN (idRail);\n  q = p;\n  q.x += 1.;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (12. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 12.);\n  q.y -= 0.17;\n  q.x = abs (q.x + 0.5) - trWidf + 0.02;\n  d = PrCylDf (q.xzy, 0.007, 0.1);\n  DMIN (idRail);\n  q = p;\n  q.x += 0.46 * sqrt3 - 0.02;\n  q.y -= 0.51;\n  d = 0.9 * PrCylDf (q.xzy, 0.01 * (1. - 0.6 * q.y), 0.51);\n  DMIN (idSup);\n  q = p;\n  d = PrCylDf (q.xzy, 0.46 * sqrt3, 0.08);\n  DMIN (idBas);\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 0.1 - 0.2 * q.y, 0.2);\n  DMIN (idCone);\n  q = p;\n  q.y -= 1.;\n  s1 = length (vec2 (abs (r - 0.5), abs (q.y))) - 0.8 * trWidf;\n  s2 = length (vec2 (abs (length (q.xz) - 0.46 * sqrt3 + trWidf), abs (q.y))) - 0.8 * trWidf;\n  d = SmoothMax (max (abs (s1), - s2) - wThk, - q.y, 0.02);\n  DMIN (idRfT);\n  d = SmoothMax (max (abs (s2), - s1) - wThk, - q.y, 0.02);\n  DMIN (idRfC);\n  q = p;\n  d = q.y;\n  DMIN (idGrnd);\n  q = p;\n  q.x += 1.;\n  q.xz = Rot2D (q.xz, mod (0.5 * cDir * tCur + pi / 3., 2. * pi / 3.) - pi / 3.);\n  qa = 0.5 * q.xz - vec2 (0.5, 0.);\n  qb = 0.5 * sqrt3 * q.zx * vec2 (1., -1.);\n  r = sqrt (dot (qa, qa) + dot (qb, qb) - 2. * abs (dot (qa, qb)));\n  d = min (max (r, abs (q.y - 0.21) - 0.09), length (vec2 (r, q.y - 0.34))) - 0.025;\n  DMIN (idBod);\n  return dMin;\n}\n\nvoid SetTrConf ()\n{\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-99.);\n  for (int j = VAR_ZERO; j < 50; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 ) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec4 PathCol (vec2 p)\n{\n  vec4 col4;\n  vec2 q;\n  float a, d, f;\n  p = Rot2D (p, cDir * pi / 6.);\n  p = Rot2D (p, 2. * pi * floor (3. * atan (p.y, - p.x) / (2. * pi) + 0.5) / 3.);\n  p.x += 1.;\n  col4 = vec4 (0.9, 0.9, 0.95, 0.1);\n  col4 *= 0.3 + 0.7 * smoothstep (0.05, 0.1, abs (mod (72. * atan (p.y, - p.x) / (2. * pi) + 0.5, 1.) - 0.5));\n  f = abs (length (p) - 0.5);\n  if (f < trWidf - 0.04) {\n    q = Rot2D (p, mod (0.5 * cDir * tCur + pi / 3., 2. * pi / 3.) - pi / 3.);\n    a = mod (15. * atan (cDir * q.y, - q.x) / (2. * pi), 1.) - 0.5;\n    for (float s = 1.; s >= 0.; s -= 1.) {\n      d = 1.;\n      if (abs (a - 0.2) - 0.2 < 0.006 * s) d = min (d, smoothstep (0., 0.002,\n         f - 0.015 * (1. - a / 0.2) - 0.002 * s));\n      else if (abs (a + 0.2) - 0.2 < 0.006 * s) d = min (d, smoothstep (0., 0.002, f - 0.005 - 0.003 * s));\n      if (abs (mod (4. * a + 0.5, 1.) - 0.5) - 0.3 < 0.03 * s)\n         d = min (d, smoothstep (0., 0.002, abs (f - 0.05) - 0.004 - 0.003 * s));\n      col4 = mix (vec4 (1. - 0.9 * s, 0., 0., -1.), col4, d);\n    }\n  }\n  return col4;\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.05 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.1, 0.35, 0.1), vec3 (0.3, 0.35, 0.35),\n       smoothstep (-0.05, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  }\n  return 0.5 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 q, vf;\n  float dstObj, sh, nDotL, s;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    q = (ro.xz - cMid) / hgSize;\n    if (idObj == idPath) {\n     col4 = PathCol (q);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.8, 0.7, 0.2, 0.2);\n    } else if (idObj == idBod) {\n      col4 = mix (vec4 (0.2, 0.7, 0.2, 0.2), vec4 (0.2, 1., 0.2, -1.), step (0.66, ro.y));\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n    } else if (idObj == idBas) {\n      s = length (q);\n      col4 = vec4 (0.55, 0.5, 0.5, 0.1) * (0.8 + 0.2 * smoothstep (0.12, 0.15, s));\n      col4 = mix (vec4 (0., 0., 1., 0.1), col4, 0.5 + 0.5 * smoothstep (0.12, 0.18, s));\n      vf = vec2 (64., 0.2);\n    } else if (idObj == idCone) {\n      col4 = vec4 (0.1, 0.1, 0.6, -1.);\n    } else if (idObj == idRfT) {\n      if (vn.y < 0.) {\n        s = abs (length (q) - 0.46 * sqrt3 + trWidf);\n        q = Rot2D (q, cDir * pi / 6.);\n        q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n        q.x += 1.;\n        s = min (s, abs (abs (length (q) - 0.5)));\n      }\n    } else  if (idObj == idRfC) {\n      if (vn.y < 0.) s = abs (length (q) - 0.46 * sqrt3 + trWidf);\n    } else  if (idObj == idGrnd) {\n      col4 = vec4 (0.3, 0.4, 0.3, 0.);\n      vf = vec2 (32., 1.);\n    }\n    if (idObj == idRfT || idObj == idRfC) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.1);\n      if (vn.y < 0.) col4 = mix (vec4 (1., 1., 0.9, -1.), col4, smoothstep (0.004, 0.008, s));\n      if (vn.y > 0. || s > 0.008) vf = vec2 (64., 0.5);\n    } else if (idObj == idGrnd || idObj == idBas && abs (vn.y) < 0.1) {\n      q = Rot2D (q, cDir * pi / 6.);\n      q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n      q.x += 1.;\n      col4 = mix (vec4 (0., 1., 0., 0.1), col4, smoothstep (0.02, 0.12, abs (abs (length (q) - 0.5))));\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    nDotL = max (dot (vn, sunDir), 0.);\n    if (idObj == idRail || idObj == idSup) nDotL *= nDotL;\n    sh = ObjSShadow (ro, sunDir);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n    col = mix (col, vec3 (0.1, 0.2, 0.1), 1. - max (0., 1. - 2. * smoothstep (0., 1.,\n       dstObj / (2. * dstFar))));\n  } else col = SkyHrzCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec2 TrkPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3/2., -0.5), vec2 (sqrt3/2., 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3/2., 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3/2., 2.5), tt - 3.);\n  r += vec2 (0.001, 3. * floor (t / 4.));\n  return r * hgSize;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, p1, p2, vd;\n  float el, az, zmFac, asp, sr, vel, tCyc, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize = 2.;\n  trWidf = 0.1;\n  vel = 0.2;\n  tCyc = 4. / vel;\n  p1 = 0.5 * (TrkPath (vel * tCur + 0.05) + TrkPath (vel * tCur + 0.15));\n  p2 = 0.5 * (TrkPath (vel * tCur - 0.05) + TrkPath (vel * tCur - 0.15));\n  s = SmoothBump (0.25, 0.75, 0.05, mod (tCur / (1. * tCyc), 1.));\n  ro.xz = 0.5 * (p1 + p2);\n  ro.x += 0.2 * (2. * SmoothBump (0.25, 0.75, 0.15, mod (0.07 * vel * tCur, 1.)) - 1.);\n  ro.y = 1.2 + 1.8 * s;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = -0.2 * pi * (s + 0.3);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.5;\n  dstFar = 60.;\n  sunDir = normalize (vec3 (1., 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[925, 925, 947, 947, 2640], [2642, 2642, 2661, 2661, 2743], [2745, 2745, 2778, 2778, 4020], [4022, 4022, 4043, 4043, 4298], [4300, 4300, 4337, 4337, 4745], [4747, 4747, 4770, 4770, 5817], [5819, 5819, 5854, 5854, 6612], [6614, 6614, 6649, 6649, 9191], [9193, 9193, 9217, 9217, 9606], [9608, 9608, 9664, 9664, 11168], [11170, 11170, 11203, 11203, 11230], [11232, 11232, 11274, 11274, 11325], [11327, 11327, 11351, 11351, 11581], [11583, 11583, 11607, 11607, 11667], [11669, 11669, 11691, 11691, 11729], [11731, 11731, 11776, 11776, 11879], [11881, 11881, 11926, 11926, 11964], [11966, 11966, 12023, 12023, 12106], [12108, 12108, 12144, 12144, 12350], [12352, 12352, 12382, 12382, 12495], [12529, 12529, 12553, 12553, 12613], [12615, 12615, 12639, 12639, 12692], [12694, 12694, 12718, 12718, 12830], [12832, 12832, 12857, 12857, 13003], [13005, 13005, 13030, 13030, 13216], [13218, 13218, 13240, 13240, 13394], [13396, 13396, 13417, 13417, 13572], [13574, 13574, 13603, 13603, 13815], [13817, 13817, 13856, 13856, 14036]], "test": "untested"}
{"id": "WsVyWd", "name": "Hexagon SDF Study 2", "author": "bunnybones", "description": "Another attempt to try to get an SDF of hexagon tiles. Based on https://www.shadertoy.com/view/ll3yW7 by laserdog", "tags": ["sdf", "hexagon"], "likes": 3, "viewed": 467, "published": 3, "date": "1604050504", "time_retrieved": "2024-07-30T20:37:29.721916", "image_code": "const vec2 s = vec2(1, 1.7320508); // 1.7320508 = sqrt(3)\n\nvec3 hue( float c )\n{\n    return smoothstep(0.,1., abs(mod(c*6.+vec3(0,4,2), 6.)-3.)-1.);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// xy - offset from nearest hex center\n// zw - unique ID of hexagon\nvec4 calcHexInfo(vec2 uv)\n{\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (4. * fragCoord - iResolution.xy) / iResolution.y;\n    const float tileAmount = 3.;\n    vec4 hexInfo = calcHexInfo(uv * tileAmount);\n//    fragColor.rgb = vec3(pow(length(abs(hexInfo.x) + abs(hexInfo.y)) * 1.3, 4.0));\n    \n    fragColor.rgb = vec3(pow(length(hexInfo.xy) * 2.0, 8.0));\n    //fragColor.rg = hexInfo.zw;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 80, 80, 150], [152, 152, 175, 175, 247], [249, 317, 344, 344, 619], [621, 621, 678, 678, 1017]], "test": "untested"}
{"id": "3sKcDt", "name": "Hexagon SDF study", "author": "bunnybones", "description": "Exporing cheap hexagons.\nMouse X position changes underlying wave offset for interesting variations.\n\nThanks for the tips, Fabrice!", "tags": ["sdf", "hexagon"], "likes": 7, "viewed": 366, "published": 3, "date": "1604048324", "time_retrieved": "2024-07-30T20:37:30.581617", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy * 0.5;\n    \n    vec2 mouse = vec2(iMouse)/vec2(iResolution);\n    \n    float width = 50.;\n    float width2 = 100.;\n    \n    vec3 ramp = vec3(uv.x+200.0 * mouse.x, (uv.x*0.33+uv.y*0.66) * 1.51, (uv.x*0.33-uv.y*0.66) * 1.51);\n\n    vec3 wave = abs(mod(ramp, width2) / width - 1.0);\n//    vec3 col = vec3(v); \n    // Output to screen\n//    float v = (wave.x+wave.y)-wave.z;\n//    float v = max(max(wave.x,wave.y),wave.z);\n//    float v = min(min(wave.x,wave.y),wave.z);\n    wave -= wave.yzx;\n    float v = max(max(wave.x,wave.y), wave.z);\n//    float v = abs(step(wave.x-wave.y,wave.y-wave.z));\n    fragColor = vec4(vec3(v),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 761]], "test": "untested"}
{"id": "wsGcWd", "name": "Polar displacement", "author": "henrmota", "description": "Some displacement with polar", "tags": ["polar"], "likes": 2, "viewed": 376, "published": 3, "date": "1604016809", "time_retrieved": "2024-07-30T20:37:31.396439", "image_code": "vec2 toPolar(vec2 p) {\n\treturn vec2(length(p), atan(p.y, p.x));     \n}\n\nvec2 fromPolar(vec2 p) {\n\treturn vec2(p.x * cos(p.y), p.x * sin(p.y));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n\tvec2 pv = toPolar(uv * 0.5 + 0.5);\n    float t = sin(iTime) * 0.5 + 0.5;\n  \tpv.x += 0.01 * (\n        cos(1./t * pv.y * uv.x * uv.y * pv.x)\n        \n    );\n  \n    uv = fromPolar(pv) * 2.0 - 1.0;\n    float d = length(pv.x);\n   \t\n    col = texture(iChannel0, uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 70], [72, 72, 96, 96, 148], [150, 150, 207, 207, 597]], "test": "untested"}
{"id": "wsGyWd", "name": "Coloured donut", "author": "codecontemplator", "description": "Cosine palette", "tags": ["learning"], "likes": 1, "viewed": 265, "published": 3, "date": "1604009056", "time_retrieved": "2024-07-30T20:37:32.237191", "image_code": "vec3 colorX(float x)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);    \n    vec3 b = vec3(0.5, 0.5, 0.5);    \n    vec3 c = vec3(1.0, 1.0, 0.5);    \n    vec3 d = vec3(0.00, 0.33, 0.67);    \n    \n    float t = x;\n    vec3 color = a + b * cos( 2. * 3.1415 * (c * t + d));\n    return color;\n}\n\nvec3 colorY(float x)\n{\n    vec3 a = vec3(0.8, 0.5, 0.4 );    \n    vec3 b = vec3(0.2, 0.4, 0.2);    \n    vec3 c = vec3(2.0, 1.0, 1.0);    \n    vec3 d = vec3(0.00, 0.25, 0.25);    \n    \n    float t = x;\n    vec3 color = a + b * cos( 2. * 3.1415 * (c * t + d));\n    return color;\n}\n\nvec3 calc(vec2 uv)\n{\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    float time = iTime;\n    vec3 colorx = colorX(uv.x + time*0.321);\n    vec3 colory = colorY(uv.y + time*0.35);\n    vec3 color = mix(colorx, colory, length(uv)*2.);\n    color = clamp(color, vec3(0.3,0.3,0.2), vec3(0.9,0.5,0.3));\n    color *= 1.5 - 0.2*length(uv); // vignetting\n    color *= smoothstep(0.3, 0., abs(length(uv)-0.5));\n    //fragColor = vec4(color, 1.0);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = calc(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 277], [279, 279, 301, 301, 557], [559, 559, 579, 625, 1015], [1017, 1017, 1074, 1125, 1293]], "test": "untested"}
{"id": "wsGcWt", "name": "Color Weave - Polar", "author": "BackwardsCap", "description": "@@@", "tags": ["colors", "sin", "cos"], "likes": 5, "viewed": 347, "published": 3, "date": "1603997009", "time_retrieved": "2024-07-30T20:37:32.992172", "image_code": "// Fork of \"Color Weave\" by BackwardsCap. https://shadertoy.com/view/tlKGRc\n\nfloat rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(12389.1253,8941.1283)))*12893.128933);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y/1.5, uv2=uv;\n    uv = vec2(atan(uv.x,uv.y),length(uv));\n    uv.y-=.4+(.25*sin(iTime*.1));\n    vec3 o = vec3(0);\n    \n    uv.x+=iTime;\n    \n    for(float i=-5.,id=0., T=iTime*.075;i<5.;i+=.15,id++)\n    {\n        uv.y *= 1.025;\n        uv.x -= .35*T;\n        float l = abs(uv.y + sin(uv.x+T)/1.-sin(cos(uv.x+T/50.))/2.);\n        o += smoothstep((20.+i*1.)/iResolution.y,0.,l);\n        o *= 1.2 * vec3((0.5+(0.5*rand(vec2(1.,id)))),\n                        (0.5+(0.5*rand(vec2(id+i/2.0,id)))),\n                        (0.5+(0.5*rand(vec2(id-i,10.5)))));\n    }\n    \n    \n    c.rgb = (o+pow(o.b,2.0)*.2);\n    c.rgb *= smoothstep(0.,.1,length(uv2)-0.001);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGcWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 98, 98, 174], [176, 176, 217, 217, 919]], "test": "untested"}
{"id": "wsGczG", "name": "ED-209", "author": "dean_the_coder", "description": "\"PLEASE NORMALIZE YOUR VECTORS. YOU HAVE 20 SECONDS TO COMPLY...\"\n\nI've always loved the (original) Robocop movie, but have never felt confident enough to try modelling ED-209.\nI hope you like it!", "tags": ["3d", "raymarching", "robot", "movie", "cineshader", "robocop"], "likes": 217, "viewed": 257716, "published": 3, "date": "1603996706", "time_retrieved": "2024-07-30T20:37:34.020423", "image_code": "// 'ED-209' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/wsGczG\n//\n// Processed by 'GLSL Shader Shrinker' (10,705 to 9,801 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I've always loved the (original) Robocop movie, but have never\n// felt confident enough to try modelling ED-209.\n// I hope you like it!\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat stretch, gunsUp, gunsForward, edWalk, edTwist, edDown, edShoot, doorOpen, glow = 0.0;\n\n//#define AA  // Enable this line if your GPU can take it!\n\nstruct MarchData {\n\tfloat d;\n\tvec3 mat; // RGB\n\tfloat specPower; // 0: None, 30.0: Shiny\n};\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) { return mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.)); }\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n\tfloat cube = sdBox(p, r);\n\tp.xz *= rot(.78525);\n\tr.xz *= -c / 1.41 + 1.41;\n\treturn max(cube, sdBox(p, r));\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x * .866025 + p.y * .5, -p.y) - h.x * .5);\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tfloat rba = rb - ra,\n\t      baba = dot(b - a, b - a),\n\t      papa = dot(p - a, p - a),\n\t      paba = dot(p - a, b - a) / baba,\n\t      x = sqrt(papa - paba * paba * baba),\n\t      cax = max(0., x - ((paba < .5) ? ra : rb)),\n\t      cay = abs(paba - .5) - .5,\n\t      f = clamp((rba * (x - ra) + paba * baba) / (rba * rba + baba), 0., 1.),\n\t      cbx = x - ra - f * rba,\n\t      cby = paba - f;\n\treturn ((cbx < 0. && cay < 0.) ? -1. : 1.) * sqrt(min(cax * cax + cay * cay * baba, cbx * cbx + cby * cby * baba));\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a,\n\t     ba = b - a;\n\treturn length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0., 1.)) - r;\n}\n\nfloat sdOctogon(vec2 p, float r) {\n\tconst vec3 k = vec3(-.92387953, .38268343, .41421356);\n\tp = abs(p);\n\tp -= 2. * min(dot(k.xy, p), 0.) * k.xy;\n\tp -= 2. * min(dot(vec2(-k.x, k.y), p), 0.) * vec2(-k.x, k.y);\n\tp -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n\treturn length(p) * sign(p.y);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nvoid setBodyMaterial(inout MarchData mat) {\n\tmat.mat = vec3(.36, .45, .5);\n\tmat.specPower = 30.;\n}\n\nfloat legWalkAngle(float f) { return sin(edWalk * 3.141 * 6. * f) * .2; }\n\nfloat edZ() { return mix(5., -2., edWalk); }\n\nfloat fireShock() { return abs(sin(edShoot * 78.5375)); }\n\nfloat headSphere(vec3 p) { return (length(p / vec3(1, .8, 1)) - 1.) * .8; }\n\nMarchData headVisor(vec3 p, float h, float bump) {\n\tbump *= sin(p.x * 150.) * sin(p.y * 150.) * .002;\n\tMarchData result;\n\tresult.d = sdBox(p, vec3(1, h, 2));\n\tresult.d = max(mix(result.d, headSphere(p), .57), -p.y) - bump;\n\tresult.mat = vec3(.05);\n\tresult.specPower = 30.;\n\treturn result;\n}\n\nMarchData headLower(vec3 p) {\n\tvec3 op = p;\n\n\t// Start by mirroring the visor.\n\tMarchData r = headVisor(p * vec3(.95, -1.4, .95), 1., 0.);\n\n\t// Add the side panels.\n\tr.d = min(r.d, max(max(headVisor((p + vec3(0, .01, 0)) * vec3(.95), 1., 0.).d, p.y - .35), p.y * .625 - p.z - .66));\n\n\t// 'Wings'.\n\tp.xy *= rot(.075 * (gunsUp - 1.) * sign(p.x));\n\tp.x = abs(p.x) - 1.33;\n\tp.y -= .1 - p.x * .1;\n\tr.d = min(r.d, sdBox(p, vec3(.4, .06 * (1. - p.x), .3 - p.x * .2)));\n\tp = op;\n\n\t// Cut out a mouth grill.\n\tp.y = abs(abs(p.y + .147) - .0556) - .0278;\n\tr.d = max(r.d, -sdBox(p + vec3(0, 0, 1.5), vec3(mix(.25, .55, -op.y), .015, .1)));\n\n\t// 'Cheeks'.\n\tp = op;\n\tp.y = abs(p.y + .16) - .06;\n\tp.z -= -1.1;\n\tr.d = max(r.d, -max(max(sdCappedCylinder(p.xzy, 1., .03), -sdCappedCylinder(p.xzy, .55, 1.)), p.z + .2));\n\tsetBodyMaterial(r);\n\treturn r;\n}\n\nMarchData gunPod(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tp.yz += vec2(.1, .45);\n\n\t// Carousel.\n\tvec3 pp = p;\n\tpp.z = abs(pp.z) - .5;\n\tr.d = sdCappedCone(pp, vec3(0), vec3(0, 0, -.1), .35 - .1, .35);\n\tr.d = min(r.d, sdCappedCylinder(p, .35, .4));\n\n\t// Triangle nobble.\n\tpp = vec3(p.x, .28 - p.y, p.z);\n\tr.d = min(r.d, sdTriPrism(pp, vec2(.1, .5)));\n\n\t// Square outriggers.\n\tpp = p;\n\tpp.x = abs(p.x);\n\tpp.xy *= rot(.78525);\n\tfloat fs,\n\t      bump = sign(sin(pp.z * 33.3)) * .003,\n\t      d = sdBox(pp, vec3(.1 - bump, .38 - bump, .34)) - .02;\n\n\t// Barrels.\n\tpp = p - vec3(0, 0, -.6);\n\tpp.x = abs(pp.x) - .1;\n\td = min(min(min(d, sdCappedCylinder(pp, .06, .15)), sdCappedCylinder(pp + vec3(0, .12, -.05), .06, .05)), sdBox(p + vec3(0, 0, .54), vec3(.1, .06, .04)));\n\tif (d < r.d) {\n\t\td = max(d, -sdCappedCylinder(pp + vec3(0, 0, .1), .03, .2));\n\t\tr.d = d;\n\t\tr.mat = vec3(.02);\n\t}\n\n\t// Muzzle flash.\n\tfs = fireShock();\n\tif (fs > .5) {\n\t\td = sdCappedCylinder(pp, .01 + pp.z * .05, fract(fs * 3322.423) * .5 + .9);\n\t\tif (d < r.d) {\n\t\t\tr.d = d;\n\t\t\tr.mat = vec3(1);\n\t\t\tglow += .1 / (.01 + d * d * 4e2);\n\t\t}\n\t}\n\n\treturn r;\n}\n\nMarchData arms(vec3 p) {\n\tconst vec3 wrist = vec3(1.5, 0, 0) - vec3(0, 0, .3);\n\tMarchData r;\n\tsetBodyMaterial(r);\n\n\t// Position origin.\n\tp.x = abs(p.x);\n\tp.yz += vec2(.24, 0);\n\tp.xy *= rot(.15 * (gunsUp - 1.));\n\n\t// Shoulder and forearm.\n\tr.d = min(sdCapsule(p, vec3(0), vec3(1.5, 0, 0), .2), sdCapsule(p, vec3(1.5, 0, 0), wrist, .2));\n\n\t// Gunz.\n\tp -= wrist;\n\tp.z -= gunsForward * .15;\n\treturn minResult(r, gunPod(p));\n}\n\nfloat toe(vec3 p) {\n\tp.yz += vec2(.1, .32);\n\treturn max(sdBox(p, vec3(.3 + .2 * (p.z - .18) - p.y * .228, .3 + .2 * cos((p.z - .18) * 3.69), .35)), .1 - p.y);\n}\n\nfloat foot(vec3 p) {\n\tp.z += .8;\n\tp.yz *= rot(.86);\n\tfloat d = toe(p);\n\tp.xz *= rot(1.57);\n\tp.x -= .43;\n\tp.z = .25 - abs(p.z);\n\treturn min(d, toe(p));\n}\n\nMarchData waist(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tp.y += .65;\n\tp.yz *= rot(-.2);\n\tfloat bump, d,\n\t      legAngle = legWalkAngle(1.);\n\tp.xy *= rot(legAngle * .3);\n\tvec3 pp = p;\n\tpp.y += .3;\n\tr.d = max(sdCappedCylinder(pp.zyx, .5, .5), p.y + .15);\n\n\t// Thorax.\n\tbump = .5 - abs(sin(p.y * 40.)) * .03;\n\td = sdBox(p, vec3(bump, .15, bump));\n\n\t// Leg joins.\n\tbump = .3 - abs(sin(p.x * 40.)) * .03;\n\tpp.y += .18;\n\td = min(d, sdCappedCylinder(pp.zyx, bump, .75));\n\n\t// Hips.\n\tpp.x = abs(pp.x);\n\tpp.yz *= rot(-.58525 + legAngle * sign(p.x));\n\tpp.x -= .98;\n\tr.d = min(r.d, max(sdCappedCylinder(pp.zyx, .4, .24), -pp.y));\n\tr.d = min(r.d, sdBox(pp, vec3(.24, .2, .14 + .2 * pp.y)));\n\n\t// Thigh pistons.\n\tp = pp;\n\tpp.xz = abs(pp.xz) - vec2(.12, .25);\n\tr.d = min(r.d, max(min(sdCappedCylinder(pp.xzy, .1, .325), sdCappedCylinder(pp.xzy, .05, .5)), pp.y));\n\n\t// 'Knees'.\n\tp.y += .68;\n\tr.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - .04) * .005 + .26, .2, .34)));\n\tif (d < r.d) {\n\t\t// Black segments.\n\t\tr.d = d;\n\t\tr.mat = vec3(.02);\n\t}\n\n\treturn r;\n}\n\nMarchData legs(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tfloat silver,\n\t      legAngle = legWalkAngle(1.);\n\tp.z += .27;\n\tp.yz *= rot(legAngle * sign(p.x));\n\tp.z -= .27;\n\tp.y += .65;\n\tp.yz *= rot(-.2);\n\tp.xy *= rot(legAngle * .3);\n\tvec3 cp,\n\t     pp = p;\n\tpp.x = abs(pp.x);\n\tpp.y += .48;\n\tpp.yz *= rot(-.58525);\n\tpp.x -= .98;\n\tcp = pp;\n\tp = pp;\n\tpp.xz = abs(pp.xz) - vec2(.12, .25);\n\tp.y += .68;\n\n\t// Thighs.\n\tp.xy = abs(p.xy) - .12;\n\tsilver = sdBox(p, vec3(.07, .05, 1.2));\n\n\t// Leg end cap.\n\tcp -= vec3(0, -.7, 0);\n\tr.d = sdBox(cp - vec3(0, 0, 1.15), vec3(.17, .17, .07)) - .04;\n\n\t// Shin.\n\tcp.z++;\n\tr.d = min(r.d, sdChamferedCube(cp.xzy, vec2(.28 - sign(abs(cp.z) - .3) * .01, .5).xyx, .18));\n\n\t// Feet.\n\tr.d = min(r.d, foot(cp));\n\tif (silver < r.d) {\n\t\tr.d = silver;\n\t\tr.mat = vec3(.8);\n\t}\n\n\treturn r;\n}\n\nMarchData ed209(vec3 p) {\n\tp.yz += vec2(legWalkAngle(2.) * .2 + .1, -edZ());\n\tMarchData r = legs(p);\n\tfloat f = min(stretch * 2., 1.),\n\t      slide = f < .5 ? smoothstep(0., .5, f) : (1. - smoothstep(.5, 1., f) * .2);\n\tp.yz -= slide * .5;\n\tgunsUp = smoothstep(0., 1., clamp((stretch - .66) * 6., 0., 1.)); // 0.66-0.83\n\tgunsForward = smoothstep(0., 1., clamp((stretch - .83) * 6., 0., 1.)) // 0.83-1.0\n\t + fireShock() * .5;\n\tr = minResult(r, waist(p));\n\tp.yz *= rot(.1 * (-edDown + legWalkAngle(2.) + smoothstep(0., 1., clamp((stretch - .5) * 6., 0., 1.)) - 1.)); // 0.5-0.66\n\tp.xz *= rot(edTwist * .2);\n\treturn minResult(minResult(minResult(r, headLower(p)), headVisor(p, .8, 1.)), arms(p));\n}\n\nMarchData room(vec3 p) {\n\tconst vec3 frameInner = vec3(2.8, 2.6, .1);\n\tMarchData r;\n\tr.mat = vec3(.4);\n\tr.specPower = 1e7;\n\tvec2 xy = p.xy - vec2(0, 2);\n\tp.x = abs(p.x);\n\tp.yz += vec2(.5, -3.4);\n\tfloat doorFrame, doorWidth, door, d,\n\t      doorHole = sdBox(p, frameInner + vec3(0, 0, 1)),\n\t      backWall = length(p.z - 8.);\n\tr.d = min(backWall, max(length(p.z), -doorHole + .1));\n\tif (r.d == backWall) {\n\t\tfloat ocp = min(abs(sdOctogon(xy, 2.6)), abs(sdOctogon(xy, 1.9)));\n\t\tocp = min(max(ocp, min(.7 - abs(xy.x + 1.2), -xy.y)), max(abs(sdOctogon(xy, 1.2)), min(xy.x, .7 - abs(xy.y))));\n\t\tif (ocp < .3) r.mat = vec3(.39, .57, .71);\n\t}\n\n\tdoorFrame = max(sdBox(p, frameInner + vec3(.4, .4, .1)), -doorHole);\n\tdoorWidth = frameInner.x * .5;\n\tp.x -= frameInner.x;\n\tp.xz *= rot(doorOpen * 2.1);\n\tp.x += doorWidth;\n\tdoor = sdBox(p, vec3(doorWidth, frameInner.yz));\n\tp = abs(p) - vec3(doorWidth * .5, 1.1, .14);\n\td = min(doorFrame, max(door, -max(sdBox(p, vec3(.45, .9, .1)), -sdBox(p, vec3(.35, .8, 1)))));\n\tif (d < r.d) {\n\t\tr.d = d;\n\t\tr.mat = vec3(.02, .02, .024);\n\t\tr.specPower = 10.;\n\t}\n\n\treturn r;\n}\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n\tMarchData r = minResult(room(p), ed209(p));\n\tfloat gnd = length(p.y + 3.);\n\tif (gnd < r.d) {\n\t\tr.d = gnd;\n\t\tr.mat = vec3(.1);\n\t}\n\n\treturn r;\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\tfloat res = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = map(p + rd * t).d;\n\t\tres = min(res, 12. * h / t);\n\t\tt += h;\n\t\tif (res < .001 || t > 25.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tfloat d = .01 * t * .33;\n\tvec2 e = vec2(1, -1) * .5773 * d;\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(map(p + h * n).d / h, 0., 1.); }\n\n/**********************************************************************************/\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n\tvec3 sunP = vec3(10, 10, -10),\n         sunDir = normalize(sunP - p),\n\t     n = calcNormal(p, d);\n\n\t// Primary light.\n\tfloat primary = max(0., dot(sunDir, n)),\n\t      bounce = max(0., dot(-sunDir, n)) * .3,\n\t      spe = pow(max(0., dot(rd, reflect(sunDir, n))), data.specPower) * 2.,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\t      fog = exp(-length(p) * .05);\n          \n    primary /= pow(length(sunP - p) / 15., 3.0);\n    if (data.specPower > 1e6) spe *= 0.;\n\n\t// Combine.\n\tprimary *= mix(.2, 1., calcShadow(p, vec3(10, 10, -10)));\n\treturn mix(data.mat * ((primary + bounce) * ao(p, n, .33) + spe) * vec3(2, 1.6, 1.7), vec3(.01), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\tfloat g,\n\t      d = .01;\n\tMarchData h;\n\tfor (float steps = 0.; steps < 120.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 * d) break;\n\t\tif (d > 64.) return vec3(0); // Distance limit reached - Stop.\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\t// Lighting.\n\tg = glow;\n\treturn applyLighting(p, rd, d, h) + fireShock() * .3 + g;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tedWalk = 1.;\n\tedTwist = 0.;\n\tedDown = 0.;\n\tedShoot = 0.;\n\tdoorOpen = 1.;\n\tstretch = 1.;\n\n\t// Camera.\n\tvec3 ro, lookAt, col;\n\tfloat startScene, endScene, dim,\n\t      time = mod(iTime, 55.);\n\tif (time < 12.) {\n\t\tstartScene = 0.;\n\t\tendScene = 12.;\n\t\tedWalk = 0.;\n\t\tro = vec3(0, -1.5, -.625);\n\t\tlookAt = vec3(0, -1, edZ());\n\t\tdoorOpen = smoothstep(0., 1., time / 5.);\n\t\tstretch = remap(time, 7., 10., 0., 1.);\n\t}\n\telse if (time < 25.) {\n\t\tstartScene = 12.;\n\t\tendScene = 25.;\n\t\tfloat t = time - startScene;\n\t\tedWalk = smoothstep(0., 1., remap(t, 3., 8., 0., 1.));\n\t\tro = vec3(-.5 * cos(t * .7), .5 - t * .1, edZ() - 3.);\n\t\tlookAt = vec3(0, 0, edZ());\n\t}\n\telse if (time < 29.) {\n\t\tstartScene = 25.;\n\t\tendScene = 29.;\n\t\tro = vec3(-2, .5 + (time - startScene) * .1, edZ() - 3.);\n\t\tlookAt = vec3(0, 0, edZ());\n\t}\n\telse if (time < 37.) {\n\t\tstartScene = 29.;\n\t\tendScene = 37.;\n\t\tfloat t = time - startScene;\n\t\tro = vec3(1.5, -1. - t * .05, edZ() - 5.);\n\t\tlookAt = vec3(0, -1, edZ());\n\t\tstretch = remap(t, 2., 5., 1., 0.);\n\t}\n\telse if (time < 55.) {\n\t\tstartScene = 37.;\n\t\tendScene = 55.;\n\t\tfloat t = time - startScene;\n\t\tro = vec3(-1.8, -.5, edZ() - 2.5);\n\t\tstretch = remap(t, 2., 3., 0., 1.) - remap(t, 11.5, 14.5, 0., 1.);\n\t\tlookAt = vec3(0, stretch * .5 - .5, edZ());\n\t\tedTwist = remap(t, 3., 3.2, 0., 1.) * stretch;\n\t\tedDown = remap(t, 3.2, 3.4, 0., 1.) * stretch;\n\t\tedShoot = t <= 9.5 ? remap(t, 4., 9.5, 0., 1.) : 0.;\n\t}\n\n\tdim = 1. - cos(min(1., 2. * min(abs(time - startScene), abs(time - endScene))) * 1.5705);\n\tcol = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 coord = fragCoord + vec2(dx, dy) * .5;\n#else\n\t\t\tvec2 coord = fragCoord;\n#endif\n\t\t\tcoord += (fract(fireShock() * vec2(23242.232, 978.23465)) - .5) * 10.;\n\t\t\tvec2 uv = (coord - .5 * iResolution.xy) / iResolution.y;\n\t\t\tcol += getSceneColor(ro, getRayDir(ro, lookAt, uv));\n#ifdef AA\n\t\t}\n\t}\n\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.4545)), fragCoord), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGczG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[812, 812, 831, 831, 898], [900, 900, 968, 968, 1034], [1036, 1036, 1065, 1065, 1152], [1154, 1154, 1202, 1202, 1312], [1314, 1314, 1348, 1348, 1440], [1442, 1442, 1506, 1506, 2015], [2017, 2017, 2067, 2067, 2175], [2177, 2177, 2227, 2227, 2337], [2339, 2339, 2373, 2373, 2625], [2627, 2627, 2674, 2674, 2846], [2848, 2848, 2895, 2895, 2934], [2936, 2936, 2979, 2979, 3034], [3036, 3036, 3065, 3065, 3109], [3111, 3111, 3124, 3124, 3155], [3157, 3157, 3176, 3176, 3214], [3216, 3216, 3242, 3242, 3291], [3293, 3293, 3343, 3343, 3583], [3585, 3585, 3614, 3614, 4420], [4422, 4422, 4448, 4448, 5541], [5543, 5543, 5567, 5567, 5964], [5966, 5966, 5985, 5985, 6126], [6128, 6128, 6148, 6148, 6280], [6282, 6282, 6307, 6307, 7326], [7328, 7328, 7352, 7352, 8138], [8140, 8140, 8165, 8165, 8834], [8836, 8836, 8860, 8860, 9934], [9936, 9974, 9997, 9997, 10141], [10143, 10143, 10184, 10199, 10445], [10447, 10447, 10481, 10481, 10670], [10672, 10700, 10735, 10735, 10781], [10783, 10868, 10909, 10909, 11035], [11037, 11037, 11099, 11099, 11756], [11758, 11758, 11796, 11810, 12172]], "test": "untested"}
{"id": "tsKyRd", "name": "CirlesInHexGrid", "author": "Arseny", "description": "Just fun", "tags": ["procedural", "2d"], "likes": 16, "viewed": 370, "published": 3, "date": "1603983284", "time_retrieved": "2024-07-30T20:37:34.851203", "image_code": "const vec3 colorA = vec3(255., 252., 167.) / 255.;\nconst vec3 colorB = vec3(117., 252., 167.) / 255.;\nconst vec3 colorC = vec3(167., 247., 255.) / 255.;\n\nconst vec3 cols[3] = vec3[3](colorA, colorB, colorC);\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sDistToArc(vec2 uv, vec2 A, vec2 B, float d){ \n    vec2 v = B - A;\n    vec2 n = normalize(vec2(-v.y, v.x));\n    vec2 c = A + v / 2.;\n    float l = length(v) / 2.;\n    vec2 p;\n    p.x = dot(normalize(v), uv - c);\n    if (abs(d) < 1e-6){\n        return abs(p.x) > l ?\n            1e9\n            : dot(n, uv - c);\n    }\n    float h = (l * l) / 2. / d - d / 2.;\n    p.y = dot(n, uv - c) + h;\n    return (d * p.y < 0. || abs(p.x) > l) ?\n        1e9\n        : (length(p) - abs(h + d)) * sign(d);\n}\n\nfloat getD(vec2 id){\n    float d = 1./sqrt(3.) - .5,\n          k = 1.2;\n    \n#define get(op)  floor( hash12( vec2( hash12(id), op(iTime*k) ) ) * 2.)\n                 \n    return d * ( mix( get(floor), get(ceil), fract(iTime*k) ) * 2. - 1. );\n}\n\nfloat getDist(vec2 lv, vec2 A, vec2 B, vec2 id){\n    float s = sign((A - B).x + (A - B).y);\n    return sDistToArc(lv, A, B, getD(id + (A + B) / 2.) * s);\n}\n\nvec3 TriCoord(vec2 uv){\n    vec2 id;\n    const float sqrt3 = sqrt(3.);\n    vec2 v = normalize(vec2(3., sqrt3));\n    id.y = floor(uv.y / sqrt3 * 2.) * sqrt3 / 2. + sqrt3 / 4.;\n    id.x = floor(dot(uv, v) / sqrt3 * 2.) - id.y / sqrt3 + 0.5;\n    float h = sqrt3 / 6.;\n    vec2 lv = uv - id;\n    float d = sqrt(0.25 + h * h) - 0.5;\n    vec2 LC = vec2(-0.25, h / 2.);\n    vec2 RC = vec2(0.25, -h / 2.);\n    vec2 LLC = vec2(-0.75, -h / 2.);\n    vec2 RDC = vec2(0.25, -h / 2. - h * 2.);\n    vec2 RRC = vec2(0.75, h / 2.);\n    vec2 UC = vec2(-0.25, h / 2. + h * 2.);\n    float dd = abs(getDist(lv, RC, LC, id));\n    dd = min(dd, abs(getDist(lv, LC, LLC, id)));\n    dd = min(dd, abs(getDist(lv, RC, RDC, id)));\n    dd = min(dd, abs(getDist(lv, RRC, RC, id)));\n    dd = min(dd, abs(getDist(lv, UC, LC, id)));\n    dd *= 40.;\n    dd = min(dd, 1.);\n    if (getDist(lv, LC, RC, id) < 0. || getDist(lv, LLC, LC, id) < 0. || getDist(lv, RC, RDC, id) < 0.){\n        return cols[int(mod(id.x + mod(id.y, 2.), 3.))] * dd;\n    }\n    if (getDist(lv, RC, LC, id) < 0. || getDist(lv, RRC, RC, id) < 0. || getDist(lv, LC, UC, id) < 0.){\n        return cols[int(mod(id.x + mod(id.y, 2.) + 2., 3.))] * dd;\n    }\n    return cols[int(mod(id.x + mod(id.y, 2.) + 1., 3.))] * dd;\n    return vec3(dd * 20.);\n}\n\nvoid mainImage( out vec4 ans, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    ans.rgb = TriCoord(uv * 5.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 251, 273, 273, 423], [425, 425, 476, 476, 923], [925, 925, 945, 945, 1168], [1170, 1170, 1218, 1218, 1325], [1327, 1327, 1350, 1350, 2604], [2606, 2606, 2657, 2657, 2753]], "test": "untested"}
{"id": "WsGcWd", "name": "intro-get ready for this", "author": "jorge2017a1", "description": "intro-get ready for this", "tags": ["introgetreadyforthis"], "likes": 1, "viewed": 322, "published": 3, "date": "1603982921", "time_retrieved": "2024-07-30T20:37:35.658044", "image_code": "//modificado por jorgeflores oct-2020\n\n/* Normal Map Stuff */\n/* By: Flyguy */\n/* With help from http://stackoverflow.com/q/5281261 */\n\n// fancified a bit by psonice\n\n#define PI 3.141592\n\n\n vec2 mouse;\n\n\n vec2 surfaceSize;\n vec2 surfacePosition;\n\nvec3 heightmap(vec2 position)\n{\n\tfloat row = floor((position.y-15.)/100.);\n\tif (mod(row, 2.0) < 1.0)\n\t\tposition.x += 50.;\n\t\n\tfloat height = 0.0;\n\t\n   height = (position.x*0.002);\n\t\n    height += clamp((position.y*0.0625),0.0,1.0);\n    \n    \n\theight = clamp(height,0.0,0.5);\n\theight = 1.0 - height;\n        height -= height > 0.0 && height < 0.51 ? (max(sin(position.x * 0.25 + PI * .5) + cos(position.y * .25 - PI *0.5), 0.0125) - 2.0) * 0.85 : 0.1;\n\t\n\treturn vec3(position,height);\n}\n\t\nvec3 n1,n2,n3,n4;\nvec2 size = vec2(-0.4,0.0);\n\n\n\n\n\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define Cm(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    Cm(83);Cm(111);Cm(117);Cm(110);Cm(100);Cm(32);Cm(105);Cm(110);Cm(115);Cm(105);Cm(100);Cm(101); // message \"Sound inside\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    mouse.x=0.5+0.25*cos(iTime);\n    mouse.y=0.5+0.25*sin(iTime);\n    \n\tvec2 pos = fragCoord.xy;\n\n\tvec3 color = vec3(0.0);\n\t\n\tvec2 off = vec2(pos.x,pos.y-1.0);\n\t\n\tn1 = heightmap(off);\n\t\n\toff = vec2(pos.x-1.0,pos.y);\n\t\n\tn2 = heightmap(off);\n\t\n\toff = vec2(pos.x+1.0,pos.y);\n\t\n\tn3 = heightmap(off);\n\t\n\toff = vec2(pos.x,pos.y+1.0);\n\t\n\tn4 = heightmap(off);\n\t\n\tvec3 va = normalize(vec3(size.xy,n2.z-n3.z));\n\tvec3 vb = normalize(vec3(size.yx,n1.z-n4.z));\n\t\n\tvec3 p2m = vec3(-((pos/iResolution.xy)-mouse.xy)*iResolution.xy,64.0);\t\n\t\n\tvec3 normal = vec3(cross(va,vb));\n\t\n\tcolor = vec3(dot(normal.xyz, p2m)/96.0);\n\t\n\tcolor *= vec3(clamp(1.0-distance(mouse.xy*iResolution.xy,pos)/iResolution.x*2.0,0.0,1.0));\n\t\n    \n    \n      if (iResolution.y<2000.) \n      {\n          float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n    \t  vec3 col = 0.5 + 0.5*cos(iTime+pos.xyx+vec3(0,2,4)); \t      \n          if(c>=0.)\n          {\n           fragColor=vec4(c*col,1.0);\n           return;\n          }\n          \n      }\n\n    \n    \n\tfragColor = vec4( vec3( color ), 1.0 );\n\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n//29-oct-2020\n//---por jorgeflores ----jorge2017a1\n\n//referencia\n//https://www.shadertoy.com/view/wsScWV ......Creado por NonGrate en 2020-04-19\n\n///Referencia  la grande comunidad de usuarios de  Shadertoy... :)\n//Reference the large community of Shadertoy users ... :)\n\n#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n\n// Durations\nconst float WHOLE_NOTE = 1.0;\nconst float HALF_NOTE = 1.0/2.0;\nconst float _4_NOTE = 1.0/4.0;\nconst float _8_NOTE = 1.0/8.0;\nconst float _16_NOTE = 1.0/16.0;\nconst float _32_NOTE = 1.0/32.0;\nconst float DOUBLE_NOTE = 2.0;\n\n\nstruct TNote {\n    // in Hz, see \"common\" tab\n    float note;\n    float octave;\n    float offset; // offset - time in seconds when to start playing note\n    float duration;  // duration of a note (1/4, 1/8, ...), see \"common\" tab\n};\n\n    \n\nfloat n2f(float n)\n{\n    return 440.0*pow(2.0,(n-69.0)/12.0);\n}\n\n\nfloat n2m(float n)\n{\n    return pow(2.0,n/12.0);\n}\n\n\n///-----------------------------------\n\nfloat noise( float x ){return fract(sin(1371.1*x)*43758.5453);}\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n///-----------------------------------\n\nconst float t2 =6.5;\n\nconst TNote[] notes = TNote[] \n    (\n    //-------N1\n    TNote(E, 5.0, 0.0, _4_NOTE),\n    TNote(B, 4.0, 0.0, _4_NOTE),\n    TNote(E, 4.0, 0.0, _4_NOTE),\n\n        \n    TNote(E, 5.0, 0.5, _4_NOTE),\n    TNote(B, 4.0, 0.5, _4_NOTE),\n    TNote(E, 4.0, 0.5, _4_NOTE),\n        \n    TNote(E, 5.0, 1.0, _4_NOTE),\n    TNote(B, 4.0, 1.0, _4_NOTE),\n    TNote(E, 4.0, 1.0, _4_NOTE),\n    ///------------\n    //----------N2\n    TNote(A, 4.0, 1.5, _4_NOTE),\n    TNote(E, 4.0, 1.5, _4_NOTE),\n    TNote(A, 3.0, 1.5, _4_NOTE),\n    \n    TNote(A, 4.0, 2.0, _4_NOTE),\n    TNote(E, 4.0, 2.0, _4_NOTE),\n    TNote(A, 3.0, 2.0, _4_NOTE),\n        \n    TNote(B, 4.0, 2.5, _4_NOTE),\n    TNote(F, 4.0, 2.5, _4_NOTE),\n    TNote(B, 3.0, 2.5, _4_NOTE),\n        \n    TNote(B, 4.0, 3.0, _4_NOTE),\n    TNote(F, 4.0, 3.0, _4_NOTE),\n    TNote(B, 3.0, 3.0, _4_NOTE),\n    ///------------\n    ///---------N3\n    TNote(E, 5.0, 3.5, _4_NOTE),\n    TNote(B, 4.0, 3.5, _4_NOTE),\n    TNote(E, 4.0, 3.5, _4_NOTE),\n\n        \n    TNote(E, 5.0, 4.0, _4_NOTE),\n    TNote(B, 4.0, 4.0, _4_NOTE),\n    TNote(E, 4.0, 4.0, _4_NOTE),\n        \n    TNote(E, 5.0, 4.5, _4_NOTE),\n    TNote(B, 4.0, 4.5, _4_NOTE),\n    TNote(E, 4.0, 4.5, _4_NOTE),\n    ///------------\n    //---------N4\n    TNote(G, 5.0, 5.0, _4_NOTE),\n    TNote(D, 5.0, 5.0, _4_NOTE),\n    TNote(G, 4.0, 5.0, _4_NOTE),\n        \n    TNote(G, 5.0, 5.5, _4_NOTE),\n    TNote(D, 5.0, 5.5, _4_NOTE),\n    TNote(G, 4.0, 5.5, _4_NOTE),\n        \n    TNote(A, 5.0, 6.0, _4_NOTE),\n    TNote(E, 5.0, 6.0, _4_NOTE),\n    TNote(A, 4.0, 6.0, _4_NOTE),\n        \n    TNote(B, 5.0, 6.5, _4_NOTE),\n    TNote(F, 5.0, 6.5, _4_NOTE),\n    TNote(B, 4.0, 6.5, _4_NOTE),\n    //-------------------\n    //---------N5\n    TNote(E, 5.0, 7.0, _4_NOTE),\n    TNote(B, 4.0, 7.0, _4_NOTE),\n    TNote(E, 4.0, 7.0, _4_NOTE),\n        \n    TNote(E, 5.0, 7.5, _4_NOTE),\n    TNote(B, 4.0, 7.5, _4_NOTE),\n    TNote(E, 4.0, 7.5, _4_NOTE),\n        \n    TNote(E, 5.0, 8.0, _4_NOTE),\n    TNote(B, 4.0, 8.0, _4_NOTE),\n    TNote(E, 4.0, 8.0, _4_NOTE),\n        \n    //-------------------\n    //---------N6\n    TNote(A, 4.0, 8.5, _4_NOTE),\n    TNote(E, 4.0, 8.5, _4_NOTE),\n    TNote(A, 3.0, 8.5, _4_NOTE),\n\n    TNote(A, 4.0, 9.0, _4_NOTE),\n    TNote(E, 4.0, 9.0, _4_NOTE),\n    TNote(A, 3.0, 9.0, _4_NOTE),\n        \n    TNote(B, 4.0, 9.5, _4_NOTE),\n    TNote(F, 4.0, 9.5, _4_NOTE),\n    TNote(B, 3.0, 9.5, _4_NOTE),\n        \n    TNote(B, 4.0, 10.0, _4_NOTE),\n    TNote(F, 4.0, 10.0, _4_NOTE),\n    TNote(B, 3.0, 10.0, _4_NOTE),\n     //----------\n    //-------N7\n    TNote(E, 5.0, 10.5, _4_NOTE),\n    TNote(B, 4.0, 10.5, _4_NOTE),\n    TNote(E, 4.0, 10.5, _4_NOTE),\n\n        \n    TNote(E, 5.0, 11.0, _4_NOTE),\n    TNote(B, 4.0, 11.0, _4_NOTE),\n    TNote(E, 4.0, 11.0, _4_NOTE),\n        \n    TNote(E, 5.0, 11.5, _4_NOTE),\n    TNote(B, 4.0, 11.5, _4_NOTE),\n    TNote(E, 4.0, 11.5, _4_NOTE),\n    ///------------    \n    //-------N8\n    TNote(G, 5.0, 12., _4_NOTE),\n    TNote(D, 5.0, 12., _4_NOTE),\n    TNote(G, 4.0, 12., _4_NOTE),\n        \n    TNote(G, 5.0, 12.5, _4_NOTE),\n    TNote(D, 5.0, 12.5, _4_NOTE),\n    TNote(G, 4.0, 12.5, _4_NOTE),\n    \n    TNote(A, 5.0, 13., _4_NOTE),\n    TNote(E, 5.0, 13., _4_NOTE),\n    TNote(A, 4.0, 13., _4_NOTE),\n\n    TNote(A, 5.0, 13.5, _4_NOTE),\n    TNote(E, 5.0, 13.5, _4_NOTE),\n    TNote(A, 4.0, 13.5, _4_NOTE),\n     //-------N9\n    TNote(E, 5.0, 14.0, _4_NOTE),\n    TNote(B, 4.0, 14.0, _4_NOTE),\n    TNote(E, 4.0, 14.0, _4_NOTE),\n\n        \n    TNote(E, 5.0, 14.5, _4_NOTE),\n    TNote(B, 4.0, 14.5, _4_NOTE),\n    TNote(E, 4.0, 14.5, _4_NOTE),\n        \n    TNote(E, 5.0, 15.0, _4_NOTE),\n    TNote(B, 4.0, 15.0, _4_NOTE),\n    TNote(E, 4.0, 15.0, _4_NOTE),\n    ///------------\n     //----------N10\n    TNote(A, 4.0, 15.5, _4_NOTE),\n    TNote(E, 4.0, 15.5, _4_NOTE),\n    TNote(A, 3.0, 15.5, _4_NOTE),\n    \n    TNote(A, 4.0, 16.0, _4_NOTE),\n    TNote(E, 4.0, 16.0, _4_NOTE),\n    TNote(A, 3.0, 16.0, _4_NOTE),\n        \n    TNote(B, 4.0, 16.5, _4_NOTE),\n    TNote(F, 4.0, 16.5, _4_NOTE),\n    TNote(B, 3.0, 16.5, _4_NOTE),\n        \n    TNote(B, 4.0, 17.0, _4_NOTE),\n    TNote(F, 4.0, 17.0, _4_NOTE),\n    TNote(B, 3.0, 17.0, _4_NOTE),\n    ///------------\n    //-------N11\n    TNote(E, 5.0, 17.5, _4_NOTE),\n    TNote(B, 4.0, 17.5, _4_NOTE),\n    TNote(E, 4.0, 17.5, _4_NOTE),\n\n        \n    TNote(E, 5.0, 18., _4_NOTE),\n    TNote(B, 4.0, 18., _4_NOTE),\n    TNote(E, 4.0, 18., _4_NOTE),\n        \n    TNote(E, 5.0, 18.5, _4_NOTE),\n    TNote(B, 4.0, 18.5, _4_NOTE),\n    TNote(E, 4.0, 18.5, _4_NOTE),\n    ///------------\n    ///------------\n    //---------N12\n    TNote(G, 5.0, 19.0, _4_NOTE),\n    TNote(D, 5.0, 19.0, _4_NOTE),\n    TNote(G, 4.0, 19.0, _4_NOTE),\n        \n    TNote(G, 5.0, 19.5, _4_NOTE),\n    TNote(D, 5.0, 19.5, _4_NOTE),\n    TNote(G, 4.0, 19.5, _4_NOTE),\n        \n    TNote(A, 5.0, 20.0, _4_NOTE),\n    TNote(E, 5.0, 20.0, _4_NOTE),\n    TNote(A, 4.0, 20.0, _4_NOTE),\n        \n    TNote(B, 5.0, 20.5, _4_NOTE),\n    TNote(F, 5.0, 20.5, _4_NOTE),\n    TNote(B, 4.0, 20.5, _4_NOTE)\n    //-------------------\n    \n);\n\n\nvec2 noteFreq(TNote note, float time) {\n    \n    // 6.2831 = 2pi\n    // exp() goes exponentially down to fade out the volume\n    //return vec2(sin(6.2831 * note.frequency * time) * exp(-1.0/note.duration * (time - note.offset)));\n    float n1=saw(time,note.note, note.octave)* exp(-1.0/note.duration * (time - note.offset));\n    \n        \n    return vec2(n1);\n}\n\n\nvec2 mainSound( in int samp,float time) \n{\n    \n    \n    \n    vec2 result;\n    \n    // time counts in seconds\n    // (time - x) is required, because we want to \"reset\" exp() function\n    // otherwise the output of exp() function will go down globally\n    // and we'll hear only first note\n\n    for (int i = 0; i < notes.length(); i++) {\n        TNote note = notes[i];\n        float x = float(i) * 1.0;\n        if (time > note.offset) \n        {\n            result += noteFreq(note, time);\n            \n        }\n    }\n\n\n    \n    return result;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 278, 278, 731], [1461, 1461, 1484, 1531, 1754], [1759, 1759, 1816, 1816, 2880]], "test": "untested"}
{"id": "3dVyD3", "name": "[♪]Pumpkin Rave", "author": "Catzpaw", "description": "pumpkin...pumpkin...pumpkin...", "tags": ["raymarching", "music", "halloween"], "likes": 23, "viewed": 1117, "published": 3, "date": "1603968797", "time_retrieved": "2024-07-30T20:37:36.598530", "image_code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Image:post effects\n\n//TEXTURE\nvec4 tx0(vec2 uv){\n    vec4 c=texture(iChannel0,uv);\n    c.g=texture(iChannel0,.99*(uv-.5)+.5).g;\n    c.r=texture(iChannel0,.98*(uv-.5)+.5).r;\n    return c;\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n\t//DOF filter\n    vec2 fp=vec2(.5);\n    mat2 vel=rot(1.);\n    vec2 mul=vec2(0,iResolution.x/iResolution.y),ang=vec2(0,1)*mul;\n    vec4 acc=vec4(0,0,0,1),tgt=vec4(1),c=tx0(uv);\n    float foc=min(.6,tx0(fp).w),bok=abs(c.w-foc),rad=0.,dis=0.;\n    for(int j=ZERO;j<30;j++){\n        rad+=.03;\n        tgt=tx0(uv+ang*rad*.03);dis=tgt.w;tgt.w=1.;\n        acc+=(((dis<c.w)&&(abs(dis-foc)>=rad))||(bok>=rad))?tgt:vec4(0);\n        ang*=vel;\n    }\n    c.rgb+=acc.rgb;c/=acc.w;\n\n    //vignette\n    uv-=.5;uv.x*=mul.y;\n    c.rgb-=length(uv)*.3;\n    c.w=1.;\n    fragColor=c;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Common:snippets\n\n#define ZERO min(0,iFrame)\n\nfloat hash(vec2 p){return fract(cos(p.x*400.)*199.7+cos(p.y*400.)*189.6);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n", "buffer_a_code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Buffer A:animation\n\n#define ITER 96\n#define EPS 1e-4\n#define NEAR 0.5\n#define FAR 20.0\n\nvec2 fold(vec2 p,float s){float a=3.142/s-atan(p.x,p.y),n=6.283/s;p*=rot(floor(a/n)*n);return p;}\nfloat sminCubic(float a,float b,float k){float h=max(k-abs(a-b),0.)/k;return min(a,b)-h*h*h*k*(1./6.);}\nfloat sdTorus(vec3 p,vec2 t){return length(vec2(length(p.yz)-t.x,p.x))-t.y;}\nfloat sdCube(vec3 p){vec3 q=abs(p)-.5;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat sdCappedCylinder(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdPumpkin(vec3 p){\n    p.xz=fold(p.xz,16.);\n    return sminCubic(sdTorus(p+vec3(0,0,-0.5),vec2(0.9,0.6)),\n        sdCappedCylinder(p+vec3(0,-1.6,-0.1),.1,.2+p.z*.1),.3);\n}\nfloat sdEyes(vec3 p){\n\tp.x=abs(p.x);p.z*=.25;\n    p+=vec3(-.8,-.5,.9);\n    p.xz*=rot(1.);p.xy*=rot(-.1);\n    return sdCube(p);\n}\nfloat sdMouth(vec3 p){\n\tp.x=abs(p.x);p.y*=2.5;\n    p+=vec3(-.3,1.2,1.9);\n    p.xz*=rot(-1.);p.yz*=rot(1.1);\n    return sdCube(p);\n}\nvec3 mapTrans(vec3 p){\n    float h=hash(floor(p.xz*.25));\n    p.xz=mod(p.xz,4.)-2.;\n    p.y-=abs(sin(h+iTime*7.069));\n    p.xz*=rot(h*10.+sin(h+iTime*5.585));\n    p.yz*=rot(h*.5);\n\treturn p;\n}\nfloat map(vec3 p){\n    p=mapTrans(p);\n\treturn max(-sdMouth(p),max(-sdEyes(p),sdPumpkin(p)));\n}\nvec2 material(vec3 p){\n    p=mapTrans(p);\n    p.y*=1.26;\n    return vec2(step(.5+length(p),2.4),length(p.xz));\n}\n\nconst vec2 e=vec2(EPS,-EPS);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(8,10,3),rd=vec3(uv,1),ld=normalize(vec3(0,1,0.5));\n    ro.xz+=vec2(30,0)*rot(iTime*.17);\n    ro.xz+=vec2(10,0)*rot(-iTime*.37);\n    rd.yz*=rot(-.9);\n    rd.xz*=rot(iTime*.2);\n    float t=NEAR;\n    vec3 p=ro;\n    for(int i=ZERO;i<ITER;i++){\n    \tp=ro+rd*t;\n        float d=map(p);\n    \tif(abs(d)<EPS||t>FAR)break;\n        t+=step(d,.7)*d+d*.1;\n    }\n    vec3 n=normalize(e.xxx*map(p+e.xxx)+e.xyy*map(p+e.xyy)+e.yxy*map(p+e.yxy)+e.yyx*map(p+e.yyx));\n    vec2 m=material(p);\n    vec3 c=hsv(.2-smoothstep(0.3,0.5,m.y)*.15,.7,.9);\n    float s=step(0.,p.y);\n    float v=s*pow(clamp(dot(n,ld),0.,1.),2.);\n    c*=v;\n    c+=pow(clamp(dot(n,ld),0.,1.),40.);\n    ld.xy*=rot(iTime*1.3);\n\tc+=s*hsv(iTime*2.51,.9,.3)*dot(n,ld);\n    ld.yz*=rot(iTime*3.3);\n\tc+=s*hsv(iTime*.31,.5,.3)*dot(n,ld);\n    c+=vec3(1,1,0.5)*m.x*(.9+hash(uv.xy+iTime));\n\n    fragColor = vec4(c,t/FAR);\n}\n", "buffer_a_inputs": [], "sound_code": "//---Pumpkin Rave\n// by Catzpaw 2020\n\n//Sound:music\n\n//---Scale Sequencer 2 by Catzpaw 2020\n//https://www.shadertoy.com/view/3tVGz3\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=92.;\nconst float noteseed=40.;\nconst int chord3=2; //3rd tone(default:2)\nconst int chord5=4; //5th tone(default:4)\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=1;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    0x37000000u,0x37011171u,0x47012172u,0x37011773u,  //00-   melody\n    0x37054394u,0x37054c95u,0x44226166u,0x34617167u,\n    0x34028168u,0x34019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x31001434u,0x31001491u,0x31001022u,0x31001022u,  //0C-0F backing\n    0x18510520u,0x18510530u,0x18510540u,0x18510550u,  //10-13 chord\n    0x42111112u,0x42222223u,0x42333334u,0x42444445u,  //14-17 bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu,\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu);\nconst uint[16] seq2=uint[]( //bassdrum+conga\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111ee11fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x1100011fu);\nconst uint[16] seq3=uint[]( //bass\n    0x01000414u,0x01000114u,0x01000514u,0x01000116u,\n    0x01000114u,0x01000414u,0x01000514u,0x01000717u,\n    0x01000615u,0x01000415u,0x01000515u,0x01000116u,\n    0x01000615u,0x01000415u,0x01000515u,0x01000717u);\nconst uint[16] seq4=uint[]( //chord\n    0x11000410u,0x11000110u,0x11000510u,0x11000112u,\n    0x11000410u,0x11000110u,0x11000510u,0x11000713u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000112u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000713u);\nconst uint[16] seq5=uint[]( //backing\n    0x0100040cu,0x0100010cu,0x0100050cu,0x090d810eu,\n    0x0100040cu,0x0100010cu,0x0100050cu,0x010d870fu,\n    0x0100060du,0x0100040cu,0x0100050du,0x070d810eu,\n    0x0100060du,0x0100040cu,0x0100050du,0x010d870fu);\nconst uint[16] seq6=uint[]( //melody\n    0x11000401u,0x11000102u,0x11000503u,0x11000104u,\n    0x11000401u,0x11000102u,0x11000503u,0x11000705u,\n    0x11000606u,0x11000407u,0x11000508u,0x11000109u,\n    0x11000606u,0x11000407u,0x1100050Au,0x1100070Bu);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),2),osc_c30(f*(1.+detune),2))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(10./(x*.3+.1),.25)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(12./(x*.3+.1),.25)*env_d(x,.05);}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 NES noise snaredrum,closehh,openhh\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nessd(n.x)*.8:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track2(float t,float l,int s){//TRACK 2 NES sqr bassdrum,lowconga,highconga\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.6:0.;\n    o+=(n.y==2.)?neslc(n.x)*.3:0.;\n    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\nvec2 track3(float t,float l,int s){//TRACK 3 NES sqr bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?dutybass(freq(n.y+36.)*n.x,n.x)*.35:vec2(0);\n    return o;\n}\nvec2 track4(float t,float l,int s){//TRACK 4 N163 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30chord(freq(n.y+60.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.z+60.02)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.w+60.01)*n.x,n.x)*.25:vec2(0);\n    return o;\n}\nvec2 track5(float t,float l,int s){//TRACK 5 N163 backing\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30bell(freq(n.y+72.05)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 N163 & NES tri melody\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30lead(freq(n.y+48.05)*n.x,n.x)*.6+tri4lead(freq(n.y+60.)*n.x,n.x)*.6:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    vec4  n=vec4(0);  //chord info x:gate yzw:notes\n    o+=e?track1(t,l,s):vec2(0); //TRACK 1 snaredrum,closehh,openhh\n    o+=  track2(t,l,s);         //TRACK 2 bassdrum,lowconga,hiconga\n    o+=e?track3(t,l,s):vec2(0); //TRACK 3 bass\n    o+=  track4(t,l,s);         //TRACK 4 chord\n    o+=  track5(t,l,s);         //TRACK 5 backing\n    o+=  track6(t,l,s);         //TRACK 6 melody\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.4\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    5\n#define DELAY_WET       0.3\n#define DELAY_FEEDBACK  0.9\n#define DELAY_TIME      0.2\nfloat mvol=0.; //for indicator\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n        o+=a*d;\n    }\n    mvol=vol;\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n\n", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 70, 88, 88, 228], [230, 237, 290, 290, 891]], "test": "untested"}
{"id": "3sGyDt", "name": "upsideDownClouds", "author": "Kaeylos", "description": "#5 Sky\nmade during the Ink-MAC-tober 2020", "tags": ["raymarching", "volumetric", "imac"], "likes": 5, "viewed": 336, "published": 3, "date": "1603968667", "time_retrieved": "2024-07-30T20:37:37.346530", "image_code": "// inspired by iq, shane and otherds\n// https://www.shadertoy.com/view/XslGRr\n// https://www.shadertoy.com/view/MscXRH\n\n// #define LOW_QUALITY\n#define CLOUDS_LOD\n#define FBM_MAX_ITER  10\n\n#define MOUSE\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\nfloat gauss(float t, float s) { return exp(-(t*t*s*s)/2.); }\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat max2(vec2 v) { return max(v.x , v.y); }\nfloat max3(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float a, float b, float t) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat mult2(vec2 v) { return v.x*v.y; }\nfloat mult3(vec3 v) { return v.x*v.y*v.z; }\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash4(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = f;\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nfloat perlinNoise(vec2 x) {\n    vec2 id = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash1(id);\n    float b = hash1(id + vec2(1.0, 0.0));\n    float c = hash1(id + vec2(0.0, 1.0));\n    float d = hash1(id + vec2(1.0, 1.0));\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = hermiteInter(f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat perlinNoise(vec3 x) {\n    const vec3 step = vec3(110., 241., 171.);\n\n    vec3 id = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(id, step);\n\n    vec3 u = hermiteInter(f);\n    return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n    vec2 shift = vec2(100.);\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t\t// Rotate and shift to reduce axial bias\n\t\tx = rot2(0.5) * x + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat fbm (vec3 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\nfloat density(vec3 pos, int lod) {\n\tvec3 q = pos - vec3(0.1,0.1,0.4)*iTime;\n\tfloat f = fbm(q, 1., lod);\n\tfloat f2 = fbm(q + vec3(100.), 1., lod);\n\treturn f * (smoothstep(1.5, 2., pos.y + f) + 1. - smoothstep(-1., -0.2, pos.y - 1.5*f2));\n    // return clamp( -0.5 - pos.y + 2.*f, 0.0, 1.0 );\n}\n\nvec4 cloudsMarching(vec3 ro, vec3 rd, vec3 bgCol, vec3 sundir, int steps) {\n\n\tfloat t = 0.;\n\tvec4 sum = vec4(0.);\n#ifdef LOW_QUALITY\n\tsteps = steps/2;\n#endif\n\n\tfor(int i=0; i<steps; i++) {\n\t\tvec3 pos = ro + t*rd;\n\t\t// clamp computation space\n\t   \tif( abs(pos.y)>3. || sum.a>0.99 ) break;\n\n#ifdef LOW_QUALITY\n\t\tint lod = 1;\n#else\n#ifdef CLOUDS_LOD\n\t    int lod = int(exp(-0.005*float((i-350))));\n#else\n\t    int lod = 3;\n#endif\n#endif\n\t\tfloat den = density(pos, lod);\n\t   \tif( den>0.01 ) {\n\t\t\t\n\t\t\t// mix color using density\n\t\t\tvec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n\t\t\t\n        \t// fake lighting using diff of density throught ou sunDir\n\t\t\tfloat dif = clamp((den - density(pos+0.3*sundir, lod))/0.3, 0.0, 1.0 );\n\t\t\tvec3 lin = vec3(0.91,0.98,1.1) + vec3(1.0,0.6,0.3)*dif;\n\t\t\tvec3 lightColor = mix(vec3(0.91,0.98,1.1), vec3(0.65,0.55,0.52)*2.4,dif*1.3);\n\t\t\t\n\t\t\tcol.xyz *= lightColor;\n\t\t\t// exponential decresing of density (mixing with bgcol)\n\t\t\tcol.xyz = mix( col.xyz, bgCol, 1.0-exp(-0.002*t*t) );\n\t\t\tcol.w *= 0.5; // reduce density alpha\n\t\t\tcol.rgb *= col.a; // apply alpha\n\t\t\tsum += col*(1.0-sum.a);\n\t\t}\n\t// Enforce minimum stepsize. This is probably the most important part of the procedure.\n#ifdef LOW_QUALITY\n\tt += max(0.1,0.05*t);\n#else\n\tt += max(0.05,0.02*t);\n#endif\n\t}\n\treturn sum;\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvec4 render(vec3 O, vec3 D) {\n\n\tvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\t\n\tvec3 col = vec3(0.67,0.8,0.9) - D.y*0.4*vec3(0.5,0.2,0.8); // background sky color\n\tfloat sun = clamp( dot(sundir,D), 0.0, 1.0);\n\tcol += 0.3*vec3(1.0,.6,0.1)*pow(sun, 10.0); // add sun\n\n    vec4 res = clamp(cloudsMarching(O, D, col, sundir, 150), 0., 1.);\n    col = col*(1.0-res.w) + res.xyz;// clouds\n     \n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 ); // sun glare   \n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.5; // zoom\n\n#ifdef MOUSE\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    \n    // camera pos\n    vec3 O = 4.0*normalize(vec3(sin(2.5*m.x+1.), 0.15+m.y*0.15, cos(2.5*m.x+1.)));\n#else\n\tvec3 O = 4.0*vec3(2.5, 0.15, 1.);\n#endif\n    vec3 D = computeCamDir(uv, O, vec3(0., 1., 0.), vec3(0.));\n    \n    fragColor = render(O, D);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 232, 255, 255, 268], [269, 269, 293, 293, 313], [314, 314, 338, 338, 353], [354, 354, 379, 379, 399], [400, 400, 426, 426, 466], [467, 467, 492, 492, 525], [526, 526, 557, 557, 586], [844, 844, 864, 864, 889], [890, 890, 910, 910, 945], [946, 946, 966, 966, 985], [986, 986, 1012, 1012, 1040], [1041, 1041, 1079, 1079, 1104], [1105, 1139, 1160, 1160, 1178], [1179, 1179, 1200, 1200, 1222], [1382, 1382, 1404, 1404, 1489], [1491, 1491, 1512, 1512, 1629], [1631, 1631, 1653, 1653, 1756], [1758, 1758, 1779, 1779, 1907], [1909, 1909, 1929, 1929, 2062], [2064, 2064, 2085, 2085, 2204], [2206, 2206, 2227, 2227, 2360], [2362, 2362, 2382, 2382, 2518], [2520, 2520, 2541, 2541, 2665], [2667, 2667, 2688, 2688, 2831], [2833, 2833, 2853, 2853, 3002], [3004, 3004, 3024, 3024, 3173], [3175, 3175, 3196, 3196, 3330], [3332, 3332, 3360, 3360, 3475], [3477, 3477, 3504, 3504, 3899], [3901, 3901, 3928, 3928, 4694], [4696, 4696, 4738, 4738, 5087], [5089, 5089, 5131, 5131, 5379], [5381, 5381, 5415, 5415, 5673], [5675, 5675, 5750, 5750, 7003], [7005, 7005, 7075, 7075, 7354], [7356, 7356, 7385, 7385, 7841], [7843, 7843, 7900, 7900, 8310]], "test": "untested"}
{"id": "Wtd3R2", "name": "Babylon 5", "author": "hubbe", "description": "Babylon 5\nNot finished, but I haven't had time to work on it for a long time, so I decided to publish it.", "tags": ["raymarch", "b5"], "likes": 10, "viewed": 386, "published": 3, "date": "1603951004", "time_retrieved": "2024-07-30T20:37:38.281031", "image_code": "#define R 0.08\n#define CUTR (R/8.0)\n\nconst float pi = 3.1415926535;\n\n\nmat3 rotz(float f) {\n    return mat3(cos(f), sin(f), 0,\n                -sin(f), cos(f), 0,\n                0,0,1);\n}\nmat3 roty(float f) {\n    return mat3(cos(f), 0, sin(f),\n                0,1,0,\n                -sin(f), 0, cos(f));\n}\nmat3 rotx(float f) {\n    return mat3(1,0,0,\n                0, cos(f), sin(f),\n                0, -sin(f), cos(f));\n}\nmat3 scale(float x, float y, float z) {\n    return mat3(x,0,0,\n                0,y,0,\n                0,0,z);\n}\n\nvec3 R4YZ(vec3 p) {\n//    p *= rotx(3.1415);\n    p.z = abs(p.z);\n    p.y = abs(p.y);\n    return p;\n}\n\n\nvec3 R8YZ(vec3 p) {\n    p = R4YZ(p);\n    if (p.y < p.z) {\n        return p.xyz;\n    } else {\n        return p.xzy;\n    }\n\n}\n\nvec3 R4XZ(vec3 p) {\n//    p *= rotx(3.1415);\n//    p.z = abs(p.z);\n//    p.x = abs(p.x);\n    if (p.x < 0.0) p.x = - p.x;\n//    if (p.y > 0.0) p.y = - p.y;\n    if (p.z > 0.0) p.z = - p.z;\n    return p;\n}\n\n\nvec3 R8XZ(vec3 p) {\n    p = R4XZ(p);\n    if (-p.x < p.z) {\n        return p.xyz;\n    } else {\n        return p.zyx;\n    }\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPanelHeight = 0.38;\n\nfloat sdPanelOneEdge(vec3 p) {\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    p.y -= sdPanelHeight;\n    p.x = mod(p.x, 0.2) - 0.1;\n    p.x = abs(p.x);\n    float p1 = sdPlane(p, normalize(vec4( 8,1,0,-0.5)));\n    float p3 = sdPlane(p, normalize(vec4( 2,-1,0,-0.4)));\n    float p2 = abs(p.y) -0.3; // max(-0.3 - p.y, p.y - 0.3);\n//    p.y = abs(p.y);\n//    float p2 = 0.0;\n//    float p2 = min(p.y, 0.3) - p.y;\n    return max(p1, max(p2, p3));\n//    return max(p1, p3);\n}\n\nfloat sdPanelOne(vec3 x) {\n    vec3 p = x;\n    p.y -= sdPanelHeight;\n    p.x = mod(p.x, 0.2) - 0.1;\n    p.x = abs(p.x);\n    float b =  sdBox(p - vec3(0,0,0.3), vec3(0.3,0.3,0.005));\n    float p1 = sdPanelOneEdge(x);\n    return max(b, p1);\n}\n\n\nfloat sdPanel(vec3 p) {    \n    float dist = sdPanelOne(vec3(p.x, abs(p.y), abs(p.z)));\n    float box1 = sdBox(p + vec3(1.5,0,0), vec3(0.3, 0.8, 0.31));\n    dist = max(dist, box1);\n//    float box2 = sdBox(p + vec3(1.5, 0.0, 0.4), vec3(0.1, 0.8, 0.31));\n//    dist = min(dist, box2);\n    return dist;\n}\n\nfloat sdSphere( vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec3 c) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTriPrism( vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec4 opElongate( in vec3 p, in vec3 h) {\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat storage(vec3 p) {\n    p -= vec3(-0.83, 0.25, -0.02);\n    p.z = abs(p.z);\n    float d = sdHexPrism(p.zyx, vec2(0.04, 0.35));\n    p -= vec3(0, 0.08, 0);\n    p.x = mod(p.x, 0.12) - 0.06;\n    float b = sdBox(p, vec3(0.05, 0.1, 0.1));\n    return max(d, b);\n}\n\nfloat topSection(vec3 p) {\n    float s = sdBox(p - vec3(0.31,0.15,0), vec3(0.03,0.1,0.1));\n    \n    p.z = -abs(p.z);\n    vec3 pos = vec3(0.3,0.25,0.0);\n//    float a = sdBox(rotx(0.3) * (p - pos), vec3(0.5,0.05,0.3));\n//    float c = sdBox(rotx(-0.3) * (p - pos), vec3(0.5,0.05,0.3));\n    float b = sdBox(p - pos, vec3(0.5,0.031,0.13));\n    float c = sdBox(p - pos - vec3(0.5,0,0), vec3(0.5,0.13,0.027));\n    float p1 = sdPlane(p - pos, normalize(vec4( -1, -12,0,0.2)));\n    float p2 = sdPlane(p - pos, normalize(vec4( -1, -3, 8, 0.8)));\n    float p3 = sdPlane(p - pos, normalize(vec4( -1, -12, 2, 0.25)));\n    \n    float p4 = sdPlane(p - pos, normalize(vec4( 1, 0, 1.5, 0.25)));\n    float p5 = sdPlane(p - pos, normalize(vec4( 1, 5, 0, 0.25)));\n\n//    return max(a, max(b, c));\n    b=max(b, -c);\n    b=max(b, -p1);\n    b=max(b, -p2);\n    b=max(b, -p3);\n    b=max(b, -p4);\n    b=max(b, -p5);\n    b = min(b, s);\n    \n    b = min(b, storage(p));\n    float x = sdBox(p - pos - vec3(-1.2,0,0), vec3(0.6, 0.010, 0.027));\n    b = min(b, x);\n    \n    \n    vec3 pos2 = vec3(-0.1,0.25,0.0);\n    float q = sdBox(p - pos2, vec3(0.22, 0.035, 0.082));\n    float q1 = sdPlane(p - pos, normalize(vec4(1,3,0,0.5 )));\n    float q2 = sdPlane(p - pos, normalize(vec4(-1,3,0,-0.2 )));\n    float q3 = sdPlane(p - pos, normalize(vec4(-1,-8,0,-0.05 )));\n    float q4 = sdPlane(p - pos, normalize(vec4(0,1,1,0.07 )));\n    float q5 = sdPlane(p - pos, normalize(vec4(0,-1,1,0.1 )));\n    q = max(q, -q1);\n    q = max(q, -q2);\n    q = max(q, -q3);\n    q = max(q, -q4);\n    q = max(q, -q5);\n    b = min(b, q);\n    \n    return b;\n}\n\nfloat hand(vec3 p) {\n    p.z = abs(p.z);\n    float dist = sdBox(p + vec3(0.1, 0.042, 0), vec3(0.13, 0.05, 0.04));\n//    float \n//    dist = max(dist, - sdBox(p + vec3(0.1, 0.042, 0), vec3(0.13, 0.05, 0.04)));\n\n    dist = max(dist,sdPlane(p, normalize(vec4(-1,2,0,  -0.04 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(1,3,0,  -0.04 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(0,3,1,  -0.04 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(1,0,1.5,  -0.06 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(-1,0,8,  -0.35 ))));\n//    dist = max(dist,sdPlane(p, normalize(vec4(0,3,-1,  -0.04 ))));\n        float cut = sdBox(p + vec3(-0.05, 0, 0), vec3(0.04, 0.05, 0.008));\n    dist = max(dist, -cut);\n\n    return dist;\n}\n\nfloat rotating_gray(vec3 p) {\n    p *= rotx(iTime * pi * 2.0 / 45.0);\n    float dist = 100000.0;\n    \n    dist = min(dist, hand((R4XZ(p.yxz) * roty(-pi / 4.0)).yxz - vec3(0.08,0.19,0.0)));\n  return dist;\n}\n\nfloat rotating_section(vec3 p) {\n    p *= rotx(iTime * pi * 2.0 / 45.0);\n    float dist = 100000.0;\n    \n    dist = min(dist, sdBox((R4XZ(p.yxz) * roty(-pi / 4.0)).yxz - vec3(-0.1,0.13,0.0), vec3(0.1, 0.01, 0.03)));\n    dist = min(dist, hand((R4XZ(p.yxz) * roty(-pi / 4.0)).yxz - vec3(0.08,0.19,0.0)));\n    \n    // Rotating section...\n    dist = min(dist, sdSphere(p - vec3(0.08,0.0,0.0), 0.18));\n    dist = min(dist, sdCappedCylinder(p.yxz - vec3(0,0.05,0), 0.11, 0.3));\n\n    // main barrel\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,0.95,0), 0.18/2.0, 0.09, 0.75));\n    \n    // Main barrel segments\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,0.35,0), 0.22/2.0, 0.04, 0.10));\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.025,0), 0.20/2.0, 0.04, 0.07));\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.7,0), 0.22/2.0, 0.04, 0.10));\n    \n//    dist = min(dist, sdBox(p.yxz * roty(-3.1516/8.0) + vec3(0,1.025,0), vec3(0.19, 0.7, 0.01)));\n    dist = min(dist, sdBox(R8XZ(p.yxz) * roty(-pi/8.0) + vec3(0,1.025,0), vec3(0.19, 0.7, 0.01)));\n\n  return dist;    \n}\n\nfloat fingers(vec3 p) {\n    p += vec3(1.5, 0.0, 0.3);\n    p.y = abs(p.y);\n    float dist = sdBox(p, vec3(0.4,0.03,0.015));\n    dist = max(dist, sdPlane(p, normalize(vec4(0.0,0.1,-0.15,-0.004))));\n    dist = max(dist, sdPlane(p, normalize(vec4(0.03,0.0,-0.4,-0.012))));\n//    dist = max(dist, sdPlane(p, normalize(vec4(0.03,0.1,-0.4,-0.012))));\n    dist = max(dist, sdPlane(p, normalize(vec4(0.03,0.25,-0.15,-0.016))));\n\n    return dist;\n}\n\nfloat end_section(vec3 p) {\n    float dist = 10000.0;\n    // X\n    dist = min(dist, sdBox(R4XZ(p.yxz) * roty(-pi/12.0) + vec3(0,1.65,0), vec3(0.1, 0.7, 0.01)));\n    dist = min(dist, sdBox(R4XZ(p.yxz) * roty(-pi*3.0/12.0) + vec3(0,1.65,0), vec3(0.1, 0.7, 0.01)));\n    dist = min(dist, sdBox(R4XZ(p.yxz) * roty(-pi*5.0/12.0) + vec3(0,1.65,0), vec3(0.1, 0.7, 0.01)));\n    \n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.7,0), 0.08/2.0, 0.01, 0.7));\n    \n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,2.4,0), 0.14/2.0, 0.05, 0.01));\n\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.8,0), 0.06/2.0, 0.01, 1.0));\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,2.8,0), 0.12/2.0, 0.01, 0.05));\n    dist = min(dist, fingers(p));\n    return dist;\n}\n\nvec3 dorot(vec3 p) {\n    p = p  * roty(-0.4) * rotx(-pi/8.0);\n    p += vec3(-1,0,0);\n    return p;\n}\n\n// Return actual distance, step\nvec2 map(vec3 p) {\n    // p = vec3(p.x, -p.z, p.y);\n    // Top view\n    //p = p  * roty(0.2) * rotx(-pi/2.0);\n    // view\n    p = dorot(p);\n    \n    float dist = 10000.0;\n    \n    dist = min(dist, sdPanel(p));\n    dist = min(dist, topSection(p));\n    dist = min(dist, rotating_section(p));\n    dist = min(dist, end_section(p));\n    return vec2(dist);\n}\n\nvec4 Color(vec3 hp, vec3 ray_dir) {\n    vec4 c;\n        hp = dorot(hp);\n\n    float panel_dist = sdPanel(hp);\n\tfloat top_section_dist = topSection(hp);\n    float rotating_dist = rotating_section(hp);\n    float storage_dist = storage(hp);\n    \n    if (storage_dist+0.0001 >= top_section_dist &&\n        panel_dist > storage_dist &&\n        rotating_dist > storage_dist) {\n        float x = mod(hp.x + 0.83, 0.12) - 0.06;\n        if (abs(x) < 0.04) return vec4(1,0,0,1);\n        return vec4(0.8, 0.8, 0.8,1);\n    }\n    \n    if (panel_dist < rotating_dist && panel_dist < rotating_dist) {\n       float poe = sdPanelOneEdge(hp);\n        if (poe < -0.01) {\n           vec2 tpos = vec2(dot(hp, 8.0*vec3(0.1,1,0.5)), 8.0 * dot(hp, vec3(1,0.1,0.2)));\n           c = texture(iChannel3, tpos) * mat4(0.2,0,0,0, 0,0.2,0,0, 0.5,0.5,0.8,0, 0,0,0,1);\n           return c;\n        }\n    }\n    \n    if (rotating_dist < panel_dist && rotating_dist < top_section_dist) {\n      hp *= rotx(iTime * pi * 2.0 / 45.0);\n        \n        \n        bool blue = false;\n        if (hp.x > -0.02 && hp.x < 0.18) {\n            int ring = int( (hp.x - 0.08 + (0.2/3.0)) / (0.1/3.0) );\n            int slice = int(50.0 + atan(hp.y,hp.z)*16.0/pi);\n            if ((ring + slice) % 2 == 0 || ring < 1 || ring > 2) {\n                blue = true;\n            }\n        }\n        if (hp.x > -0.21 && hp.x < -0.14) {\n            \tblue = true;\n        }\n        if (hp.x > -0.3 && hp.x < -0.24) {\n            \tblue = true;\n        }\n        if (hp.x > -1.1 && hp.x < -0.945) {\n            \tblue = true;\n        }\n        if (mod(atan(hp.y, hp.z) * 4.0 / pi + 24.0, 1.0) < 0.05) {\n            blue=false;\n        }\n\n        if (blue) {\n            float hand_dist = hand((R4XZ(hp.yxz) * roty(-pi / 4.0)).yxz - vec3(0.08,0.19,0.0));\n            if (rotating_dist != hand_dist) {\n \n              vec2 tpos = vec2(dot(hp, vec3(0.1,1,0.5)), dot(hp, vec3(1,0.1,0.2)));\n  \t       \t    c = texture(iChannel0, tpos) * mat4(0.4,0,0,0, 0,0.4,0,0, 0.3,0.3,0.5,0, 0,0,0,1);\n              return c;\n            }\n        }\n    }\n    \n    vec2 tpos = vec2(dot(hp, vec3(0.1,1,0.5)), dot(hp, vec3(1,0.1,0.2)));\n    c = texture(iChannel0, tpos);\n    return c;\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        vec2 tmp = map(position);\n\t    float distance_to_closest_object = tmp.x;\n        float step_size = hit ? tmp.x : tmp.y;\n\n        if (distance_to_closest_object < 0.001) {\n        \tif (distance_to_closest_object < 0.0) {\n                // We are inside of an object. Go back to the\n                // previous position and stop using tangent distances\n                // so that we can find the surface.\n            \thit = true;\n          \t    travel_distance = last_travel_distance;\n           \t    continue;\n            }\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += step_size;\n    }\n    // We hit something, but then we ran out of iterations while\n    // finding the surface.\n    #if 1\n    return travel_distance;\n        #else\n    if (hit) return travel_distance;\n    // We walked 50 steps without hitting anything.\n    return 0.0;\n    #endif\n}\n\n\nvec3 norm(vec3 pos) {\n    float d = 0.0001;\n    float dist = map(pos).x;\n    return normalize(vec3(map(pos + vec3(d,0,0)).x - dist,\n                          map(pos + vec3(0,d,0)).x - dist,\n                          map(pos + vec3(0,0,d)).x - dist));\n}\n\nfloat shade(vec3 from, vec3 light_pos) {\n    vec3 direction = light_pos - from;\n    float d2 = dot(direction, direction);\n    float dist = sqrt(d2);\n    direction /= dist;\n    \n    float small_step = 0.0005;\n    float dist_from_surface = map(from).x;\n    float dist_closer_to_light = map(from + small_step * direction).x;\n\n    float shading = max(0.0, (dist_closer_to_light - dist_from_surface) / small_step);\n//    float shading = max(0.0, (dist_from_surface - dist_closer_to_light) / small_step);\n    shading += 0.1;\n    shading = min(1.0, shading);\n    \n    float travel_distance = 0.01;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        vec2 tmp = map(position);\n\t    float distance_to_closest_object = tmp.x;\n\n        if (travel_distance >= dist) {\n            break;\n        }\n        if (distance_to_closest_object < 0.001) {\n            return 0.0;\n        }\n        \n        shading = min(shading, 10.0 * distance_to_closest_object / travel_distance);\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += tmp.y;\n\n    }\n    shading = shading / (1.0 + d2 * 0.2);\n    \n    return shading;\n}\n\nvoid planet(out vec4 O,vec2 I)\n{\n    vec4 bg = texture(iChannel2, I / iResolution.xy);\n//    O = bg;    return ;\n    vec2 P =(( I / iResolution.x)/0.8+vec2(-0.9, 0.5)) / 1.0;\n    vec3 RR = vec3(P,sqrt(max(1.-dot(P,P),0.)));\n\tO = mix(\n        texture(iChannel1, .001*iTime+.3*RR.xy/sqrt(RR.z))*max(RR.x*.3+RR.y*.9+RR.z*.1+.5,.1),\n            vec4(.6,.4,.3,1)/dot(P,P*.5),pow(1.-RR.z,2.));\n    if (RR.z == 0.0)\n      O = mix(O, bg, min(1.0, max(0.0, pow((dot(P,P)-1.0),0.2))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -3.5);\n    vec3 light_position = vec3(1.1, 1.1, 1.1);\n\n    // Animate\n  // camera_position.z += iTime/2.0 + iTime * iTime / 200.0;\n // camera_position.x += iTime/2.0;\n\n   light_position += camera_position;\n //   camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 0.9;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance > 50.0) {\n        planet(fragColor, fragCoord);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n    \n    \n    float sunlight = shade(hit_position, light_position);\n\n      fragColor = Color(hit_position, ray_direction);\n     vec3 light_dir = normalize(light_position - hit_position);\n    vec3 normal = norm(hit_position);    \n    vec3 reflection = reflect(ray_direction, normal);\n    float l2 = max(dot(reflection, light_dir), 0.0);\n    float spec = pow(l2, 4.0) * 0.3;\n    \n    fragColor = pow(fragColor * sunlight + vec4(1,1,1,0) * spec, vec4(1.0/2.2));\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////////////\n// Xavier Benech\n// Galaxy Trip\n// Inspired by \"Star Tunnel\" shader from P_Malin\n// https://www.shadertoy.com/view/MdlXWr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n\n// Increase pass count for a denser effect\n#define PASS_COUNT 4\n\nfloat fBrightness = 2.5;\n\n// Number of angular segments\nfloat fSteps = 121.0;\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.5 / 60.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n// fog density\nfloat fDepthFade = 0.8;\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\t\t\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\tfloat fShade = clamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\n\tif (d<3.0)\n\t{\n\t\tfClosestDist = max(abs(vDeltaPos.x),abs(vDeltaPos.y)) / fParticleSize;\n\t\tfloat f = clamp(1.0 - 0.8*fClosestDist, 0.0, 1.0);\n\t\tfShade += f*f*f*f;\n\t\tfShade *= fShade;\n\t}\n\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n}\n\n// Simplex Noise by IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat marble(in vec2 p)\n{\n\treturn cos(p.x+fbm4(p));\n}\n\nfloat dowarp ( in vec2 q, out vec2 a, out vec2 b )\n{\n\tfloat ang=0.;\n\tang = 1.2345 * sin (33.33); //0.015*iTime);\n\tmat2 m1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 0.2345 * sin (66.66); //0.021*iTime);\n\tmat2 m2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\ta = vec2( marble(m1*q), marble(m2*q+vec2(1.12,0.654)) );\n\n\tang = 0.543 * cos (13.33); //0.011*iTime);\n\tm1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 1.128 * cos (53.33); //0.018*iTime);\n\tm2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\tb = vec2( marble( m2*(q + a)), marble( m1*(q + a) ) );\n\t\n\treturn marble( q + b +vec2(0.32,1.654));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\tfloat T = 180.0;\n\t// camera\t\n\tvec3 rd = normalize(vec3( q.x, q.y, 1. ));\n\tvec3 euler = vec3(\n\t\tsin(T * 0.2) * 0.625,\n\t\tcos(T * 0.1) * 0.625,\n\t\tT * 0.1 + sin(T * 0.3) * 0.5);\n\n\tif(iMouse.z > 0.0)\n\t{\n\t\teuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\teuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\teuler.z = 0.0;\n\t}\n\trd = RotateX(rd, euler.x);\n\trd = RotateY(rd, euler.y);\n\trd = RotateZ(rd, euler.z);\n\t\n\t// Nebulae Background\n\tfloat pi = 3.141592654;\n\tq.x = 0.5 + atan(rd.z, rd.x)/(2.*pi);\n\tq.y = 0.5 - asin(rd.y)/pi + 0.512 + 0.001*iTime;\n\tq *= 2.34;\n\t\n\tvec2 wa = vec2(0.);\n\tvec2 wb = vec2(0.);\n\tfloat f = dowarp(q, wa, wb);\n\tf = 0.5+0.5*f;\n\t\n\tvec3 col = vec3(f);\n\tfloat wc = 0.;\n\twc = f;\n\tcol = vec3(wc, wc*wc, wc*wc*wc);\n\twc = abs(wa.x);\n\tcol -= vec3(wc*wc, wc, wc*wc*wc);\n\twc = abs(wb.x);\n\tcol += vec3(wc*wc*wc, wc*wc, wc);\n\tcol *= 0.7;\n\tcol.x = pow(col.x, 2.18);\n\tcol.z = pow(col.z, 1.88);\n\tcol = smoothstep(0., 1., col);\n\tcol = 0.5 - (1.4*col-0.7)*(1.4*col-0.7);\n\tcol = 0.75*sqrt(col);\n\tcol *= 1. - 0.5*fbm4(8.*q);\n\tcol = clamp(col, 0., 1.);\n\t\n\t// StarField\n\tfloat fShade = 0.0;\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0;// + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = 0.; //c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = vec3(0.);\n\t\n\tvec3 red = vec3(0.7,0.4,0.3);\n\tvec3 blue = vec3(0.3,0.4,0.7);\n\tvec3 tint = vec3(0.);\n\tfloat ti = 1./float(PASS_COUNT-1);\n\tfloat t = 0.;\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\ttint = mix(red,blue,t);\n\t\tvResult += 1.1*tint*Starfield(rd, fZPos, fSeed);\n\t\tt += ti;\n\t\tfSeed += 1.234;\n\t\trd = RotateX(rd, 0.25*euler.x);\n\t}\n\t\n\tcol += sqrt(vResult);\n\t\n\t// Vignetting\n\t//vec2 r = -1.0 + 2.0*(uv);\n\t//float vb = max(abs(r.x), abs(r.y));\n\t//col *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor = vec4( col, 1.0 );\n}", "buffer_a_inputs": [{"id": 21480, "src": "https://soundcloud.com/nailz1911/babylon-5-intro-theme", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtd3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 90, 90, 187], [188, 188, 208, 208, 305], [306, 306, 326, 326, 423], [424, 424, 463, 463, 535], [537, 537, 556, 581, 637], [640, 640, 659, 659, 763], [765, 765, 784, 853, 967], [970, 970, 989, 989, 1093], [1095, 1095, 1128, 1154, 1185], [1186, 1186, 1217, 1217, 1304], [1335, 1335, 1365, 1365, 1801], [1803, 1803, 1829, 1829, 2043], [2046, 2046, 2069, 2069, 2348], [2350, 2350, 2384, 2384, 2408], [2410, 2410, 2445, 2445, 2479], [2481, 2481, 2532, 2532, 2639], [2641, 2641, 2704, 2704, 2821], [2823, 2823, 2858, 2858, 3131], [3133, 3133, 3171, 3171, 3451], [3453, 3453, 3488, 3488, 3571], [3573, 3573, 3613, 3715, 3808], [3810, 3810, 3833, 3833, 4069], [4071, 4071, 4097, 4097, 5672], [5674, 5674, 5694, 5694, 6409], [6411, 6411, 6440, 6440, 6616], [6618, 6618, 6650, 6650, 7715], [7717, 7717, 7740, 7740, 8155], [8157, 8157, 8184, 8184, 8927], [8929, 8929, 8949, 8949, 9029], [9031, 9063, 9081, 9184, 9415], [9417, 9417, 9452, 9452, 11619], [11621, 11721, 11759, 11796, 13151], [13154, 13154, 13175, 13175, 13407], [13409, 13409, 13449, 13449, 14766], [14768, 14768, 14800, 14800, 15245], [15248, 15248, 15305, 15305, 16801]], "test": "untested"}
{"id": "Wlt3DM", "name": "Simple Bend", "author": "iq", "description": "A simple way to bend 2D shapes", "tags": ["2d", "bending"], "likes": 56, "viewed": 1260, "published": 3, "date": "1603949582", "time_retrieved": "2024-07-30T20:37:39.074909", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// A simple way to bend 2D space\nvec2 bend( in vec2 p, in float l, in float a )\n{\n    if( abs(a)<0.001 ) return p;  // if perfectly straight\n    \n    float ra = 0.5*l/a;\n    p.x -= ra;\n    \n    vec2 sc = vec2(sin(a),cos(a));\n    vec2 q = p - 2.0*sc*max(0.0,dot(sc,p));\n    \n    float s = sign(a);\n    return vec2( (p.y>0.0) ? ra-s*length(q)        : sign(-s*p.x)*(q.x+ra),\n                 (p.y>0.0) ? ra*atan(s*p.y,-s*p.x) : (s*p.x<0.0)?p.y:l-p.y );\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checker( in vec2 p )\n{\n    vec2 w = fwidth(p) + 0.01;  \n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdArc( in vec2 p, in vec2 scb, in float ra, in float rb )\n{\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 q = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n   \n    // recenter\n    vec2 p = q; p.y += 0.4;\n    // space bend\n    float an = 0.6*sin(iTime*3.0);\n    an *= 1.0 - smoothstep(1.0,2.0,abs(p.x));\n    p = bend(p,2.0,an);\n\n    // star\n    float d = sdStar(p-vec2(0.0,0.4), 0.8, 5, 3.0 ) - 0.05;\n    d = max( d, -sdArc( vec2(abs(p.x)-0.2,p.y-0.44), vec2(0.8,0.6), 0.15, 0.02 ) );\n\td = max( d, -sdArc( vec2(p.x,0.45-p.y), vec2(0.8,0.6), 0.25, 0.05 ) );\n        \n    // coloring\n\tvec3 col = texture(iChannel0,q+0.5).xyz;\n\tif( sin(iTime)<0.0 )\n    {\n        col = vec3(0.6+0.1*checker(p*6.0));\n        col *= 1.0 + 0.1*cos(128.0*d);\n    }\n    col *= 1.0 - 0.75*exp(-10.0*d);\n    if( d<0.0 )\n        col = texture(iChannel0,p+0.5).xyz;\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    col = sqrt(col);\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlt3DM.jpg", "access": "api", "license": "mit", "functions": [[1079, 1112, 1160, 1160, 1531], [1533, 1585, 1613, 1613, 1778], [1780, 1831, 1896, 1896, 2039], [2041, 2092, 2162, 2220, 2654], [2656, 2656, 2713, 2749, 3604]], "test": "untested"}
{"id": "wdVyW3", "name": "pioneer sugar mills limited", "author": "lennyjpg", "description": "https://pbs.twimg.com/media/ElcRDa5W0AAglDO?format=jpg", "tags": ["tunnel", "retro", "lines", "circle", "rectangle", "mirror", "pattern", "mono"], "likes": 2, "viewed": 317, "published": 3, "date": "1603940487", "time_retrieved": "2024-07-30T20:37:40.090195", "image_code": "// https://pbs.twimg.com/media/ElcRDa5W0AAglDO?format=jpg\n\nfloat c(vec2 u, float i){\n    float d = length(u),\n        k = smoothstep(d,d * 1.005, .5),\n        r = 1. - step( max(abs(u.x), abs(u.y)), .5);\n    return i > .7 ? r : max(k,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 res = iResolution.xy,\n        uv = f.xy / min(res.x, res.y),\n        u = (uv - .5) * 1.1;\n    float d = 1.;\n    float r = 1. - step( max(abs(u.x), abs(u.y)), .5);   \n    for(float i = 0. ; i < 1. ; i += 1. / 5.){\n        d = min(d,c(u,i));\n        u *= 1.415;\n    }\n    float m = abs(u.x) < abs(u.y) ? f.x : f.y;\n    float l = min(d, max(r,floor(fract(m / 7.) + .6)));\n    vec3 front = vec3(.35, .31, .22),\n        back = vec3(1., .97, .9);\n    fragColor = vec4(mix(front, back, l), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 84, 84, 239], [241, 241, 290, 290, 789]], "test": "untested"}
{"id": "wdVyWc", "name": "CAM16", "author": "thepheer", "description": "Partial implementaion of CAM16 and CAM16-UCS.\nhttps://observablehq.com/@jrus/cam16\nhttps://arxiv.org/pdf/1802.06067.pdf", "tags": ["cam16"], "likes": 4, "viewed": 337, "published": 3, "date": "1603936941", "time_retrieved": "2024-07-30T20:37:40.984802", "image_code": "#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(x, a, b) ((a) <= (x) && (x) < (b))\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n    \n    float tau = radians(360.0);\n    float J = 0.50 + 0.49*sin(tau*(0.2*uv.x - 0.1*iTime));\n    float M = 0.56*J*(1.0 - J*J); // 0.84*J*(1.0 - J)\n    float h = tau*(fract(uv.x + 0.5*iTime) - 0.5);\n\n    // CAM16 → sRGB → CAM16 → sRGB\n    vec3 JMh1 = vec3(J, M, h);\n    vec3 sRGB1 = XYZ_D65_TO_sRGB*CAM16_UCS_to_XYZ_D65(JMh1);\n    vec3 JMh2 = XYZ_D65_to_CAM16_UCS(sRGB_TO_XYZ_D65*sRGB1);\n    vec3 sRGB2 = XYZ_D65_TO_sRGB*CAM16_UCS_to_XYZ_D65(JMh2);\n\n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    vec3 split = 0.025*vec3(-1.0, 0.0, 1.0);\n    \n    vec3 plots =\n        plot(px.y, uv.y, 0.500)*dotted*0.1 +\n        plot(px.y, uv.y, 0.100)*dotted*0.1 +\n        plot(px.y, uv.y, 0.775 + 1e3*(JMh2 - JMh1) - split) +\n        plot(px.y, uv.y, 0.625 + 1e3*(sRGB2 - sRGB1) - split) +\n        plot(px.y, uv.y, 0.100 + 0.4*sRGB1)*0.5 +\n       \tplot(px.y, uv.y, 0.100 + 0.4*sRGB2)*0.5*dashed;\n\n    vec3 rgb =\n        range(uv.y, px.y + 0.95, 1.00) ? sRGB1 :\n        range(uv.y, px.y + 0.90, 0.95) ? sRGB2 :\n    \tplots;\n\n    rgba = vec4(sRGB_OETF(rgb), 1.0);\n}", "image_inputs": [], "common_code": "#define diag3(v) mat3((v).x, 0.0, 0.0, 0.0, (v).y, 0.0, 0.0, 0.0, (v).z)\n#define xy_to_XYZ(x, y) vec3(x/y, 1.0, (1.0 - x - y)/y)\n\nconst vec3 D65 = xy_to_XYZ(0.31271, 0.32902);\nconst mat3 sRGB = mat3(xy_to_XYZ(0.64, 0.33), xy_to_XYZ(0.30, 0.60), xy_to_XYZ(0.15, 0.06));\nconst mat3 sRGB_TO_XYZ_D65 = sRGB*diag3(inverse(sRGB)*D65);\nconst mat3 XYZ_D65_TO_sRGB = inverse(sRGB_TO_XYZ_D65);\n\nvec3 sRGB_OETF(vec3 c) {\n    vec3 a = 12.92*c;\n    vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));\n}\n\nvec3 sRGB_EOTF(vec3 c) {\n    vec3 a = c/12.92;\n    vec3 b = pow((c + 0.055)/1.055, vec3(2.4));\n    return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));\n}\n\n#define adapt_aux(x) pow(F_L*abs(x), vec3(0.42))\n#define adapt(x) 400.0*sign(x)*adapt_aux(x)/(27.13 + adapt_aux(x))\n#define unadapt(x) sign(x)/F_L*pow(27.13*abs(x)/(400.0 - abs(x)), vec3(1.0/0.42))\n\nconst mat3 M16 = mat3(\n    +0.401288, -0.250268, -0.002079,\n    +0.650173, +1.204414, +0.048952,\n    -0.051461, +0.045854, +0.953127\n);\n\n// sRGB conditions, average surround\nconst vec3 XYZ_w = D65;\nconst float Y_w = XYZ_w.y;\nconst float Y_b = 0.2;\nconst float L_w = 64.0/radians(180.0);\nconst float L_A = L_w*Y_b/Y_w;\nconst float F = 1.0;\nconst float c = 0.69;\nconst float N_c = F;\n\n// step 0*\nconst vec3 RGB_w = M16*XYZ_w;\nconst float D = 1.0; // clamp(F*(1.0 - 1.0/3.6*exp((-L_A - 42.0)/92.0)), 0.0, 1.0);\nconst vec3 D_RGB = D*(Y_w/RGB_w) + 1.0 - D;\nconst float k4 = pow(1.0/(5.0*L_A + 1.0), 4.0);\nconst float F_L = k4*L_A + 0.1*pow(1.0 - k4, 2.0)*pow(5.0*L_A, 1.0/3.0);\nconst float n = Y_b/Y_w;\nconst float z = 1.48 + sqrt(n);\nconst float N_bb = 0.725/pow(n, 0.2);\nconst float N_cb = N_bb;\nconst vec3 RGB_cw = D_RGB*RGB_w;\nconst vec3 RGB_aw = adapt(RGB_cw);\nconst float A_w = dot(vec3(2.0, 1.0, 0.05), RGB_aw)*N_bb;\n\nvec3 XYZ_D65_to_CAM16(vec3 XYZ) {\n    // step 1\n    vec3 RGB = M16*XYZ;\n    // step 2\n    vec3 RGB_c = D_RGB*RGB;\n    // step 3*\n    vec3 RGB_a = adapt(RGB_c);\n    // step 4*\n    const mat3x4 m = 1.0/1980.0*mat3x4(\n        3960.0, 1980.0, 220.0, 1980.0,\n        1980.0, -2160.0, 220.0, 1980.0,\n        99.0, 180.0, -440.0, 2079.0\n    );\n    vec4 aux = m*RGB_a; // p_2, a, b, u\n    float h = atan(aux.z, aux.y);\n    // step 5\n    float e_t = 0.25*(cos(h + 2.0) + 3.8);\n    // step 6*\n    float A = aux.x*N_bb;\n    // step 7\n    float J = pow(A/A_w, c*z);\n    // step 8\n    // step 9*\n    float t = 5e4/13.0*N_c*N_cb*e_t*length(aux.yz)/(aux.w + 0.305);\n    float alpha = pow(t, 0.9)*pow(1.64 - pow(0.29, n), 0.73);\n    float C = 0.01*alpha*sqrt(J);\n    float M = C*pow(F_L, 0.25);\n    return vec3(J, M, h);\n}\n\nvec3 CAM16_to_XYZ_D65(vec3 JMh) {\n    // step 1\n    // step 1-1\n    // step 1-2*\n    float C = JMh.y/pow(F_L, 0.25);\n    float alpha = JMh.x == 0.0 ? JMh.x : 100.0*C/sqrt(JMh.x);\n    float t = pow(alpha/pow(1.64 - pow(0.29, n), 0.73), 1.0/0.9);\n    // step 1-3\n    // step 2*\n    float e_t = 0.25*(cos(JMh.z + 2.0) + 3.8);\n    float A = A_w*pow(JMh.x, 1.0/(c*z));\n    float p_1 = 5e4/13.0*N_c*N_cb*e_t;\n    float p_2 = A/N_bb;\n    // step 3*\n    vec2 cs = vec2(cos(JMh.z), sin(JMh.z));\n    float r = 23.0*(p_2 + 0.305)*t/(23.0*p_1 + t*dot(vec2(11.0, 108.0), cs));\n    vec2 ab = r*cs;\n    // step 4\n    const mat3 m = 1.0/1403.0*mat3(\n        460.0, 460.0, 460.0,\n        451.0, -891.0, -220.0,\n        288.0, -261.0, -6300.0\n    );\n    vec3 RGB_a = m*vec3(p_2, ab);\n    // step 5*\n    vec3 RGB_c = unadapt(RGB_a);\n    // step 6\n    vec3 RGB = RGB_c/D_RGB;\n    // step 7\n    return inverse(M16)*RGB;\n}\n\nvec3 XYZ_D65_to_CAM16_UCS(vec3 XYZ) {\n    vec3 JMh = XYZ_D65_to_CAM16(XYZ);\n    float J = 1.7*JMh.x/(1.0 + 0.7*JMh.x);\n    float M = log(1.0 + 2.28*JMh.y)/2.28;\n    return vec3(J, M, JMh.z);\n}\n\nvec3 CAM16_UCS_to_XYZ_D65(vec3 JMh) {\n    float J = JMh.x/(1.0 - 0.7*(JMh.x - 1.0));\n    float M = (exp(2.28*JMh.y) - 1.0)/2.28;\n    return CAM16_to_XYZ_D65(vec3(J, M, JMh.z));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 223, 223, 1398]], "test": "untested"}
{"id": "tdKcD3", "name": "Jungle explorer game demo", "author": "jarble", "description": "An interactive demo based on my [url=https://www.shadertoy.com/view/3dyyWc]\"Jungle Branches\"[/url] shader.\nUse the mouse and arrow keys to fly through the jungle.", "tags": ["fractal", "tree", "forest", "jungle"], "likes": 4, "viewed": 343, "published": 3, "date": "1603932331", "time_retrieved": "2024-07-30T20:37:41.849490", "image_code": "const float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 surface_color(vec3 p3)\n{\n    p3 = vec3(sceneSDF1(p3*7.0),sceneSDF1(p3/11.0),sceneSDF1(p3/13.0));\n    //surface color\n    return sin((p3+.2)/p3.zyx)/2.0;\n}\n\n\n\n\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3((fragCoord - size / 2.0), -z));\n}\n\nvec3 bump_map(vec3 p3)\n{\n  \t//return vec3(0.0);\n    p3 *= 10.0;\n    return (sin(p3)+sin(p3))/10.0;\n}\n\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    \n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    vec3 rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n\n    \n\n    //ro /= scale;\n    \n    vec3 eye = ro;\n    \n    vec3 worldDir = rd;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    EPSILON1 = EPSILON;\n    \n    if (dist > MAX_DIST - EPSILON1) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a;\n\n    K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//based on https://www.shadertoy.com/view/4lVXRm\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    //m.y = -m.y; //invert up/down key\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (sceneSDF(p) < 1.0) p = prev + estimateNormal(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 2.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 2.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 100.0;\n    \n    //target.y -= 2.0; //gravity\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta;\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    vec4 mouse = iMouse;\n    mouse.x *= -1.0;\n    mouse.x += iResolution.x;\n    mouse /= 8.0;\n\n    \n    if (any(greaterThan(mouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(vm.xy + (mouse.zw - mouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(VMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\nfloat EPSILON1;\nint color;\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)+cos(p)))-2.2;\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    p.x += 20.0;\n    p /= 8.0;\n    for(float i = 1.0; i < 8.0; i*= -2.0){\n        p += (sin(p.yzx/i+i)+cos(p.yzx/i+i))*(i);\n        result = min(sceneSDF1(p/i)-result,-result);\n        //p += p.yzx;\n    }\n    return -(result-1.0)*2.0;\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float depth, float end) {\n    //float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 240, 240, 370], [389, 643, 708, 708, 824], [826, 826, 850, 873, 926], [930, 1422, 1562, 1562, 2152], [2154, 2524, 2609, 2609, 3300], [3302, 3629, 3678, 3713, 3844], [3846, 3846, 3903, 3903, 5023]], "test": "untested"}
{"id": "WsKcD3", "name": "Fab29 #inktober2020 \"shoes\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nReference image: (inspiration)[img]https://contents.mediadecathlon.com/p1555674/637877ca0b0ff380e6113ddb73d40a0b/p1555674.jpg [/img]", "tags": ["short", "golf", "reproduction", "inktober2020"], "likes": 4, "viewed": 308, "published": 3, "date": "1603917453", "time_retrieved": "2024-07-30T20:37:42.699218", "image_code": "\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                    // rotation                  \n#define C(e,r,w)  t = min(t,  max( max(abs( length(q.xy*vec2(1,e))-r) , abs(q.z)-w ) -.3 , \\\n                                   max(-q.y-1., H ) ) )             // 1/2 flat ring band with holes\n#define H         .2 - length(vec2(mod(atan(q.y,q.x),.63)-.31,q.z)) // holes\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s;\n    vec3  R = iResolution, e = vec3(1,-1,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n      //  M =  iMouse.xyz/R -.5,\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),             // ray direction\n          p = 50./R, q,r;                                        // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot( .5+6.*M.y),                                 // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        t = min(t, s = max( length(q.zx/vec2(2.8,1))-6.4, abs(q.y)-.5) ), // sole\n        q.y-=1.5, q.z -= 7., \n        r = q, q.yz*= rot(1.), q.y-=3.,q.z+=1.5, t = C(1,6.,.5), // ankle loop\n        q = r, q.yz*= rot(-.5), q.y += .5, t = C(.8,6.1,1.5),    // main loop\n        q = r, q.z += 16.,\n        q.xz *= rot(-.3), C(2,6.,1.),                            // toes loops\n        q.xz *= rot (.6), C(2,6.,1.),                                  \n        p += .5*t*D;                                             // step forward = dist to obj          \n\n    O = exp(-2.5*O);\n    if ( t!= s ) O *= vec4(1,.5,.5,1);                           // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 370, 406, 406, 1636]], "test": "untested"}
{"id": "WdKcD3", "name": "Fab28 #inktober2020 \"float\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["short", "golf", "inktober2020"], "likes": 8, "viewed": 314, "published": 3, "date": "1603908680", "time_retrieved": "2024-07-30T20:37:43.522019", "image_code": "// variant of https://shadertoy.com/view/wsGyRm\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )           // rotation                  \n#define C(a,l,L)  max(  length((a).xy) -l, abs(a).z -L )   // cylinder\n#define B(a)      max( a.x, max(a.y, a.z) ) -2.            // cube\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a,b,c;\n    vec3  r = iResolution, M = iMouse.xyz/r,\n          D = normalize(vec3( U+U, -3.*r.y ) - r ),      // ray direction\n          p = 50./r, q,q1,q2;                            // marching point along ray \n#define R(t) rot(t*iTime)\n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.02 )\n        q = p, t=9.,\n        q.yz *= rot(.8 + 2. *M.y),                       // rotations\n        q.xz *= rot(   - 6.3*M.x),\n        q = q.xzy,\n        t = max( -C( q, 9.,11.), C( q, 10.,10.)),        // mug\n        t = min(t, a = C( q, 9.,8.)),                    // liquid\n        q1 = q - vec3(2.*cos(.5*iTime+vec2(0,11)),7.5), \n        q2 = q - vec3(6.*sin(.2*iTime+vec2(0,11)),7.5),\n        q1.xy *= R(.1),  q1.yz *= R(.1),\n        q2.xy *= R(-.1), q2.yz *= R(-.1),\n        t = min(t, b = min( B(abs(q1)), B(abs(q2) )) ),  // ice cubes\n        p += t*D;                                        // step forward = dist to obj          \n\n    if(O.x>1.) return;\n    if (a==t) O = vec4(0,.5,.8,0);                       // coloring\n    else if (b==t) O *= vec4(4,4,8,0);\n    else O *= vec4( 0,0,1,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 313, 313, 1428]], "test": "untested"}
{"id": "wdyyWc", "name": "Fab27 #inktober2020 \"music\"score", "author": "FabriceNeyret2", "description": "automatic music score from source music. ( don't expect any accuracy ! )\nFourier analysis (since provided one unusable) + note analysis. efficient warp //ism\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["scroll", "musical", "score"], "likes": 11, "viewed": 922, "published": 3, "date": "1603907245", "time_retrieved": "2024-07-30T20:37:44.270018", "image_code": "// from v0 https://shadertoy.com/view/wsycDy\n// + half tone = * 2^(1./12.)\n\n#define S(r, v)    clamp(  r - (v) * R.y * scale ,0.,1.)\n#define drawL(f)   S(  1.5, abs( f - y ) )\n#define drawN(f)   clamp( R.x/100. - length( vec2( x*(fract(U.x/x-(speed-1.))-.5), (f - y)* R.y * scale ) *mat2(.7,-.7,1,1) ),0.,1. )\n#define B(f)       O *= 1. - drawL(freq(f))          // lines\n\nfloat line(vec2 p, vec2 a,vec2 b) {                  // https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);  // proj coord on line\n    return length(p - b * h);                        // dist to segment\n}\n\n//  --- read note, get (f,r), draw extra horiz segments\n#define prep_note(i,f,r) {                                  \\\n    f =  note(i+8.*16.-speed-1.); /*  last note =127 */     \\\n    r = 1.;                                                 \\\n    if (f>900.) f/=2., r++;     /* higher range of notes */ \\\n /* if (f<240.) f*=2.;                                      \\\n    if ( f < 290.) B( 262.)/r;  /* horiz extra segments */  \\\n    if ( f < 243.) B( 220.)/r;                              \\\n    if ( f < 204.) B( 185.)/r;                              \\\n    if ( f > 790.) B( 880.)/r;                              \\\n    if ( f > 990.) B(1046.)/r;                              \\\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n // U.y = (exp2(U.y/R.y/scale)-1.)*R.y*scale;        // linearize frequencies\n    float x = R.x/speed, \n          y = U.y/R.y / scale,\n          i = floor( U.x / x ),                      // score slot number\n          l = U.x-x*i;\n    int m = (iFrame+int(i)) % 16;                    // pos in current measure\n    \n    O = vec4(1);                                     // background \n    O.gb -= .5 * texelFetch(iChannel1, ivec2(U), 0).r;\n    \n  // if (i<3.) {} else                               // --- draw key \n    {\n        float f,r, F,r0;                             //  --- draw note\n\n        prep_note(i,f,r);\n        O *= 1. - drawN(freq(f)) / r;                // draw body\n        \n        if (l/x<.3)                                  // continue potential left extra segment\n            prep_note(i-1.,F,r0);                    // prev note\n        \n        if ( y > freq(f) && y < freq(f)+.015 && x-l<2. ) O -= 1./r; // tail\n        \n        //int I = ( iFrame+int(i) ) / 4 * 4;\n        F = note(i-1. +8.*16.-speed-1.) / exp2(r-1.);// prev note\n        if ( (iFrame+int(i)) % 4 > 0  // or m > 0. ?\n            && abs(f/F-1.)<.16 )                     // 2-bar quaver\n            O *=  1. - S( 2., abs( line(vec2(l,y-.0135),vec2(0,freq(F)),vec2(x,freq(f))) - .0015) ) /r;\n    }\n    \n    if (  m == 0                                     // --- measure bars \n        && l<1. && y > freq(330.) && y < freq(699.) ) O *= 0.;\n    \n//        E1       G1       B2       D2       F2     // --- draw lines\n       B(330.); B(392.); B(494.); B(588.); B(699.);\n//  C1, D1,    F1       A2       C2       E2    G2  A3 \n// 262. 294.  350.     440.     523.     660.  784.  880.\n   //  B(165.); B(196.); B(247.); B(294.); B(350.);  // range below\n   //  B(660.); B(784.); B(494.); B(988.); B(1398.); // range up\n\n   // O *= 1. - .5* float ( drawL(freq(440.)) ) ;    // draw ref A\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float scale = 6.,\n      speed = 60.; // max 128\n\n#define R          iResolution.xy\n#define T(U)       texelFetch( iChannel0, ivec2(U), 0 )\n#define freq(f)   ( (f) / (iSampleRate/4.) )  // normalized freq. NB: last FFT value in texture = iSampleRate/4\n#define sound(y)   T(  ivec2( int((y)*512.) %64 , int((y)*512.) /64 ) ).r // read spectrum\n#define note(t)    T( ivec2(64 +(int(t)%8) , int(t)/8) ).r                // read music score", "buffer_a_code": "// === frequency analyse + music score production ===================\n// note that both encodings are done so as to optimize warp parallelism:\n// warps are 4x8 pixels blocks and cost 1 eval :coding data as 1 single line would cost 8 times more\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float f;\n    if (U.x < 64. && U.y < 8.) {      // --- Fourier analysis of signal -------------\n        U -= .5;\n        f = ( U.x + 64.*U.y) /4.;                 // freq to analyze ( optim warps parallelisme )\n        vec2 v = vec2(0.);\n        for (float k = 0.; k  < 512.; k++ )       // compute fourier transform in .g\n            v += sin( f *6.28*k/512.+ vec2(0,1.5708) )\n            * ( 2.* texelFetch(iChannel1, ivec2(k,1), 0).r - 1. );\n\n        O.r = length(v) / 32.;  \n    //  O.r = exp2(length(v)/64.)/2.;\n    //  O.r = (1.- exp2(-length(v)/32.)) *.7+.3;\n    //  O.r = log2(1.+length(v)/32.) *.7+.3;  // <<\n    //  O.r = length(v) *f/64.;  \n    }\n    else if (U.x < 72. && U.y < 16.) { // --- music score ---------------------------\n        U -= .5; U.x -= 64.;\n        if ( U == vec2(7,15) ) {                  // analyse current note   \n            float m = 1., f = 1., v;\n            for (float k=0.; k  < 1489.; k++ ) {  // search note in spectrum\n                v = sound(freq(k));\n             // if ( v > m ) m = v, f = k;        // unweighted max intensity\n                if ( v*k > m*f ) m = v, f = k;    // maxy int weighted by 1/f\n            }\n            O.r = f;\n        }\n        else \n            O.r =  note( U.x + 8.*U.y +1.) ;      // offset with time\n    }\n    else discard;\n}\n", "buffer_a_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// --- just to display scrolling spectrum\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float x = R.x/speed, \n          y = U.y/R.y / scale;\n    O = texelFetch(iChannel1, ivec2(U + vec2(x,0)), 0);  \n    if ( U.x < (speed-1.)*x ) return;                   // scroll  \n    O.r =  sound(y);                                    // update right band\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 408, 466, 635], [1316, 1316, 1354, 1432, 3231]], "test": "untested"}
{"id": "tsGyW3", "name": "CHILL MIND by Kamel Ghabte", "author": "kamelghabte", "description": "CHILL MIND BY KAMEL GHABTE", "tags": ["cineshader"], "likes": 8, "viewed": 12484, "published": 3, "date": "1603876358", "time_retrieved": "2024-07-30T20:37:45.099800", "image_code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.9*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.9 + 0.5 * cos((b + iTime * 9.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"MY MIND\",\n\t\"description\": \"Kamel Ghabte\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 188, 188, 212], [215, 215, 234, 234, 569], [571, 571, 601, 601, 883], [885, 885, 942, 942, 1660]], "test": "untested"}
{"id": "3sycWc", "name": "1 sample fuzzed reflections", "author": "NLIBS", "description": "A simple technique for fuzzed reflections by adding a small sphere to the reflected ray.\nOne improvement would be to use a 16 bit texture, but for only one sample 8 bits is fine.\n", "tags": ["raytracing", "reflections", "bluenoise", "rng"], "likes": 4, "viewed": 458, "published": 3, "date": "1603865603", "time_retrieved": "2024-07-30T20:37:46.053251", "image_code": "vec3 viewPos = vec3(0,0,-1.8);\n\n#define DISPLAY_GAMMA 2.2\n#define GOLDEN_RATIO 1.6180339887\n#define EXPOSURE 1.\n\n#define BLUE_NOISE\n#define SAMPLES 1\n#define FUZZ .1\n\n\nfloat trace(vec3 rd, vec3 ro) {\n    float r = 1.;\n\tfloat c = dot(ro, ro) - r*r;\n\tfloat b = dot(rd, ro);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n    float t2 = -b + sqrt(abs(d));\n    t = (t<=0.) ? t2 : t;\n\treturn mix(0.0, t, step(0.,min(t,d)));\n}\n\nvec3 _sample(vec3 rd) {\n\tvec3 col = texture(iChannel0,rd).rgb;\n    col = pow(col*1.6,vec3(DISPLAY_GAMMA+2.));\n    \n    return col;\n}\n\n//------------------------ \"High-quality hash function\" by nojima\nuvec4 murmurHash44(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 4 inputs\nvec4 hash44(vec4 src) {\n    uvec4 h = murmurHash44(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n//-------------------------\n\nvec4 bluehash (ivec3 v) {\n    vec4 n = texelFetch(iChannel1, v.xy%1024, 0);\n    //Gamma correction here if needed\n    n = fract(n+GOLDEN_RATIO*float(v.z));\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.xx;\n    \n    float a = (iMouse.z>0.) ? iMouse.x/iResolution.x*3.141593 : iTime;    \n    \n    mat2 mat = mat2(cos(a),-sin(a),sin(a),cos(a));\n    vec3 ro = viewPos;\n    ro.xz = mat * ro.xz;\n    \n    vec3 rd = normalize(vec3(uv,.8));\n    rd.xz = mat * rd.xz;\n    \n    float t = trace(rd,ro);\n    \n    vec3 col;\n    \n    if (t>0.) {\n        //Hit pos and normal\n        vec3 p = ro + rd*t;\n        vec3 n = normalize(p);\n\n        //Summing up a couple reflection rays\n        vec3 acc = vec3(0);\n        vec3 reflect_rd = reflect(rd,n);\n        int frameInt = (iFrame%4)*SAMPLES; //720 works for both 60 and 144fps\n        \n        for (int i = 0; i<SAMPLES; i++) {\n            #ifdef BLUE_NOISE\n            \tvec4 hash = bluehash(ivec3(fragCoord,i+frameInt)); \n            \t//hash += hash44(vec4(uv,float(i)/float(SAMPLES),iTime))/256. - 1./512.;\n            #else\n            \tvec4 hash = hash44(vec4(uv,float(i)/float(SAMPLES),iTime));\n            #endif\n            \n            \n            \n            vec3 sph = normalize(hash.xyz*2.-1.)*pow(hash.w,0.3333);\n            vec3 fuzz_rd = normalize(reflect_rd+sph*FUZZ);\n        \tacc += _sample(fuzz_rd);    \n        }\n        acc/=float(SAMPLES);\n\n        //Colours calc\n        col = acc * vec3(0.7);\n    } else {\n        //Background\n        col = _sample(rd);\n    }\n    \n    \n    //Tone mapping\n    col = vec3(1.0) - exp(-col * EXPOSURE);\n    //Gamma correction\n\tcol = pow(col, vec3(1./DISPLAY_GAMMA));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 199, 199, 423], [425, 425, 448, 448, 557], [559, 625, 656, 656, 939], [941, 964, 987, 987, 1104], [1134, 1134, 1159, 1159, 1305], [1308, 1308, 1365, 1365, 2920]], "test": "untested"}
{"id": "WdyyDc", "name": "Desert dunes", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wdKyDG]\"Cratered moonscape\"[/url] terrain. This is a fairly realistic desert landscape using a [url=https://www.shadertoy.com/view/XdycWy]two-pass raymarching[/url] technique.", "tags": ["terrain", "landscape", "desert", "dune"], "likes": 3, "viewed": 431, "published": 3, "date": "1603864885", "time_retrieved": "2024-07-30T20:37:47.034627", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*1000.0;\n    return sin(vec3(planet_surface(p)*2.0+.5,planet_surface(p)*2.0,planet_surface(p*10.0)*2.0))/12.0+vec3(.7,.5,.3)*1.6;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON*32.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\tif(iters < 6){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else{\n                return depth;\n            }\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float speed = 10.0;\n    float t1 = iTime/10.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    //float dist = length(eye-p); //lower quality\n    \n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*.1; //to prevent rendering artifacts\n\nvec3 warp(vec3 a){\n    return (sin(a)+cos(a));\n}\n\nfloat planet_surface(vec3 p){\n    p += warp(p.yzx/500.0)*500.0;\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx))*size;\n    return length(p) + p.y - size;\n}\n\nfloat sceneSDF(vec3 p,int iter) {\n    p /= scale;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 6; k++){\n        result -= min(-result,planet_surface(p*i))/(i*i);\n        i *= -1.5;\n        if(k == iter) break;\n    }\n    return (result-p.y*2.0)*scale/4.0;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,6);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*1000.0;\n    return sin(vec3(planet_surface(p)*2.0+.5,planet_surface(p)*2.0,planet_surface(p*10.0)*2.0))/12.0+vec3(.7,.5,.3)*1.6;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON*32.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth*scale)*image_scale) {\n\t\t\tif(iters < 6){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else{\n                return depth;\n            }\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dmap = depth_map(fragCoord);\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    float speed = 10.0;\n    float t1 = iTime/10.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-3.0, -1.0, 3.0*sin(t1/3.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    \n    float l0 = length(eye-dmap.xyz); //distance to point in last frame\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w; //distance between points in consecutive frames\n    float dist = sceneSDF(eye);\n    float l2 = l0-50.0;\n    \n    \n    dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(p, max(0.0,l0-dist));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 87, 87, 233], [236, 657, 748, 748, 1279], [1294, 1548, 1613, 1613, 1745], [1747, 1836, 1865, 1865, 2175], [2177, 2669, 2809, 2809, 3419], [3421, 3791, 3876, 3876, 4291], [4293, 4620, 4669, 4704, 4835], [4837, 4837, 4864, 4864, 5013], [5015, 5015, 5072, 5072, 5720]], "test": "untested"}
{"id": "WdGyDc", "name": "Rainbow Shards", "author": "jarble", "description": "This is another edit of my [url=https://www.shadertoy.com/view/3dyyWc]\"Jungle Branches\"[/url] fractal.", "tags": ["fractal"], "likes": 5, "viewed": 302, "published": 3, "date": "1603859672", "time_retrieved": "2024-07-30T20:37:47.783624", "image_code": "\n\nvec3 surface_color(vec3 p3)\n{\n    p3 = vec3(sceneSDF1(p3*7.0),sceneSDF1(p3/11.0),sceneSDF1(p3/13.0));\n    //surface color\n    return sin((p3+.2)/sin(p3.zyx))/2.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float c1 = 3.0;\n    float t1 = iTime/2.0;\n    vec3 eye = vec3(sin(t1/c1),sin(t1/c1)*c1,cos(t1/c1)*c1);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length(abs(sin(p.yzx))-abs(cos(p))))-1.0;\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    p.x += 40.0;\n    p /= 8.0;\n    for(float i = 1.0; i < 8.0; i*= -2.0){\n        float i1 = i*i;\n        p += (sin(p.yzx/i1)+cos(p.yzx/i1))*(i1);\n    \tresult = max(sceneSDF1(p*i1)/i1,result);\n    }\n    return -(result-.1)*2.0;\n}", "buffer_a_code": "\n\nvec3 surface_color(vec3 p3)\n{\n    p3 = vec3(sceneSDF1(p3*7.0),sceneSDF1(p3/11.0),sceneSDF1(p3/13.0));\n    //surface color\n    return sin((p3+.2)/sin(p3.zyx))/2.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    \n    \n    float c1 = 3.0;\n    float t1 = iTime/2.0;\n    vec3 eye = vec3(sin(t1/c1),sin(t1/c1)*c1,cos(t1/c1)*c1);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 31, 31, 166], [168, 589, 680, 680, 1041], [1056, 1310, 1375, 1375, 1507], [1509, 1598, 1627, 1627, 1937], [1939, 2431, 2571, 2571, 3161], [3163, 3533, 3618, 3618, 4376], [4378, 4705, 4754, 4789, 4920], [4922, 4922, 4949, 4949, 5098], [5100, 5100, 5157, 5157, 5830]], "test": "untested"}
{"id": "3dyyWc", "name": "Jungle branches", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/wdyyDV]\"vine jungle\"[/url] fractal, with more realistic-looking branches.", "tags": ["fractal", "tree", "jungle"], "likes": 5, "viewed": 351, "published": 3, "date": "1603851209", "time_retrieved": "2024-07-30T20:37:48.763006", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    \n    \n    float c1 = 3.0;\n    vec3 eye = vec3(sin(iTime/c1),sin(iTime/c1)*c1,cos(iTime/c1)*c1);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nint s1(int t,int s){\n\treturn (t/s>>t*s);\n}\nvec2 sound1(int t,int t2)\n    {\n    int t1 = t;\n    for(int i = 4; abs(i) <= 128; i *= t2){\n        t1 |= s1(t,i);\n    }\n    t1 |= t/1024;\n    //t = (t|s1(t,4)|s1(t,8)|s1(t,16)|s1(t,32)|s1(t,64)|s1(t,128)|t/1024);\n    return vec2(float(t1 & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    int t = int(time*12000.0);\n    return sound1(t,2);\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 200;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)+cos(p)))-2.2;\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    p.x += 20.0;\n    p /= 8.0;\n    for(float i = 1.0; i < 2.0; i*= -2.0){\n        p += (sin(p.yzx/i+i)+cos(p.yzx/i+i))*(i);\n    \tresult = max(result,sceneSDF1(p*i)/i);\n    }\n    \n    return -(result-.8)*2.0;\n}\nvec3 surface_color(vec3 p3)\n{\n    p3 = vec3(sceneSDF1(p3*7.0),sceneSDF1(p3/11.0),sceneSDF1(p3/13.0));\n    //surface color\n    return sin((p3+.2)/p3.zyx)/2.0;\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n\tfragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    \n    \n    float c1 = 3.0;\n    vec3 eye = vec3(sin(iTime/c1),sin(iTime/c1)*c1,cos(iTime/c1)*c1);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 480, 571, 571, 931], [947, 947, 974, 974, 1123], [1125, 1125, 1182, 1182, 2077]], "test": "untested"}
{"id": "tdycWV", "name": "Bouncing Dots (2nd Reality)", "author": "xjorma", "description": "Remake of my favorite \"Second Reality\" effect, unfortunately need a beefy PC to run fullscreen.\nhttps://youtu.be/KTjnt_WSJu8?t=383", "tags": ["demoscene", "particles", "demo", "demoeffect", "dots", "bouncing", "secondreality", "future", "reproduction", "crew"], "likes": 8, "viewed": 718, "published": 3, "date": "1603850584", "time_retrieved": "2024-07-30T20:37:49.626696", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA 0\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\n\nvec3 Fog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nbool floorIntersect(in vec3 ro, in vec3 rd, out float t) \n{\n    if(rd.y < -0.01)\n    {\n        t = ro.y / - rd.y;\n        return true;\n    }\n    return false;\n} \n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist, int frame)\n{\n    float \tt = 0.;\n    vec3\tpi;\n    bool\tcolPlane = false;    \n    if(floorIntersect(ro, rd, t))\n    {\n        pi = ro + rd * t;\n        colPlane = true;\n    }\n    \n    \n    \n    float mint = dist;\n    float sha = 1.;\n    vec3  c = vec3(0);\n    for(int i = 0; i < nbPart; i++)\n    {\n        vec3 pos = Load(i).xyz;\n        float t = sphIntersect( ro, rd, pos, BALL_RADIUS).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            c = pos;\n        }\n        if(colPlane)\n        {\n            float lifeSpan;\n        \tif (i > (frame % nbPart))\n            {\n                lifeSpan = float(i - (frame % nbPart)) / float(nbPart);\n            }\n            else\n            {\n                lifeSpan = float(512 + i - (frame % nbPart)) / float(nbPart);\n            }\n            float fadeGap = 0.05;\n            float sc = BALL_RADIUS * smoothstep(0.0, fadeGap, lifeSpan) * smoothstep(1.0, 1.0 - fadeGap, lifeSpan);\n\n            t = sphIntersect( pi, normalize(vec3(0.2,1,0.1)), pos, sc).x;\n          \tif(t > 0.)\n            {\n                sha = 0.7;\n            }\n        }\n    }\n    \n    vec3\tcol = vec3(0);\n    if(mint<dist)\n    {\n        vec3 i = (ro + mint * rd);\n        vec3 n = normalize(i - c);\n        vec3 r = reflect(rd, n);\n        col = texture(iChannel1, r).rgb;\n    }\n    else if(colPlane)\n    {\n        mint = t;\n        col = vec3(0.3) * sha;\n    }\n    col = Fog(col, mint, vec3(0)); \n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n\t    int f = iFrame % wrapFrame;\n        float a1 = sin(float(f) * 1./60.f) * radians(90.);\n        float a2 = (float(f - 1900) * 1./60.f) * 3. ;\n\t\tfloat theta\t= mix(a1, a2, clamp((float(f) - 1900.) / 100., 0., 1. ));\n        float phi\t= radians(70.);\n\n        vec3 ro = 2.2 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3(0,0.8,0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        vec3 rd =  ca*normalize(vec3(p,1.5));              \n        vec3 col = Render(ro ,rd ,ca[2],12., f);\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n\ttot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n\n", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24304, "src": "https://soundcloud.com/hexen-1/second-reality-future-crew", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\nconst float restitution = 13. / 16.;\nconst float dropper\t\t= 1.f;\nconst float scale\t\t= 1. / 40.;\nconst float baseGravity\t= 9.8 / 200.;\n\nfloat intToRad(in int a)\n{\n\treturn float(a) * tau / 1024.;\n}\n\nvec4 spawnNewParticle(in int f)\n{\n    vec4 dotInfo;\n    if(f < 500)\n    {\n        dotInfo.x = sin(intToRad(f*11)) * 40. * scale;\n        dotInfo.y = cos(intToRad(f*13)) * 10. * scale + dropper;\n        dotInfo.z = sin(intToRad(f*17)) * 40. * scale;\n        dotInfo.w = 0.;\n    }\n    else if(f < 900)\n    {\n        dotInfo.x = cos(intToRad(f*15)) * 55. * scale;\n        dotInfo.y = dropper;\n        dotInfo.z = sin(intToRad(f*15)) * 55. * scale;\n        dotInfo.w = 2.5;\n    }\n    else if(f < 1700)\n\t{\t\n        float a = sin(intToRad(f)) * 256. / 8.;\n        dotInfo.x = cos(intToRad(f*66)) * a * scale;\n        dotInfo.y = 0.;\n        dotInfo.z = sin(intToRad(f*66)) * a * scale;\n        dotInfo.w = 5.;\n\t}\n    else if(f < 2360)\n    {\n        dotInfo.xyz= (hash31(float(f)) - 0.5) * 2. * 3.;\n        dotInfo.w = 0.;    \n    }\n    else\n    {\n        dotInfo = vec4(vec3(4000.), 0);\n    }\n    \n\treturn dotInfo;\n}\n\nvec4 update(in vec4 dotInfo, in int f)\n{\n    float oldY = dotInfo.y;\n    float gravity = baseGravity * smoothstep(2000., 1900., float(f));\n    dotInfo.y += dotInfo.w / 200.;\n    dotInfo.w -= gravity;\n    if(dotInfo.y < 0.)\n    {\n        float r = oldY / (oldY - dotInfo.y);\n        dotInfo.y = -dotInfo.y * restitution;\n        dotInfo.w = (-2. * gravity * (1. - r) - dotInfo.w)  * restitution;\t\t// This make the bounce almost perfect, this point that annoyed my eye a little in the original demo. But let say, it's an old demo from the integer time, much easier to fix today :)\n    }\n    return dotInfo;\n}\n  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + MAX_PER_ROW * fragCoord.y);\n    if( fragCoord.x >= MAX_PER_ROW || pixId >= nbPart)\n    {\n        discard;\n    }\n    vec4\tdotInfo;\n    if(iFrame == 0)\n    {\n        dotInfo = vec4(vec3(4000.), 0);\n    }\n    else\n    {\n        dotInfo = Load(pixId);\n    }\n    \n   \n    int f = iFrame % wrapFrame;\n    \n    if((f % nbPart) == pixId)\n    {\n        dotInfo = spawnNewParticle(f);\n    }\n\n\tdotInfo = update(dotInfo, f);\n    \n    fragColor = dotInfo;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst int\twrapFrame = 3000;\nconst int\tnbPart = 512;\nconst float\ttau = radians(360.);\n#define MAX_PER_ROW\t\t256.\n#define BALL_RADIUS\t\t0.01\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdycWV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[128, 128, 150, 150, 239], [243, 243, 293, 293, 389], [392, 392, 451, 451, 552], [556, 556, 616, 616, 2066], [2069, 2069, 2111, 2111, 2275], [2277, 2277, 2321, 2321, 2420]], "test": "untested"}
{"id": "3sVyWK", "name": "RNG using sine", "author": "kmccord1", "description": "testing randomness", "tags": ["fun"], "likes": 1, "viewed": 259, "published": 3, "date": "1603847203", "time_retrieved": "2024-07-30T20:37:50.478419", "image_code": "float rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 normal = fragCoord/iResolution.xy;\n   vec3 col = vec3(rand(fragCoord.xy + (iTime * 0.1)), rand(fragCoord.xy + (iTime * 0.1) - 500.0), rand(fragCoord.xy + (iTime * 0.1) - 1000.0));\n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 90], [91, 91, 148, 148, 368]], "test": "untested"}
{"id": "3sGcD3", "name": "wobblyer thingy", "author": "UrbanClubProfessional", "description": "Remix of \"wobbly thing\" by avix.", "tags": ["procedural", "3d", "demoscene", "wobble", "demo", "remix", "glitch", "green", "fork", "weird", "party"], "likes": 2, "viewed": 318, "published": 3, "date": "1603843967", "time_retrieved": "2024-07-30T20:37:51.307203", "image_code": "#define FARCLIP    45.0\n\n#define MARCHSTEPS 70\n#define AOSTEPS    9\n#define SHSTEPS    20\n#define SHPOWER    4.0\n\n#define PI         4.14\n#define PI2        PI*0.6    \n\n#define AMBCOL     vec3(2.0,2.0,2.0)\n#define BACCOL     vec3(2.0,2.0,2.0)\n#define DIFCOL     vec3(2.0,2.0,2.0)\n\n#define MAT1       2.0\n\n#define FOV 2.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat cylinder(vec3 p, vec2 h) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n/***********************************************/\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=2./l;\n\tfloat ofs=s+s/(r*3.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n\nfloat hash(float n) { \n\treturn fract(sin(n)*53758.5453123); \n}\n\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(4.0-3.0*f);\n    float n = p.x + p.y*67.0 + p.z*213.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  2.0),f.x),\n                        mix( hash(n+ 67.0), hash(n+ 68.0),f.x),f.y),\n                    mix(mix( hash(n+213.0), hash(n+214.0),f.x),\n                        mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sminp(float a, float b) {\n    const float k=0.2;\n    float h = clamp( 0.6+0.6*(b-a)/k, 0.0, 2.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/***********************************************/\n\nvec2 DE(vec3 p) {\n    \n    //distortion\n    float d3=noise3(p*3.0 + iTime)*0.28;\n    //shape\n    float h=torus(p, vec2(4.0,2.5)) -d3;\n    float h2=torus(p, vec2(4.0,2.45)) -d3;\n        vec3 q=p.yzx; p.yz=q.yx;\n        oprep2(p.xy,42.0,0.25, 0.0);\n        oprep2(p.yz,24.0,0.25, 0.0);\n        float flag=p.z;\n        float k=rbox(p,vec3(0.06,0.06,2.0),0.0) ;\n        if (flag>0.2) k-=flag*0.28; else k-=0.02 ;\n\n    //pipes\n    p=q.zyx;\n\n    oprep2(p.xy,4.0,9.5, 4.0);\n    oprep2(p.xz,22.0,0.35, 0.0);\n        \n    p.y=mod(p.y,0.4)-0.6*0.4;\n    float k2=rbox(p,vec3(0.22,0.22,2.0),0.06) - 0.02;\n\n    p=q.xzy;\n    float r=p.y*0.03+sin(iTime)*0.06;\n        oprep2(p.zy,4.0,9.5, 0.0);\n    float g=cylinder(p,vec2(2.15+r,27.0)) - sin(p.y*2.3 - iTime*5.0)*0.2 -d3;\n    float g2=cylinder(p,vec2(2.05+r,28.0)) - sin(p.y*2.3 - iTime*5.0)*0.2 -d3;\n\n      float tot=max(h,-h2);\n      float sub=max(g,-g2);\n        float o=max(tot,-g);\n        float i=max(sub,-h);\n        \n            o=max(o,-k);\n            i=max(i,-k2);\n      \n      tot=sminp(o,i);\n\n\treturn vec2( tot*1.0 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.02,-0.02,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 2.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.02 + 2.2*pow(float(i)/float(AOSTEPS),2.5);\n        \tfloat dd = DE( p+n*h ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.75;\n    \t}\n   return clamp( 2.0 - 2.0*ao, 0.0, 2.0 );\n //  return clamp(ao,0.0,1.0);\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 2.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.03*SHPOWER;\n    }\n    return clamp( res, 0.0, 2.0 );\n}\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -2.0 + 3.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -25.0);\n\tvec3 lig=normalize(vec3(3.3, 4.0, 0.0));\n\t\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n//\trot(lig,vec3(mp.x,mp.y,0.0));\n\t\n    float a=iTime*0.6;\n    float b=sin(iTime*0.35)*0.85;\n\trot(ro,vec3(a,b,0.0));\n\trot(lig,vec3(a,b,0.0));\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,2.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 3.5*cf );\n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\t\t\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\tif( r.x<FARCLIP ) {\n\t    vec2 rs=vec2(0.3,2.0);  //rim and spec\n\t\tif (r.y==MAT1) { col=vec3(0.39,0.73,0.101);  } \n\n\t\tvec3 nor=normal(ww);\n\n    \tfloat amb= 2.0;\t\t\n    \tfloat dif= clamp(dot(nor, lig), 0.0,2.0);\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,2.0);\n    \tfloat rim= pow(1.+dot(nor,rd), 4.0);\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.6, 2.0 ) ,26.0 );\n    \tfloat ao= calcAO(ww, nor);\n    \tfloat sh= calcSh(ww, lig, 0.02, 3.0, 5.0);\n\n\t    col *= 0.6*amb*AMBCOL*ao + 0.5*dif*DIFCOL*sh + 0.06*bac*BACCOL*ao;\n\t    col += 0.4*rim*amb * rs.x;\n    \tcol += 0.6*pow(spe,2.0)*sh * rs.y;\n        \n\t}\n\t\n\tcol*=exp(.09*-r.x); col*=3.0;\n\t\n\tfragColor = vec4( col, 2.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 373, 410, 410, 461], [462, 462, 491, 491, 560], [561, 561, 593, 593, 645], [647, 697, 751, 751, 903], [905, 905, 926, 926, 967], [969, 969, 991, 991, 1393], [1395, 1395, 1426, 1426, 1542], [1596, 1596, 1613, 1635, 2670], [2671, 2721, 2742, 2742, 2888], [2889, 2939, 2969, 2969, 3269], [3270, 3320, 3381, 3381, 3595], [3596, 3646, 3679, 3679, 3907], [3908, 3958, 4015, 4015, 5527]], "test": "untested"}
{"id": "tsGyzt", "name": "mass_spring_system_1", "author": "balkhan", "description": "differrent masses", "tags": ["2d", "springs"], "likes": 8, "viewed": 374, "published": 3, "date": "1603830056", "time_retrieved": "2024-07-30T20:37:52.282595", "image_code": "// Fork of \"mass_spring_system_0\" by balkhan. https://shadertoy.com/view/3ljXDm\n// 2020-10-23 13:40:46\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2 rotate(vec2 v, float alpha);\nfloat line(vec2 p1, vec2 p2, vec2 p, float thickness);\n\n#define SHOW_LINES\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2\tR = iResolution.xy;\n    vec2\tu = 1.*(f.xy-.5*R) / R.y;\n    vec3 idl;\n    float ma,md = 1e5;\n    o = vec4(0.);\n    \n    for( float i = .0; i < NUM*NUM; i++)\n    {\n        vec2 cd = vec2(floor((i)/NUM) , mod(i, NUM) );\n        ma = texture(iChannel0, (cd+vec2(.0, NUM))/R).x+(cd.x <= .0 ? 1. : .0)*.0+(cd.y <= .0 ? 2. : .0)*.0;\n        vec2 pos = texture(iChannel0, cd/R).xy-vec2((cd.x <= 0. ? .125:.0), (cd.y <= 0. ? .125:.0) );\n        float bl = length(u - pos*SC)-(6.*ma)/R.x;\n    \tmd = min(md,\n                 bl\n                 );\n        if (md == bl && md < (4.)/R.x)\n        idl.x = i+floor(iTime);\n        #ifdef SHOW_LINES\n        vec2 apos = texture(iChannel0, vec2(cd.x+0., cd.y-1.)/R ).xy-vec2((cd.x <= 0. ? .125:.0), (cd.y-1. <= 0. ? .125:.0) );\n        float l0 = 1.-(line(apos*SC, pos*SC, u, 4./R.x) );\n        \t\t        md = min(md,\n\t\t                 l0\n                        );\n        apos = texture(iChannel0, vec2(cd.x-1., cd.y-0.)/R ).xy-vec2((cd.x-1. <= 0. ? .125:.0), (cd.y <= 0. ? .125:.0) );\n        float l1 = 1.-(line(apos*SC, pos*SC, u, 4./R.x));\n        md = min(md,\n\t\t                 l1\n                        );        \n        #endif\n        if (md < 0.001)\n            break;\n    }\n    #ifdef SHOW_LINES\n    if (f.x < NUM*16. && f.y < NUM*2.*16.)\n\to.xyz = (texelFetch(iChannel0, ivec2(f.xy/16.), 0).xyz/3.)+.5*(f.y <= NUM*16.?1.:.0);\n    else\n    #endif\n    o.xyz += .75-1.*vec3(smoothstep( .01, .005, md))*1.0*(sin( idl.x*.5*vec3(0.5, 1., 2.) +1.570 ) );\n}\n\nvec2 rotate(vec2 v, float alpha)\n{\n\tfloat vx = v.x*cos(alpha)-v.y*sin(alpha);\n\tfloat vy = v.x*sin(alpha)+v.y*cos(alpha);\n\tv.x = vx;\n\tv.y = vy;\n\treturn v;\n}\n\nfloat line(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = -atan(lineVector.y,lineVector.x);\n\tp = rotate(p,angle);\n\t\n\tfloat dx = 0.0;\n\tif(p.x<0.0)\n\t\tdx = abs(p.x);\n\telse if(p.x>length(lineVector))\n\t\tdx = abs(p.x) - length(lineVector);\n\t\t\n\treturn ( thickness/(dx+abs(p.y)) );\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n* BUFFER A : 2D Particle System\n*/\n\n\n// for reading clarity's sake, not rly useful\nstruct\tparticle\n{\n    vec2\tpos;\n    vec2\tacc;\n    vec2\tvit;\n    float\tma;\n};\n\n#define Ma 1.\n#define Gr vec2(.0, -.98)\n#define Xrs 1. // X rest straight\n#define Xrd sqrt(2.) // X rest diagonal\n#define DIST .3\n\n    void\tinit_pos(inout vec2 pos, vec2 ij)\n{\n    pos.x = ij.x*DIST-.5*NUM*DIST;\n    pos.y = ij.y*DIST-.5*NUM*DIST;\n}\n\nvoid\tinit(inout particle part, vec2 f)\n{\n    part.acc = vec2(0.);\n\tpart.vit.xy = vec2(0.);\n    init_pos(part.pos, f);\n    part.ma = 1.+abs((NUM-f.x)/5.+(f.y-NUM)/5.);\n}\n\nvec2 DistanceConstraint(vec2 x, vec2 x2, float restlength, float stiffness)\n{\n    vec2 delta = x2 -x;\n    float deltalength = length(delta);\n    float diff = (deltalength-restlength) /deltalength;\n    return delta*stiffness*diff;\n}\n\nvec2 summ_current_minus_rest_spring_len(vec2 f, vec2 R, particle parts)\n{\n    vec2 summ_pos = vec2(.0);    \n    vec2 fpos = texture(iChannel0, (f+vec2(0., 0.))/R.xy ).xy;\n    float xrest = 1.;\n    for(float i = 0.; i < 9.; i++)\n    {\n        vec2 cd = vec2(float(int((i))%3-1), float(int(i/3.)-1));\n        vec2 idf = f + cd;\n        if(idf.x < .0 || idf.x > NUM || idf.y < .0 || idf.y > NUM)\n            continue;\n        if (cd.x == cd.y && cd.x == 0.)\n            continue;\n        float ma = texture(iChannel0, (f+cd+vec2(.0, NUM) )/R).x;\n        if (abs(cd.x) == abs(cd.y) && abs(cd.x) == 1.) // diagonals\n            xrest = Xrd*DIST;\n        else\n            xrest = Xrs*DIST;\n       \tcd = texture(iChannel0, (f+cd)/R.xy ).xy; // need a vec2, reusing cd var\n            summ_pos += DistanceConstraint(fpos, cd, xrest, 1./(abs(ma-parts.ma)+.125)+.05 );\n    }\n\treturn summ_pos/8.;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    particle parts;\n    vec4\ttexture_buff;\n    vec2\tR = iResolution.xy;\n    //o -= o;\n    o = vec4(0.);\n    if (f.x > NUM || f.y > NUM+NUM)\n        discard;\n    if (float(iFrame) <= 10.)\n    {\n\t\tinit(parts, f);\n\t    o.xy += parts.pos;\n\t\to.zw += parts.vit;\n        if (f.y > NUM)\n        {\n            o -= o;\n        \to.x = parts.ma;\n        }\n        return;\n    }\n    \n    if (f.y > NUM)\n    {\n        o = -o;\n        o.x = texture(iChannel0, f/R ).x;\n        return;\n    }\n    parts.ma = texture(iChannel0, (f+vec2(.0, NUM) )/R).x;\n    texture_buff = texture(iChannel0, f/R.xy ).xyzw;\n    parts.pos = texture_buff.xy;\n  \tparts.vit = texture_buff.zw;\n    if (f.y >= NUM-1.5 && (f.x <= 1. || f.x >= NUM-1.5 )) // top first and last node need to not moove\n    {\n        o = vec4(parts.pos, .0, .0);\n        return;\n    }\n    parts.acc = \n            parts.ma*Gr*iTimeDelta*.001\n            +\n            summ_current_minus_rest_spring_len(f, R, parts)*iTimeDelta\n            ;\n    parts.vit.xy += parts.acc.xy;\n\tparts.pos.xy += parts.vit.xy;\n\t    \to.xy += parts.pos.xy;\n\t\t\to.zw += parts.vit.xy;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Be aware that NUM spawns NUM*NUM balls draw check and 2 * NUM * NUM lines draw check per pixel\n#define NUM 10.\n\n#define SC .25", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyzt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1879, 1879, 1913, 1913, 2034], [2036, 2036, 2091, 2091, 2363]], "test": "untested"}
{"id": "wdKcWV", "name": "Sunset City", "author": "Dragonpeak", "description": "2D sunset City", "tags": ["2d", "sunset", "city"], "likes": 7, "viewed": 350, "published": 3, "date": "1603827030", "time_retrieved": "2024-07-30T20:37:53.146286", "image_code": "\n#define time iTime*0.1\nconst int COUNT = 10;\nconst float SCALE = 32.;\n\nfloat rand(float x)\n{\n\treturn fract(sin(x)*1276818.27865);\n}\n\nfloat rand2(vec2 x)\n{\n\treturn fract(sin(dot(x ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.x;\n\n    \n    vec3 col = vec3(0.2);\n    int l = 0;\n    float r = 0.;\n    for(int i = 0; i < COUNT; i++)\n    {\n        vec2 coord = uv*SCALE/float(i);\n        coord.x += time*float(i);\n\t\tint l2 = max(l, int(step(rand(floor(coord.x))*uv.y*2.*float(i), 0.1))*i);\n        if(l2 != l)\n        {\n\t\t\tr = clamp(rand2(floor(coord*vec2(8, 32)))-0.8, 0., 1.)*4.;\n        }\n        \n        \n        l = l2;\n        \n\n    }\n    col = vec3(l)/float(COUNT);\n    \n    float sun = clamp(length((uv-vec2(0.5, 0.1))*vec2(0.5, 1.))*1.3, 0., 1.);\n    vec3 sky = mix(vec3(.6, 0.3, 0.4)*3., vec3(0.1, 0.1, 0.4), sun)*0.7;\n    col = vec3(sky);\n    \n    if(l > 0)\n    {\n\t\tcol = vec3(0.3);\n        col = mix(col, vec3(0.8, 0.8, 0.2)*2., r);\n        col = mix(sky, col, float(l)/float(COUNT)*0.5);\n    }\n    \n   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 93, 93, 132], [134, 134, 155, 155, 220], [224, 224, 281, 281, 1162]], "test": "untested"}
{"id": "llBXRm", "name": "Colored Cube on a Checkerboard", "author": "Nauja", "description": "Simulation of a colored cube moving on a checkerboard.\n\nThe cube move one step forward, then one step rightward, then one step forward, ...", "tags": ["cube", "checkerboard", "colored"], "likes": 6, "viewed": 413, "published": 3, "date": "1603823295", "time_retrieved": "2024-07-30T20:37:54.163566", "image_code": "/**\n * Simulation of a colored cube moving on a checkerboard.\n *\n * The cube move one step forward, then one step rightward, then one step forward, ...\n *\n * Although the cube seems to rotate infinitely, it only rotates by 90° (either forward or\n * rightward) during [0, PI] seconds then go back to its initial rotation. The cube always stays\n * at position (0, 0, 0) but move a little upward during its rotation.\n *\n * The floor moves one tile backward or leftward during [0, PI] seconds then go back to its\n * initial position.\n *\n * So we have an infinite loop where everything move during [0, PI] seconds then go back to\n * the initial state.\n *\n *\n * The forward movement follows a periodic function looking like:\n *\n *     /         /         /\n *    /         /         /\n *   /         /         /\n *  /         /         /\n * /    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n *\n *\n * The rightward movement follows a periodic function looking like:\n *\n *          /         /         /\n *         /         /         /\n *        /         /         /\n *       /         /         /\n * _____/    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n *\n * So every PI seconds, the cube is moving either forward or rightward.\n *\n * To create the illusion that the cube is moving one tile forward and one tile rightward each\n * step, many equations include an offset of 1.0 if sin(time) > 0.0. You can set ENABLE_FLOOR_OFFSET\n * to 0.0 to disable this offset for the floor and you will see that its position is reset each time.\n */\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define SPEED 1.0 // how fast is the simulation\n#define ENABLE_FLOOR_OFFSET 1.0\n#define PI 3.1415926535897932384626433832795\n#define PI2 6.28318530718\n\n//------------------------------------------------------------------\n\n// possible shapes\n#define SHAPE_VOID 0.0\n#define SHAPE_FLOOR 1.0\n#define SHAPE_CUBEFRAME 2.0\n// cube faces are arranged in the order they will touch the floor\n#define SHAPE_CUBEFACEDOWN 3.0\n#define SHAPE_CUBEFACEFRONT 4.0\n#define SHAPE_CUBEFACERIGHT 5.0\n#define SHAPE_CUBEFACEUP 6.0\n#define SHAPE_CUBEFACEBACK 7.0\n#define SHAPE_CUBEFACELEFT 8.0\n\n// intersected shape\nstruct Shape\n{        \n    float d; // distance\n    float t; // type of shape\n    vec3 c; // color\n};\n\n// colors of each face of the cube\nconst vec3 CubeFaces[6] = vec3[6](\n    vec3(1.0, 0.65, 0.0), // yellow, down\n    vec3(0.14, 1.0, 0.0), // green, front\n    vec3(1.0, 0.0, 0.0), // red, right\n    vec3(1.0, 1.0, 1.0), // white, up\n    vec3(0.0, 0.55, 1.0), // blue, back\n    vec3(1.0, 0.31, 0.0) // orange, left\n);\n\n//------------------------------------------------------------------\n\n// create a quaternion\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\nvec3 rotate(in vec3 p, in vec4 q)\n{\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\nShape opU( Shape d1, Shape d2 )\n{\n    if (d1.d<d2.d) {\n        return d1;\n    }\n    return d2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n\n// test intersection with a box https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// test intersection with the black frame of the cube\nfloat sdCubeFrame(vec3 p, vec3 b)\n{    \n    return opSubtraction(\n        sdBox(p, b * vec3(0.9, 0.9, 1.1)),\n        opSubtraction(\n            sdBox(p, b * vec3(0.9, 1.1, 0.9)),\n            opSubtraction(\n                sdBox(p, b * vec3(1.1, 0.9, 0.9)),\n                sdBox(p, b)\n            )\n        )\n    );\n}\n\n// test intersection with the colored cube\nShape sdColoredCube( in vec3 pos )\n{\n    Shape res = Shape( 1e10, SHAPE_VOID, vec3(0.0, 0.0, 0.0) );\n\n    {\n      res = opU( res, Shape( sdCubeFrame( pos, vec3(0.25, 0.25, 0.25) ), SHAPE_CUBEFRAME, vec3(0.0, 0.0, 0.0 )) );\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.24, 0.0), vec3(0.225, 0.01, 0.225)), SHAPE_CUBEFACEDOWN, vec3(0.0, 0.0, 0.0 ) )); // yellow, down\n      res = opU( res, Shape( sdBox( pos+vec3(-0.24, 0.0, 0.0), vec3(0.01, 0.225, 0.225)), SHAPE_CUBEFACEFRONT, vec3(0.0, 0.0, 0.0)) ); // green, front\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.0, 0.24), vec3(0.225, 0.225, 0.01)), SHAPE_CUBEFACERIGHT, vec3(0.0, 0.0, 0.0 ) )); // red, right\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.0, -0.24), vec3(0.225, 0.225, 0.01)), SHAPE_CUBEFACELEFT, vec3(0.0, 0.0, 0.0 ) )); // orange, left\n      res = opU( res, Shape( sdBox( pos+vec3(0.24, 0.0, 0.0), vec3(0.01, 0.225, 0.225)), SHAPE_CUBEFACEBACK, vec3(0.0, 0.0, 0.0 ) )); // blue, back\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, -0.24, 0.0), vec3(0.225, 0.01, 0.225)), SHAPE_CUBEFACEUP, vec3(0.0, 0.0, 0.0 ) )); // white, up\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------\n\n/**\n * calculate the forward movement\n * \n *     /         /         /\n *    /         /         /\n *   /         /         /\n *  /         /         /\n * /    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n */\nfloat advanceX(in float time)\n{\n    return mod(min(time - floor(time / PI2) * PI, PI * ceil(time / PI2)) * ceil(sin(time)), PI) / 2.0;\n}\n\n/**\n * same as advanceX but without the reset every [PI, 2PI]\n *\n * This is used to compute the forward movement when time == PI without having the\n * reset to 0.\n */\nfloat advanceX2(in float time)\n{\n    return (time - floor(time / PI2) * PI) / 2.0;\n}\n\n/**\n * calculate the rightward movement\n * \n *          /         /         /\n *         /         /         /\n *        /         /         /\n *       /         /         /\n * _____/    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n */\nfloat advanceZ(in float time)\n{\n    return mod(min(time - PI - floor((time - PI) / PI2) * PI, PI * ceil((time- PI) / PI2)) * (1.0 - ceil(sin(time))), PI) / 2.0;\n}\n\n// test intersection with the scene\nShape map( in float time, in vec3 pos )\n{\n    Shape res = Shape( 1e10, SHAPE_VOID, vec3(0.0, 0.0, 0.0) );\n\n    {\n        pos += vec3(0.0, -0.25, 0.0);\n        pos += vec3(0.0, -0.10, 0.0) * abs(sin(time));\n    \tpos = rotate(pos, q_mul(\n            quat(vec3(0.0, 0.0, 1.0), advanceX(time)),\n        \tquat(vec3(1.0, 0.0, 0.0), advanceZ(time))\n       \t));\n    \tres = opU( res, sdColoredCube(pos) );\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nShape raycast( in float time, in vec3 ro, in vec3 rd )\n{\n    Shape res = Shape(-1.0,SHAPE_VOID,vec3(0.0,0.0, 0.0));\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = Shape( tp1, SHAPE_FLOOR, vec3(1.0, 1.0, 1.0) );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            Shape h = map( time, ro+rd*t );\n            if( abs(h.d)<(0.0001*t) )\n            { \n                res = Shape(t,h.t, h.c); \n                break;\n            }\n            t += h.d;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in float time, in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( time, ro + rd*t ).d;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in float time, in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(time, pos+0.0005*e).d;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in float time, in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map(time, pos + h*nor ).d;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in float time, in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in float time, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    Shape res = raycast(time, ro,rd);\n    float t = res.d;\n    if( res.t != SHAPE_VOID )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (res.t == SHAPE_FLOOR) ? vec3(0.0,1.0,0.0) : calcNormal(time, pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = res.c;\n        float ks = 1.0;\n        \n        /**\n         * Every PI time, our cube is moving forward or rightward.\n         * \n         * shift is used to shift the first row to the left if == 1\n         */\n        float shift = ceil(sin(time)) * ENABLE_FLOOR_OFFSET;\n        float face = floor(time / PI);\n        if (res.t > SHAPE_CUBEFRAME)\n        {\n            if (res.t == SHAPE_CUBEFACEUP)\n            {\n            \tcol = CubeFaces[int(mod(face + 3.0, 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEDOWN)\n            {\n            \tcol = CubeFaces[int(mod(face, 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEFRONT)\n            {\n            \tcol = CubeFaces[int(mod(face + 1.0 + mod(face, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEBACK)\n            {// 1 - 3, 2-3; 3-5, 4-5, 5-1, 6-1\n            \tcol = CubeFaces[int(mod(face + 4.0 + mod(face, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACELEFT)\n            {\n            \tcol = CubeFaces[int(mod(face + 4.0 + mod(face + 1.0, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACERIGHT)\n            {\n            \tcol = CubeFaces[int(mod(face + 1.0 + mod(face + 1.0, 2.0), 6.0))];   \n            }\n        }\n        else if(res.t == SHAPE_FLOOR)\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n            \n            vec3 pos2 = pos;\n       \t\tpos2 += vec3(-0.25, 0.0, -0.25);\n            pos2 += vec3(0.5, 0.0, 0.0) * advanceX(time) / advanceX2(PI);\n       \t\tpos2 += vec3(0.0, 0.0, -0.5) * advanceZ(time) / advanceX2(PI);\n            float tileX = floor((pos2.x + 0.5) / 0.5f);\n            float tileZ = floor(-pos2.z / 0.5f) + shift;\n       \t\t//pos += vec3(0.0, 0.0, -1.0) * time * max(ceil(-1.0*sin(time)), 0.0) / 5.0;\n            float f = checkersGradBox( time, 1.7*pos.xz, 1.7*dpdx.xz, 2.5*dpdy.xz /* blur */);\n            col = 0.15 + f*vec3(0.05); // luminance + f * contrast\n            ks = 0.4; // godray ?\n            float f1 = floor(mod((pos2.x + 0.5 * shift) / 0.5, 2.0));\n            float f2 = clamp(floor(mod((pos2.z + 0.5 * f1) / 0.5, 2.0)), 0.15, 0.25);\n            col = vec3(f2, f2, f2);\n            /**\n             * tileX <= 0.0 && tileZ <= 0.0 : only tiles behind the cube\n             * abs(tileX - tileZ) <= 1.0 : only the diagonal\n             * tileZ >= tileX : one tile up, then one left, then one up, ...\n             */\n            if (tileX <= 0.0 && tileZ <= 0.0 && abs(tileX - tileZ) <= 1.0 && tileZ >= tileX)\n            {\n                /**\n                 * tileX + tileZ : initial color of the tile\n                 * + face : shift by the current cube face that is down\n                 * - shift : shift by one for odd rows\n                 */\n             \tcol = CubeFaces[int(mod(tileX + tileZ + face - shift, 6.0))];   \n            }\n        }\n\n        // lighting\n        float occ = calcAO( time, pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow(time, pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow(time, pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*4.0*SPEED;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 2.5*cos(0.1/**time*/), 1.3, 2.5*sin(0.1/**time */) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( time, ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2708, 2731, 2765, 2765, 2816], [2818, 2818, 2844, 2844, 2876], [2878, 2878, 2899, 2899, 2924], [2926, 2926, 2962, 2962, 3220], [3222, 3222, 3257, 3257, 3312], [3314, 3314, 3347, 3347, 3410], [3412, 3412, 3455, 3455, 3477], [3480, 3558, 3589, 3589, 3680], [3682, 3736, 3771, 3771, 4053], [4055, 4098, 4134, 4134, 5244], [5316, 5524, 5555, 5555, 5660], [5662, 5829, 5861, 5861, 5913], [5915, 6150, 6181, 6181, 6312], [6314, 6350, 6391, 6391, 6775], [6877, 6925, 6976, 6976, 7181], [7183, 7183, 7239, 7239, 8119], [8121, 8166, 8259, 8282, 8675], [8677, 8723, 8770, 8770, 9346], [9348, 9348, 9405, 9405, 9719], [9721, 9773, 9852, 9873, 10106], [10108, 10108, 10188, 10207, 15311], [15313, 15313, 15365, 15365, 15542]], "test": "untested"}
{"id": "3sVcWK", "name": "Glassy Glassy", "author": "NLIBS", "description": "I hard coded only 2 bounces so it isn't perfect, but sure looks good to me.\n", "tags": ["reflection", "refraction", "light", "glass", "fresnel"], "likes": 10, "viewed": 651, "published": 3, "date": "1603795210", "time_retrieved": "2024-07-30T20:37:54.986366", "image_code": "#define N_AIR 1.0\n#define N_GLASS 1.51\n#define exposure 1.\n#define DISPLAY_GAMMA 2.2\n#define irr N_AIR/N_GLASS\n\nconst vec3 GLASS_COL = vec3(.0196,.0314,.4);\nconst vec3 GLASS_REF = pow(GLASS_COL,vec3(0.6));\n\nfloat trace(vec3 rd, vec3 ro) {\n    float r = 1.;\n\tfloat c = dot(ro, ro) - r*r;\n\tfloat b = dot(rd, ro);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n    float t2 = -b + sqrt(abs(d));\n    t = (t<=0.) ? t2 : t;\n\treturn mix(0.0, t, step(0.,min(t,d)));\n}\n\nfloat fresnel(vec3 rd, vec3 n,float n1, float n2){\n    float I = acos(abs(dot(rd, n))-0.0001);\n    float cosI = cos(I);\n    float cosR = n1/n2 * sin(I);\n    if(cosR > 1.0) return 1.0; // total internal reflection\n    cosR = sqrt(1.0 - cosR * cosR);\n    float Rs = (n1*cosI - n2 * cosR)/(n1*cosI + n2 * cosR);\n    float Rp = (n1*cosR - n2 * cosI)/(n1*cosR + n2 * cosI);\n    return mix(Rs*Rs, Rp*Rp, 0.5);\n}\n\nvec3 _sample(vec3 rd) {\n\tvec3 col = texture(iChannel0,rd).rgb;\n    col = pow(col*1.6,vec3(DISPLAY_GAMMA+2.));\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 U ) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*U-R)/R.x;\n    float a = (iMouse.z>0.) ? iMouse.x/R.x*3.14 : iTime;    \n    vec3 viewPos = vec3(0,0,-1.8);\n    \n    mat2 mat = mat2(cos(a),-sin(a),sin(a),cos(a));\n    vec3 ro = viewPos;\n    ro.xz = mat * ro.xz;\n    \n    vec3 rd = normalize(vec3(uv,.8));\n    rd.xz = mat * rd.xz;\n    \n    float t = trace(rd,ro);\n    \n    vec3 col;\n    \n    if (t>0.) {\n        //Hit pos and normal\n        vec3 p = ro + rd*t;\n        vec3 n = normalize(p);\n\n        //Bounce 1\n        float fresnel_1 = fresnel(rd,n,N_AIR,N_GLASS);\n        vec3 reflect_rd = reflect(rd,n);\n        vec3 refract_rd = refract(rd,n,irr); \n        p = p+rd*0.001;\n        t = trace(refract_rd,p);\n\n        //Refract hit pos and normal\n        vec3 p2 = p + refract_rd*t;\n        vec3 n2 = -normalize(p2);\n\n        //Bounce 2\n        float fresnel_2 = fresnel(refract_rd,n,N_GLASS,N_AIR);\n        vec3 reflect_2_rd = reflect(refract_rd,n2);\n        vec3 refract_2_rd = refract(refract_rd,n2,1./irr);\n\n        //Colours calc\n        vec3 reflect_col = _sample(reflect_rd) * GLASS_REF;\n        vec3 reflect_2_col = _sample(reflect_2_rd);\n        vec3 refract_2_col = _sample(refract_2_rd);\n\n        //Fresnel\n        col = mix(refract_2_col,reflect_2_col,fresnel_2);\n\n        //Fresnel and Attenuation\n        col *= pow(GLASS_COL,vec3(t));\n        col = mix(col,reflect_col,fresnel_1);\n    } else {\n        //Background\n        col = _sample(rd);\n    }\n    \n    \n    //Tone mapping\n    col = vec3(1.0) - exp(-col * exposure);\n    //Gamma correction\n\tcol = pow(col, vec3(1./DISPLAY_GAMMA));\n    \n    \n    O = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 238, 238, 462], [464, 464, 514, 514, 869], [871, 871, 894, 894, 1003], [1007, 1007, 1048, 1048, 2679]], "test": "untested"}
{"id": "3dKyDK", "name": "Fast 3D water - 421 Chars", "author": "Ric3cir121", "description": "Fast 3D water generated with a procedural cosine noise", "tags": ["procedural", "3d", "raytracing", "raymarching", "noise", "waves", "wave", "sea", "fast", "water", "light", "ocean", "blue", "blue", "realistic", "chars"], "likes": 22, "viewed": 862, "published": 3, "date": "1603786758", "time_retrieved": "2024-07-30T20:37:55.743342", "image_code": "#define r(A)     mat2( C=cos(A), S=sin(A), -S, C )           //\n//#define r(a)   mat2( cos( a + vec4(0,11,33,0) ) )          // bug: https://www.shadertoy.com/view/ttGyzh\n#define w(c,a) ( R.xy = r(a) * c.xz + iTime,  abs( cos( R.y + cos( R.x ) ) ))  //\n#define W(c)   ( w(c,9.) + w(c,7.) + w(c,h) )                //\n#define D(c)     W(h*c) + W(c)*.1 + 9. + c.y\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float h = .3, f = h, C,S; \n    vec3 m = u.xyy/iResolution.x - .5, c=m-m, R;\n    m.z -= .4; m.xz *= r(iTime*h);\n    \n    for( m /= length(m) ; \n         f++ < 30. && (C=D((c+h))) > .1 ; \n         c += m * C );\n    \n    o = min((D(c)+h)*9., 0.) * min(m.x+.6, 0.) \n      + .1* vec4( C= c.y+12. , 2.+C , 4 , 1 )\n      + f/50. - length(c)/7e2 ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 401, 401, 747]], "test": "untested"}
{"id": "tsGcWV", "name": "MIS scene with blue noise", "author": "koiava", "description": "white noise vs blue noise.\nScene is from my old shader : https://www.shadertoy.com/view/4sSXWt", "tags": ["motionblur", "mis", "rendering", "bluenoise", "directlight", "veach"], "likes": 36, "viewed": 1579, "published": 3, "date": "1603782497", "time_retrieved": "2024-07-30T20:37:56.782564", "image_code": "//Implementation of Multiple Importance Sampling technique(E.Veach 1995)\n//example shows MIS for direct light calculation\n//Idea behind technique is that every monte-carlo sampling technique has \n//variance and this variance comes from low probability of success.\n//So if you have 2 or more unbiased monte-carlo sampling techniques \n//which gives you different response on same situation you can predict \n//which of those responses contains more variance and weight them\n//correspondingly to decrease overal variance and stay unbiased.\n#define PIXEL_SAMPLES 1\n#define LIGHT_SAMPLES 1\n#define BSDF_SAMPLES 1\n#define FRAME_TIME 0.05\t//for motion blur\n//#define IMPORTANCE_SAMPLE_LIGHTS\n#define SHADOWS\n\n//light sampling technique *******************\n#define IMPORTANCE_SAMPLE_LIGHT_SOURCE\n//#define SAMPLE_LIGHT_AREA\n#define SAMPLE_LIGHT_SOLIDANGLE\n//********************************************\n\n#define SHOW_PLANES\n#define SHOW_TEXT\n\n#define GAMMA 2.2\nconst vec3 backgroundColor = vec3( 0.2 );\n\n//used macros and constants\n#define HALF_PI \t\t\t1.5707963\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001\n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(abs(a-(b))<eps)\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n\n#define MATERIAL_COUNT \t\t8\n#define BSDF_COUNT \t\t\t3\n#define BSDF_R_DIFFUSE \t\t0\n#define BSDF_R_GLOSSY \t\t1\n#define BSDF_R_LIGHT \t\t2\n\n//***********************************\n//sampling types\n#define SAMPLING_BLUE_NOISE\t\t\t0\n#define SAMPLING_WHITE_NOISE\t\t1\n#define SAMPLING_NONE\t\t\t\t2\nint samplingTechnique;\nfloat split;\n\nvoid initSamplingTechnique(float p) {\n    float k = iMouse.x/iResolution.x;\n    if(iMouse.z<0.0 /*|| iMouse.x==0.0*/) {\n      \tsplit = iResolution.x * 0.5;\n    } else {\n        split = iMouse.x;\n    }\n    \n    if(p < split-1.0) {\n        samplingTechnique = SAMPLING_WHITE_NOISE;\n    } else if(p > split+1.0) {\n        samplingTechnique = SAMPLING_BLUE_NOISE;\n    } else {\n        samplingTechnique = SAMPLING_NONE;\n    }\n}\n//***********************************\n\n#define LIGHT_COUNT (4)\n#define LIGHT_COUNT_INV (0.25)\n#define WALL_COUNT \t(2)\n\n//MIS heuristics *****************************\n#define MIS_HEURISTIC_BALANCE\n//#define MIS_HEURISTIC_POWER\n\nfloat misWeightPower( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\nfloat misWeightBalance( in float a, in float b ) {\n    float ab = a + b;\n    \n    return a / ab;\n}\nfloat misWeight( in float pdfA, in float pdfB ) {\n#ifdef MIS_HEURISTIC_POWER\n    return misWeightPower(pdfA,pdfB);\n#else\n    return misWeightBalance(pdfA,pdfB);\n#endif\n}\n//********************************************\n            \n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n// Color corversion code from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//************************************************************************************\n\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\n// Data structures ****************** \nstruct Sphere { vec3 pos; float radius; float radiusSq; float area; };\nstruct LightSamplingRecord { vec3 w; float d; float pdf; };\nstruct Plane { vec4 abcd; };\nstruct Range { float min_; float max_; };\nstruct Material { vec3 color; float roughness_; int bsdf_; };\nstruct RaySurfaceHit { vec3 N; vec3 E; int mtl_id; int obj_id; float dist; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; float fovV; };\n//***********************************\n    \n// ************ SCENE ***************\nPlane walls[WALL_COUNT];\nSphere lights[LIGHT_COUNT];\n\n#ifdef SHOW_PLANES\n#define PLANE_COUNT (3)\nPlane planes[PLANE_COUNT];\nRange planeZRanges[PLANE_COUNT];\nfloat planeHalfWidth = 2.3;\n#endif\n//***********************************\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool raySphereIntersection( Ray ray, in Sphere sph, out float t ) {\n    t = -1.0;\n\tvec3  ce = ray.origin - sph.pos;\n\tfloat b = dot( ray.dir, ce );\n\tfloat c = dot( ce, ce ) - sph.radiusSq;\n\tfloat h = b*b - c;\n    if( h > 0.0 ) {\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn ( t > 0.0 );\n}\n\nbool rayPlaneIntersection( Ray ray, Plane plane, out float t ){\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   \n    if ( abs( dotVN ) < EPSILON ) {\n        return false;\n    }\n    \n\tt = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;\n    \n    return ( t > 0.0 );\n}\n// ***************************************************************************\n\nvoid updateScene(float t) {\n    //init lights\n    t *= 4.0;\n\n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+t*speed;    \n    lights[0].pos = vec3( -2.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+t*speed;    \n    lights[1].pos = vec3( -1.1, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+t*speed;    \n    lights[2].pos = vec3( 0.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+t*speed;    \n    lights[3].pos = vec3( 1.6, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n}\n\nvoid initScene() {\n    //init lights\n    lights[0] = Sphere( vec3( -2.0, 1.4, -5.0 ), 0.05, 0.0025, 0.0314159 );\n\tlights[1] = Sphere( vec3( -1.1, 1.4, -5.0 ), 0.2, 0.04, 0.5026548 );\n\tlights[2] = Sphere( vec3( 0.0, 1.4, -5.0 ), 0.4, 0.16, 2.0106193 );\n\tlights[3] = Sphere( vec3( 1.6, 1.4, -5.0 ), 0.8, 0.64, 8.0424770 );\n    \n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+iTime*speed;    \n    lights[0].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+iTime*speed;    \n    lights[1].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+iTime*speed;    \n    lights[2].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+iTime*speed;    \n    lights[3].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //init walls\n    walls[0].abcd = vec4( normalize(vec3(0.0, 1.0, -EPSILON)), 1.0 );\n    //walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    walls[1].abcd = vec4( 0.0, 0.0, 1.0, 6.2 );\n    \n#ifdef SHOW_PLANES\n    //init planes\n    vec3 planeNormal = normalize( vec3( 0.0, 1.0, 1.2 ) );\n    planes[0].abcd = vec4( planeNormal, 3.8 );\n    planeZRanges[0].min_ = -5.8;\n    planeZRanges[0].max_ = -5.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.7 ) );\n    planes[1].abcd = vec4( planeNormal, 2.8 );\n    planeZRanges[1].min_ = -4.8;\n    planeZRanges[1].max_ = -4.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.3 ) );\n    planes[2].abcd = vec4( planeNormal, 1.8 );\n    planeZRanges[2].min_ = -3.8;\n    planeZRanges[2].max_ = -3.0;\n#endif\n}\n\n#define GET_LIGHT_SPHERE_CONST(i) lights[i]\n\n\nMaterial materialLibrary[MATERIAL_COUNT];\n\n#define INIT_MTL(i,bsdf,phongExp,colorVal) materialLibrary[i].bsdf_=bsdf; materialLibrary[i].roughness_=phongExp; materialLibrary[i].color=colorVal;\nvoid initMaterialLibrary()\n{\n    vec3 white = vec3( 1.0, 1.0, 1.0 );\n    vec3 gray = vec3( 0.8, 0.8, 0.8 );\n    \n    //walls\n    INIT_MTL( 0, BSDF_R_DIFFUSE, 0.0, white );\n\t\n    //planes\n    INIT_MTL( 1, BSDF_R_GLOSSY, 4096.0, gray );\n    INIT_MTL( 2, BSDF_R_GLOSSY, 128.0, gray );\n    INIT_MTL( 3, BSDF_R_GLOSSY, 32.0, gray );\n    \n    //lights\n    float totalIntencity = 6.0;\n    float min_x = lights[0].pos.x;\n    float max_x = lights[3].pos.x;\n    float x_range = max_x - min_x;\n    float h1 = ((lights[0].pos.x-min_x)/x_range)*0.6;\n    float h2 = ((lights[1].pos.x-min_x)/x_range)*0.6;\n    float h3 = ((lights[2].pos.x-min_x)/x_range)*0.6;\n    float h4 = ((lights[3].pos.x-min_x)/x_range)*0.6;\n    float s = 0.7;\n    float v1 = 1.0/(FOUR_PI*lights[0].radiusSq);\n    float v2 = 1.0/(FOUR_PI*lights[1].radiusSq);\n    float v3 = 1.0/(FOUR_PI*lights[2].radiusSq);\n    float v4 = 1.0/(FOUR_PI*lights[3].radiusSq);\n    \n    INIT_MTL( 4, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h1, s, v1 ) )*totalIntencity );\n    INIT_MTL( 5, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h2, s, v2 ) )*totalIntencity );\n    INIT_MTL( 6, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h3, s, v3 ) )*totalIntencity );\n    INIT_MTL( 7, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h4, s, v4 ) )*totalIntencity );\n}\n\nMaterial getMaterialFromLibrary( int index ){\n#if __VERSION__ >= 300\n    return materialLibrary[index];\n#else\n    if(index == 0) return materialLibrary[0];\n    if(index == 1) return materialLibrary[1];\n    if(index == 2) return materialLibrary[2];\n    if(index == 3) return materialLibrary[3];\n    if(index == 4) return materialLibrary[4];\n    if(index == 5) return materialLibrary[5];\n    if(index == 6) return materialLibrary[6];\n    return materialLibrary[7];\n#endif\n}\n\nvoid getLightInfo( in int index, out Sphere sphere, out vec3 intensity ) {\n#if __VERSION__ >= 300\n    sphere = lights[index];\n#else\n    if(index == 0) { sphere = lights[0]; } else\n    if(index == 1) { sphere = lights[1]; } else\n    if(index == 2) { sphere = lights[2]; } else\n    \t\t\t   { sphere = lights[3]; }\n#endif\n    intensity = getMaterialFromLibrary(4+index).color;\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) {\n    float sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n\n// BSDF functions *************************************************************\nfloat evaluateBlinn( in  vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n    return (roughness + 2.0) / (8.0 * PI) * pow(cosTheta, roughness);\n}\n\nfloat pdfBlinn(in vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n\tfloat normalizationFactor = (roughness + 1.0) / TWO_PI;\n    return pow( cosTheta, roughness ) * normalizationFactor / (4.0 * dot(E, H));\n}\n\nvec3 sampleBlinn( in vec3 N, in vec3 E, in float roughness, in float r1, in float r2, out float pdf ) {\n    float cosTheta = pow( r1, 1.0/( roughness ) );\n    float phi = r2*TWO_PI;\n    float theta = acos( cosTheta );\n    vec3 H = localToWorld( sphericalToCartesian( 1.0, phi, theta ), N );\n    float dotNH = dot(H,N);\n    vec3 L = reflect( E*(-1.0), H );\n    \n    pdf = pdfBlinn(N, E, L, roughness );\n    \n    return L;\n}\n\nfloat evaluateLambertian( in vec3 N, in vec3 L ) {\n    return INV_PI;\n}\n\nfloat pdfLambertian( in vec3 N, in vec3 L ) {\n    return max(.0, dot( N, L )) * INV_PI;\n}\n\nvec3 sampleLambertian( in vec3 N, in float r1, in float r2, out float pdf ){\n    vec3 L = sampleHemisphereCosWeighted( N, r1, r2 );\n    pdf = pdfLambertian(N, L);\n    return L;\n}\n//*****************************************************************************\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( in vec3 pos, in vec3 frontDir, in vec3 upDir, in float fovV, out Camera dst ) {\n\tvec3 back = normalize( -frontDir );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    dst.rotate[0] = right;\n    dst.rotate[1] = up;\n    dst.rotate[2] = back;\n    dst.fovV = fovV;\n    dst.pos = pos;\n}\n\nRay genRay( in Camera camera, in vec2 pixel ) {\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    Ray ray;\n    ray.origin = camera.pos;\n\tray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\n\nbool raySceneIntersection( \tin Ray ray,\n                          \tin float distMin,\n                          \tout RaySurfaceHit hit ) {\n    hit.obj_id = -1;\n    hit.dist = 1000.0;\n    hit.E = ray.dir*(-1.0);\n    \n    //check lights\n    for( int i1=0; i1<LIGHT_COUNT; i1++ ){\n        float dist;\n        if( raySphereIntersection( ray, lights[i1], dist ) && (dist>distMin) && ( dist < hit.dist ) ) {\n            hit.dist = dist;\n          \tvec3 hitpos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = (hitpos - lights[i1].pos)*(1.0/lights[i1].radius);\n    \t\thit.mtl_id = 4 + i1;\n            hit.obj_id = i1;\n        }\n    }\n    \n    //check walls\n    for( int i=0; i<WALL_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, walls[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            hit.dist = dist;\n//            hit.pos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = walls[i].abcd.xyz;\n    \t\thit.mtl_id = 0;\n            hit.obj_id = LIGHT_COUNT + i;\n        }\n    }\n    \n#ifdef SHOW_PLANES\n    //check planes\n    for( int i=0; i<PLANE_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, planes[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            vec3 hitPos = ray.origin + ray.dir*dist;\n            if( (hitPos.z < planeZRanges[i].max_ ) && (hitPos.z > planeZRanges[i].min_) && (hitPos.x < planeHalfWidth ) && (hitPos.x > -planeHalfWidth ) ) {\n                hit.dist = dist;\n//                hit.pos = hitPos;\n                hit.N = planes[i].abcd.xyz;\n                hit.mtl_id = 1+i;\n                hit.obj_id = LIGHT_COUNT + WALL_COUNT + i;\n            }        \n        }\n    }\n#endif\n    \n    return ( hit.obj_id != -1 );\n}\n\nvoid sampleSphericalLight( in vec3 x, in Sphere sphere, float Xi1, float Xi2, out LightSamplingRecord sampleRec ) {\n#ifdef SAMPLE_LIGHT_AREA\n    vec3 n = randomDirection( Xi1, Xi2 );\n    vec3 p = sphere.pos + n*sphere.radius;\n    float pdfA = 1.0/sphere.area;\n    \n    vec3 Wi = p - x;\n    \n    float d2 = dot(Wi,Wi);\n    sampleRec.d = sqrt(d2);\n    sampleRec.w = Wi/sampleRec.d; \n    float cosTheta = max( 0.0, dot(n, -sampleRec.w) );\n    sampleRec.pdf = PdfAtoW( pdfA, d2, cosTheta );\n#else\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = sphere.radiusSq / dc_2;\n\t\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    \tfloat cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    \tfloat sin_theta = sqrt(sin_theta_2);\n        sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    \tsampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n        //Calculate intersection distance\n\t\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n        sampleRec.d = dc*cos_theta - sqrt(sphere.radiusSq - dc_2*sin_theta_2);\n    } else {\n        sampleRec.w = randomDirection( Xi1, Xi2 );\n        sampleRec.pdf = 1.0/FOUR_PI;\n    \traySphereIntersection( Ray(x,sampleRec.w), sphere, sampleRec.d );\n    }\n#endif\n}\n\nfloat sphericalLightSamplingPdf( in vec3 x, in vec3 wi, float d, in vec3 n1, in Sphere sphere ) {\n#ifdef SAMPLE_LIGHT_SOLIDANGLE\n    float solidangle;\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = clamp( sphere.radiusSq / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n#else\n    float lightPdfA = 1.0/sphere.area;\n    float cosTheta1 = max( 0.0, dot( n1, -wi ) );\n    return PdfAtoW( lightPdfA, d*d, cosTheta1 );\n#endif\n}\n\nfloat lightChoosingPdf(in vec3 x, in int lightId) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    return cdf[lightId] - (lightId==0? 0.0 : cdf[lightId-1]);\n#else\n   \treturn 1.0/float(LIGHT_COUNT);\n#endif\n}  \t\n\nint chooseOneLight(in vec3 x, in float Xi, out float pdf) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    int id = 0;\n    for(int i=0; i<LIGHT_COUNT; i++) {\n        if(Xi < cdf[i]) {\n        \tid = i;\n            pdf = cdf[i] - (i==0? 0.0 : cdf[i-1]);\n            break;\n        }\n    }\n    \n    return id;\n#else\n   \tpdf = 1.0/float(LIGHT_COUNT);\n    return int(Xi*float(LIGHT_COUNT));\n#endif\n}\n\nvec3 sampleBSDF( in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS, vec2 xi ) {\n    vec3 Lo = vec3( 0.0 );\n    float bsdfSamplingPdf = 1.0/float(BSDF_SAMPLES);\n    vec3 n = hit.N * vec3((dot(hit.E, hit.N) < 0.0) ? -1.0 : 1.0);\n    \n    for( int i=0; i<BSDF_SAMPLES; i++ ) {\n        //Generate direction proportional to bsdf\n        vec3 bsdfDir;\n        float bsdfPdfW;\n        float Xi1 = xi.x;//rnd();\n        float Xi2 = xi.y;//rnd();\n        float strataSize = 1.0 / float(BSDF_SAMPLES);\n        Xi2 = strataSize * (float(i) + Xi2);\n        float brdf;\n        \n        if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n            bsdfDir = sampleBlinn( n, hit.E, mtl.roughness_, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateBlinn( n, hit.E, bsdfDir, mtl.roughness_ );\n        } else {\n            bsdfDir = sampleLambertian( n, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateLambertian( n, bsdfDir );\n        }\n        \n        float dotNWi = dot( bsdfDir, n );\n\n        //Continue if sampled direction is under surface\n        if( (dotNWi > 0.0) && (bsdfPdfW > EPSILON) ){\n            //calculate light visibility\n            RaySurfaceHit newHit;\n            if( raySceneIntersection( Ray( x, bsdfDir ), EPSILON, newHit ) && (newHit.obj_id < LIGHT_COUNT) ) {\n                //Get hit light Info\n                vec3 Li;\n                Sphere lightSphere;\n                getLightInfo( newHit.obj_id, lightSphere, Li );\n\n                //Read light info\n                float weight = 1.0;\n\t\t\t\tfloat lightPdfW;\n                if ( useMIS ) {\n                    lightPdfW = sphericalLightSamplingPdf( x, bsdfDir, newHit.dist, newHit.N, lightSphere );\n                    lightPdfW *= lightChoosingPdf(x, newHit.obj_id);\n                    weight = misWeight( bsdfPdfW, lightPdfW );\n                }\n\n                Lo += brdf*dotNWi*(Li/bsdfPdfW)*weight;\n            }\n        }\n    }\n\n    return Lo*bsdfSamplingPdf;\n}     \n\nvec3 sampleLight( \tin vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS, vec2 xi, float sl ) {\n    vec3 Lo = vec3( 0.0 );\t//outgoing radiance\n    float lightSamplingPdf = 1.0/float(LIGHT_SAMPLES);\n   \n    for( int i=0; i<LIGHT_SAMPLES; i++ ) {\n        //select light uniformly\n        \n        float Xi = xi.x;\n        float strataSize = 1.0 / float(LIGHT_SAMPLES);\n        Xi = strataSize * (float(i) + Xi);\n        float lightPickPdf;\n        int lightId = chooseOneLight(x, sl, lightPickPdf);\n\n        //Read light info\n        vec3 Li;\t\t\t\t//incomming radiance\n        Sphere lightSphere;\n        getLightInfo( lightId, lightSphere, Li );\n        \n        float Xi1 = xi.x;//rnd();\n        float Xi2 = xi.y;//rnd();\n        LightSamplingRecord sampleRec;\n        sampleSphericalLight( x, lightSphere, Xi1, Xi2, sampleRec );\n        \n        float lightPdfW = lightPickPdf*sampleRec.pdf;\n        vec3 Wi = sampleRec.w;\n        \n        float dotNWi = dot(Wi,hit.N);\n\n        if ( (dotNWi > 0.0) && (lightPdfW > EPSILON) ) {\n            Ray shadowRay = Ray( x, Wi );\n            RaySurfaceHit newHit;\n            bool visible = true;\n#ifdef SHADOWS\n            visible = ( raySceneIntersection( shadowRay, EPSILON, newHit ) && EQUAL_FLT(newHit.dist,sampleRec.d,EPSILON) );\n#endif\n            if(visible) {\n                float brdf;\n    \t\t\tfloat brdfPdfW;\t\t\t//pdf of choosing Wi with 'bsdf sampling' technique\n                \n                if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n                    brdf = evaluateBlinn( hit.N, hit.E, Wi, mtl.roughness_ );\n                    brdfPdfW = pdfBlinn(hit.N, hit.E, Wi, mtl.roughness_ );\t//sampling Pdf matches brdf\n                } else {\n                    brdf = evaluateLambertian( hit.N, Wi );\n                    brdfPdfW = pdfLambertian( hit.N, Wi );\t//sampling Pdf matches brdf\n                }\n\n                float weight = 1.0;\n                if( useMIS ) {\n                    weight = misWeight( lightPdfW, brdfPdfW );\n                }\n                \n                Lo += ( Li * brdf * weight * dotNWi ) / lightPdfW;\n            }\n        }\n    }\n    \n    return Lo*lightSamplingPdf;\n}\n\nvec3 Radiance( in Ray ray, vec2 xi1, vec2 xi2, float sl ) {\n    RaySurfaceHit hit;\n    if( raySceneIntersection( ray, 0.0, hit ) ) {\n    \tMaterial mtl = getMaterialFromLibrary( hit.mtl_id );\n\n        vec3 f, Le;\n\n        if( mtl.bsdf_ == BSDF_R_LIGHT ) {\n            Le = mtl.color;\n            f = vec3( 1.0, 1.0, 1.0 );\n        } else {\n            Le = vec3( 0.0 );\n            f = mtl.color;\n        }\n        \n        vec3 hitPos = ray.origin + ray.dir*hit.dist;\n            \n        vec3 directLight = vec3(0.0);\n        directLight += sampleBSDF( hitPos, hit, mtl, true, xi2 );\n        directLight += sampleLight( hitPos, hit, mtl, true, xi1, sl );\n        return Le + f * directLight;\n    }\n\n    return backgroundColor;\n}\n\nvec4 bluenoise(int s, vec2 fc) {\n    vec2 blue_noise_res = iChannelResolution[0].xy;\n    vec2 tileRes = vec2(256.0, 256.0);\n\tint tilex = s % 4;\n    int tiley = s / 4;\n    \n    vec2 coord = mod(fc, tileRes);\n    \n    return texture( iChannel0, (vec2(tilex, tiley) * tileRes + coord) / blue_noise_res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n    \n    Camera camera;\n    initScene();\n    initMaterialLibrary();\n    \n    vec2 splitterPos = iMouse.xy;\n    if ( splitterPos.x == 0.0 && splitterPos.y == 0.0 ) {\n        splitterPos = iResolution.xy*0.5;\n    }\n    initSamplingTechnique((iMouse.x==0.0)?iResolution.x*0.5:fragCoord.x);\n\t\n    if (samplingTechnique == SAMPLING_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        Ray ray;\n        vec3 accumulatedColor = vec3( 0.0 );\n        for(int si=0; si<PIXEL_SAMPLES; ++si ){\n            vec4 xi;\n            if(samplingTechnique == SAMPLING_BLUE_NOISE) {\n                xi = bluenoise(si, fragCoord);\n            } else {\n                xi = vec4(rnd(), rnd(), rnd(), rnd());\n            }\n\n            //stratified sampling for t\n            float tprev = iTime;\n            float tnext = iTime+FRAME_TIME;\n            float tStrata = 1.0/float(PIXEL_SAMPLES);\n            float tnorm = tStrata*(float(si)  + xi.w);\n            float t = mix(tprev,tnext,tnorm);\n\n\n            //for object motion blur\n            updateScene(t);\n\n            //update camera for camera motion blur\n            vec3 cameraPos = vec3( 0.0, 1.0 + sin(t*0.45), 3.0 + sin(t*0.4)*3.0 );\n            vec3 cameraTarget = vec3( sin(t*0.4)*0.3, 0.0, -5.0 );\n            initCamera( cameraPos, cameraTarget - cameraPos, vec3( 0.0, 1.0, 0.0 ), radians(45.0), camera );\n\n            vec2 subPixelCoord = vec2(rnd(), rnd());\n            vec2 screenCoord = fragCoord.xy + subPixelCoord;\n            ray = genRay( camera, screenCoord );\n\n            accumulatedColor += Radiance( ray, xi.xy, xi.xy, xi.z );\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*(1.0/float(PIXEL_SAMPLES));\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1762, 1762, 1799, 1799, 2185], [2413, 2413, 2461, 2461, 2551], [2552, 2552, 2602, 2602, 2650], [2651, 2651, 2700, 2700, 2820], [2881, 2978, 2991, 2991, 3034], [3074, 3161, 3183, 3183, 3352], [3442, 3560, 3620, 3620, 3713], [3715, 3766, 3826, 3826, 3966], [4829, 4908, 4975, 4975, 5183], [5185, 5185, 5248, 5248, 5466], [5547, 5547, 5574, 5592, 6374], [6376, 6376, 6394, 6412, 8141], [8381, 8381, 8409, 8409, 9633], [9635, 9635, 9680, 9680, 10106], [10108, 10108, 10182, 10182, 10481], [10483, 10565, 10643, 10643, 10751], [10753, 10753, 10843, 10843, 10993], [10995, 10995, 11044, 11044, 11244], [11246, 11246, 11301, 11301, 11401], [11403, 11403, 11476, 11476, 11584], [11586, 11586, 11661, 11661, 11804], [11806, 11806, 11858, 11858, 11986], [12069, 12149, 12226, 12226, 12360], [12362, 12362, 12432, 12432, 12634], [12636, 12636, 12739, 12739, 13058], [13060, 13060, 13110, 13110, 13131], [13133, 13133, 13178, 13178, 13222], [13224, 13224, 13300, 13300, 13402], [13484, 13556, 13652, 13652, 13890], [13892, 13892, 13939, 13939, 14192], [14195, 14195, 14332, 14332, 15899], [15901, 15901, 16016, 16016, 17398], [17400, 17400, 17497, 17497, 18171], [18173, 18173, 18224, 18224, 18708], [18713, 18713, 18772, 18772, 19436], [23550, 23550, 23609, 23609, 24279], [24281, 24281, 24313, 24313, 24583]], "test": "untested"}
{"id": "tsKyWG", "name": "Spectral 2", "author": "Pidhorskyi", "description": "Spectral ray tracing", "tags": ["raytracing", "spectral"], "likes": 34, "viewed": 971, "published": 3, "date": "1603778146", "time_retrieved": "2024-07-30T20:37:57.811812", "image_code": "/*\nStanislav Pidhorskyi 2020\n\nThis is a more complex version of https://www.shadertoy.com/view/3sKcRd\nIt has few hard coded hacks, such as biasing rays towards the lens and casting more rays for the projection of the wall.\n\n\nI implemented a spectral path tracer, where each ray has a random wavelength. Surprisingly, it's not much noisier than conventional RGB path tracing.\nWavelength is sampled uniformly from 400.0nm to 700.0nm, but of course, it would be better to utilize importance sampling here and sample more those wavelengths that contribute to the RGB color more.\n\nSpecter can be converted to the color values by computing dot products with color matching functions.\nI used CIE color-matching functions that I took from John Walker website: https://www.fourmilab.ch/documents/specrend/\nThese functions are tabulated and correspond to the CIE tristimulus values X, Y, and Z.\nThe lookup table would not be too large, but it seems to be a significant source of slowdown, so I decided to approximate them with Gaussians.\nBut before with dive into the approximation, it worth noting that white color does not have a uniform specter.\nIn order to get sources of white light, we need to use a specific specter, like Illuminant D65.\nI took the values for D65 from here: https://www.waveformlighting.com/tech/calculate-illuminant-d-spd-and-cie-1931-xy-from-color-temperature/\nI computed the point-wise product of D65 specter and CIE color-matching functions so that we could pretend that now the white color has a uniform specter.\nThe result functions I approximated with Gaussians and a mixture of two Gaussians for the Red color:\n\n\nRed:    \t8233.31 * f(l | mu=593.95, sigma=34.00) + 1891.26 * f(l | mu=448.89, sigma=18.785),\nGreen:      10522.64 * f(l | 555.38, 40.80),\nBlue:       111254.78 * f(l | mu=452.98, sigma=21.57)\n\nwhere f(l) = 1/(sigma sqrt(2 * pi)) * exp(-1/2 * ((l - mu) / sigma)^2)\n\nCode for computing the coefficients can be found here: https://gist.github.com/podgorskiy/99c283773f7cee8e71386aa8ef622fdf\n\nRepresented in this way, it would be actually not hard to compute a CDF and perform importance sampling, but I did not do it. I just used uniform sampling for wavelengths.\n\nTo compute the XYZ values given a specter, we need to compute the integral of the point-wise product of the specter with the color matching functions.\nThe integral is computed in the Monte Carlo way by sampling wavelength at random and then accumulating the XYZ values. The averaged XYZ value is then converted to RGB\n\nIn order to actually appreciate the spectral path tracing, we need to make the refraction index to be a function of the wavelength. Otherwise, the output of the spectral raytracer won't differ from the conventional one.\n\nI use the Sellmeier equation https://en.wikipedia.org/wiki/Sellmeier_equation. The material of the prism is Flint glass, parameters I found here: https://refractiveindex.info/?shelf=glass&book=SCHOTT-F&page=F2.\n\nTo sample from the cubemap, we need to do an inverse operation, go from RGB values to a specter. Sure, that's an ill-posed problem, but we could approach it with some basis of orthogonal functions and Non-negative least squares (NNLS), but that would be too costly. Instead, I used a very naive way and assumed that the CIE color-matching functions are orthogonal (which are not) and used just a dot product.\nBecause of such a naive assumption, colors are off.\n\nAnd finally, I wrote the code for a ray-prism intersection because I could not find one.\n\n----------------------------------------\n\nReuses some code from https://www.shadertoy.com/view/lssBD7 that implements Peter Shirley's \"Ray Tracing in One Weekend\" pathtracer.\n\nPost-processing from Inigo Quilezh's `Happy Jumping` ttps://www.shadertoy.com/view/3lsSzf\n\n\n*/\n\n#define PI \t\t\t3.1415926535\n#define MAXFLOAT\t99999.99\n\n#define MAXDEPTH \t8\n#define NUMSAMPLES \t64\n#define NUMSAMPLES_MAX \t256\n\n// Do not unroll.\n#define DNU(X)  min(int(iResolution.x) << 12, X)\n\nconst mat3 XYZ_2_RGB = (mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n));\n\nconst mat3 RGB_2_XYZ = (mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041\n));\n\n\nconst float R1 = 150.0;\nconst float R2 = -50.0;\nconst float d = 6.0;\nconst float n = 1.634;\nconst float f = 1. / ((n - 1.) * (1./R1 - 1./R2 + (n - 1.) * d / (n * R1 * R2)));\n\nconst float light2lens_dist = 100.0;\nconst float angle = -0.7;\nconst float lens_pos = 0.0;\nconst float prism_pos = 40.0;\n\nconst float image2lens = 1. / (1. / f - 1. / light2lens_dist);\n\nconst float wall2prism = image2lens - prism_pos;\n\nconst float prism_size = 20.0;\n\n\n\n\nuint seedA = 0x9c127997U;\nuint seedB = 0x140b75b2U;\n\nuint urand()\n{\n\tuint x = seedA;\n\tuint y = seedB;\n\tseedA = y;\n\tx ^= x << 23;\n\tseedB = x ^ y ^ (x >> 17) ^ (y >> 26);\n    uint n = seedB + y;\n\treturn n * (n * n * 15731U + 789221U) + 1376312589U;\n}\n\nfloat rand1()\n{\n \treturn uintBitsToFloat( (urand()>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 rand2()\n{\n \tfloat a = uintBitsToFloat( (urand()>>9U) | 0x3f800000U ) - 1.0;\n \tfloat b = uintBitsToFloat( (urand()>>9U) | 0x3f800000U ) - 1.0;\n    return vec2(a, b);\n}\n\nfloat rand(float a, float b)\n{\n \treturn rand1() * (b - a) + a;\n}\n\n// Random unit vector, uniformly distributed on a sphere\nvec3 random_unit_vector()\n{\n    float a = rand(0.0, 2. * PI);\n    float z = rand(-1.0, 1.0);\n    float r = sqrt(1.0 - z*z);\n    return vec3(r * cos(a), r * sin(a), z);\n}\n\n// Random, uniformely distributed point on unit disk\nvec2 random_in_unit_disk()\n{\n    vec2 uv = rand2();\n    float theta = 6.283185 * uv.x;\n    return sqrt(uv.y) * vec2(cos(theta), sin(theta));\n}\n\nvec3 random_cosine_direction(in vec3 normal)\n{\n    return normalize(normal + random_unit_vector());\n}\n\nfloat gaussian(float x, float mu, float sigma)\n{\n    return 1.0 / (sigma * sqrt(2.0 * PI)) * exp(-(x-mu)*(x-mu)/(2.*sigma*sigma));\n}\n\n\n// The CIE color matching functions were taken from  https://www.fourmilab.ch/documents/specrend\n// The tabulated functions then were approximated with gaussians (for G and B) and with a mixture of two gaussiuns (R).\nvec3 wavelength2XYZ(float l)\n{\n\treturn vec3(\n    \t8233.31 * gaussian(l, 593.951, 34.00) + 1891.26 * gaussian(l, 448.89, 18.785),\n        10522.64 * gaussian(l, 555.38, 40.80),\n        11254.78 * gaussian(l, 452.98, 21.57)\n    );\n}\n\n\n// Very very crude convertion from XYZ color to spectrum. It is wrong in many ways, but I don't know a faster way to do it.\n// The assumption is that the three color matching functions are orthogonal, but they are not.\nfloat XYZ2WavelengthApprox(float l, vec3 color)\n{\n    return dot(wavelength2XYZ(l), color) / 100.0;\n}\n\nfloat glass_crown_n(float l)\n{\n    l /= 1000.0;\n    float l2 = l * l;\n\tvec3 k = vec3(1.03961212, 0.231792344, 1.01046945) * l2 /\n        (l2 - vec3(0.0060007, 0.020018, 103.560));\n\treturn 1.0 * (sqrt(1. + dot(k, vec3(1.0))) - 1.52) + 1.52;\n}\n\n\nfloat glass_flint_n(float l)\n{\n    l /= 1000.0;\n    float l2 = l * l;\n\tvec3 k = vec3(1.34533359, 0.209073176, 0.937357162) * l2 /\n        (l2 - vec3(0.00997743871, 0.0470450767, 111.886764));\n\treturn sqrt(1. + dot(k, vec3(1.0)));\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float wave_length;\n};\n\nstruct Material\n{\n    int   materialType;\n    vec3  albedo;\n    float fuzz;\n    float refractionIndex;\n};\n\nstruct IntersectInfo\n{\n    vec2 t;\n    vec3  p;\n    vec3  normal;\n    Material mat;\n};\n\nstruct Transform\n{\n\tmat3 rotation;\n    vec3 position;\n    vec3 scale;\n};\n\nstruct Object\n{\n    Transform transform;\n    Material mat;\n};\n\nvec3 InvertseTransformPosition(Transform tr, vec3 p)\n{\n    return (tr.rotation * (p - tr.position)) / tr.scale;\n}\n\nvec3 DirectTransformPosition(Transform tr, vec3 p)\n{\n    return (p * tr.scale) * tr.rotation + tr.position;\n}\n\nvec3 InvertseTransformDirection(Transform tr, vec3 d)\n{\n    return normalize((tr.rotation * d) / tr.scale);\n}\n\nvec3 DirectTransformDirection(Transform tr, vec3 d)\n{\n    return normalize((d * tr.scale) * tr.rotation);\n}\n\nIntersectInfo Box(Object box, Ray ray, vec2 t)\n{\n    Transform tr = box.transform;\n    IntersectInfo rec;\n    rec.t.x = MAXFLOAT;\n    vec3 o = InvertseTransformPosition(tr, ray.origin);\n    vec3 d = InvertseTransformDirection(tr, ray.direction);\n    vec3 m = 1.0 / d;\n    vec3 k = abs(m);\n    vec3 a = -m * o -k;\n    vec3 b = a + k * 2.0;\n    float near = max(max(a.x, a.y), a.z);\n    float far = min(min(b.x, b.y), b.z);\n    if (near > far)\n    {\n\t\treturn rec;\n    }\n\n    vec3 localPosFar = o + far * d;\n    vec3 localPosNear = o + near * d;\n    vec3 posFar = DirectTransformPosition(tr, localPosFar);\n    vec3 posNear = DirectTransformPosition(tr, localPosNear);\n\n    float dmax = dot(posFar - ray.origin, ray.direction);\n    float dmin = dot(posNear - ray.origin, ray.direction);\n\n    if (dmin < t.y && dmin > t.x)\n    {\n       rec.t = vec2(dmin, dmax);\n       rec.p                = posNear;\n       vec3 f = step(0.999, abs(localPosNear));\n       rec.normal = normalize(localPosNear * f * tr.rotation);\n       rec.mat = box.mat;\n    }\n\telse\n    if (dmax < t.y && dmax > t.x)\n    {\n       rec.t = vec2(dmax, MAXFLOAT);\n       rec.p                = posFar;\n       vec3 f = step(0.999, abs(localPosFar));\n       rec.normal = normalize(localPosFar * f * tr.rotation);\n       rec.mat = box.mat;\n    }\n    return rec;\n}\n\n\nIntersectInfo Rect(Object box, Ray ray, vec2 t)\n{\n    Transform tr = box.transform;\n    IntersectInfo rec;\n    rec.t.x = MAXFLOAT;\n    vec3 o = InvertseTransformPosition(tr, ray.origin);\n    vec3 d = InvertseTransformDirection(tr, ray.direction);\n    float l = -o.x / d.x;\n    vec3 localPos = o + d * l;\n    if (l < 0. || any(greaterThan(abs(localPos.yz), vec2(1.0))))\n    {\n\t\treturn rec;\n    }\n\n    vec3 pos = DirectTransformPosition(tr, localPos);\n\n    float dm = dot(pos - ray.origin, ray.direction);\n\n    if (dm < t.y && dm > t.x)\n    {\n       rec.t = vec2(dm, t.y);\n       rec.p                = pos;\n       rec.normal = normalize(vec3(1., 0., 0.) * tr.rotation);\n       rec.mat = box.mat;\n    }\n    return rec;\n}\n\n\nIntersectInfo Prism(Object box, Ray ray, vec2 t)\n{\n    Transform tr = box.transform;\n    IntersectInfo rec;\n    rec.t.x = MAXFLOAT;\n    vec3 o = InvertseTransformPosition(tr, ray.origin);\n    vec3 d = InvertseTransformDirection(tr, ray.direction);\n    vec3 m = 1.0 / d;\n    vec3 k = abs(m);\n    vec3 a = -m * o -k;\n    vec3 b = a + k * 2.0;\n    float near = max(max(a.x, a.y), a.z);\n    float far = min(min(b.x, b.y), b.z);\n    if (near > far)\n    {\n\t\treturn rec;\n    }\n\n    vec3 pn1 = normalize(vec3(2.0, 1.0, 0.0));\n    vec3 pn2 = pn1;\n    pn2.x = -pn2.x;\n    float pm1 = -1.0 / dot(pn1, d);\n    float pm2 = -1.0 / dot(pn2, d);\n    float p1 = dot(o, pn1) * pm1 - pn1.y * pm1;\n    float p2 = dot(o, pn2) * pm2 - pn2.y * pm2;\n    float pb = o.y * m.y + m.y;\n\n    if (pm1 > 0.0)\n     \tnear = max(near, p1);\n    else\n      \tfar = min(far, p1);\n    if (pm2 > 0.0)\n      \tnear = max(near, p2);\n    else\n      \tfar = min(far, p2);\n\n    if (near > far)\n    {\n\t\treturn rec;\n    }\n\n    vec3 localPosFar = o + far * d;\n    vec3 localPosNear = o + near * d;\n    vec3 posFar = DirectTransformPosition(tr, localPosFar);\n    vec3 posNear = DirectTransformPosition(tr, localPosNear);\n\n    float dmax = dot(posFar - ray.origin, ray.direction);\n    float dmin = dot(posNear - ray.origin, ray.direction);\n\n    if (dmin < t.y && dmin > t.x)\n    {\n       rec.t = vec2(dmin, dmax);\n       rec.p                = posNear;\n       vec3 f = step(0.9999, abs(localPosNear));\n       rec.normal = normalize(sign(localPosNear) * f);\n       if (all( lessThan(f, vec3(1.0))))\n       {\n           rec.normal = mix(pn1, pn2, bvec3(localPosNear.x < 0.0));\n       }\n       rec.normal *= tr.rotation;\n       rec.mat = box.mat;\n    }\n\telse\n    if (dmax < t.y && dmax > t.x)\n    {\n       rec.t = vec2(dmax, MAXFLOAT);\n       rec.p                = posFar;\n       vec3 f = step(0.9999, abs(localPosFar));\n       rec.normal = normalize(localPosFar * f);\n       if (all( lessThan(f, vec3(1.0))))\n       {\n           rec.normal = mix(pn1, pn2, bvec3(localPosFar.x < 0.0));\n       }\n       rec.normal *= tr.rotation;\n       rec.mat = box.mat;\n    }\n    return rec;\n}\n\n\n\nIntersectInfo Sphere(Object sphere, Ray ray, vec2 t)\n{\n    Transform tr = sphere.transform;\n    IntersectInfo rec;\n    rec.t.x = MAXFLOAT;\n    vec3 o = InvertseTransformPosition(tr, ray.origin);\n    vec3 d = InvertseTransformDirection(tr, ray.direction);\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, o);\n    float c = dot(o, o) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0f)\n    {\n    \treturn rec;\n    }\n\n    float D = sqrt(discriminant);\n    vec2 temp = vec2(D - b, -D - b) / 2.0 / a;\n\n    vec3 localPosMax = o + temp.x * d;\n    vec3 localPosMin = o + temp.y * d;\n    vec3 posMax = DirectTransformPosition(tr, localPosMax);\n    vec3 posMin = DirectTransformPosition(tr, localPosMin);\n\n    float dmax = dot(posMax - ray.origin, ray.direction);\n    float dmin = dot(posMin - ray.origin, ray.direction);\n\n    if (dmin < t.y && dmin > t.x)\n    {\n       rec.t                = vec2(dmin, dmax);\n       rec.p                = posMin;\n       rec.normal           = normalize(localPosMin * tr.scale * tr.rotation);\n       rec.mat = sphere.mat;\n    }\n\telse\n    if (dmax < t.y && dmax > t.x)\n    {\n       rec.t                = vec2(dmax, MAXFLOAT);\n       rec.p                = posMax;\n       rec.normal           = normalize(localPosMax * tr.scale * tr.rotation);\n       rec.mat = sphere.mat;\n    }\n    return rec;\n}\n\n// Schlick's approximation for approximating the contribution of the Fresnel factor\n// in the specular reflection of light from a non-conducting surface between two media\n//\n// Theta is the angle between the direction from which the incident light is coming and\n// the normal of the interface between the two media\nfloat schlick(float cos_theta, float n2)\n{\n    const float n1 = 1.0f;  // refraction index for air\n\n    float r0s = (n1 - n2) / (n1 + n2);\n    float r0 = r0s * r0s;\n\n    return r0 + (1.0f - r0) * pow((1.0f - cos_theta), 5.0f);\n}\n\nbool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n    refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n    return discriminant > 0.0f;\n}\n\nvec3 reflectVec(vec3 v, vec3 n)\n{\n     return v - 2.0f * dot(v, n) * n;\n}\n\n\nstruct Camera\n{\n    float apertureRadius;\n    vec3 origin;\n    mat3 cam;\n    mat3 k_inv;\n    float focusDist;\n};\n\n\nvoid Camera_init(out Camera camera, vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focusDist)\n{\n    camera.apertureRadius = aperture;\n    camera.focusDist = focusDist;\n\n    float theta = vfov * PI / 180.0;\n    float halfHeight = tan(theta / 2.0);\n    float halfWidth = aspect * halfHeight;\n\n    camera.origin = lookfrom;\n\n    vec3 z = normalize(lookfrom - lookat);\n    vec3 x = normalize(cross(vup, z));\n    vec3 y = normalize(cross(z, x));\n\n    camera.cam = mat3(x, y, z);\n    camera.k_inv = mat3(vec3(halfWidth, 0, 0), vec3(0, halfHeight, 0), vec3(0.0, 0.0, -1.));\n}\n\n\nRay Camera_getRay(Camera camera, vec2 uv)\n{\n    vec3 rd = camera.apertureRadius * vec3(random_in_unit_disk(), 0.0);\n\n    Ray ray;\n    vec2 pixel = 1.0/iResolution.xy;\n\tuv += pixel * (rand2() - 0.5);\n    uv = 2.0 * uv - 1.0;\n\n    ray.origin = camera.origin;\n    ray.direction = camera.cam * (normalize(camera.k_inv * vec3(uv, 1.0)));\n\n    return ray;\n}\n\n#define LAMBERT    0\n#define METAL      1\n#define DIELECTRIC 2\n#define LIGHT 3\n\nbool Material_bsdf(IntersectInfo rec, Ray wo, out Ray wi, out float attenuation, inout float emission, out float pdf)\n{\n    pdf = 1.0;\n    int materialType = rec.mat.materialType;\n\n    if(materialType == LAMBERT)\n    {\n        wi.origin = rec.p;\n        \n        // HACK!! Biasing rays towards the lens\n     \t// BEGIN\n        vec3 virtual_lens_n = -vec3(cos(angle), 0.0, -sin(angle));\n\n        if (dot(virtual_lens_n, rec.normal) > 0.0)\n        {\n            vec3 virtual_lens_pos = vec3(prism_pos, 0., 0.) - (image2lens - wall2prism) * virtual_lens_n;\n\n            vec3 virtual_lens_b1 = cross(virtual_lens_n, vec3(0.0, 1.0, 0.0));\n            vec3 virtual_lens_b2 = cross(virtual_lens_n, virtual_lens_b1);\n\n            vec3 r = vec3(rand2() * 2.0 - 1.0, 0.0) * vec3(30., 25., 0.);\n            vec3 random_point_on_lens = virtual_lens_b1 * r.x + virtual_lens_b2 * r.y + virtual_lens_pos;\n\n            wi.direction = normalize(random_point_on_lens - wi.origin);\n\n            pdf = 1.0 / PI;\n        }\n     \t// END\n        else\n        {\n        \twi.direction = random_cosine_direction(rec.normal);\n            pdf = dot(rec.normal, wi.direction) / PI;\n        }\n        attenuation = rec.mat.albedo.x;\n        return true;\n    }\n    else if(materialType == LIGHT)\n    {\n        emission += 30.0;\n        return false;\n    }\n    else\n    if(materialType == METAL)\n    {\n        vec3 reflected = reflect(normalize(wo.direction), rec.normal);\n\n        wi.origin = rec.p;\n        wi.direction = reflected + rec.mat.fuzz * random_cosine_direction(rec.normal);\n\n        attenuation = rec.mat.albedo.x;\n\n        return (dot(wi.direction, rec.normal) > 0.0f);\n    }\n    else\n    if(materialType == DIELECTRIC)\n    {\n        vec3 outward_normal;\n        vec3 reflected = reflect(wo.direction, rec.normal);\n\n        float ni_over_nt;\n\n        attenuation = 1.0f;\n        vec3 refracted;\n        float reflect_prob;\n        float cosine;\n\n        float rafractionIndex = glass_flint_n(wo.wave_length);\n\n        if (dot(wo.direction, rec.normal) > 0.0f)\n        {\n            outward_normal = -rec.normal;\n            ni_over_nt = rafractionIndex;\n\n            cosine = dot(wo.direction, rec.normal) / length(wo.direction);\n            cosine = sqrt(1.0f - rafractionIndex * rafractionIndex * (1.0f - cosine * cosine));\n        }\n        else\n        {\n            outward_normal = rec.normal;\n            ni_over_nt = 1.0f / rafractionIndex;\n            cosine = -dot(wo.direction, rec.normal) / length(wo.direction);\n        }\n        if (refractVec(wo.direction, outward_normal, ni_over_nt, refracted))\n            reflect_prob = schlick(cosine, rafractionIndex);\n        else\n            reflect_prob = 1.0f;\n\n        if (rand1() < reflect_prob)\n        {\n            wi.origin = rec.p;\n            wi.direction = reflected;\n        }\n        else\n        {\n            wi.origin = rec.p;\n            wi.direction = refracted;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nfloat ScatterPDF(IntersectInfo rec, Ray r)\n{\n    int materialType = rec.mat.materialType;\n\n    if(materialType == LAMBERT)\n    {\n        return max(0.0, dot(rec.normal, r.direction) / PI);\n    }\n    else\n        return 1.0;\n}\n\n#define RotateY(x) mat3(cos(x), 0.0, sin(x), 0.0, 1.0, 0.0, -sin(x), 0.0, cos(x))\n#define RotateX(x) mat3(1.0, 0.0, 0.0, 0.0, cos(x), sin(x), 0.0, -sin(x), cos(x))\n#define RotateZ(x) mat3(cos(x), sin(x), 0.0, -sin(x), cos(x), 0.0, 0.0, 0.0, 1.0)\n\n    Object light = Object(\n            Transform(mat3(1.0), vec3(lens_pos - light2lens_dist, 0.0, 0.0),  vec3(2.0)),\n            Material(3, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\n    Object lens1 = Object(\n            Transform(mat3(1.0), vec3(R1 - d / 2.0 + lens_pos, 0.0, 0.0), vec3(R1)),\n            Material(2, vec3( 0.193093, 0.510542, 0.613362), 0.200000, 1.500000));\n\n    Object lens2 = Object(\n            Transform(mat3(1.0), vec3(R2 + d / 2.0 + lens_pos, 0.0, 0.0), vec3(R2)),\n            Material(2, vec3( 0.193093, 0.510542, 0.613362), 0.200000, 1.500000));\n\n    const mat3 r = RotateZ(-angle / 2.0) * RotateX(PI / 2.);\n    Object prism = Object(\n            Transform(r, vec3(prism_pos, 0.0, 0.0) - r * vec3(0., prism_size / 2.0 * tan(angle / 2.0), 0.0), vec3(prism_size)),\n            Material(2, vec3( 0.193093, 0.510542, 0.613362), 0.200000, 1.500000));\n\n    Object wall = Object(\n            Transform(RotateY(1.2), vec3(prism_pos, 0., 0.) + wall2prism * vec3(cos(angle), 0.0, -sin(angle)), vec3(0.1, 10.0, 25.0)),\n            Material(0, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\n    Object table = Object(\n            Transform(RotateZ(-0.18), vec3(100.0, -prism_size - 0.1 + 18.0, 0.0), vec3(100.0, 0.1, 100.0)),\n            Material(0, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\n    Object virtual_lens = Object(\n            Transform(RotateY(angle), vec3(prism_pos, 0., 0.) - (image2lens - wall2prism) * vec3(cos(angle), 0.0, -sin(angle)), vec3(27.0, 27.0, 30.0)),\n            Material(0, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\nIntersectInfo Intersections(IntersectInfo a, IntersectInfo b)\n{\n    IntersectInfo none;\n    none.t.x = MAXFLOAT;\n\n    if (a.t.y == MAXFLOAT && b.t.y == MAXFLOAT)\n    {\n\t\tif (a.t.x < b.t.x) return a;\n\t\tif (a.t.x > b.t.x) return b;\n    }\n    else if (a.t.y != MAXFLOAT && b.t.y != MAXFLOAT)\n    {\n\t\tif (b.t.x < a.t.y && b.t.x > a.t.x) return b;\n\t\tif (a.t.x < b.t.y && a.t.x > b.t.x) return a;\n    }\n    else\n    {\n        if (a.t.y == MAXFLOAT && a.t.x > b.t.x) return b;\n        if (b.t.y == MAXFLOAT && b.t.x > a.t.x) return a;\n    }\n    return none;\n}\n\nIntersectInfo Add(IntersectInfo a, IntersectInfo b)\n{\n\tif (a.t.x < b.t.x) return a; else return b;\n}\n\nbool intersectScene(Ray ray, vec2 t, out IntersectInfo rec)\n{\n    IntersectInfo hit;\n    hit.t.x = MAXFLOAT;\n\n\t// hit = Add(hit,  Box(table, ray, t));\n\thit = Add(hit,  Box(light, ray, t));\n\thit = Add(hit,  Box(wall, ray, t));\n\t//hit = Add(hit,  Rect(virtual_lens, ray, t));\n\thit = Add(hit, Intersections(Sphere(lens1, ray, t), Sphere(lens2, ray, t)));\n\thit = Add(hit, Prism(prism, ray, t));\n    rec = hit;\n\treturn hit.t.x != MAXFLOAT;\n}\n\nfloat skyColor(Ray ray)\n{\n\tvec3 sky = texture(iChannel0, normalize(ray.direction)).rgb;\n    sky = RGB_2_XYZ * pow(sky, vec3(2.2));\n    return XYZ2WavelengthApprox(ray.wave_length, sky) * 0.5;\n}\n\n\nfloat radiance(Ray ray)\n{\n    IntersectInfo rec;\n    Material mat;\n    float intensity = 1.0;\n\n    for(int i = 0; i < DNU(MAXDEPTH); i++)\n    {\n        if (intersectScene(ray, vec2(0.001, MAXFLOAT), rec))\n        {\n            Ray wi;\n            float attenuation;\n\t\t\tfloat pdf;\n            float emission;\n\n            bool wasScattered = Material_bsdf(rec, ray, wi, attenuation, emission, pdf);\n\n            ray.origin = wi.origin;\n            ray.direction = wi.direction;\n\n            if (wasScattered && intensity > 0.01)\n                intensity *= attenuation * ScatterPDF(rec, ray) / pdf;\n            else\n            {\n                return intensity * emission;\n            }\n        }\n        else\n        {\n            return intensity * skyColor(ray);\n        }\n    }\n\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    uvec2 p = uvec2(fragCoord);\n\tseedA = p.x + 1920U*p.y + (1920U*1080U)*uint(iFrame);\n\tseedB = p.y + 1920U*p.x + (1920U*1080U)*uint(iFrame);\n\n    //vec3 lookfrom = vec3(13.0, 2.0, 3.0);\n    const vec3 lookat = vec3(prism_pos, 0.0, 0.0);\n    float aperture = 1.0;\n\n    if (iMouse.z + iMouse.w < 1.0)\n    {\n        vec2 mo1 = vec2(0.59, 0.53);\n        vec2 mo2 = vec2(0.3, 0.7);\n        vec2 mo3 = vec2(0.1, 0.50);\n        mo = mo1;\n        float time = iTime - 17.0 * floor(iTime / 17.0);\n        mo = mix(mo, mo2, smoothstep(1.0, 4.0, time));\n        mo = mix(mo, mo3, smoothstep(5.0, 10.0, time));\n        mo = mix(mo, mo1, smoothstep(10.0, 17.0, time));\n    }\n\t// camera\n    float theta = 6.283*(0.5 * mo.y - 0.5);\n    vec3 ro = vec3(cos(6.283*mo.x) * sin(theta),\n                   cos(theta),\n                   sin(6.283*mo.x) * sin(theta));\n\n    float camera_dist = 150.0;\n  \tro *= camera_dist;\n    ro += lookat;\n    float distToFocus = length(lookat - ro);\n\n    Camera camera;\n    Camera_init(camera, ro, lookat, vec3(0.0f, 1.0f, 0.0f), 45.0f, float(iResolution.x) / float(iResolution.y), aperture, distToFocus);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    vec2 uv = fragCoord / vec2(iResolution);\n\n    Ray r = Camera_getRay(camera, uv);\n\n\n    int samples = DNU(NUMSAMPLES);\n\n    // HACK!! More rays for the projection on the wall.\n    // BEGIN\n    IntersectInfo rec;\n    rec = Box(wall, Camera_getRay(camera, uv), vec2(0.001, MAXFLOAT));\n    if (rec.t.x != MAXFLOAT)\n        samples = DNU(NUMSAMPLES_MAX);\n    // END\n\n    for (int s = 0; s < samples; s++)\n    {\n        Ray r = Camera_getRay(camera, uv);\n        r.wave_length = rand(400.0, 700.0);\n\n        float intensity = radiance(r);\n\n        // vec3 color = cie_colour_match[r.wave_length] * D65[r.wave_length];\n        vec3 color = wavelength2XYZ(r.wave_length);\n\n        col += color * intensity;\n    }\n    col = XYZ_2_RGB * col;\n    col /= float(samples);\n    col /= 40.0;\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\n    // compress\n    col = 1.35*col/(1.0+col);\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    //// s-surve\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n\n    // output\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4760, 4760, 4774, 4774, 4955], [4957, 4957, 4972, 4972, 5037], [5039, 5039, 5053, 5053, 5210], [5212, 5212, 5242, 5242, 5276], [5278, 5335, 5362, 5362, 5504], [5506, 5559, 5587, 5587, 5701], [5703, 5703, 5749, 5749, 5804], [5806, 5806, 5854, 5854, 5938], [5941, 6158, 6188, 6188, 6388], [6391, 6610, 6659, 6659, 6711], [6713, 6713, 6743, 6743, 6954], [6957, 6957, 6987, 6987, 7188], [7599, 7599, 7653, 7653, 7712], [7714, 7714, 7766, 7766, 7823], [7825, 7825, 7880, 7880, 7934], [7936, 7936, 7989, 7989, 8043], [8045, 8045, 8093, 8093, 9363], [9366, 9366, 9415, 9415, 10084], [10087, 10087, 10137, 10137, 12211], [12215, 12215, 12269, 12269, 13569], [13571, 13886, 13928, 13928, 14114], [14116, 14116, 14187, 14187, 14418], [14420, 14420, 14453, 14453, 14493], [14611, 14611, 14745, 14745, 15218], [15221, 15221, 15264, 15264, 15572], [15654, 15654, 15773, 15773, 18631], [18633, 18633, 18677, 18677, 18858], [20735, 20735, 20798, 20798, 21287], [21289, 21289, 21342, 21342, 21389], [21391, 21391, 21452, 21452, 21827], [21829, 21829, 21854, 21854, 22022], [22025, 22025, 22050, 22050, 22827], [22829, 22829, 22886, 22886, 25136]], "test": "untested"}
{"id": "3sKcRd", "name": "Spectral", "author": "Pidhorskyi", "description": "Spectral ray tracing.", "tags": ["raytracing", "spectral"], "likes": 27, "viewed": 769, "published": 3, "date": "1603777042", "time_retrieved": "2024-07-30T20:37:58.807151", "image_code": "/*\nStanislav Pidhorskyi 2020\n\nThis one is inspired by the book by Peter Shirley \"Ray Tracing: The Rest of Your Life\".\n\n\nI implemented a spectral path tracer, where each ray has a random wavelength. Surprisingly, it's not much noisier than conventional RGB path tracing.\nWavelength is sampled uniformly from 400.0nm to 700.0nm, but of course, it would be better to utilize importance sampling here and sample more those wavelengths that contribute to the RGB color more.\n\nSpecter can be converted to the color values by computing dot products with color matching functions. \nI used CIE color-matching functions that I took from John Walker website: https://www.fourmilab.ch/documents/specrend/\nThese functions are tabulated and correspond to the CIE tristimulus values X, Y, and Z.\nThe lookup table would not be too large, but it seems to be a significant source of slowdown, so I decided to approximate them with Gaussians.\nBut before with dive into the approximation, it worth noting that white color does not have a uniform specter.\nIn order to get sources of white light, we need to use a specific specter, like Illuminant D65.\nI took the values for D65 from here: https://www.waveformlighting.com/tech/calculate-illuminant-d-spd-and-cie-1931-xy-from-color-temperature/\nI computed the point-wise product of D65 specter and CIE color-matching functions so that we could pretend that now the white color has a uniform specter.\nThe result functions I approximated with Gaussians and a mixture of two Gaussians for the Red color:\n\n\nRed:    \t8233.31 * f(l | mu=593.95, sigma=34.00) + 1891.26 * f(l | mu=448.89, sigma=18.785),\nGreen:      10522.64 * f(l | 555.38, 40.80),\nBlue:       111254.78 * f(l | mu=452.98, sigma=21.57)\n\nwhere f(l) = 1/(sigma sqrt(2 * pi)) * exp(-1/2 * ((l - mu) / sigma)^2)\n\nCode for computing the coefficients can be found here: https://gist.github.com/podgorskiy/99c283773f7cee8e71386aa8ef622fdf\n\nRepresented in this way, it would be actually not hard to compute a CDF and perform importance sampling, but I did not do it. I just used uniform sampling for wavelengths.\n\nTo compute the XYZ values given a specter, we need to compute the integral of the point-wise product of the specter with the color matching functions. \nThe integral is computed in the Monte Carlo way by sampling wavelength at random and then accumulating the XYZ values. The averaged XYZ value is then converted to RGB\n\nIn order to actually appreciate the spectral path tracing, we need to make the refraction index to be a function of the wavelength. Otherwise, the output of the spectral raytracer won't differ from the conventional one.\n\nI use the Sellmeier equation https://en.wikipedia.org/wiki/Sellmeier_equation. The material of the prism is Flint glass, parameters I found here: https://refractiveindex.info/?shelf=glass&book=SCHOTT-F&page=F2.\n\nTo sample from the cubemap, we need to do an inverse operation, go from RGB values to a specter. Sure, that's an ill-posed problem, but we could approach it with some basis of orthogonal functions and Non-negative least squares (NNLS), but that would be too costly. Instead, I used a very naive way and assumed that the CIE color-matching functions are orthogonal (which are not) and used just a dot product. \nBecause of such a naive assumption, colors are off.\n\nAnd finally, I wrote the code for a ray-prism intersection because I could not find one.\n\n----------------------------------------\n\nReuses some code from https://www.shadertoy.com/view/lssBD7 that implements Peter Shirley's \"Ray Tracing in One Weekend\" pathtracer.\n\nPost-processing from Inigo Quilezh's `Happy Jumping` ttps://www.shadertoy.com/view/3lsSzf\n\n\n*/\n\n#define PI \t\t\t3.1415926535\n#define MAXFLOAT\t99999.99\n\n#define MAXDEPTH \t8\n#define NUMSAMPLES \t64\n\n\n// Do not unroll.\n#define DNU(X)  min(int(iResolution.x) << 12, X)\n\nconst mat3 XYZ_2_RGB = (mat3(\n     3.2404542,-0.9692660, 0.0556434,\n    -1.5371385, 1.8760108,-0.2040259,\n    -0.4985314, 0.0415560, 1.0572252\n));\n\nconst mat3 RGB_2_XYZ = (mat3(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041\n));\n\nuint seedA = 0x9c127997U;\nuint seedB = 0x140b75b2U;\n\nuint urand()\n{\n\tuint x = seedA;\n\tuint y = seedB;\n\tseedA = y;\n\tx ^= x << 23;\n\tseedB = x ^ y ^ (x >> 17) ^ (y >> 26);\n    uint n = seedB + y;\n\treturn n * (n * n * 15731U + 789221U) + 1376312589U;\n}\n\nfloat rand1()\n{\n \treturn uintBitsToFloat( (urand()>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 rand2()\n{\n \tfloat a = uintBitsToFloat( (urand()>>9U) | 0x3f800000U ) - 1.0;\n \tfloat b = uintBitsToFloat( (urand()>>9U) | 0x3f800000U ) - 1.0;\n    return vec2(a, b);\n}\n\n\nfloat rand(float a, float b)\n{\n \treturn rand1() * (b - a) + a;\n}\n\n// Random unit vector, uniformly distributed on a sphere\nvec3 random_unit_vector()\n{\n    float a = rand(0.0, 2. * PI);\n    float z = rand(-1.0, 1.0);\n    float r = sqrt(1.0 - z*z);\n    return vec3(r * cos(a), r * sin(a), z);\n}\n\n// Random, uniformely distributed point on unit disk\nvec2 random_in_unit_disk()\n{\n    vec2 uv = rand2();\n    float theta = 6.283185 * uv.x;\n    return sqrt(uv.y) * vec2(cos(theta), sin(theta));\n}\n\nvec3 random_cosine_direction(in vec3 normal)\n{\n    return normalize(normal + random_unit_vector());\n}\n\nfloat gaussian(float x, float mu, float sigma)\n{\n    return 1.0 / (sigma * sqrt(2.0 * PI)) * exp(-(x-mu)*(x-mu)/(2.*sigma*sigma));\n}\n\n\n// The CIE color matching functions were taken from  https://www.fourmilab.ch/documents/specrend\n// The tabulated functions then were approximated with gaussians (for G and B) and with a mixture of two gaussiuns (R).\nvec3 wavelength2XYZ(float l)\n{\n\treturn vec3(\n    \t8233.31 * gaussian(l, 593.95, 34.00) + 1891.26 * gaussian(l, 448.89, 18.785),\n        10522.64 * gaussian(l, 555.38, 40.80),\n        11254.78 * gaussian(l, 452.98, 21.57)\n    );\n}\n\n\n// Very very crude convertion from XYZ color to spectrum. It is wrong in many ways, but I don't know a faster way to do it.\n// The assumption is that the three color matching functions are orthogonal, but they are not.\nfloat XYZ2WavelengthApprox(float l, vec3 color)\n{\n    return dot(wavelength2XYZ(l), color) / 100.0;\n}\n\nfloat glass_crown_n(float l)\n{\n    l /= 1000.0;\n    float l2 = l * l;\n\tvec3 k = vec3(1.03961212, 0.231792344, 1.01046945) * l2 /\n        (l2 - vec3(0.0060007, 0.020018, 103.560));\n\treturn 1.0 * (sqrt(1. + dot(k, vec3(1.0))) - 1.52) + 1.52;\n}\n\n\nfloat glass_flint_n(float l)\n{\n    l /= 1000.0;\n    float l2 = l * l;\n\tvec3 k = vec3(1.34533359, 0.209073176, 0.937357162) * l2 /\n        (l2 - vec3(0.00997743871, 0.0470450767, 111.886764));\n\treturn sqrt(1. + dot(k, vec3(1.0)));\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float wave_length;\n};\n\nstruct Material\n{\n    int   materialType;\n    vec3  albedo;\n    float fuzz;\n    float refractionIndex;\n};\n\nstruct IntersectInfo\n{\n    vec2 t;\n    vec3  p;\n    vec3  normal;\n    Material mat;\n};\n\nstruct Transform\n{\n\tmat3 rotation;\n    vec3 position;\n    vec3 scale;\n};\n\nstruct Object\n{\n    Transform transform;\n    Material mat;\n};\n\nvec3 InvertseTransformPosition(Transform tr, vec3 p)\n{\n    return (tr.rotation * (p - tr.position)) / tr.scale;\n}\n\nvec3 DirectTransformPosition(Transform tr, vec3 p)\n{\n    return (p * tr.scale) * tr.rotation + tr.position;\n}\n\nvec3 InvertseTransformDirection(Transform tr, vec3 d)\n{\n    return normalize((tr.rotation * d) / tr.scale);\n}\n\nvec3 DirectTransformDirection(Transform tr, vec3 d)\n{\n    return normalize((d * tr.scale) * tr.rotation);\n}\n\nIntersectInfo Box(Object box, Ray ray, vec2 t)\n{\n    Transform tr = box.transform;\n    IntersectInfo rec;\n    rec.t.x = MAXFLOAT;\n    vec3 o = InvertseTransformPosition(tr, ray.origin);\n    vec3 d = InvertseTransformDirection(tr, ray.direction);\n    vec3 m = 1.0 / d;\n    vec3 k = abs(m);\n    vec3 a = -m * o -k;\n    vec3 b = a + k * 2.0;\n    float near = max(max(a.x, a.y), a.z);\n    float far = min(min(b.x, b.y), b.z);\n    if (near > far)\n    {\n\t\treturn rec;\n    }\n\n    vec3 localPosFar = o + far * d;\n    vec3 localPosNear = o + near * d;\n    vec3 posFar = DirectTransformPosition(tr, localPosFar);\n    vec3 posNear = DirectTransformPosition(tr, localPosNear);\n\n    float dmax = dot(posFar - ray.origin, ray.direction);\n    float dmin = dot(posNear - ray.origin, ray.direction);\n\n    if (dmin < t.y && dmin > t.x)\n    {\n       rec.t = vec2(dmin, dmax);\n       rec.p                = posNear;\n       vec3 f = step(0.999, abs(localPosNear));\n       rec.normal = normalize(localPosNear * f * tr.rotation);\n       rec.mat = box.mat;\n    }\n\telse\n    if (dmax < t.y && dmax > t.x)\n    {\n       rec.t = vec2(dmax, MAXFLOAT);\n       rec.p                = posFar;\n       vec3 f = step(0.999, abs(localPosFar));\n       rec.normal = normalize(localPosFar * f * tr.rotation);\n       rec.mat = box.mat;\n    }\n    return rec;\n}\n\n\nIntersectInfo Prism(Object box, Ray ray, vec2 t)\n{\n    Transform tr = box.transform;\n    IntersectInfo rec;\n    rec.t.x = MAXFLOAT;\n    vec3 o = InvertseTransformPosition(tr, ray.origin);\n    vec3 d = InvertseTransformDirection(tr, ray.direction);\n    vec3 m = 1.0 / d;\n    vec3 k = abs(m);\n    vec3 a = -m * o -k;\n    vec3 b = a + k * 2.0;\n    float near = max(max(a.x, a.y), a.z);\n    float far = min(min(b.x, b.y), b.z);\n    if (near > far)\n    {\n\t\treturn rec;\n    }\n\n    vec3 pn1 = normalize(vec3(2.0, 1.0, 0.0));\n    vec3 pn2 = pn1;\n    pn2.x = -pn2.x;\n    float pm1 = -1.0 / dot(pn1, d);\n    float pm2 = -1.0 / dot(pn2, d);\n    float p1 = dot(o, pn1) * pm1 - pn1.y * pm1;\n    float p2 = dot(o, pn2) * pm2 - pn2.y * pm2;\n    float pb = o.y * m.y + m.y;\n\n    if (pm1 > 0.0)\n     \tnear = max(near, p1);\n    else\n      \tfar = min(far, p1);\n    if (pm2 > 0.0)\n      \tnear = max(near, p2);\n    else\n      \tfar = min(far, p2);\n\n    if (near > far)\n    {\n\t\treturn rec;\n    }\n\n    vec3 localPosFar = o + far * d;\n    vec3 localPosNear = o + near * d;\n    vec3 posFar = DirectTransformPosition(tr, localPosFar);\n    vec3 posNear = DirectTransformPosition(tr, localPosNear);\n\n    float dmax = dot(posFar - ray.origin, ray.direction);\n    float dmin = dot(posNear - ray.origin, ray.direction);\n\n    if (dmin < t.y && dmin > t.x)\n    {\n       rec.t = vec2(dmin, dmax);\n       rec.p                = posNear;\n       vec3 f = step(0.9999, abs(localPosNear));\n       rec.normal = normalize(sign(localPosNear) * f);\n       if (all( lessThan(f, vec3(1.0))))\n       {\n           rec.normal = mix(pn1, pn2, bvec3(localPosNear.x < 0.0));\n       }\n       rec.normal *= tr.rotation;\n       rec.mat = box.mat;\n    }\n\telse\n    if (dmax < t.y && dmax > t.x)\n    {\n       rec.t = vec2(dmax, MAXFLOAT);\n       rec.p                = posFar;\n       vec3 f = step(0.9999, abs(localPosFar));\n       rec.normal = normalize(localPosFar * f);\n       if (all( lessThan(f, vec3(1.0))))\n       {\n           rec.normal = mix(pn1, pn2, bvec3(localPosFar.x < 0.0));\n       }\n       rec.normal *= tr.rotation;\n       rec.mat = box.mat;\n    }\n    return rec;\n}\n\n\n\nIntersectInfo Sphere(Object sphere, Ray ray, vec2 t)\n{\n    Transform tr = sphere.transform;\n    IntersectInfo rec;\n    rec.t.x = MAXFLOAT;\n    vec3 o = InvertseTransformPosition(tr, ray.origin);\n    vec3 d = InvertseTransformDirection(tr, ray.direction);\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, o);\n    float c = dot(o, o) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0f)\n    {\n    \treturn rec;\n    }\n\n    float D = sqrt(discriminant);\n    vec2 temp = vec2(D - b, -D - b) / 2.0 / a;\n\n    vec3 localPosMax = o + temp.x * d;\n    vec3 localPosMin = o + temp.y * d;\n    vec3 posMax = DirectTransformPosition(tr, localPosMax);\n    vec3 posMin = DirectTransformPosition(tr, localPosMin);\n\n    float dmax = dot(posMax - ray.origin, ray.direction);\n    float dmin = dot(posMin - ray.origin, ray.direction);\n\n    if (dmin < t.y && dmin > t.x)\n    {\n       rec.t                = vec2(dmin, dmax);\n       rec.p                = posMin;\n       rec.normal           = normalize(localPosMin * tr.scale * tr.rotation);\n       rec.mat = sphere.mat;\n    }\n\telse\n    if (dmax < t.y && dmax > t.x)\n    {\n       rec.t                = vec2(dmax, MAXFLOAT);\n       rec.p                = posMax;\n       rec.normal           = normalize(localPosMax * tr.scale * tr.rotation);\n       rec.mat = sphere.mat;\n    }\n    return rec;\n}\n\n// Schlick's approximation for approximating the contribution of the Fresnel factor\n// in the specular reflection of light from a non-conducting surface between two media\n//\n// Theta is the angle between the direction from which the incident light is coming and\n// the normal of the interface between the two media\nfloat schlick(float cos_theta, float n2)\n{\n    const float n1 = 1.0f;  // refraction index for air\n\n    float r0s = (n1 - n2) / (n1 + n2);\n    float r0 = r0s * r0s;\n\n    return r0 + (1.0f - r0) * pow((1.0f - cos_theta), 5.0f);\n}\n\nbool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n    refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n    return discriminant > 0.0f;\n}\n\nvec3 reflectVec(vec3 v, vec3 n)\n{\n     return v - 2.0f * dot(v, n) * n;\n}\n\n\nstruct Camera\n{\n    float apertureRadius;\n    vec3 origin;\n    mat3 cam;\n    mat3 k_inv;\n    float focusDist;\n};\n\n\nvoid Camera_init(out Camera camera, vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focusDist)\n{\n    camera.apertureRadius = aperture;\n    camera.focusDist = focusDist;\n\n    float theta = vfov * PI / 180.0;\n    float halfHeight = tan(theta / 2.0);\n    float halfWidth = aspect * halfHeight;\n\n    camera.origin = lookfrom;\n\n    vec3 z = normalize(lookfrom - lookat);\n    vec3 x = normalize(cross(vup, z));\n    vec3 y = normalize(cross(z, x));\n\n    camera.cam = mat3(x, y, z);\n    camera.k_inv = mat3(vec3(halfWidth, 0, 0), vec3(0, halfHeight, 0), vec3(0.0, 0.0, -1.));\n}\n\n\nRay Camera_getRay(Camera camera, vec2 uv)\n{\n    vec3 rd = camera.apertureRadius * vec3(random_in_unit_disk(), 0.0);\n\n    Ray ray;\n    vec2 pixel = 1.0/iResolution.xy;\n\tuv += pixel * (rand2() - 0.5);\n    uv = 2.0 * uv - 1.0;\n\n    ray.origin = camera.origin;\n    ray.direction = camera.cam * (normalize(camera.k_inv * vec3(uv, 1.0)));\n\n    return ray;\n}\n\n#define LAMBERT    0\n#define METAL      1\n#define DIELECTRIC 2\n#define LIGHT 3\n\nbool Material_bsdf(IntersectInfo rec, Ray wo, out Ray wi, out float attenuation, out float emission)\n{\n    int materialType = rec.mat.materialType;\n\n    if(materialType == LAMBERT)\n    {\n        wi.origin = rec.p;\n        wi.direction = random_cosine_direction(rec.normal);\n        attenuation = rec.mat.albedo.x;\n        return true;\n    }\n    else if(materialType == LIGHT)\n    {\n        emission = 1.0;\n        return false;\n    }\n    else\n    if(materialType == METAL)\n    {\n        vec3 reflected = reflect(normalize(wo.direction), rec.normal);\n\n        wi.origin = rec.p;\n        wi.direction = reflected + rec.mat.fuzz * random_cosine_direction(rec.normal);\n\n        attenuation = rec.mat.albedo.x;\n\n        return (dot(wi.direction, rec.normal) > 0.0f);\n    }\n    else\n    if(materialType == DIELECTRIC)\n    {\n        vec3 outward_normal;\n        vec3 reflected = reflect(wo.direction, rec.normal);\n\n        float ni_over_nt;\n\n        attenuation = 1.0f;\n        vec3 refracted;\n        float reflect_prob;\n        float cosine;\n\n        float rafractionIndex = glass_flint_n(wo.wave_length);\n\n        if (dot(wo.direction, rec.normal) > 0.0f)\n        {\n            outward_normal = -rec.normal;\n            ni_over_nt = rafractionIndex;\n\n            cosine = dot(wo.direction, rec.normal) / length(wo.direction);\n            cosine = sqrt(1.0f - rafractionIndex * rafractionIndex * (1.0f - cosine * cosine));\n        }\n        else\n        {\n            outward_normal = rec.normal;\n            ni_over_nt = 1.0f / rafractionIndex;\n            cosine = -dot(wo.direction, rec.normal) / length(wo.direction);\n        }\n        if (refractVec(wo.direction, outward_normal, ni_over_nt, refracted))\n            reflect_prob = schlick(cosine, rafractionIndex);\n        else\n            reflect_prob = 1.0f;\n\n        if (rand1() < reflect_prob)\n        {\n            wi.origin = rec.p;\n            wi.direction = reflected;\n        }\n        else\n        {\n            wi.origin = rec.p;\n            wi.direction = refracted;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nObject prism = Object(\n    \tTransform(mat3(1.0), vec3(0.0, 2.0, 0.0), vec3(2.0, 2.0, 2.0)),\n    \tMaterial(2, vec3( 0.193093, 0.510542, 0.613362), 0.200000, 1.500000));\n\nObject table = Object(\n    \tTransform(mat3(1.0), vec3(-4.5, -2.1, 0.0), vec3(5.5, 0.1, 5.0)),\n    \tMaterial(0, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\nObject prop1 = Object(\n    \tTransform(mat3(1.0), vec3(0.0, -1.001, -1.9), vec3(1.0, 1.0, 0.1)),\n    \tMaterial(0, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\nObject prop2 = Object(\n    \tTransform(mat3(1.0), vec3(0.0, -1.001, 1.9), vec3(1.0, 1.0, 0.1)),\n    \tMaterial(0, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\nObject light = Object(\n    \tTransform(mat3(1.0), vec3(-9.0, -1.0, 0.0), vec3(1.0, 1.0, 1.0)),\n    \tMaterial(3, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\nObject wall = Object(\n    \tTransform(mat3(1.0), vec3(10.0, 0.0, 0.0), vec3(0.1, 10.0, 10.0)),\n    \tMaterial(0, vec3( 0.500000, 0.500000, 0.500000), 1.000000, 1.500000));\n\nIntersectInfo Add(IntersectInfo a, IntersectInfo b)\n{\n\tif (a.t.x < b.t.x) return a; else return b;\n}\n\nbool intersectScene(Ray ray, vec2 t, out IntersectInfo rec)\n{\n    IntersectInfo hit;\n    hit.t.x = MAXFLOAT;\n\n\thit = Add(hit,  Box(table, ray, t));\n\thit = Add(hit,  Box(prop1, ray, t));\n\thit = Add(hit,  Box(prop2, ray, t));\n\thit = Add(hit,  Box(light, ray, t));\n\thit = Add(hit, Prism(prism, ray, t));\n\n    rec = hit;\n\treturn hit.t.x != MAXFLOAT;\n}\n\nfloat skyColor(Ray ray)\n{\n\tvec3 sky = texture(iChannel0, normalize(ray.direction)).rgb;\n    sky = RGB_2_XYZ * pow(sky, vec3(2.2));\n    return XYZ2WavelengthApprox(ray.wave_length, sky);\n}\n\n\nfloat radiance(Ray ray)\n{\n    IntersectInfo rec;\n    Material mat;\n    float intensity = 1.0;\n\n    for(int i = 0; i < DNU(MAXDEPTH); i++)\n    {\n        if (intersectScene(ray, vec2(0.001, MAXFLOAT), rec))\n        {\n            Ray wi;\n            float attenuation;\n            float emission;\n\n            bool wasScattered = Material_bsdf(rec, ray, wi, attenuation, emission);\n\n            ray.origin = wi.origin;\n            ray.direction = wi.direction;\n\n            if (wasScattered && intensity > 0.01)\n                intensity *= attenuation;\n            else\n            {\n                return intensity * emission;\n            }\n        }\n        else\n        {\n            return intensity * skyColor(ray);\n        }\n    }\n\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    uvec2 p = uvec2(fragCoord);\n\tseedA = p.x + 1920U*p.y + (1920U*1080U)*uint(iFrame);\n\tseedB = p.y + 1920U*p.x + (1920U*1080U)*uint(iFrame);\n\n    //vec3 lookfrom = vec3(13.0, 2.0, 3.0);\n    const vec3 lookat = vec3(0.0, 1.5, 0.0);\n    float aperture = 1.0;\n\n    if (iMouse.z + iMouse.w < 1.0)\n    {\n        vec2 mo1 = vec2(0.59, 0.53);\n        vec2 mo2 = vec2(0.5, 0.415);\n        vec2 mo3 = vec2(0.5, 0.895);\n        vec2 mo4 = vec2(0.4, 0.4);\n        vec2 mo5 = vec2(0.1, 0.5);\n        mo = mo1;\n        float time = iTime - 25.0 * floor(iTime / 25.0);\n        mo = mix(mo, mo2, smoothstep(1.0, 4.0, time));\n        mo = mix(mo, mo3, smoothstep(5.0, 10.0, time));\n        mo = mix(mo, mo4, smoothstep(12.0, 15.0, time));\n        mo = mix(mo, mo5, smoothstep(15.0, 20.0, time));\n        mo = mix(mo, mo1, smoothstep(20.0, 25.0, time));\n    }\n\t// camera\n    float theta = 6.283*(0.5 * mo.y - 0.5);\n    vec3 ro = vec3(cos(6.283*mo.x) * sin(theta),\n                   cos(theta),\n                   sin(6.283*mo.x) * sin(theta));\n  \tro *= 35.0;\n    float distToFocus = length(lookat - ro);\n\n    Camera camera;\n    Camera_init(camera, ro, lookat, vec3(0.0f, 1.0f, 0.0f), 20.0f, float(iResolution.x) / float(iResolution.y), aperture, distToFocus);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    vec2 uv = fragCoord / vec2(iResolution);\n\n    IntersectInfo rec;\n    for (int s = 0; s < DNU(NUMSAMPLES); s++)\n    {\n        Ray r = Camera_getRay(camera, uv);\n        r.wave_length = rand(400.0, 700.0);\n\n        float intensity = radiance(r);\n\n        // vec3 color = cie_colour_match[r.wave_length] * D65[r.wave_length];\n        vec3 color = wavelength2XYZ(r.wave_length);\n\n        col += color * intensity;\n    }\n    col = XYZ_2_RGB * col;\n    col /= float(NUMSAMPLES);\n    col /= 40.0;\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\n    // compress\n    col = 1.35*col/(1.0+col);\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    //// s-surve\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n\n    // output\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4184, 4184, 4198, 4198, 4379], [4381, 4381, 4396, 4396, 4461], [4463, 4463, 4477, 4477, 4634], [4637, 4637, 4667, 4667, 4701], [4703, 4760, 4787, 4787, 4929], [4931, 4984, 5012, 5012, 5126], [5128, 5128, 5174, 5174, 5229], [5231, 5231, 5279, 5279, 5363], [5366, 5583, 5613, 5613, 5812], [5815, 6034, 6083, 6083, 6135], [6137, 6137, 6167, 6167, 6378], [6381, 6381, 6411, 6411, 6612], [7023, 7023, 7077, 7077, 7136], [7138, 7138, 7190, 7190, 7247], [7249, 7249, 7304, 7304, 7358], [7360, 7360, 7413, 7413, 7467], [7469, 7469, 7517, 7517, 8787], [8790, 8790, 8840, 8840, 10914], [10918, 10918, 10972, 10972, 12272], [12274, 12589, 12631, 12631, 12817], [12819, 12819, 12890, 12890, 13121], [13123, 13123, 13156, 13156, 13196], [13314, 13314, 13448, 13448, 13921], [13924, 13924, 13967, 13967, 14275], [14357, 14357, 14459, 14459, 16444], [17473, 17473, 17526, 17526, 17573], [17575, 17575, 17636, 17636, 17922], [17924, 17924, 17949, 17949, 18111], [18114, 18114, 18139, 18139, 18868], [18870, 18870, 18927, 18927, 21015]], "test": "untested"}
{"id": "wdyyDV", "name": "Vine jungle", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wsycDK]\"Twisted thorn lattice\"[/url] fractal.", "tags": ["fractal", "vine", "jungle"], "likes": 3, "viewed": 320, "published": 3, "date": "1603763196", "time_retrieved": "2024-07-30T20:37:59.735668", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p3)\n{\n    p3 = vec3(sceneSDF1(p3*7.0),sceneSDF1(p3/11.0),sceneSDF1(p3/13.0));\n    //surface color\n    return sin((p3+.2)/p3.zyx)/2.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth/10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n     vec3 p = depth_map(fragCoord);\n        vec3 worldDir = normalize(p-eye);\n        float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n            if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n        p = eye+dist*worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)+cos(p))-1.0);\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    p /= 8.0;\n    for(float i = 1.0; i < 8.0; i*= 2.0){\n        float i1 = i*i;\n        p += (sin(p.yzx/i1+i1)+cos(p.yzx/i1+i1))*(i1);\n    \tresult = max(sceneSDF1(p*i1)/i1,result);\n    }\n    return (result-.05)*4.0;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p3)\n{\n    p3 = vec3(sceneSDF1(p3*7.0),sceneSDF1(p3/11.0),sceneSDF1(p3/13.0));\n    //surface color\n    return sin((p3+.2)/p3.zyx)/2.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth/10.0)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 89, 89, 219], [221, 642, 733, 733, 1101], [1116, 1370, 1435, 1435, 1567], [1569, 1658, 1687, 1687, 1997], [1999, 2491, 2631, 2631, 3221], [3223, 3593, 3678, 3678, 4436], [4438, 4765, 4814, 4849, 4980], [4982, 4982, 5009, 5009, 5158], [5160, 5160, 5217, 5217, 5880]], "test": "untested"}
{"id": "wsycDK", "name": "Twisted thorn lattice", "author": "jarble", "description": "A spiky lattice-like twisted structure.", "tags": ["fractal", "thorn"], "likes": 3, "viewed": 315, "published": 3, "date": "1603747546", "time_retrieved": "2024-07-30T20:38:00.603348", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth/10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.01;\n\nvec3 surface_color(vec3 p3)\n{\n    p3 = sin(p3*10.0);\n    //surface color\n    return fract((p3+.2)/p3.zyx)/2.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)+cos(p))-.6);\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result;\n    for(float i = 1.0; i < 27.0; i*= 3.0){\n        float i1 = i*i;\n        p += (sin(p.yzx/i1+i)+cos(p.yzx/i1+i))/(i1);\n    \tresult += sceneSDF1(p*i1)/i1;\n    }\n    return result/2.0;\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth/10.0)*(image_scale/2.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0);\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 893], [908, 1162, 1227, 1227, 1359], [1361, 1450, 1479, 1479, 1789], [1791, 2283, 2423, 2423, 3013], [3015, 3385, 3470, 3470, 4228], [4230, 4557, 4606, 4641, 4772], [4774, 4774, 4801, 4801, 4950], [4952, 4952, 5009, 5009, 5656]], "test": "untested"}
{"id": "wsycWK", "name": "Ignition", "author": "n0f4c3", "description": "Flames like those to ignite gas", "tags": ["fire", "flames", "ignition"], "likes": 4, "viewed": 421, "published": 3, "date": "1603743297", "time_retrieved": "2024-07-30T20:38:01.418170", "image_code": "const float PI = 3.14159265359;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMin = min(iResolution.x, iResolution.y);\n    float resMax = max(iResolution.x, iResolution.y);\n    vec2 uvMin = fragCoord/resMin;\n    vec2 uvMax = fragCoord/resMax;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \tuvMin.y -= 0.5;\n    \n    uvMin.y *= sin(uv.x*PI*2.+iTime*3.)+1.*10.;\n    \n    uvMin.y = uvMin.x+sin(sin(uvMin.y*4.));\n    \n    uvMin.x -= abs(sin(uv.y*PI));\n    uvMin.x -= iTime*3.;\n    //uv.x = uv.x*sin(iTime)+1.;//-iTime;\n    //uv.y = uv.y*cos(iTime)+1.;//-iTime;\n   // uvMin.x /= cos(fract(uvMin.y)+iTime);\n    //uv.xy *= cos(iTime/8.)*(uv.x+uv.y)*uv.y*5./uv.x;\n    \n\tfloat uvPlus = uvMin.x+uvMin.y;\n    float uvSub = uvMin.x-uvMin.y;\n    // Time varying pixel color\n    float plus = cos(uvPlus);//*cos(uvPlus*PI);\n    float sub = cos(uvSub);//*cos(uvSub*PI);\n    float flame = sqrt(pow(plus,25.) * pow(sub,25.));\n    vec3 col = vec3(flame*uv.x*2.5, flame*flame*uv.x*2., flame*flame*uv.x*uv.y*3.5);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 90, 90, 1137]], "test": "untested"}
{"id": "wsGcWK", "name": "Desert canyons", "author": "jarble", "description": "This canyon has many unusual rock formations. This is an edit of my [url=https://www.shadertoy.com/view/wdKyDG]\"Cratered moonscape\"[/url] fractal terrain.", "tags": ["fractal", "desert", "canyon"], "likes": 1, "viewed": 303, "published": 3, "date": "1603742794", "time_retrieved": "2024-07-30T20:38:02.288841", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 a){\n    return (sin(a)+cos(a));\n}\n\nfloat planet_surface(vec3 p){\n    p /= 10.0;\n    //p /= 100.0;\n    p += warp(p.yzx/size)*size;\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx+(length(sin(p/100.0))+sin(p1.yxz))))*size;\n    return (length(p) + p.y - size)*5.0;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= .01;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    //p *= 2.0;\n    for(int k = 0; k < 3; k++){\n        result -= min(-result,planet_surface(p*i))/(i*i);\n        i *= -1.5;\n        //p *= -1.0001;\n        //i /= 2.0;\n        //i /= -3.0;\n        //p *= 3.0;\n        //i /= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return (result-p.y*2.0)/2000.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= 10.0;\n    return sin(vec3(planet_surface(p)*2.0+.5,planet_surface(p)*2.0,planet_surface(p*10.0)*2.0))/12.0+vec3(.7,.5,.3)*1.6;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    float speed = 10.0;\n    float t1 = iTime/20.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-3.0, -1.0, 3.0*sin(t1/3.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 519, 537, 537, 567], [569, 569, 598, 598, 791], [795, 795, 819, 819, 1214], [1216, 1216, 1244, 1244, 1382], [1385, 1806, 1897, 1897, 2258], [2273, 2527, 2592, 2592, 2724], [2726, 2815, 2844, 2844, 3154], [3156, 3648, 3788, 3788, 4398], [4400, 4770, 4855, 4855, 5270], [5272, 5599, 5648, 5683, 5814], [5816, 5816, 5873, 5873, 6829]], "test": "untested"}
{"id": "tsyyWK", "name": "Freistil in colors", "author": "mrange", "description": "License CC0: Freistil in Colors\n  Created for twitch streamer FullStackLive just for fun\n", "tags": ["3d", "grid"], "likes": 9, "viewed": 461, "published": 3, "date": "1603741153", "time_retrieved": "2024-07-30T20:38:03.104660", "image_code": "// License CC0: Freistil in Colors\n//  Created for twitch streamer FullStackLive just for fun\n\n// Heavily inspired by \"Grid of Cylinders\" and while I understood how it worked\n//  in concept I didn't get the math so I had to resort to pen and paper to recreate it :)\n\n// Cylinder intersection by IQ: https://iquilezles.org/articles/intersectors\n// SDFs by IQ: https://iquilezles.org/articles/distfunctions2d\n// Smooth min by IQ: https://iquilezles.org/articles/smin\n\nconst float globalHeight    = 2.75;\nconst float eps             = 1E-4;\nconst float miss            = -1E6;\nconst float delta           = 1.0 ;\n\nconst vec3 lightPos1        = 100.0*vec3(2.0, .35, -1.0);\nconst vec3 lightPos2        = 100.0*vec3(-2.0, 3.0, 1.0);\nconst vec3 lightCol1        = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2        = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nconst vec3 lightDir1        = normalize(lightPos1);\nconst vec3 lightDir2        = normalize(lightPos2);\nconst float pi              = 3.14159654;\nconst float tau             = 2.0*pi;\n\nfloat hash1(vec2 n) { \n  return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); \n}\n\nvec2 mod2_1(inout vec2 x) {\n  vec2 n = floor(x+0.5);\n  x = fract(x+0.5)-0.5;\n  return n;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p)-(b - r);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat tanh_approx(float z) {\n  float z2 = z*z;\n  // z / (1 + z2/(3 + z2/(5 + z2/(7 + ...))))\n  return clamp(z / (1.0 + z2/(3.0+ z2/5.0)), -1.0, 1.0);\n}\n\nvec2 freistil_logo(vec2 p) {\n  vec2 mp = p;\n  vec2 mn = mod2_1(mp);\n  vec2 amp = abs(mp);\n\n  const float lw = 0.03;\n  \n  float d0 = circle(mp, 0.40);\n  vec2 d1 = -(amp-(0.5)) - lw;\n  float d3 = pmin(d1.x, d1.y, 0.1);\n  float d4 = box(p, vec2(3.0/2.0+lw), 0.1);\n\n\n  float d = 1E6;\n  d = (mn.x + mn.y) == 1.0 || mn.y == -1.0 ? d0 : d;\n  d = min(d, d3);\n  d = max(d, d4);\n  return vec2(d, d4);\n}\n\nfloat height(vec2 x, float t) {\n  vec2 n = x;\n  vec2 p = (x) * 0.025;\n  vec2 f = freistil_logo(p)-0.02;\n  float d = f.x;\n  float fh = max(tanh_approx(-d*5.0), 0.0);\n  float nh = hash1(n)*mix(0.35, 1.0, psin(iTime+max(10.0*f.y, 0.0)));\n  float m = 1.0-smoothstep(-0.1, 0.125, f.y);\n  return globalHeight*mix(nh, fh, 0.9*m);\n}\n\nvec4 cylinder(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float ra) {\n  vec3 ba     = pb-pa;\n\n  vec3  oc    = ro - pa;\n\n  float baba  = dot(ba,ba);\n  float bard  = dot(ba,rd);\n  float baoc  = dot(ba,oc);\n   \n  float k2    = baba            - bard*bard;\n  float k1    = baba*dot(oc,rd) - baoc*bard;\n  float k0    = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n  float h     = k1*k1 - k2*k0;\n    \n  if (h<0.0) return vec4(miss);\n  h = sqrt(h);\n    \n  float t = (-k1-h)/k2;\n\n  // body\n  float y = baoc + t*bard;\n  if (y>0.0 && y<baba) return vec4(t, (oc+t*rd - ba*y/baba)/ra);\n   \n  // caps\n  t = (((y<0.0) ? 0.0 : baba) - baoc)/bard;\n  if (abs(k1+k2*t)<h) return vec4(t, ba*sign(y)/sqrt(baba));\n\n  return vec4(miss);\n}\n\nvec4 gridTrace(vec3 ro, vec3 rd, float initial, const int max_iter) {\n  float t = initial;\n\n  vec2 x = 0.5*(1.0 + sign(rd.xz));\n  vec2 y = 1.0/rd.xz;\n  \n  float mt = (-globalHeight - ro.y)/rd.y;\n\n  for (int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + t*rd;\n    vec2 n = floor(p.xz);\n    vec2 m = fract(p.xz);\n\n    float h = height(n, t);\n    float dt = (h - p.y)/rd.y;\n    vec3 tp = p + dt*rd;\n    \n    if (p.y < -globalHeight) {\n      return vec4(mt, vec3(0.0, 1.0, 0.0));\n    }\n    \n    float hh = hash1(n+100.0);\n    \n    if (n == floor(tp.xz)||h > p.y) {\n      vec3 lp = vec3(m.x, p.y, m.y);\n      vec4 c = cylinder(lp, rd, vec3(0.5, -globalHeight, 0.5), vec3(0.5, h, 0.5), 0.35 + 0.145*hh);\n      float tt = t + c.x;\n      \n      if (mt >= 0.0 && tt > mt) {\n        return vec4(mt, vec3(0.0, 1.0, 0.0));\n      }\n      \n      if (c.x >= 0.0) {\n        return vec4(tt, c.yzw);\n      }\n    }\n\n    vec2 z = (x - fract(p.xz))*y;\n    t += min(z.x, z.y) + eps;\n  }\n  \n  return vec4(miss);\n}\n\nvec3 skyColor(vec3 rayDir) {\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n  final += 1.0*pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += 1.0*lightCol1 * pow(ld1, 200.0);\n  return final;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.125);\n  \n  float dup = (1.025*globalHeight - ro.y)/rd.y;\n  vec3 upp = ro + rd*dup;\n\n  vec3 sky = skyColor(rd);\n\n  if (dup > 0.0) {\n    vec4 dgt  = gridTrace(ro, rd, dup, 40);\n    float t   = dgt.x;\n    vec3 nor  = dgt.yzw;\n    vec3 gtp  = ro + rd*t;\n\n    vec2 n = floor(gtp.xz);\n    vec2 m = fract(gtp.xz);\n    float h = height(n, t);\n    float l2 = dot(gtp.xz, gtp.xz);\n\n    vec4 dst  = gridTrace(gtp + nor*0.01, lightDir1, 0.0, 8);\n\n    vec3 refl     = reflect(rd, nor);\n    vec3 reflCol  = skyColor(refl);\n\n    vec3 refr     = refract(rd, nor, 1.25);\n\n    \n    float dif1 = max(dot(lightDir1, nor), 0.0);  \n    float dif2 = max(dot(lightDir2, nor), 0.0);  \n    \n    vec3 baseCol = pow(vec3(0.5 + 0.5*sin(iTime + 0.1*vec3(n, n.x + n.y)/(1.0+0.0000125*l2)))*mix(vec3(1.0), vec3(0.125), tanh(abs(2.0*h))), vec3(1.0, 1.5, 0.5)/(1.0+0.00005*l2));\n\n    float shade = dst.x > miss ? tanh_approx(0.25*dst.x) : 1.0;\n\n    dif1 *= shade;\n    if (dgt.x > miss) {\n      col += baseCol*0.75*mix(0.125, 1.0, sqrt(dif1 + dif2));\n      col += 0.5*sqrt(reflCol)*mix(1.0, shade, max(dot(refl, lightDir1), 0.0));\n      if (refr != vec3(0.0)) {\n        col += 0.3*vec3(1.0)*pow(max(dot(refr, rd), 0.0), 100.0);\n      }\n    } else {\n      col = sky;\n    }\n    \n    float mm = 1.0-max(dot(rd, vec3(0.0, -1.0, 0.0)), 0.0);\n    mm*=mm;\n    col = mix(col, sky, mm*(1.0-exp(-0.0125*max(t-100.0, 0.0))));\n  } else {\n    col = sky;\n  }\n\n  return col;\n}\n\nvec3 pos(float time) {\n  float m1 = smoothstep(0.0, 10.0, time);\n  float m2 = smoothstep(13.0, 30.0, time);\n  float h = mix(10.0, 25.0, m1);\n  vec3 p1 = vec3(15.0*time-250.0, h, 0.5);\n  const float r = 100.0;\n  time *= 0.2;\n  float h2 = mix(25.0, 350.0, m2);\n  vec3 p2 = vec3(-r*sin(time), h2, -r*cos(time));\n  return mix(p1, p2, m2);\n}\n\nvec3 dpos(float time) {\n  float m = smoothstep(0.0, 10.0, time);\n  vec3 dp = (pos(time + delta) - pos(time - delta))/(2.0*delta);\n  rot(dp.xy, mix(1.0, 0.5, m)); \n  return dp;\n}\n\nvec3 ddpos(float time) {\n  vec3 ddp = (dpos(time + delta) - dpos(time - delta))/(2.0*delta);\n  return ddp;\n}\n\nvec3 dir(vec3 ro, float time) {\n  vec3 dpos =  normalize(dpos(time));\n  vec3 la = normalize(vec3(0.0)-ro);\n  float m = smoothstep(13.0, 20.0, time);  \n  return normalize(mix(dpos, la, m));\n}\n\nvec3 up(float time) {\n  vec3 ddp = ddpos(time);  \n  vec3 up = normalize(vec3(0.0, 1.0, 0.0) + 0.1*ddp);\n  float m = 0.5*(tanh(time - 11.0)+1.0);\n  rot(up.yz, m*tau);\n  return up;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n//  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n  p.x *= iResolution.x/ iResolution.y;\n  \n  float aa = 2.0/iResolution.y;\n\n  float tm = mod(iTime, 35.0);\n  vec3 ro  = pos(tm);\n  vec3 dir = dir(ro, tm);\n  vec3 up = up(tm);\n\n  vec3 ww = dir;\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = render(ro, rd);\n  \n  float ss1 = smoothstep(28.00, 35.0, tm);\n  float ss2 = smoothstep(33.0, 35.0, tm);\n  float ss3 = smoothstep(28.00, 31.40, tm);\n  float scale = 0.22+0.1*ss1;\n\n  vec2 lp = p;\n  rot(lp, -0.5*(1.0-tanh((tm-30.0))));\n  vec2 df = freistil_logo(lp/scale)*scale;\n  vec3 col2 = mix(vec3(1.0), vec3(ss2*ss2), smoothstep(-aa, aa, -df.x));\n  col = mix(col, col2, ss3*ss3);\n  \n  float fadeIn = 1.0 - smoothstep(0.0, 3.0, tm);\n  col += fadeIn;\n\n  col = postProcess(col, q);\n    \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyyWK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1035, 1035, 1056, 1056, 1119], [1121, 1121, 1148, 1148, 1211], [1213, 1213, 1252, 1252, 1341], [1343, 1343, 1364, 1364, 1393], [1395, 1395, 1428, 1428, 1513], [1515, 1515, 1546, 1546, 1572], [1574, 1574, 1610, 1610, 1696], [1698, 1698, 1726, 1726, 1849], [1851, 1851, 1879, 1879, 2243], [2245, 2245, 2276, 2276, 2569], [2571, 2571, 2632, 2632, 3281], [3283, 3283, 3352, 3352, 4273], [4275, 4275, 4303, 4303, 4518], [4521, 4521, 4552, 4552, 5999], [6001, 6001, 6023, 6023, 6337], [6339, 6339, 6362, 6362, 6516], [6518, 6518, 6542, 6542, 6626], [6628, 6628, 6659, 6659, 6818], [6820, 6820, 6841, 6841, 7000], [7003, 7003, 7040, 7040, 7291], [7293, 7293, 7345, 7345, 8292]], "test": "untested"}
{"id": "3t2fR3", "name": "Halloween - 'It' Tribute", "author": "dean_the_coder", "description": "Inspired by the 'drain' scene from the Stephen King 'It' movie.\nHappy Halloween everyone!\n(https://youtu.be/HsGZhpXIMBs)", "tags": ["3d", "raymarching", "halloween", "scary", "movie", "it", "clown"], "likes": 15, "viewed": 668, "published": 3, "date": "1603738927", "time_retrieved": "2024-07-30T20:38:04.156847", "image_code": "// 'It' Tribute\n//\n// Inspired by the 'drain' scene from the Stephen King 'It' movie.\n// I'd love to come back to this in the future when a) my modelling\n// skills are improved, and b) my GPU is faster. :o)\n//\n// Concrete texture reused from my earlier shader:\n// https://www.shadertoy.com/view/WllfzB\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n#define MAX_DIST 64.0\n\n//#define AA  // Enable this line if your GPU can take it!\n\nvec3 rayDir;\nfloat faceVisibility, eyeWonk, headLunge;\n\nstruct MarchData {\n    float d;\n    vec3 mat;        // RGB\n    float specPower; // 0: None, 30.0: Shiny\n    float opacity;   // 1.0: Solid\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fbm(vec3 p) {\n    return noise(p) * noise(p + 0.2) * noise(p + 0.66);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat opRep(float p, float c) {\n    float c2 = c * 0.5;\n    return mod(p + c2, c) - c2;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0.0, h);\n\treturn length(p) - r;\n}\n\nfloat sdPuddle(vec3 p, float r) {\n    r *= 0.9 + 0.1 * cos(7.0 * atan(p.x, p.y));\n    return sdCappedCylinder(p, r, 0.05);\n}\n\nfloat sdEye(vec3 p, inout vec3 mat, float openness, float maxEyeWonk) {\n    const float r = 0.5;\n    float d = length(p) - r;\n    vec3 pp = p;\n    pp.yz *= rot(0.181);\n    float frontAngle = abs(atan(pp.y, pp.z)) / 3.1415;\n\n    const float pupilSize = 0.1;\n    const float irisSize = 0.3;\n    \n    vec3 eyeRay = rayDir;\n    eyeRay.xz *= rot(0.75 * eyeWonk * maxEyeWonk);\n    vec3 pupilCenter = eyeRay * -r;\n    vec3 pupilToP = p - pupilCenter;\n    float distFromFocus = length(pupilToP);\n    \n    // Corners.\n    mat = mix(mat, vec3(0.3, 0.01, 0.05), smoothstep(0.8, 1.0, abs(p.x / r)));\n    \n    // Iris color.\n    const vec3 irisCol = vec3(0.068, 0.211, 0.18);\n    float radialTint = sin(atan(pupilToP.y, pupilToP.x) * 23.0) * 0.3 + 1.7 - irisSize * distFromFocus;\n    mat *= smoothstep(0.0, 0.05, distFromFocus - irisSize); // Gradient\n    mat = mix(mat,\n              irisCol * radialTint, // Radial lines\n              1.0 - min(distFromFocus / irisSize, 1.0)); // Solid\n    \n    // Iris outer.\n    mat *= mix(0.17, 1.0, smoothstep(0.0, 0.04, abs(distFromFocus - irisSize)));\n    \n    // Pupil.\n    mat = mix(vec3(0.01), mat, smoothstep(0.0, 0.06, distFromFocus - pupilSize));\n    \n    // Open/close eyelids.\n    mat *= smoothstep(0.1, 0.0, mix(1.1, 0.91, openness) - frontAngle);\n    return d;\n}\n\nMarchData sdHead(vec3 p, vec3 eyeMat) {\n    p -= vec3(0.0, 1.2, -2.0);\n    \n    // Eyes.\n    float openness = faceVisibility;\n    float blink = clamp(iTime - 32.0, 0.0, 0.4) / 0.4;\n    openness *= pow(abs(cos(blink * 3.1415)), 2.0);\n    \n    vec3 eyeMat1 = eyeMat;\n    MarchData result = MarchData(sdEye(p - vec3(-0.9, 0.0, 0.0), eyeMat1, openness, 1.0), eyeMat1, 30.0, 1.0);\n    \n    float eye2 = sdEye(p - vec3(0.9, 0.0, 0.0), eyeMat, openness, 0.0);\n    if (eye2 < result.d) {\n        result.d = eye2;\n        result.mat = eyeMat;\n    }\n    \n    // Forehead.\n    float ox = p.x;\n    p.x = abs(p.x);\n    float brow = (1.0 - cos(p.x * 2.9)) * 0.1;\n    float head = sdCapsule(p - vec3(0.0, 0.37 + brow, 0.0), 1.2, 0.2);\n    \n    vec3 pp = p.yxz;\n    pp.xz *= rot(0.6);\n    head = smin(head, sdCapsule(pp - vec3(-0.36, 0.0, 0.2), 0.5, 0.2), 0.5);\n    if (head < result.d) {\n        result.d = head;\n        float noseDim = mix(1.0, smoothstep(-0.4, 0.5, ox), clamp(0.3 - p.y, 0.0, 1.0));\n        result.mat = vec3(0.004 * faceVisibility * noseDim);\n        result.specPower = 1e7;\n    }\n    \n    return result;\n}\n\nfloat getConcreteMaterial(vec3 p, out vec3 mat) {\n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(p));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    float rough = noise(p * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(p * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    return rough;\n}\n\nfloat getAsphaltMaterial(vec3 p, out vec3 mat) {\n    // Surface roughness.\n    float rough = abs(fbm(p * 10.0) - 0.5) * 0.1;\n    mat = vec3(rough * 0.3);\n    return rough;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\n// Once it has been hit, we exclude the water from the scene.\nbool refracted = false;\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData result;\n    result.specPower = 1000.0;\n    result.opacity = 1.0;\n    \n    // Concrete texture.\n    vec3 concreteMat;\n    float concreteDisplacement = getConcreteMaterial(p, concreteMat);\n    result.mat = concreteMat;\n\n    // Curb.\n    vec3 rp = p;\n    rp.x = opRep(rp.x, 12.2);\n    const vec3 curbSize = vec3(6.0, 2.0, 1.0);\n    float curb = max(sdBox(rp, curbSize), 0.25 - (sdBox(p, curbSize) - 0.1));\n\n    // Paving.\n    rp.x = opRep(p.x + 2.3, 9.2);\n    float slab = sdBox(rp - vec3(0.0, 1.8, 6.0), vec3(4.5, 0.2, 4.5));\n    rp.x = opRep(p.x - 2.3, 9.2);\n    slab = min(slab, sdBox(rp - vec3(0.0, 1.8, 15.3), vec3(4.5, 0.2, 4.5)));\n    \n    if (slab < curb) {\n        // Black out underside of paving slabs.\n        result.mat *= rayDir.y < 0.0 ? 1.0 : 0.0;\n    }\n    \n\tresult.d = min(slab, curb) - 0.1 - concreteDisplacement;\n    \n    // Drain.\n    p.y += curbSize.y;\n    float drainBox = max(\n        sdBox(p, curbSize * vec3(1.025, 2.0, 1.0)) - 0.1,\n        -sdBox(p, curbSize * vec3(0.9, 1.8, 2.0)));\n    if (drainBox < result.d) {\n    \tresult.d = drainBox;\n        result.mat *= vec3(.439, .157, .035);\n    }\n    \n    // Road.\n    p.yz += vec2(0.5, 10.7);\n    vec3 mm;\n    float road = sdBox(p, vec3(100.0, 0.5 + getAsphaltMaterial(p, mm), 10.0));\n    if (road < result.d) {\n        result.mat = mm;\n        result.d = road;\n        result.specPower = 1.0;\n    }\n\n    // Head.\n    vec3 headMat;\n    vec3 pp = p - vec3(0.0, 0.6 + sin(headLunge * 6.282) * 0.1, -1.0) * headLunge * 2.0;\n    MarchData head = sdHead(pp - vec3(0.0, 0.0, 15.0), concreteMat * 1.3);\n    if (head.d < result.d)\n        result = head;\n    \n    if (!refracted) {\n        // Puddles.\n        vec3 puddleP = p.xzy - vec3(6.0, 6.0, 0.5);\n        float puddles = sdPuddle(puddleP, 1.2);\n        puddles = min(puddles, sdPuddle(puddleP - vec3(2.0, 0.0, 0.0), 2.0));\n        puddles = min(puddles, sdPuddle(puddleP - vec3(5.0, 0.0, 0.0), 1.5));\n        \n        // Stream.\n        float waterClip = sdBox(p - vec3(0.0, 0.0, 61.0), vec3(100.0, 100.0, 50.0));\n        p.xz += vec2(46.25, -151.08);\n        float edgeWave = sin(p.x - iTime * 5.0) * 0.2;\n        float radius = 150.0 + edgeWave;\n        float prad = length(p.xz);\n        float water = max(prad - radius, abs(p.y - 0.6));\n        vec3 wp = p;\n        wp.xz *= rot(iTime * 0.1) * 0.05;\n\n        float wt = iTime * 8.0;\n        float dis = (sin(p.x - wt) + 0.5 * sin((p.x - wt * 0.5) * 1.8)) * 0.25 + 0.5;\n        dis += texture(iChannel0, wp.xz).r * 0.8;\n        dis *= (radius - prad) * 0.2;\n        water -= dis;\n        water = max(water, -waterClip);\n        water = min(water, puddles);\n        \n        if (water < result.d) {\n            result.d = water;\n            result.mat = vec3(0.25, 0.3, 0.4);\n            result.specPower = 3.0;\n            result.opacity = 0.2;\n        }\n    }\n\n    return result;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, MarchData data) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(6.0, 3.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p);\n    \n    // Ambient occlusion (exluding water).\n    bool b = refracted;\n    refracted = true;\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    refracted = b;\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    \n    // Primary light.\n    vec3 lig = diff * sunCol * mix(amb, 1.0, iMouse.x/640.0);\n\n    // Specular.\n    float spe = pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), data.specPower);\n    lig += smoothstep(0.5, 1.0, spe) * 10.0;\n\n    float fre = 1.0 + dot(rd, n);\n    float fog = exp(-length(p) * 0.14);\n    return mix(data.mat * lig, vec3(0.0), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    \n    float d = 0.01;\n    float opacity = 1.0;\n    MarchData h;\n    vec3 col = vec3(0.0);\n    for (float steps = 0.0; steps < 90.0; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.d) < MIN_DIST) {\n            if (h.opacity > 0.9999 || refracted)\n            \tbreak; // We've hit a solid surface - Stop.\n            opacity = max(0.0, opacity - h.opacity);\n            col = applyLighting(p, rd, h) * h.opacity;\n            refracted = true;\n            rd = refract(rd, calcNormal(p), 0.95);\n        }\n        \n        if (d > MAX_DIST)\n            return vec3(0.0); // Distance limit reached - Stop.\n        \n        d += h.d; // No hit, so keep marching.\n    }\n    \n    // Lighting.\n    return applyLighting(p, rd, h) * opacity + col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    const float stageCount = 3.0;\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 12.0));\n    float phase = mod(floor(iTime / 12.0), stageCount);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 12.0)), 100.0);\n    \n    vec3 ro, lookAt = vec3(0.0, 0.0, 0.0);\n    faceVisibility = 0.0;\n    headLunge = 0.0;\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(-30.0, -9.0, ft), 7.0, -15.0);\n        lookAt = ro * vec3(1.1, 0.0, 0.0);\n    } else if (phase == 1.0) {\n        ro = mix(vec3(20.0, 8.0, -20), vec3(0.0, 5.0, -10.0), ft);\n        faceVisibility = min(1.0, (ft - 0.3) * 2.0);\n        eyeWonk = 1.0;\n    } else if (phase == 2.0) {\n        float progress = min(1.0, pow(ft * 4.0, 4.0));\n        eyeWonk = 1.0 - smoothstep(0.4, 1.0, (ft - 0.2) * 2.0);\n        faceVisibility = 1.0 + min(sin(eyeWonk * 3.141), 0.5);\n        headLunge = ft;\n        ro = mix(vec3(1.0, 10.0, -20), vec3(-1.0, 0.85, -5.0), progress);\n    }\n    \n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            rayDir = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rayDir);\n#ifdef AA\n            refracted = false;\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    // Output to screen.\n    col = vignette(pow(col * dim, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24113, "src": "https://soundcloud.com/naturesoundsofficial/ambient-stream-1", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2fR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[813, 869, 890, 890, 1166], [1168, 1168, 1188, 1188, 1255], [1257, 1257, 1296, 1296, 1399], [1401, 1401, 1420, 1420, 1478], [1480, 1480, 1499, 1499, 1575], [1577, 1577, 1608, 1608, 1666], [1668, 1668, 1697, 1697, 1792], [1794, 1794, 1844, 1844, 1960], [1962, 1962, 2005, 2005, 2058], [2060, 2060, 2093, 2093, 2184], [2186, 2186, 2257, 2257, 3487], [3489, 3489, 3528, 3528, 4600], [4602, 4602, 4651, 4690, 5014], [5016, 5016, 5064, 5090, 5189], [5191, 5191, 5238, 5238, 5443], [5532, 5570, 5593, 5593, 8462], [8464, 8464, 8489, 8489, 8682], [8684, 8712, 8747, 8747, 8782], [8870, 8870, 8911, 8911, 9052], [9054, 9054, 9107, 9107, 9906], [9908, 9908, 9946, 9963, 10752]], "test": "untested"}
{"id": "WdyyDK", "name": "lesson 03: rectangle ", "author": "njikki", "description": "https://www.youtube.com/watch?v=bigjgiavOM0", "tags": ["tutorial"], "likes": 0, "viewed": 305, "published": 3, "date": "1603722168", "time_retrieved": "2024-07-30T20:38:04.993610", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n   \n    float d = length(uv-p); //distance    \n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n\tuv-= .5; // -0.5 <> -0.5\t\t\t\t// to get to the center of the screen --- from x to y \n\tuv.x *= iResolution.x/iResolution.y;    // to make a cirlce in a widescreen, making all sides equal\n  \n    vec3 col = vec3(0.); //color\n  \n    float mask = Circle(uv, vec2 (0.), .4, .05);\n    \n    \n    mask -= Circle(uv, vec2 (-.13, .2), .07, .01);\n    mask -= Circle(uv, vec2 (.13, .2), .07, .01);\n\n     \n    float mouth = Circle(uv, vec2 (0.), .3, .02); \n    mouth -= Circle(uv, vec2 (0., 0.1), .3, .02); \n    \n    mask -= mouth;\n   // col = vec3(mouth);\n    \n    // Output to screen\n     col = vec3(1., 0., 1.) *mask; // purp (uv) circle\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 160], [165, 165, 222, 272, 977]], "test": "untested"}
{"id": "XlSGzz", "name": "yuan", "author": "playertk", "description": "yuan", "tags": ["cineshader"], "likes": 56, "viewed": 30227, "published": 3, "date": "1603717695", "time_retrieved": "2024-07-30T20:38:05.910159", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (2.*fragCoord.xy-iResolution.xy) / iResolution.y; \n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    vec2 uv = vec2(0.0,r);\n\n\tuv = (2.0 * uv) -1.0;     \n    float beamWidth = abs(5.0 / (40.0 * uv.y));\n\n    \n    \n    \n\n    if(abs(uv.y)>=1.0)\n    {\n    \n   \t  // fragColor=vec4(0.0,0.5,0.0,1.0);\n      //  return;\n    }\n    \n\tvec3 horBeam = vec3(beamWidth);\n\t\n\t//fragColor = vec4( horBeam , 1.0);\n    fragColor = vec4( 5. / (40. * abs(2.*length(p)-1.) ) );\n\n    \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 543]], "test": "untested"}
{"id": "wdVyDy", "name": "Plots′", "author": "thepheer", "description": "Continuation of https://www.shadertoy.com/view/WdGyWy", "tags": ["sdf", "derivatives", "plots"], "likes": 8, "viewed": 432, "published": 3, "date": "1603707568", "time_retrieved": "2024-07-30T20:38:06.712015", "image_code": "#define Colors mat4x3\n#define Plots vec4\n\nPlots f(float x) {\n\tconst float pi = radians(180.0);\n    Plots t = Plots(-3.0, -1.0, 1.0, 3.0)/12.0 + 6.0*cos(pi*x) + iTime;\n    return 0.5 + x*(1.0 - x)*sin(pi*t);\n}\n\nPlots f(vec2 xy) {\n    return f(xy.x) - xy.y;\n}\n\nPlots sdf(vec2 xy, vec2 px) {\n    vec3 e = vec3(0.5*px, 0.0);\n    Plots x = f(xy + e.xz) - f(xy - e.xz);\n    Plots y = f(xy + e.zy) - f(xy - e.zy);\n    return f(xy)/sqrt(x*x + y*y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Colors colors = Colors(\n        hsl(vec3(0.00, 2.0, 0.5)),\n        hsl(vec3(0.25, 2.0, 0.5)),\n        hsl(vec3(0.50, 2.0, 0.5)),\n        hsl(vec3(0.75, 2.0, 0.5))\n    );\n    \n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = px*fragCoord;\n    vec3 plots = colors*smoothstep(2.0, 0.0, abs(sdf(uv, px)));\n    fragColor = vec4(sRGB_OETF(plots), 1.0);\n}", "image_inputs": [], "common_code": "// https://www.shadertoy.com/view/WsKyWh\nvec3 hsl(vec3 hsl) {\n    const float tau = radians(360.0);\n    const vec3 offset = vec3(0.0, 1.0, 2.0)/3.0;\n    float limit = (1.0 - hsl.z)*hsl.z;\n\treturn hsl.z + hsl.y*limit*cos(tau*(offset - hsl.x));\n}\n\nvec3 sRGB_OETF(vec3 c) {\n    vec3 a = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 60, 60, 208], [210, 210, 228, 228, 257], [259, 259, 288, 288, 442], [444, 444, 499, 499, 851]], "test": "untested"}
{"id": "wdKyDG", "name": "Cratered moonscape", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/Wt2fDR]\"Dune world\"[/url] fractal terrain.\nThe SDF is defined in the \"Common\" buffer.", "tags": ["fractal", "terrain", "landscape", "moon", "crater"], "likes": 6, "viewed": 503, "published": 3, "date": "1603682064", "time_retrieved": "2024-07-30T20:38:07.512874", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*1000.0;\n    return sin(vec3(planet_surface(p)*2.0+.5,planet_surface(p)*2.0,planet_surface(p*10.0)*2.0))/12.0+vec3(.7,.5,.3)*1.6;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(depth+1.0)) {\n\t\t\tif(iters < 2){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t1 = iTime/10.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n        //distance fog\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+50.0)*100.0;\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/((t/5/4096)%5+(t/3/4096)%3)))|(t)>>4&(t)>>5|(t)>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n\n/*\n//rain sound effect\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/((t/4096)%5+(t/4096)%3)))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    //vec2 result1 = vec(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult = sound1(int(time*factor));\n        factor *= 1.5+result.x;\n    }\n    return result/100.0;\n}\n*/", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 a){\n    return (sin(a)+cos(a));\n}\n\nfloat planet_surface(vec3 p){\n    p /= 10.0;\n    //p /= 100.0;\n    p += warp(p.yzx/500.0)*500.0;\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx+(length(sin(p/100.0))+sin(p1.yxz))))*size;\n    return length(p) + p.y - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,int iters) {\n    p /= scale;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    //p *= 2.0;\n    for(int k = 0; k < 6; k++){\n        result -= min(-result,planet_surface(p*i))/(i*i);\n        i *= -1.5;\n        if(k == iters) break;\n        //p *= -1.0001;\n        //i /= 2.0;\n        //i /= -3.0;\n        //p *= 3.0;\n        //i /= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return (result-p.y*2.0)*scale/4.0;\n}\n\nfloat sceneSDF(vec3 p) {\nreturn sceneSDF(p,5);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*1000.0;\n    return sin(vec3(planet_surface(p)*2.0+.5,planet_surface(p)*2.0,planet_surface(p*10.0)*2.0))/12.0+vec3(.7,.5,.3)*1.6;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON*2.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (abs(dist) < eps*(depth+1.0)*image_scale/2.0) {\n\t\t\tif(iters < 2){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    float speed = 10.0;\n    float t1 = iTime/10.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-3.0, -1.0, 3.0*sin(t1/3.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = length(eye-dmap); //distance to point in last frame\n\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w; //distance between points in consecutive frames\n    \n    float l2;\n\n    l2 = l0-1.0;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, (dist-l0)*.9);    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 234], [237, 658, 749, 749, 1273], [1288, 1377, 1406, 1406, 1716], [1718, 2210, 2350, 2350, 2960], [2962, 3332, 3417, 3417, 3832], [3835, 3835, 3862, 3862, 4011], [4013, 4013, 4070, 4070, 4754]], "test": "untested"}
{"id": "wdKczy", "name": "[inktober20]Steel Dogs", "author": "iY0Yi", "description": "A shader drawing for inktober 2020 day18.\n#inktober2020day18", "tags": ["trap", "comic", "inktober2020"], "likes": 30, "viewed": 727, "published": 3, "date": "1603664335", "time_retrieved": "2024-07-30T20:38:08.699701", "image_code": "//////////////////////////////////////////////////////////////////////////////////////////\n//  .--. .-----. .--.  .--. .-.     .---.  .--.  .--.  .--.                             //\n// : .--'`-. .-': .--': .--': :     : .  :: ,. :: .--': .--'                            //\n// `. `.   : :  : `;  : `;  : :     : :: :: :: :: : _ `. `.                             //\n//  _`, :  : :  : :__ : :__ : :__   : :; :: :; :: :; : _`, :                            //\n// `.__.'  :_;  `.__.'`.__.':___.'  :___.'`.__.'`.__.'`.__.'                            //\n//                                                                                      //\n//                                                                                      //\n//  [inktober20]Steel Dogs by iY0Yi                                                     //\n//  https://www.shadertoy.com/view/wdKczy                                               //\n//                                                                                      //\n//  Created by Atsushi Hashimoto 2020                                                   //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n\n//#define DEBUG\n\nvec3 readAlbedo(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack(data.y);\n}\n\nvec3 readNormal(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).xyz*2.-1.;\n}\nvec3 readSharpenNormal(in vec2 fragCoord, float strength)\n{\n    vec3 res =\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).x).xyz*2.-1.) *   9. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).x).xyz*2.-1.) *  -1.\n    ;\n    return mix((unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).x).xyz*2.-1.), res , strength);\n}\n\nfloat readSpecular(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.x;\n}\nfloat readSharpenSpecular(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).x *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).x *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).x, res , strength);\n}\n\nfloat readDiffuse(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.y;\n}\nfloat readSharpenDiffuse(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).y *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).y *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).y, res , strength);\n}\n\nfloat readAO(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z);\n    return spec_diffuse_ao.z;\n}\n\nfloat readShadow(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).w;\n}\n\nfloat readDepth(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return data.w;\n}\n\nfloat palettize(float v)\n{\n    return saturate(floor(v*6.)/5.);\n}\n\nfloat dithering(float v, vec2 fragCoord)\n{\n    v=pow(v, 4.);\n\n    float stride = .1;\n    vec2 p = fragCoord;\n\n    p = mod(p.xx + vec2(p.y, -p.y), vec2(stride));\n    float res=0.;\n    vec2 coords = fragCoord;\n\n    float angle = dot(readSharpenNormal(fragCoord, 1.), vec3(0,0,1));\n\n    coords.xy*= mat2(cos(angle*PI+vec4(0,11,33,0)));\n    coords.y *= .75+.25*hash12(p);\n    float rand_ditherVal = fbm(coords*.75, 2);\n    const float paletteDist = 1.15;\n    res=v + (rand_ditherVal - .5) * paletteDist;\n    res=smoothstep(0.1,1.,res);\n    res=palettize(res);\n\n    return res;\n}\n\nfloat checkEdge(vec3 norz1, vec3 norz2)\n{\n    vec2 diffNor = abs(norz1.xy - norz2.xy);\n    float diffZ = pow(abs(norz1.z - norz2.z), 8.5) * 1.8;\n    float a = 1.-smoothstep(.5, .91, diffNor.x + diffNor.y);\n    float b = 1.-smoothstep(.5, .95, diffZ);\n    return smoothstep(0., .01, a*b);\n}\nfloat getEdge(vec2 fragCoord)\n{\n    vec2 coord = fragCoord;\n    if(all(lessThan(coord, iResolution.xy-2.)))\n    coord += u2s(noise(coord*.05))*1.;\n    float radius = .6;\n    \n    vec3 offset = vec3(1, -1, 0) * radius;\n    float edge = 1.0;\n    edge *= checkEdge(readNormal(coord+offset.xx), readNormal(coord+offset.yy));\n    edge *= checkEdge(readNormal(coord+offset.xy), readNormal(coord+offset.yx));\n    edge *= checkEdge(readNormal(coord+offset.zy), readNormal(coord+offset.zx));\n    edge *= checkEdge(readNormal(coord+offset.yz), readNormal(coord+offset.xz));\n    return edge;\n}\n\nfloat getShadowEdge( vec2 fragCoord )\n{\n    vec2 coord = fragCoord;\n    float sha = readShadow(coord);\n    sha -= .5;\n    sha = abs(sha);\n    sha = smoothstep(.1,.2,sha);\n    return sha;\n}\n\n// https://www.shadertoy.com/view/3ssSz2\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\n    // rescaling contrast to more easily compare with optimized version:\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n\n    // original version:\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\n\n// https://www.shadertoy.com/view/MdjBRy\nvec3 saturation( vec3 color, float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n\n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n\n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n\n    return mat3( red, green, blue) * color;\n}\n\nfloat getDottedShadow(vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    uv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n    uv = mod(uv*.225, 1.);\n    float res = 0.;\n    float shadow = readShadow(fragCoord);\n    shadow = max(.65,shadow*.85) + .35*readAO(fragCoord);\n    shadow = 1. - shadow;\n    res = smoothstep(shadow, shadow+1., pow(length(uv-.5), 4.));\n    res = smoothstep(.0, .2, pow(res, .05));\n    return res;\n}\n\n\nfloat hatching(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return 1.;\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSharpenDiffuse(fragCoord, 2.);\n    shading = mix(shading, (1.-shading)*.3+.7*readAO(fragCoord), 1.-readShadow(fragCoord));\n    shading *= 1.35;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n\n    shading = originalSigmoidContrast(shading*.95+.05*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatching(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatching(fragCoord, 4., .6, .6, .8, true), 10.);\n        ln*= pow(hatching(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatching(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return ln;\n}\n\nfloat hatchingSpecular(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return -1.;\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSpecular(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading *= 1.5;\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n    \n    shading = originalSigmoidContrast(shading*.98+.03*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    shading = 1.-saturate(shading*.55);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\nfloat getHatchingSpecular(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return 1.-ln;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(.8, .77, .7);\n\n    float shading = readDiffuse(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = shading*.9+.1*readAO(fragCoord);\n\n    float contrast = 8.8;\n    float midpoint = .5;\n    shading = originalSigmoidContrast(shading, contrast, midpoint);\n    shading = saturate(shading);\n    if(readDepth(fragCoord)<.5)\n    {\n        col*=saturate(dithering(shading, fragCoord));\n        col*=.2+.8*shading;\n    }\n\n    col+=fbm(fragCoord*.5, 3)*.15;\n    col*= getHatching(fragCoord);\n    col *= getEdge(fragCoord);\n    col *= getShadowEdge(fragCoord);\n    col *= getDottedShadow(fragCoord);\n    if(readShadow(fragCoord)<.2)\n    col += (1.-getEdge(fragCoord))*.1;\n    col+=.05*dithering((smoothstep(.95,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.97,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.99,1.,shading)), fragCoord);\n\n    col *= .4 + .6*(readShadow(fragCoord)*.8+.2*readAO(fragCoord));\n    col *= .2 + .8*shading;\n\tcol += (1.-dithering(pow(abs(dot(vec3(0,0,1), readNormal(fragCoord))), 2.)*.5, fragCoord))*.25;\n    \n    //st_assert( pow(abs(dot(vec3(0,0,1), readNormal(fragCoord))), 1.5) > 0.5, 0 );\n    \n    col *= dithering(pow(saturate(readAO(fragCoord)), 1.5), fragCoord*2.);\n\n    vec3 albedo = readAlbedo(fragCoord);\n    \n    if(!(distance(albedo,AMB_COL)<.01))\n        col*=albedo;\n\n    float spec = readSharpenSpecular(fragCoord, 1.5)*readShadow(fragCoord);\n    if(spec>.1)\n    col+=dithering(spec, fragCoord);\n    col+=saturate(getHatchingSpecular(fragCoord));\n    if(distance(albedo,AMB_COL)<.1)\n        col = saturation(albedo, 2.5)*.075;\n    col *= (readShadow(fragCoord))*(getEdge(fragCoord));\n    \n    if(distance(albedo,MAT_GROUND)>.1)\n    col += (1.-readShadow(fragCoord))*(1.-getEdge(fragCoord))*.0001;\n    col*= dithering(noise(fragCoord*.095)+noise(fragCoord*.07)+.7, fragCoord);\n    col+= (1.-dithering((1.-noise(fragCoord*.08)*noise(fragCoord*.06))+.8, fragCoord));\n\tcol = saturation(col, 5.5);\n    col = pow(col, vec3(.25));\n    fragColor = vec4(col, 1);\n\n#ifdef DEBUG\n    if(iFrame==2)\n    fragColor.xyz = vec3(readDiffuse(fragCoord));\n    if(iFrame==3)\n    fragColor.xyz = vec3(readShadow(fragCoord));\n    if(iFrame==4)\n    fragColor.xyz = vec3(readSharpenSpecular(fragCoord, 1.5));\n    if(iFrame==5)\n    fragColor.xyz = vec3(readDepth(fragCoord));\n    if(iFrame==6)\n    fragColor.xyz = vec3(readAO(fragCoord));\n    if(iFrame==7)\n    fragColor.xyz = readAlbedo(fragCoord);\n    if(iFrame==8)\n    fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    if(iFrame==9)\n    fragColor.xyz = vec3(getEdge(fragCoord));\n    if(iFrame==10)\n    fragColor.xyz = vec3(getShadowEdge(fragCoord));\n    if(iFrame==11)\n    fragColor.xyz = vec3(getDottedShadow(fragCoord));\n    if(iFrame==12)\n    fragColor.xyz = vec3(getHatching(fragCoord));\n    if(iFrame==13)\n    fragColor.xyz = vec3(getHatchingSpecular(fragCoord));\n#endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// BLU_GUI\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nuniform float blu1f0;\nuniform float blu1f1;\nuniform float blu1f2;\nuniform float blu1f3;\nuniform float blu1f4;\nuniform float blu1f5;\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24\n#define ZERO min(0,iFrame)\n#define CHARM min(0,iFrame) /* faster compilation... */\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash / Noise by Anonymous:\n// I forgot where I found this...\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n            mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f = 0.5000 * noise(p);\n    p *= 2.01;\n    f += 0.2500 * noise(p);\n    p *= 2.02;\n    f += 0.1250 * noise(p);\n\n    return f;\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define SDF_RENDER_SCALE float(1)\n#define INV_SDF_RENDER_SCALE (1./SDF_RENDER_SCALE)\n#define MIN_DIST 0.0010000000474974513\n#define MAX_DIST 30.0\n#define ITERATION 300\n#define MAT_VOID vec3(-1)\n#define MAT_METAL vec3(0.8514)\n#define MAT_GROUND vec3(0.0021, 0.0025, 0.0014)*.1\n#define MAT_BLADE vec3(0.0585, 0.0628, 0.0671)\n\n#define AMB_COL vec3(0.0470, 0.0465, 0.0445)*5.\n#define AMB_STRENGTH 0.2000\n#define FOG_COL vec3(0.0000, 0.0000, 0.0000)\n#define FOG_START 1.0000\n\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n\n//Animation\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ID_Camera 0\n#define ID_sdLight001 1\n#define ID_sdLight002 2\n\n\n\n// Read vec3(10bit/float) from a float...\nconst float THRESHOLD = .92;\n// Read vec3(10bit/float) from a float. Although can't say so smart...\nvec3 unpackSnorm3x10(uint x)\n{\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(1), vec3(-1), greaterThanEqual(sig,uvec3(1)));\n    vec3 fmag = vec3(mag);\n    return fsig * fmag / 511.0/THRESHOLD;\n}\nfloat packSnorm3x10(vec3 x) {\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(vec3(0),sign(x))));\n    x = clamp(x*THRESHOLD,-THRESHOLD, THRESHOLD) * 511.0;\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig << 9 | mag;\n    return float((r.x << 22) | (r.y << 12) | (r.z << 2));\n}\n\nuint packSnorm3x10_2(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10_2(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n#define pack(x) uintBitsToFloat(packSnorm3x10_2(x))\n#define unpack(x) unpackSnorm3x10_2(floatBitsToUint(x))\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n#define pack_bl(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_bl(x) unpackSnorm3x10(floatBitsToUint(x))\nvoid readFrameTexCamera3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec4 quat, inout float fov, in vec3 tra_scl, in vec4 quat_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n\n    quat = vec4(0);\n    quat.xyz = unpack_bl(anm.y)*quat_scl.xyz;\n    vec3 qw_fov_zero = unpack_bl(anm.z);\n    quat.w = qw_fov_zero.x*quat_scl.w;\n\n    fov = qw_fov_zero.y;\n}\n\nvoid readFrameTex3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec3 rot, in vec3 tra_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n    rot = unpack_bl(anm.y).xyz * PI;\n}\n\nvoid readFrameTexLight3x10(sampler2D tex, int id, int f, inout vec3 dir, inout vec3 col, inout float clip_start, inout float clip_end, inout float softness, in vec3 shadow_props_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    dir = unpack_bl(anm.x).xzy;\n    col = unpack_bl(anm.y);\n    vec3 shadow = unpack_bl(anm.z);\n    clip_start = shadow.x*shadow_props_scl.x;\n    clip_end = shadow.y*shadow_props_scl.y;\n    softness = shadow.z*shadow_props_scl.z;\n}\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "vec3 ro = vec3(0), rd = vec3(0);\nvec3 gp;\nvec3 col = vec3(0);\nvec2 uv=vec2(0);\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3  Cam_pos;\nvec4  Cam_quat;\nfloat Cam_fov;\nvec3  L0_dir;\nvec3  L0_col;\nfloat L0_str;\nfloat L0_end;\nfloat L0_sft;\n\nvoid init()\n{\n\tCam_pos = vec3(-4.3957,0.2853,0.5985);\n\tCam_quat = vec4(0.4832,-0.5162,-0.5162,0.4832);\n\tCam_fov = 0.19;\n    L0_dir = normalize(vec3(-0.5666,0.0000,0.8240));\n\tL0_col = vec3(1.0000,1.0000,1.0000);\n\tL0_str = 0.0500;\n\tL0_end = 30.0000;\n\tL0_sft = 50.0000;\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid camera(vec2 uv)\n{\n    vec3 dir = quat_rotate(Cam_quat, vec3(0,0,-1)).xzy;\n    vec3 up = quat_rotate(Cam_quat, vec3(0,1,0)).xzy;\n    vec3 pos = Cam_pos.xzy;\n    float fov = Cam_fov;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n\n    // iq:\n    //float h = max(r-abs(a-b),0.0);\n    //return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\n\nfloat fOpSubstraction(in float a,in float b)\n{\n    return max(-a, b);\n}\n\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b)\n{\n    float res = max(-a.x, b.x);\n    return (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\n\nfloat fOpIntersectionLinear(float a, float b, float r)\n{\n    return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n\nfloat fOpSubstractionLinear (float a, float b, float r)\n{\n    return fOpIntersectionLinear(b, -a, r);\n}\n\n\nfloat fOpIntersection(in float a,in float b)\n{\n    return max(a, b);\n}\n\n\nfloat pMirror(float x, float k){\n    return sqrt(x * x + k);\n}\n\n\nvoid pElongate(inout float p, in float h )\n{\n    p = p-clamp(p,-h,h);\n}\n\n\n//Based on \"bend\" by las:\n//https://www.pouet.net/topic.php?which=7931&page=5\nvec2 pBend(vec2 p, float k)\n{\n    //float r = 1.0/max(abs(k),1e-3);\n    //vec2 d= vec2(p.x, r-p.y*(step(0.0,k)*2.0-1.0));\n    //return vec2(atan(d.x,d.y)*r,length(d)-r);\n    if(k==0.) return p;\n    float r = 1./k;\n    float sgn = sign(k);\n    vec2 d = vec2(p.x, (r-p.y)*sgn);\n\n    float a = -atan(d.x, d.y);\n    vec2 b = vec2(sin(a), cos(a));\n    return sgn*vec2(-b.y*d.x-b.x*d.y, b.x*d.x-b.y*d.y)+vec2(a*r,r);\n}\n\n\n// Based on \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions )\n{\n#if 0\n    float r = round(p_el/s);\n    float half_num = (repetitions-1.)/2.;\n    r = clamp(r, -half_num, repetitions-half_num);\n    p_el-=s*r;\n#else\n    repetitions -= 1.;\n    float offset = 1.-step(.5, mod(repetitions, 2.));\n    p_el += s*.5*offset;\n    float r = round(p_el/s);\n    float half_rep = ceil(repetitions/2.);\n    r = clamp(r, -half_rep, repetitions-half_rep);\n    p_el-=s*r;\n#endif\n}\n\n\n// map: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdSpring(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp001_002 = p;\n\tcp001_002.xyz += vec3(-0.0000, -0.2653, -0.0000);\n\tcp001_002.xyz = rot(cp001_002, vec3(-0.0000, 0.0000, -0.0000));\n\t{\n\t\tvec3 q = cp001_002;\n\t\tR(q.xz, PI*.5);\n\t\tq.y+= (atan(q.x, q.z)/PI)*.0125*(.3/.25);\n\t\tcp001_002 = q;\n\t}\n\tpRepLimited(cp001_002.y, 0.0300, 23.);\n\n\td = fOpUnion(sdTorus(rot(cp001_002+vec3(-0.0000, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec2(0.0385, 0.0115)), d);\n\td = fOpUnion(sdCappedCylinder(rot(p+vec3(-0.0379, -0.5945, -0.0953), vec3(-1.5708, 0.0000, 1.5708)), vec2(0.0117, 0.0965))-0.0000, d);\n\td = fOpUnion(sdConeSection(rot(p+vec3(-0.0373, -0.5949, -0.2156), vec3(-1.5708, 0.0000, -0.0000)), 0.0235, 0.0120, 0.0000)-0.0000, d);\n\tres = v4OpUnion(vec4(d,MAT_METAL), res);\n\treturn res;\n}\n\nvec4 sdBolt(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.05000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    p.x+=.005;\n\t{\n        vec3 tp = p+vec3(-0.0129, -0.0000, 0.0000);\n        vec3 trp = rot(p+vec3(-0.0129, -0.0000, 0.0000), vec3(0.0000, 1.5708, -0.0000));\n        vec3 dim = vec3(0.0273, 0.0273, 0.0123);\n        float td = MAX_DIST;  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        vec2 h = dim.xz;\n        trp = abs(trp);\n        trp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n        vec2 d2 = vec2(length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x), trp.z-h.y );\n        td = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n        d=fOpUnion(td, d);\n\t}\n\t{\n        vec3 tp = p+vec3(-0.0312, -0.0000, 0.0000);\n        vec3 trp = rot(p+vec3(-0.0312, -0.0000, 0.0000), vec3(0.0000, 1.5708, -0.0000));\n        vec3 dim = vec3(0.0247, 0.0247, 0.0111);\n        float td = MAX_DIST;  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        vec2 h = dim.xz;\n        trp = abs(trp);\n        trp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n        vec2 d2 = vec2(length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),trp.z-h.y );\n        td = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n\t\td=fOpSubstraction(td, d);\n\t}\n    \n\td = fOpSubstraction(sdBox(rot(p+vec3(-0.0681, -0.0000, -0.0000), vec3(0.0000, 0.7854, 0.0000)), vec3(0.0463, 0.0049, 0.0463))-0.0000, d);\n    d = fOpSubstraction(sdBox(rot(p+vec3(-0.0681, -0.0000, -0.0000), vec3(1.5708, 0.0000, -0.7854)), vec3(0.0463, 0.0049, 0.0463))-0.0000, d);\n\td = fOpUnionSmooth(sdCappedCylinder(rot(p+vec3(-0.0035, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708)), vec2(0.0306, 0.0031))-0.0000, d, 0.0025);\n\t\n\td = fOpIntersection(sdEllipsoid(rot(p+vec3(-0.0076, -0.0000, -0.0000), vec3(-0.0000, 0.0000, -0.0000)), vec3(0.0295, 0.0347, 0.0347)), d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n\treturn res;\n}\n\nfloat bladeOffset = 0.;\n\nvec4 sdTBlade(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, -0.2500)), bsr=0.3000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp002_003 = p;\n\tcp002_003.xyz += vec3(0.0000, -0.0000, -0.0000);\n\tcp002_003.xyz = rot(cp002_003, vec3(-0.0000, 0.0000, -0.0000));\n\tvec3 cp002_003_mir0_Pos = max(vec3(0), sign(cp002_003));\n\tvec3 cp002_003_mir0_Neg = max(vec3(0),-sign(cp002_003));\n\tcp002_003.x = pMirror(cp002_003.x, 0.0000);\n\n\tvec3 cp002_001 = cp002_003;\n\tcp002_001.xyz += vec3(0.0000, -0.0000, -0.5381);\n\tcp002_001.xyz = rot(cp002_001, vec3(0.0000, 3.1416, -0.0000));\n\t{\n\t\tvec2 q = cp002_001.xz;\n\t\tfloat k = 112.601*.025;\n\t\tfloat s0=0., sb=-44.5854*.025, se=22.3006*.025;\n\t\tfloat r = 1./k, ak = abs(k), sk = sign(k);\n\t\tvec2 d = vec2(q.x - s0, (r - q.y) * sk);\n\t\tfloat a = -atan(d.x, d.y);\n\t\tfloat b = clamp(a, ak*(sb-s0), ak*(se-s0));\n\t\tfloat s = b*r+s0;\n\t\tvec2 c = vec2(sin(b), cos(b));\n\t\tq.xy = mix(vec2(s, length(d) - abs(r)), sk*(c.yx*d.xx*vec2(-1.,1) - c.xy*d.yy) + vec2(s, r), abs(sign(a-b)));\n\t    cp002_001.xz = q;\n\t}\n\tvec3 cp001_003 = cp002_001;\n\tcp001_003.xyz += vec3(-0.0453, -0.0000, 0.0000);\n\tcp001_003.xyz = rot(cp001_003, vec3(0.0000, 0.0000, -0.0000));\n\t{\n\t\tvec3 q = cp001_003;\n\t\tq.x-=bladeOffset;\n\t\tcp001_003 = q;\n\t}\n\tpRepLimited(cp001_003.x, 0.1500, 7.);\n\tres = v4OpUnion(sdBolt(rot(cp002_003+vec3(-0.4282, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000))), res);\n\td = fOpUnion(sdBox(rot(cp001_003+vec3(-0.0000, 0.0321, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec3(0.1974, 0.0624, 0.0100))-0.0000, d);\n\td = fOpSubstraction(sdBox(rot(cp002_001+vec3(-0.7382, 0.1619, -0.0616), vec3(0.0000, 3.1416, -0.0000)), vec3(0.1000, 0.1000, 0.1000))-0.0000, d);\n\td = fOpUnion(sdBox(rot(cp002_003+vec3(-0.3544, 0.0177, -0.0892), vec3(0.0000, 1.5708, 0.0000)), vec3(0.0891, 0.0483, 0.0100))-0.0000, d);\n\td = fOpUnion(sdBox(rot(cp001_003+vec3(0.0000, -0.0046, 0.0000), vec3(0.0000, 0.0000, 0.7854)), vec3(0.0702, 0.0702, 0.0100))-0.0000, d);\n\td = fOpUnion(sdBox(rot(p+vec3(-0.3307, 0.0164, -0.1383), vec3(-0.0000, 0.0000, 1.5708)), vec3(0.0077, 0.0313, 0.0661))-0.0000, d);\n\td = fOpUnion(sdCappedCylinder(rot(cp002_003+vec3(-0.0000, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708)), vec2(0.0153, 0.4240))-0.0000, d);\n\td = fOpUnion(sdBox(rot(p+vec3(-0.3071, 0.0380, -0.1383), vec3(-0.0000, 0.0000, -0.0000)), vec3(0.0077, 0.0204, 0.0661))-0.0000, d);\n\td = fOpUnion(sdCappedCylinder(rot(cp002_003+vec3(-0.3561, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708)), vec2(0.0630, 0.0100))-0.0000, d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n    \n    res.x += smoothstep(.5,.6,fbm(cp002_001.xy*70., 3))*.00075;\n    res = v4OpUnion(sdSpring(rot(p+vec3(0.2645, -0.0000, -0.0000), vec3(-0.0000, 0.0000, 1.5708))), res);\n\treturn res;\n}\n\n\nvec4 sdChainRing(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.0500;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp003 = p;\n\tpElongate(cp003.z, 0.0300);\n\n\td = fOpUnion(sdTorus(cp003, vec2(0.0281, 0.0113)), d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n\treturn res;\n}\n\n\nvec4 sdGround(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp001_001 = p;\n\tcp001_001.xyz += vec3(-0.0000, -0.0733, -0.0000);\n\tcp001_001.xyz = rot(cp001_001, vec3(-0.0000, 0.0000, -0.0000));\n\t{\n\t\tvec3 q = cp001_001;\n\t\tfloat dist = smoothstep(.5,0.,length(q.xz));\n\t\tq.y+=fbm(p.xz*5., 4)*.1;\n\t\tcp001_001 = q;\n\t}\n\td = fOpUnion(sdPlane(rot(cp001_001+vec3(-0.0000, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000))), d);\n\tres = v4OpUnion(vec4(d,MAT_GROUND), res);\n\treturn res;\n}\n\n\nvec4 sdTrap(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0.0000, 0.0000, 0.0000)), bsr=0.3750;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cp002_002 = p;\n\tcp002_002.xyz += vec3(-0.0000, -0.1073, -0.0000);\n\tcp002_002.xyz = rot(cp002_002, vec3(0.0000, 1.5708, -0.0000));\n\tpElongate(cp002_002.x, 0.1000);\n\tcp002_002.xy = pBend(cp002_002.xy, -2.0000);\n\n\tvec3 cp004 = p;\n\tcp004.xyz += vec3(-0.0000, -0.0000, -0.0000);\n\tcp004.xyz = rot(cp004, vec3(-0.0000, 0.0000, -0.0000));\n\tvec3 cp004_mir0_Pos = max(vec3(0), sign(cp004));\n\tvec3 cp004_mir0_Neg = max(vec3(0),-sign(cp004));\n\tcp004.z = pMirror(cp004.z, 0.0000);\n\tvec3 cp004_mir1_Pos = max(vec3(0), sign(cp004));\n\tvec3 cp004_mir1_Neg = max(vec3(0),-sign(cp004));\n\tcp004.x = pMirror(cp004.x, 0.0000);\n\n\td = fOpUnion(sdBox(rot(cp004+vec3(-0.3973, -0.0110, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec3(0.0150, 0.0837, 0.1564))-0.0000, d)+smoothstep(.5,.6,fbm(cp004.yz*70., 3))*.00075;\n\td = fOpUnion(sdBox(rot(cp004+vec3(-0.1806, 0.0611, -0.0454), vec3(-1.5708, -1.5708, 0.0000)), vec3(0.1109, 0.2186, 0.0122))-0.0000, d);\n    float disp = smoothstep(.5,.6,fbm(cp002_002.xy*70., 3))*.00075;\n\td = fOpUnion(sdCappedCylinder(rot(cp002_002+vec3(-0.0000, -0.0000, -0.0000), vec3(0.0000, 0.0000, -0.0000)), vec2(0.1872, 0.0050))-disp, d);\n\tres = v4OpUnion(vec4(d,MAT_BLADE), res);\n\td = MAX_DIST;\n\n    const vec3 bloc[2] = vec3[](\n\t\tvec3(-0.0000, -0.0226, -0.0700),\n\t\tvec3(-0.0000, -0.0226, 0.0700)\n\t\t);\n\tconst vec3 brot[2] = vec3[](\n\t\tvec3(1.1461, 0.0000, -0.0000),\n\t\tvec3(1.1461, 3.1416, 0.0000)\n\t\t);\n\tconst float offsets[2] = float[](4.1346*0.025, 1.13058 *0.025);\n\tfor(int i = ZERO; i < 2+CHARM; i++){\n        bladeOffset = offsets[i];\n\t\tres = v4OpUnion(sdTBlade(rot(p+bloc[i], brot[i])), res);\n\t}\n    \n\td = fOpUnion(sdBox(rot(cp004+vec3(-0.3973, -0.0931, -0.1759), vec3(-0.7854, 0.0000, -0.0000)), vec3(0.0198, 0.0500, 0.1564))-0.0000, d);\n    \n\tres = v4OpSubstraction(vec4(d,MAT_BLADE), res);\n    \n    \n    \n\treturn res;\n}\n\n\nvec4 sdChain(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=0.5000;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n\tconst vec3 cloc[8] = vec3[](\n\t\tvec3(0.0551, -0.0006, 0.0188),\n\t\tvec3(-0.0127, 0.0058, 0.0683),\n\t\tvec3(-0.0997, 0.0091, 0.0683),\n\t\tvec3(-0.2047, 0.0155, 0.0683),\n\t\tvec3(-0.2816, -0.0147, 0.0683),\n\t\tvec3(-0.3866, -0.0082, 0.0683),\n\t\tvec3(-0.4667, -0.0047, 0.0683),\n\t\tvec3(-0.5632, 0.0021, 0.0683)\n\t\t);\n\tconst vec3 crot[8] = vec3[](\n\t\tvec3(0.8681, -0.0836, -1.4726),\n\t\tvec3(3.0044, -1.5708, -0.0000),\n\t\tvec3(1.5708, 0.0000, -1.6083),\n\t\tvec3(3.0044, -1.5708, -0.0000),\n\t\tvec3(1.5708, 0.6626, -1.6083),\n\t\tvec3(1.4310, -0.2474, -1.5783),\n\t\tvec3(1.5708, 0.6626, -1.6083),\n\t\tvec3(1.3961, -1.3752, -1.6083)\n\t\t);\n\n\tfor(int i = ZERO; i < 8+CHARM; i++)\n\tres = v4OpUnion(sdChainRing(rot(p+cloc[i], crot[i])), res);\n\n\treturn res;\n}\n\n\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n\tconst vec3 cloc[2] = vec3[](\n\t\tvec3(0.3252, -0.4480, 0.7412),\n\t\tvec3(-0.6978, -0.5313, -0.8275)\n\t\t);\n\tconst vec3 crot[2] = vec3[](\n\t\tvec3(0.2092, -1.4354, 0.2111),\n\t\tvec3(-2.9959, 0.4528, -0.0728)\n\t\t);\n\tconst vec3 tloc[2] = vec3[](\n\t\tvec3(0.0371, -0.4715, -0.5216),\n\t\tvec3(0.0188, -0.5819, 0.4570)\n\t\t);\n\tconst vec3 trot[2] = vec3[](\n\t\tvec3(1.4634, -0.4793, 0.3623),\n\t\tvec3(-1.3017, 0.5585, -0.2646)\n\t\t);\n\n\tfor(int i = ZERO; i < 2+CHARM; i++){\n\t\tres = v4OpUnion(sdTrap(rot(p+tloc[i], trot[i])), res);\n\t\tres = v4OpUnion(sdChain(rot(p+cloc[i], crot[i])), res);\n\t}\n\tres = v4OpUnion(sdGround(rot(p+vec3(-0.0000, -0.1335, -0.0000), vec3(-0.0000, 0.0000, -0.0000))), res);\n\n    return res;\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = MIN_DIST;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        gp = p;\n        vec4 res = sdScene(p);\n        res.x*=.5;\n        m = res.yzw;\n        if (abs(res.x) < MIN_DIST)break;\n        d += res.x;\n        if (d >= MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    }\n    if(d>MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+CHARM; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nvec3 ldir = normalize(vec3(-.5, 1.,-.95));\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft*2.;\n    float res = 1.;\n    float ph = 1e20;\n    float t=mint;\n    for( int i=ZERO; i < 64+CHARM; i++)\n    {\n        float h = sdScene(o + ldir*t).x;\n        if(abs(h)<MIN_DIST) return 0.;\n\n        res = min( res, k*h/t);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n\n        if(t >= maxt) break;\n    }\n    return smoothstep(.5, .51, res);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=ZERO; i<nbIte+CHARM; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\nfloat fakeReflection(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, -n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 nml = vec3(0);\nvec3 albedo = vec3(0);\nfloat spec = 0.;\nfloat depth = 0.;\nfloat ao = 1.;\nfloat shdw = 1.;\n\nvec3 render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    vec3 n = normal(p);\n\n    vec3 offset = n * .0005;\n    float vol = 1.0;\n    shdw=ao=1.;\n\n    vec3 res_col = vec3(1);\n\n    if (hit.x>=MAX_DIST)\n    {\n        nml = vec3(0);\n        res_col=vec3(1);\n        albedo = AMB_COL;\n        spec = 0.;\n        depth = 1.;\n        return AMB_COL;\n    }\n    else\n    {\n\n        ldir=L0_dir.xzy;\n\n        // Camera localized normal\n        vec3 up = quat_rotate(Cam_quat, vec3(0,1,0)).xzy;\n        vec3 side = cross(rd, up);\n        nml.x = dot(n+offset,  side);\n        nml.y = dot(n+offset,  up);\n        nml.z = dot(n+offset,  -rd);\n\n        float light1 = dot(n+offset,  ldir)*.5+.5; // Half-Lanbert model\n        float light2 = dot(n+offset, -ldir)*.5+.5;\n        shdw = shadow(p+offset);\n        float shade = 0.;\n        shade = 1.;\n\n        ao = ambientOcclusion(p+n*0.01, n, .1, 2.);\n        ao += ambientOcclusion(p+n*0.01, n, .01, .2);\n        ao += ambientOcclusion(p+n*0.01, n, .5, 2.);\n        ao += ambientOcclusion(p+n*0.01, n, 1., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        const float thresh = .01;\n        if(distance(base_col, MAT_BLADE) < thresh)\n        {\n            // STeel\n            n.y += u2s(fbm(p.xz*30., 1))*.25*smoothstep(.1, .25, abs(p.z));\n            spec = specular(p+offset, n, ldir, 10.);\n            //n.z += u2s(fbm(p.xz*10., 1))*.5*smoothstep(.1, .25, abs(p.z));\n            // base_col = vec3(.005);\n            shade *= smoothstep(.4, .6, s2u(fbm(reflect(rd,n).xyz*vec3(5, 1.2, 5))));\n            shade *= 1.-fakeReflection(p+offset, n, ldir, 1.);\n        }\n        if(distance(base_col, MAT_METAL) < thresh)\n        {\n            // Spring\n            n.y += u2s(fbm(p.xz*30., 1))*.5*smoothstep(.1, .25, abs(p.z));\n            spec = specular(p+offset, n, ldir, 15.);\n            shade *= 1.-fakeReflection(p+offset, n, ldir, 1.);\n        }\n        albedo = base_col;\n        res_col=vec3(shade);\n        depth = distance(ro, p)/MAX_DIST;\n    }\n    return res_col;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(iFrame>1){fragColor = texture(iChannel0, fragCoord/iResolution.xy); return;}\n    \n    // Setup UV...\n    uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.)*iResolution.y/iResolution.x;\n    uv.x *= iResolution.x / iResolution.y;\n\n\n    // Rendering...\n    init();\n    camera(uv);\n\n    col=render();\n\n    vec3 spec_diffuse_ao = vec3(spec, col.x, ao)*2.-1.;\n    fragColor = vec4(pack4(vec4(nml*.5+.5, shdw)), pack(albedo), pack(spec_diffuse_ao*.998), depth);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKczy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1383, 1383, 1409, 1409, 1491], [1493, 1493, 1519, 1519, 1612], [1613, 1613, 1672, 1672, 2622], [2624, 2624, 2653, 2653, 2787], [2788, 2788, 2850, 2850, 3771], [3773, 3773, 3801, 3801, 3935], [3936, 3936, 3997, 3997, 4918], [4920, 4920, 4943, 4943, 5071], [5073, 5073, 5100, 5100, 5185], [5187, 5187, 5213, 5213, 5287], [5289, 5289, 5315, 5315, 5354], [5356, 5356, 5398, 5398, 5930], [5932, 5932, 5973, 5973, 6221], [6222, 6222, 6253, 6253, 6804], [6806, 6806, 6845, 6845, 6994], [6996, 7037, 7108, 7181, 7520], [7522, 7563, 7612, 7612, 7988], [7990, 7990, 8029, 8029, 8399], [8402, 8402, 8503, 8503, 9540], [9542, 9542, 9577, 9577, 9824], [9826, 9826, 9935, 9935, 11017], [11018, 11018, 11061, 11061, 11261], [11263, 11263, 11320, 11320, 14262]], "test": "untested"}
{"id": "wsyyDy", "name": "Noise test lab", "author": "Miestrode", "description": "Some quick experiment with an N octave fbm.", "tags": ["noise"], "likes": 3, "viewed": 393, "published": 3, "date": "1603632622", "time_retrieved": "2024-07-30T20:38:09.538458", "image_code": "#define ZOOM 1.0\n#define BOUND 1.0\n#define DARKNESS 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zooming and positioning\n    vec2 uv = ( ( fragCoord/iResolution.xy + iTime / 4.0 )/ZOOM + 1.0 );\n\t\n    // coloring\n    vec3 col = vec3( wFbm( vec3( uv, iTime / 10.0 ), 2, 2 ) + BOUND)/ DARKNESS;\n\t\n    // tinting\n    col *= vec3( 0.7, 0.2, 0.4 );\n    col += 0.8;\n    \n    // Output to screen\n    fragColor = vec4( col ,1.0 );\n}", "image_inputs": [], "common_code": "// hashes by IQ\n\n// 1d, 2d and 3d hashing functions, used for generating random numbers.\n// based on coordinates in order to then generate terrain.\n// The hashing functions are a lower dimensional version\n// of the 3D variant.\nfloat hash( in float x )\n{\n    vec3 p = vec3( x, 1.0, 1.0 );\n    \n    p = 50.0*fract( p*0.3183099 + vec3( 0.71, 0.113, 0.419 ) );\n    return -1.0+2.0*fract( p.x*p.y*p.z*( p.x + p.y + p.z ) );\n}\n\n// Still the same exact thing, all of those could probably\n// be optimized for their respective dimension, but it\n// worked well enough.\nfloat hash( in vec2 x )\n{\n    vec3 p = vec3( x, 1.0 );\n    \n    p = 50.0*fract( p*0.3183099 + vec3( 0.71, 0.113, 0.419 ) );\n    return -1.0+2.0*fract( p.x*p.y*p.z*( p.x + p.y + p.z ) );\n}\n\n// The actual 3D version of the hashing function, those\n// will later be used for noise function.\nfloat hash( in vec3 x )\n{\n    vec3 p = x;\n    \n    p = 50.0*fract( p*0.3183099 + vec3( 0.71, 0.113, 0.419 ) );\n    return -1.0+2.0*fract( p.x*p.y*p.z*( p.x + p.y + p.z ) );\n}\n\n// 2D and 3D noise surface functions.\n// used for constructing fractional brownian motion surfaces.\nfloat noise( in vec2 x )\n{\n    vec3 p = vec3( floor(x), 0.0 );\n    vec3 w = vec3( fract(x), 0.0 );\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return float( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return float( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z) );\n}\n// analytic derivatives of the 2D and 3D surface noise functions.\n// used for assigning colors to terrain based on steepness.\nvec3 noiseD( in vec2 x )\n{\n    vec3 p = vec3( floor(x), 0.0 );\n    vec3 w = vec3( fract(x), 0.0 );\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du =   30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec3(2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec3 noiseD( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du =   30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p + vec3( 0, 0, 0 ) );\n    float b = hash( p + vec3( 1, 0, 0 ) );\n    float c = hash( p + vec3( 0, 1, 0 ) );\n    float d = hash( p + vec3( 1, 1, 0 ) );\n    float e = hash( p + vec3( 0, 0, 1 ) );\n    float f = hash( p + vec3( 1, 0, 1 ) );\n    float g = hash( p + vec3( 0, 1, 1 ) );\n    float h = hash( p + vec3( 1, 1, 1 ) ); \n\n    float k0 =                               a;\n    float k1 =                           b - a;\n    float k2 =                           c - a;\n    float k3 =                           e - a;\n    float k4 =                   a - b - c + d;\n    float k5 =                   a - c - e + g;\n    float k6 =                   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec3(2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n// fractional brownian motion based noise modification with d octaves for 2D and 3D noise. \n// used for generating more realistic terrain.\nfloat fbm( in vec2 p, in int d )\n{\n    float n = 0.0;\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noise( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\nfloat fbm( in vec3 p, in int d )\n{\n    float n = 0.0;\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noise( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\n// fractional brownian motion based noise analytic derivative modification with d octaves for 2D and 3D noise/\n// used for getting the derivative of the realistic terrain.\nvec3 fbmD( in vec2 p, in int d )\n{\n    vec3 n = vec3(0.0);\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noiseD( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\nvec3 fbmD( in vec3 p, in int d )\n{\n    vec3 n = vec3(0.0);\n    \n    for( int i = 0; i < d; i++ )\n    {\n    \tn += pow( 1.5, -float( i ) )*noiseD( p*( pow( 2.14, float( i ) ) ) );\n    }\n    \n    return n;\n}\n\n// warped fractional brownian motion surface.\n// works by re-entering input into the fbm.\nfloat wFbm( in vec2 p, in int w, in int d )\n{\n    vec2 x = vec2( fbm( p, d ), fbm( p*4.568934, d ) );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbm( x, 1 );\n        t2 = fbm( x*4.568934, 1 );\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n\nfloat wFbm( in vec3 p, in int w, in int d )\n{\n    vec2 x = vec2( fbm( p, d ), fbm( p*4.568934, d ) );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbm( vec3( x, 1.0 ), d );\n        t2 = fbm( vec3( x*4.568934, 1.0 ), d );\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n\nfloat wFbmD( in vec2 p, in int w, in int d )\n{\n    vec2 x = vec2( fbmD( p, d ).x, fbmD( p*4.568934, d ).y );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbmD( x, 1 ).x;\n        t2 = fbmD( x*4.568934, 1 ).y;\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n\nfloat wFbmD( in vec3 p, in int w, in int d )\n{\n    vec2 x = vec2( fbmD( p, d ).x, fbmD( p*4.568934, d ).y );\n    \n    for( int i = 0; i < w; i++ )\n    {\n    \tfloat t1 = 0.0;\n    \tfloat t2 = 0.0;\n        \n    \tt1 =          fbmD( vec3( x, 1.0 ), d ).x;\n        t2 = fbmD( vec3( x*4.568934, 1.0 ), 1 ).y;\n        \n        x = vec2( t1, t2 );\n    }\n    \n    return float( x );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 114, 145, 448]], "test": "untested"}
{"id": "wdycWy", "name": "Fab26 #inktober2020 \"hide\"", "author": "FabriceNeyret2", "description": "mouse controls the blocks.  Will you dare moving it ? :-p\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["2d", "simulation", "particles", "short", "swarm", "inktober2020", "cockroaches"], "likes": 13, "viewed": 742, "published": 3, "date": "1603628547", "time_retrieved": "2024-07-30T20:38:10.315381", "image_code": "// find hidding cockroaches !  variant of https://www.shadertoy.com/view/3dGyWy\n\n#define rot(v) mat2( v, -v.y, v.x ) / length(v)\n\nfloat line(vec2 p, vec2 a,vec2 b) { // https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    p -= b * clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return dot(p,p);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / R.y, P, X = vec2(.01,0);\n    \n    O = T(u);                                            // load drawing\n    \n    float l = 1e5,v;\n#define d(d) .03*sin(6.28*(iTime+float(d)/3.)+float(i))\n    for(int i=1; i<N; i++) {                             // draw moving particles\n        vec4 T =T(vec2(i,0));\n        P = T.xy - U; \n        if ( length(P) > .084 ) continue;                // bounding sphere optimization\n//      O.b += clamp( R.y*max(0.,.04-length( P )/2.1 ), 0., 1. );        // show bounding sphere\n        P *= rot(T.zw);\n//      O.b += clamp( R.y*max(0.,.04-length( P/ vec2(3,1) ) ), 0., 1. ); // show bounding ellipse\n        v = max(0.,length( P/ vec2(3,1) ) - .01 ); l = min(l, v*v );        // body\n        v = max(0.,length( P + 3.*X )     - .01 ); l = min(l, v*v );        // head\n        for(int s=0; s<2; s++) {\n            l = min(l, line(P, vec2( .01, .013), vec2(.04+d(0)   , .03)) ); // legs\n            l = min(l, line(P, vec2(  0,  .013), vec2(.01+d(1)/2., .04)) ); \n            l = min(l, line(P, vec2(-.01, .013), vec2(-.015+d(2) , .03)) ); \n            l = min(l, line(P, vec2(-.03,  0  ), vec2(-.08, d(0))      ) ); \n            P.y = -P.y;\n        }\n    }\n     O *=  clamp( R.y*(sqrt(l)-.001), 0., 1. );\n    \n    U = abs( U - T(0).xy ) ; O += max(0., R.y/8.- R.y/2.*max(U.x,U.y) );    // hidder \n    O = sqrt(O);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(u) fract(sin( (u)* mat2(127.1,311.7, 269.5,183.3) ) *4e5 ) // variant from https://www.shadertoy.com/view/llySRh\n#define G(d) textureLod(iChannel0, (d + P) / a  ,2. ).a\n#define dt   iTimeDelta\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                                 // restore state\n    vec2 U = u / R.y, a = R/R.y, P, e=vec2(.1,0), F,D; float l;\n    \n    if (T(1).b != iChannelResolution[1].x || T(1).a != R.x ) {// --- init at texture load or resolution change\n        if (u.y == .5)\n        { if (iFrame < 1) O = vec4( H(u) , .7*(2.*H(u+.5)-1.) ); }  // particles\n        else O = texture(iChannel1, u/R ).r * vec4(.8,.4,.2,1)+.1*vec4(1,1,1,0); // ground\n        if (u==vec2(1.5)) O.b = iChannelResolution[1].x, O.a = R.x; // for re-init\n        return;\n    }    \n    \n    if ( u == vec2(.5) )                                      // --- leader\n            O.xy = iMouse.xy !=vec2(0) ? iMouse.xy / R.y : a/2.;\n         // O.xy = iMouse.z > 0. ? iMouse.xy / R.y : (.5+.4*cos(iTime+vec2(0,33)))*a;\n    else if ( u.y == .5  && int(u.x) < N )                    // --- particle simulation\n    {\n        P = O.xy; \n        F = T(0).xy - P; F *= 5. / max(.1,length(F));        // attracted by leader\n        F -= .5 * ( vec2(G(e),G(e.yx)) - G() ) / e.x;         // repulsed by dense areas                      \n        for (int i=1; i<N; i++)                               // particles repulse each other\n            if (int(u)!=i) D = T(vec2(i,0)).xy - P, l = length(D),\n                           l < .1 ? F -= D/(.1+l*l)  : F;\n\n        O.zw *= .98;                                          // viscosity\n        O.zw += dt * F,                                       // Newton: v += F.dt\n        O.xy += dt * O.zw;                                    //         p += v.dt\n     // O.xy = fract(O.xy /a ) * a;                           // wrapped world\n    }\n }", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int N = 100;    // number of particles\n#define R       iResolution.xy\n#define T(U)    texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdycWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 165, 206, 300], [302, 302, 340, 340, 1700]], "test": "untested"}
{"id": "tsGyDy", "name": "Magic Ball Sorter", "author": "dr2", "description": "Works as advertised (alternating mix and sort cycles)", "tags": ["collision", "dynamics", "physics", "entropy", "galton"], "likes": 33, "viewed": 669, "published": 3, "date": "1603627605", "time_retrieved": "2024-07-30T20:38:11.530133", "image_code": "// \"Magic Ball Sorter\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 QtToRMat (vec4 q);\nvec3 OrAng (vec3 p);\nvec3 OrAngT (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\nconst ivec3 nbEdge = ivec3 (20, 2, 16);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 ltDir, qHit, vnBall, hbSize, blkAng, vnBlk;\nfloat dstFar, hbMarg, nBin;\nint idObj, idBall;\nconst int txOff = 4;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q, eWid, ss;\n  float dMin, d, tr, f, b;\n  dMin = dstFar;\n  q = p;\n  q = OrAng (q);\n  sLen = vec4 (hbSize - hbMarg - 0.1, 0.);\n  eWid = vec3 (0.15);\n  q = abs (q);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, eWid + sLen.xww - 0.1, 0.1),\n     PrRoundBoxDf (q - sLen.xwz, eWid + sLen.wyw - 0.1, 0.1)),\n     PrRoundBoxDf (q - sLen.xyw, eWid + sLen.wwz - 0.1, 0.1));\n  DMINQ (1);\n  q = p;\n  q.y -= - hbSize.x - eWid.x - 0.4;\n  d = PrRoundBoxDf (q, vec3 (hbSize.z + 3., 0.4, hbSize.z + 3.) - 0.05, 0.05);\n  DMINQ (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cEdge;\n  float dMin, d, cGap, hGap, hHt, vHt, cr, hy;\n  dMin = dstFar;\n  cGap = 2.5;\n  cEdge = vec2 (3.5, 4.5);\n  hGap = 0.2;\n  hHt = 0.5;\n  vHt = 8.;\n  cr = 0.46;\n  hy = hbSize.y - hbMarg - 0.5;\n  p = OrAng (p);\n  q = p;\n  d = max (abs (q.x) - cEdge.x * cGap, abs (q.z) - cEdge.y * cGap);\n  q.z += 0.25 * cGap * sign (mod (floor (q.x / cGap + 0.5), 2.) - 0.5);\n  d = max (d, PrCapsDf (vec3 (mod (q.xz + 0.5 * cGap, cGap) - 0.5 * cGap, q.y), cr, hy));\n  dMin = min (dMin, d);\n  q = p;\n  d = max (abs (q.z) - hbSize.z + hbMarg, - q.x - hbSize.x + hbMarg);\n  if (mod (nBin, 2.) != 0.) q.z += hbSize.z / nBin;\n  q.z = mod (q.z + hbSize.z / nBin, 2. * hbSize.z / nBin) - hbSize.z / nBin;\n  d = max (d, PrRoundBoxDf (vec3 (q.x + hbSize.x, q.yz), vec3 (vHt, hy, 0.01), cr));\n  dMin = min (dMin, d);\n  q = p;\n  q.z = abs (q.z) - hbSize.z;\n  d = q.z + hbMarg;\n  q.x -= hHt * hbSize.x;\n  d = max (d, PrRoundBoxDf (q, vec3 (0.01, hy, (1. - hGap) * hbSize.z), cr));\n  dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.46 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n} \n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = vnBall * QtToRMat (Loadv4 (txOff + 4 * idBall + 2));\n  return step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat BlkHitSil (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec3 col)\n{\n  vec4 col4;\n  vec3 roo, rdo, vn, colT;\n  float dstBall, dstObj, dstTrObj, db, c, nDotL;\n  hbMarg = 0.4;\n  dstObj = ObjRay (ro, rd);\n  dstTrObj = TrObjRay (ro, rd);\n  dstBall = dstFar;\n  roo = ro;\n  rdo = rd;\n  ro = OrAng (ro);\n  rd = OrAng (rd);\n  db = BlkHitSil (ro, rd);\n  if (db < dstFar) {\n    dstBall = BallHit (ro, rd);\n    if (dstBall < min (dstObj, dstFar)) {\n      vn = OrAngT (vnBall);\n      c = Loadv4 (txOff + 4 * idBall + 1).w;\n      col = vec3 (1., 0.3, 0.3);\n      if (c > 0.) col = (c == 1.) ? col.grg : ((c == 2.) ? col.ggr : ((c == 3.) ? col.rrg :\n         (c == 4.) ? col.rgr : col.grr));\n      col4 = vec4 (col * (0.6 + 0.4 * BallChqr (idBall, vnBall)), 0.3);\n      idObj = -1;\n    }\n  }\n  ro = roo;\n  rd = rdo;\n  if (dstObj < min (dstBall, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    } else if (idObj == 2) {\n       col4 = mix (vec4 (0.7, 0.3, 0.1, 0.1), vec4 (0.4, 0.2, 0.1, 0.1),\n          Fbm2 (qHit.xz * vec2 (0.5, 4.)));\n    }\n  }\n  if (min (dstBall, dstObj) < dstFar) {\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj != 4) nDotL *= nDotL;\n    col = col4.rgb * (0.3 + 0.7 * nDotL) + col4.a * pow (max (0.,\n       dot (ltDir, reflect (rd, vn))), 32.);\n  } else if (db < dstFar) col *= 0.9;\n  if (dstTrObj < min (dstBall, dstObj)) {\n    ro = roo;\n    rd = rdo;\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    colT = vec3 (0.8, 0.8, 0.9) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) + 0.1 * pow (max (0.,\n       dot (ltDir, reflect (rd, vn))), 32.);\n    col = mix (col, colT, 0.85);\n  }\n  if (BlkHit (OrAng (roo), OrAng (rdo)) < min (dstObj, dstFar)) {\n    vn = OrAngT (vnBlk);\n    col = mix (col, vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rdo, vn))), 32.),\n       pow (1. - abs (dot (rdo, vn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float b, zmFac, el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  stDat = Loadv4 (1);\n  blkAng = stDat.xyz;\n  zmFac = 9.;\n  stDat = Loadv4 (2);\n  nBin = stDat.w;\n  stDat = Loadv4 (3);\n  el = stDat.x;\n  az = stDat.y;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  b = length (hbSize);\n  ro = vuMat * vec3 (0., -0.04, - 8.) * b;\n  dstFar = 20. * b;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  col = vec3 (0.3, 0.3, 0.35) * (0.7 + 0.3 * uv.y);\n  col = ShowScene (ro, rd, col);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec3 OrAng (vec3 p)\n{\n  p.xz = Rot2D (p.xz, blkAng.y);\n  p.yz = Rot2D (p.yz, blkAng.x);\n  p.xy = Rot2D (p.xy, blkAng.z);\n  return p;\n}\n\nvec3 OrAngT (vec3 p)\n{\n  p.xy = Rot2D (p.xy, - blkAng.z);\n  p.yz = Rot2D (p.yz, - blkAng.x);\n  p.xz = Rot2D (p.xz, - blkAng.y);\n  return p;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Magic Ball Sorter\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (20, 2, 16);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT, nBin, rSeed;\nconst float txRow = 128.;\nconst int txOff = 4;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 cEdge;\n  float cGap, hGap, hHt, vHt, rSep, diamAv, h, fc, ft, fHoriz;\n  fHoriz = 0.5;\n  cGap = 2.5;\n  hGap = 0.2;\n  hHt = 0.5;\n  cEdge = vec2 (3.5, 4.5);\n  vHt = 8.;\n  diamAv = 0.5 * (diam + 1.);\n  dr.y = 0.;\n  dr.xz = rm.xz;\n  dr.z += 0.25 * cGap * sign (mod (floor (dr.x / cGap + 0.5), 2.) - 0.5);\n  if (abs (dr.x) < cEdge.x * cGap && abs (dr.z) < cEdge.y * cGap)\n     dr.xz = mod (dr.xz + 0.5 * cGap, cGap) - 0.5 * cGap;\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  if (mod (nBin, 2.) != 0.) dr.z += hbSize.z / nBin;\n  dr.z = mod (dr.z + hbSize.z / nBin, 2. * hbSize.z / nBin) - hbSize.z / nBin;\n  dr.x = max (dr.x + hbSize.x - vHt, 0.);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  dr.x -= hHt * hbSize.x;\n  if (dr.x > 0.) am.z -= fHoriz * sign (rm.z);\n  else am.z += 0.5 * fHoriz * sign (rm.z);\n  dr.z = min (abs (dr.z) - hGap * hbSize.z, 0.) * sign (dr.z);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  bCol = p.w;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  ObsInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec3 e;\n  float mIdf, ha;\n  mIdf = float (mId);\n  e = vec3 (0.5 * hbSize.x, hbSize.y, 2. * hbSize.z);\n  rm = 0.8 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  rm.x += hbSize.x - 4.5;\n  ha = mIdf + rSeed;\n  vm = 0.05 * normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (ha + 0.1);\n  bCol = floor (nBin * Hashff (ha + 1.1));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas;\n  float el, az, diam, bCol, bc, vMax, nCyc, todCur, todInit;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = vec3 (nbEdge);\n    nStep = 0.;\n    nCyc = 0.;\n    el = 0.;\n    az = 0.;\n    todInit = todCur;\n    nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    blkAng = vec3 (0., -0.5 * pi, 1.5 * pi);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nCyc = stDat.w;\n    stDat = Loadv4 (2);\n    nBin = stDat.w;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    todInit = stDat.z;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = clamp (0.5 * pi * mPtr.y, -0.2 * pi, 0.);\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  rSeed = 11.1 * mod (todInit, 1.);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam, bCol);\n    else Step (mId, rm, vm, qm, wm, diam, bCol);\n  }\n  if (nStep > 1000.) {\n    vMax = 0.;\n    for (int n = VAR_ZERO; n < nBall; n ++) vMax = max (vMax, length (Loadv4 (txOff + 4 * n + 1).xyz));\n    if (vMax < 0.5) {\n      nStep = 0.;\n      ++ nCyc;\n      if (mod (nCyc, 2.) > 0.) bc = floor (nBin * (0.5 * rm.z / hbSize.z + 0.5));\n      else todInit = todCur;\n      rSeed = 11.1 * mod (todInit, 1.);\n      Init (mId, rm, vm, qm, wm, diam, bCol);\n      if (mod (nCyc, 2.) > 0.) bCol = bc;\n      else nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    }\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, 0.);\n  else if (pxId == 1) stDat = vec4 (blkAng, nCyc);\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, nBin);\n  else if (pxId == 3) stDat = vec4 (el, az, todInit, nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, bCol)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Magic Ball Sorter\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (20, 2, 16);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT, nBin, rSeed;\nconst float txRow = 128.;\nconst int txOff = 4;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 cEdge;\n  float cGap, hGap, hHt, vHt, rSep, diamAv, h, fc, ft, fHoriz;\n  fHoriz = 0.5;\n  cGap = 2.5;\n  hGap = 0.2;\n  hHt = 0.5;\n  cEdge = vec2 (3.5, 4.5);\n  vHt = 8.;\n  diamAv = 0.5 * (diam + 1.);\n  dr.y = 0.;\n  dr.xz = rm.xz;\n  dr.z += 0.25 * cGap * sign (mod (floor (dr.x / cGap + 0.5), 2.) - 0.5);\n  if (abs (dr.x) < cEdge.x * cGap && abs (dr.z) < cEdge.y * cGap)\n     dr.xz = mod (dr.xz + 0.5 * cGap, cGap) - 0.5 * cGap;\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  if (mod (nBin, 2.) != 0.) dr.z += hbSize.z / nBin;\n  dr.z = mod (dr.z + hbSize.z / nBin, 2. * hbSize.z / nBin) - hbSize.z / nBin;\n  dr.x = max (dr.x + hbSize.x - vHt, 0.);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  dr.x -= hHt * hbSize.x;\n  if (dr.x > 0.) am.z -= fHoriz * sign (rm.z);\n  else am.z += 0.5 * fHoriz * sign (rm.z);\n  dr.z = min (abs (dr.z) - hGap * hbSize.z, 0.) * sign (dr.z);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  bCol = p.w;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  ObsInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec3 e;\n  float mIdf, ha;\n  mIdf = float (mId);\n  e = vec3 (0.5 * hbSize.x, hbSize.y, 2. * hbSize.z);\n  rm = 0.8 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  rm.x += hbSize.x - 4.5;\n  ha = mIdf + rSeed;\n  vm = 0.05 * normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (ha + 0.1);\n  bCol = floor (nBin * Hashff (ha + 1.1));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas;\n  float el, az, diam, bCol, bc, vMax, nCyc, todCur, todInit;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = vec3 (nbEdge);\n    nStep = 0.;\n    nCyc = 0.;\n    el = 0.;\n    az = 0.;\n    todInit = todCur;\n    nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    blkAng = vec3 (0., -0.5 * pi, 1.5 * pi);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nCyc = stDat.w;\n    stDat = Loadv4 (2);\n    nBin = stDat.w;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    todInit = stDat.z;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = clamp (0.5 * pi * mPtr.y, -0.2 * pi, 0.);\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  rSeed = 11.1 * mod (todInit, 1.);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam, bCol);\n    else Step (mId, rm, vm, qm, wm, diam, bCol);\n  }\n  if (nStep > 1000.) {\n    vMax = 0.;\n    for (int n = VAR_ZERO; n < nBall; n ++) vMax = max (vMax, length (Loadv4 (txOff + 4 * n + 1).xyz));\n    if (vMax < 0.5) {\n      nStep = 0.;\n      ++ nCyc;\n      if (mod (nCyc, 2.) > 0.) bc = floor (nBin * (0.5 * rm.z / hbSize.z + 0.5));\n      else todInit = todCur;\n      rSeed = 11.1 * mod (todInit, 1.);\n      Init (mId, rm, vm, qm, wm, diam, bCol);\n      if (mod (nCyc, 2.) > 0.) bCol = bc;\n      else nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    }\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, 0.);\n  else if (pxId == 1) stDat = vec4 (blkAng, nCyc);\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, nBin);\n  else if (pxId == 3) stDat = vec4 (el, az, todInit, nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, bCol)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Magic Ball Sorter\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (20, 2, 16);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT, nBin, rSeed;\nconst float txRow = 128.;\nconst int txOff = 4;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 cEdge;\n  float cGap, hGap, hHt, vHt, rSep, diamAv, h, fc, ft, fHoriz;\n  fHoriz = 0.5;\n  cGap = 2.5;\n  hGap = 0.2;\n  hHt = 0.5;\n  cEdge = vec2 (3.5, 4.5);\n  vHt = 8.;\n  diamAv = 0.5 * (diam + 1.);\n  dr.y = 0.;\n  dr.xz = rm.xz;\n  dr.z += 0.25 * cGap * sign (mod (floor (dr.x / cGap + 0.5), 2.) - 0.5);\n  if (abs (dr.x) < cEdge.x * cGap && abs (dr.z) < cEdge.y * cGap)\n     dr.xz = mod (dr.xz + 0.5 * cGap, cGap) - 0.5 * cGap;\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  if (mod (nBin, 2.) != 0.) dr.z += hbSize.z / nBin;\n  dr.z = mod (dr.z + hbSize.z / nBin, 2. * hbSize.z / nBin) - hbSize.z / nBin;\n  dr.x = max (dr.x + hbSize.x - vHt, 0.);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  dr.x -= hHt * hbSize.x;\n  if (dr.x > 0.) am.z -= fHoriz * sign (rm.z);\n  else am.z += 0.5 * fHoriz * sign (rm.z);\n  dr.z = min (abs (dr.z) - hGap * hbSize.z, 0.) * sign (dr.z);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  bCol = p.w;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  ObsInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec3 e;\n  float mIdf, ha;\n  mIdf = float (mId);\n  e = vec3 (0.5 * hbSize.x, hbSize.y, 2. * hbSize.z);\n  rm = 0.8 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  rm.x += hbSize.x - 4.5;\n  ha = mIdf + rSeed;\n  vm = 0.05 * normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (ha + 0.1);\n  bCol = floor (nBin * Hashff (ha + 1.1));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas;\n  float el, az, diam, bCol, bc, vMax, nCyc, todCur, todInit;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = vec3 (nbEdge);\n    nStep = 0.;\n    nCyc = 0.;\n    el = 0.;\n    az = 0.;\n    todInit = todCur;\n    nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    blkAng = vec3 (0., -0.5 * pi, 1.5 * pi);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nCyc = stDat.w;\n    stDat = Loadv4 (2);\n    nBin = stDat.w;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    todInit = stDat.z;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = clamp (0.5 * pi * mPtr.y, -0.2 * pi, 0.);\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  rSeed = 11.1 * mod (todInit, 1.);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam, bCol);\n    else Step (mId, rm, vm, qm, wm, diam, bCol);\n  }\n  if (nStep > 1000.) {\n    vMax = 0.;\n    for (int n = VAR_ZERO; n < nBall; n ++) vMax = max (vMax, length (Loadv4 (txOff + 4 * n + 1).xyz));\n    if (vMax < 0.5) {\n      nStep = 0.;\n      ++ nCyc;\n      if (mod (nCyc, 2.) > 0.) bc = floor (nBin * (0.5 * rm.z / hbSize.z + 0.5));\n      else todInit = todCur;\n      rSeed = 11.1 * mod (todInit, 1.);\n      Init (mId, rm, vm, qm, wm, diam, bCol);\n      if (mod (nCyc, 2.) > 0.) bCol = bc;\n      else nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    }\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, 0.);\n  else if (pxId == 1) stDat = vec4 (blkAng, nCyc);\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, nBin);\n  else if (pxId == 3) stDat = vec4 (el, az, todInit, nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, bCol)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Magic Ball Sorter\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (20, 2, 16);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT, nBin, rSeed;\nconst float txRow = 128.;\nconst int txOff = 4;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 cEdge;\n  float cGap, hGap, hHt, vHt, rSep, diamAv, h, fc, ft, fHoriz;\n  fHoriz = 0.5;\n  cGap = 2.5;\n  hGap = 0.2;\n  hHt = 0.5;\n  cEdge = vec2 (3.5, 4.5);\n  vHt = 8.;\n  diamAv = 0.5 * (diam + 1.);\n  dr.y = 0.;\n  dr.xz = rm.xz;\n  dr.z += 0.25 * cGap * sign (mod (floor (dr.x / cGap + 0.5), 2.) - 0.5);\n  if (abs (dr.x) < cEdge.x * cGap && abs (dr.z) < cEdge.y * cGap)\n     dr.xz = mod (dr.xz + 0.5 * cGap, cGap) - 0.5 * cGap;\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  if (mod (nBin, 2.) != 0.) dr.z += hbSize.z / nBin;\n  dr.z = mod (dr.z + hbSize.z / nBin, 2. * hbSize.z / nBin) - hbSize.z / nBin;\n  dr.x = max (dr.x + hbSize.x - vHt, 0.);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.xz = rm.xz;\n  dr.x -= hHt * hbSize.x;\n  if (dr.x > 0.) am.z -= fHoriz * sign (rm.z);\n  else am.z += 0.5 * fHoriz * sign (rm.z);\n  dr.z = min (abs (dr.z) - hGap * hbSize.z, 0.) * sign (dr.z);\n  rSep = length (dr);\n  if (rSep < diamAv) {\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm;\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  bCol = p.w;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  ObsInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam, out float bCol)\n{\n  vec3 e;\n  float mIdf, ha;\n  mIdf = float (mId);\n  e = vec3 (0.5 * hbSize.x, hbSize.y, 2. * hbSize.z);\n  rm = 0.8 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  rm.x += hbSize.x - 4.5;\n  ha = mIdf + rSeed;\n  vm = 0.05 * normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (ha), Hashff (ha + 0.3), Hashff (ha + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (ha + 0.1);\n  bCol = floor (nBin * Hashff (ha + 1.1));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas;\n  float el, az, diam, bCol, bc, vMax, nCyc, todCur, todInit;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = vec3 (nbEdge);\n    nStep = 0.;\n    nCyc = 0.;\n    el = 0.;\n    az = 0.;\n    todInit = todCur;\n    nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    blkAng = vec3 (0., -0.5 * pi, 1.5 * pi);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nCyc = stDat.w;\n    stDat = Loadv4 (2);\n    nBin = stDat.w;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    todInit = stDat.z;\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = clamp (0.5 * pi * mPtr.y, -0.2 * pi, 0.);\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  rSeed = 11.1 * mod (todInit, 1.);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam, bCol);\n    else Step (mId, rm, vm, qm, wm, diam, bCol);\n  }\n  if (nStep > 1000.) {\n    vMax = 0.;\n    for (int n = VAR_ZERO; n < nBall; n ++) vMax = max (vMax, length (Loadv4 (txOff + 4 * n + 1).xyz));\n    if (vMax < 0.5) {\n      nStep = 0.;\n      ++ nCyc;\n      if (mod (nCyc, 2.) > 0.) bc = floor (nBin * (0.5 * rm.z / hbSize.z + 0.5));\n      else todInit = todCur;\n      rSeed = 11.1 * mod (todInit, 1.);\n      Init (mId, rm, vm, qm, wm, diam, bCol);\n      if (mod (nCyc, 2.) > 0.) bCol = bc;\n      else nBin = 4. + floor (3. * Hashff (mod (todInit, 1.)));\n    }\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, 0.);\n  else if (pxId == 1) stDat = vec4 (blkAng, nCyc);\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, nBin);\n  else if (pxId == 3) stDat = vec4 (el, az, todInit, nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, bCol)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[820, 820, 842, 842, 1397], [1399, 1399, 1432, 1432, 1616], [1618, 1618, 1639, 1639, 1896], [1898, 1898, 1922, 1922, 2935], [2937, 2937, 2972, 2972, 3158], [3160, 3160, 3183, 3183, 3442], [3444, 3444, 3478, 3478, 3909], [3912, 3912, 3954, 3954, 4088], [4090, 4090, 4123, 4123, 4435], [4437, 4437, 4473, 4473, 4677], [4679, 4679, 4724, 4724, 6642], [6644, 6644, 6697, 6697, 7411], [7413, 7413, 7459, 7459, 7506], [7508, 7508, 7550, 7550, 7601], [7603, 7603, 7646, 7646, 7719], [7721, 7721, 7743, 7743, 7781], [7783, 7783, 7805, 7805, 7843], [7845, 7845, 7870, 7870, 8266], [8268, 8268, 8289, 8289, 8402], [8404, 8404, 8426, 8426, 8545], [8547, 8547, 8583, 8583, 8789], [8791, 8791, 8821, 8821, 8934], [8968, 8968, 8992, 8992, 9122], [9124, 9124, 9149, 9149, 9335], [9337, 9337, 9358, 9358, 9513], [9607, 9607, 9632, 9632, 9755]], "test": "untested"}
{"id": "3dGyWy", "name": "Fab25 #inktober2020 \"buddy\"", "author": "FabriceNeyret2", "description": "mouse controls the leader.\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["2d", "simulation", "particles", "short", "swarm", "inktober2020"], "likes": 8, "viewed": 481, "published": 3, "date": "1603618112", "time_retrieved": "2024-07-30T20:38:12.340965", "image_code": "  #define rot(v) mat2( v, -v.y, v.x ) / length(v)\n//#define rot(v) mat2( cos( -atan(v.y,v.x) + vec4(0,33,11,0) ) )\n\n#define D(i,r)  ( P =  T(vec2(i,0)), \\\n                  clamp( R.y*r - R.y/2.*length( (P.xy-U)*rot(P.zw) / vec2(2,1) ), 0., 1. ) ) // draw disk\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / R.y;\n    vec4 P;\n    \n    O = T(u);                                 // load drawing\n    \n    for(int i=1; i<N; i++)                    // draw moving particles\n        O.r = max( O.r,  D( i , .008 ) );\n    \n    O.rg += D( 0. , .016 );                   // leader\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(u) fract(sin( (u)* mat2(127.1,311.7, 269.5,183.3) ) *4e5 )\n#define G(d) textureLod(iChannel0, (d + P) / a  ,2. ).a\n#define dt   iTimeDelta\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                                 // restore state\n    vec2 U = u / R.y, a = R/R.y, P, e=vec2(.1,0), F,D; float l;\n    \n    if (T(1).b != iChannelResolution[1].x || T(1).a != R.x ) {// --- init at texture load or resolution change\n        if (u.y == .5)                                        // particles\n        {  if(iFrame < 1) O = vec4( H(u) , .7*(2.*H(u+.5)-1.) ); }\n        else  O = texture( iChannel1, u/R, 0. ).rrrr;         // draw ground\n        if (u==vec2(1.5)) O.b = iChannelResolution[1].x, O.a = R.x; // for re-init\n        return;\n    }    \n    \n    if ( u == vec2(.5) )                                      // --- leader\n            O.xy = iMouse.z > 0. ? iMouse.xy / R.y : (.5+.4*cos(iTime+vec2(0,33)))*a,\n            O.zw = ( O.xy - T(0).xy ) / dt; \n    else if ( u.y == .5  && int(u.x) < N )                    // --- particle simulation\n    {\n        P = O.xy; \n        F = T(0).xy - P; F *= 1.5 / max(.1,length(F));        // attracted by leader\n        F -= .5 * ( vec2(G(e),G(e.yx)) - G() ) / e.x;         // repulsed by dense areas                      \n/*      for (int i=1; i<N; i++)                               // particles repulse each other\n            if (int(u)!=i) D = T(vec2(i,0)).xy - P, l = length(D),\n                           l < .1 ? F -= D/(.1+l*l)  : F;\n*/\n        O.zw *= .98;                                          // viscosity\n        O.zw += dt * F,                                       // Newton: v += F.dt\n        O.xy += dt * O.zw;                                    //         p += v.dt\n     // O.xy = fract(O.xy /a ) * a;                           // wrapped world\n    } \n }", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int N = 100;    // number of particles\n#define R       iResolution.xy\n#define T(U)    texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 300, 300, 582]], "test": "untested"}
{"id": "tdGcWG", "name": "Conway's Game of Life, 1 px res", "author": "milesWaugh", "description": "Look at \"image\"", "tags": ["life", "conway", "cellularautomata", "golly"], "likes": 2, "viewed": 512, "published": 3, "date": "1603601868", "time_retrieved": "2024-07-30T20:38:13.266994", "image_code": "// INSTRUCTIONS:\n \n// Click/drag to invert cell states (dead --> live, live --> dead)\n// Auto-pauses when you draw\n// Pause shader to prolong pause for lengthier drawings\n// Restart project to generate random soup.\n// I recommend screen zoomers to draw literally anything.\n\nvoid mainImage(out vec4 a,in vec2 b){a=texture(iChannel0,b/iResolution.xy);}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float grab(vec2 uv, vec2 rel){\n    return texture(iChannel0,uv+(rel/iResolution.xy)).r;\n}\n\nvec3 mPrev = vec3(0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    mPrev = iMouse.xyz;\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame < 1){\n    \tfragColor = vec4(texture(iChannel1,fragCoord/256.).r>.5?1.:0.);\n    }else{\n        float a = float(round(texture(iChannel0,uv).r));\n        if(iMouse.z > 0.){\n            vec2 v1 = iMouse.xy-fragCoord;\n            if(abs(v1.x)<1. && abs(v1.y)<1.){\n            \ta = 1.-a;\n            }\n        }else{\n            int b = -int(a);\n            for(int i=-1; i<2; i++){\n                for(int j=-1; j<2; j++){\n                \tb += int(grab(uv, vec2(i,j)));\n                }\n            }\n            if(a==1.){\n                if(b<2||b>3){\n                    a=0.;\n                }\n            }else{\n                if(b==3){\n                    a=1.;\n                }\n            }\n        }\n        fragColor = vec4(a);\n    }\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 311, 311, 350]], "test": "untested"}
{"id": "wsGyWG", "name": "october v006", "author": "darkczar", "description": "trippy", "tags": ["trippy"], "likes": 1, "viewed": 354, "published": 3, "date": "1603594942", "time_retrieved": "2024-07-30T20:38:14.136669", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n   //vec3 col = 1000000.5 + 60.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,200);\n    float d = 900000.0 + 1.0*sin(iTime)+4200.*cos(iTime);\n    float di = 50.0;// +3.2*sin(iTime * .1);\n    for(int i = 0;i<5;i++)\n    {\n        di = float(i)*.3;\n        curve_p.x = 900000.5-4.0*sin(.3*iTime); //-25.05*float(d)*cos(float(d)+.4*iTime); // +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = .000005-.3 *cos(.3*iTime)-600.05*float(di)*sin(float(di)+.2*iTime); // +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = sin(min(d*1000.0, 1.*sin(length(p-curve_p))));\n        //d = length(p-curve_p)/(di+1.0);\n  \n    }\n    float r = 50.05*d + 1.5*(.05 - 50.015*pow(dot(sin(p*p + d*d), log(20.0+2.*curve_p -d)),2.0));\n    float g = 30.0008 + 1.05*cos(.50*d*d*d+.3*length(p + curve_p.x)); //+.03*dot(p,curve_p + .0005*vec2(iTime, iTime));\n    float b=60.5*abs(.5+2.3*cos(iTime*.8 - 2.5*pow(d,2.0))); // +.01*(dot(p,curve_p - .005*vec2(iTime-200.05, iTime-200.05)+10.0));\n    if (d < 2.2)\n    {\n        b = .0 +50000.0-.04;//*(.5+ .5*sin(iTime*.1 + 1.28*dot(p,curve_p)));\n    }\n    float checkers = mod(float(uv.x*uv.x +uv.y*uv.y)+r*r*1200.+b*200., .25);\n    float checkers_02 = mod(float( -.01*curve_p.x*curve_p.y)+g*g*100.,.245);\n    if (checkers + checkers_02 > .0000000000001+8.1*sin(iTime*8.))\n    {\n        r = 50.4*r;\n        g = 60.;//1.2*g;\n        b = 50.06*b;\n    }\n    \n    if(uv.x > .5)\n    {\n        r=1.0;\n        g=0.0;\n        b=0.5;\n    } else {\n        r=0.;\n        g=0.5;\n        b=1.0;\n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 2058]], "test": "untested"}
{"id": "WsycDy", "name": "october v005", "author": "darkczar", "description": "algorithmic", "tags": ["trippy"], "likes": 2, "viewed": 497, "published": 3, "date": "1603594563", "time_retrieved": "2024-07-30T20:38:15.047235", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,200);\n    float d = 10000.0 + 4200.*sin(iTime)+4200.*cos(iTime);\n    float di = 2.;// +3.2*sin(iTime * .1);\n    for(int i = 0;i<300;i++)\n    {\n        di = float(i)*.3;\n        curve_p.x = .5-.3*sin(.3*iTime)-.05*float(d)*cos(float(d)+.4*iTime); // +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = .5-.3*cos(.3*iTime)-.05*float(di)*sin(float(di)+.2*iTime); // +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = sin(min(d*1.0, 1.*sin(length(p-curve_p))));\n        //d = length(p-curve_p)/(di+1.0);\n  \n    }\n    float r =.05*d + .05*(.05 - .015*pow(dot(sin(p*p + d*d), log(20.0+2.*curve_p -d)),2.0));\n    float g = .0008 + .005*cos(.001*d*d*d+3.1*length(p)); //+.03*dot(p,curve_p + .0005*vec2(iTime, iTime));\n    float b=2.5*abs(.5+.3*cos(iTime*.8 - 2.5*pow(d,2.0))); // +.01*(dot(p,curve_p - .005*vec2(iTime-200.05, iTime-200.05)+10.0));\n    if (d < 2.2)\n    {\n        b = .0 +.04*(.5+ .5*sin(iTime*.1 + 1.28*dot(p,curve_p)));\n    }\n    float checkers = mod(float(uv.x*uv.x +uv.y*uv.y)+r*r*1200.+b*20., .25);\n    float checkers_02 = mod(float( -.01*curve_p.x*curve_p.y)+g*g*1000.,.245);\n    if (checkers + checkers_02 > .25+.1*sin(iTime))\n    {\n        r = 0.06*r;\n        g = 1.2*g;\n        b = .06*b;\n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsycDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 1842]], "test": "untested"}
{"id": "WsVcRd", "name": "big chungus", "author": "pikmin2010", "description": "chungus", "tags": ["bigchungus"], "likes": 4, "viewed": 431, "published": 3, "date": "1603590541", "time_retrieved": "2024-07-30T20:38:16.192174", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://iquilezles.org/articles/distfunctions\n\n//------------------------------------------------------------------\n#define March_Quality 32\n#define Shadow_Quality 4\n#define AO_Quality 8\n#define Lighting 1\n#define Epsilon 0.00001\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opB( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec3 opRepLim(  vec3 p,  float c, vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return ( q );\n}\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    pos = opRepLim(pos,3.,vec3(1,1,1));\n    pos.y +=0.2;\n    pos.y *=0.9;\n    vec2 belly = vec2( sdSphere(    pos-vec3(.0,0., 0.2), 0.5 ), 11  );\n\n    vec2 brownBelly = vec2(sdSphere(    pos-vec3(.0,0., 0.0), 0.6), 12  );\n    vec2 brownHead = vec2(sdSphere(    pos-vec3(.0,0.6, 0.0), 0.4), 12  );\n    vec3 eyePos = pos;\n    eyePos.x *=1.3;\n    vec2 whiteEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.65, 0.25),0.15), 11  );\n    vec2 whiteEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.65, 0.25), 0.15), 11  );\n    vec2 brownEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.73, 0.22),0.15), 12  );\n    vec2 brownEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.73, 0.22), 0.15), 12  );\n\tvec2 pupilEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.65, 0.37),0.05), 13  );\n    vec2 pupilEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.65, 0.37), 0.05), 13  );\n\t\n    vec3 furPos = pos;\n    furPos.x *=0.5;\n    \n    vec2 mouthFur = vec2(sdSphere( furPos-vec3(0.,0.44,0.35),0.11),11);\n    vec2 mouthFur2 = vec2(sdSphere( furPos-vec3(0.,0.5,0.35),0.09),11);\n    vec2 mouthFur3 = vec2(sdSphere( furPos-vec3(0.,0.56,0.42),0.04),11);\n    vec3 earPos = pos;\n    earPos.z *=1.6;\n    earPos.x *=1.7;\n    earPos.y *=0.5;\n    vec2 brownEarL = vec2(sdSphere(earPos-vec3(0.27,0.5,0.),0.25),12);\n\tvec2 brownEarR = vec2(sdSphere(earPos-vec3(-0.27,0.5,0.),0.25),12);\n    vec2 redEarL = vec2(sdSphere(earPos-vec3(0.27,0.5,0.1),0.18),14);\n\tvec2 redEarR = vec2(sdSphere(earPos-vec3(-0.27,0.5,0.1),0.18),14);\n    vec3 mouthPos = pos;\n\tmouthPos.y -= 0.5;\n    mouthPos.z +=0.14;\n    vec2 mouthSub = vec2(sdBox(mouthPos-vec3(0,-0.05,.5),vec3(0.1,0.1,0.1)),15);\n    vec2 redMouth = vec2(sdSphere(mouthPos-vec3(0.,0.,.5),0.1),15);\n\tredMouth = opB(redMouth,mouthSub);\n    \n    vec2 teeth = opU(vec2(sdBox(mouthPos-vec3(0.035,0.031,0.59),vec3(0.025,0.03,0.005)),11),vec2(sdBox(mouthPos-vec3(-0.035,0.031,0.59),vec3(0.025,0.03,0.005)),11));\n    \n    vec3 feetPos =pos;\n    feetPos.y += 0.4;\n    feetPos.x *=0.7;\n    \n    vec2 leftFoot = vec2(sdSphere(feetPos-vec3(-0.30,0,0),0.25),12);\n    vec2 rightFoot = vec2(sdSphere(feetPos-vec3(0.30,0,0),0.25),12);\n    \n    feetPos.y *=1.1;\n    vec2 leftFootWhite = vec2(sdSphere(feetPos-vec3(-0.40,-0.05,0),0.25),11);\n    vec2 rightFootWhite = vec2(sdSphere(feetPos-vec3(0.40,-0.05,0),0.25),11);\n    vec2 feetWhite = opU(leftFootWhite,rightFootWhite);\n    vec2 feet = opU(leftFoot,rightFoot);\n    feet = opU(feetWhite,feet);\n    \n    \n    vec2 rightArm = vec2(sdCylinder(pos-vec3(0.5,0.25,0.),vec3(0,0,0),vec3(0.5,0,0),0.1),12);      \n    vec2 leftArm = vec2(sdCylinder(pos-vec3(-0.5,0.25,0.),vec3(0,0,0),vec3(-0.5,0,0),0.1),12);\n\tvec2 leftHand = vec2(sdSphere(pos-vec3(-1.0,0.25,0),0.15),11);\n    vec2 rightHand = vec2(sdSphere(pos-vec3(1.0,0.25,0),0.15),11);\n    \n    vec2 res =opU(brownBelly,belly);\n    res = opU(res,brownHead);\n    res = opU(res,whiteEyeL);\n    res = opU(res,whiteEyeR);\n    res = opU(res,brownEyeR);\n\tres = opU(res,brownEyeL);\n    res = opU(res,pupilEyeR);\n\tres = opU(res,pupilEyeL);\n    res = opU(res,mouthFur);\n    res = opU(res,mouthFur2);\n    res = opU(res,mouthFur3);\n    res = opU(res,brownEarL);\n    res = opU(res,brownEarR);\n    res = opU(res,redEarL);\n    res = opU(res,redEarR);\n    res = opU(res,redMouth);\n    res = opU(res,teeth);\n\tres = opU(res,feet);\n    res = opU(res,rightArm);\n    res = opU(res,leftArm);\n    res = opU(res,leftHand);\n    res = opU(res,rightHand);\n\n    return res;\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n   \n    //else return res;\n    \n    // raymarch primitives   \n\n        float t = tmin;\n        for( int i=0; i<March_Quality && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(Epsilon*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    \n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<Shadow_Quality; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<AO_Quality; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if(m>=10.){\n        if(m<=11.){\n         col = vec3(1,1,1);   \n        }else if(m<=12.){\n         col = vec3(0.45,0.4,0.4);   \n        }else if(m<=13.){\n            col = vec3(0.,0.,0.);\n        }else if(m<=14.){\n            col = vec3(0.85,0.54,0.50);\n        \n        }else if(m<=15.){\n            col = vec3(0.75,0.47,0.63);\n        }\n    \n  \n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n        \n        \n            ks = 0.4;\n        }\n        if(Lighting ==1){\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(1.5, 0.8, 0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n        }\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0., -0., -0. );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.1);\n\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.45) );\n\n        tot += col;\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVcRd.jpg", "access": "api", "license": "mit", "functions": [[1596, 1596, 1621, 1621, 1640], [1641, 1641, 1666, 1666, 1685], [1686, 1686, 1722, 1722, 1750], [1754, 1800, 1827, 1827, 1974], [1976, 2022, 2049, 2049, 2196], [2198, 2244, 2271, 2271, 2418], [2420, 2420, 2455, 2455, 2481], [2483, 2483, 2514, 2514, 2605], [2608, 2608, 2660, 2660, 2774], [2777, 2789, 2825, 2825, 2928], [2930, 2955, 3006, 3006, 3361], [3435, 3435, 3465, 3465, 3498], [3500, 3500, 3530, 3530, 3563], [3565, 3565, 3608, 3608, 3669], [3840, 3840, 3865, 3865, 7270], [7272, 7272, 7323, 7323, 7528], [7530, 7530, 7570, 7570, 8025], [8027, 8072, 8150, 8173, 8572], [8574, 8620, 8652, 8652, 9222], [9224, 9224, 9266, 9266, 9584], [9640, 9640, 9705, 9724, 12465], [12467, 12467, 12519, 12519, 12696], [12698, 12698, 12755, 12755, 13768]], "test": "untested"}
{"id": "3sGcDy", "name": "Lakes and forests", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/tsVyzc]\"Meandering Canyons\"[/url] shader.", "tags": ["fractal", "forest", "lake"], "likes": 1, "viewed": 318, "published": 3, "date": "1603589933", "time_retrieved": "2024-07-30T20:38:17.068829", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 20.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat heightmap(vec2 uv)\n{\n    \tuv /= 75.0;\n            float col;\n    float t = iTime*.1;\n    vec2 v1;\n\n        float factor = 1.5;\n        for(int i=0;i<9;i++)\n        {\n            v1 = uv.yx/factor;\n            uv *= -factor*factor;\n            uv += sin(uv.yx/factor)/factor;\n            col += sin(uv.x-uv.y+col+v1.y)+cos(uv.y-uv.x+v1.x);\n        }\n    return -col/2.0;\n}\n\nfloat sceneSDF(vec3 p) {\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n\n    return (-p.y+20.0-heightmap(p.xz))*.01/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    vec3 p1 = p;\n    p /= 100.0;\n    //p1.y *= 1000.0;\n    return vec3(heightmap(p.xz*100.0)+1.0)/20.0 + vec3(.0,.6-p.y,.5+p1.y);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(3.14*0.666);\n    float speed = 2.0;\n    float t1 = speed*iTime+5.0;\n\tvec3 eye = vec3(-t1,-10,-t1*2.0);\n    eye.y -= 20.0;\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(0,5,1), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 517, 517, 868], [870, 870, 894, 956, 1007], [1009, 1009, 1037, 1037, 1169], [1172, 1593, 1684, 1684, 1990], [2005, 2259, 2324, 2324, 2456], [2458, 2547, 2576, 2576, 2886], [2888, 3380, 3520, 3520, 4130], [4132, 4502, 4587, 4587, 5002], [5004, 5331, 5380, 5415, 5546], [5548, 5548, 5605, 5605, 6587]], "test": "untested"}
{"id": "WdGcDy", "name": "Volcanic landscape", "author": "jarble", "description": "Is it a lava flow, or is it a storm on Jupiter?", "tags": ["fractal", "lava"], "likes": 4, "viewed": 492, "published": 3, "date": "1603588565", "time_retrieved": "2024-07-30T20:38:17.814835", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 col;\n\tfloat t = iTime*.1;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t,t*2.0);\n    float factor = 1.5;\n    vec2 v1;\n    for(int i=0;i<12;i++)\n    {\n        uv *= -factor*factor;\n        v1 = uv.yx/factor;\n        uv += sin(v1+col)/factor;\n        col += vec2(sin(uv.x-uv.y+v1.y-col.y),sin(uv.y-uv.x+v1.x-col.x));\n    }\n    fragColor = vec4(vec3(col.x+4.0,col.x-col.y/2.0,col.x/5.0)/4.0,1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    //t *= 1 + ((t/4096)%2);\n    t = (t>>(t/((t/4096)%5+(t/4096)%3)))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 477]], "test": "untested"}
{"id": "WdGyWy", "name": "Plots", "author": "thepheer", "description": "Experimenting: plots with constant line thickness.", "tags": ["sdf", "derivatives", "plots"], "likes": 6, "viewed": 424, "published": 3, "date": "1603580184", "time_retrieved": "2024-07-30T20:38:18.597742", "image_code": "vec3 f(float x) {\n\tconst float pi = radians(180.0);\n    vec3 t = vec3(-1.0, 0.0, 1.0)/6.0 + 6.0*cos(pi*x) + iTime;\n    return 0.5 + x*(1.0 - x)*sin(pi*t);\n}\n\nvec3 f(vec2 xy) {\n    return f(xy.x) - xy.y;\n}\n\nvec3 sdf(vec2 xy, float px) {\n    return f(xy)/px;\n}\n\nvec3 sdf(vec2 xy, vec2 px) {\n    vec3 e = vec3(0.5*px, 0.0);\n    vec3 x = f(xy + e.xz) - f(xy - e.xz);\n    vec3 y = f(xy + e.zy) - f(xy - e.zy);\n    return f(xy)/sqrt(x*x + y*y);\n}\n\nvec3 sdf(vec2 xy) {\n    vec3 d = f(xy);\n    vec3 x = dFdx(d);\n    vec3 y = dFdy(d);\n    return d/sqrt(x*x + y*y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = px*fragCoord;\n    vec3 dist = mix(sdf(uv, px.y), sdf(uv, px), step(0.5, uv.x));\n    vec3 plot = smoothstep(2.0, 0.0, abs(dist));\n    float line = smoothstep(1.0, 0.0, abs(0.5 - uv.x)/px.x);\n    fragColor = vec4(sRGB_OETF(plot + line), 1.0);\n}", "image_inputs": [], "common_code": "vec3 sRGB_OETF(vec3 c) {\n    vec3 a = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 156], [158, 158, 175, 175, 204], [206, 206, 235, 235, 258], [260, 260, 288, 288, 440], [442, 442, 461, 461, 557], [559, 559, 614, 614, 905]], "test": "untested"}
{"id": "3sGyDy", "name": "Yoda fractal", "author": "jarble", "description": "By chance, I managed to find Yoda in one of my \"lava fractals.\"", "tags": ["fractal", "lava"], "likes": 4, "viewed": 402, "published": 3, "date": "1603578813", "time_retrieved": "2024-07-30T20:38:19.440489", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 col;\n    float t = .5;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    uv /= 5.0+sin(iTime);\n    uv += vec2(t*-1.0,t*1.65);\n    float factor = 1.5;\n    vec2 v1;\n    for(int i=0;i<12;i++)\n    {\n        uv *= -factor*factor;\n        v1 = uv.yx/factor;\n        uv += sin(v1+col)/factor;\n        col += vec2(sin(uv.x-uv.y+v1.y-col.y),sin(uv.y-uv.x+v1.x-col.x));\n        factor -= .05;\n    }\n    fragColor = vec4(vec3(col.x+4.0,col.x-col.y/2.0,col.x/5.0)/4.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 540]], "test": "untested"}
{"id": "wdVczd", "name": "first shader, hello circle", "author": "aylictal", "description": "i guess if theres a hello world for this, this is the type.", "tags": ["circle", "colorchange", "blurchange"], "likes": 2, "viewed": 347, "published": 3, "date": "1603560332", "time_retrieved": "2024-07-30T20:38:20.327118", "image_code": "float circle(vec2 uv, vec2 pos, float radius, float blur){\n    \n    float d = length(uv-pos);\n    float c = smoothstep(radius, radius-blur, d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat t = iTime;\n    \n    uv -= .5; // converts range from 0=>1 to -.5=>.5\n    uv.x *= iResolution.x/iResolution.y; //convert aspect ratio to viewing display\n\tfloat blur = abs(sin(t));\n    //normalized cartesian coordinates where 0 is center of screen, range -1.0 => 1.0\n    vec2 pos = vec2(0.0, 0.0);\n    float mask = circle(uv, pos, .5, blur);\n    vec3 color = vec3(sin(t), cos(t), atan(t)) * mask;\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 159], [161, 161, 217, 267, 774]], "test": "untested"}
{"id": "3sGyzd", "name": "Pumpkin Patch", "author": "PixelPhil", "description": "Here is something spooky for Halloween.\nUse the mouse to look around.\nI hope this brings you joy.\n\nMusic : This is Halloween - JackG 90bpm remix", "tags": ["ray", "marching", "iq", "halloween", "spooky", "pumpkin"], "likes": 22, "viewed": 1038, "published": 3, "date": "1603553475", "time_retrieved": "2024-07-30T20:38:21.250649", "image_code": "//\n// Pumpkin Patch by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_DST 200.0\n#define MIN_DST 0.008\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n//Material regions\n#define PUMPKIN_DARK \t0.0\n#define PUMPKIN \t\t1.0\n#define PUMPKIN_INSIDE\t2.0\n#define GROUND_AO\t\t3.0\n#define GROUND\t\t\t4.0\n#define STEM\t\t\t5.0\n\n//#define MODELING\n\nfloat speechHeight = 0.0;\nfloat beat = 0.0;\n\n\n// Attributes of a PBR material\nstruct PBRMat\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n};\n\n    \nfloat spacing = 9.0;\nfloat offsetMax = 3.5;\n\n// Computes a PBR Material from material ID and world position\nvoid GetColor(float id, vec3 pos, out PBRMat mat, vec2 pumpkinCenter)\n{   \n\n\n    \n    vec3 orange = vec3(0.8, 0.3, 0.01);\n    vec3 orangeDark = vec3(0.5, 0.01, 0.01);\n    vec3 yellow = vec3(0.8, 0.8, 0.0);\n    \n    vec3 stem = vec3(0.15, 0.65, 0.02);\n    vec3 stemDark = vec3(0.05, 0.15, 0.05);\n    \n    if (id <= PUMPKIN)\n    {\n        mat = PBRMat(mix(orange, orangeDark, id), 0.15 * id, id);\n    } \n    else if (id <= GROUND)\n    {\n        \n    \n        float len = length(pos.xz - pumpkinCenter);\n\t\tfloat ao = 0.6 + 0.4 * S(0.5, 3.0, len);\n\n   \n        float noise2 = VoroNoise(pos.xz * 4.0, 1.0, 1.0);\n        vec2 band = S(vec2(0.26), vec2(0.25), abs(fract(pos.xz * 0.07 + vec2(noise2 * 0.05)) - vec2(0.5))); \n        \n        \n        mat = PBRMat(mix( vec3(0.4, 0.01, 0.4), vec3(0.3, 0.01, 0.3), band.y) * ao, 0.05, 1.0);\n    }  \n    else\n    {\n        float ratio = id - STEM;\n        \n        mat = PBRMat(mix(stemDark, stem, ratio), 0.06, 1.0);\n    }  \n  \n    return;\n}\n\n\n\nvec2 SDFPumpkin(vec3 pos, vec4 rnd)\n{  \n\n    float proxy = length(pos - vec3(0.0, 1.2, 0.0));\n    \n    if (proxy > 4.0)\n    {\n    \treturn vec2(proxy - 3.0, 0.0);\n    }\n    else   \n    {\n        \n        pos = (rotationY(rnd.z * 360.0) * vec4(pos, 1.0)).xyz;\n        \n        float bounce = sin(iTime * 10.0 + (rnd.x + rnd.a) * 234.4) * beat;\n        \n        float scX = rnd.x * 0.4 + 1.0 + bounce * 0.05;\n        float scY = rnd.w * 0.4 + 1.0 - bounce * 0.1;\n        \n        pos *= vec3(scX, scY, scX);\n        \n        pos.y -= 1.25;\n        \n    \n        \n        float angle = atan(pos.x, pos.z);\n\n\n        float section = smax(0.05, abs(sin(angle * 4.0)), 0.05) * 0.1;\n\n        float longLen = length(pos.xz);\n\n        float pinch = S(1.4, -0.2, longLen);\n\n        float pumpkin = sdEllipsoid(pos, vec3(1.7, 1.5, 1.7)) + pinch * 0.6;\n        \n        float pumpkinDisplace =  ((sin(angle * 25.0) + sin(angle * 43.0)) * 0.0015 - section) * S(0.2, 1.3, longLen);\n\n        pumpkin +=   pumpkinDisplace;\n\n        //pumpkin *= mix(1.0, 0.5, pinch);\n\n        float stem = longLen - 0.29 + S(1.1, 1.5, pos.y) * 0.15 + sin(angle * 4.0) * 0.01;\n        \n        float stemDisplace = sin(angle * 10.0);\n        \n        stem += stemDisplace * 0.005;\n\n        stem -= (pos.y - 1.2) * 0.1;\n        \n        stem *= 0.8;\n        \n        float stemCut =  pos.y - 1.6 + pos.x * 0.3;\n\n        stem = smax(stem, stemCut, 0.05);\n\n        stem = max(stem, 1.0 - pos.y);\n\n\n        float pumpkinID = clamp(pumpkinDisplace * 4.0 + 0.5, 0.0, 0.999);//, PUMPKIN_INSIDE, S(0.03, -0.05, pumpkin));\n        \n\t    float stemID = STEM + (0.5 + stemDisplace * 0.2) * S(0.1, -0.6, stemCut);\n        \n        \n        pumpkin = abs(pumpkin) - 0.05;\n\n        float face = length(pos.xy - vec2(0.0, 0.3)) - 1.1;\n        face = max(face, -(length(pos.xy - vec2(0.0, 1.8)) - 2.0));\n        \n        float teeth = abs(pos.x - 0.4) - 0.16;\n        teeth = smax(teeth, -0.45 - pos.y + pos.x * 0.1, 0.07);\n        \n        float teeth2 = abs(pos.x + 0.40) - 0.16;\n        teeth2 = smax(teeth2, 0.5 + pos.y + pos.x * 0.05, 0.07);\n        \n        \n        face = smax(face, -min(teeth, teeth2), 0.07);\n\n        vec2 symPos = pos.xy;\n        symPos.x = abs(symPos.x);\n\n        float nose = -pos.y + 0.1;\n        nose = max(nose, symPos.x - 0.25 + symPos.y* 0.5);\n\n        float eyes = -pos.y + 0.48 - symPos.x * 0.17;\n        eyes = max(eyes, symPos.x - 1.0 + symPos.y * 0.5);\n        eyes = max(eyes, -symPos.x - 0.05 + symPos.y * 0.5);\n\n\n        face = min(face, nose);\n        face = min(face, eyes);\n\n        face = max(face, pos.z);\n\n        pumpkin = smax(pumpkin, -face, 0.03);\n        \n        \n\n\n        pumpkin *= 0.9 / max(scX, scY);\n\n        vec2 res = vec2(pumpkin, pumpkinID);\n\t\tres = combineMin(res, vec2(stem, stemID));\n\n        return res;\n    }\n}\n\nfloat groundHeight(vec2 xz, bool detailed)\n{\n    float h = sin(xz.x * 0.05) * 4.0;\n    h += sin(xz.y * 0.05) * 4.0;\n    \n    h += sin(xz.y * 0.1 + xz.x * 0.2) * 0.5;\n    \n    h += sin(xz.y * 0.15 + xz.x * 0.3) * 0.3;\n   \n    \n    return h;\n}\n\nvec2 SDFPumpkinCell(vec3 pos, vec2 cellId)\n{   \n\t\n    \n    vec4 rnd = N24(cellId);\n    \n    vec2 offsetXZ = (rnd.xy - vec2(0.5)) * offsetMax;\n    \n    float ground0 = groundHeight((cellId + vec2(0.5)) * spacing + offsetXZ, false);\n    \n    vec2 pumpkin = SDFPumpkin(pos - vec3(offsetXZ.x, ground0, offsetXZ.y), rnd);\n    \n   \n    \n \n\n    return pumpkin;\n}\n\n// SDF of the scene\nvec2 SDF(vec3 pos, bool precise)\n{   \n    \n#ifdef MODELING\n    vec2 pumpkin =  SDFPumpkinCell(pos, vec2(0.0));\n#else\n\n    vec2 posxz = pos.xz / spacing;\n    \n    vec2 cellId = floor(posxz);\n    \n    \n    vec2 cellXZ = (fract(posxz) - vec2(0.5)) * spacing;\n\n    vec3 cellPos = vec3(cellXZ.x, pos.y, cellXZ.y);\n    \n    \n    // Make sure the pumpkin sits on flat ground\n    vec4 rnd = N24(cellId);\n    vec2 offsetXZ = (rnd.xy - vec2(0.5)) * offsetMax;\n    vec2 centerPumpkin = (cellId + vec2(0.5)) * spacing + offsetXZ;\n    float len = length(centerPumpkin.xy - pos.xz);\n    float ground0 = groundHeight(centerPumpkin , true);\n    float gound = pos.y - mix(ground0, groundHeight(pos.xz, true), S(1.0, 3.0, len));\n    \n    vec2 res = vec2(gound, GROUND);\n    \n    if (precise)\n    {\n        for (float z = -1.0; z <= 1.0; z++)\n        {\n            for (float x = -1.0; x <= 1.0; x++)\n            {\n\n                res = combineMin(res, SDFPumpkinCell(cellPos - vec3(x * spacing, 0.0,z * spacing), \n                                                     cellId + vec2(x, z)));\n            }\n        }\n    \t \n    }\n    else\n    {\n        res = combineMin(res, SDFPumpkinCell(cellPos, cellId));\n    }\n#endif\n    \n\n    \n    return res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, false).x;\n    }\n    return normalize(n);\n}\n\n// inspired by\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 pos, vec3 lPos)\n{   \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += dir * MIN_DST * 2.0;  // Get out of the surface\n    \n    float dst = SDF(pos, false).x; // Get the SDF\n    \n    // Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst < MIN_DST) return 0.0; \n        obscurance = min(obscurance, (20.0 * dst / t)); \n        t += dst;\n        pos += dst * dir;\n        dst = SDF(pos, false).x;\n    }\n    return obscurance;     \n}\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos)\n{\n    return shadow(p + n * MIN_DST * 10.0, lPos);\n}\n\n// Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst)\n{\n    vec2 dst = vec2(minDst * 2.0, 0.0);\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, true);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\nvec3 cookie(vec3 camPos, vec3 camDir, vec3 cookiePos, float radius, vec3 color)\n{\n    return vec3(0.0);\n}\n\n\n// A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float fresnel, bool shadows, float range)\n{\n    //Basic lambert shading stuff\n    \n    //return vec3(fresnel);\n    \n    vec3 key_Dir = lightPos - pos;\n    \n    float key_len = length(key_Dir);\n    \n    float atten = key_len / range;\n    atten = 1.0 - atten * atten;\n    if (atten < 0.0) return vec3(0.0);\n\n    \n    key_Dir /= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir));\n    \n     \n    float key_shadow = shadows ? S(0.0, 0.10, shadow(pos, normal, lightPos)) : 1.0; \n    \n    float diffuseRatio = key_lambert * key_shadow;\n   \n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n\n    // The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    // metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo, mat.metalness);\n    \n    vec3 col = mat.albedo * key_diffuse * (1.0 - mat.metalness);\n    \n    // Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    // Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n\n    \n    return col * atten;\n}\n\nvec4 render(vec2 uvs)\n{\n\n#ifdef MODELING\n    vec3 camPos = vec3(0.0, 2.0, -10);\n    vec3 camDir = vec3(0.0, 0.0,  1.0);\n#else\n    \n    float z = iTime * 4.0 - 38.0;\n    \n    float y = groundHeight(vec2(0.0, z), false);\n    float yNext = groundHeight(vec2(0.0, z + 1.3), false);\n    \n    // build camera ray\n    vec3 camPos = vec3(0.0, 2.0 + y, z);\n    vec3 camDir = normalize(vec3(0.0, (yNext - y) * 0.3,  1.0));\n#endif\n    \n\n    vec3 rayDir = camDir + vec3(uvs * 0.45, 0.0);\n    \n    \n//    vec3 key_LightPos = camPos + vec3(6.0, 10.0, -5.0);  \n    \n    vec3 key_LightPos = camPos + vec3(6.0, 2.0, 5.0);\n    \t//vec3 fill_LightPos =  (modelViewMat * vec4(-15.0, -7.0, 10.0, 0.0)).xyz;\n\n\t// mouse interaction\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    if(mouse.x<.001) mouse = vec2(0.5, 0.5);\n\n    vec2 viewAngle = vec2((-mouse.x - 0.35 ) * pi2, (mouse.y - 0.54) * pi2);\n\n\n\n\t// then the viwe matrix\n    mat4 viewMat =  rotationY(viewAngle.x) * rotationX(viewAngle.y);\n\n\t// transform the ray in object space\n    rayDir = (viewMat * vec4(rayDir, 0.0)).xyz;\n\n    \n\tvec2 d = castRay(camPos, rayDir, MAX_DST, MIN_DST);\n    \n    vec3 bg = vec3(0.0, 0.0, 0.2);\n    bg.r += S( 0.25, 0.0, rayDir.y);\n    bg.g += S( 0.16, -0.1, rayDir.y);\n    \n    vec3 col;\n    \n    if (d.x < MAX_DST)\n    {\n        // if it's a hit render the face\n        \n    \tvec3 pos = camPos + rayDir * d.x;\n \t\n    \tvec3 n;\n        \n        vec2 cellId = floor(pos.xz / spacing);\n        vec4 rnd = N24(cellId);\n        vec2 offsetXZ = (rnd.xy - vec2(0.5)) * offsetMax;\n        vec2 pumpkinCenter = (cellId + vec2(0.5)) * spacing + offsetXZ;\n\n        // compute the surface material\n    \tPBRMat mat;\n    \tGetColor(d.y, pos, mat, pumpkinCenter);\n    \t\n    \tmat.albedo *= mat.albedo; // Convert albedo to linear space\n    \t\n    \tn = calcNormal(pos);\n\n    \tcol = mat.albedo * 0.2;\n    \t\n    \t// Fresnel\n    \tfloat fresnel = 1.0 - sat(dot(n, -rayDir));\n\t\n\t\n        // transform lights to object space\n        vec3 innerLight = vec3(pumpkinCenter.x, groundHeight(pumpkinCenter.xy, false)  + 1.34 ,pumpkinCenter.y);\n    \n        //innerLight += sin(vec3(iTime * fract(pumpkinCenter.xyx * vec3(45.0, 35.0,12.0))) * 10.0) * 0.05;\n        \n        // Add lighting\n    \tcol += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(1.3), fresnel, true, 120.0);\n\n        // Light from inside the pumpkin\n        //float dst = length(pumpkinCenter.xy - pos.xz) * 0.25;\n        //float lightAtten = max(0.0, (1.0 - dst * dst));\n    \tcol += PBRLight(pos, n, rayDir, mat, innerLight, vec3(8.0), fresnel, true, 4.5);// * lightAtten;\n\t\n \t\t//col *= S(0.0, 0.1, ao) * 0.5 + 0.5; // blend AO to unflatten a bit\n        \n      \tcol = mix(col, vec3(1.0), S(0.0, -20.3,pos.y));\n    \t\n    \tcol = pow(col,vec3(0.4545)); // gamma correction\n        \n        col = mix(col, bg, S(100.0, MAX_DST,d.x));\n        \n    \treturn vec4(col, 0.0);\n    }\n    \n    \n    // Background\n \tcol = bg;\n\n  \n    return vec4(col, 0.0);\n}\n\n// Classic stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    \n\n    \n    float a = textureLod(iChannel0, vec2(0.0, 0.5), 0.0).r;\n    float b = textureLod(iChannel0, vec2(0.01, 0.5), 0.0).r;\n    float c = textureLod(iChannel0, vec2(0.5, 1.0), 0.0).r;\n    \n    speechHeight =  abs(a - b);\n    beat = max(0.0, a + b + c - 1.0) * 0.5;\n    \n    vec3 res = render(uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}", "image_inputs": [{"id": 24205, "src": "https://soundcloud.com/iamjackg/this-is-halloween-6", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n#define degToRad (pi / 180.0)\n\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat3 rotationX3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3(1.0, 0,\t 0,\n\t\t\t \t0, \t c,\t-s,\n\t\t\t\t0, \t s,\t c);\n}\n\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat3 rotationY3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3( c, 0,\t s,\n\t\t\t \t 0,\t1.0, 0,\n\t\t\t\t-s,\t0,\t c);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\n\n// Adapted from BigWIngs\nvec4 N24(vec2 t) {\n    float n = mod(t.x * 458.0 + t.y * 127.3, 100.0);\n\treturn fract(sin(n*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoidPrecise( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    return (k1-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// https://iquilezles.org/articles/voronoise\nfloat VoroNoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyzd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[700, 763, 834, 834, 1743], [1747, 1747, 1784, 1784, 4576], [4578, 4578, 4622, 4622, 4819], [4821, 4821, 4865, 4865, 5176], [5178, 5198, 5232, 5232, 6428], [6431, 6477, 6505, 6603, 6821], [6823, 6883, 6918, 6918, 7496], [7498, 7498, 7539, 7539, 7590], [7592, 7656, 7718, 7718, 7960], [7962, 7962, 8043, 8043, 8067], [8070, 8098, 8233, 8300, 9560], [9562, 9562, 9585, 9585, 12512], [12514, 12531, 12588, 12588, 13029]], "test": "untested"}
{"id": "WdVyRd", "name": "Balls on a rope", "author": "xjorma", "description": "Remake of an old Atari ST Demoscene Effect by Elric/Holocaust\nhttps://youtu.be/X3f5e8cIDT8?t=706\nMusic by Jess", "tags": ["demoscene", "amiga", "demo", "ball", "atari", "rope", "reproduction", "cineshader"], "likes": 40, "viewed": 10280, "published": 3, "date": "1603513319", "time_retrieved": "2024-07-30T20:38:22.038542", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst int\tnbBall = 8;\nconst float ballRadius = 0.07;\nconst float maxLateralSpeed = 1.;\nconst float Tau = radians(360.);\nconst float minPhaseSpeed = 2.1;\nconst float maxPhaseSpeed = 3.2;\nconst float sinAmplitude = 1.2;\nconst vec3\tdrawColor = vec3(0.2,0.3,0.4);\n\n// Hash without Sine, https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat triangleSignal(float x, float f)\n{\n    f = 1. / f;\n    return (abs((f * x - 4. * floor(0.25 * f * x)) - 2.) - 1.) / f;\n}\n\nfloat smoothFilter(float d)\n{\n    float v = 2. / iResolution.y;\n    return smoothstep(v, -v, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\tratio = iResolution.x / iResolution.y;\n    vec3\tcol = vec3(0);\n    \n    // Compute and draw balls\n    vec2\tballArray[nbBall + 1];\n    for(int i = 0; i < nbBall; ++i)\n    {\n        float LateralSpeed = (hash11(float(i) * 1.2544) - 0.5) * 2. * maxLateralSpeed;\n        float phaseOffset = hash11(float(i) * 1.4482) * Tau;\n        float LateralOffset = hash11(float(i) * 1.9528) * (ratio * 2. - 2. * ballRadius);\n        float phaseSpeed = mix(minPhaseSpeed, maxPhaseSpeed, hash11(float(i) * 1.1273));\n        ballArray[i] = vec2(\ttriangleSignal(LateralOffset + LateralSpeed * iTime, ratio - ballRadius),\n                       \t\t\tsinAmplitude * (abs(sin(phaseOffset + phaseSpeed * iTime)) - 0.5) \n                           );\n        float a = smoothFilter(sdCircle( ballArray[i] - p , ballRadius));\n        col = mix(col, drawColor, a);           \n    }\n    \n    // Sort Ball in X (Lame bubble)\n    for(int i = 0; i < nbBall - 1; ++i)\n    {\n\t    for(int j = 0; j < nbBall - 1 - i; ++j)\n        {\n            if(ballArray[j].x > ballArray[j + 1].x)\n            {\n                vec2 tmp = ballArray[j + 1];\n                ballArray[j + 1] = ballArray[j];\n                ballArray[j] = tmp;\n            }\n        }\n    }\n    \n   \t// Find convex using an algorithm similar to gift wraping\n \tballArray[nbBall] = vec2(ratio, 0);\n    int   convexSize = 0;\n    vec2  convexHull[nbBall + 2];\n    convexHull[convexSize++] = vec2(-ratio, 0);\n    int\t  SmallestIndex = 0;\n    for(;;)\n    {\n        float SmallestDir = 1.;\n        bool  found = false;\n        for(int i = SmallestIndex; i < nbBall + 1; ++i)\n        {\n            vec2 dir = normalize(ballArray[i] - convexHull[convexSize - 1]);\n            if(dir.y < SmallestDir)\n            {\n                \n                SmallestDir = dir.y;\n                SmallestIndex = i;\n                found = true;\n            }\n        }\n       \tif(found)\n        {\n            convexHull[convexSize++] = ballArray[SmallestIndex];\n        }\n        else\n        {\n            break;\n        }\n    }\n      \n        \n    // Draw hull\n    for(int i = 0; i < convexSize - 1; ++i)\n    {\n\t    float a = smoothFilter(udSegment(p, convexHull[i] - vec2(0, ballRadius), convexHull[i + 1] - vec2(0, ballRadius)) - 0.005);\n        col = mix(col, drawColor, a);\n          \n    }\n\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24193, "src": "https://soundcloud.com/david-gallardo-492062428/atari-demo-music-by-jess-overlander", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyRd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[374, 434, 457, 457, 542], [544, 544, 579, 579, 607], [609, 609, 661, 661, 784], [786, 786, 826, 826, 912], [914, 914, 943, 943, 1012], [1014, 1014, 1071, 1071, 3509]], "test": "untested"}
{"id": "3dVyzt", "name": "Cocktail Shaker", "author": "xjorma", "description": "Cocktail Shaker\nFuild simulation with color blending. Based on Muller's SPH.", "tags": ["2d", "fluid", "particles", "physics", "sph", "cocktail", "shaker"], "likes": 31, "viewed": 1069, "published": 3, "date": "1603500826", "time_retrieved": "2024-07-30T20:38:22.982019", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define SMOOTH\t1\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nfloat smoothFilter(float d)\n{\n    float v = 3000. / iResolution.y;\n    return smoothstep(0., -v, d);\n}\n\nconst float k = 0.1;\nconst float maxDistBlend = KernelRadius * 4.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    p *= 1000.;\n    vec3 col = vec3(0);\n    \n    float t = float(iFrame) * 1. / 60.;\n    col = mix(col, vec3(1,0,0), smoothFilter(map(p, t)));\n   \n    #if SMOOTH \n        float sminAcc = 0.;\n    \tfloat colorWeightSum = 0.;\n    \tvec3  colorSum = vec3(0);\n        for(int i = 0; i < PartNum; i++)\n        {\n            vec2 pp = Load(i, CompPosition).xy;\n            vec2 vp = p - pp;\n            sminAcc += exp2(-k *sdCircle( vp, KernelRadius ));\n            float d2 = dot(vp, vp);\n            if(d2 < maxDistBlend * maxDistBlend)\n            {\n                float colorWeight = max( pow(maxDistBlend - sqrt(d2), 3.), 0.);\n                colorWeightSum += colorWeight;\n                colorSum += colorWeight * Load(i, CompColor).xyz;\n            }\n        }\n        float d = -log2( sminAcc ) / k;\n        if(d < 0.)\n        {\n            col = mix(col, colorSum / colorWeightSum, smoothFilter(d));\n        }\n    #else //SMOOTH\n    {\n        for(int i = 0; i < PartNum; i++)\n        {\n            vec2 pp = Load(i, CompPosition).xy;\n            if(distance(p, pp) < KernelRadius)\n            {\n                col = Load(i, CompColor).xyz;\n            }\n        }        \n    }\n    #endif //SMOOTH\n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst int PartNum\t\t= 512;\nconst int MaxCompPerRow\t= 256;\nconst float DeltaTime   = 0.0008;\nconst float Pi \t\t\t= radians(180.);\n\n\nconst vec2  ExtForce = vec2(0, 12000.*-9.8);\nconst float RestDensity = 1000.;\nconst float GasConst = 2000.;\nconst float KernelRadius = 16.;\nconst float PartMass = 65.;\nconst float Viscosity = 250.;\nconst float ColRestitution = 0.20;\nconst float Poly6 = 315./(65.*Pi*pow(KernelRadius, 9.));\nconst float SpikyGrad = -45./(Pi*pow(KernelRadius, 6.));\nconst float ViscLap = 45./(Pi*pow(KernelRadius, 6.));\n\n\n\nconst int CompPosition\t= 0;\nconst int CompColor\t\t= 1;\nconst int CompVelocity\t= 2;\nconst int CompDensity\t= 3;\nconst int CompPresure\t= 4;\nconst int CompNum\t\t= 5;\n\n\nconst float Phi \t\t=  (sqrt(5.)*0.5 + 0.5);\n\n\n// https://iquilezles.org/articles/distfunctions2d\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rotate(in vec2 v, in float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2  m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nfloat map(in vec2 p, in float t)\n{\n    //p = rotate(p, 0.5);\n    p = rotate(p, sin(t * 0.8) * 0.8);\n    return sdStar5(p, 1.2 * 800., 0.6 ) - 0.1 * 800.;\n    //return sdBox(p, vec2(1.2 * 800., 1.2 * 400.) ) - 0.1 * 800.;\n}\n\nvec2 normal( in vec2 p, in float t) // for function f(p)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec2(map(p + h.xy, t) - map(p - h.xy, t),\n                           map(p + h.yx, t) - map(p - h.yx, t)));\n}\n\nbool reset(int frame)\n{\n    return (frame % (60*16)) < 2; \n}\n\n\n", "buffer_a_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute density & pressure Pass 2\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n    vec3\tc;\n\n\tbool reset = reset(iFrame);\n\n    if(reset)\n    {\n        float\tside = float(pixId & 1);\n        vec2\toff = vec2( (side - 0.5) * 2. * 500., 0);\n        int \tspawnId = pixId >> 1;\n        x = ((vec2(spawnId & 15, spawnId >> 4)) - 4.) * 16. - vec2(0, 400.) + off;\n        v = vec2(1);\n        c = mix(vec3(0,1,0), vec3(0,0,1), side);\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n        c \t= Load(pixId, CompColor).xyz;\n    }\n    \n    // SPH Compute density & pressure\n    \n    float rho = 0.f;\n    float colorWeightSum = 0.;\n    vec3  colorSum = vec3(0);    \n    for(int i = 0; i < PartNum; i++)\n    {\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r2 = dot(rij, rij);\n\n        if(r2 < KernelRadius * KernelRadius)\n        {\n            // compute density\n            rho += PartMass * Poly6 * pow(KernelRadius * KernelRadius - r2, 3.);\n            // color\n            float colorWeight = max( KernelRadius - sqrt(r2), 0.);\n            colorWeightSum += colorWeight;\n            colorSum += colorWeight * Load(i, CompColor).xyz;\n        }\n    }\n    // Presure\n    float p = GasConst*(rho - RestDensity);\n    // color\n    if(!reset)\n    {\n        vec3 proximityColor = colorSum / colorWeightSum;\n        c = mix(c, proximityColor, 0.1);\n    }\n     \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(c, 0), CompColor, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute forces, integration + collision pass1\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec3\tc;\n    vec2\tv;\n    float\trho;\n    float\tp;\n\n    x\t= Load(pixId, CompPosition).xy;\n    c\t= Load(pixId, CompColor).xyz;\n    v\t= Load(pixId, CompVelocity).xy;\n    rho\t= Load(pixId, CompDensity).x;\n    p\t= Load(pixId, CompPresure).x;\n\n    // SPH Compute forces\n    \n\tvec2 f = ExtForce * rho;\n    \n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i == pixId)\n            continue;\n\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r = length(rij);\n\n        if(r < KernelRadius)\n        {\n            float partDensity = Load(i, CompDensity).x;\n            // pressureForce\n            f += normalize(-rij) * PartMass * (p + Load(i, CompPresure).x) / (2. * partDensity) * SpikyGrad * pow(KernelRadius-r, 2.);\n \t\t\t// viscosityForce\n            f += Viscosity * PartMass * (Load(i, CompVelocity).xy - v) / partDensity * ViscLap * (KernelRadius - r);\n        }\n    }\n    \n    if(!reset(iFrame))\n    {\n        // SPH Integration\n        v += DeltaTime * f / rho;\n        x += DeltaTime * v;\n    }\n\n    // enforce constraints\n    float t = float(iFrame) * 1. / 60.;\n    float d = map(x, t) + KernelRadius;\n    vec2  n = normal(x, t);\n    if(d > 0.)\n    {\n        x += -d * n;\n        v = reflect(v, n);\n        d = dot(v, n);\n        v -= n * d * ColRestitution;\n    }   \n    \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(c, 0), CompColor, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute density & pressure Pass 2\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n    vec3\tc;\n\n\tbool reset = reset(iFrame);\n\n    if(reset)\n    {\n        float\tside = float(pixId & 1);\n        vec2\toff = vec2( (side - 0.5) * 2. * 500., 0);\n        int \tspawnId = pixId >> 1;\n        x = ((vec2(spawnId & 15, spawnId >> 4)) - 4.) * 16. - vec2(0, 400.) + off;\n        v = vec2(1);\n        c = mix(vec3(0,1,0), vec3(0,0,1), side);\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n        c \t= Load(pixId, CompColor).xyz;\n    }\n    \n    // SPH Compute density & pressure\n    \n    float rho = 0.;\n    float colorWeightSum = 0.;\n    vec3  colorSum = vec3(0);    \n    for(int i = 0; i < PartNum; i++)\n    {\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r2 = dot(rij, rij);\n\n        if(r2 < KernelRadius * KernelRadius)\n        {\n            // compute density\n            rho += PartMass * Poly6 * pow(KernelRadius * KernelRadius - r2, 3.);\n            // color\n            float colorWeight = max( KernelRadius - sqrt(r2), 0.);\n            colorWeightSum += colorWeight;\n            colorSum += colorWeight * Load(i, CompColor).xyz;\n        }\n    }\n    // Presure\n    float p = GasConst*(rho - RestDensity);\n    // color\n    if(!reset)\n    {\n        vec3 proximityColor = colorSum / colorWeightSum;\n        c = mix(c, proximityColor, 0.1);\n    }\n     \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(c, 0), CompColor, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute forces, integration + collision pass 2\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec3\tc;\n    vec2\tv;\n    float\trho;\n    float\tp;\n\n    x\t= Load(pixId, CompPosition).xy;\n    c\t= Load(pixId, CompColor).xyz;\n    v\t= Load(pixId, CompVelocity).xy;\n    rho\t= Load(pixId, CompDensity).x;\n    p\t= Load(pixId, CompPresure).x;\n\n    // SPH Compute forces\n    \n\tvec2 f = ExtForce * rho;\n    \n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i == pixId)\n            continue;\n\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r = length(rij);\n\n        if(r < KernelRadius)\n        {\n            float partDensity = Load(i, CompDensity).x;\n            // pressureForce\n            f += normalize(-rij) * PartMass * (p + Load(i, CompPresure).x) / (2. * partDensity) * SpikyGrad * pow(KernelRadius-r, 2.);\n \t\t\t// viscosityForce\n            f += Viscosity * PartMass * (Load(i, CompVelocity).xy - v) / partDensity * ViscLap * (KernelRadius - r);\n        }\n    }\n    \n    if(!reset(iFrame))\n    {\n        // SPH Integration\n        v += DeltaTime * f / rho;\n        x += DeltaTime * v;\n    }\n   \n    // enforce constraints\n    float t = float(iFrame) * 1. / 60.;\n    float d = map(x, t) + KernelRadius;\n    vec2  n = normal(x, t);\n    if(d > 0.)\n    {\n        x += -d * n;\n        v = reflect(v, n);\n        d = dot(v, n);\n        v -= n * d * ColRestitution;\n    }   \n    \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(c, 0), CompColor, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyzt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[132, 132, 167, 167, 287], [289, 289, 318, 318, 391], [461, 461, 518, 518, 1841]], "test": "untested"}
{"id": "WsKczt", "name": "Equal Relative Luminance plane..", "author": "hanfling", "description": "..in sRGB colorspace.", "tags": ["luminance", "srgb", "colorscience", "relativeluminance"], "likes": 3, "viewed": 415, "published": 3, "date": "1603499339", "time_retrieved": "2024-07-30T20:38:23.747971", "image_code": "\n// Configuration.\nconst bool  bAnimateRelativeLuminancePlane = true;  // Set to true automatically modulate relative luminance input.\nconst float AnimationAngularFrequency      = 0.3;   // Angular frequency for rl modulation in 1/s.\nconst float StaticRelativeLuminancePlane   = 0.707; // If bAnimatePlane is not set, use this relative lumianance.\nconst float BorderFraction                 = 0.379; // Amount of combined top-bottom or left-right fraction.\n\n// Piecewise gamma transfer functions for sRGB colorspace.\nvec3 GammaCompress_sRGB( vec3 Color )\n{\n\tvec3 Step = step(vec3(0.0031308),Color);\n\treturn (12.92*Color)*(vec3(1.0)-Step) + (1.055*pow(Color,vec3(0.41666))-vec3(0.055))*Step;\n}\n\n\nconst vec3 Rec709RelativeLuminanceWeights = vec3( 0.2126, 0.7152, 0.0722 );\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    float RelativeLuminancePlane;\n\n    if ( bAnimateRelativeLuminancePlane )\n    {\n        // Use the square of the modulation, to make it look a little more brightness uniform over time.\n    \tRelativeLuminancePlane = pow( 0.5+0.5*cos(AnimationAngularFrequency*iTime), 2.0 );\n    }\n    else // !bAnimateRelativeLuminancePlane\n    {\n    \tRelativeLuminancePlane = StaticRelativeLuminancePlane;\n    }\n    \n    vec3 LinearFragColor;\n\n    if ( RelativeLuminancePlane<0.0 )\n    {\n        LinearFragColor = vec3(0.0,0.0,1.0); // Blue.\n    }    \n    //else if ( RelativeLuminancePlane<0.001 )\n    //{\n    //    LinearFragColor = vec3(0.0,0.0,0.0); // Black.\n    //}\n    else if ( RelativeLuminancePlane>1.0 )\n    {\n        LinearFragColor = vec3(1.0,0.0,0.0); // Red.\n    }\n    //else if ( RelativeLuminancePlane>0.999 )\n    //{\n    //    LinearFragColor = vec3(1.0,1.0,1.0); // White.\n    //}\n    else // RelativeLuminancePlane in (0,1).\n    {\n        // Start with coloring everything with border/out of gamut color.\n        //LinearFragColor = vec3(RelativeLuminancePlane);\n        \n        // Turns out, the above is really annoying, and that black seems to be preferable.\n        LinearFragColor = vec3(0.0);\n        \n        //vec2 NormalizedFragCoord = 2.0*FragCoord/iResolution.xy-vec2(1.0);\n        vec2 NormalizedFragCoord = 2.0*FragCoord/min(iResolution.x,iResolution.y)-vec2(max(iResolution.x/iResolution.y,1.0),max(iResolution.y/iResolution.x,1.0));\n        \n        //\n        \n        vec2 SquareFragCoords = (NormalizedFragCoord)/(1.0-BorderFraction);\n        \n        //SquareFragCoords = NormalizedFragCoord;\n        \n        if ( SquareFragCoords.x>=-1.0 && SquareFragCoords.x<=1.0 && SquareFragCoords.y>=-1.0 && SquareFragCoords.y<=1.0 )\n        {\n            float Red   = (1.0+SquareFragCoords.y)/2.0;\n            float Blue  = (1.0+SquareFragCoords.x)/2.0;\n\n            float Green = (RelativeLuminancePlane-Red*Rec709RelativeLuminanceWeights.r-Blue*Rec709RelativeLuminanceWeights.b)/Rec709RelativeLuminanceWeights.g;\n\n            // Color is in gamut and we can just display it, otherwise gray background remains.\n            if ( Green>=0.0 && Green<=1.0 )\n            {\n                LinearFragColor = vec3(Red,Green,Blue);\n            }\n        }\n    }\n\n    // Output to screen\n    FragColor.rgb = GammaCompress_sRGB( LinearFragColor );\n    FragColor.a   = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[458, 517, 556, 556, 692], [772, 772, 829, 829, 3214]], "test": "untested"}
{"id": "wdVyR3", "name": "Fab24 #inktober2020 \"dig\"", "author": "FabriceNeyret2", "description": "Mouse control dig position.\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\n\nNot satisfactory look but too long spent on it !", "tags": ["2d", "simulation", "particles", "short", "heap", "inktober2020"], "likes": 6, "viewed": 426, "published": 3, "date": "1603488585", "time_retrieved": "2024-07-30T20:38:24.597700", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( u+u - R ) / R.y;\n    \n    O = T(u);                                                    // load drawing\n    \n    for(int i=1; i<N; i++)                                       // draw moving particles\n        O.rg = max( O.rg, D( T(vec2(i,0)).xy , 1.5 ) * vec2(.8,.4) );\n    \n    O = mix( O, vec4(.5), D( T(0).xy + vec2(0,.1*T(0).z), 4.) ); // draw digger\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(s) fract(sin(vec2(s,u)*mat2(127.1,311.7, 269.5,183.3)) *4e5 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( u+u - R ) / R.y, P, Z=R-R;\n    if (iFrame<1) {                                           // --- init\n        O-=O;\n        if (U.y < -.5) O = vec4(1.+U.y,-.5-U.y,0,1);          // draw ground\n        if (u.y == .5) O = vec4( -R , Z );                    // particles\n        if (u == .5+Z) O = vec4(0,-.45,.5,0);                 // digger\n        return;\n    }    \n    O = T(u);                                                 // restore state\n    \n    if ( u == .5+Z )                                          // --- digger\n            iMouse.z > 0.\n              ? O.xy = ( 2.*iMouse.xy - R ) / R.y, 0.\n              : O.y = max(-.96, O.y - .01/60.),               // digger depth\n            O.z = .5+.5*atan(9.*sin(6.*iTime))/1.46;          // digger hit rythm. see https://www.shadertoy.com/view/Wsyczz\n    else if ( u.y == .5 && int(u.x) < N )                     // --- particle simulation\n    {\n        if ( ( O.zw==Z || O.y < -1. )                         // particle available\n            && H(iTime).x > T(0).z )                          // creation rythm\n            O.xy = T(0).xy,                                   // start position\n            O.zw = H(-iTime), O.z-=.5, O.w*=1.5;              // init velocity\n        P = O.xy;\n        O.w  -= .05,                                          // Newton: v += a.dt , a = -g\n        O.xy += .05*O.zw;                                     //         p += v.dt\n        if (T( (R+R.y*O.xy)*.5 +.5).a > 0.)                   // collision: backtrack + ends particle\n            O = vec4( P, 0, O.z != 0. ? -.1 : 0. );           // 1st: fall vertically\n    }                                                         // 2nd: ends & recycle\n    else {                                                    // --- draw\n        for(int i=0; i<N; i++) {\n            vec4 p = T(vec2(i,0));\n            if (p.zw==Z) O.ra = max(O.ra, D(p.xy, 1.5 )*.6);  // ended particle: drop dirt\n        }\n        P = ( U - T(0).xy +vec2(0,.05)) * mat2(-1,1,1,1);     // carve digger place\n        O =  clamp( O - max(0.,min(P.x,P.y)), 0.,1. );        \n    }\n }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int N = 100;    // number of particles\n#define R       iResolution.xy\n#define T(U)    texelFetch( iChannel0, ivec2(U), 0 )\n#define D(p,r)  clamp( r - R.y/4.*length(p-U) , 0., 1. ) // draw disk", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 408]], "test": "untested"}
{"id": "WdKcRt", "name": "Turbulent lava flow", "author": "jarble", "description": "I discovered this formula by accident when I was editing my [url=https://www.shadertoy.com/view/tdKyRc]\"Fractal Rivers\"[/url] shader.", "tags": ["fractal", "turbulence", "lava"], "likes": 28, "viewed": 1327, "published": 3, "date": "1603485040", "time_retrieved": "2024-07-30T20:38:25.407534", "image_code": "/*\n\nCopyright (c) 2021 Anderson Green\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 col;\n    float t = iTime*.1;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t,t*2.0);\n    float factor = 1.5;\n    vec2 v1;\n    for(int i=0;i<12;i++)\n    {\n        uv *= -factor*factor;\n        v1 = uv.yx/factor;\n        uv += sin(v1+col+t*10.0)/factor;\n        col += vec2(sin(uv.x-uv.y+v1.x-col.y),sin(uv.y-uv.x+v1.y-col.x));\n    }\n    fragColor = vec4(vec3(col.x+4.0,col.x-col.y/2.0,col.x/5.0)/2.0,1.0);\n}", "image_inputs": [], "sound_code": "vec2 sound1(int t)\n{\n    t = (t*(((t/5/4096)%5+(t*t/3/4096)%3+(t*t/7/4096)%7-(t/2/4096)%2)))|t>>4|t>>5&t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcRt.jpg", "access": "api", "license": "mit", "functions": [[1067, 1067, 1124, 1124, 1554]], "test": "untested"}
{"id": "tdGczt", "name": "bas-relief ( 105 chars )", "author": "FabriceNeyret2", "description": "proof of Cthulhu's times ? :-p\n\nlighted version here: [url] https://www.shadertoy.com/view/tsGyRd [/url]", "tags": ["golf"], "likes": 7, "viewed": 484, "published": 3, "date": "1603464618", "time_retrieved": "2024-07-30T20:38:26.222356", "image_code": "void mainImage(out vec4 O, vec2 u) {\n    O.yxz = iResolution;\n    O = texture(iChannel0,vec3(u+u-O.yx,-O/.7).xzy);\n    O = O.rrrr/.1 - 15.*O.g;}                              /*\n\n\n\n\n\n/* // 112 chars\n\n#define mainImage(O,u)                                      \\\n    O.rgb = iResolution,                                    \\\n    O = texture(iChannel0,vec3(0,1.4*u+.3*O.xy).yxz-O.xyy); \\\n    O = O.rrrr/.1 - 15.*O.g                                /*\n\n/**/", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 144]], "test": "untested"}
{"id": "tsKyzc", "name": "Catmull-Rom", "author": "henrmota", "description": "Catmull Rom experiment", "tags": ["catmull"], "likes": 6, "viewed": 483, "published": 3, "date": "1603463056", "time_retrieved": "2024-07-30T20:38:27.367295", "image_code": "highp vec2 points[5];\n\nconst mat4 catmullMatrix =  mat4(\n    0., 2., 0., 0., \n   -1.,0., 1., 0.,\n    2., -5., 4., -1,\n   -1, 3, -3, 1\n);\n\nvec2 getPoint(float t, int index) {\n   vec2 p1 = points[index];\n   vec2 p2 = points[(index+1) % points.length()];\n   vec2 p3 = points[(index+2)% points.length()];\n   vec2 p0 = points[(index - 1 + points.length()) % points.length()];\n    \n   mat4x2 pointsMat;\n   pointsMat[0] = p0;\n   pointsMat[1] = p1;\n   pointsMat[2] = p2;\n   pointsMat[3] = p3;\n\n   float t2 = t*t;\n   float t3 = t2 * t;\n   \n   return pointsMat * catmullMatrix * vec4(1., t, t2, t3) * 0.5;\n}\n\nfloat catrom(vec2 uv, int index) {\n   float onePixel = 1./iResolution.y;\n   float d = 100.;\n    \n   for(float t=0.; t<=1.; t+=onePixel*5.) {\n     vec2 p = getPoint(t, index);\n     d = min(d, distance(uv, p));\n   }\n   \n   return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    points = vec2[](\n    \tvec2(-0.5, 0.5 * (sin(iTime) * 0.5 + 0.5)), \n   \t \tvec2(-0.25, 0.2 * abs(sin(iTime))),\n        vec2(-0.15 * abs(sin(iTime)), 0.2 * abs(sin(iTime))),\n    \tvec2(mouse.x, mouse.y), \n    \tvec2(0.5,-0.2 * (sin(iTime) * 0.5 + 0.5))\n\t);\n    \n    float t = mod(iTime, float(points.length()));\n    float t2 = mod(0.4 * iTime, float(points.length()));\n    \n    float onePixel = 1./iResolution.y;\n\tvec3 col = vec3(0);\n    float m = 0.;\n    for(int i=0; i < points.length(); i++) {\n       float pixel = 10.*onePixel;\n       m+= 0.002/distance(uv, points[i]);\n    }\n\n    float pixel = 20.*onePixel;\n    vec2 point = getPoint(fract(t), int(floor(t)));\n    col += 0.02/distance(uv, point) * vec3(0.12, 0.04, 0.5);\n    \n    point = getPoint(fract(t2), int(floor(t2)));\n    col += 0.02/distance(uv, point) * vec3(0.12, 0.2, 0.04);\n    \n    pixel = 4.*onePixel;\n    \n    col.g += m;\n    for(int i = 0; i < points.length(); i++) {\n    \tcol += 0.0005/catrom(uv, i) *  vec3(0.5, 0.54, 0.32);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 173, 173, 597], [599, 599, 633, 633, 831]], "test": "untested"}
{"id": "WdGyzt", "name": "Beautified Random Path", "author": "Arseny", "description": "Just some visual stuff of my random path generator [url]https://www.shadertoy.com/view/wdKczV[/url]", "tags": ["procedural", "2d"], "likes": 1, "viewed": 321, "published": 3, "date": "1603462585", "time_retrieved": "2024-07-30T20:38:28.312766", "image_code": "#define pi (3.14159265359)\n\n#define gridScale (10.) // must be integer\n\nmat2 Rot(float a) {\n    a *= pi * 2.;\n    float s=sin(a), c=cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat f(float x){\n    return 16. * pow(x - 0.5, 5.) + 0.5;\n}\n\n// must be idb.x <= idp.x <= ide.x && idb.y <= idp.y <= ide.y\nfloat IsOnRandomPath(vec2 idp, vec2 idb, vec2 ide, float seed){\n    if (idp.x < idb.x || idp.y < idb.y || idp.x > ide.x || idp.y > ide.y) return 0.;\n    vec2 sz = ide - idb;\n    vec2 id = idp - idb;\n    float need = id.x + id.y;\n    float l = 0.;\n    float r = sz.x + sz.y + 1.;\n    vec2 lb = vec2(0.), ur = sz;\n    vec2 as = vec2(0.);\n    while (r - l > 1.){\n        float m = floor((r + l) / 2.);\n        float miny = max(lb.y, m - ur.x), maxy = min(m - lb.x, ur.y);\n        float rnd = miny + floor((maxy - miny + 0.999) * f(hash12(vec2(m, seed))));\n        if (need < m){\n            r = m;\n            ur = vec2(m - rnd, rnd);\n            //ur = vec2(m - rnd, rnd);\n        } else {\n            l = m;\n            lb = vec2(m - rnd, rnd);\n        }\n    }\n    return (lb == id) ? 1. : 0.;\n}\n\nvec2 hexGrid(vec2 uv){\n    vec2 cid = floor(uv * gridScale - 0.5) + 0.5;\n   \tvec2 lcuv = uv * gridScale - cid;\n    //lcuv = vec2(min(lcuv.x, 1. - lcuv.x), min(lcuv.y, 1. - lcuv.y));\n    vec2 slcuv = vec2(max(lcuv.x, lcuv.y), min(lcuv.x, lcuv.y));\n    vec2 n = Rot(1. / 16.) * vec2(1., 0.);\n    vec2 add = vec2(0.);\n    add -= vec2(0.5) * step(dot(slcuv, n) - dot(vec2(0.5, 0.), n), 0.);\n    slcuv = vec2(1. - slcuv.y, 1. - slcuv.x);\n    add += vec2(0.5) * step(dot(slcuv, n) - dot(vec2(0.5, 0.), n), 0.);\n\tif (length(add) > 0.) return (cid + add);\n    return step(lcuv.x, lcuv.y) * (cid + vec2(-0.5, 0.5)) + \n        step(lcuv.y, lcuv.x) * (cid + vec2(0.5, -0.5));\n    /*if (lcuv.y > lcuv.x){\n        return (cid + vec2(-0.5, 0.5)) / 10.;\n    }\n    return (cid + vec2(0.5, -0.5)) / 10.;*/\n}\n\nvec4 CellSegment(vec2 id, vec2 idb, vec2 ide, float seed){\n    vec2 beg = vec2(0.);\n    beg += IsOnRandomPath(id + vec2(-1., 0.), idb, ide, seed) * vec2(-1., 0.) / 2.;\n    beg += IsOnRandomPath(id + vec2(0., -1.), idb, ide, seed) * vec2(0., -1.) / 2.;\n    vec2 end = vec2(0.);\n    end += IsOnRandomPath(id + vec2(1., 0.), idb, ide, seed) * vec2(1., 0.) / 2.;\n    end += IsOnRandomPath(id + vec2(0., 1.), idb, ide, seed) * vec2(0., 1.) / 2.;\n    return vec4(beg, end) / gridScale;\n}\n\nfloat beautifier(vec2 uv, vec2 idb, vec2 ide, float seed){\n    vec2 id = hexGrid(uv);\n    if (IsOnRandomPath(id, idb, ide, seed) < 0.5){\n        return 0.;\n    }\n    /*vec2 beg = vec2(0.);\n    beg += IsOnRandomPath(id + vec2(-1., 0.), idb, ide, seed) * vec2(-1., 0.) / 2.;\n    beg += IsOnRandomPath(id + vec2(0., -1.), idb, ide, seed) * vec2(0., -1.) / 2.;\n    vec2 end = vec2(0.);\n    end += IsOnRandomPath(id + vec2(1., 0.), idb, ide, seed) * vec2(1., 0.) / 2.;\n    end += IsOnRandomPath(id + vec2(0., 1.), idb, ide, seed) * vec2(0., 1.) / 2.;*/\n    vec4 s = CellSegment(id, idb, ide, seed);\n    //return vec3(beg, 0.);\n    id += vec2(0.5);\n    id /= gridScale;\n    //beg /= gridScale;\n    //end /= gridScale;\n    return (1. - min(sdSegment(uv, id + s.xy, id + s.zw) * 30., 1.));\n    \n    return 1.;\n}\n\nfloat pathSegment(vec2 uv, vec2 idb, vec2 ide, float seed, float beg, float end){\n    vec2 idp = hexGrid(uv);\n    vec2 sz = ide - idb;\n    vec2 id = idp - idb;\n    float d = (uv.x + uv.y) * gridScale - (idb.x + idb.y) - 1.;\n    if (beg * (sz.x + sz.y) < d && d < end * (sz.x + sz.y + 2.)){\n        return beautifier(uv, idb, ide, seed);\n    }\n    /*if (floor(beg * (sz.x + sz.y) - 0.0001) < id.x + id.y && id.x + id.y < ceil(end * (sz.x + sz.y) + 0.0001)){\n        return beautifier(uv, idb, ide, seed);\n    }*/\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 3.;\n    \n    float T = iTime / 4.;\n    \n    uv += vec2(T, T / 2.);\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //fragColor = vec4(IsOnRandomPath(id, vec2(-8., -5.), vec2(7., 6.)));\n    float k = 1.8;\n    vec2 id = floor(uv / k) * k;\n    vec2 lv = uv - id;\n    //float d = beautifier(lv, vec2(0., 0.), vec2(7., 6.), floor(T + hash12(id)));\n    float d = pathSegment(lv, vec2(0., 0.), vec2(15., 13.), \n                          floor(T + hash12(id)) + hash12(id), \n                          (fract(T + hash12(id)) - 0.5) * 2., \n                          fract(T + hash12(id)) * 2.);\n    //d = max(d, beautifier(uv, vec2(-8., -5.), vec2(7., 6.), floor(iTime) + 0.24));\n    //fragColor = d * vec4(0., 1., 0., 0.);\n    fragColor = mix(vec4(1., 0.7, 0., 0.), vec4(0., .5, 1., 0.), d);d * vec4(0., 1., 0., 0.);\n    //fragColor.r = 1.;\n    //fragColor = min(ll.x, ll.y) < 0.005 ? vec4(0., 1., 0., 0.) : fragColor ;\n\treturn;\n    // Output to screen\n    fragColor = vec4(id / 10., 0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 91, 91, 171], [173, 224, 276, 276, 395], [397, 438, 460, 460, 610], [612, 612, 629, 629, 672], [674, 736, 799, 799, 1530], [1532, 1532, 1554, 1554, 2322], [2324, 2324, 2382, 2382, 2805], [2807, 2807, 2865, 2865, 3610], [3612, 3612, 3693, 3693, 4140], [4142, 4142, 4199, 4249, 5361]], "test": "untested"}
{"id": "wsycRt", "name": "Vector Field Feature Dither 2", "author": "JeroenDStout", "description": "Dithering using my great love, vector fields.\n\nBoth (gaussian corrected) video and dithering are analysed with feature detection. A vector is derived between them which has the potential to flip pixels. (Formerly erroneously called gradient descent.)", "tags": ["dithering"], "likes": 6, "viewed": 281, "published": 3, "date": "1603461666", "time_retrieved": "2024-07-30T20:38:29.420804", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 samp = texture(iChannel1, uv);\n    \n    fragColor.xyz = vec3(samp.x, samp.x, samp.x);\n    \n    //fragColor.xyz = vec3(samp.z, samp.z, samp.z);\n    \n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float samplePx(in vec2 px)\n{\n    if (px.x < 0. || px.y < 0. || px.x > 1. || px.y > 1.)\n        return 0.;\n    return texture(iChannel0, px).x - texture(iChannel1, px).x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pxSz = vec2(1., 1.) / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float sample_video[25];\n    int index = 0;\n    for (float y = -2.; y <= 2.; y += 1.) {\n        for (float x = -2.; x <= 2.;x += 1.) {\n            sample_video[index++] = samplePx(uv + vec2(pxSz.x * x, pxSz.y * y));\n        }\n    }\n    \n    float filter_l = 0.;\n    for (int i = 0; i < 25; i++) {\n        filter_l += sample_video[i] * kernel_l[i];\n    }\n    filter_l *= .2;\n    \n    float filter_h = 0.;\n    for (int i = 0; i < 25; i++) {\n        filter_h += sample_video[i] * kernel_h[i];\n    }\n    \n    float filter_v = 0.;\n    for (int i = 0; i < 25; i++) {\n        filter_v += sample_video[i] * kernel_v[i];\n    }\n    \n    float filter_s = 0.;\n    for (int i = 0; i < 25; i++) {\n        filter_s += sample_video[i] * kernel_s[i];\n    }\n\n    // Output to screen\n    fragColor = vec4(filter_l, filter_h, filter_v, filter_s);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float kernel_l[25] = float[25](\n\t .1, .2, .2, .2, .1,\n\t .2, .3, .3, .3, .2,\n\t .2, .3, .4, .3, .2,\n\t .2, .3, .3, .3, .2,\n\t .1, .2, .2, .2, .1\n);\n\nfloat kernel_h[25] = float[25](\n\t.6, .3, 0., -.3, -.6,\n\t.6, .3, 0., -.3, -.6,\n\t.6, .3, 0., -.3, -.6,\n\t.6, .3, 0., -.3, -.6,\n\t.6, .3, 0., -.3, -.6\n);\n\nfloat kernel_v[25] = float[25](\n\t .6,  .6,  .6,  .6,  .6,\n\t .3,  .3,  .3,  .3,  .3,\n     .0,  .0,  .0,  .0,  .0,\n\t-.3, -.3, -.3, -.3, -.3,\n\t-.6, -.6, -.6, -.6, -.6\n);\n\nfloat kernel_s[25] = float[25](\n\t-.1, -.2, -.2, -.2, -.1,\n\t-.2,  .1,  .1,  .1, -.2,\n    -.2,  .1,  .5,  .1, -.2,\n\t-.2,  .1,  .1, -.1, -.2,\n\t-.1, -.2, -.2, -.2, -.1\n);\n\nuint HashWang( uint a )\n{\n\ta = (a ^ 61u) ^ (a >> 16u);\n\ta = a + (a << 3u);\n\ta = a ^ (a >> 4u);\n\ta = a * 0x27d4eb2du;\n\ta = a ^ (a >> 15u);\n\treturn a;\n}\n\nuint Rand( inout uint seed )\n{\n    seed += 13u;\n    return HashWang( seed );\n}\n\nfloat FRand( inout uint seed )\n{\n    uint urand = Rand( seed );    \n    const uint mantissaMask = (0xffffffffu) >> ( 32u - 23u );\n    return fract(float(urand & mantissaMask) / float(mantissaMask)); \n    //return uintBitsToFloat( (urand & mantissaMask) | (127u << 23u) );\n}", "buffer_b_code": "vec4 sample_diff_tex(vec2 uv)\n{\n    if (uv.x < 0. || uv.x > 1. || uv.x < 0. || uv.y > 1.)\n      return vec4(0., 0., 0., 0.);\n    \n    return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint seed = uint( iTime * 23.456 ) + uint(fragCoord.x *23.45f) * 12326u + uint(fragCoord.y * 36.43) * 42332u;\n    float rnd = FRand(seed);\n    \n    vec2 pxSz = vec2(1., 1.) / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 old_sample = texture(iChannel1, uv);\n    vec4 proc_video = texture(iChannel2, uv);\n    \n    float rate = proc_video.y;// * proc_video.y;\n    float tired_rate = pow(0.995, 1.0 + rate * 10.);\n    float shift_rate = 7. + 1. * pow(2.0, -1. + rate * 2.);\n    \n    float prev_bw = old_sample.x;\n    float luminosity = old_sample.y;\n    float luminosity_shift = 0.;\n    float tiredness = old_sample.w * tired_rate;\n    \n    vec4 sample_diff[25];\n    int index = 0;\n    for (float y = -2.; y <= 2.; y += 1.) {\n        for (float x = -2.; x <= 2.;x += 1.) {\n            sample_diff[index++] = sample_diff_tex(uv + vec2(pxSz.x * x, pxSz.y * y));\n        }\n    }\n    \n    float filter_l = 0.;\n    float filter_h = 0.;\n    float filter_v = 0.;\n    float filter_s = 0.;\n    for (int i = 0; i < 25; i++) {\n        filter_l += sample_diff[i].x * kernel_l[i];\n        filter_h += sample_diff[i].y * kernel_h[i];\n        filter_v += sample_diff[i].z * kernel_v[i];\n        filter_s += sample_diff[i].w * kernel_s[i];\n    }\n    luminosity_shift += filter_l * 10.0;\n    luminosity_shift += filter_h * -9.;\n    luminosity_shift += filter_v * -9.;\n    luminosity_shift += filter_s * 10.;\n    \n   // if (abs(luminosity_shift) < 10.)\n   //     luminosity_shift = 0.;\n    \n    tiredness *= pow(0.9, abs(luminosity_shift * 0.005));\n    \n    luminosity_shift *= shift_rate;\n    //luminosity_shift += (-1. + rnd * 2.) * 1.;\n    \n    luminosity += sign(luminosity) * (100. * log(1. + tiredness));\n    luminosity *= 0.9995;\n    luminosity += luminosity_shift;\n    \n    luminosity = max(-1000., min(1000., luminosity));\n    \n    float new_bw = luminosity > 0. ? 1. : 0.;\n    if (new_bw != prev_bw)\n        tiredness += 1. + 100. * rnd;\n    \n   // if (rnd > 0.5)\n   // \tnew_bw = prev_bw;\n    \n    fragColor = vec4(new_bw, luminosity, filter_s, tiredness);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float videoToPixel( vec3 pix )\n{\n    return max(pix.x, max(pix.y, pix.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = fragCoord/iResolution.xy;\n    vec4 samp = texture(iChannel0, uv);\n    vec2 off  = vec2(1. / 40.);//vec2(16.) / iResolution.xy;\n    \n    float val[12];\n    vec2  acc = vec2(0.);\n    \n    val[ 0] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x, uv.y - off.y * 2.)).xyz);\n    val[ 1] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x, uv.y - off.y * 2.)).xyz);\n    val[ 2] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 2., uv.y - off.y * 1.)).xyz);\n    val[ 3] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 1., uv.y - off.y * 1.)).xyz);\n    val[ 4] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 2., uv.y - off.y * 1.)).xyz);\n    val[ 5] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 1., uv.y - off.y * 1.)).xyz);\n    val[ 6] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 2., uv.y + off.y * 1.)).xyz);\n    val[ 7] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 1., uv.y + off.y * 1.)).xyz);\n    val[ 8] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 2., uv.y + off.y * 1.)).xyz);\n    val[ 9] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 1., uv.y + off.y * 1.)).xyz);\n    val[10] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x, uv.y + off.y * 2.)).xyz);\n    val[11] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y * 2.)).xyz);\n    \n    acc += texture(iChannel1, vec2(uv.x - off.x * .125, uv.y - off.y * .125)).zw;\n    acc += texture(iChannel1, vec2(uv.x + off.x * .125, uv.y - off.y * .125)).zw;\n    acc += texture(iChannel1, vec2(uv.x - off.x * .125, uv.y + off.y * .125)).zw;\n    acc += texture(iChannel1, vec2(uv.x + off.x * .125, uv.y + off.y * .125)).zw;\n    \n    float prev_value = texture(iChannel1, uv).x;\n    \n    \n    float mean = 0.;\n    for (int i = 0; i < 12; i++) {\n        val[i] = pow(val[i], 2.2);\n        mean += val[i];\n    }\n    mean /= 12.;\n    \n    float var = 0.;\n    for (int i = 0; i < 12; i++) {\n        var += pow(val[i]-mean, 2.);\n    }\n    \n    mean *= 0.05;\n    mean += acc.x * 0.95 * 0.25;\n    var *= 0.05;\n    var += acc.y * 0.95 * 0.25;\n    \n    float overShot = max(0., sqrt(var)*1.5 + mean * 0.8 - 1.0);\n    //overShot -= max(0., 1. - sqrt(var)*1.5 - mean);\n    //mean += overShot * 0.015;\n    \n    fragColor.y     = overShot;\n    \n    fragColor.z     = mean;\n    fragColor.w     = var;\n    \n    float vid = videoToPixel(texture(iChannel0, uv).xyz);\n    \n    fragColor.x = pow(vid, 2.2) - mean;\n    fragColor.x /= min(1., max(4e-1, sqrt(var) * .85));\n    fragColor.x += 0.15 + mean * 0.8;// - overShot * 0.1;\n    // fragColor.x = vid;\n    \n    float diff = abs(fragColor.x - prev_value);\n    fragColor.y = sqrt(diff);\n\n    //fragColor.x = var;//pow(vid, 2.2);\n}", "buffer_c_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 278]], "test": "untested"}
{"id": "tdGcRt", "name": "Weird Distortion 3", "author": "Leasel", "description": "This a distortion where every pixel moves itself based on the texture from iChannel1 and moves a part of its colour to the neighbouring pixel.\n(Somehow the texture from iChannel1 can reconstruct itself out of the texture from iChannel 2)", "tags": ["buffer", "sequel"], "likes": 1, "viewed": 289, "published": 3, "date": "1603458541", "time_retrieved": "2024-07-30T20:38:30.444068", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = Smp(fragCoord*dif.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Move(uv) texture(iChannel1,uv)\n\nvec2 Mov(in vec2 uv)\n{\n    vec4 Pix = Move(uv);\n    return (Pix.xy - Pix.zw)*dif.xy;\n}\n//vec2 Mov(in vec2 uv)//Also beautifull\n//{\n//    return (Move(uv).xy-0.5)*2.;\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord*dif.xy;\n    vec4 Initiation = (iFrame == 0) ? texture(iChannel2, uv) : vec4(0.);\n    \n    vec4 Col = vec4(0.);\n    //The right way is making x < 2. && y < 2.\n    for(float y = -1.; y < 1.; y++)\n    {\n        for(float x = -1.; x < 1.; x++)\n    \t{\n            vec2 Pos = vec2(x, y);//Object Space\n            vec2 Move = Mov(uv);//The amount this cell will move\n            Move += Pos;//Is the amount the cell should have moved\n            \n            Pos *= dif.xy;//Texture space\n        \tPos += uv;//Texture space\n            \n            //The part it will get from another cell\n    \t\tfloat Part = (1. - abs(Move.x))*(1. - abs(Move.y))*1.05;//make the 1.05 1 for almost perfect colour balance\n    \t\t//Summed up colors\n    \t\tCol += Smp(Pos)*Part;\n    \t}\n    }\n    \n    fragColor = Initiation + Col;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = Smp(fragCoord*dif.xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dif vec3(1./iResolution.xy,0.)\n//#define dif2 vec3(-1./iResolution.x, 1./iResolution.y,0.)\n#define Smp(uv) texture(iChannel0,uv)", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGcRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 98]], "test": "untested"}
{"id": "wljfRD", "name": "Rectangles - Movement", "author": "DawCrash", "description": "Rectangles", "tags": ["rectangle"], "likes": 3, "viewed": 264, "published": 3, "date": "1603457819", "time_retrieved": "2024-07-30T20:38:31.217002", "image_code": "vec4 rectangle(vec2 xy, float x1, float y1, float x2, float y2) {\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (xy.x >= x1 && xy.x <= x2 && xy.y >= y1 && xy.y <= y2) result = vec4(0.04, 0.04, 0.04, 1.0);\n    \n    return result;\n}\n\nvec4 rectangleSin(vec2 xy, float modx, float mody) {\n    float r1x1 = sin(iTime / modx) / 2.0 + 0.25;\n    float r1x2 = r1x1 + 0.5;\n    float r1y1 = sin(iTime / mody) / 2.0 + 0.25;\n    float r1y2 = r1y1 + 0.5;\n    \n    return rectangle(xy, r1x1, r1y1, r1x2, r1y2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    xy.x = xy.x / iResolution.x; //We divide the coordinates by the screen size\n    xy.y = xy.y / iResolution.y;\n    \n    fragColor = rectangleSin(xy, 1.0, 1.5);\n    \n    for (float i = 1.0; i < 2.0; i += 0.01) {\n        fragColor += rectangleSin(xy, i, 3.0-i);\n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 65, 237], [239, 239, 291, 291, 504], [506, 506, 563, 563, 921]], "test": "untested"}
{"id": "wsyyRt", "name": "plasma pixel color \"fixer\"", "author": "oatmealine", "description": "i dunno, i just decided to stick a plasma into a sampler and got this", "tags": ["plasma", "post", "weird"], "likes": 1, "viewed": 650, "published": 3, "date": "1603456793", "time_retrieved": "2024-07-30T20:38:32.031823", "image_code": "#define PI 3.1415\n#define strength (iMouse.x / iResolution.x)\n\nfloat plasma(vec2 uv) {\n    float v = 0.0;\n    float k = 4.0;\n    vec2 c = uv * k - k / 2.0;\n    \n    v += sin((c.x + iTime));\n    v += sin((c.y + iTime) / 2.0);\n    \n    v += sin((c.x + c.y + iTime) / 3.0);\n    \n    c += k / 2.0 * vec2(sin(iTime / 3.2), cos(iTime / 2.62));\n    \n    v += sin(sqrt(c.x * c.x + c.y * c.y + 1.0 ) + iTime);\n    \n    v = v/2.0;\n    \n    // vec3 col = vec3(1, sin(PI*v), cos(PI*v));\n    return v;\n}\n\nfloat sum(vec3 p) {\n    return p.r + p.g + p.b;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float angle = tan(plasma(uv));\n    float dist = max(cos(plasma(uv)), 0.0);\n    dist *= strength;\n    \n   \tvec2 diff = vec2(cos(angle), sin(angle)) * dist;\n    \n    uv -= diff;\n    \n    vec2 pixDiff = diff * iResolution.xy;\n    int pixDist = int(sqrt(pixDiff.x * pixDiff.x + pixDiff.y * pixDiff.y));\n    \n    vec3 origCol = texture(iChannel0, uv).rgb;\n    \n    vec2 furthestPix = vec2(0.0);\n    vec3 furthestCol = vec3(0.0);\n    for (int pix = 0; pix < pixDist; pix++) {\n        float a = float(pix) / float(pixDist);\n        vec2 samplePos = uv + pixDiff * a;\n        vec3 col = texture(iChannel0, fract(samplePos/iResolution.xy)).rgb;\n        \n        if (sum(abs(origCol - col)) > sum(furthestCol)) {\n            furthestCol = abs(origCol - col);\n            furthestPix = pixDiff * a;\n        }\n    }\n    \n    vec3 col = texture(iChannel0, uv + furthestPix).rgb;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 86, 86, 490], [492, 492, 511, 511, 541], [543, 543, 598, 598, 1547]], "test": "untested"}
{"id": "tdyyRt", "name": "medieval flag ( 82 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["golf"], "likes": 6, "viewed": 330, "published": 3, "date": "1603456615", "time_retrieved": "2024-07-30T20:38:32.775834", "image_code": "void mainImage(out vec4 O,vec2 u){O-=log(texture(iChannel0,vec3(0,u+u).yxz-iResolution.xyy).r)+O;}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 98]], "test": "untested"}
{"id": "tdGyRt", "name": "Math Zebra", "author": "hamoid", "description": "Hi! Can someone help me with this one? \n\nIt works fine on two Intel GPUs I tried but on a Mac with an NVidia graphics card \nit shows the pattern only inside a rounded area, and most of the screen is empty.\n\nWhat could it be?\n", "tags": ["bw", "monochrome", "helpneeded"], "likes": 5, "viewed": 340, "published": 3, "date": "1603455368", "time_retrieved": "2024-07-30T20:38:33.693380", "image_code": "mat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = uv - 0.5;\n    vec2 p2 = rotate(p.x + iTime + p.y) * p;\n    \n    float pattern = fract(8.5 * pow(p2.y, 0.5) *\n        fract(p.y * 2.2 + fract(1.75 * fract(p2.x * 1.6) *\n        pow(p.x * 1.8 + fract(p.y * 1.5 + iTime * 0.7 + p.x), 1.2))) + iTime * 0.4);\n    \n    pattern = smoothstep(0.48, 0.52, pattern);\n    \n    fragColor = vec4(vec3(pattern), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [99, 99, 156, 156, 568]], "test": "untested"}
{"id": "wsycWD", "name": "Shader Submit", "author": "eltounyomar", "description": "axaxxa", "tags": ["shader"], "likes": 9, "viewed": 342, "published": 3, "date": "1603440425", "time_retrieved": "2024-07-30T20:38:34.735594", "image_code": "#define SKEW_GRID\n#define FAR 20.\n#define QUANTIZE_HEIGHTS\n#define FLAT_GRID\n#define PTH_INDPNT_GRD\n#define GRAYSCALE\n#define REVERSE_PALETTE\nfloat objID;\n\nmat2 rot2(in float a){float c=cos(a), s=sin(a); return mat2(c,-s,s,c);}\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), 0);\n}\n\nvec3 getTex(in vec2 p){\n    \n    // Stretching things out so that the image fills up the window.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, p/8.).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\nvec2 unskewXY(vec2 p, vec2 s){\n\n\treturn inverse(mat2(1, -s.y, -s.x, 1))*p;\n\n}\n\nvec2 gp;\n\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\tvec2 w=vec2(sdf,abs(pz)-h-sf/2.);\n    return min(max(w.x,w.y),0.) + length(max(w + sf, 0.)) - sf;\n}\n\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    // Scale... Kind of redundant here, but sometimes there's a distinction\n    // between scale and dimension.\n\tconst vec2 scale = vec2(1./5.);\n\n    // Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    // Skewing half way along X, and Y.\n    const vec2 sk = vec2(-.5, .5);\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.; // Zero height pylons for the flat grid.\n    #else\n    const float hs = .4;\n    #endif\n    \n    float height = 0.; // Pylon height.\n\n\n    // Local cell coordinate copy.\n    gP = vec2(0);\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0]/2.;\n        \n        // Skewed local coordinates.\n        p = skewXY(q.xz, sk);\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \n        // Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n        \n \n        // The larger grid cell face.\n        //\n        vec2 idi1 = idi; // Block's central position, and ID.\n        float h1 = hm(idi1);\n        #ifdef QUANTIZE_HEIGHTS\n        h1 = floor(h1*20.999)/20.; // Discreet height units.\n        #endif\n        h1 *= hs; // Scale the height.\n        \n        // Larger face and height extrusion.\n        float face1 = sBoxS(p, 2./5.*dim - .02*scale.x, .015);\n        //float face1 = length(p) - 2./5.*dim.x;\n        float face1Ext = opExtrusion(face1, q.y + h1, h1, .006); \n    \n        \n        // The second, smaller face.\n        //\n        //vec2 offs = vec2(3./5., -1./5.)*dim;\n        vec2 offs = unskewXY(dim*.5, sk);\n        vec2 idi2 = idi + offs;  // Block's central position, and ID.\n        float h2 = hm(idi2);\n        #ifdef QUANTIZE_HEIGHTS\n        h2 = floor(h2*20.999)/20.; // Discreet height units.\n        #endif\n        h2 *= hs; // Scale the height.\n     \n        // Smaller face and height extrusion.\n        float face2 = sBoxS(p - offs, 1./5.*dim - .02*scale.x, .015);\n        //float face2 = length(p - offs) - 1./5.*dim.x;\n        float face2Ext = opExtrusion(face2, q.y + h2, h2, .006);\n         \n        // Pointed face tips, for an obelisque look, but I wasn't feeling it. :)\n        //face1Ext += face1*.25;\n        //face2Ext += face2*.25;\n        \n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            // Setting the local coordinates: This is hacky, but I needed a \n            // copy for the rendering portion, so put this in at the last minute.\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and pylong height.\n    return vec4(d, id, height);\n}\n\nfloat getTwist(float z){ return z*.08; }\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// Speaking of lazy, here's some global glow variables. :D\n// Glow: XYZ is for color (unused), and W is for individual \n// blocks.\nvec4 gGlow = vec4(0);\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Wrap the scene around the path. This mutates the geometry,\n    // but it's easier to implement. By the way, it's possible to\n    // snap the geometry around the path, and I've done that in\n    // other examples.\n    p.xy -= path(p.z);\n    \n    // Twist the geometry along Z. It's cheap and visually effective.\n    // Demosceners having been doing this for as long as I can remember.\n    p.xy *= rot2(getTwist(p.z));\n\n    \n    // Turning one plane into two. It's an old trick.\n    p.y = abs(p.y) - 1.25;\n  \n    // There are gaps between the pylons, so a floor needs to go in\n    // to stop light from getting though.\n    float fl = -p.y + .01;\n    \n    #ifdef PTH_INDPNT_GRD\n    // Keep the blocks independent of the camera movement, but still \n    // twisting with warped space.\n    p.xy += path(p.z);\n    #endif\n    \n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    // Only alowing certain blocks to glow. We're including some \n    // animation in there as well.\n    float rnd = hash21(gID.xy);\n    //\n    // Standard blinking lights animation.\n    gGlow.w = smoothstep(.992, .997, sin(rnd*6.2831 + iTime/4.)*.5 + .5);\n    //gGlow.w = rnd>.05? 0. : 1.; // Static version.\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded blocks.\n    return min(fl, d4.x);\n \n}\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n     \n    // Zero out the glow.\n    gGlow = vec4(0);\n    t = hash31(ro.zxy + rd.yzx)*.25;\n    \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t); // Distance function.\n        \n        // Adding in the glow. There'd be better and worse ways to do it.\n        float ad = abs(d + (hash31(ro + rd) - .5)*.05);\n        const float dst = .25;\n        if(ad<dst){\n            gGlow.xyz += gGlow.w*(dst - ad)*(dst - ad)/(1. + t);\n        }\n        if(abs(d)<.001*(1. + t*.05) || t>FAR) break; \n        \n        t += i<32? d*.4 : d*.7; \n    }\n\n    return min(t, FAR);\n}\n\nvec3 getNormal(in vec3 p){\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.25)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*2.0); // Camera position, doubling as the ray origin.\n    ro.xy += path(ro.z); \n    vec2 roTwist = vec2(0, 0);\n    roTwist *= rot2(-getTwist(ro.z));\n    ro.xy += roTwist;\n    \n\tvec3 lk = vec3(0, 0, ro.z + .45); // \"Look At\" position.\n    lk.xy += path(lk.z); \n    vec2 lkTwist = vec2(0, -.1); // Only twist horizontal and vertcal.\n    lkTwist *= rot2(-getTwist(lk.z));\n    lk.xy += lkTwist;\n    \n\tvec3 lp = vec3(0, 0, ro.z + 5.); // Light.\n    lp.xy += path(lp.z);\n    vec2 lpTwist = vec2(0, -.3); // Only twist horizontal and vertcal.\n    lpTwist *= rot2(-getTwist(lp.z));\n    lp.xy += lpTwist;\n    \n\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    float a = getTwist(ro.z);\n    // Swiveling the camera about the XY-plane.\n    a += (path(ro.z).x - path(lk.z).x)/(ro.z - lk.z)/4.;\n\tvec3 fw = normalize(lk - ro);\n\t//vec3 up = normalize(vec3(-fw.x, 0, -fw.z));\n\tvec3 up = vec3(sin(a), cos(a), 0);\n\t//vec3 up = vec3(0, 1, 0);\n    vec3 cu = normalize(cross(up, fw));\n\tvec3 cv = cross(fw, cu);   \n    \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*cu + uv.y*cv + fw/FOV);\t\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID, object ID and local coordinates.\n    vec3 svGID = gID;\n    float svObjID = objID;\n    vec2 svP = gP; \n    \n    vec3 svGlow = gGlow.xyz;\n   \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n          \n        // Texel color. \n\t    vec3 texCol;   \n        \n        // Transforming the texture coordinates according to the camera path\n        // and Z warping.\n        vec3 txP = sp;\n        txP.xy -= path(txP.z);\n        txP.xy *= rot2(getTwist(txP.z));\n        #ifdef PTH_INDPNT_GRD\n        txP.xy += path(txP.z);\n        #endif\n\n        // The extruded grid.\n        if(svObjID<.8){\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID.xy);\n            \n            // Ramping the shade up a bit.\n            texCol = smoothstep(-.3, 1., tx)*vec3(1, .4, 2.6);\n            \n            \n            // Very fake, but very cheap, bump mapping. Render some equispaced horizontal\n            // dark lines, and some light adjacent ones. As you can see, it gives the\n            // impression of horizontally segmented grooves on the pylons.\n            const float lvls = 9.;\n            \n            // Vertical lines... A bit too much for this example, but useful for a fake\n            // voxel setup.\n            //float vLn = min(abs(txP.x - svGID.x), abs(txP.z - svGID.y));\n            \n            // Horizontal lines (planes, technically) around the pylons.\n            float yDist = (1.25 + abs(txP.y) + svGID.z*2.);\n            float hLn = abs(mod(yDist  + .8/lvls, 1./lvls) - .5/lvls);\n            float hLn2 = abs(mod(yDist + .75/lvls - .018, 1./lvls) - .7/lvls);\n            \n            // Omitting the top and bottom planes... I was in a hurry, and it seems to\n            // work, but there'd be better ways to do this. \n            if(yDist - 2.5<.45/lvls) hLn = 1e5;\n            if(yDist - 2.5<.45/lvls) hLn2 = 1e5;\n            \n            // Rendering the dark and light lines using 2D layering techniques.\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .006, hLn2 - .0055));\n       \t\ttexCol = mix(texCol, texCol/2.5, 1. - smoothstep(0., .006, hLn - .0055));\n       \t\t \n            \n            // Render a dot on the face center of each extruded block for whatever reason...\n            // They were there as markers to begin with, so I got used to them. :)\n            float fDot = length(txP.xz - svGID.xy) - .0096;\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .002, fDot - .0065));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .002, fDot));\n  \n\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // there are very slight gaps, so it's still necessary.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .003);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.45, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 3./(1. + lDist*lDist*.5);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff *= diff*1.55; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 4.);\n        col = texCol*(diff + ao*.25 + vec3(1, .4, .2)*fre*.25 + vec3(1, .4, .2)*spec*4.);\n        \n        col *= ao*sh*atten;\n\t\n\t}\n\n    svGlow.xyz *= mix(vec3(4, 1, 2), vec3(4, 2, 1), min(svGlow.xyz*3.5, 1.25));\n    col *= .25 + svGlow.xyz*8.;\n   \n    vec3 fog =  mix(vec3(4, 1, 2), vec3(4, 2, 1), rd.y*.5 + .5);\n    fog = mix(fog, fog.zyx, smoothstep(0., .55, uv.y - .35));\n    col = mix(col, fog/1.5, smoothstep(0., .99, t*t/FAR/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    // Grayscale... or almost grayscale. :)\n    col = mix(col, vec3(1)*dot(col, vec3(.320, .650, .174)), .75);\n    #endif \n \n    \n    #ifdef REVERSE_PALETTE\n    col = col.zyx; // A more calming blue, for those who don't like fiery things.\n    #endif\n\n    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 178, 178, 227], [229, 229, 250, 250, 313], [315, 315, 336, 336, 410], [412, 412, 434, 462, 513], [515, 515, 538, 660, 810], [812, 876, 896, 896, 945], [947, 947, 994, 994, 1079], [1081, 1081, 1109, 1109, 1153], [1155, 1155, 1185, 1185, 1232], [1244, 1244, 1314, 1314, 1415], [5038, 5038, 5062, 5062, 5078], [5312, 5335, 5353, 5577, 6741], [6742, 6742, 6778, 6827, 7424], [8122, 8313, 8365, 8482, 9763], [9766, 9918, 9954, 9954, 10198], [10203, 10203, 10259, 10292, 16424]], "test": "untested"}
{"id": "WsGyRt", "name": "Sea cliffs", "author": "jarble", "description": "A procedural terrain using a fractal heightmap.\nThis is based on my [url=https://www.shadertoy.com/view/tsVyzc]\"Meandering Canyons\"[/url] fractal landscape.", "tags": ["fractal", "landscape", "cliff"], "likes": 5, "viewed": 367, "published": 3, "date": "1603427616", "time_retrieved": "2024-07-30T20:38:35.614245", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 20.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*.1; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat heightmap(vec2 uv)\n{\n\tuv *= 4.0;\n    float col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n        t = 0.0;\n        for(int i=0;i<5;i++)\n        {\n            uv /= 1.3;\n        \tuv += float(i) + (sin(uv.x)*cos(uv.y)+sin(uv.y));\n        }\n     col = (sin(uv.x+uv.y+t));\n\t}\n\treturn col;\n}\n\nfloat sceneSDF(vec3 p) {\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    p.y *= 1.0;\n    return (-p.y+20.0-heightmap(p.xz))*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    vec3 p1 = p;\n    p /= scale*500.0;\n    return vec3(heightmap(p.xz*100.0)+1.0)/20.0 + vec3(.6-p.y,.5-p1.y/10.0,.2+p1.y);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(3.14*0.666);\n    float speed = 2.0;\n    float t1 = speed*iTime+5.0;\n\tvec3 eye = vec3(-t1,-10,-t1*2.0);\n    eye.y -= 20.0;\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(0,5,1), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 611, 611, 879], [881, 881, 905, 967, 1035], [1037, 1037, 1065, 1065, 1191], [1194, 1615, 1706, 1706, 2012], [2027, 2281, 2346, 2346, 2478], [2480, 2569, 2598, 2598, 2908], [2910, 3402, 3542, 3542, 4152], [4154, 4524, 4609, 4609, 5024], [5026, 5353, 5402, 5437, 5568], [5570, 5570, 5627, 5627, 6609]], "test": "untested"}
{"id": "3sGyzc", "name": "AutoWasher 2", "author": "xjorma", "description": "SPH Fluid simulation.\nWork really well on my old PC with a NV 860, it's a 1fps on my phone. :(\nhttps://matthias-research.github.io/pages/publications/sca03.pdf", "tags": ["physics", "sph", "fluids", "pbd"], "likes": 17, "viewed": 587, "published": 3, "date": "1603423024", "time_retrieved": "2024-07-30T20:38:36.789607", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define SMOOTH\t1\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nfloat smoothFilter(float d)\n{\n    float v = 2000. / iResolution.y;\n    return smoothstep(v, -v, d);\n}\n\nconst float k = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    p *= 1000.;\n    vec3 col = vec3(0);\n    \n    col = mix(col, vec3(1,0,0), smoothFilter(map(p, iTime)));\n   \n    #if SMOOTH \n        float sminAcc = 0.;\n        for(int i = 0; i < PartNum; i++)\n        {\n            vec2 pp = Load(i, CompPosition).xy;\n            sminAcc += exp2(-k *sdCircle( p - pp, KernelRadius ));\n        }\n    \tcol = mix(col, vec3(0,0,1), smoothFilter(-log2( sminAcc ) / k));\n    #else //SMOOTH\n    {\n        for(int i = 0; i < PartNum; i++)\n        {\n            vec2 pp = Load(i, CompPosition).xy;\n            col = mix(col, vec3(fract(Phi * float(i * 3)), fract(Phi * float(i * 3 + 1)), fract(Phi * float(i * 3 + 2))), smoothFilter(sdCircle(p - pp, KernelRadius)));\n        }        \n    }\n    #endif //SMOOTH\n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst int PartNum\t\t= 512;\nconst int MaxCompPerRow\t= 256;\nconst float DeltaTime   = 0.0008;\nconst float Pi \t\t\t= radians(180.);\n\n\nconst vec2  ExtForce = vec2(0.f, 12000.*-9.8);\nconst float RestDensity = 1000.;\nconst float GasConst = 2000.;\nconst float KernelRadius = 16.;\nconst float PartMass = 65.;\nconst float Viscosity = 250.;\nconst float ColRestitution = 0.20f;\nconst float Poly6 = 315./(65.*Pi*pow(KernelRadius, 9.f));\nconst float SpikyGrad = -45./(Pi*pow(KernelRadius, 6.f));\nconst float ViscLap = 45./(Pi*pow(KernelRadius, 6.f));\n\n\n\nconst int CompPosition\t= 0;\nconst int CompVelocity\t= 1;\nconst int CompDensity\t= 2;\nconst int CompPresure\t= 3;\nconst int CompNum\t\t= 4;\n\n\nconst float Phi \t\t=  (sqrt(5.)*0.5 + 0.5);\n\n\n// https://iquilezles.org/articles/distfunctions2d\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nvec2 rotate(in vec2 v, in float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2  m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nfloat map(in vec2 p, in float t)\n{\n    p = rotate(p, 0.5)*1.12;\n    p = rotate(p, sin(t * 0.2) * 3.);\n    return sdStar5(p, 1.2 * 800., 0.6 ) - 0.1 * 800.;\n}\n\nvec2 normal( in vec2 p, in float t) // for function f(p)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec2(map(p + h.xy, t) - map(p - h.xy, t),\n                           map(p + h.yx, t) - map(p - h.yx, t)));\n}\n\n\n", "buffer_a_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute density & pressure Pass1\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n\n    if(iFrame < 2)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16. - vec2(0, 400.);\n        v = vec2(1);\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n    }\n    \n    // SPH Compute density & pressure\n    \n    float rho = 0.f;\n    for(int i = 0; i < PartNum; i++)\n    {\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r2 = dot(rij, rij);\n\n        if(r2 < KernelRadius * KernelRadius)\n        {\n            // this computation is symmetric\n            rho += PartMass * Poly6 * pow(KernelRadius * KernelRadius - r2, 3.);\n        }\n    }\n    float p = GasConst*(rho - RestDensity);\n    \n    \n     \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute forces, integration + collision pass1\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n    float\trho;\n    float\tp;\n\n    if(false)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16.;\n        v = vec2(1);\n        rho = 0.;\n        p = 0.;\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n        rho\t= Load(pixId, CompDensity).x;\n        p\t= Load(pixId, CompPresure).x;\n    }\n\n    // SPH Compute forces\n    \n\tvec2 f = ExtForce * rho;\n    \n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i == pixId)\n            continue;\n\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r = length(rij);\n\n        if(r < KernelRadius)\n        {\n            float partDensity = Load(i, CompDensity).x;\n            // pressureForce\n            f += normalize(-rij) * PartMass * (p + Load(i, CompPresure).x) / (2. * partDensity) * SpikyGrad * pow(KernelRadius-r, 2.);\n \t\t\t// viscosityForce\n            f += Viscosity * PartMass * (Load(i, CompVelocity).xy - v) / partDensity * ViscLap * (KernelRadius - r);\n        }\n    }\n    \n    if(iFrame > 2)\n    {\n        // SPH Integration\n        v += DeltaTime * f / rho;\n        x += DeltaTime * v;\n    }\n   \n    // enforce constraints\n    float d = map(x, iTime) + KernelRadius;\n    vec2  n = normal(x, iTime);\n    if(d > 0.)\n    {\n        x += -d * n;\n        v = reflect(v, n);\n        d = dot(v, n);\n        v -= n * d * ColRestitution;\n    }   \n    \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute density & pressure pass2\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n\n    if(iFrame < 2)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16. - vec2(0, 400.);\n        v = vec2(1);\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n    }\n    \n    // SPH Compute density & pressure\n    \n    float rho = 0.f;\n    for(int i = 0; i < PartNum; i++)\n    {\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r2 = dot(rij, rij);\n\n        if(r2 < KernelRadius * KernelRadius)\n        {\n            // this computation is symmetric\n            rho += PartMass * Poly6 * pow(KernelRadius * KernelRadius - r2, 3.);\n        }\n    }\n    float p = GasConst*(rho - RestDensity);\n    \n    \n     \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// SPH Compute forces, integration + collision pass2\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    \n    vec2\tx;\n    vec2\tv;\n    float\trho;\n    float\tp;\n\n    if(false)\n    {\n        x = ((vec2(pixId & 7, pixId >> 3)) - 4.) * 16.;\n        v = vec2(1);\n        rho = 0.;\n        p = 0.;\n    }\n\telse\n    {\n        x\t= Load(pixId, CompPosition).xy;\n        v\t= Load(pixId, CompVelocity).xy;\n        rho\t= Load(pixId, CompDensity).x;\n        p\t= Load(pixId, CompPresure).x;\n    }\n\n    // SPH Compute forces\n    \n\tvec2 f = ExtForce * rho;\n    \n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i == pixId)\n            continue;\n\n        vec2 rij = Load(i, CompPosition).xy - x;\n        float r = length(rij);\n\n        if(r < KernelRadius)\n        {\n            float partDensity = Load(i, CompDensity).x;\n            // pressureForce\n            f += normalize(-rij) * PartMass * (p + Load(i, CompPresure).x) / (2. * partDensity) * SpikyGrad * pow(KernelRadius-r, 2.);\n \t\t\t// viscosityForce\n            f += Viscosity * PartMass * (Load(i, CompVelocity).xy - v) / partDensity * ViscLap * (KernelRadius - r);\n        }\n    }\n    \n    if(iFrame > 2)\n    {\n        // SPH Integration\n        v += DeltaTime * f / rho;\n        x += DeltaTime * v;\n    }\n   \n    // enforce constraints\n    float d = map(x, iTime) + KernelRadius;\n    vec2  n = normal(x, iTime);\n    if(d > 0.)\n    {\n        x += -d * n;\n        v = reflect(v, n);\n        d = dot(v, n);\n        v -= n * d * ColRestitution;\n    }   \n    \n    Store(vec4(x, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(v, 0, 0), CompVelocity, curComp, fragColor);\n    Store(vec4(rho, 0, 0, 0), CompDensity, curComp, fragColor);\n    Store(vec4(p, 0, 0, 0), CompPresure, curComp, fragColor);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyzc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[132, 132, 167, 167, 287], [289, 289, 318, 318, 390], [414, 414, 471, 471, 1330]], "test": "untested"}
{"id": "tsVyzc", "name": "Meandering Canyons", "author": "jarble", "description": "These canyons were generated using a modified version of my [url=https://www.shadertoy.com/view/tdKyRc]\"Fractal Rivers\"[/url] pattern as a heightmap.", "tags": ["fractal", "river", "canyon"], "likes": 4, "viewed": 356, "published": 3, "date": "1603418425", "time_retrieved": "2024-07-30T20:38:37.771981", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 20.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*.1; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat heightmap(vec2 uv)\n{\n    \tuv /= 25.0;\n        float factor = 1.5;\n    \tfloat col = 0.0;\n        for(int i=0;i<6;i++)\n        {\n            uv *= -factor*factor;\n            uv += sin(uv.yx/factor)/factor;\n            col += (sin(uv.x-uv.y+col)+cos(uv.y-uv.x+col));\n        }\n    return -col/2.0;\n}\n\nfloat sceneSDF(vec3 p) {\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    p.y *= 1.0;\n    return (-p.y+20.0-heightmap(p.xz))*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    vec3 p1 = p;\n    p /= scale*500.0;\n    return vec3(heightmap(p.xz*100.0)+1.0)/20.0 + vec3(.6-p.y,.5-p1.y/10.0,.2+p1.y);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(3.14*0.666);\n    float speed = 2.0;\n    float t1 = speed*iTime+5.0;\n\tvec3 eye = vec3(-t1,-10,-t1*2.0);\n    eye.y -= 20.0;\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(0,5,1), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 611, 611, 888], [890, 890, 914, 976, 1044], [1046, 1046, 1074, 1074, 1200], [1203, 1624, 1715, 1715, 2021], [2036, 2290, 2355, 2355, 2487], [2489, 2578, 2607, 2607, 2917], [2919, 3411, 3551, 3551, 4161], [4163, 4533, 4618, 4618, 5033], [5035, 5362, 5411, 5446, 5577], [5579, 5579, 5636, 5636, 6618]], "test": "untested"}
{"id": "wdKyzc", "name": "Image/Video Sharpener", "author": "milesWaugh", "description": "Drag the bar to see the difference between the two. This is not sharpening for beauty, but rather for... sharpening?", "tags": ["video", "filter", "sharpen"], "likes": 3, "viewed": 719, "published": 3, "date": "1603413686", "time_retrieved": "2024-07-30T20:38:38.707480", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(abs(fragCoord.x - iMouse.x) < 3.) {\n        fragColor = vec4(0., 0., 0., 1.);\n    } else {\n        vec2 uv = fragCoord / iResolution.xy;\n        if(fragCoord.x > iMouse.x) {\n            vec3 col = vec3(0.);\n            for(int i = -10; i < 11; i++) {\n                col += texture(iChannel1, uv + vec2(0., float(i) / iResolution.x)).rgb / (float(i) * float(i) + 7.);\n            }\n            col = texture(iChannel0, uv).rgb + 2. * (texture(iChannel0, uv).rgb - col);\n            col = col * 1.2 - .04;\n            fragColor = vec4(col, 1.0);\n        } else {\n            fragColor = vec4(texture(iChannel0, uv));\n        }\n    }\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.);\n    for(int i=-10; i<11; i++){\n    \tcol += texture(iChannel0, uv+vec2(float(i)/iResolution.x,0.)).rgb/(float(i)*float(i)+7.);\n    }\n\t\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dKcRV", "name": "Black Hole Test", "author": "milesWaugh", "description": "Einstein is kool <insert sunglasses emoji>", "tags": ["test", "noise", "blackhole", "volumetrics"], "likes": 7, "viewed": 612, "published": 3, "date": "1603412761", "time_retrieved": "2024-07-30T20:38:39.654946", "image_code": "vec3 tex(vec2 fragCoord, vec2 off) {\n    return texture(iChannel0, (fragCoord + off) / iResolution.xy).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.);\n\n    for(int i = -2; i < 3; i++) {\n        for(int j = -2; j < 3; j++) {\n            /*float mul = 1.;\n            if(i*j == 0){mul=2.; if(i+j == 0){ mul = 4.;}}*/\n            col += tex(fragCoord, vec2(i, j)) / (dot(vec2(i, j), vec2(i, j)) + .5);\n        }\n    }\n\n    col /= 40.;\n    col = (1. - (1. / (1. + (4. * (col * col))))) * 1.;\n    float br = (col.x + col.y + col.z) / 3.;\n    col = col + .2 * (col - br);\n    col = vec3(pow(max(col.x - .02, .0), .6), pow(max(col.y - .02, 0.), .55), pow(col.z, .6));\n    br = (col.x + col.y + col.z) / 3.;\n    col = col + .2 * (col - br);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Modeling how light bends around a black hole to render an accretion disk\n\n//Accretion disk simulates volumbetric emmission and volumetric absorption\n\n//Strength of gravity\n#define gravitationalConstant 0.022\n\n//Higher values are better quality but slower. Higher values also cause more gravity and brighter accretion disk.\n//Simulation precision when moving through empty space\n#define minorStep 10000.\n//Simulation precision when moving through accresion disk\n#define majorStep 15000.\n\n#define rot -sin(iTime/7.)/3.\n#define c cos(rot)\n#define s sin(rot)\n#define c2 cos(.4)\n#define s2 sin(.4)\n#define s3 sin(iTime/3.)\n#define c3 cos(iTime/3.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(int(fragCoord.y) % 4 == iFrame % 4) {\n        vec2 co = fragCoord.xy;\n        vec2 uv = ((co + texture(iChannel1, vec3(co.x, co.y, iTime) / 32.).xy) - iResolution.xy / 2.) / iResolution.x;\n        uv = vec2(c2 * uv.x - s2 * uv.y, c2 * uv.y + s2 * uv.x) / 1.1;\n        uv += 5. * (texture(iChannel3, vec2(iTime / 64., iTime * 4.)) - .5).xy / iResolution.x;\n        vec3 pos = vec3(0., 0., -7.);\n        vec2 rotpos;\n        vec3 vel = vec3(uv.x, uv.y, 1.) * 1.8;\n        vec3 col = vec3(0.);\n        float gravity = 0.;\n        float dt = 1.;\n        vec3 gravdir = vec3(0.);\n        int iters = 0;\n        float step = 800.;\n        vec2 sgn = vec2(1., 1.);\n        int switches = 0;\n        vec3 emit = vec3(1. / 1.1, 1. / 2., 1. / 3.5);\n        vec3 absorb = vec3(0.995, 1., 1.005);\n        \n        while(iters < 2048 && pos.z < 5. && dot(pos, pos) > .01 && switches < 3) {\n            gravity = gravitationalConstant / dot(pos, pos);\n            gravdir = normalize(-pos);\n            float stepcur = 2. * step * texture(iChannel0, vec3(float(iters) / 32., pos.x, pos.y)).r;\n            stepcur += step;\n            stepcur /= 2.;\n            dt = gravity * stepcur;\n            vel += gravdir * gravity;\n            sgn = vec2(sgn.y, vel.z / abs(vel.z));\n            if(sgn.x / sgn.y < 0.) {\n                switches++;\n            }\n            pos += vel / dt;\n            iters++;\n            rotpos = vec2(c * pos.z - s * pos.y, c * pos.y + s * pos.z);\n            vec2 xz = vec2(pos.x, rotpos.x);\n            float rad = dot(xz, xz);\n            float thickness = pow((30. - rad) / 2., 0.25) / 2. - 0.49;\n            if(rad < 30. && abs(rotpos.y) < thickness && dot(pos, pos) > 1.) {\n                float noise = 0.;\n                float scale = 6.;\n                vec3 posr = vec3(pos.x * c3 - pos.z * s3, pos.y, pos.z * c3 + pos.x * s3);\n                for(int i = 0; i < 4; i++) {\n                    noise += texture(iChannel0, posr / scale).r * pow(scale, 0.8) * 0.04;\n                    scale /= 2.;\n                }\n                float ch = min(max((noise * 20. - (abs(rotpos.y) - thickness) * 40. - 10.5), 0.), 1.);\n                col += (ch * 0.09) * emit;\n                col *= (1.05 - ch * 0.15) * absorb;\n                if(step == minorStep) {\n                    step = -minorStep;\n                } else {\n                    step = majorStep;\n                }\n            } else {\n                if(step == -minorStep) {\n                    step = majorStep;\n                } else {\n                    step = minorStep;\n                }\n            }\n        }\n        \n        col = max(col, 0.);\n        fragColor = (vec4(col, 1.0) * 20. + texture(iChannel2, fragCoord / iResolution.xy)) / 21.;\n    } else {\n        fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 109], [111, 111, 166, 166, 806]], "test": "untested"}
{"id": "tdKyRc", "name": "Fractal rivers", "author": "jarble", "description": "This is based on my \"metamorphic rock texture\" fractal.", "tags": ["fractal", "river"], "likes": 19, "viewed": 538, "published": 3, "date": "1603405729", "time_retrieved": "2024-07-30T20:38:40.757000", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col;\n    float t = iTime*.1;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t,t*2.0);\n        float factor = 1.5;\n        for(int i=0;i<9;i++)\n        {\n            uv *= -factor*factor;\n            uv += sin(uv.yx/factor)/factor;\n            col += sin(uv.x-uv.y+col)+cos(uv.y-uv.x);\n        }\n    fragColor = vec4(vec3(col/5.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 418]], "test": "untested"}
{"id": "tdKyR3", "name": "Live coding TK Games 2", "author": "jaszunio15", "description": "Live coding improvisation during TK Games scientific circle inauguration.", "tags": ["terrain", "map", "live"], "likes": 0, "viewed": 211, "published": 3, "date": "1603396092", "time_retrieved": "2024-07-30T20:38:41.697485", "image_code": "\nfloat noise12(vec2 uv)\n{\n \tuv *= 0.05;\n    uv += iTime * 0.01;\n    \n    float noise = 0.0;\n    \n    for (float i = 1.0; i <= 8.0; i *= 2.0)\n    {\n        float scale = pow(i, 1.6);\n        float alpha = pow(1.0 / i, 1.9);\n        noise += texture(iChannel0, uv * scale + vec2(0.32, 0.81)).r * alpha;\n    }\n    \n    noise *= 0.5;\n    return noise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float distanceToCenter = length(uv * vec2(iResolution.y / iResolution.x, 1.0));\n    float mask = 1.0 - smoothstep(0.5, 1.0, distanceToCenter);\n    \n\tfloat noise = noise12(uv);\n    noise *= mask;\n    \n\n    float terrain = step(0.3, noise);\n    float mountains = step(0.4, noise);\n    float highMountains = step(0.5, noise);\n    float beach = step(0.28, noise) - terrain;\n    \n    \n    fragColor = mix(vec4(0.5, 0.7, 0.7, 0.0) * 0.6, vec4(0.0, 0.6, 0.0, 0.0), terrain); \n    fragColor = mix(fragColor, vec4(0.5, 0.5, 0.5, 0.0), mountains); \n    fragColor = mix(fragColor, vec4(1.0), highMountains); \n    fragColor = mix(fragColor, vec4(0.7, 0.6, 0.3, 0.0), beach);\n    \n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SEED 0\n\nint[] hash = int[] (208,34,231,213,32,248,233,56,161,78,24,140,71,48,140,254,245,255,247,247,40,\n                     185,248,251,245,28,124,204,204,76,36,1,107,28,234,163,202,224,245,128,167,204,\n                     9,92,217,54,239,174,173,102,193,189,190,121,100,108,167,44,43,77,180,204,8,81,\n                     70,223,11,38,24,254,210,210,177,32,81,195,243,125,8,169,112,32,97,53,195,13,\n                     203,9,47,104,125,117,114,124,165,203,181,235,193,206,70,180,174,0,167,181,41,\n                     164,30,116,127,198,245,146,87,224,149,206,57,4,192,210,65,210,129,240,178,105,\n                     228,108,245,148,140,40,35,195,38,58,65,207,215,253,65,85,208,76,62,3,237,55,89,\n                     232,50,217,64,244,157,199,121,252,90,17,212,203,149,152,140,187,234,177,73,174,\n                     193,100,192,143,97,53,145,135,19,103,13,90,135,151,199,91,239,247,33,39,145,\n                     101,120,99,3,186,86,99,41,237,203,111,79,220,135,158,42,30,154,120,67,87,167,\n                     135,176,183,191,253,115,184,21,233,58,129,233,142,39,128,211,118,137,139,255,\n                     114,20,218,113,154,27,127,246,250,1,8,198,250,209,92,222,173,21,88,102,219);\n\nint noise2(int x, int y)\n{\n    int tmp = hash[(y + SEED) % 256];\n    return hash[(tmp + x) % 256];\n}\n\nfloat lin_inter(float x, float y, float s)\n{\n    return x + s * (y-x);\n}\n\nfloat smooth_inter(float x, float y, float s)\n{\n    return lin_inter(x, y, s * s * (3.0-2.0*s));\n}\n\nfloat noise2d(float x, float y)\n{\n    int x_int = int(x);\n    int y_int = int(y);\n    float x_frac = fract(x);\n    float y_frac = fract(x);\n    int s = noise2(x_int, y_int);\n    int t = noise2(x_int+1, y_int);\n    int u = noise2(x_int, y_int+1);\n    int v = noise2(x_int+1, y_int+1);\n    float low = smooth_inter(float(s), float(t), x_frac);\n    float high = smooth_inter(float(u), float(v), x_frac);\n    return smooth_inter(low, high, y_frac);\n}\n\nfloat perlin2d(float x, float y, float freq, int depth)\n{\n    float xa = x*freq;\n    float ya = y*freq;\n    float amp = 1.0;\n    float fin = 0.0;\n    float div = 0.0;\n\n    int i;\n    for(i=0; i<depth; i++)\n    {\n        div += 256.0 * amp;\n        fin += float(noise2d(xa, ya)) * amp;\n        amp /= 2.0;\n        xa *= 2.0;\n        ya *= 2.0;\n    }\n\n    return fin/div;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 349], [352, 352, 409, 409, 1149]], "test": "untested"}
{"id": "WsVcRc", "name": "firezebra", "author": "lennyjpg", "description": "asdfasdfasdf", "tags": ["noise", "stripes", "motion", "pattern", "mono"], "likes": 13, "viewed": 484, "published": 3, "date": "1603395538", "time_retrieved": "2024-07-30T20:38:42.858381", "image_code": "vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    float t = iTime * 1.2 + uv.y;\n    float a = snoise(uv * 2.4 + vec2(0.,-t) ) * 3.7 * uv.y;\n    uv += vec2(sin(a), cos(a)) * uv.y * .5;\n    float k = sin(uv.x * 50.) * 3.0;\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 61], [63, 63, 84, 84, 904], [906, 906, 963, 963, 1206]], "test": "untested"}
{"id": "3sKczc", "name": "Feugo Flame", "author": "kstyler", "description": "Rocket flame effect", "tags": ["fire", "rocket", "fuel"], "likes": 4, "viewed": 626, "published": 3, "date": "1603395219", "time_retrieved": "2024-07-30T20:38:43.724067", "image_code": "//https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat random(vec2 p){\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n///////////////////////////////////////\n\nfloat noise(vec2 uv){\n\tvec2 id = floor(uv*10.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*10.));\n    \n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n}\n\nfloat octaves(vec2 uv){\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<5;i++){\n    \tf+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n    return f;\n}\n\nfloat circle(vec2 p){\n    p.y*=2.1;\n    \n\treturn length(p) -.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1);\n    col-=circle(uv*1.);\n\tuv.y/=(sin(iTime*1.5+uv.x)*0.1)+0.4;\n    uv.x-=0.14;\n    uv*=.5;\n    \n    vec2 p = uv;\n    p.x+=iTime*2.;\n    \n    col *=vec3(smoothstep(circle(uv)+sin(-uv.x*10.14)*.1,.8,0.3))*octaves(p);\n    col +=vec3(smoothstep(circle(uv)+sin(-uv.x*10.14)*.1,.78,0.3));\n    col +=2.5*vec3(smoothstep(circle(uv)+sin(-uv.x*10.14)*.1,.8,0.3))*octaves(p-5.);\n \n    col*=1.-vec3(1.,0.5,0.);\n    if(uv.y>0.4 || uv.y <-0.4){\n    \tcol = vec3(0);\n    }\n\n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 218, 218, 307], [349, 349, 370, 370, 710], [712, 712, 735, 735, 881], [883, 883, 904, 904, 948], [950, 950, 1006, 1006, 1587]], "test": "untested"}
{"id": "3sVyzc", "name": "Raymarching Lightcycle", "author": "dnekos", "description": "my midterm for my Introduction to Graphics class\nControls:\nWS: z-axis controls\nAD: x-axis controls\nQE: y-axis controls", "tags": ["raymarching"], "likes": 0, "viewed": 171, "published": 3, "date": "1603391784", "time_retrieved": "2024-07-30T20:38:44.663555", "image_code": "/*\n\tCopyright 2020 Demetrius and Nathan\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t\thttp://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n// rotationMatrix: Basic Rotation matrix for any axis\n//    angle: the vector, in radians, to be translated into a matrix\nmat3 rotationMatrix(in vec2 angle)\n{\n    //credit to wikipedia for matrix\n    \n    float sa = sin(angle.x);\n    float ca = cos(angle.x);\n    float sb = sin(-angle.y);\n    float cb = cos(-angle.y);\n\n    return mat3(ca, sa * sb, sa * cb,\n                0.0, cb, -sb,\n                -sa, ca * sb, cb * ca);\n}\n\n// Sets up and draws scene\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 camuv = fragCoord / iResolution.xy; // used for sampling camera channels\n    \n    // default cam position + position gotten from inputs\n    vec3 rayOrigin = vec3(0.2, 2.3, 1.0) + texture(iChannel0,uv).xyz;\n    // default coords * mouse angle (put through rotation matrix\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0)) * rotationMatrix(texture(iChannel1,uv).xy * 3.14159);\n        \n    // distance from viewport to whatever the ray hits\nsColoredObj dist = shortestDistanceToSurface(rayOrigin, rayDirection, MIN_DIST, MAX_DIST, iTime);    \t\n    // point on object surface\n    vec3 point = rayOrigin + dist.dist * rayDirection;\n    \n\tvec4 color = dist.color; // set color\n    // add pointlights\n    color = calcLighting ( vec3(0.0, 5.0, 1.0),  vec4(1.0),  20.0,  point,\n                    getNormal(point),  rayOrigin, point-rayOrigin,color)\n        + calcLighting ( vec3(3.0, 5.0, 9.0),  vec4(1.0),  20.0,  point,\n                    getNormal(point),  rayOrigin, point-rayOrigin,color);\n\n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Work by Demetrius and Nathan\n// This common tab is responsible for holding all functions and structs relevent to the overall project\n// This tab also contains the code for the main implementations of lighting, ray marching, and scene rendering\n// \n\n#define MAX_STEPS 150\n#define MAX_DIST 150.0\n#define SURF_DIST 0.0001\n#define MIN_DIST 0.0\n  \n// sColoredOBJ: Object in scene\n//    color: color of object\n//    dist:  distance of object calculated by corresponding distance function (initOBJ)  \nstruct sColoredObj\n{\n    vec4 color;\n    float dist;\n};\n        \n// OBJintersect: Returns the intesection of two volumes\n//    distA: the first volume\n//    distA: the second volume\nsColoredObj OBJintersect(sColoredObj distA, sColoredObj distB) \n{\n    if (distA.dist > distB.dist)\n        return distA;\n    return distB;\n}\n\n// OBJintersect: Returns the union of two volumes\n//    distA: the first volume\n//    distA: the second volume\nsColoredObj OBJunion(in sColoredObj distA, in sColoredObj distB) \n{\n    if (distA.dist > distB.dist)\n        return distB;\n    return distA;\n\n}\n\n// OBJintersect: Returns the difference of two volumes\n//    distA: the first volume\n//    distA: the second volume, which will be removed\nsColoredObj OBJdifference(in sColoredObj distA, in sColoredObj distB) \n{\n    //return (distA.dist > -distB.dist) ? distA : distB; //WHY TF DOESNT ISNT THIS LEGAL\n    if (distA.dist > -1.0 * distB.dist)\n        return distA;\n    distB.dist = -1.0 * distB.dist;\n    return distB;\n}\n\n// initSphere: distance to a given sphere\n//    center: Coordinates to manipulate spheres position in coordinate space. Sets center point of sphere\n//    radius: Holds the radius of the spheres\n//    p:      Coordinate in space that a ray hits a sphere created by this function\n//    color:  Holds the color of the sphere\n// Functions main purpose is to algebraically calculate the distance of any point on the sphere\n// from a position passed into the function and return that distance.\nsColoredObj initSphere(vec4 center, float radius, \n                      vec4 color, vec3 p)\n{\n    sColoredObj sphere;\n    sphere.color = color;\n    sphere.dist = length(p - center.xyz) - radius;\n    return sphere;\n}\n\n// initPlane: distance to the plane y = 0\n// p: sample point \n// color: color of plane (used as grid in this instance)\n// Grid design inspired from theraot on shadertoy\n// https://www.shadertoy.com/view/wljXRh\nsColoredObj initPlane(vec4 color, vec3 p, float time)\n{\n\tsColoredObj plane;\n    p.x = p.x - time * 10.0;\n    vec2 tile_coord = p.xz;\n\tfloat size = 2.5;  // size of the tile\n\tfloat edge = size/16.0; // size of the edge\n    float tile_brightness = 0.1; // 0.9 controls the brighness of the face of the tile\n    float edge_brightness = 2.0; // 0.5 controls the darkness of the edge\n\ttile_coord = (mod(tile_coord, size) - mod(tile_coord - edge, size) - edge) * 1.0/size; //Calculates grid\n\tplane.color = vec4(tile_brightness + length(tile_coord) * edge_brightness);\n    plane.dist = p.y;\n    return plane;\n}\n\n// initCylinder: Distance function of a cylinder borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position: Coordinate in space that a ray hits a cylinder created by this function\n//    top:      Holds the coordinate space for the top part of the cylinder (axis alignment)\n//    bottom:   Holds the coordinate space for the bottom part of the cylinder (axis alignment)\n//    center:   Coordinates to manipulate cylinders position in coordinate space. Sets center point of cylinder\n//    radius:   Holds the radius of the cylinder\n//    color:    Holds the color of the cylinder\n// Functions main purpose is to algebraically calculate the distance of any point on the cylinder\n// from a position passed into the function and return that distance.\nsColoredObj initCylinder(vec3 position, vec3 top, vec3 bottom, vec4 center,\n                          float radius, vec4 color)\n{\n\tsColoredObj cylinder;\n\tcylinder.color = color;\n    vec3  bottomToTop = bottom - top;\n    vec3  positionToTop = (position - center.xyz) - top;\n    float fullLength = dot(bottomToTop, bottomToTop);\n    float currentLength = dot(positionToTop, bottomToTop);\n    float x = length(positionToTop * fullLength - bottomToTop * currentLength) - radius * fullLength;\n    float y = abs(currentLength - fullLength * 0.5) - fullLength * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * fullLength;\n    \n    float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n    \n    cylinder.dist = sign(d) * sqrt(abs(d)) / fullLength;\n\treturn cylinder;\n}\n\n// initCone: Distance function of a cone borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position:     Coordinate in space that a ray hits a cone created by this function\n//    top:          Holds the coordinate space for the top part of the cone (axis alignment)\n//    bottom:       Holds the coordinate space for the botom part of the cone (axis alignment)\n//    center:       Coordinates to manipulate cones position in coordinate space. Sets center point of cone\n//    topRadius:    Radius of the top part of the cone\n//    bottomRadius: Radius of the bottom part of the cone\n//    color:        Holds the color of the cone\n// Functions main purpose is to algebraically calculate the distance of any point on the cone\n// from a position passed into the function and return that distance.\nsColoredObj initCone(vec3 position, vec3 top, vec3 bottom, vec4 center, float topRadius,\n\t\t\t\tfloat bottomRadius, vec4 color)\n{\n\tsColoredObj cone;\n\tcone.color = color;\n    float middleRadius  = bottomRadius - topRadius;\n    float bottomFromTop = dot(bottom - top, bottom - top);\n    float positionFromTop = dot((position - center.xyz) - top, (position - center.xyz) - top);\n    float positionIntersect = dot((position - center.xyz) - top, bottom - top) / bottomFromTop;\n\n    float x = sqrt( positionFromTop - positionIntersect * positionIntersect * bottomFromTop );\n\n    float topx = max(0.0, x - ((positionIntersect < 0.5) ? topRadius : bottomRadius));\n    float topy = abs(positionIntersect - 0.5) - 0.5;\n\n    float k = middleRadius * middleRadius + bottomFromTop;\n    float f = clamp( (middleRadius * (x - topRadius) + positionIntersect * bottomFromTop) / k, 0.0, 1.0 );\n\n    float bottomx = x - topRadius - f * middleRadius;\n    float bottomy = positionIntersect - f;\n    \n    float s = (bottomx < 0.0 && topy < 0.0) ? -1.0 : 1.0;\n    \n    cone.dist = s * sqrt( min(topx * topx + topy * topy * bottomFromTop,\n                       bottomx * bottomx + bottomy * bottomy * bottomFromTop) );\n\treturn cone;\n}\n\n// initBox: Distance function of a box borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position:   Coordinate in space that a ray hits a box created by this function\n//    dimensions: Holds the dimensions of the box\n//    center:     Coordinates to manipulate boxes position in coordinate space. Sets center point of box\n//    color:      Holds the color of the box\n// Functions main purpose is to algebraically calculate the distance of any point on the box\n// from a position passed into the function and return that distance.\nsColoredObj initBox( vec3 position, vec3 dimensions, vec4 center, vec4 color)\n{\n\tsColoredObj box;\n\tbox.color = color;\n    \n\tvec3 q = abs(position - center.xyz) - dimensions;\n\tbox.dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\treturn box;\n}\n\n// initTorus: Distance function of a torus borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position: Coordinate in space that a ray hits a torus created by this function\n//    toroid:   axis of revolution against which the torus is drawn to. Usually represented as a circle\n//    center:   Coordinates to manipulate tori position in coordinate space. Sets center point of torus\n//    color:    Holds the color of the torus\n// Functions main purpose is to algebraically calculate the distance of any point on the torus\n// from a position passed into the function and return that distance.\nsColoredObj initTorus( vec3 position, vec2 toroid, vec4 center, vec4 color)\n{\n    sColoredObj torus;\n    torus.color = color;\n    \n    vec2 innerDistance = vec2(length((position.xy - center.xy)) - toroid.x,(position.z - center.z));\n    torus.dist = length(innerDistance) - toroid.y;\n    return torus;\n}\n\n// initCapsule: Distance function of a capsule borrowed from: \n// https://iquilezles.org/articles/distfunctions\n//    position: Coordinate in space that a ray hits a capsule created by this function\n//    top:      Holds the coordinate space for the top part of the capsule (axis alignment)\n//    bottom:   Holds the coordinate space for the bottom part of the capsule (axis alignment)\n//    center:   Coordinates to manipulate capsules position in coordinate space. Sets center point of capsule\n//    radius:   Holds the radius of the capsule\n//    color:    Holds the color of the capsule\n// Functions main purpose is to algebraically calculate the distance of any point on the capsule\n// from a position passed into the function and return that distance.\nsColoredObj initCapsule( vec3 position, vec3 top, vec3 bottom, vec4 center, \n                float radius, vec4 color)\n{\n    sColoredObj capsule;\n    capsule.color = color;\n    \n    vec3 topFromPosition = (position - center.xyz) - top, topFromBottom = bottom - top;\n    float height = clamp( dot(topFromPosition, topFromBottom)\n                         / dot(topFromBottom, topFromBottom), 0.0, 1.0 );\n    capsule.dist = length( topFromPosition - topFromBottom * height ) - radius;\n    return capsule;\n}\n   \n// renderScene: Creates objects according to their distance functions\n//              Adds model to scene by returning the calculated sum distance of all objects\n//    Position: A ray created using ray marching\n//    Color:    Output color\n// Sets up scene for model rendering by creating containers for Objects and using distance functions\n// to fill containers with data for each object being rendered in scene. Also uses union, difference,\n// and intersection functions to determine if space is being displayed, negated, or conjoined \n// Model reference: https://sketchfab.com/3d-models/classic-tron-lightcycle-a9eae73385234105b548b0e35a3e63a4\nsColoredObj renderScene(vec3 position, float time)\n{\n\n    // use Logic to build the correct distance\n\n    // front wheel done\n    sColoredObj d = OBJdifference(initSphere(vec4(-1.5, 1.0, 6.0, 1.0), 1.0, // Front wheel\n                  vec4(1.0, 0.5, 0.0, 1.0), position),\n                  initSphere(vec4(-1.5, 1.0, 5.1, 1.0), 0.8, // Front wheel negative space left\n                  vec4(1.0, 0.5, 0.0, 1.0), position));\n    d = OBJdifference(d,initSphere(vec4(-1.5, 1.0, 6.9, 1.0), 0.8, // Front wheel negative space right\n                  vec4(1.0, 0.5, 0.0, 1.0), position));\n    d = OBJunion(d, initSphere(vec4(-1.5, 1.0, 6.4, 1.0), 0.15, // Front wheel cap left\n                  vec4(1.0), position));\n    d = OBJunion(d, initSphere(vec4(-1.5, 1.0, 5.6, 0.0), 0.15, // Frot wheel cap right\n                  vec4(1.0), position));\n    d = OBJunion(d, initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(-1.5, 1.0, 6.0, 1.0),\n                  0.9, vec4(0.0))); // Front wheel black\n    \n    // grey chasis\n    d = OBJunion(d, initBox(position, vec3(1.5, 0.65, 0.3), vec4(0.0, 1.0, 6.0, 1.0),\n                  vec4(0.7))); // body\n    d = OBJunion(d, initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(1.4, 0.65, 6.0, 1.0),\n                  0.06, vec4(1.0, 0.5, 0.0, 1.0))); // foothold axel thing\n    d = OBJunion(d, initCone(position, vec3(0.0,0.0,0.0), vec3(1.4,0.0,0.0), vec4(-.7, 1.0, 6.0, 1.0),\n                  0.6, 0.2, vec4(0.7))); // Front wheel cone\n    d = OBJunion(d, initCone(position, vec3(0.0,-0.1,0.0), vec3(-.5,0.0,0.0), vec4(0.95, 0.87, 5.8, 1.0),\n                  0.2, 0.1, vec4(0.7))); // Left pipe bit\n    d = OBJunion(d, initCone(position, vec3(0.0,-0.1,0.0), vec3(-.5,0.0,0.0), vec4(0.95, 0.87, 6.2, 1.0),\n                  0.2, 0.1, vec4(0.7))); // right pipe bit);\n\td = OBJunion(d, initBox(position, vec3(1.0, 0.65, 0.02), vec4(1.7, 1.0, 5.72, 1.0),\n                  vec4(0.7))); // backwheel frame left\n    d = OBJunion(d, initBox(position, vec3(1.0, 0.65, 0.02), vec4(1.6, 1.0, 6.28, 1.0),\n                  vec4(0.7))); // backwheel frame right\n    d = OBJunion(d, initCylinder(position, vec3(0.5,0.3,0.0), vec3(-1.2,-0.5,0.0), vec4(2.2, 1.6, 6.0, 1.0),\n                  0.30, vec4(0.7))); // Back Wheel body cover);\n    d = OBJunion(d, initCone(position, vec3(0.0,0.0,-0.08), vec3(-.65,-0.15,0.0), vec4(2.65,1.7, 5.8, 1.0),\n                  0.2, 0.1, vec4(0.7))); // Left exhaust\n    d = OBJunion(d, initCone(position, vec3(0.0,0.0,0.08), vec3(-.65,-0.15,0.0), vec4(2.65,1.7, 6.2, 1.0),\n                  0.2, 0.1, vec4(0.7))); // right exhaust\n\n    \n    d = OBJdifference(d, initCylinder(position, vec3(0.55,0.3,0.0), vec3(-1.25,-0.5,0.0), vec4(2.2, 1.6, 6.0, 1.0),\n                  0.27, vec4(0.7))); //Back Wheel body cover negative\n    d = OBJdifference(d, initCylinder(position, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.28, vec4(0.7))); //back wheel 'axis' negative\n    d = OBJdifference(d,initBox(position, vec3(0.5, 1.5, 0.5), vec4(3.1, 1.0, 6.0, 1.0),\n                  vec4(0.7))); // backwheel cutoff negative\n    d = OBJdifference(d, initBox(position, vec3(0.7, 0.8, 0.25), vec4(2.8, 1.0, 6.0, 1.0),\n                  vec4(0.7))); // backwheel cutoff negative\n\n\n    //orange body\n    sColoredObj top = OBJunion(initCylinder(position, vec3(0.0,0.0,0.2), vec3(0.0,0.0,-0.2), vec4(0.1, -3.6, 6.0, 1.0),\n                  6.0, vec4(1.0, 0.5, 0.0, 1.0)), // Top piece\n                  initCylinder(position, vec3(0.0,0.0,0.39), vec3(0.0,0.0,-0.39), vec4(0.1, -3.66, 6.0, 1.0),\n                  6.0, vec4(1.0, 0.5, 0.0, 1.0))); // Top main bit);\n    top = OBJintersect(top, initBox(position, vec3(2.3, 1.0, 0.9), vec4(0.0, 1.74, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0))); // Orange body base cuttoff negative\n    top = OBJdifference(top,initCone(position, vec3(0.0,0.0,0.0), vec3(1.6,0.0,0.0), vec4(-.78, 1.0, 6.0, 1.0),\n                  0.7, 0.2, vec4(1.0, 0.5, 0.0, 1.0))); // orage top front slant negative\n    top = OBJdifference(top,initBox(position, vec3(0.7, 0.5, 0.9), vec4(-1.76, 1.33, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0))); // orange body wheel negative\n\ttop = OBJdifference(top,initBox(position, vec3(0.7, 0.5, 0.9), vec4(0.4, 0.6, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0)));\n    top = OBJdifference(top,initCone(position, vec3(0.0,0.0,0.0), vec3(0.3,-0.7,0.0), vec4(0.48, 0.83, 6.0, 1.0),\n                  0.8, 0.8, vec4(1.0, 0.5, 0.0, 1.0))); // orage top front slant negative\n\ttop = OBJdifference(top,initBox(position, vec3(0.5, 0.8, 0.9), vec4(2.0, 0.6, 6.0, 1.0),\n                  vec4(1.0, 0.5, 0.0, 1.0)));\n    top = OBJdifference(top,initCylinder(position, vec3(0.5,0.5,0.0), vec3(-0.8,-0.2,0.0), vec4(2.44, 1.36, 5.4, 1.0),\n                  0.35, vec4(1.0, 0.5, 0.0, 1.0))); // orange body Back Wheel cover negative left\n    top = OBJdifference(top,initCylinder(position, vec3(0.5,0.5,0.0), vec3(-0.8,-0.2,0.0), vec4(2.44, 1.36, 6.6, 1.0),\n                  0.35, vec4(1.0, 0.5, 0.0, 1.0))); // orange body Back Wheel cover negative right\n\n    \n    // windows\n    sColoredObj windows = OBJunion(initSphere(vec4(2.6, 1.0, 6.0,0.0), 0.15, // back wheel cap\n                  vec4(1.0), position), \n                  initCapsule(position, vec3(0.5, 0.0, 0.0), vec3(-0.5, 0.0, 0.0), vec4(-0.4, 1.8, 5.45, 1.0), \n                  0.3, vec4(0.0))); // right window\n    windows = OBJunion(windows, initCapsule(position, vec3(0.5, 0.0, 0.0), vec3(-0.5, 0.0, 0.0), vec4(-0.47, 1.8, 6.45, 1.0), \n                0.3, vec4(0.0))); //left window\n    windows = OBJdifference(windows, initBox(position, vec3(1.3, 0.8, 1.25), vec4(-0.4, 0.99, 5.55, 1.0),\n                  vec4(0))); // Window lower cutoff\n    windows = OBJdifference(windows, initBox(position, vec3(1.3, 0.8, 1.25), vec4(1.2, 1.5, 5.55, 1.0),\n                  vec4(0))); // Window back cutoff\n    windows = OBJdifference(windows, initCone(position, vec3(0.0,0.0,0.0), vec3(1.2,0.0,0.0), vec4(-1.3, 2.4, 5.45, 1.0),\n                  0.6, 0.3, vec4(0.0))); // window left slant negative\n    windows = OBJdifference(windows, initCone(position, vec3(0.0,0.0,0.0), vec3(1.2,0.0,0.0), vec4(-1.3, 2.4, 6.45, 1.0),\n                  0.6, 0.3, vec4(0.0))); // window right slant negative\n\t\n    // trail\n    sColoredObj trail = OBJdifference( initBox(position, vec3(500.0, 0.8, 0.1), vec4(502.6, 1.0, 6.0, 1.0),\n                  vec4(mix(vec4(1.0),vec4(1.0, 0.5, 0.0, 1.0),position.y / 0.8))), // trail\n    initCylinder(position, vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, -1.0), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.8, vec4(0.0)));\n    d = OBJunion(d, trail);\n\n\n    // back wheel\n    sColoredObj wheel = OBJdifference(initTorus(position, vec2(0.8,0.19), vec4(2.6, 1.0, 6.0, 1.0), vec4(1.0, 0.5, 0.0, 1.0)),\n                  initCylinder(position, vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.7, vec4(1.0, 0.5, 0.0, 1.0))); // Back Wheel Negative Space\n    wheel = OBJunion(wheel, initCylinder(position, vec3(0.0, 0.0, 0.02), vec3(0.0, 0.0, -0.02), vec4(2.6, 1.0, 6.0, 1.0),\n                  0.7, vec4(0.0))); // Back Wheel black\n    d = OBJunion(d, initSphere(vec4(2.6, 1.0, 6.0,0.0), 0.15, // back wheel cap\n                  vec4(1.0), position));\n                       \n    //combining subobjects\n    d = OBJunion(d, wheel);\n    d = OBJunion(d, top);\n\td = OBJunion(d, windows);\n    d = OBJunion(d, initPlane(vec4(1.0), position - vec3(0.08).y, time));\n        \n    return d;\n}\n\n// RayMarching Function: Draws scene by getting a distance for every object in the scene from the \n//                       Calculated position found from ray origin and ray direction\n//    color:             Output color\n//    eye:               ray origin\n//    marchingDirection: ray direction\n//    start:             Minimum distance ray can travel while searching for Objects\n//    end:               Maximum distance ray can travel while searching for Objects\nsColoredObj shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, float time) {\n    //credit to https://www.shadertoy.com/view/4tcGDr\n    sColoredObj dist;\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        dist = renderScene(eye + depth * marchingDirection, time);\n        if (dist.dist < SURF_DIST) {\n            dist.dist = depth;\n\t\t\treturn dist;\n        }\n        depth += dist.dist;\n        if (depth >= end) {\n            dist.dist = end;\n\t\t\treturn dist;\n        }\n    }\n    dist.dist = end;\n\treturn dist;\n}\n\n// getNormal: Calculate normal for given rat\n//    p: A ray created using ray marching\n// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n// https://www.shadertoy.com/view/XlGBW3\nvec3 getNormal(vec3 p)\n{  \n    float d = renderScene(p, 0.0).dist;\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n    renderScene(p - e.xyy, 0.0).dist,\n    renderScene(p - e.yxy, 0.0).dist,\n    renderScene(p - e.yyx, 0.0).dist);\n    \n    return normalize(n);\n}\n\n// calcLighting: calculates Lambertian and Blinn-Phong reflectance, and returns part of the summation of the final color\n//    light: the current Point Light\n//    position:     point on the sphere that we are drawing\n//    normal:       normal vector from point\n//    rayOrigin:    input ray origin\n//\t  viewVector:\tvector from point to camera\nvec4 calcLighting (in vec3 lightpos, in vec4 lightcolor, float lightintense, in vec3 position,\n                   in vec3 normal, in vec3 rayOrigin, in vec3 viewVector, in vec4 Objectcolor)\n{\n    //Taken from Demetri's Lab 4\n    // LAMBERTIAN REFLECTANCE\n    vec3 lightVector = lightpos.xyz - position; // get vector of position to the light\n\tfloat lightLength = length(lightVector); // get length of light vector\n    lightVector = lightVector / lightLength; // normalizes vector\n   \n    float diffuseCoefficient = max(0.0, dot(lightVector, normal)); // get coefficient\n   \n    float intensityRatio = lightLength/lightintense; // simplifying attenuation equation by doing this once\n    float attenuation = 1.0 / (1.0 + intensityRatio +\n                             (intensityRatio * intensityRatio)); // get attenuation\n    float Lambertian = diffuseCoefficient * attenuation; // final lambertian\n\n    // BLINN-PHONG REFLECTANCE\n   \n    float specular = max(0.0,dot(normal, normalize(viewVector + lightVector))); // get base specular coefficient\n    specular *= specular; // specularCoefficient^2\n    specular *= specular; // specularCoefficient^4\n    specular *= specular * specular * specular; // ^16\n    specular *= specular * specular * specular; // ^64\n\n    specular *= 4.0; // Blinn coefficient\n   \n    //return (Lambertian * vec4(normal * 0.5 + 0.5, 1.0) + specular) * lightcolor;\n    return (Lambertian * Objectcolor + specular) * lightcolor;\n}", "buffer_a_code": "/*\n\tCopyright 2020 Demetrius and Nathan\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t\thttp://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n/*\n    Credit to Andrew Hunt for advice on keyboard controls\n*/\n\n// Keyboard constants definition\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\n\n// getKey: texel fetches input from keyboard\n//    channel: the channel that the keyboard is on, iChannel1\n//    key1:    first ASCII key\n//    key2:    second ASCII key (for WASD)\nfloat getKey(sampler2D channel, int key1, int key2)\n{\n    return texelFetch(channel, ivec2(key1, 0), 0).x + \n        texelFetch(channel, ivec2(key2, 0), 0).x;\n}\n\n//determines new movement and stores camera position in Buffer A\n// Controls: \n//    WS/Up Down arrows - Z axis\n//    AD/Left Right arrows - X axis\n//    QE - Y axis\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //get UV and fetch last recorded position\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 previouscoord = texture(iChannel0,uv);\n    \n    //get all inputs\n    float forward = getKey(iChannel1, KEY_UP, KEY_W);\n    float left = getKey(iChannel1, KEY_LEFT, KEY_A);\n    float back = getKey(iChannel1, KEY_DOWN, KEY_S);\n    float right = getKey(iChannel1, KEY_RIGHT, KEY_D);\n\tfloat up = getKey(iChannel1, KEY_Q, KEY_Q) * 0.5;\n\tfloat down = getKey(iChannel1, KEY_E, KEY_E) * 0.5;\n\n    //add inputs with previous position for new position\n    fragColor = previouscoord + vec4(right - left, up - down, forward - back, 0.0) * 0.1;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n\tCopyright 2020 Demetrius and Nathan\n\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n\t\thttp://www.apache.org/licenses/LICENSE-2.0\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n/*\n    Credit to Andrew Hunt for advice on keyboard controls\n*/\n\n//Sets up mouse interactivity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get uv\n    vec2 invReso = 1.0 / iResolution.xy;\t\n    vec2 uv = fragCoord * invReso;\n\n    // sample previous mouse coordinate\n    vec4 mouse = texture(iChannel1,uv);\n    vec2 mousecurrent = mouse.xy;\n    vec2 mouseclick = mouse.zw;\n    \n    if (iMouse.z >= 0.0) // if mouse down\n    {\n        vec2 newmouse = iMouse.xy * invReso; // take in new mouse variables\n        vec2 newclick = abs(iMouse.zw) * invReso;\n        \n        // get centralized distance of mouse to clicked coord\n        vec2 mousefromclick = (newmouse - 0.5) - (newclick - 0.5);\n        vec2 radian = mouseclick - mousefromclick; // get difference from last frame\n\t\tfragColor = vec4(radian, mouseclick);\n    }\n    else\n    {\n        fragColor = vec4(mousecurrent, mousecurrent); // unchanged, return last frame\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyzc.jpg", "access": "api", "license": "apache-2.0", "functions": [[573, 695, 731, 768, 1002], [1004, 1031, 1088, 1088, 2182]], "test": "untested"}
{"id": "3dVyzc", "name": "Metamorphic rock texture", "author": "jarble", "description": "A simple edit of my [url=https://www.shadertoy.com/view/3sKyDw]\"Cells Under a Microscope\"[/url] shader.", "tags": ["fractal", "marble", "metamorphic"], "likes": 7, "viewed": 356, "published": 3, "date": "1603390764", "time_retrieved": "2024-07-30T20:38:45.445464", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col;\n    float t = iTime*.1;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t);\n        for(int i=0;i<9;i++)\n        {\n            float factor = 1.5;\n            vec2 uv1 = uv;\n            uv /= factor;\n            uv += uv1;\n            uv += sin(uv.yx)/factor;\n            uv *= factor;\n            col += sin(uv.y-uv.x)+cos(uv.x-uv.y);\n        }\n    fragColor = vec4(vec3(col)*100.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 475]], "test": "untested"}
{"id": "3lKXDm", "name": "Social Force Model", "author": "Txoka", "description": "just people escaping a room", "tags": ["escape"], "likes": 16, "viewed": 404, "published": 3, "date": "1603387697", "time_retrieved": "2024-07-30T20:38:46.230366", "image_code": "/*\nbased on \nhttps://addi.ehu.es/handle/10810/38527\n(work of one of my ex-teachers)\n(which you wont understand because it\n\tis in a local language)\n\nACCELERATE THE SHADER:\n(function(){if(Effect.prototype.Paint.toString().length>1000){_Paint=Effect.prototype.Paint;} Effect.prototype.Paint = function(...args){for(var i=0; i<50;i++){_Paint.apply(this,args);}}})()\n*/\nvoid mainImage(out vec4 Q, in vec2 U){\n    vec2 uv=(U*2.-R.xy)/R.y;\n    Q=vec4(0);\n    \n    \n    #ifdef FOLLOW\n    Q.b+=point(uv,person_radius);\n    vec4 who=tf(ivec2(PERSON_TO_FOLLOW,0));\n    vec2 dir=normalize(who.zw);\n    #ifdef ROTATE\n    uv=vec2(dot(uv,dir.yx*vec2(-1,1)),dot(uv,dir));\n    #endif\n    uv+=who.xy;\n    #endif\n    \n    for(int i=0;i<N;i++){\n        #ifdef FOLLOW\n        if(i==PERSON_TO_FOLLOW)continue;\n        #endif\n        Q.r+=point(uv-tf(ivec2(i,0)).xy,person_radius);\n    }\n    \n    #ifdef FOLLOW\n    Q.r*=attention(who.zw,uv-who.xy);\n    #endif\n    Q=vec4(0,0,Q.b,0)+Q.r;\n    \n    \n    Q.r+=point(uv-objective,exit_size);\n    \n    float pix=1./R.y;\n    \n   \tfloat o=smoothstep(pix*3.,0.,obstacles(uv));\n    \n    \n    \n\tQ.rgb=mix(Q.rgb,vec3(.3,.3,.1),o);\n    //if(obstacles==0.)Q=vec4(.3,.3,.1,0);\n    //Q=texture(iChannel1,(U/R.y*float(N))/R.xy);\n    //Q=tf1(ivec2(U/R.y*float(N)));\n    #ifdef SEE_WALL_DISTANCES\n    Q*=0.4;\n    float d=obstacles(uv);\n    float c=clamp(sin(100.*d),0.,1.);\n    if(d<0.){\n        Q.r+=c;\n    }else{\n        Q.b+=c;\n    }\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define FOLLOW\n//#define ROTATE\nconst int PERSON_TO_FOLLOW=0;\n//#define AVOID_OBSTACLE\n//#define SEE_WALL_DISTANCES\n//#define RANDOMIZE_SPIRAL_INITIALIZATION\n\nfloat dot2(vec2 x){return dot(x,x);}\nfloat point(vec2 x,float r){return clamp(0.,1.,r*r/dot2(x));}\n\n#define R iResolution\n#define tf(id) texelFetch(iChannel0,id,0)\n#define tf1(id) texelFetch(iChannel1,id,0)\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec4 hash42(vec2 p){\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n#define key(id) texelFetch(iChannel2,ivec2(id,0),0).x>0.\nint kSpace=32;\n\nconst float eps=1e-4;\nconst float pi=4.*atan(1.);\nconst float golden_angle=(3.-sqrt(5.))*pi;\n\nfloat sphere(vec2 p,float r){return length(p)-r;}\nfloat box_(vec2 p,vec2 b){return length(max((abs(p)-b),0.));}\nfloat box(vec2 p, vec2 size){\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y),0.0)+length(max(d, 0.0));\n}\n\n//VARIABLES\nconst int N=288;\n\nfloat obstacles(vec2 p){\n    //return 1.;\n    float sph=sphere(p-vec2(0.8,0),0.09);\n    float box0=box(p-vec2(1.1,-0.55)\t,vec2(0.05,0.40));\n    float box1=box(p-vec2(-0.9,0)\t\t,vec2(0.05,0.95));\n    float box2=box(p-vec2(0.1,0.9)\t\t,vec2(1.05,0.05));\n    float box3=box(p-vec2(0.1,-0.9)\t\t,vec2(1.05,0.05));\n    float box4=box(p-vec2(1.1,0.55)\t\t,vec2(0.05,0.40));\n    \n    //float box5=box(p-vec2(0.8,0.)\t\t,vec2(0.01,0.35));\n    return min(box0,min(box1,min(box2,min(box3,min(box4,sph)))));\n}\n\nconst float dt=2e-2;\n\nconst vec2 objective=vec2(1.5,0);\n\nconst float alpha=0.5;\nconst float obj_vel=1.;\nconst float max_vel=2.;\n\nconst float exit_size=0.07;\nconst float person_mass=1.;\nconst float person_radius=0.01;\nconst float person_A=3.;\nconst float person_B=0.1;\nconst float person_k0=8000.;\nconst float person_k1=5000.;\nconst float person_A_wall=9.;\nconst float person_B_wall=0.05;\nconst float attention_lambda=0.1;\n\nfloat attention(vec2 vel,vec2 b){\n    //return 1.;\n    if(dot2(vel)==0.)return 1.;\n\treturn mix(dot(normalize(vel),normalize(b))*0.5+0.5,1.,attention_lambda);\n}", "buffer_a_code": "void mainImage(out vec4 Q, in vec2 U){\n    if(int(U.y)==0&&int(U.x)<N){\n        ivec2 id=ivec2(U.x,0);\n        Q=tf(id);\n        if(!all(equal(Q,vec4(-100)))){\n            //Q.zw*=0.95;\n            \n            //DIRECTOR FORCE\n            vec2 r=normalize(objective-Q.xy);\n            vec2 a=(obj_vel*r-Q.zw)/alpha;\n            \n            \n            //PERSON INTERACTIONS\n            vec2 f_persons=vec2(0);\n            for(int i=0;i<N;i++)f_persons+=tf1(ivec2(i,id.x)).xy;\n            \n            \n            //OBSTACLES\n            float pix=1./R.y;\n            float d=obstacles(Q.xy);\n            vec2 dir=\n                vec2(obstacles(Q.xy+vec2(pix,0)),obstacles(Q.xy+vec2(0,pix)))-\n                vec2(obstacles(Q.xy-vec2(pix,0)),obstacles(Q.xy-vec2(0,pix)));\n            \n            float f_modulo=person_A_wall*exp((person_radius-d)/person_B_wall);\n            vec2 f_obstacles=vec2(0);\n            if(dot2(dir)!=0.){\n                dir=normalize(dir);\n                f_obstacles=dir*f_modulo;\n                \n                #ifdef AVOID_OBSTACLE\n                f_obstacles+=dir.yx*vec2(-1,1)*f_modulo;\n                #endif\n                //collision stuff\n            \tfloat collision=person_radius-d;\n        \t\tif(collision>0.){\n        \t\t\tf_obstacles+=person_k0*collision*dir;\n        \t\t\tf_obstacles+=person_k1*collision*Q.zw*dir.yx*vec2(-1,1);\n        \t\t}\n            }\n            \n            vec2 f=f_persons+f_obstacles;\n            \n\n        \tQ.zw+=(a+f/person_mass)*dt;\n            if(dot2(Q.zw*dt)>max_vel*max_vel)Q.zw=normalize(Q.zw)*max_vel;\n        \tQ.xy+=Q.zw*dt;\n            \n        \tif(dot2(Q.xy-objective)<exit_size*exit_size)Q=vec4(-100);\n        }\n        if(iFrame==0||key(kSpace)){\n        \t//Q=hash42(U+iTime)*2.-1.;\n            //Q.xy*=0.7;\n        \t//Q.zw*=0.4;\n            float a=floor(U.x)*golden_angle;\n            #ifdef RANDOMIZE_SPIRAL_INITIALIZATION\n            Q.xy=vec2(sin(a),cos(a))*sqrt(hash11(U.x+iTime))*0.7;\n            #else\n            Q.xy=vec2(sin(a),cos(a))*sqrt(floor(U.x)/float(N))*0.7;\n            #endif\n            Q.zw=(hash22(U+iTime)*2.-1.)*0.2;\n        }\n   \t}\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 Q, in vec2 U){\n    ivec2 id=ivec2(U);\n    \n    if(id.x<N&&id.y<N&&id.x!=id.y){\n        vec4 p0=tf(ivec2(id.y,0));\n        vec4 p1=tf(ivec2(id.x,0));\n        \n        float d=distance(p0.xy,p1.xy);\n        vec2 n=normalize(p0.xy-p1.xy);\n        vec2 f=vec2(0);\n        f=+person_A*exp((2.*person_radius-d)/person_B)*n;\n        \n        \n        f*=attention(p0.zw,p1.xy-p0.xy);\n        \n        \n        //no effect unless they collide\n        float collision=2.*person_radius-d;\n        if(collision>=0.){\n        \tf+=person_k0*collision*n;\n        \tf+=person_k1*collision*(p1.zw-p0.zw)*n.yx*vec2(-1,1);\n        }\n        \n        Q=vec4(f,0,0);\n        if(iFrame==0)Q=vec4(0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 365, 403, 403, 1457]], "test": "untested"}
{"id": "3dVcRc", "name": "Weird Distortion 2", "author": "Leasel", "description": "Uses a buffer to update its own position from a texture. Then the pos(in uv space) is used to search for other pixels in a texture. ART!", "tags": ["buffer", "sequel"], "likes": 3, "viewed": 302, "published": 3, "date": "1603385952", "time_retrieved": "2024-07-30T20:38:46.977368", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.yxzw = texture(iChannel1,Smp(fragCoord*dif.xy).xy);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord.xy*dif.xy;\n    \n    //First value for intiating the procedure\n    vec2 Pos = (iFrame == 0 ? fragCoord.xy*dif.xy : Smp(uv).xy);\n    \n    //Set to 1. for an also interesting effect\n    vec2 Val = (texture(iChannel1, Pos).xy-0.5)*dif.xy;\n    \n    fragColor = vec4(Pos + Val,0.,0.); \n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//General\n#define dif vec3(1./iResolution.xy,0.)\n#define Smp(uv) texture(iChannel0,uv)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 125]], "test": "untested"}
{"id": "WdKcRc", "name": "Spherical View Challenge", "author": "oneshade", "description": "I've recently been interested in codegolfing and decided to try it. Since I'm new to this, please tell me if I'm doing something incorrectly.", "tags": ["spherical", "challenge", "360", "codegolf"], "likes": 2, "viewed": 156, "published": 3, "date": "1603385356", "time_retrieved": "2024-07-30T20:38:47.878958", "image_code": "/*And another 5 chars (now 245 chars)*/\nvoid mainImage(out vec4 o, vec2 u)                                                   \\\n{\n    vec4 A = vec4(0,11,33,0), d, i=A-A,\n         r = cos( A + (u / iResolution.xy * vec2(2,1)*3.14 ).xyxy );\n    mat2 t = mat2( cos( A -iTime ) );\n    r.xz *= t *r.w; r.yz *= t;\n    for ( o = r ; o.w++ < 9.; i -= d.x )\n        d = max( d = max( d = abs(r*i), .39 - max( d , d.zxyw ) ),\n                 max( d.y, d.z ) ) -.2,\n        d.x < .002 ? o++ : o;\n}\n\n/**/\n\n/*And another 8 chars (now 250 chars)*\n#define mainImage(o,u)                                                    \\\n    vec4 A = vec4(0,11,33,0), d, i=A-A,                                   \\\n         r = cos( A.xyyx + (u / iResolution.xy * vec2(2,1)*3.14 ).xyxy ); \\\n    mat2 t = mat2( cos(iTime + A) );                                      \\\n    r.xz *= t *r.w; r.yz *= t;                                            \\\n    for ( o = r ; o.w++ < 9.; i -= d.x )                                  \\\n        d = max( d = max( d = abs(r*i), .39 - max( d , d.zxyw ) ),        \\\n                 max( d.y, d.z ) ) -.2,                                   \\\n        d.x < .002 ? o++ : o\n**/\n\n/*And another 18 chars (now 258 chars)*\n#define mainImage(o,u)                                                     \\\n    vec4 A = vec4(0,11,33,0), p,v,d, m, i=A-A,                             \\\n         r = cos( A.xyyx + (u / iResolution.xy * vec2(2,1)*3.14 ).xyxy );  \\\n    mat2 t = mat2( cos(iTime + A) );                                       \\\n    r.xz *= t *r.w; r.yz *= t;                                             \\\n    for (o = r ; o.w++ < 9.; i -= d.x )                                    \\\n        d = max( m = max( p = abs( r * i ), v = .39 - max( p , p.zxyw ) ), \\\n                 max(m.y,m.z ) ) -.2,                                      \\\n        d.x < .002 ? o++ : o\n**/\n\n/*And another 4 chars (now 272 chars)*\n#define mainImage(o,u)                                          \\\n    vec4 A = vec4(0,11,33,0), p,v,d, i=A-A,                     \\\n         r = cos( A.xyyx + (u / iResolution.xy * vec2(2,1)*3.14 ).xyxy);  \\\n    mat2 t = mat2( cos(iTime + A) );                            \\\n    r.xz *= t *r.w; r.yz *= t;                                  \\\n    for (o = r ; o.w++ < 9.; i -= d.x )                         \\\n        d = max(  max( v = .39 - max( p = abs(r*i) , p.zxyw ),  \\\n                          max( v.y, v.z ) ),                    \\\n                  max( p, max( p.y, p.z ) ) ) -.2,              \\\n        d.x < .002 ? o++ : o\n**/        \n\n/*Fabrice drops 3 more chars (now 276 chars)*\n#define mainImage(o,u)                                          \\\n    vec4 A = vec4(0,11,33,0), p,v,d, i=A-A,                     \\\n         r = cos( A.xyyx + (u / iResolution.xy).xyxy * vec4(2,1,2,1)*3.14 );  \\\n    mat2 t = mat2( cos(iTime + A) );                            \\\n    r.xz *= t *r.w; r.yz *= t;                                  \\\n    for (o = r ; o.w++ < 9.; i -= d.x )                         \\\n        d = max(  max( v = .39 - max( p = abs(r*i) , p.zxyw ),  \\\n                          max( v.y, v.z ) ),                    \\\n                  max( p, max( p.y, p.z ) ) ) -.2,              \\\n        d.x < .002 ? o++ : o\n**/\n\n/*Fabrice reaches the 2tweet milestone (279 chars)*\n#define mainImage(o,u)                                      \\\n    vec2 U = u / iResolution.xy * vec2(2,1)*3.14;           \\\n    vec4 A = vec4(0, 11, 33, 0), p,v,d, i=A-A,              \\\n         r = cos(U.xyxy+A.xyyx );                           \\\n    mat2 t = mat2( cos(iTime + A) );                        \\\n    r.xz *= t *r.w; r.yz *= t;                              \\\n    for (o = r ; o.w++ < 9.; i -= d.x )                     \\\n        d = max(  max( v = .39 - max( p = abs(r*i) , p.zxyw ),  \\\n                          max( v.y, v.z ) ),                \\\n                  max( p, max( p.y, p.z ) ) ) -.2,          \\\n        d.x < .002 ? o++ : o\n**/\n\n/*I tweaked the parameters and dropped 1 char (now 298 chars)*\n#define mainImage(o,u)                                      \\\n    vec2 U = u / iResolution.xy * vec2(2,1)*3.14,           \\\n         c = cos(U), s = sin(U);                            \\\n    vec4 r = vec4(c.x * c.y, s.y, s.x * c.y, 0), p, v, d;   \\\n    mat2 t = mat2( cos(iTime + vec4(0, 11, 33, 0)) );       \\\n    r.xz *= t; r.yz *= t;                                   \\\n    for (o = r ; o.w++ < 9.; r.w -= d.x )                   \\\n        v = .39 - max( p = abs( r * r.w ) , p.zxyw ),       \\\n        d = max(  max( p, max( p.y, p.z ) ),                \\\n                  max( v, max( v.y, v.z ) ) ) -.2,          \\\n        d.x < .002 ? o++ : o\n**/\n\n/*And yet another 1 char (now 299 chars)*\n#define mainImage(o,u)                                      \\\n    vec2 U = u / iResolution.xy * vec2(2,1)*3.14,           \\\n         c = cos(U), s = sin(U);                            \\\n    vec4 r = vec4(c.x * c.y, s.y, s.x * c.y, 0), p, v, d;   \\\n    mat2 t = mat2( cos(iTime + vec4(0, 11, 33, 0)) );       \\\n    r.xz *= t; r.yz *= t;                                   \\\n    for (o = r ; o.w++ < 99.; r.w -= d.x )                  \\\n        v = .39 - max( p = abs( r * r.w ) , p.zxyw ),       \\\n        d = max(  max( p, max( p.y, p.z ) ),                \\\n                  max( v, max( v.y, v.z ) ) ) -.2,          \\\n        d.x < .001 ? o++ : o\n**/\n\n/*And another 13 chars (now 300 chars)*\n#define mainImage(o,u)                                      \\\n    vec2 U = u / iResolution.xy * vec2(2,1)*3.14,           \\\n         c = cos(U), s = sin(U);                            \\\n    vec4 r = vec4(c.x * c.y, s.y, s.x * c.y, 0), p, v, d;   \\\n    mat2 t = mat2( cos(iTime + vec4(0, 11, 33, 0)) );       \\\n    r.xz *= t; r.yz *= t;                                   \\\n    for (o = r ; o.w++ < 99.; r.w -= d.x )                  \\\n        v = -max( p = abs( r * r.w ) , p.zxyw ),            \\\n        d = max(  max( p, max( p.y, p.z ) ) -.2,            \\\n                  max( v, max( v.y, v.z ) ) +.19 ),         \\\n        d.x < .001 ? o++ : o\n**/\n\n/*And another 19 chars (now 313 chars)*\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 U = u / iResolution.xy * vec2(2,1)*3.14,\n         c = cos(U), s = sin(U); \n    vec4 r = vec4(c.x * c.y, s.y, s.x * c.y, 0), p, V, d;\n//  vec4 A = cos( vec4(U,U+11.)),\n//       r = vec4(A.x * A.y, A.w, A.z * A.y, 0); \n    mat2 t = mat2( cos(iTime + vec4(0, 11, 33, 0)) ); \n    r.xz *= t; r.yz *= t; \n \n    for (o = r ; o.w++ < 99.; r.w -= d.x )\n        V = max( p = abs( r * r.w ) , p.zxyw ),\n        d = max(  max( p, max( p.y, p.z ) ) -.2,\n                 -min( V, min( V.y, V.z ) ) +.19 ), \n        d.x < .001 ? o++ : o;  \n}\n**/\n\n/*And another 24 chars (now 332 chars)*\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 U = u / iResolution.xy * vec2(2,1)*3.14,\n         c = cos(U), s = sin(U); \n    vec4 r = vec4(c.x * c.y, s.y, s.x * c.y, 0);\n//  vec4 A = cos( vec4(U,U+11.)),\n//       r = vec4(A.x * A.y, A.w, A.z * A.y, 0); \n    mat2 t = mat2( cos(iTime + vec4(0, 11, 33, 0)) ); \n    r.xz *= t; r.yz *= t; \n    o = r;\n\n    for (int i=0; i++ < 99; ) {\n        vec3  p = abs( r.xyz * r.w ),\n              V = max( p.zxy ,p );\n        float d = max( max( p.x, max( p.y, p.z ) ) -.2,\n                      -min( V.y, min( V.z, V.x ) ) +.19\n                     ); \n        if (d < .001)  o++;   \n        r.w -= d;  \n    }\n}\n**/\n\n/*Fabrice drops 35 chars (now 356 chars)*\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 U = u / iResolution.xy * vec2(2,1)*3.14, \n         c = cos(U), s = sin(U); \n    vec4 r = vec4(c.x * c.y, s.y, s.x * c.y, 0); \n    mat2 t = mat2( cos(iTime + vec4(0, 11, 33, 0)) ); \n    r.xz *= t; r.yz *= t; \n    o = r;\n\n    for (int i=0; i++ < 99; i) {\n        vec3  p = abs( r.xyz * r.w ), \n              a = p - .2,\n              b = p - .19;\n        float d = max( max( a.x, max(a.y, a.z) ),\n                      -min( max(b.x, b.y), min(max(b.y, b.z), max(b.z, b.x)))\n                   ); \n        if (d < .001)  o++;   \n        r.w -= d;  \n    }\n}\n**/\n\n/*initial version (391 chars)*\n#define g(a, b) max(a, b)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 U = (u / iResolution.xy) * vec2(6.28, 3.14), c = cos(U), s = sin(U); // calculate stuff for 360 view\n    vec4 r = vec4(c.x * c.y, s.y, s.x * c.y, 0); // initialize ray\n    mat2 t = mat2(u = sin(iTime + vec2(1.6, 0.0)), -u.y, u.x); // rotation trick from Fabrice's one cube challenge\n    r.xz *= t; r.yz *= t; // double rotation\n    vec3 a, b, p;\n    o = r;\n\n    for (int i=0; i < 99; i++) {\n        p = r.xyz * r.w; // current raymarch position\n        a = abs(p) - .2; b = abs(p) - .19;\n        float d = g(g(a.x, g(a.y, a.z)), -min(g(b.x, b.y), min(g(b.y, b.z), g(b.z, b.x)))); // rather ugly usage of booleans\n        if (d < .001) { o++; } { r.w -= d; } // check for hit. if none then step along the ray\n    }\n}\n**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 128, 128, 486]], "test": "untested"}
{"id": "WdVyRc", "name": "picture in picture 2", "author": "FabriceNeyret2", "description": "drawing pixelized video (or image) from channel 2/3  made of small videos (or images) from BuffA:channel1, which are stored there as tiles corresponding to different moments of the small video.", "tags": ["video"], "likes": 2, "viewed": 442, "published": 3, "date": "1603383676", "time_retrieved": "2024-07-30T20:38:48.801491", "image_code": "// variant of https://shadertoy.com/view/3dVyz3\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = TILES*u/R.y,\n          I = floor(U)/TILES, F = fract(U);\n    \n    O = ( mod(iTime,6.) > 3. \n           ? texture(iChannel2, I*R.y/R)   // target intensity \n           : texture(iChannel3, I*R.y/R) )   \n        * texture(iChannel0, u/R) ;        // normalized subimage\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define T(U)     texelFetch(iChannel0,ivec2(U),0)\n\n#define read(F)   texture(iChannel1, F)         /* small video           */  \\\n                / texture(iChannel1, U, 99.)/2. /* normalize small video */\n                    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = TILES*u/R.y,\n          I = floor(U), F = fract(U), J;\n    \n    if (    T(0).a != iChannelResolution[0].x // init (at texture loaded or resol change)\n         || T(1).a != iResolution.x  )  \n        O = read(F);\n    else \n    {\n        O = T(u);                                                // restore previous state\n        if ( hash(I) < .01 )                                     // update some random tiles with the new image\n            O = read(F);\n        else  \n            J = floor(TILES*hash2(I)),                           // random copy from another tile\n     //     J == I ? J = floor(TILES*hash2(I+.5)) : J  ,\n            O = texture(iChannel0,(F+J)/TILES*R.y/R);\n     //     O = T( (F+J)/TILES*R+.5 );\n    }\n  //O-=O;\n    if ( u == vec2( .5) ) O.a = iChannelResolution[0].x;         // store texture resol  \n    if ( u == vec2(1.5) ) O.a = iResolution.x;                   // store screen resol  \n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TILES 20.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 401]], "test": "untested"}
{"id": "wdGcRK", "name": "Building smasher", "author": "michael0884", "description": "Tracking the deformation gradient to model solid bodies. Yeah, no actual particles here.  Only particle distributions.\nSPACE - zoom in\nUse plugin to accelerate simulation\n", "tags": ["particles", "ca"], "likes": 53, "viewed": 1683, "published": 3, "date": "1603383460", "time_retrieved": "2024-07-30T20:38:49.962389", "image_code": "// Fork of \"Neo-Hookean Field\" by michael0884. https://shadertoy.com/view/3dVyDD\n// 2020-10-20 18:45:49\n\n// Fork of \"Neo-Hookean 2: Electric Boogaloo\" by michael0884. https://shadertoy.com/view/tsVyWR\n// 2020-10-16 17:16:16\n\n// Fork of \"CA Neo-Hookean\" by michael0884. https://shadertoy.com/view/WdGyWR\n// 2020-10-13 18:17:06\n\n//used sources \n//https://github.com/nialltl/incremental_mpm/blob/master/Assets/2.%20MLS_MPM_NeoHookean_Multithreaded/MLS_MPM_NeoHookean_Multithreaded.cs\n//https://www.seas.upenn.edu/~cffjiang/research/mpmcourse/mpmcourse.pdf\n\n// Fork of \"CA Paste\" by michael0884. https://shadertoy.com/view/tsGczh\n// 2020-10-12 21:02:54\n\n// Fork of \"CA Molecular dynamics\" by michael0884. https://shadertoy.com/view/3s3cWr\n// 2020-10-08 22:00:15\n\n// Fork of \"Landau Ginzburg fluid\" by michael0884. https://shadertoy.com/view/WlXBDf\n// 2020-09-21 21:03:05\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 0.25\n#define zoom 0.2\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    vec2 c = vec2(0.);\n    float De = 0.;\n    vec2 vel = vec2(0., 0.);\n    vec2 grad = vec2(0.);\n\n    float rho2 = 0.;\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n        vec2 dx0 = X0 - tpos;\n\t    mat2 D0 = mat2(T1(tpos));\n        \n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        grad += normalize(dx)*K;\n        c += M0*K*DECODE(data.w);\n        De += M0*K*abs(deformation_energy(D0));\n        vel += M0*K*V0;\n        vec2 dsize = destimator(dx0,  data.z);\n        float bsdf = sdBox(pos - X0,0.5*dsize);\n        //float bsdf = length(pos - X0) - 0.5*length(destimator(dx0));\n        rho2 += M0*smoothstep(0.1, -0.1, bsdf)/(dsize.x*dsize.y);\n    }\n\n   grad /= rho; \n   c /= rho;\n   vel /= rho;\n   De /= rho;\n    \n   //vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)/(2.*PI), 1.0, rho*length(vel.xy)));\n   float d = smoothstep(0.3,0.7,mix(rho, rho2,1.0));\n   col.xyz = mix(vec3(0.),5.*vec3(0,0.5,1.0)*De*De + 0.04*rho2 + 0.02*texture(iChannel2, 3.*c).xyz, d);\n   col.xyz = sqrt(col.xyz);\n    //col.xyz = vec3(rho2)*0.2;\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define T1(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 0.5\n#define R iResolution.xy\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define velocity_averaging 0.\n\n//squishy solid\n#define relax 0.000\n#define distribution_size 1.0\n//estimation str\n#define difd 2.0\n//target density\n#define trho 0.\n//density target strenght\n#define rhoe 0.0\n\n//estimating the in-cell distribution size\nvec2 destimator(vec2 dx, float M)\n{\n    //size estimate by in-cell location\n    vec2 ds = distribution_size*clamp(1.0 - difd*abs(dx), 0.001, 1.0);\n    return ds + 0.3*max(M/(ds.x*ds.y) - 1.1, 0.)*dt;\n}\n\nfloat deformation_energy(mat2 D)\n{\n    D = transpose(D)*D;\n    return 2.*(D[0][0]*D[0][0] + D[1][1]*D[1][1] - 2.0);\n}\n\n\n// Lamé parameters for stress-strain relationship\n#define elastic_lambda 3.2\n#define elastic_mu 4.2\n#define incompressible_viscosity 1.0\n\n\n//viscous fluid\n/*\n#define relax 0.05\n#define distribution_size 0.98\n// Lamé parameters for stress-strain relationship\n#define elastic_lambda 0.2\n#define elastic_mu 0.1\n#define incompressible_viscousity 0.05\n*/ \n\n//MD force\nfloat MF(vec2 dx, vec2 dv)\n{\n    return incompressible_viscosity*dot(dx,dv)*GS(0.8*dx);\n}\n\n\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec2 opRepLim(in vec2 p, in vec2 c, in vec2 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "//Reintegration tracking\n\nfloat particleBox(vec2 x, vec2 s)\n{\n    return float(sdBox(x, s) < 0.);\n}\n\nfloat particleArch(vec2 x, vec2 s)\n{\n    return float(opSubtraction(sdBox(x + vec2(0, s.y*0.4), s*vec2(0.5, 0.9)), sdBox(x, s)) < 0.);\n}\n\nfloat Building(vec2 x, vec2 s)\n{\n    vec2 room_s = s.y*vec2(0.12);\n    vec2 rep_s = vec2(0.15)*s.x;\n    float rooms = sdBox(opRepLim(x + vec2(0., -0.1*room_s.y), rep_s, vec2(30.0)), room_s);\n    float sd = opSubtraction(rooms, sdBox(x, s));\n    return float(sd < 0.);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    vec2 C = vec2(0.);\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n        \n        \n        //particle distribution size\n        vec2 K = destimator(X0 - tpos , data.z);\n       \n        X0 += V0*dt; //integrate position\n\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K.x*K.y);\n        \n        //add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \tC += m.z*DECODE(data.w);\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n        C /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        vec4 nya = texture(iChannel2, clamp(1.8*X*vec2(0.166,1.)/R, vec2(0.),vec2(0.1666, 1.0)));\n        M = max(max(Building(X - R*vec2(0.5,0.32), R*vec2(0.4,0.3)),\n            particleBox(X - R*vec2(0.1,0.9), R*vec2(0.0))), \n                particleBox(X - R*vec2(0.5,0.12), R*vec2(0.47, 0.1)));\n        \n        C = mod(3.*pos/R, 1.);\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, ENCODE(C));\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//deformation gradient advection and update\n\n\n//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //deformation gradient\n   \tmat2 D = mat2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n       \tmat2 D0 = mat2(T1(tpos));\n          \n        //particle distribution size\n        vec2 K = destimator(X0 - tpos,  data.z);\n        \n        X0 += V0*dt; //integrate position\n\n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K.x*K.y);\n        \n        //add deformation grad weighted by mass\n        D += D0*m.z;\n      \t\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n       D /= M;\n    }\n\telse D = mat2(1.0);\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        D = mat2(1.0);\n    }\n\n    U = vec4(D);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//velocity update\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.48, 0.48)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\n\nmat2 strain(mat2 D)\n{\n    float J = abs(determinant(D)) + 0.001;\n\n    // MPM course, page 46\n    float volume = J;\n\n    // useful matrices for Neo-Hookean model\n    mat2 F_T = transpose(D);\n    mat2 F_inv_T = inverse(F_T);\n    mat2 F_minus_F_inv_T = D - F_inv_T;\n\n    // MPM course equation 48\n    mat2 P_term_0 = elastic_mu * (F_minus_F_inv_T);\n    mat2 P_term_1 = elastic_lambda * log(J) * F_inv_T;\n    mat2 P = P_term_0 + P_term_1;\n\n    // equation 38, MPM course\n    mat2 stress = P*F_T;\n\n    return volume * stress;\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    mat2 D = mat2(T1(pos));\n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = clamp(data.z, 0., 2.0);\n    vec2 C = DECODE(data.w);\n    if(M>0.0) //not vacuum\n    {\n        //Compute the force\n      \n        vec2 F = vec2(0.);\n        float b = 0.;\n   \n        mat2 local_strain = strain(D);\n        if(M > 0.0)\n        {\n            range(i, -2,2) range(j, -2, 2)\n            {\n                if(!(i == 0 && j == 0))\n                {\n                    vec2 tpos = pos + vec2(i,j);\n                    vec4 data = T(tpos);\n\n                    vec2 X0 = 0.*DECODE(data.x) + tpos;\n                    vec2 V0 = DECODE(data.y);\n                    float M0 = data.z;\n                    vec2 dx = X0 - X;\n                    vec2 dv = V0 - V;\n                    mat2 D0 = mat2(T1(tpos));\n                    float weight = GS(0.8*dx);\n                   \n                    //F += M0*strain((D0*M + D*M0)/(M+M0))*dx*weight;\n                    mat2 strain0 = (M0*strain(D0) + M*local_strain)/(M0+M) + mat2(2.4*dot(dx,dv));\n                    F += M0*strain0*dx*weight;\n                   \n                    b += weight;\n                }\n            }\n       \n            F /= b;\n \t\t\tF = clamp(F, -0.4,0.4);\n        }\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n            F += 0.02*normalize2(dx)*GS(dx/80.);\n        }\n        \n       \t//gravity\n        F += 0.001*vec2(0,-1);\n        \n        //integrate velocity\n        V += F*dt;\n        //X +=  0.*F*dt;\n        \n        vec3 BORD = bN(X);\n        V += 0.1*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        V *= 1. - 0.5*smoothstep(-30., 0., -pos.y);\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), data.z, ENCODE(C));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    mat2 D = mat2(T1(pos));\n    \n    if(M > 0.01) //not vacuum\n    {\n        //Compute the velocity gradient matrix\n        mat2 B = mat2(0.);\n        float a = 0.01;\n        float rho = 0.;\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            vec2 dv = V0 - V;\n\t\t\tvec2 dsize = clamp(destimator(X0 - tpos, data.z), 0.3, 1.0);\n            float weight = clamp(M0, 0.0, 1.0)*GS(0.8*dx);\n            rho += M0*weight;\n            B += mat2(dv*dx.x,dv*dx.y)*weight;\n            a += weight;\n        }\n        B /= a;\n        rho /= a;\n      \n        float drho = rho - 1.0;\n        B -= 0.007*mat2(drho)*abs(drho);\n       \n        //integrate deformation gradient\n       \tD += 1.*dt*B*D;\n       \n        //smoothing\n        \n        float r = relax + 0.05*smoothstep(-30., 0., -pos.y);\n        D = D*(1. - r) + mat2(1.)*r;\n        \n        //clamp the gradient to not go insane\n        D = mat2(clamp(vec4(D - mat2(1.)), -5.0, 5.0)) + mat2(1.);\n    }\n    \n    //save\n    U = vec4(D);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1065, 1065, 1092, 1092, 1270], [1298, 1298, 1326, 1326, 1386]], "test": "untested"}
{"id": "WdKyRc", "name": "Shore Flood 3", "author": "Leasel", "description": "A nice degrading wave", "tags": ["buffer", "sequel"], "likes": 1, "viewed": 291, "published": 3, "date": "1603381446", "time_retrieved": "2024-07-30T20:38:51.065438", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tfragColor = Smp(fragCoord*dif.xy); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord*dif.xy;\n    \n    float Value = max(Smp(uv).x-DegradingValue,0.) + ((\n        Smp(uv).x == 0. &&\n        (\n        \tSmp(uv + dif.xz).x == 1. ||\n        \tSmp(uv - dif.xz).x == 1. ||\n        \tSmp(uv + dif.zy).x == 1. ||\n        \tSmp(uv - dif.zy).x == 1.\n     \t)) ? 1. : 0.);\n    \n    float Mouse = \n        (\n        \t(length(fragCoord-iMouse.xy) < 20. && iMouse.z > 0.) || \n        \t(iTime < 0.1 && length(uv-vec2(0.5, 0.25)) < 0.1) ||\n            (iTime < 0.1 && length(uv-vec2(0.25, 0.60)) < 0.1) \n        ) ? 1. : 0.;\n    \n    fragColor = vec4(min(Value + Mouse, 1.)); \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n    \n    fragColor = Smp(fragCoord*dif.xy); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//General\n#define dif vec3(1./iResolution.xy,0.)\n#define Smp(uv) texture(iChannel0,uv)\n\n//Flood parameters\n//Set this to 0.5 for more interesting effect\n#define DegradingValue 0.01 ", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 97]], "test": "untested"}
{"id": "3dVyz3", "name": "picture in picture", "author": "FabriceNeyret2", "description": "drawing pixelized video (or image) from channel 0  made of small videos (or images) from channel1.", "tags": ["video", "short"], "likes": 4, "viewed": 444, "published": 3, "date": "1603378827", "time_retrieved": "2024-07-30T20:38:51.934115", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 20.*u/R.y,\n          I = floor(U)/20., F = fract(U);\n    \n    O = ( mod(iTime,6.) > 3. \n           ? texture(iChannel0, I*R.y/R)   // target intensity \n           : texture(iChannel3, I*R.y/R) )   \n        * texture(iChannel1, F)            // small video\n        / texture(iChannel1, U, 99.)/2.;   // normalize small video\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 408]], "test": "untested"}
{"id": "3dKcz3", "name": "Quick screen shake", "author": "Miestrode", "description": "Quick screen shake for any use.", "tags": ["2d", "hash"], "likes": 1, "viewed": 406, "published": 3, "date": "1603378641", "time_retrieved": "2024-07-30T20:38:52.678126", "image_code": "// quick screen shake\n// created by yoav greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 c = texture( iChannel0, uv );\n\n    fragColor = c;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKcz3.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[163, 163, 220, 220, 324]], "test": "untested"}
{"id": "tdyyzc", "name": "uniform/Poisson distrib in grid", "author": "FabriceNeyret2", "description": "Generating large distrib of random points is costly at rendering, and problematic for infinite worlds.\nPer-cell generation with 1 (or N) point per cell doesn't give a Uniform distrib (i.e. Poissonian, in screen space).\nHere:Worley \"voronoï guy\" solution.", "tags": ["voronoi", "voronoi", "worley", "stars", "tuto", "pointdistribution"], "likes": 7, "viewed": 490, "published": 3, "date": "1603373096", "time_retrieved": "2024-07-30T20:38:53.427124", "image_code": "float DENS = 10.;                         // target average density per cell\n\n#define hash2(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define lcg(p)        toFloat( p = p * 1664525u + 1013904223u )\n#define toFloat(p)  ( float(p)  / float(0xffffffffu) )\n#define toUint(p)     uint( (p) * float(0xffffffffu) )\n\n// Poisson generator via Inverse transform sampling ( for small d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat Poisson(vec2 U, float d) {          // d = target average density\n    float x = 0., p = exp(-d), s = p;\n    uint r = toUint( hash2(U+.5).x );     // seed\n    \n    for( ; lcg(r) > s && x<50. ; ) \n        s += p *= d/++x; \n        \n    return x;\n}\n    \nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         M = length(iMouse.xy) < 10. ? vec2(0) : 2.*iMouse.xy/R-1.,\n         S = 4.*exp2(2.*M.x) / R.yy,\n         U = S * ( 2.*u - R ) - iTime,\n         I = floor(U), F = fract(U), P;\n    \n // O = vec4( 2.-R.y/8.*length(hash2(I)-F) ); return; // test: one single value per cell\n\n    float d = 1e5, i = 0.,\n           n = Poisson(I, DENS );         // number of dot per cell = Poisson law\n    for( ; i < n; i++ )                   // then, generates n Uniform dots in the cell\n        P = F - hash2(I+i/100.),\n        d = min(d, dot(P,P) );\n                         // dot size proportional if big or 1 pixel if small \n    O = vec4( max(0., 1. - min(R.y/8.,.5/S.x)* sqrt(d) ) );   // draw points \n    O.b += .2*mod(I.x+I.y,2.);            // show cells\n    O = sqrt(O);                          // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 545, 577, 616, 796], [802, 802, 841, 841, 1677]], "test": "untested"}
{"id": "tdyczc", "name": "Weird Diffusion", "author": "Leasel", "description": "Uses the texture from iChannel0 the red and green channel to and the neighbours from the pixel to calculate a new uv. ", "tags": ["weird"], "likes": 2, "viewed": 302, "published": 3, "date": "1603371080", "time_retrieved": "2024-07-30T20:38:54.288820", "image_code": "#define dif vec3(1./iResolution.xy,0.)\n#define Smp(uv) texture(iChannel0, uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord*dif.xy;\n\n    uv = (\n        Smp(uv + dif.xz).xy + \n        Smp(uv - dif.xz).xy + \n        Smp(uv + dif.zy).xy + \n        Smp(uv - dif.zy).xy)*(sin(iTime -0.7) + 1.)*0.5;\n\n    fragColor = Smp(uv);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 136, 136, 358]], "test": "untested"}
{"id": "tsycRc", "name": "Shore Flood 2", "author": "Leasel", "description": "Uses one buffer to perform a flood", "tags": ["buffer", "single"], "likes": 3, "viewed": 270, "published": 3, "date": "1603366975", "time_retrieved": "2024-07-30T20:38:55.036820", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord*dif.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Single buffer, because the states are limited for the pixels which means I could trace all possible combinations,\n//which resulted in me getting the same result on paper when I used 1 or 2 buffers. But the 2 buffer makes it possible to\n//have equal value after the simulation and before the simulation. Which the 1 buffer can not exceed.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord*dif.xy;\n   //fragColor = vec4(max(fragColor.x-0.5,0.) + ((\n   //    \t\t\t\t  fragColor.x == 0. && \n   //    texture(iChannel0, uv + dif.xz).x != 0. &&\n   //    texture(iChannel0, uv - dif.xz).x != 0. &&\n   //    texture(iChannel0, uv + dif.zy).x != 0. &&\n   //    texture(iChannel0, uv - dif.zy).x != 0.) ? 1. : 0.)) + vec4((length(fragCoord-iMouse.xy) < 1.) ? 1. : 0.);\n    \n    float State = max(texture(iChannel0, uv).x-0.5,0.) + ((\n        texture(iChannel0, uv).x == 0. &&\n        (\n        \ttexture(iChannel0, uv + dif.xz).x != 0. ||\n        \ttexture(iChannel0, uv - dif.xz).x != 0. ||\n        \ttexture(iChannel0, uv + dif.zy).x != 0. ||\n        \ttexture(iChannel0, uv - dif.zy).x != 0.\n     \t)) ? 1. : 0.);\n    float Mouse = ((length(fragCoord-iMouse.xy) < 20. && iMouse.z > 0.) || (iTime < 0.1 && length(uv-vec2(0.5)) < 0.1 ) ? 1. : 0.);\n    \n    fragColor = vec4(min(State + Mouse, 1.));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dif vec3(1./iResolution.xy,0.)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsycRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 113]], "test": "untested"}
{"id": "wsyyRc", "name": "Constant speed", "author": "andreagarritano", "description": "circle that mantain constant speed", "tags": ["speed", "constant"], "likes": 1, "viewed": 225, "published": 3, "date": "1603361735", "time_retrieved": "2024-07-30T20:38:56.057092", "image_code": "float circle(vec2 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvoid blend(inout vec4 back, float dist, vec4 color, float border)\n{\n    float alpha = saturate(dist);;\n    //float alpha = saturate((dist+border)/border);\n    color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), saturate((dist)));    \n    back = mix(back, color, (1.0-alpha) * color.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float width_piano = 30.0; //meter\n    float velox = 25.0; //km/h\n    float velox_ms = velox / 3.6;\n    float velox_pixel = (iResolution.x/width_piano)*velox_ms;\n    float radius_meters = 4.5;\n    \n    float center = (iResolution.y / 2.0);\n        \n    // background color\n    fragColor = vec4(0.0,0.0,0.0,1.0); \n    \n    float radius = (iResolution.x/width_piano)*(radius_meters/2.0);\n\n    float x = mod((iTime*velox_pixel), iResolution.x+2.0*radius)-radius;\n\n    \n    blend(fragColor, circle(vec2(fragCoord.x - x, fragCoord.y - center), radius), vec4(1.0), 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 69], [71, 71, 96, 96, 129], [131, 131, 198, 198, 411], [413, 413, 470, 470, 1047]], "test": "untested"}
{"id": "WsGczc", "name": "camino cilindro", "author": "jorge2017a1", "description": "camino cilindro", "tags": ["caminocilindro"], "likes": 3, "viewed": 264, "published": 3, "date": "1603330848", "time_retrieved": "2024-07-30T20:38:57.155156", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n    res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n   \n    p.y=p.y-5.0;\n    \n    \n\tvec3 q=p;\n    float cz=40.00;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    p=q;\n\t\n    \n    float sdc1= sdCylinderYZ(p-vec3(0.0), vec2(20.0,15.0));\n\tfloat sdc2= sdCylinderYZ(p-vec3(0.0), vec2(22.0,12.0));\n    float sdc3= sdCylinderYZ(p-vec3(0.0), vec2(15.0,15.0));\n    \n    float dif1= differenceSDF(sdc1, sdc2);\n    res =opU3(res, vec3(sdc3,-1.0,3.0)); \n    \n    res =opU3(res, vec3(dif1,-1.0,2.0)); \n    \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST )\n        {\t\n            mObj.dist = -1.0;\n    \t\tmObj.id_color = -1.0;\n    \t\tmObj.marchCount=marchCount;\n    \t\tmObj.id_material=-1.0;\n            return -1.0;\n        }\n        \n        if (abs(dS.x)<MIN_DIST) \n        { break;  }\n            \n            \n        dO += dS.x;\n        marchCount++;\n        \n        \n        \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 64.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n   \n    vec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z+iTime, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z+iTime*2.0, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(0.0,21.0+(3.0*sin(iTime*0.75-3.5)),t);\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n    \n\n\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n///--------------------------------------------\n\n", "sound_code": "//referencia \n//https://www.shadertoy.com/view/llBSzK\n//https://www.shadertoy.com/view/tdVyRK....Creado por jt en 2020-10-21\n//modificado por Jorge2017a1\n\n\nconst float trt = 1.0594630943592952645;\nconst float bpm = 140.0;\n\n\n\n#define N 96\n\nconst int base[N] = int[N](\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 3, 2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2\n);\n\nconst int voice[N] = int[N](\n    7, 7, 7, 7, 7, 7,\n    0, 0, 0, 0, 0, 0,\n    3, 5, 7, 7, 7, 7,\n    0, 0, 0, 0, 3, 5,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    5, 5, 5, 5, 5, 5,\n   -2,-2,-2,-2, 3, 2,\n    5, 5, 5, 5, 5, 5,\n   -2,-2,-2,-2, 3, 2,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n    );\n\n\n\nfloat note2freq(float note) {\n    return 440.0 * pow(trt,note);\n}\n\nfloat sawWave(float time, float freq, float amp) {\n \t   return mod(time,1.0/freq)*freq*amp;\n}\n\n\n\n\n#define pi 3.1415926\n\nfloat wave(float t)\n{\n    return sin(2.0 * pi * t);\n}\n\nfloat saw(float t)\n{\n    return 2.0 * fract(t) - 1.0;\n}\n\n#define S 8.0\n\nivec2 note(float time)\n{\n    int n = int(floor(time * S)); // keep in sync with local\n    return ivec2(base[n % N] - 24, voice[n % N]);\n}\n\nfloat local(float time)\n{\n    return fract(time * S) / S; // keep in sync with note\n}\n\nfloat sound1(float freq, float time)\n{\n    float t = freq * time;\n    float h = clamp(1.0 - 4.0 * time, 0.0, 1.0); // linear\n    return mix(wave(t), saw(t), h) * h; // plucked string like sound\n}\n\nfloat sound2(float freq, float time)\n{\n    float t = freq * time;\n    float h = 0.5;\n    return mix(wave(t), saw(t), h);\n}\n\n\nvec2 bassSynth(float time, float tempo)\n{\t\n    \n    \n     ivec2 n = note(time);\n    float t = local(time);\n    vec2 f = 0.5 * 440.0 * exp2(vec2(n) / 12.0);\n    \n    \n    float s1= sound2(f.y, t)*2.0;\n    return vec2(s1);\n}\n\n\nvec2 leadSynth(float time, float tempo) \n{\n    \n    \n    ivec2 n = note(time);\n    float t = local(time);\n    vec2 f = 0.5 * 440.0 * exp2(vec2(n) / 12.0);\n    //vec2 f = 0.5 *  exp2(vec2(n) / 12.0);\n    \n    float s1= sound1(f.x, t)*2.0;\n    return vec2(s1);\n}\n\nvec2 kickSynth(float time, float tempo) {\n    const float dist = 3.0;\n    tempo = mod(tempo,1.0); \n    return vec2(clamp(sin(pow((tempo+0.2)*0.0001,-0.5))*exp(-3.0*tempo),-(1.0/dist),(1.0/dist)) * dist);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 clapSynth(float time, float tempo) {\n    float q = floor(mod(tempo*2.0,32.0)); //quaver number;\n    float b = floor(q/8.0);//bar number\n    float qb = mod(q,8.0); //quaver in bar;\n    float ampMask = float((qb >= 2.0 && qb < 4.0) || (qb >= 6.0 && qb < 7.0)\n                         || (b == 3.0 && (qb == 1.0 || qb >= 5.0))); \n    tempo = mod(tempo*4.0 ,2.0);\n    return vec2(rand(vec2(time+1.2,tempo+6.1)) * ampMask * exp(-1.5*tempo),\n                rand(vec2(time+2.1,tempo+1.6)) * ampMask * exp(-1.5*tempo));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float t = time;\n    float tempo = t * (bpm/60.0);\n    \n    vec2 bass = bassSynth(t,tempo) * 0.30; //mixing here\n    vec2 lead = leadSynth(t*1.005,tempo) * 0.333;\n    vec2 kick = kickSynth(t,tempo) * 0.333;\n    vec2 clap = clapSynth(t,tempo) * 0.333;\n    \n    vec2 synths = bass + lead; //sidechain\n    \n    \n    synths *= min(mod(tempo,1.0)+0.4,1.0);\n    \n    return synths + kick + clap;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 293, 293, 314], [315, 315, 347, 347, 431], [432, 432, 478, 478, 565], [566, 566, 600, 600, 662], [663, 663, 700, 700, 795], [796, 796, 835, 835, 930], [931, 931, 970, 970, 1065], [1066, 1066, 1105, 1105, 1200], [1202, 1246, 1293, 1293, 1320], [1322, 1322, 1365, 1365, 1392], [1394, 1394, 1442, 1442, 1470], [1518, 1583, 1617, 1617, 1715], [1716, 1716, 1750, 1750, 1842], [1843, 1843, 1877, 1877, 1969], [1970, 2010, 2044, 2044, 2141], [2142, 2182, 2207, 2207, 2877], [2879, 2924, 2991, 2991, 3359], [3360, 3411, 3435, 3435, 3623], [3624, 3687, 3720, 3720, 4425], [4427, 4481, 4517, 4517, 4751], [4808, 4808, 4857, 4857, 5079], [5080, 5114, 5194, 5194, 5638], [5681, 5732, 5779, 5779, 6403], [6457, 6457, 6550, 6550, 6977], [6982, 7031, 7088, 7088, 8274]], "test": "untested"}
{"id": "WltXD8", "name": "Slit-scan", "author": "tomorrowevening", "description": "Based on: https://www.shadertoy.com/view/Wt2GRw", "tags": ["slitscan", "dithered"], "likes": 2, "viewed": 415, "published": 3, "date": "1603328412", "time_retrieved": "2024-07-30T20:38:57.905151", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 ch0 = texture(iChannel0, uv);\n    fragColor = mix( ch0 , vec4(ch0.w), saturate(iMouse.z)); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//slit-mask settings\nfloat pxwidth = 5.;\nfloat ditherstrength = 0.2;\n\nfloat saturate (float x){\n\treturn min(max(x,0.),1.);\n}", "buffer_a_code": "float dither (vec2 fragCoord){\n    return texture(iChannel2, fragCoord / 1024.).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mouse-Driven slit mask values\n    float mouse = max(0.1, iMouse.x / iResolution.x);\n    pxwidth = mouse * 20.;\n\tditherstrength = (iMouse.y / iResolution.y) * 20.; \n    //\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 video = texture(iChannel0, uv);    \n\tvec4 buffer = texture(iChannel1, uv);\n    \n    float fr = float(iFrame);   // this drives the animation of the mask \n    float pxdither = pxwidth * (dither(fragCoord) - 0.5) * ditherstrength; // dither setup\n    \n    float mask = saturate( (fract( (fragCoord.x + pxdither + fr * pxwidth) / iResolution.x ) * iResolution.x / pxwidth) );\n    mask = ceil(1. - mask);\n\n    fragColor = mix(buffer, video, mask); // mix each masked frame to buffer\n    fragColor.w = mask; // for debug\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 197]], "test": "untested"}
{"id": "3dGyzc", "name": "Fractal VJ", "author": "henrmota", "description": "Fractal parameterised by audio", "tags": ["fractal"], "likes": 6, "viewed": 290, "published": 3, "date": "1603323340", "time_retrieved": "2024-07-30T20:38:58.740916", "image_code": "#define PI 3.14155\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy -0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0);\n    uv*=2.0;\n    float freq = smoothstep(0.3, 0.7,(\n        texture(iChannel0, vec2(0., 0.)).x + \n        texture(iChannel0, vec2(0.25, 0.25)).x + \n        texture(iChannel0, vec2(0.5, 0.5)).x +\n        texture(iChannel0, vec2(0.75, 0.75)).x + \n        texture(iChannel0, vec2(1., 1.)).x) / 5.);\n    \n\tfloat onePixel = 1./iResolution.y;\n    /*\n    \n    \n    col.rg += sin(uv * 100.);\n    //col += m;\n    */\n    float angle = 5./6. * PI;\n    vec2 rv = vec2(sin(angle), cos(angle));\n    uv.x = abs(uv.x);\n    uv.y -= 0.3;\n    uv -= max(0., dot(uv - vec2(0.5, 0), rv))*rv*2.0;\n    \n    angle = mix(2./3., 2.15/3., freq) * PI;\n    rv = vec2(sin(angle), cos(angle));\n   \tuv.x += 0.5;\n    float rescale = 1.;\n    for(int i = 0; i < 7; i++) {\n      uv *= 3.0;\n      rescale *= 3.0;\n      uv.x -= 1.5;\t\n      uv.x = abs(uv.x);\n      uv.x -= 0.5;\n   \t  uv -= min(0., dot(uv, rv))*rv*2.0;\n    }\n    \n   \n    uv/=rescale;\n    float lineDistance = distance(uv, vec2(clamp(uv.x, -1., 1.), 0.));\n    \n    //col.r += sin(uv.y * 0.5);\n    // Output to screen\n    col+= pow(texture(iChannel0, uv).r, 0.5) * texture(iChannel1,  fract(uv + freq*0.01)).rgb; \n    col.rgb += pow(smoothstep(mix(2., 20., freq) * onePixel, onePixel * 0.9, lineDistance), 3.);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 76, 1479]], "test": "untested"}
{"id": "WdycRc", "name": "AssPimpShiny", "author": "jj99", "description": "for of PimpThatAss - added AO + Spec + Ambient changes", "tags": ["raymarch", "fork"], "likes": 12, "viewed": 407, "published": 3, "date": "1603321892", "time_retrieved": "2024-07-30T20:38:59.544767", "image_code": "// copy of the original - https://www.shadertoy.com/view/3ty3Dd\n// +AO++\n// copy of the original - https://www.shadertoy.com/view/3ty3Dd\n// +AO++\n#define AA 2\n\nfloat pi = 3.14159265, tau = 6.2831853;\n\nfloat box (in float x, in float x1, in float x2, in float a, in float b) {\n\treturn tanh(a * (x - x1)) + tanh(-b * (x - x2));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ex (in float z, in float z0, in float s) {\n    return exp(-(z - z0) * (z - z0) / s);\n}\n\nfloat r(in float z, in float x) {\n    float s = sin (tau * x), c = cos(tau * x),\n\t\tc2 = cos (pi * x), t4z = tanh(4. * z);\n    return /* body */.4 * (1.0 - .4 * ex(z, .8, .15) +\n\t\ts * s + .6 * ex(z, .8, .25) * c * c + .3 * c) *\n\t\t0.5 * (1. + t4z) + /* legs */ (1. - .2 * ex(z, -1.3, .9)) *\n\t\t0.5 * (1. - t4z) * (.5 * (1. + s * s + .3 * c) *\n\t\t(pow(abs(s), 1.3) + .08 * (1. + t4z) ) ) +\n\t\t/* improve butt */ .13 * box(c2, -.45, .45, 5., 5.) *\n\t\tbox(z, -.5, .2, 4., 2.) - 0.1 * box(c2, -.008, .008, 30., 30.) *\n\t\tbox(z, -.4, .25, 8., 6.) - .05 * pow(abs(sin(pi * x)), 16.) * box(z, -.55, -.35, 8., 18.);\n}\n\n// $1M question: how close are we to ParametricPlot3D[...] surface?\nfloat sd( in vec3 p )\n{\n\t/* shift butt belly */\n\tfloat dx = .1 * exp(-pow((p.z-.8),2.)/.6) - .18 * exp(-pow((p.z -.1),2.)/.4);\n\n    // on the surface, we have:\n    // p.x = r * cos + dx\n\t// p.y = r * sin\n\t\n    float jiggle = p.z*1.75;\n    float jsize = 0.5;\n    if (iMouse.z>0.5)\n    {\n        jiggle+=p.y*.5;\n        jsize+=.175;\n    }\n    \n\tdx *= 1.5+(sin(jiggle+iTime*9.65)*jsize);\n\t\n\tfloat angle = atan(p.y, p.x - dx);\n\tfloat r_expected = r(p.z, angle / tau);\n//\tfloat d1 = (.5 + .5 * smoothstep(.4,1.,p.z)) * (length(vec2(p.y, p.x - dx)) - r_expected);\n\tfloat d1 = (length(vec2(p.y, p.x - dx)) - r_expected)*0.5;\n    \n    p.x -= dx;\n\tfloat d2 = sdSphere(p+vec3(-0.35,0.4,-1.875),0.4);\n\tfloat d3 = sdSphere(p+vec3(-0.35,-0.4,-1.875),0.4);\n    d2 = smin(d2,d3,0.35);\n    return smin(d1,d2,0.07);\n    //return min(d1,min(d2,d3));\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sd (pos.zxy);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an =2.+sin(iTime+2.15)*0.7;\t//0.5*iTime - 0.8;\n    // if (iMouse.z>0.5)\n        //an+=iMouse.x/(iResolution.x*0.25);\n    //an+=3.14;\n    \n\tvec3 ro = vec3( 2.55*sin(an), 0.5, 2.55*cos(an) );\n    vec3 ta = vec3( 0.0, .8, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 tot = vec3(0.0);\n    \n    \n    vec2 p1 = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float val = sin(iTime+p1.x*3.0+p1.y*20.0)*(0.8+sin(p1.y*24.4+iTime*3.0)*0.3);\n    val = clamp(pow(abs(val),2.6),0.0,2.0);\n    vec3 bcol = vec3(val*0.6,val*0.1,val*0.9);\n\tbcol *= length(p1*p1*p1);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        vec3 col = bcol;\n        // raymarch\n        if (abs(p.x)<0.8)\n        {\n            // create view ray\n            vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n            \n            const float tmax = 5.0;\n            float t = 0.0;\n            for( int i=0; i<200; i++ )\n            {\n                vec3 pos = ro + t*rd;\n                float h = map(pos);\n                if( h<0.0001 || t>tmax ) break;\n                t += h;\n            }\n            // shading/lighting\t\n            if( t<tmax )\n            {\n                vec3 pos = ro + t*rd;\n                vec3 nor = calcNormal(pos);\n\t\t    \n\t\tfloat ao = calcAO(pos,nor);\n\t\t    \n\t\t    vec3 ln = normalize(vec3(1.1,-.52,-.4));\n\t\t    \n\t        float spec = pow(max( dot( reflect(-ln, nor), -rd ), 0.0 ), 20.0);\n\t\t    \n                float dif = clamp( dot(nor,ln), 0.0, 1.0 );\n                float amb = 0.25 + 0.5*dot(nor,vec3(.2,0.2,0.2));\n                col = vec3(0.4,0.05,0.3)*amb + (vec3(1.1,0.6,0.4)*2.0)*dif*ao;\n\t\t    col *= 1.1+spec;\n            }\n        }\n\n        // gamma        \n        //col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    // gamma        \n    tot = sqrt( tot );\n    \n   \tvec2 qq = fragCoord.xy / iResolution.xy;\n    tot *= 0.5 + 0.5*pow( 16.0*qq.x*qq.y*(1.0-qq.x)*(1.0-qq.y), 0.95 );\n\tfragColor = vec4( tot, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdycRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 275, 275, 327], [328, 328, 363, 363, 389], [390, 390, 431, 431, 524], [526, 526, 574, 574, 618], [620, 620, 653, 653, 1222], [1224, 1292, 1315, 1339, 2125], [2128, 2128, 2154, 2154, 2181], [2183, 2229, 2261, 2261, 2499], [2501, 2501, 2541, 2541, 2800]], "test": "untested"}
{"id": "3dycz3", "name": "Fab23 #inktober2020 \"rip\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["spiral", "paper", "short", "golf", "inktober2020", "fault"], "likes": 29, "viewed": 507, "published": 3, "date": "1603315606", "time_retrieved": "2024-07-30T20:39:00.289776", "image_code": "#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n#define F(h)      ( q.x - sin(.3*(h)) - .3* sin(.79*(h)) )    // fault shape\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,r=t,s,l,h,z, T = 20.*iTime;\n    vec3  R = iResolution,\n          M = iMouse.z > 0. ? iMouse.xyz/R-.5 : vec3(4,2,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -1.5*R.y ) - R ),          // ray direction\n          p = vec3(0,0,80), q;                                // marching point along ray \n    \n    for ( O-=O ; O.x < 2. && t > .01 ; O+=.005 )\n        q = p, t=9.,\n        q.yz *= rot(    -6.*M.y),                             // rotations\n        q.xz *= rot(.2 -6.4*M.x),\n        l = dot(q.yz,q.yz),                                   // --- paper roll\n        s = 6.28*( fract( ( sqrt(l) -atan(q.y,q.z) -sqrt(T) ) /6.28 ) -.5), // spiral r = theta²/2 . cf https://www.desmos.com/calculator/hmjyvcbxqa and https://mathcurve.com/courbes2d.gb/archimede/archimede.shtml\n        t = min( t, l > T-1. ? t: r = max( F(l/2.-5.), abs(s)-.1 )),  // T = rolled lenght\n        h = q.y-T/2.,                                         // h = ripped length\n        \n        t = min( t, max( max( -q.y, h ),                      // --- ripped top paper part\n                   max( -F(h), z = abs( q.z+sqrt(T) ) -.1) )),\n        t = min( t, max(q.y, z) ),                            // --- unripped bottom paper part\n        p += .2*t*D;                                          // step forward = dist to obj          \n   \n    O = exp(-O);                                              // --- coloring\n    if (t<.01 && (t!=r || s<0.) ) O.rg *= 1. - max(0.,sin(.5*(r==t?l/2.-5.:h))-.8); // lines\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dycz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 206, 206, 1730]], "test": "untested"}
{"id": "wsVcRK", "name": "Improved Reintegration", "author": "michael0884", "description": "Now with variable distributions!\nVisualizing how the particle distributions are updated every frame in close up\nhttps://michaelmoroz.github.io/Reintegration-Tracking", "tags": ["particles", "ca"], "likes": 18, "viewed": 622, "published": 3, "date": "1603310376", "time_retrieved": "2024-07-30T20:39:01.111578", "image_code": "// Fork of \"Reintegration visualization\" by michael0884. https://shadertoy.com/view/WlSfWD\n// 2020-10-21 10:57:34\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-08-31 20:06:54\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    pos = R*0.495 + pos*0.04; //zoom in\n    ivec2 p = ivec2(pos + 0.5);\n    \n    float rho = 0.; float varr = 0.;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, vec2(p) + ij);\n        particle P0 = getParticle(data, vec2(p) + ij);\n        vec2 dx = P0.X - (vec2(p) + ij);\n        rho += P0.M.x*smoothstep(0.1, 0.09, distance(pos,P0.X)); \n    \tfloat rad = dif/2.;\n        varr += P0.M.x*smoothstep(0.03, 0.01, sdArrow(pos, P0.X, P0.X+20.*P0.V));\n        varr += clamp(P0.M.x,0., 4.0)*smoothstep(0.03, 0.01, sdBox(pos - P0.X - P0.V*dt,0.5*destimator(dx, P0.M.x)));\n    }\n    \n    float sdgrid = sdBox(mod(pos + 0.5, vec2(1.0)), vec2(1.0));\n   \n    vec3 particles = vec3(0.2)*(rho + varr);\n    vec3 cellcol = vec3(1.);\n   \tvec3 grid = cellcol*smoothstep(0.0, -0.1, sdgrid);\n    // Output to screen\n    col.xyz = grid - particles;\n    col.xyz = col.xyz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, Bf(p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.0\n\n//distribution diameter\n// 0 - completely particle like\n// >1.0 - field-like\n#define dist 1.0\n//diffusion\n#define dif 0.001\n//estimation str\n#define difd 2.0\n\n\n//estimating the in-cell distribution size\nvec2 destimator(vec2 dx, float M)\n{\n    //size estimate by in-cell location\n    return dist*clamp(1.0 - difd*abs(dx), 0.002, 1.0) + dif*dt;\n}\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArrow( in vec2 p, in vec2 a, in vec2 b )\n{\n    float sdl = sdSegment(p,a,b);\n    vec2 delta = normalize(b-a);\n    sdl = min(sdl, sdSegment(p,b,b-delta*0.05 + 0.05*delta.yx*vec2(-1,1)));\n    sdl = min(sdl, sdSegment(p,b,b-delta*0.05 - 0.05*delta.yx*vec2(-1,1)));\n    return sdl;\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpackSnorm2x16(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = packSnorm2x16(clamp(x, vec2(-1.), vec2(1.)));\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n\nvec3 distribution(vec2 x, vec2 p, vec2 K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K.x*K.y); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        vec2 dx0 = P0.X - tpos;\n        vec2 difR = destimator(dx0, P0.M.x);\n        P0.X += P0.V*dt; //integrate position\n\t    \n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        vec2 dx0 = P0.X - tpos;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n    \n   \t\tReintegration(ch0, P, pos);\n   \t//initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos + vec2(0., 1.0)+0.28);\n        if(rand.z < 0.6) \n        {\n            P.X = pos + 0.3*(rand.yz-0.5);\n            P.V = 0.65*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        //Simulation(ch0, P, pos);\n    }\n\n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 243, 243, 421], [423, 423, 459, 459, 509], [511, 511, 527, 527, 555]], "test": "untested"}
{"id": "wsKcWw", "name": "ShallowWaterEquation", "author": "EvilRyu", "description": "mouse supported", "tags": ["simulation", "water", "rain", "shallowwaterequation"], "likes": 28, "viewed": 990, "published": 3, "date": "1603294179", "time_retrieved": "2024-07-30T20:39:02.044085", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 hash2(vec2 p) \n{\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\nvec2 hash2(float n) \n{ \n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); \n}\n\nfloat hash1(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat cloud(vec2 x)\n{\n    float f = 2.;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for(int i=0; i<3+min(0,iFrame); i++)\n    {\n        float n = noise(vec2(x.x, x.y-iTime*0.3));\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nfloat terrian(vec2 p)\n{    \n    p*=0.0035;\n    float f = 1.7;\n    float s = 0.5;\n    float a = 0.;\n    float b = 0.5;\n    for(int i=0; i<9+min(0,iFrame); i++)\n    {\n        float n = noise(p);\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n\t\n    a=smoothstep(-0.5,0.7,a);\n    \n    return a*300.;\n}\n\n\nvec3 terrian_normal(vec2 pos, float t)\n{   \n    vec2 e = vec2(0.001*t,0.0);\n\treturn normalize(vec3(terrian(pos-e.xy)-terrian(pos+e.xy),\n                           2.0*e.x,\n                           terrian(pos-e.yx)-terrian(pos+e.yx)));\n}\n\nfloat march_terrian(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float t = tmin;\n    vec3 p=ro+t*rd;\n    float d=p.y-terrian(p.xz);\n\n    float sgn=sign(d);\n    float told=t;\n    bool bisect=false;\n        \n    for (int i=0;i<256+min(0,iFrame);i++)\n    {\n        if(abs(d)<0.002*t || t>tmax) break;            \n       \tif(sign(d)!=sgn)\n        {\n            bisect=true;\n            break;\n        }\n        \n        told=t;\n        if(d>1.)t+=d*0.4;\n        else t+=log(abs(d)+1.1)*1.;\n        p=ro+t*rd;\n       \td=p.y-terrian(p.xz);\n    }\n    \n    if(bisect)\n    {\n        float m = 0.;\n        p=ro+told*rd;\n        sgn=sign(p.y-terrian(p.xz));\n        for(int i=0; i<6; i++)\n        { \n            m=(told+t)*.5;\n            p=ro+rd*m;\n            d=p.y-terrian(p.xz);\n            if(abs(d)<0.002*t)break;\n            d*sgn<0. ? t=m : told=m;\n        }\n        t=(told+t)*.5;\n    }\n    return t;\n}\n\n\nfloat water(vec2 p)\n{\n    p*=0.05;\n\tfloat f = 2.;\n    float s = 0.4;\n    float a = 0.0;\n    float b = 0.1;\n\n   \n    float n = texture(iChannel2, p.xy*.1-vec2(0.45,.2)).x * 5.;\n    a += n;\n    #if FBM\n    for(int i=0; i<5+min(0,iFrame); i++)\n    {\n        float n = noise(vec2(p.x+10.,p.y-iTime*1.));\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n    #endif\n\treturn 3.*a;\n}\n\nvec3 water_normal(vec2 pos, float t) \n{\n\tvec2 e=vec2(1e-7*t*t*t,0.0);\n    return normalize(vec3(water(pos-e.xy)-water(pos+e.xy),\n                          2.0*e.x,\n                          water(pos-e.yx)-water(pos+e.yx)));\n}\n\nfloat intersect_water(vec3 ro, vec3 rd)\n{\n    float t=2000.;\n    if(rd.y <-0.01)\n    {\n      \tfloat t0=-(ro.y-20.)/rd.y;\n      \tt=min(t,t0);\n    }\n    return t;\n}\n\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nfloat terrian_shadow(vec3 ro, vec3 rd, vec2 fragCoord)\n{\n    float res=1.0;\n    float t=.5+0.5*hash1(fragCoord);\n\n    float h;    \n    for(int i=0;i<20+min(0,iFrame);i++)\n    {\n        vec3 p=ro+t*rd;\n        h=p.y-terrian(p.xz);\n        res=min(16.0*h/t, res);\n        t+=clamp(h,1.+.1*t,30.);\n        if(res<0.001*t)\n            break;\n    }\n    return clamp(res, 0., 1.);\n}     \n\n\nvec3 sun_dir=normalize(vec3(-5., 1.5, 4.6));\nvec3 sun_col=vec3(1.);\n\nvec3 terrian_material(vec3 pos, vec3 n)\n{\n    float tree_pdf=smoothstep(0.,.5,n.y);\n    tree_pdf*=1.-smoothstep(20.,50.,pos.y);\n    vec3 mate=pow(texcube(iChannel0, pos*0.008, n).xyz,vec3(3.));\n    mate=mix(mate, .05*vec3(.7, 1., .2), tree_pdf);\n    tree_pdf=smoothstep(0.2,.3,n.y)*smoothstep(50.,200.,pos.y);\n    mate=mix(mate, .08*vec3(.5, 1., .2), tree_pdf);\n\treturn mate;\n}\n\nvec3 render_terrian(vec3 ro, vec3 rd, float t, vec2 fragCoord)\n{\n    vec3 pos=ro+t*rd;\n    vec3 n=terrian_normal(pos.xz, t);\n\n    vec3 sky=vec3(0.2,0.7,1.);\n    \n    vec3 mate=terrian_material(pos, n);\n    n=bump_mapping(pos*.1,n,0.15);\n    float sha=terrian_shadow(pos+.5*n, sun_dir, fragCoord);\n    float dif=max(0.,dot(n,sun_dir));\n    float bac=max(0.,dot(n,-sun_dir));\n    float amb=max(0.,dot(n,vec3(0,1,0)));\n    vec3 Lo=4.0*dif*sun_col*sha;\n    Lo+=0.5*bac*sun_col;\n    Lo+=4.5*amb*sky;\n   \tLo*=smoothstep(-1.,10.,pos.y);\n    return Lo*mate*0.2;        \n}\n\n// sky from iq's rainforest  https://www.shadertoy.com/view/4ttSWf\nvec3 render_sky(vec3 ro, vec3 rd)\n{\n    // darker on top of the head\n    vec3 col=0.8*vec3(0.45,0.6,1.0)-rd.y*vec3(0.4,0.36,0.4);\n\n    float t=(1000.0-ro.y)/rd.y;\n    if(t>0.0)\n    {\n        vec2 uv=(ro+t*rd).xz-vec2(4710.,235.);\n        float cl=cloud(uv*0.0015);\n        float dl=smoothstep(-0.2,0.6,cl);\n        col=mix(col, vec3(1.0), 0.6*dl);\n    }\n    \n    \n\treturn col;\n}\n\nvec3 render_water(vec3 ro, vec3 rd, float t, float t1, vec2 fragCoord, vec3 sky)\n{\n    vec3 pos=ro+t*rd;\n    vec3 n=water_normal(pos.xz, t);\n\n    vec3 mate=vec3(.8,.9,1.)*0.5;\n\n    float sha=terrian_shadow(pos+.1*n, sun_dir, fragCoord);\n    float dif=max(0.,dot(n,sun_dir));\n    float amb=max(0.,dot(n,vec3(0,1,0)));\n    float fre=clamp(1.0+dot(rd,n), .0, 1.); \n    vec3 refl=reflect(rd,n);\n    vec3 refr=refract(rd,n,1./1.33);\n    float spe=max(0.0, pow(clamp(dot(sun_dir, refl), 0.0, 1.0), 5.0));\n\n    vec3 Lo=2.0*dif*sun_col*sha;\n    Lo+=2.*amb*sky;\n    Lo+=2.5*pow(fre,8.)*vec3(1.);\n    Lo+=2.5*spe*vec3(1.);\n\tvec3 col=Lo*mate*0.2;\n    \n    float t_terrian=march_terrian(pos+1.*n, refl, 0.5, 500.);\n    vec3 reflcol=render_sky(pos,refl)*.5;\n    \n    float falloff=0.;\n    \n    if(t_terrian<500.) \n    {\n        falloff=1.-smoothstep(0.5,500.,t_terrian);\n        reflcol=.4*falloff*falloff*render_terrian(pos+1.*n, refl, t_terrian, fragCoord);\n    }\n\n    vec3 refrcol=render_terrian(ro, rd, t1, fragCoord);\n    \n    falloff=1.-smoothstep(0.5,500.,t1-t);\n    col=mix(col,refrcol,falloff*falloff);\n      \n    col=mix(col, reflcol, fre);   \n    return col;\n}\n\n\n\nvec3 scene(vec3 ro, vec3 rd, vec2 fragCoord, out float t)\n{\n    vec3 bg=vec3(.6,.8,1.1);\n    vec3 col=render_sky(ro, rd);\n    float t0=intersect_water(ro,rd);\n    float t1=march_terrian(ro, rd, 50., 2000.);\n    t=min(t0,t1);\n    \n  \tif(t>=2000.) return col;\n        \n    if(t1<t0)\n    {\n        col=render_terrian(ro, rd, t1, fragCoord);  \n    }\n    else\n    {\n        col=render_water(ro, rd, t0, t1, fragCoord, col);\n    }\n    \n    col=mix(col,bg, 1.0-exp(-1.5e-7*t*t) );\n    \n    return col;\n}\n\n\nvec3 tonemap(vec3 x) \n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0,1,0)));\n    vec3 u=normalize(cross(r,f));\n    return mat3(r,u,f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord.xy/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(0.,100.,0.);\n    vec3 ta=ro+vec3(0,-0.2,-1.);\n        \n   \tmat3 cam=camera(ro, ta); \n    vec3 rd=normalize(cam*vec3(p.xy,PI/2.));\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=0.;\n    \n    col=scene(ro,rd,fragCoord.xy, t);\n    //col = texture(iChannel2, q).xxx;\n    \n    // rain by Dave Hoskins\n    #if RAIN\n    //if(iTime > RAIN_START_TIME)\n    {\n        vec2 st = 256. * (p* vec2(.5, .01)+vec2(iTime*.13-q.y*.1, iTime*.13));\n        float f = noise(st) * noise( st*0.773) * 1.55;\n        f = 0.25 + clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\n        col += 0.2 * f * vec3(1.2) * smoothstep(RAIN_START_TIME-.5, RAIN_START_TIME+.5, iTime);\n    }\n    #endif\n    \n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n\tcol=col*0.6+0.4*col*col*(3.0-2.0*col);\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\n    fragColor.xyz=col;;\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define H0 1.0\n\nfloat g = GRAVITY;\n\nvec2 hash21(float p)\n{\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n    \n     // use linear texture filter for the averaging\n    vec2 v_avg = texture(iChannel0, pos-pixelSize*.5).xy;\n        \n   \tvec2 U = texture(iChannel0, pos).xy;\n    \n    if(iFrame == 0)\n    {\n        U=vec2(0);\n    }\n    \n    if(iMouse.z > 0.)\n    {\n        vec2 mpos = iMouse.xy / iResolution.xy;\n        U += (1.-smoothstep(0.,0.01,length(mpos-pos))) * .3;\n    }\n    \n    #if RAIN\n    if(iTime > RAIN_START_TIME && iFrame % 1 == 0)\n    {\n        vec2 mpos = hash21(float(iFrame));\n        U += (1.-smoothstep(0.,0.01,length(mpos-pos))) * .2;\n    }\n    #endif\n    \n    \n    float h00 = texture(iChannel1, pos).x;\n    float h10 = texture(iChannel1, pos + _10).x;\n    float h01 = texture(iChannel1, pos + _01).x;\n     \n  \tvec2 Unew;\n \n    Unew.x = U.x + dt * (CORIOLIS_PARAM * v_avg.x - g * (h10 - h00) / dx);\n    Unew.y = U.y + dt * (CORIOLIS_PARAM * v_avg.y -g * (h01 - h00) / dy);\n  \n    \n\n\n    fragColor = vec4(Unew, 0, 0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 hash21(float p)\n{\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize=1./iResolution.xy;\n    vec2 pos=fragCoord.xy*pixelSize;\n        \n   \tfloat H = 0.;\n    if(iFrame == 0)\n    {\n        H=0.;\n    }\n    \n    if(iMouse.z > 0.)\n    {\n        vec2 mpos = iMouse.xy / iResolution.xy;\n        H -= (1.-smoothstep(0.,0.01,length(mpos-pos))) * 5.3;\n    }\n   \n    \n    float h = texture(iChannel1, pos).x + H;\n    \n    vec2 U0 = texture(iChannel0, pos).xy;\n    float u1 = texture(iChannel0, pos - _10).x;\n    float v1 = texture(iChannel0, pos - _01).y;\n    \n    // .99 for attenuation\n    float hnew = .99*h - dt * DEPTH * ((U0.x - u1) / dx + (U0.y - v1) / dy);\n    \n  \n\n    fragColor = vec4(hnew, 0., 0., 0.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// passthrough pass, for workaround a shadertoy bug:\n// the wrap mode of buffers would always change back to \"clamp\" even you set to \"repeat\" in Image pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 pos = fragCoord.xy * pixelSize;\n    \n    fragColor.xyz = vec3(texture(iChannel1, pos).x, 0., 0.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Very Basic Shallow Water Equation\n\n\n#define RAIN 1\n#define RAIN_START_TIME 3.\n#define FBM 1\n#define PI 3.1415926535\n\n\n#define SHOWSIM 0\n\n#define dx 1.\n#define dy 1.\n\n\n#define _10 vec2(pixelSize.x, 0)\n#define _01 vec2(0, pixelSize.y)\n#define _11 (pixelSize.xy)\n\n\n#define GRAVITY 9.8\n#define DEPTH 10.\n#define CORIOLIS_PARAM  2e-4\n\n// CFL\n#define dt  (0.5 * min(dx, dy) / sqrt(GRAVITY * DEPTH))\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKcWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[111, 111, 132, 132, 257], [259, 259, 281, 281, 357], [359, 359, 380, 380, 457], [459, 459, 480, 480, 791], [868, 868, 889, 889, 1135], [1137, 1137, 1160, 1160, 1447], [1450, 1450, 1490, 1490, 1689], [1691, 1691, 1754, 1754, 2594], [2597, 2597, 2618, 2618, 2983], [2985, 2985, 3024, 3024, 3211], [3213, 3213, 3254, 3254, 3375], [3378, 3378, 3423, 3423, 3569], [3571, 3571, 3599, 3599, 3680], [3682, 3682, 3731, 3731, 3995], [3997, 3997, 4053, 4053, 4373], [4450, 4450, 4491, 4491, 4827], [4829, 4829, 4893, 4893, 5392], [5394, 5461, 5496, 5529, 5839], [5841, 5841, 5923, 5923, 6999], [7003, 7003, 7062, 7062, 7499], [7502, 7502, 7525, 7525, 7711], [7713, 7713, 7744, 7744, 7877], [7879, 7879, 7936, 7936, 8902]], "test": "untested"}
{"id": "3dyyR3", "name": "Halton(2, 3) Sequence", "author": "piyushslayer", "description": "A simple helper demo for generating a Halton(2, 3) sequence for some TAA stuff.", "tags": ["antialiasing", "supersampling", "halton", "temporal", "taa", "txaa"], "likes": 9, "viewed": 1217, "published": 3, "date": "1603293936", "time_retrieved": "2024-07-30T20:39:02.912762", "image_code": "/**\n*\n* A simple helper demo for generating a Halton(2, 3) sequence for some TAA stuff.\n*\n* The sequence adds a new offset to the index every 60 frames (or 1 second, this can be changed). So I can \n* scrub the time (shadertoy plugin <3) and see where the discrepancy of the sequence is the lowest and \n* calculate the offset value at that timestep. \n*\n* To calculate offset, offs = floor((t * 1000 / 16.67) / interval)\n*\n* The above calculation assumes a stable framerate of 60 fps. \n*\n*/\n\n//#define GRID\n\nconst int interval = 60;\nconst int sampleCount = 16;\n\n// https://en.wikipedia.org/wiki/Halton_sequence#Implementation_in_pseudocode\nfloat halton(int base, int index)\n{\n\tfloat result = 0.;\n\tfloat f = 1.;\n\twhile (index > 0)\n\t{\n\t\tf = f / float(base);\n\t\tresult += f * float(index % base);\n\t\tindex = index / base; \n        //index = int(floor(float(index) / float(base)));\n\t}\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    int offset = iFrame / interval; // increment offset every x no. of frames\n    \n    for (int i = 0; i < sampleCount; ++i)\n    {\n        int idx = offset + i;\n        vec2 hh = vec2(halton(2, idx), halton(3, idx)) - .5;\n        hh.x *= iResolution.x / iResolution.y;\n    \tcol += smoothstep(.02, .01, length(uv - hh * 1.8));\n    }\n    \n#ifdef GRID\n    vec2 st = fragCoord / iResolution.xy;\n    st *= 4.;\n    if (fract(st).x < .01 || fract(st).y > .99)\n        col.r += 1.;\n#endif\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 638, 673, 673, 894], [896, 896, 953, 953, 1568]], "test": "untested"}
{"id": "wdKczV", "name": "RandomPathGenerator", "author": "Arseny", "description": "Just random path O(log(width+height))", "tags": ["procedural", "2d"], "likes": 5, "viewed": 314, "published": 3, "date": "1603293906", "time_retrieved": "2024-07-30T20:39:03.674724", "image_code": "// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat f(float x){\n    return 16. * pow(x - 0.5, 5.) + 0.5;\n}\n\n// must be idb.x <= idp.x <= ide.x && idb.y <= idp.y <= ide.y\nvec2 IsOnRandomPath(vec2 idp, vec2 idb, vec2 ide, float seed){\n    if (idp.x < idb.x || idp.y < idb.y || idp.x > ide.x || idp.y > ide.y) return vec2(0.);\n    vec2 sz = ide - idb;\n    vec2 id = idp - idb;\n    float need = id.x + id.y;\n    float l = 0.;\n    float r = sz.x + sz.y + 1.;\n    vec2 lb = vec2(0.), ur = sz;\n    vec2 as = vec2(0.);\n    while (r - l > 1.){\n        float m = floor((r + l) / 2.);\n        float miny = max(lb.y, m - ur.x), maxy = min(m - lb.x, ur.y);\n        float rnd = miny + floor((maxy - miny + 0.999) * f(hash12(vec2(m, seed))));\n        if (need < m){\n            r = m;\n            ur = vec2(m - rnd, rnd);\n            //ur = vec2(m - rnd, rnd);\n        } else {\n            l = m;\n            lb = vec2(m - rnd, rnd);\n        }\n    }\n    if (lb == id){\n        return vec2(10.);\n    } else {\n        return vec2(0.);\n    }\n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 2.;\n    \n    vec2 id = floor(uv * 10.);\n    \n    if (id == vec2(-8, -5)){\n        fragColor = vec4(0., 0., 1., 0.);\n        return;\n    }\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //fragColor = vec4(IsOnRandomPath(id, vec2(-8., -5.), vec2(7., 6.)));\n    fragColor = vec4(IsOnRandomPath(id, vec2(-8., -5.), vec2(7., 6.), floor(iTime)) / 10., 0., 1.);\n    vec2 ll = (uv - id / 10.);\n    fragColor.r = 1.;\n    fragColor = min(ll.x, ll.y) < 0.005 ? vec4(0.) : fragColor ;\n\treturn;\n    // Output to screen\n    fragColor = vec4(id / 10., 0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 63, 63, 213], [215, 215, 232, 232, 275], [277, 339, 401, 401, 1209], [1211, 1211, 1268, 1318, 1988]], "test": "untested"}
{"id": "WsyyR3", "name": "barycentric compact - 539 chars", "author": "FabriceNeyret2", "description": "golfed antialiased (+missing inits) version of 1052 chars Artleet's [url]https://shadertoy.com/view/tdKcRK[/url]", "tags": ["2d", "barycentric", "short", "golftriangulation"], "likes": 24, "viewed": 588, "published": 3, "date": "1603293069", "time_retrieved": "2024-07-30T20:39:04.524453", "image_code": "// golfed antialiased (+missing inits) version of 1052 chars Artleet's https://shadertoy.com/view/tdKcRK\n//                                    inspired by 2817 chars mattz's https://www.shadertoy.com/view/MdfBzl\n// -9 chars by cotote\n\n#define h(p) ( fract( sin(  34.*(p) + H*(p).yx ) * H ) * 2. - 1. )       //\n#define A      cos( vec2(0,33) + ( S + iTime * .2 )                      //\n#define c(p)   cos(.63 * ( vec3(8, 8, 5) * dot( p+v + h(p+v) , A) ) / S + vec3(0, 2, 5))) //\n#define a(p)   p+v + .2 * A*h(p+v))                                      //\n                                                                         //\n#define P( A,B,C,  D ) (                                                  \\\n        P = a(A),                                                         \\\n        P = inverse( mat2( a(B)-P, a(C)-P ) ) * ( U -.5 - P ),            \\\n        w += d = max(0., 1. - H/9.* dot( z = vec4( abs( 1. - P.x - P.y) , abs(P), -1 ), z/z )), \\\n        d* mat4(.5+.5*mat3(c(I), c(A), c(D))) * z                         \\\n     )                                                                   //\nvoid mainImage(out vec4 O, vec2 u) { O-=O; O.a++;\n    float S = 5., w = 0., d, H = iResolution.y;\n    vec2  U = S* u / H * mat2(6, 0, -3, 5) / 6. ,\n          P, I = O.wx, J = I.yx, v;\n    vec4  z;\n    for(int i=0; i<4; i++)\n        v = floor(U) - vec2(i%2,i/2),\n        O+= P(  ,J,I,  J  ),\n        O+= P( J,I,1., 1. );\n    O /= w;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wsVyzV", "name": "Shore Flood", "author": "Leasel", "description": "It shows a way to make a flood in parallel", "tags": ["buffers"], "likes": 1, "viewed": 280, "published": 3, "date": "1603291559", "time_retrieved": "2024-07-30T20:39:05.584618", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Shows the flood propagating\n    vec4 Col = texture(iChannel0, uv);\n    vec4 waves = mod(texture(iChannel0, uv), 0.5)*2.;\n    fragColor = Col + waves;\n    \n    //Shows the amount of not being able to transfer fluids neighbours a cell has\n    //fragColor += texture(iChannel1, uv)*0.1f;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//This per cell what it can take from other neighbours and if the other neighbours can't get water from itsel it means it has to hold it(this is done with buffer C)\n//iChannel2 determiness where there can be water and not\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dif = vec3(1./iResolution.xy, 0); \n    vec2 uv = fragCoord.xy*dif.xy; \n    \n    float AmountIGetWhenFlooded = (texture(iChannel2, uv).x != 0. ?\n        (\n        texture(iChannel0, uv + dif.xz).x * (1.-texture(iChannel2, uv + dif.xz).x) +\n        texture(iChannel0, uv - dif.xz).x * (1.-texture(iChannel2, uv - dif.xz).x) +\n        texture(iChannel0, uv + dif.zy).x * (1.-texture(iChannel2, uv + dif.zy).x) +\n        texture(iChannel0, uv - dif.zy).x * (1.-texture(iChannel2, uv - dif.zy).x) +\n        fragColor.x * texture(iChannel1, uv).x \n        )*0.25 + texture(iChannel0, uv).x * texture(iChannel2, uv).x : 0.);\n    \n    AmountIGetWhenFlooded += length(fragCoord - iMouse.xy) < 50. && texture(iChannel2, uv).x >= 0.5 && iMouse.z>0. ? 1. : 0.;\n    \n    fragColor = vec4(AmountIGetWhenFlooded);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Set Buffer B to the new flood map\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Amount of passages free, calculates the neighbour amount of not being be able to transfer water\n//This buffer should actually be calculated only once\n//iChannel0 determiness where there can be water and not\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dif = vec3(1./iResolution.xy, 0); \n    vec2 uv = fragCoord.xy*dif.xy;\n    \n    //Loses water to the border, can negate this effect by acknowledging that the border can't get any water => count that as +1\n    fragColor = vec4(4.)-vec4(\n        texture(iChannel0, uv + dif.xz).x+\n        texture(iChannel0, uv - dif.xz).x+\n        texture(iChannel0, uv + dif.zy).x+\n        texture(iChannel0, uv - dif.zy).x);\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//This holds the map that is saying where water can be from 1 - 0\n//Is not needed but is a lot cleaner\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "buffer_d_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 391]], "test": "untested"}
{"id": "tdKyzV", "name": "basic construction-v2", "author": "jorge2017a1", "description": "basic construction-v2", "tags": ["basicconstructionv2"], "likes": 5, "viewed": 295, "published": 3, "date": "1603286938", "time_retrieved": "2024-07-30T20:39:06.605888", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n// INFINITE BUILDINGS\nfloat obj_infiniteBuildings(in vec3 p)\n{\n\tvec3 c = vec3(12,10,20); // how close cubes are to each other\n\tvec3 f = vec3(8,10,7);\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.x = mod(q.x,f.x)-0.5*f.x;\n\t\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\tq.z = mod(q.z,f.z)-0.5*f.z;\n\t\n\t//building height\n\tvec3 b1 = vec3(1.0, 3.0, 1.0);\n    vec3 b2 = vec3(2.0, 3.0, 2.0);\n    \n\tfloat s1= sdBox(q-vec3(0.0,5.0,0.0),b1);\t\n    float s2= sdBox(q,b2);\t\n    return unionSDF(s1, s2);\n    //return s2;\n}\n\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 30.0-p.y;  //piso sup\n   \n    res =opU3(res, vec3(planeDist1,-1.0,2.0)); \n    res =opU3(res, vec3(planeDist2,27,MATERIAL_NO)); \n    \n    p.y=p.y-1.0;\n    \n    \n   \n   float ib1= obj_infiniteBuildings( p);\n   res =opU3(res, vec3(ib1,-1.0,5.0));\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO));\n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n       \n        \n        if(dO>MAX_DIST )\n        {\t\n            mObj.dist = -1.0;\n    \t\tmObj.id_color = -1.0;\n    \t\tmObj.marchCount=marchCount;\n    \t\tmObj.id_material=-1.0;\n            break;\n            //return -1.0;\n        }\n        \n        if (abs(dS.x)<MIN_DIST) \n        { break;  }\n            \n            \n        dO += dS.x;\n        marchCount++;\n        \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 64.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    \n    \n    vec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n       \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//Brick Color\nvec3 color_brick(in vec3 p)\n{\t\n\t//const vec3 brickColor = vec3(0.2,0.2,0.2);\n    vec3 brickColor = getColor(2);\n    \n        \n\tconst vec3 mortarColor = vec3(0.8);\n    \n    \n\tconst vec2 brickSize = vec2(0.3,0.15)*2.0;\n\tconst vec2 brickPct = vec2(0.9,0.85);\n\t\n\tvec2 position = (p.zy)/brickSize;\n\tvec2 useBrick = vec2(0);\n\t\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\t\t\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\t\n\tvec3 color =  mix(mortarColor, brickColor, useBrick.x*useBrick.y);\n\t\n\t\n\tposition = p.xy/brickSize;\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\tcolor = (color+mix(mortarColor, brickColor, useBrick.x*useBrick.y))/2.0;\n\t\n\treturn color;\n\t\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    \n    \n    if (id_material==5.0)\n    { \n     return color_brick(p);\n    }\n    \n   \n    \n     \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n//-------------------------------------------\n//referencia https://www.shadertoy.com/view/WsKyWW\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\n\n///-----------------------------------\nmat3 camera(vec3 ro, vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    ////referencia https://www.shadertoy.com/view/3dKyR1\n    // Camera\n    \n    float screenZ = 1.0;\n    vec3 rd = normalize(vec3(uv, screenZ));\n    vec3 ta = vec3(-1.5, 0.5, -1.);\n    vec3 ro = vec3(5.0, 2.5, 2.);\n    \n    float TimeMod=60.0;\n    \n   if (mod(iTime, TimeMod) < 10.)\n    {\n        ro *= mod(iTime, TimeMod);\n        \n    }\n    else if (mod(iTime, TimeMod) < 20.) \n    {\n        ro = vec3(-1., 1.5, 1.5);\n        \n        ro.x *= 0.5*mod(iTime, TimeMod)+2.0;\n        ro.y *= 0.5*mod(iTime, TimeMod)+2.0 ;\n        \n    }\n    else if (mod(iTime, TimeMod) < 30.) \n    {\n        ro = vec3(0.1, 5., 0.5);\n        ro.x += 2.;\n        ro.zy *= mod(iTime, TimeMod) - 18.;\n        ro.xy /= 2.;\n    }\n    else if (mod(iTime, TimeMod) < 40.) \n    {\n        ro = vec3(2., 0.5, 2.5);\n        ro.xy *= mod(iTime, TimeMod) - 30.;\n    }\n    else if (mod(iTime, TimeMod) < 50.) \n    {\n\n        ro = vec3(-5., 0.5, 2.5);\n    \n        ro.z *= mod(iTime, TimeMod) - 1.;\n    }\n    else if (mod(iTime, TimeMod) < 60.) \n    {\n  \n        ro = rotate(vec3(6., 6.5, 2.5), radians(iTime), vec3(1.0,0.0,0.0)) ;\n        ro.z *= mod(iTime, TimeMod) - 40.;\n    }\n    \n    \n    \n    \n    rd = camera(ro, ta) * normalize(vec3(uv, screenZ));\n\n\tlight_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n\n///--------------------------------------------\n\n", "sound_code": "\n//referencia \n//https://www.shadertoy.com/view/llBSzK\n//https://www.shadertoy.com/view/tdVyRK....Creado por jt en 2020-10-21\n//modificado por Jorge2017a1\n\n\nconst float trt = 1.0594630943592952645;\nconst float bpm = 140.0;\n\n\n\n#define N 96\n\nconst int base[N] = int[N](\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 3, 2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2\n);\n\nconst int voice[N] = int[N](\n    7, 7, 7, 7, 7, 7,\n    0, 0, 0, 0, 0, 0,\n    3, 5, 7, 7, 7, 7,\n    0, 0, 0, 0, 3, 5,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    5, 5, 5, 5, 5, 5,\n   -2,-2,-2,-2, 3, 2,\n    5, 5, 5, 5, 5, 5,\n   -2,-2,-2,-2, 3, 2,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n);\n\n\n\nfloat note2freq(float note) {\n    return 440.0 * pow(trt,note);\n}\n\nfloat sawWave(float time, float freq, float amp) {\n \t   return mod(time,1.0/freq)*freq*amp;\n}\n\n\n\n\n#define pi 3.1415926\n\nfloat wave(float t)\n{\n    return sin(2.0 * pi * t);\n}\n\nfloat saw(float t)\n{\n    return 2.0 * fract(t) - 1.0;\n}\n\n#define S 8.0\n\nivec2 note(float time)\n{\n    int n = int(floor(time * S)); // keep in sync with local\n    return ivec2(base[n % N] - 24, voice[n % N]);\n}\n\nfloat local(float time)\n{\n    return fract(time * S) / S; // keep in sync with note\n}\n\nfloat sound1(float freq, float time)\n{\n    float t = freq * time;\n    float h = clamp(1.0 - 4.0 * time, 0.0, 1.0); // linear\n    return mix(wave(t), saw(t), h) * h; // plucked string like sound\n}\n\nfloat sound2(float freq, float time)\n{\n    float t = freq * time;\n    float h = 0.5;\n    return mix(wave(t), saw(t), h);\n}\n\n\nvec2 bassSynth(float time, float tempo)\n{\t\n    \n     ivec2 n = note(time);\n    float t = local(time);\n    vec2 f = 0.5 * 440.0 * exp2(vec2(n) / 12.0);\n    //vec2 f = 0.5 *  exp2(vec2(n) / 12.0);\n    \n    float s1= sound2(f.y, t)*2.0;\n   \n    return vec2(s1+  sawWave(time, note2freq( float( n.x)), exp(-0.0*mod(tempo, 0.5))));\n\t\n    \n    \n}\n\n\nvec2 leadSynth(float time, float tempo) \n{\n    ivec2 n = note(time);\n    float t = local(time);\n    vec2 f = 0.5 * 440.0 * exp2(vec2(n) / 12.0);\n    //vec2 f = 0.5 *  exp2(vec2(n) / 12.0);\n\n    \n    float ampMask=1.0;\n    \n\t\n    return vec2(sawWave(time, note2freq(float(n.y)+0.01), ampMask * exp(-1.0*mod(tempo, 0.5))),\n                sawWave(time, note2freq(float( n.y)-0.01), ampMask * exp(-1.0*mod(tempo, 0.5))));\n\t\n    \n    \n}\n\nvec2 kickSynth(float time, float tempo) {\n    const float dist = 3.0;\n    tempo = mod(tempo,1.0); \n    return vec2(clamp(sin(pow((tempo+0.2)*0.0001,-0.5))*exp(-3.0*tempo),-(1.0/dist),(1.0/dist)) * dist);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 clapSynth(float time, float tempo) {\n    float q = floor(mod(tempo*2.0,32.0)); //quaver number;\n    float b = floor(q/8.0);//bar number\n    float qb = mod(q,8.0); //quaver in bar;\n    float ampMask = float((qb >= 2.0 && qb < 4.0) || (qb >= 6.0 && qb < 7.0)\n                         || (b == 3.0 && (qb == 1.0 || qb >= 5.0))); \n    tempo = mod(tempo*4.0 ,2.0);\n    return vec2(rand(vec2(time+1.2,tempo+6.1)) * ampMask * exp(-1.5*tempo),\n                rand(vec2(time+2.1,tempo+1.6)) * ampMask * exp(-1.5*tempo));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float t = time;\n    float tempo = t * (bpm/60.0);\n    \n    vec2 bass = bassSynth(t,tempo) * 0.30; //mixing here\n    vec2 lead = leadSynth(t*1.005,tempo) * 0.333;\n    vec2 kick = kickSynth(t,tempo) * 0.333;\n    vec2 clap = clapSynth(t,tempo) * 0.333;\n    \n    vec2 synths = bass + lead; //sidechain\n    //vec2 synths =  lead; //sidechain\n    \n    synths *= min(mod(tempo,1.0)+0.4,1.0);\n    \n    return synths + kick + clap;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 289, 289, 373], [374, 418, 465, 465, 492], [494, 494, 537, 537, 564], [566, 566, 614, 614, 642], [643, 714, 748, 748, 846], [847, 847, 881, 881, 973], [974, 974, 1008, 1008, 1100], [1101, 1141, 1175, 1175, 1272], [1275, 1297, 1337, 1337, 1804], [1809, 1849, 1874, 1874, 2365], [2367, 2412, 2479, 2479, 2847], [2848, 2899, 2923, 2923, 3111], [3112, 3175, 3208, 3208, 3924], [3926, 3980, 4016, 4016, 4250], [4307, 4341, 4421, 4421, 4870], [4913, 4927, 4956, 5003, 5689], [5692, 5743, 5790, 5790, 6491], [6545, 6545, 6638, 6638, 6909], [6911, 7008, 7053, 7053, 7407], [7410, 7449, 7480, 7480, 7638], [7639, 7688, 7745, 7745, 10046]], "test": "untested"}
{"id": "wdVcRV", "name": "Fancy blend effects", "author": "msteen", "description": "Four fancy blend effects for pictures. My first contribution to Shadertoy.", "tags": ["2d", "blend", "presentation"], "likes": 2, "viewed": 339, "published": 3, "date": "1603285503", "time_retrieved": "2024-07-30T20:39:07.501493", "image_code": "// \n// Fancy blend effects for pictures\n// \n// written 2020 by Martin Steen\n//\n\nvec2 uv;\nvec4 textureColor0;\nvec4 textureColor1;\nfloat phase;\nfloat aspectRatio;\n\n//---------------------------------------------------------------------------\n//\n// interpolateColor\n//\n//---------------------------------------------------------------------------\n\nvec4 interpolateColor(float phaseLim, float w, float a)\n{\n    vec4 textureColor;\n    float phaseLim1 = phaseLim - w;\n    float phaseLim2 = phaseLim + w;\n\n    if (a < phaseLim1)\n    {\n        textureColor = textureColor0;\n    }\n    else\n    if (a > phaseLim2)\n    {\n        textureColor = textureColor1;\n    }\n    else\n    {\n        float p = (a - phaseLim1) / (phaseLim2 - phaseLim1);\n        textureColor = mix(textureColor0, textureColor1, p);\n    }\n    return textureColor;\n}\n\n//---------------------------------------------------------------------------\n//\n// blend_Circle\n//\n//---------------------------------------------------------------------------\n\nvec4 blend_Circle()\n{\n    vec2 texVec;\n    texVec.x = (uv.x - 0.5) * 2.0;\n    texVec.y = (uv.y - 0.5 / aspectRatio) * 2.0;\n\n    float phaseLim = phase * 1.5;\n    float texVecLength = length(texVec);\n\n    return interpolateColor(phaseLim, 0.02, texVecLength);\n}\n\n//---------------------------------------------------------------------------\n//\n// blend_Halftone\n//\n//---------------------------------------------------------------------------\n\nvec4 blend_Halftone()\n{\n    const int xsegs = 24;\n    const int ysegs = 24;\n\n    float phaseLim  = phase * 1.5 / float(xsegs);\n    const float w = 0.05 / float(xsegs);\n\n    float seg_w = 1.0 / float(xsegs);\n    float seg_h = 1.0 / float(ysegs);\n\n    int segnumx = int(uv.x * float(xsegs));\n    int segnumy = int(uv.y * float(ysegs));\n\n    vec2 center;\n    center.x = float(segnumx) * seg_w + seg_w * 0.5;\n    center.y = float(segnumy) * seg_h + seg_h * 0.5;\n\n    float dist_to_center = length(uv - center);\n\n    return interpolateColor(phaseLim, w, dist_to_center);\n}\n\n//---------------------------------------------------------------------------\n//\n// blend_Halftone2\n//\n//---------------------------------------------------------------------------\n\nvec4 blend_Halftone2(float lim1, float lim2)\n{\n    const int segs = 32;\n\n    float phase = 1.0 - (uv.x - lim1) / (lim2 - lim1);\n    float seg_w = 1.0 / float(segs);\n\n    int segnumx = int(uv.x * float(segs));\n    int segnumy = int(uv.y * float(segs));\n\n    vec2 center;\n    center.x = float(segnumx) * seg_w + seg_w * 0.5;\n    center.y = float(segnumy) * seg_w + seg_w * 0.5;\n\n    float dist_to_center = length(uv - center) / seg_w;\n\n    return interpolateColor(phase, 0.05, dist_to_center);\n}\n\n//---------------------------------------------------------------------------\n//\n// blend_Shift\n//\n//---------------------------------------------------------------------------\n\nvec4 blend_Shift()\n{\n    float phaseLim = phase * 1.1;\n    return interpolateColor(phaseLim, 0.02, uv.x);\n}\n\n//---------------------------------------------------------------------------\n//\n// blend_ShiftFancy\n//\n//---------------------------------------------------------------------------\n\nvec4 blend_ShiftFancy()\n{\n    vec4 textureColor;\n    float w = 0.2;\n    float phaseLim = (phase - 0.2) * 1.4;\n    float phaseLim1 = phaseLim - w;\n    float phaseLim2 = phaseLim + w;\n\n    if (uv.x < phaseLim1)\n    {\n        textureColor = textureColor0;\n    }\n    else\n    if (uv.x > phaseLim2)\n    {\n        textureColor = textureColor1;\n    }\n    else\n    {\n        textureColor = blend_Halftone2(phaseLim1, phaseLim2);\n    }\n    return textureColor;\n}\n\n//---------------------------------------------------------------------------\n//\n// mainImage\n//\n//---------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord / iResolution.x;\n    aspectRatio = iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    int myFrame = iFrame % 300;\n    int effect = (iFrame / 300) % 4;\n    phase = float(myFrame) / 200.0;    \n        \n    \n    if (effect == 0)\n    {   \n        textureColor1 = texture(iChannel3, uv);\n        textureColor0 = texture(iChannel0, uv);\n        \n        fragColor = blend_Shift();\n    }\n    else\n    if (effect == 1)\n    {   \n        textureColor1 = texture(iChannel0, uv);        \n        textureColor0 = texture(iChannel1, uv);\n        \n        fragColor = blend_Circle();\n    }\n    else\n    if (effect == 2)\n    {\n        textureColor1 = texture(iChannel1, uv);\n        textureColor0 = texture(iChannel2, uv);\n        \n        fragColor = blend_Halftone();\n    }\n    else\n    if (effect == 3)\n    {\n        textureColor1 = texture(iChannel2, uv);\n        textureColor0 = texture(iChannel3, uv);        \n        fragColor = blend_ShiftFancy();\n    }\n    \n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 345, 402, 402, 823], [1004, 1004, 1025, 1025, 1264], [1447, 1447, 1470, 1470, 2014], [2198, 2198, 2244, 2244, 2691], [2871, 2871, 2891, 2891, 2978], [3163, 3163, 3188, 3188, 3616], [3794, 3794, 3851, 3901, 4890]], "test": "untested"}
{"id": "wsyyRV", "name": "Fab22 #inktober2020 \"chef\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nRef image: [url]https://cdn.franceloisirs.ch/13465-315-thickbox/ratatouille.jpg[/url]", "tags": ["2d", "short", "reproduction", "inktober2020"], "likes": 9, "viewed": 278, "published": 3, "date": "1603282700", "time_retrieved": "2024-07-30T20:39:08.274427", "image_code": "#define S smoothstep\n#define L( Y,t,A,B)                                \\\n     U.y -= Y,                                     \\\n     V = cos(t+vec2(0,11)),                        \\\n     a = A*V, b = (B-A)*V +.004*cos(60.*(iTime+Y)+vec2(0,11));  \\\n     O += S(3./R.y,0., length(U-a - b * clamp(dot(U-a, b) / dot(b, b), 0., 1.))); // adapted from https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y, V,a,b;\n         \n    U.y -= .3; V = U; V.y += .9;\n    O = vec4(1,.6,.6,1) * S(3./R.y,0.,length(V)-.1)   // --- nose\n                        * (.7-.3*sin(12.*(V.x-V.y))); // gradient\n    \n    if (U.y<.5 && U.y>-.75 ) {                        // --- hat\n        float y = (U.y+.5) * .82, \n              v = y/4. - pow(y,8.); // .82 = pow(4.,-1./7.) \n        v = 16.*U.x/(.7+2.3*sqrt(max(0.,v)));         // profile. see https://www.desmos.com/calculator/71inwt2pzu\n\n        O += (  .9 -.4*U.x                            // horizontal gradient\n              + sin(4.*asin(1.-mod(v,2.)))*(-.5<U.y?.1:0.) // folds. see https://www.shadertoy.com/view/3dKczV and https://www.desmos.com/calculator/7cg0bhown0?\n              + .3* S(.3,.5,U.y)                      // white top \n             )                         \n            * clamp(1.-(abs(v)-5.7)/fwidth(v),0.,1.); // bottom + antialiased shape\n    }\n    \n    U.x = abs(U.x);                                   // --- mustache\n    L(-.93,-.1 ,.14,.95)\n    L( .02, .05,.15,1. )\n    L( .02, .3 ,.14,.9 )\n    O += vec4(.04,.06,.36,1)*max(0.,1.-2.*O.w);       // background \n    \n    O = sqrt(O);                                      // to sRGB\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tsVcRK", "name": "outline of sdf", "author": "FabriceNeyret2", "description": "controling outline thickness  as minimal 1pixel thick vs given pixel width vs %scale.\n( compare at various resolutions )", "tags": ["outline", "tuto", "mm"], "likes": 2, "viewed": 343, "published": 3, "date": "1603277677", "time_retrieved": "2024-07-30T20:39:09.147093", "image_code": "  #define S(v) clamp(1. - (v)/scale, 0., 1. )  // Antialiased draw\n//#define S(v) smoothstep(1.5*scale, 0., v  )  // Note that these are assymetrical:\n                                               // it's usually a bad idea, but here an abs() is expected in v \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;               // centred - normalize coordinates. Vertical = [-1,1]\n    float scale = 2./R.y,                      // pixel width\n            sdf = min( length(U)-.3 ,          // disk1 UNION disk2\n                       length(U+.2+.2*sin(iTime) ) - .3);\n    O = vec4( S(sdf) );                        // antialiased drawing of main shape\n    O.r +=  S ( abs(sdf-.1) );                 // 1pix thick outline offsetted by 10% of unit scale.\n    O.g +=  S ( abs(sdf-.3) -.05 );            // 5% of unit scale thick outline \n    O.b +=  S ( abs(sdf-.5) -4.*scale );       // 4 pixel outline \n    \n    O = pow( O, vec4(1./2.2) );                // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 301, 301, 1019]], "test": "untested"}
{"id": "3dKczV", "name": "columns ( 78 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "fake3d", "short", "golf"], "likes": 7, "viewed": 283, "published": 3, "date": "1603266485", "time_retrieved": "2024-07-30T20:39:10.252139", "image_code": "// cf https://www.desmos.com/calculator/7cg0bhown0\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O += .5+.5* sin(2.* asin(2.-4.*fract(3.*U.x/iResolution.x)));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 88, 88, 155]], "test": "untested"}
{"id": "3sVcRV", "name": "Simple Webcam Edge Detection", "author": "oneshade", "description": "This uses a simple algorithm I came up with to perform simple edge detection. It doesn't handle noisy images very well but it is pretty good in my opinion.", "tags": ["edgedetection", "webcam"], "likes": 8, "viewed": 467, "published": 3, "date": "1603260040", "time_retrieved": "2024-07-30T20:39:11.095883", "image_code": "const float sensitivity = 0.035;\nconst float SQRT_2 = sqrt(2.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mat3 samples = mat3(0.0);\n    vec2 uv = vec2(0.0);\n\n    // Collect samples from the surrounding texels:\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            uv = (fragCoord + vec2(i, j)) / iResolution.xy;\n            vec3 curTexel = texture(iChannel0, uv).rgb;\n            samples[i + 1][j + 1] = (curTexel.r + curTexel.g + curTexel.b) / 3.0;\n        }\n    }\n\n    // Check whether the gradient over the area around the current texel is continuous:\n    // If it is not continuous, theoretically there is some sort of division or edge.\n    bool onEdge = false;\n    for (int i=0; i < 3; i++) {\n        for (int j=0; j < 3; j++) {\n            // Compute the difference between the texel the loop is currently on and the current (center) texel:\n            float gradient1 = samples[1][1] - samples[i][j];\n            // Compute the difference between the current (center) texel and the texel opposite the texel the loop is currently on:\n            float gradient2 = samples[2 - i][2 - j] - samples[1][1];\n            // If (i, j) is a corner, the differences need to be divided by sqrt(2) to be normalized:\n            if (i == j || (2 - i) == j) {\n                gradient1 /= SQRT_2;\n                gradient2 /= SQRT_2;\n            }\n            // Check whether both gradients are going in the same direction (whether the overall gradient is continuous):\n            if ((gradient1 >= sensitivity && gradient2 >= sensitivity) || (gradient1 < -sensitivity && gradient2 < -sensitivity)) {\n                onEdge = true;\n                break;\n            }\n        }\n    }\n\n    // Return a color based on whether the current texel is on an edge:\n    vec3 color = onEdge ? vec3(1.0, 0.6, 0.0) : vec3(samples[1][1]);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 121, 121, 1904]], "test": "untested"}
{"id": "WsKcRK", "name": "AutoWasher", "author": "xjorma", "description": "Please don't watch it on a phone.\nSimple particles physics using Position Based Dynamics.\nIt's my first \"physics\" inside a shader.", "tags": ["2d", "particles", "physics", "pbd"], "likes": 18, "viewed": 701, "published": 3, "date": "1603249242", "time_retrieved": "2024-07-30T20:39:12.096208", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nfloat smoothFilter(float d)\n{\n    float v = 2. / iResolution.y;\n    return smoothstep(v, -v, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 1.2;\n    vec3 col = vec3(0);\n    \n    col = mix(col, vec3(1,0,0), smoothFilter(map(uv, iTime)));\n    \n    for(int i = 0; i < PartNum; i++)\n    {\n        vec2 p = Load(i, CompPosition).xy;\n        col = mix(col, vec3(fract(Phi * float(i * 3)), fract(Phi * float(i * 3 + 1)), fract(Phi * float(i * 3 + 2))), smoothFilter(sdCircle(uv - p, BallRadius)));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nconst int PartNum\t\t= 32;\nconst int MaxCompPerRow\t= 256;\nconst float BallRadius\t= 0.1;\nconst float BallDiameter= BallRadius * 2.;\nconst float DeltaTime   = 1. / (60.);\nconst float Damping\t\t= 0.95;\nconst float Stiffness\t= 0.95;\n\nconst int CompPosition\t= 0;\nconst int CompPPosition\t= 1;\nconst int CompVelocity\t= 2;\nconst int CompNum\t\t= 3;\n\n\nconst float Phi \t\t=  (sqrt(5.)*0.5 + 0.5);\n\n\n// https://iquilezles.org/articles/distfunctions2d\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec2 rotate(in vec2 v, in float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2  m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nfloat map(in vec2 p, in float t)\n{\n    p = rotate(p, sin(t * 0.5) * 3.);\n    return sdStar5(p, 1.2, 0.6) - 0.1;\n}\n\nvec2 normal( in vec2 p, in float t) // for function f(p)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec2(map(p + h.xy, t) - map(p - h.xy, t),\n                           map(p + h.yx, t) - map(p - h.yx, t)));\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\n", "buffer_a_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// PBD 1st Iteration (Integration + 1st interation solving constraints)\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid positionBasedDynamics(inout vec2 pos, in vec2 vel, in int id)\n{\n    // basic integration\n    vel.y -= 9.8 * DeltaTime;\n    vel *= Damping;\n    pos = pos + vel * DeltaTime;\n    // enforce constraints\n    float d = max(0., map(pos, iTime) + BallRadius);\n    vec2 off = -d * normal(pos, iTime);\n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i != id)\n        {\n\t        vec2 pp = Load(i, CompPosition).xy;\n            vec2 v = pos - pp;\n            float d = length(v);\n            v = normalize(v);\n            if( d < BallDiameter)\n            {\n                off += 0.5 * v * (BallDiameter - d);\n            }\n        }\n    }\n    pos += off * Stiffness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    vec2\tpos;\n    vec2\tnewpos;\n    vec2\tvel;\n    if(iFrame == 0)\n    {\n        pos = ((vec2(pixId & 7, pixId >> 3)) - 4.) / 8.;\n        newpos = ((vec2(pixId & 7, pixId >> 3)) - 4.) / 8.;\n        vel = vec2(0);\n    }\n    else\n    {\n        pos = Load(pixId, CompPosition).xy;\n        vel = Load(pixId, CompVelocity).xy;\n        newpos = pos;\n        positionBasedDynamics(newpos, vel, pixId);\n    }\n    \n    Store(vec4(pos, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(newpos, 0, 0), CompPPosition, curComp, fragColor);\n    Store(vec4(0), CompVelocity, curComp, fragColor);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// PBD middle Iteration (interation solving constraints only)\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid positionBasedDynamics(inout vec2 pos,in int id)\n{\n    // enforce constraints\n    float d = max(0., map(pos, iTime) + BallRadius);\n    vec2 off = -d * normal(pos, iTime);\n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i != id)\n        {\n\t        vec2 pp = Load(i, CompPosition).xy;\n            vec2 v = pos - pp;\n            float d = length(v);\n            v = normalize(v);\n            if( d < BallDiameter)\n            {\n                off += 0.5 * v * (BallDiameter - d);\n            }\n        }\n    }\n    pos += off * Stiffness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    vec2\toldpos;\n    vec2\tnewpos;\n    oldpos = Load(pixId, CompPosition).xy;\n    newpos = Load(pixId, CompPPosition).xy;\n    positionBasedDynamics(newpos, pixId);\n    \n    Store(vec4(oldpos, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(newpos, 0, 0), CompPPosition, curComp, fragColor);\n    Store(vec4(0), CompVelocity, curComp, fragColor);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// PBD middle Iteration (interation solving constraints only)\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid positionBasedDynamics(inout vec2 pos,in int id)\n{\n    // enforce constraints\n    float d = max(0., map(pos, iTime) + BallRadius);\n    vec2 off = -d * normal(pos, iTime);\n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i != id)\n        {\n\t        vec2 pp = Load(i, CompPosition).xy;\n            vec2 v = pos - pp;\n            float d = length(v);\n            v = normalize(v);\n            if( d < BallDiameter)\n            {\n                off += 0.5 * v * (BallDiameter - d);\n            }\n        }\n    }\n    pos += off * Stiffness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    vec2\toldpos;\n    vec2\tnewpos;\n    oldpos = Load(pixId, CompPosition).xy;\n    newpos = Load(pixId, CompPPosition).xy;\n    positionBasedDynamics(newpos, pixId);\n    \n    Store(vec4(oldpos, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(newpos, 0, 0), CompPPosition, curComp, fragColor);\n    Store(vec4(0), CompVelocity, curComp, fragColor);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// PBD final Iteration (interation solving constraints + compute speed for next frame)\n\n\nvec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\nvoid positionBasedDynamics(inout vec2 pos, in vec2 oldpos, out vec2 vel,in int id)\n{\n    // enforce constraints\n    float d = max(0., map(pos, iTime) + BallRadius);\n    vec2 off = -d * normal(pos, iTime);\n    for(int i = 0; i < PartNum; i++)\n    {\n        if(i != id)\n        {\n\t        vec2 pp = Load(i, CompPosition).xy;\n            vec2 v = pos - pp;\n            float d = length(v);\n            v = normalize(v);\n            if( d < BallDiameter)\n            {\n                off += 0.5 * v * (BallDiameter - d);\n            }\n        }\n    }\n    pos += off * Stiffness;\n    // store final result\n    vel = (pos - oldpos) / DeltaTime;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= PartNum * CompNum)\n    {\n        discard;\n    }\n    vec2\toldpos\t= Load(pixId, CompPosition).xy;\n    vec2\tnewpos\t= Load(pixId, CompPPosition).xy;;\n    vec2\tvel;\n    positionBasedDynamics(newpos, oldpos, vel, pixId);\n    \n    Store(vec4(newpos, 0, 0), CompPosition, curComp, fragColor);\n    Store(vec4(0), CompPPosition, curComp, fragColor);\n    Store(vec4(vel, 0, 0), CompVelocity, curComp, fragColor);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKcRK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[114, 114, 149, 149, 269], [271, 271, 300, 300, 369], [371, 371, 428, 428, 920]], "test": "untested"}
{"id": "3dVczK", "name": "Koch Snowflake Kaleidoscope", "author": "oneshade", "description": "I watched The Art of Code's video on KIFS fractals and made this.", "tags": ["kaleidoscope", "snowflake", "koch"], "likes": 14, "viewed": 302, "published": 3, "date": "1603247052", "time_retrieved": "2024-07-30T20:39:12.981840", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    uv *= 1.25;\n\n    uv.x = abs(uv.x);\n    uv.y -= 0.28867513459;\n    vec2 n = vec2(sin(2.61799387799), cos(2.61799387799));\n    uv -= n * max(0.0, dot(uv - vec2(0.5, 0.0), n)) * 2.0;\n\n    n = vec2(sin(2.09439510239), cos(2.09439510239));\n    float scale = 1.0;\n    uv.x += 0.5;\n    for (int iters=0; iters < 10; iters++) {\n        uv *= 3.0;\n        scale *= 3.0;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n * min(0.0, dot(uv, n)) * 2.0;\n    }\n\n    color = texture(iChannel0, (uv / scale) * 2.0 + iTime * 0.05).rgb;\n    //float distLine = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0));\n    //color = vec3(smoothstep(1.0 / iResolution.y, 0.0, distLine / scale));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 891]], "test": "untested"}
{"id": "3dKczK", "name": "Jupiter cloud fractal", "author": "jarble", "description": "Another edit of [url=https://www.shadertoy.com/view/3sKyDw]\"Cells Under a Microscope\"[/url]", "tags": ["fractal", "cloud", "jupiter"], "likes": 3, "viewed": 302, "published": 3, "date": "1603246075", "time_retrieved": "2024-07-30T20:39:13.924320", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t = iTime*.3;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t+2.0);\n        //uv *= 10.0;\n        int c = 0;\n        for(int i=0;i<9;i++)\n        {\n            c = i%3;\n            float factor = 1.5;\n            vec2 uv1 = uv;\n            uv /= factor+col.xy;\n            uv += uv1;\n            uv += (sin(uv.yx))/factor;\n            uv *= factor;\n            col[c] += sin(uv.x+uv.y);\n        }\n    fragColor = vec4(col*100.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 531]], "test": "untested"}
{"id": "wdGyRK", "name": "G OOD", "author": "Arseny", "description": "Just word", "tags": ["2d"], "likes": 4, "viewed": 252, "published": 3, "date": "1603244467", "time_retrieved": "2024-07-30T20:39:14.780032", "image_code": "#define S smoothstep\n#define T iTime\n\n#define pi (3.14159265359)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 neon(float t, vec3 col){\n    t = 1. - t;\n    float mx=max(col.x, max(col.y, col.y));\n    return col * t / mx;\n}\n\nmat2 Rot(float a) {\n    a *= pi * 2.;\n    float s=sin(a), c=cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat seg(vec2 uv, vec2 a, vec2 b, float t){\n    t = clamp(0., 1., t);\n    return sdSegment(uv, a, t * (b - a) + a);\n}\n\nfloat polarAgl(vec2 v){\n    return fract((atan(v.y, v.x)) / pi / 2. + 1.);\n}\n\nfloat arcDist(vec2 uv, vec2 c, vec2 a, float agl){\n    vec2 v = uv - c;\n    vec2 b = a - c;\n    float r = length(b);\n    float d = length(v);\n    float uv_agl = fract((atan(v.y, v.x) - atan(b.y, b.x)) / pi / 2. + 1.);\n    uv_agl = fract(polarAgl(v) - polarAgl(b));\n    if (uv_agl < agl)\n    \treturn abs(d - r);\n    return min(length(uv - a), length(Rot(agl) * (a - c)  + c - uv));\n}\n\nvec3 boomEvaluateParametrs(vec2 uv, vec2 c, vec2 partsrange, vec2 speedrange, float seed){\n    vec2 v = uv - c;\n    float uv_agl = polarAgl(v);//fract(atan(v.y, v.x) / pi / 2. + 1.);\n    float partsnum = partsrange.x + floor((partsrange.y - partsrange.x) * hash12(vec2(seed, 31.41)));\n    float id = floor(uv_agl * partsnum - 1e-7) / partsnum;\n    float speed = speedrange.x + (speedrange.y - speedrange.x) * hash12(vec2(id, seed));\n    return vec3(id, partsnum, speed);\n}\n\nvec2 boomShift(vec2 uv, vec2 c, vec2 partsrange, vec2 speedrange, float seed){\n    vec3 tmp = boomEvaluateParametrs(uv, c, partsrange, speedrange, seed);\n    float id = tmp.x;\n    float partsnum = tmp.y;\n    float speed = tmp.z;\n    //return vec2(id);\n    return Rot(id + 0.5 / partsnum) * vec2(-speed, 0.);\n}\n\nvec2 boomed(vec2 uv, vec2 c, vec2 partsrange, vec2 speedrange, float seed, float t){\n    vec2 sh = boomShift(uv, c, partsrange, speedrange, seed) * t;\n    if (boomEvaluateParametrs(uv + sh * t, c, partsrange, speedrange, seed).x !=\n        boomEvaluateParametrs(uv, c, partsrange, speedrange, seed).x){\n        return vec2(1e9);\n    }\n    return uv + sh * t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float T = iTime / 2.;\n    float seed = floor(T / 12.) + 1.52;\n    T = mod(T, 12.);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv /= 2.;\n    \n    uv *= S(0., 1., T - 2.) * 1.4 + 1.;\n    uv.x += S(0., 1., T - 2.) / 2.;\n    vec2 buv = uv;\n    //uv += boomShift(uv, vec2(.5, -.5), vec2(30., 50.), vec2(.1, .2), 1.52) * S(8., 15., T) * 10.;\n    uv = boomed(uv, vec2(.5, -.5), vec2(30., 50.), vec2(.1, .2), seed, S(7., 12., T) * 3.5);\n    //uv += boomShift(uv, vec2(0., 0.), vec2(30., 50.), vec2(.1, .2), 1.52) * S(8., 15., T) * 10.;\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float d = arcDist(uv, vec2(0.), vec2(.2, .1), S(0., 1., T) * 0.85242);\n    d = min(seg(uv, vec2(.2, -.1), vec2(.1, -.1), S(0., 1., T - 1.)) + step(T, 1.), d);\n    \n    d = min(seg(uv, vec2(.2, -.1), vec2(.2, -.2), S(0., 1., T - 1.)) + step(T, 1.), d);\n    \n    d = min(arcDist(uv, vec2(.5, 0.), vec2(.7, .0), S(0., 1., T - 3.)) + step(T, 3.), d);\n    float tmp = arcDist(uv, vec2(0.9, 0.), vec2(.7, .0), S(0., 1., T - 3.)) + step(T, 3.);\n    tmp += step(abs(abs(T - 6.5) - 0.2), 0.1);\n    d = min(tmp, d);\n    \n    uv.y = abs(uv.y);\n    d = min(seg(uv, vec2(1.1, .0), vec2(1.1, 0.2), S(0., 1., T - 4.)) + step(T, 4.), d);\n    \n    uv.y = -uv.y;\n    d = min(arcDist(uv, vec2(1.1, 0.), vec2(1.1, -.2), S(0., 1., T - 5.) * 0.25) + step(T, 5.), d);\n    \n    \n    \n    fragColor = vec4(d * 100.);\n    fragColor = vec4(neon(d * 100., vec3(0.8, 0.3, 0.5)), 1.);\n    \n    uv = buv;\n    \n    //fragColor = vec4(uv + boomShift(uv, vec2(.5, -.5), vec2(30., 50.), vec2(.1, .2), 1.52), 0., 1.);\n    //fragColor = boomShift(uv, vec2(.0, -.0), vec2(5., 5.), vec2(.1, .2), 1.52).xxxx;\n    //fragColor = vec4(length(Rot(1./5.) * vec2(0.3, 0.) - uv) * 100.);\n    //fragColor = vec4(fract(atan(uv.y, uv.x) / pi / 2. + 1.));\n    return;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 107, 129, 129, 279], [281, 281, 310, 310, 397], [399, 399, 418, 418, 498], [500, 540, 581, 581, 655], [657, 708, 760, 760, 879], [881, 881, 925, 925, 999], [1001, 1001, 1024, 1024, 1077], [1079, 1079, 1129, 1129, 1461], [1463, 1463, 1553, 1553, 1935], [1937, 1937, 2015, 2015, 2246], [2248, 2248, 2332, 2332, 2608], [2610, 2610, 2667, 2717, 4647]], "test": "untested"}
{"id": "3dVcRK", "name": "Circuit Flow", "author": "oneshade", "description": "I used some of the edge detection code I used in one of my previous shaders on a scrolling noise texture and got this really cool effect!", "tags": ["noise", "edges", "circuit"], "likes": 11, "viewed": 290, "published": 3, "date": "1603236728", "time_retrieved": "2024-07-30T20:39:15.577899", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord += iTime;\n    mat3 samples = mat3(0.0);\n    vec2 uv = vec2(0.0);\n\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            uv = (fragCoord + vec2(i, j)) / iResolution.xy;\n            samples[i + 1][j + 1] = texture(iChannel0, uv).x;\n        }\n    }\n\n    bool onBound = false;\n    for (int i=0; i < 3; i++) {\n        for (int j=0; j < 3; j++) {\n            if (i != 1 && j != 1) {\n                float gradient1 = samples[1][1] - samples[i][j];\n                float gradient2 = samples[2 - i][2 - j] - samples[1][1];\n                if ((gradient1 >= 0.015 && gradient2 >= 0.015) || (gradient1 < -0.015 && gradient2 < -0.015)) {\n                    onBound = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    vec3 color = onBound ? vec3(0.0) : vec3(1.0);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 922]], "test": "untested"}
{"id": "WsGyzV", "name": "My First Voronoi Shader", "author": "oneshade", "description": "I got some knowledge about how voronoi cells work from The Art of Code and made this. I used my edge detection algorithm from my shader \"Simple Webcam Edge Detection\" (https://www.shadertoy.com/view/3sVcRV) to draw the cell boundaries.", "tags": ["voronoi", "edgedetection", "edges"], "likes": 5, "viewed": 259, "published": 3, "date": "1603205567", "time_retrieved": "2024-07-30T20:39:16.495446", "image_code": "// Edge detection algorithm from my shader \"Simple Webcam Edge Detection\" (https://www.shadertoy.com/view/3sVcRV).\nconst bool DETECT_EDGES = true;\nconst float SQRT_2 = sqrt(2.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    float sensitivity = 3.624 / iResolution.y;\n\n    if (DETECT_EDGES) {\n        mat3 samples = mat3(0.0);\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                uv = (fragCoord + vec2(i, j)) / iResolution.xy;\n                vec3 curTexel = texture(iChannel0, uv).rgb;\n                samples[i + 1][j + 1] = max(curTexel.r, max(curTexel.g, curTexel.b));\n            }\n        }\n\n        bool onEdge = false;\n        for (int i=0; i < 3; i++) {\n            for (int j=0; j < 3; j++) {\n                float gradient1 = samples[1][1] - samples[i][j];\n                float gradient2 = samples[2 - i][2 - j] - samples[1][1];\n                if (i == j || (2 - i) == j) {\n                    gradient1 /= SQRT_2;\n                    gradient2 /= SQRT_2;\n                }\n\n                if ((gradient1 >= sensitivity && gradient2 >= sensitivity) || (gradient1 < -sensitivity && gradient2 < -sensitivity)) {\n                    onEdge = true;\n                    break;\n                }\n            }\n        }\n\n        color = onEdge ? color : vec3(1.0, 0.6, 0.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 GetPoint(in vec2 cell) {\n    return 0.5 + 0.5 * vec2(sin(cell.x - cell.y + iTime), cos(cell.x + cell.y * iTime));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 cellLocation = floor(uv);\n\n    float minDist = length(uv - (cellLocation + GetPoint(cellLocation)));\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + GetPoint(curCellLocation);\n            minDist = min(minDist, length(uv - curCellPoint));\n        }\n    }\n\n    vec3 color = 1.0 - vec3(minDist);\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 235, 235, 1469]], "test": "untested"}
{"id": "wdVcRy", "name": "Fab21 #inktober2020 \"sleep\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 18, "viewed": 373, "published": 3, "date": "1603180578", "time_retrieved": "2024-07-30T20:39:17.450891", "image_code": "#define L length//\n#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n#define B(q,a,b,c)  max( (q).x-a, max( (q).y-b, (q).z-c) )    // box\n#define T(q,R,r)   ( L( vec2( L(L((q).xy) -R ), (q).z ) ) -r )// torus\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s,S,c,r,f,F=t;\n    vec3  R = iResolution, Y = vec3(0,1,0),\n          M = iMouse.z > 0. ? iMouse.xyz/R-.5 : vec3(4,2,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -1.5*R.y ) - R ),          // ray direction\n          p = vec3(0), q,a,k;                                 // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.015 )\n        q = p, t=9.,\n        q.yz *= rot(-6. *M.y),                                // rotations,\n        q.xz *= rot(-6.4*M.x),  q +=  vec3(0,9,10),           // translation\n        k=q, k.xz = abs(k.xz), k.x<k.z ? k.xz=k.zx : U,       // crypt walls\n        t = min(t, s = min( 15.-L(k.yx), k.y )  ),\n        a = k, a.xz*=mat2(1,-1,1,1)*.5,                       // crypt arches\n        t = min(t, S = T( a.yzx, 15.,.3) ), \n        t = min(t, r = T( q- 14.2*Y, .6,.1) ),                // ring\n        a = abs(q+vec3(0,0,10)), t = min(t, B(a, 2.,1.,5.) ), // white base\n        q = vec3( abs(q.x)-7., q.y-5., q.z+10. ),\n        t = min(t, c = min( B(a, 1.8,3.,4.5) ,                // black coffin\n                            max( L( q.xz ) - .3, q.y) )),     // candlesticks\n        t = min(t, f = L((q-Y)/vec3(1,3,1)-.03*sin(30.*iTime+q.y))-.2 ), // flame\n        F = min(F,f),                                         // for glow\n        p += t*D;                                             // step forward = dist to obj          \n\n    \n    O = exp(-2.5*O);                                          // --- coloring\n    O += vec4(1,.5,.2,0)* ( 2./(f*f) + .05/(F*F) );           // flame lighting + halo\n    if (t==c || t==r) O *= .3;                                // coffin && roof ring\n    if (t==S)  s=S, k.z=5.;                                   // arches\n    if (t==s)  O *= vec4(1,.9,.8,1)                           // crypt walls\n                  * texture(iChannel0, vec2( .1*k.z, atan(k.y,k.x)/.63 ));\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVcRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 288, 288, 2196]], "test": "untested"}
{"id": "tdVcRy", "name": "iterative uv mirror and rotate", "author": "StrangerintheQ", "description": "iterative uv mirror and rotate", "tags": ["uv"], "likes": 3, "viewed": 320, "published": 3, "date": "1603176006", "time_retrieved": "2024-07-30T20:39:18.295633", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 sc = vec2(sin(iTime), cos(iTime));\n    float k = length(uv)*0.15 - 0.01*sc.x - 0.05;\n    for (float i = 0.; i < 6.; i++) {\n        uv = abs(uv) + k;\n        uv *= mat2(sc.x, -sc.y, sc.y, sc.x);\n    }\n    uv = pow(uv, vec2(0.3 + cos(iTime/3.)*0.05));\n    fragColor = vec4(uv, pow(uv.y,uv.x), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVcRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 451]], "test": "untested"}
{"id": "wdVyWm", "name": "Metaball Flock", "author": "xjorma", "description": "My first experiment with particles, you can use the mouse to turn around.\nNot my prettiest one but I found it very fascinating to watch. Can't stop staring at it. 😉\nFast on my old PC but very slow on my phone, please watch on PC. ", "tags": ["particles", "metaball", "flock", "vectorball", "pbd"], "likes": 20, "viewed": 604, "published": 3, "date": "1603163845", "time_retrieved": "2024-07-30T20:39:19.266038", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA 0\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\n\nvec3 Fog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.3 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float mint = dist;\n    vec3  c = vec3(0);\n    for(int i = 0; i < NB_PART; i++)\n    {\n        vec3 pos = Load(i).xyz;\n        float t = sphIntersect( ro, rd, pos, BALL_RADIUS).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            c = pos;\n        }     \n    }\n    \n    vec3 col;\n    if(mint<dist)\n    {\n        vec3 i = (ro + mint * rd);\n        vec3 n = normalize(i - c);\n        vec3 r = reflect(rd, n);\n        col = texture(iChannel1, r).rgb * color(i, iTime);\n        col = Fog(col, mint, vec3(0)); \n    }\n    else\n    {\n        col = vec3(0);\n    }\n    \n    \n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 3.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],12.);\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n\n", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define NB_PART\t\t\t512\n#define MAX_PER_ROW\t\t256.\n#define BALL_RADIUS\t\t0.05\n#define BALL_RANGE\t\tvec3(0.3,1.,1.);\n\n\n#define COLOR_0\t\tvec3(255, 215,   0) / 255.;\n#define COLOR_1 \tvec3(184, 115,  51) / 255.;\n#define COLOR_2\t\tvec3(200, 200, 200) / 255.;\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdf0(in vec3 p, in float t)\n{\n    vec3  d = BALL_RANGE;\n    float r = 0.6;\n    return sdSphere( p - d*vec3(sin(t / 2.0 + 3.2), sin(t / 2.1 + 0.4), sin(t / 2.3 + 0.7)), r );\n}\n\nfloat sdf1(in vec3 p, in float t)\n{\n    vec3  d = BALL_RANGE;\n    float r = 0.6;\n    return sdSphere( p - d*vec3(sin(t / 2.4 + 1.3), sin(t / 1.9 + 2.2), sin(t / 2.5 + 1.2)), r );\n}\n\nfloat sdf2(in vec3 p, in float t)\n{\n    vec3  d = BALL_RANGE;\n    float r = 0.6;\n    return sdSphere( p - d*vec3(sin(t / 2.9 + 2.3), sin(t / 3.0 + 0.3), sin(t / 2.6 + 2.8)), r );\n}\n\n\nconst float k = 8.;\n\nfloat map(in vec3 p, float t)\n{\n    // MetaBall\n \tfloat sminAcc = 0.;\n    sminAcc += exp2(-k * sdf0(p, t));\n    sminAcc += exp2(-k * sdf1(p, t));\n    sminAcc += exp2(-k * sdf2(p, t));\n    return -log2( sminAcc )/k;\n}\n\n#define EPS  0.001\nvec3 calcNormal( in vec3 pos, float t)\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, t ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, t ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, t ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, t ) );\n}\n\nconst float IDWMin = 0.01;\n// https://en.wikipedia.org/wiki/Inverse_distance_weighting\nvec3 color(in vec3 pos, in float t)\n{\n    vec3 c0 = COLOR_0;\n    vec3 c1 = COLOR_1;\n    vec3 c2 = COLOR_2;\n    float d0 = 1. / max(sdf0(pos, t), IDWMin);\n    float d1 = 1. / max(sdf1(pos, t), IDWMin);\n    float d2 = 1. / max(sdf2(pos, t), IDWMin);    \n    return (c0 * d0 + c1 * d1  + c2 * d2) / ( d0 + d1 + d2);\n}", "buffer_a_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nvec4 Load(in int id)\n{\n\treturn texelFetch(iChannel0, ivec2(id % int(MAX_PER_ROW), id / int(MAX_PER_ROW)), 0);\n}\n\n\nconst float pushDist = BALL_RADIUS * 8.;\n\nvec3 push(in vec3 p, in int id)\n{\n    vec3 off = vec3(0);\n    for(int i = 0; i < NB_PART; i++)\n    {\n        if(i != id)\n        {\n\t        vec3 pp = Load(i).xyz;\n            vec3 v = p - pp;\n            float d = length(v);\n            if( d < pushDist)\n            {\n                off += 0.5 * v * pow(pushDist - d, 2.);\n            }\n        }\n    }\n    return p + off;\n}\n\nvec3 project(in vec3 p, in float t)\n{\n    vec3 n = calcNormal(p, t);\n    float d = map(p, t);\n    return p - d * n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + MAX_PER_ROW * fragCoord.y);\n    if( fragCoord.x >= MAX_PER_ROW || pixId >= NB_PART)\n    {\n        discard;\n    }\n    vec3\tpos;\n    if(iFrame == 0)\n    {\n        pos = ((vec3(pixId & 7, (pixId>>3) & 7, pixId>>6)) - 4.) / 8.;\n        pos = push(pos, pixId);\n    }\n    else\n    {\n        pos = Load(pixId).xyz;\n        pos = push(pos, pixId);\n        pos = project(pos, iTime);\n    }    \n    fragColor = vec4(pos,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVyWm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[128, 128, 150, 150, 239], [243, 243, 293, 293, 389], [392, 392, 441, 441, 1056], [1059, 1059, 1101, 1101, 1265]], "test": "untested"}
{"id": "3dKyRG", "name": "lift", "author": "lennyjpg", "description": "sdfsdfsdfasdf", "tags": ["sdfsdfsfdasdf"], "likes": 1, "viewed": 254, "published": 3, "date": "1603159890", "time_retrieved": "2024-07-30T20:39:20.185580", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 u = uv;\n    float t = iTime * -0.1;\n    u += vec2(-.5,-0.2);\n    u.x = abs(u.x)+.7;\n    u.x = fract(u.x*3.0);\n    float a = atan(u.y,u.x)+t;\n    float k = fract(a*0.7);\n    vec3 ca = vec3(1.2,0.1,-0.3);\n    vec3 cb = vec3(.8,0.9,1.29);\n    vec3 cc = mix(ca, cb, k);\n    if(k>0.5){\n      cc.r -= uv.y;\n    }\n    fragColor = vec4(cc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 445]], "test": "untested"}
{"id": "wsKcRG", "name": "Fractures", "author": "wyatt", "description": "...", "tags": ["deformation"], "likes": 10, "viewed": 498, "published": 3, "date": "1603156512", "time_retrieved": "2024-07-30T20:39:20.990428", "image_code": "// Fork of \"Support Your Neighbors\" by wyatt. https://shadertoy.com/view/3dyyRy\n// 2020-10-20 00:02:46\n\n// Fork of \"Self-Designed Bridge\" by wyatt. https://shadertoy.com/view/wsGcWm\n// 2020-10-19 01:08:25\n\nMain {\n    vec4 a = A(U), b = B(U);\n    vec4\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    vec3 no = normalize(vec3(e.w-w.w,n.w-s.w,.1));\n    vec3 ref = reflect(vec3(0,0,1),no);\n   \tvec3 l = 2.*R.xyy;\n    float li = ln(vec3(U,0),vec3(U,0)+ref,l);\n    Q = (.2+a.w)*(0.7+0.3*sin(1.9+(abs(b.x*b.z-b.w*b.y)+abs(b.y*b.z-b.w*b.x))*3.+vec4(1,2,3,4)));\n    Q *= exp(-.5*li)+10.*exp(-6.*li);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}", "buffer_a_code": "Main\n{\n\tQ = A(U);vec2 f = vec2(0); vec4 b = B(U);float m = 0.;\n    float s = 0.;\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 w = 0.125*Q.w*aa.w*(mat2(bb)*mat2(bb)-mat2(1))*u;\n        s += length(w);\n        f += w;\n        f += .1*0.125*Q.w*aa.w*(aa.xy-Q.xy);\n    \tm += 0.125*aa.w;\n    }\n    s/=m*Q.w;\n    Q.y -= 1e-3;\n    if (s>0.15) Q.w *= 0.9;\n    Q.xy += f*Q.w;\n    if (U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.x-U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.y-U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    \n    if (iMouse.z>0.)Q.x += .06*exp(-.3*length(U-iMouse.xy));\n    if (iFrame<1) Q = vec4(0,0,0,1);\n    Q = clamp(Q,-1.,1.);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n\tQ = B(U);vec4 f = vec4(0), a = A(U), m = vec4(0);\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 dv = aa.xy-a.xy;\n        m += bb;\n        f += 0.125*a.w*aa.w*vec4(u.x*dv.x,u.x*dv.y,u.y*dv.x,u.y*dv.y);\n    }\n    Q += vec4(mat2(Q)*mat2(f));\n    Q = mix(Q,0.125*m,.001);\n    if (iFrame<1) Q = vec4(1,0,0,1);\n    Q = clamp(Q,-2.,2.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n\tQ = A(U);vec2 f = vec2(0); vec4 b = B(U);float m = 0.;\n    float s = 0.;\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 w = 0.125*Q.w*aa.w*(mat2(bb)*mat2(bb)-mat2(1))*u;\n        s += length(w);\n        f += w;\n        f += .1*0.125*Q.w*aa.w*(aa.xy-Q.xy);\n    \tm += 0.125*aa.w;\n    }\n    s/=m*Q.w;\n    if (s>0.12) Q.w *= 0.8;\n    Q.xy += f*Q.w;\n    if (U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.x-U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.y-U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    \n    if (iMouse.z>0.)Q.x += .06*exp(-.3*length(U-iMouse.xy));\n    if (iFrame<1) Q = vec4(0,0,0,1);\n    Q = clamp(Q,-1.,1.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n\tQ = B(U);vec4 f = vec4(0), a = A(U), m = vec4(0);\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 dv = aa.xy-a.xy;\n        m += bb;\n        f += 0.125*a.w*aa.w*vec4(u.x*dv.x,u.x*dv.y,u.y*dv.x,u.y*dv.y);\n    }\n    Q += vec4(mat2(Q)*mat2(f));\n    Q = mix(Q,0.125*m,.001);\n    if (iFrame<1) Q = vec4(1,0,0,1);\n    Q = clamp(Q,-2.,2.);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WdKczy", "name": "Angle reflection, letter M", "author": "henrmota", "description": "Experiment following lessons from The art of code on youtube", "tags": ["reflection"], "likes": 3, "viewed": 250, "published": 3, "date": "1603146950", "time_retrieved": "2024-07-30T20:39:21.763361", "image_code": "#define PI 3.14115\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\t/*\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float angle = mouse.x * PI;\n    \n   \t\n    vec2 rotation = vec2(sin(angle), cos(angle));\n    float d = dot(uv, rotation);\n    uv -= min(d,0.)*rotation*2.0;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1. - step(1./iResolution.y, abs(d/3.)));\n\tcol.rg += cos(uv * 60.);\n    */\n    \n    uv *= 4.0;\n    \n    vec3 col = vec3(0);\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float angle = (2./3.)* PI;\n    \n   \t\n    vec2 rotation = vec2(sin(angle), cos(angle));\n    \n    uv.x = abs(uv.x);\n \tuv.x -= 0.5;\n    uv -= min(dot(uv, rotation),0.)*rotation*2.0;\n    float d = distance(uv, vec2(clamp(uv.x, -1., 1.), 0.));\n   \n    col += smoothstep(2./iResolution.y, 0.0, d/3.);\n    // Output to screen\n    vec4 music = texture(iChannel0, abs(uv.xx));\n    fragColor = max(\n        texture(iChannel1, abs(uv)),\n        mix(music.xyyw, music.yyxw, abs(sin(iTime)))\n    ) + (music.yxyw * abs(sin(iTime)));\n    // Uncomment below to see the underlying reflection\n    //fragColor = vec4(vec3(smoothstep(0.03, 0., d)), 1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 126, 1265]], "test": "untested"}
{"id": "WsVyRy", "name": "Attractor Space", "author": "workingclasshacker", "description": "Using the Lorenz Attractor in a SDF, still need to figure out how to make it translucent...", "tags": ["3d", "raymarching", "attractor"], "likes": 4, "viewed": 347, "published": 3, "date": "1603139169", "time_retrieved": "2024-07-30T20:39:22.530311", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST 0.001\n#define MAX_DIST 100.0\n\n\nfloat t;\n\nmat2 Rot2d(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, - s, s, c);\n}\nfloat differenceSdf(float a, float b){\n  return max(-a,b);\n}\nfloat sdLorrenz(vec3 p, float sigma, float rho, float beta, float scale){\n  float dx = sigma * (p.y-p.x);\n  float dy = p.x * (rho - p.z) - p.y;\n  float dz = p.x * p.y - beta * p.z;\n  return length(vec3(dx*scale, dy*scale, dz*scale));\n  //return length(vec3(dx, dy, dz));\n}\nfloat GetDist(vec3 p){\n  // replace with your scene\n  p = abs(p*1.5);\n  float d = sdLorrenz(p, 10., 28., 8./4.,.004);\n  float d2 = sdLorrenz(vec3(p.x-.01, p.y+.01, p.z), 10., 28., 8./4., .005);\n  //float d = sdBox(p, vec3(.5,.5,.5));\n  //float d2 = sdBox(p, vec3(.2,.2,1.5));\n  //return d2;\n  d = max(d, d2);\n  return d;//differenceSdf(d*1.4, d2*.4);\n}\n\nvec3 GetNormal(vec3 p) {\n  vec2 e = vec2(0.02, 0);\n  float d = GetDist(p);\n  vec3 n = d-vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n  return normalize(n);\n}\nvec3 Bg(vec3 rd){\n  float k = rd.y*.5+.5;\n  float d = sin(t)*.5+.5;\n  float s = cos(t)*.5+.5;\n  float dark = .2;\n  vec3 col = mix(vec3(d,s,0.),vec3(s,d,1.),k);\n  return col*dark;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p),\n  r = normalize(cross(vec3(0, 1, 0), f)),\n  u = cross(f, r),\n  c = p+f * z,\n  i = c+uv.x * r+uv.y * u,\n  d = normalize(i - p);\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.0;\n  for(int i = 0; i < MAX_STEPS; i ++ ) {\n    vec3 p = ro + dO * rd;\n    float ds = GetDist(p);\n    dO += ds;\n    if (dO < SURFACE_DIST||dO > MAX_DIST) {\n      break;\n    }\n  }\n  return dO;\n}\nvec3 render(vec2 uv){\n  vec3 color = vec3(0);\n  \n  // camera\n  \n  vec3 camO = vec3(0, 0, -50.);\n  camO.yx *= Rot2d(t);\n  camO.xz *= Rot2d(t);\n  vec3 lookAt = vec3(0, 0, 0);\n  vec3 rd = GetRayDir(uv, camO, lookAt, 1.0);\n  color += Bg(rd);\n  // trace scene\n  float d = RayMarch(camO, rd);\n\n  // material\n  if (d < MAX_DIST) {\n    vec3 p = camO + rd * d;\n    vec3 n = GetNormal(p);\n    vec3 reflect = reflect(rd, n);\n    float height = p.y;\n    float dif = dot(n, normalize(vec3(1.,.5,.0)))*.5+.5;\n    float spec = pow(reflect.y*.5+.5, 10.);\n    color = n*.5+.5;\n    color *= pow(1./d,0.3);\n    color += mix(Bg(reflect),vec3(dif),.4);\n    color += vec3(spec);\n  }\n  return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tt = iTime/5.0;\n\tvec3 color = render(uv);\n  \tcolor = pow(color, vec3(.4545)); //correct gamma\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 105, 105, 176], [177, 177, 215, 215, 237], [238, 238, 311, 311, 510], [511, 511, 533, 562, 863], [865, 865, 889, 889, 1043], [1044, 1044, 1061, 1061, 1224], [1225, 1225, 1275, 1275, 1445], [1447, 1447, 1481, 1481, 1690], [1691, 1691, 1712, 1712, 2369], [2370, 2370, 2427, 2477, 2689]], "test": "untested"}
{"id": "WdVyzG", "name": "Solar System Screensaver", "author": "Manaz", "description": "Minimalistic recreation of the solar system using squares", "tags": ["space"], "likes": 4, "viewed": 347, "published": 3, "date": "1603132720", "time_retrieved": "2024-07-30T20:39:23.451846", "image_code": "/*\nby Manas Khadka 18 October 2020.\n\nThis is my first ever shader. Just me messing around.\nDistance between planets and sun is not perfect.\nAll planets and their orbits are to scale unless specified.\nThe sun's radius is 1/4 what it should be.\n\nA lot of reference is taken from Uğur Güney's GLSL 2D Tutorials.\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.0005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = vec2(fragCoord.xy - 0.5*iResolution.xy);\n\tr = 2.0 * r.xy / iResolution.y;\n\t// r.y will be in [-1.0, 1.0]\n\t// r.x will be in [-1.7778, 1.7778] (16:9 resolution) \n    \n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    // p.x and p.y will be in [0.0, 1.0]\n    \n    float xMax = iResolution.x/iResolution.y;\n    // in case the maximum x value is needed for reference in r.xy\n    \n\tvec3 ret;\n\n//START OF CHANGEABLE VARIABLES\n   \n   \tvec3 col =  0.5*sin(iTime*.05*vec3(8,6,4));\n    // time changing color - if you don't like it just comment this line out and remove the // from below\n    // vec3 col = vec3(.2);\n  \n    float mercRev = 7.5;\n    // change this variable to change the speed of all orbits\n    \n     float mercOrbit = .025;\n    // change this variable to change the distance of orbits\n    // make it bigger to zoom in on the orbit; smaller to zoom out (the size of planets/sun don't change)\n    \n    float sunRadius = 0.1;\n    // change this variable to change the size of all objects\n\n    vec3 colSun = vec3(1);\n    vec3 colMerc = vec3(1);\n    vec3 colVen = vec3(1);\n    vec3 colEarth = vec3(1);\n    vec3 colMars = vec3(1);\n    vec3 colJup = vec3(1);\n    vec3 colSat = vec3(1);\n    vec3 colUran = vec3(1);\n    vec3 colNept = vec3(1);\n    // if you want to color the planets, do so here!\n    \n//END OF CHANGEABLE VARIABLES\n   \n    float mercRadius = sunRadius / 66.0 * 2.0;\n    // modelled at 1/2 scale (double what it should be)\n    float venRadius = sunRadius / 26.6 * 2.0;\n    // modelled at 1/2 scale \n    float earthRadius = sunRadius / 25.0 * 2.0;\n    // modelled at 1/2 scale \n    float marsRadius = sunRadius / 47.6 * 2.0;\n    // modelled at 1/2 scale\n    float jupRadius = (sunRadius / 2.3);\n    float satRadius = (sunRadius / 2.76);\n    float uranRadius = sunRadius / 6.35;\n    float neptRadius = sunRadius / 6.54;\n    \n    float venRev = mercRev/2.55;\n    float earthRev = mercRev/ 5.15;\n    float marsRev = mercRev/7.8;\n    float jupRev = mercRev/45.6;\n    float satRev = mercRev/122.36;\n    float uranRev = mercRev/369.6;\n    float neptRev = mercRev/732.2;\n   \n    float venOrbit = mercOrbit * 1.82;\n    float earthOrbit = mercOrbit * 2.95;\n    float marsOrbit = mercOrbit * 4.25;\n    float jupOrbit = mercOrbit * 13.14;\n    float satOrbit = mercOrbit * 18.12;\n    float uranOrbit = mercOrbit * 30.24;\n    float neptOrbit = mercOrbit * 47.7;\n        \n    float xMerc = (0.14 + mercOrbit)*cos(iTime*mercRev);\n    float yMerc = (0.14 + mercOrbit)*cos(iTime*mercRev + PI/2.0);\n    \n    float xVen = (0.15 + venOrbit)*cos(iTime*venRev);\n    float yVen = (0.15 + venOrbit)*cos(iTime*venRev + PI/2.0);\n    \n    float xEarth = (0.15 + earthOrbit)*cos(iTime*earthRev);\n    float yEarth = (0.15 + earthOrbit)*cos(iTime*earthRev + PI/2.0);\n    \n    float xMars = (0.15 + marsOrbit)*cos(iTime*marsRev);\n    float yMars = (0.15 + marsOrbit)*cos(iTime*marsRev + PI/2.0);\n    \n    float xJup = (0.15 + jupOrbit)*cos(iTime*jupRev);\n    float yJup = (0.15 + jupOrbit)*cos(iTime*jupRev + PI/2.0);\n    \n    float xSat = (0.15 + satOrbit)*cos(iTime*satRev);\n    float ySat = (0.15 + satOrbit)*cos(iTime*satRev + PI/2.0);\n    \n    float xUran = (0.15 + uranOrbit)*cos(iTime*uranRev);\n    float yUran = (0.15 + uranOrbit)*cos(iTime*uranRev + PI/2.0);\n    \n    float xNept = (0.15 + neptOrbit)*cos(iTime*neptRev);\n    float yNept = (0.15 + neptOrbit)*cos(iTime*neptRev + PI/2.0);\n    \n    float sunx = 0.001*cos(iTime*1.0);\n    float suny = 0.001*cos(iTime*1.0 + PI/2.0);\n\n    ret = col;\n    // background color\n    \n    float radius = 0.2 + 0.1*sin(iTime*2.0);;\n    ret = mix(ret, colSun, rect(r, vec2(sunx-sunRadius, suny-sunRadius), vec2(sunx+sunRadius, suny+sunRadius)));\n    ret = mix(ret, colMerc, rect(r, vec2(xMerc-mercRadius, yMerc-mercRadius), vec2(xMerc+mercRadius, yMerc+mercRadius)));\n    ret = mix(ret, colVen, rect(r, vec2(xVen-venRadius, yVen-venRadius), vec2(xVen+venRadius, yVen+venRadius)));\n    ret = mix(ret, colEarth, rect(r, vec2(xEarth-earthRadius, yEarth-earthRadius), vec2(xEarth+earthRadius, yEarth+earthRadius)));\n    ret = mix(ret, colMars, rect(r, vec2(xMars-marsRadius, yMars-marsRadius), vec2(xMars+marsRadius, yMars+marsRadius)));\n    ret = mix(ret, colJup, rect(r, vec2(xJup-jupRadius, yJup-jupRadius), vec2(xJup+jupRadius, yJup+jupRadius)));\n    ret = mix(ret, colSat, rect(r, vec2(xSat-satRadius, ySat-satRadius), vec2(xSat+satRadius, ySat+satRadius)));\n    ret = mix(ret, colUran, rect(r, vec2(xUran-uranRadius, yUran-uranRadius), vec2(xUran+uranRadius, yUran+uranRadius)));\n    ret = mix(ret, colNept, rect(r, vec2(xNept-neptRadius, yNept-neptRadius), vec2(xNept+neptRadius, yNept+neptRadius)));\n\n    vec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 421, 421, 698], [700, 700, 757, 757, 5461]], "test": "untested"}
{"id": "WsKyDW", "name": "Gradient Interval Arithmetic", "author": "paniq", "description": "A set of arithmetic primitives to perform segment tracing as described in https://diglib.eg.org/handle/10.1111/cgf13951\nthis is an alpha WIP version pre-published for interested folk", "tags": ["gradient", "arithmetic", "interval"], "likes": 15, "viewed": 1041, "published": 3, "date": "1603126241", "time_retrieved": "2024-07-30T20:39:24.541932", "image_code": "// Gradient Interval Arithmetic (WIP)\n// by Leonard Ritter (@paniq)\n\n// i release this file to the public domain, but a citation would be nice\n\n// green: segment marching using GIA\n// red: sphere marching\n\n#define USE_GLOBAL_LIPSCHITZ 0\n#define USE_ANTITANGENTS 0\n\n#define DRAW_TANGENTS 0\n#define DRAW_ANTITANGENTS 0\n#define DRAW_SLICES 1\n\n//////////////////////////////////////////////////////////\n\n// GIA scalar for rays (1D)\nstruct gia1 {\n    // coefficients of f(x) = f0 + s*(f1 - f0)\n    // where s=[0..1]\n    float f0;\n    vec2 f1;\n};\n    \nstruct gia1x2 {\n    gia1 x;\n    gia1 y;\n};\n\nstruct gia1x3 {\n    gia1 x;\n    gia1 y;\n    gia1 z;\n};\n\n//////////////////////////////////////////////////////////\n\ngia1 gia_const(float x) {\n    return gia1(x, vec2(x));\n}\n\ngia1x3 gia_const(vec3 v) {\n    return gia1x3(gia_const(v.x), gia_const(v.y), gia_const(v.z));\n}\n\ngia1 gia_neg(gia1 x) {\n    return gia1(-x.f0, -x.f1.yx);\n}\n\nvec2 ia_sort(vec2 ia) {\n    return (ia.x > ia.y)?ia.yx:ia;\n}\n\nvec2 ia_merge(vec2 a, vec2 b) {\n    return vec2(min(a.x, b.x), max(a.y, b.y));\n}\n\ngia1 gia_add(gia1 a, gia1 b) {\n    return gia1(a.f0 + b.f0, a.f1 + b.f1);\n}\n\ngia1 gia_add(gia1 a, float b) {\n    return gia1(a.f0 + b, a.f1 + b);\n}\n\ngia1x3 gia_add(gia1x3 a, vec3 b) {\n    return gia1x3(gia_add(a.x, b.x), gia_add(a.y, b.y), gia_add(a.z, b.z));\n}\n\ngia1 gia_sub(gia1 a, gia1 b) {\n    return gia1(a.f0 - b.f0, a.f1 - b.f1.yx);\n}\n\ngia1 gia_sub(float a, gia1 b) {\n    return gia1(a - b.f0, a - b.f1.yx);\n}\n\ngia1 gia_sub(gia1 a, float b) {\n    return gia1(a.f0 - b, a.f1 - b);\n}\n\ngia1x2 gia_sub(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_sub(a.x,b.x),gia_sub(a.y,b.y));\n}\n\ngia1x3 gia_sub(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1x3 gia_sub(gia1x3 a, vec3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1 gia_max(gia1 a, gia1 b) {\n    vec2 f0_f1min = ((a.f0 > b.f0)?vec2(a.f0, a.f1.x):vec2(b.f0, b.f1.x));\n    return gia1(f0_f1min[0], vec2((a.f0 == b.f0)?max(a.f1.x,b.f1.x):f0_f1min[1], max(a.f1.y, b.f1.y)));\n}\n\ngia1 gia_max(gia1 a, float b) {\n    vec2 f0_f1min = ((a.f0 > b)?vec2(a.f0, a.f1.x):vec2(b));\n    return gia1(f0_f1min[0], vec2((a.f0 == b)?max(a.f1.x,b):f0_f1min[1], max(a.f1.y, b)));\n}\n\ngia1x2 gia_max(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x2 gia_max(gia1x2 a, vec2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x3 gia_max(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1x3 gia_max(gia1x3 a, vec3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1 gia_min(gia1 a, gia1 b) {\n    return gia_neg(gia_max(gia_neg(a), gia_neg(b)));\n}\n\ngia1 gia_min(gia1 a, float b) {\n    return gia_neg(gia_max(gia_neg(a), -b));\n}\n\ngia1 gia_clamp(gia1 x, float mn, float mx) {\n    return gia_min(gia_max(x, mn), mx);\n}\n\ngia1 gia_abs(gia1 a) {\n    float f1min = (a.f0 > 0.0)?a.f1.x:-a.f1.y;\n    return gia1(abs(a.f0), vec2((a.f0 == 0.0)?max(a.f1.x,-a.f1.y):f1min, max(a.f1.y, -a.f1.x)));\n}\n\ngia1x3 gia_abs(gia1x3 a) {\n    return gia1x3(gia_abs(a.x),gia_abs(a.y),gia_abs(a.z));\n}\n\ngia1 gia_sign(gia1 a) {\n    // approximate hack. needs a clear head.\n    float s0 = sign(a.f0);\n    vec2 s1 = sign(a.f1);\n    if ((s0 == s1.x) && (s1.x == s1.y))\n        return gia1(s0, s1);\n    vec2 b = (s0 * a.f1 - abs(a.f1 - a.f0)) / a.f0;\n    b = (b.x < b.y)?b:b.yx;\n    return gia1(s0, ia_merge(b, vec2(min(s0,s1.x),max(s0,s1.y))));\n}\n\nvec2 minmax(vec3 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),f[2]),\n            max(max(f[0],f[1]),f[2])); \n}\n\nvec2 minmax(vec4 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),min(f[2],f[3])),\n            max(max(f[0],f[1]),max(f[2],f[3]))); \n}\n\ngia1 gia_mul(gia1 a, gia1 b) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxyy * b.f1.xyxy);\n    // bound f'(0)\n    vec2 ff0 = minmax((b.f0*(a.f1 - a.f0)).xxyy + (a.f0*(b.f1 - b.f0)).xyxy);    \n\tfloat f0 = a.f0 * b.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\ngia1 gia_mul(gia1 a, float b) {    \n    vec2 q = a.f1.xy * b;\n    return gia1(a.f0 * b, (b < 0.0)?q.yx:q);\n}\n\ngia1x2 gia_mul(gia1 a, vec2 b) {\n    return gia1x2(gia_mul(a, b.x), gia_mul(a, b.y));\n}\n\ngia1x3 gia_mul(gia1 a, vec3 b) {\n    return gia1x3(gia_mul(a, b.x), gia_mul(a, b.y), gia_mul(a, b.z));\n}\n\ngia1 gia_pow2(gia1 a) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxy * a.f1.xyy);\n    // bound f'(0)\n    vec2 ff0a = a.f0*(a.f1 - a.f0);\n    vec2 ff0 = minmax(ff0a.xxy + ff0a.xyy);\n\tfloat f0 = a.f0 * a.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\nfloat safeinv(float x) {\n    return (x == 0.0)?0.0:1.0/x;\n}\n\ngia1 gia_sqrt(gia1 a) {\n    float d = sqrt(a.f0);\n    vec2 ia_f = sqrt(max(vec2(0.0),a.f1));\n    vec2 ia_g = 0.5 * (a.f1 - a.f0) * safeinv(d);    \n    return gia1(d, ia_merge(ia_g + max(0.0, d), ia_f));\n}\n\ngia1 gia_dot(gia1x2 a) {\n    return gia_add(gia_pow2(a.x),gia_pow2(a.y));\n}\n\ngia1 gia_dot(gia1x3 a) {\n    return gia_add(gia_add(gia_pow2(a.x),gia_pow2(a.y)),gia_pow2(a.z));\n}\n\ngia1 gia_dot(gia1x2 a, vec2 b) {\n    return gia_add(gia_mul(a.x, b.x),gia_mul(a.y, b.y));\n}\n\ngia1 gia_dot(gia1x3 a, vec3 b) {\n    return gia_add(gia_add(gia_mul(a.x, b.x),gia_mul(a.y, b.y)),gia_mul(a.z, b.z));\n}\n\ngia1 gia_length(gia1x2 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_length(gia1x3 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_mix (gia1 a, gia1 b, gia1 x) {\n    return gia_add(a, gia_mul(gia_sub(b,a),x));\n}\n\ngia1 gia_smin( gia1 a, gia1 b, float k ) {\n    gia1 h = gia_clamp(gia_add(gia_mul(gia_sub(b, a),0.5 / k),0.5), 0.0, 1.0 );\n    return gia_sub(gia_mix( b, a, h ), gia_mul(gia_mul(h, gia_add(gia_neg(h), 1.0)), k));\n}\n\ngia1 gia_exp(gia1 a) {\n    float f0 = exp(a.f0);\n    vec2 f1 = exp(a.f1);\n    vec2 ff0 = f0 + ia_sort(f0*(a.f1 - a.f0));\n    return gia1(f0, ia_merge(ff0, f1));\n}\n\ngia1 gia_rcp(gia1 a) {\n    float f0 = 1.0/a.f0;\n    const float inf = 1.0/0.0;\n    if (min(a.f0*a.f1.x, a.f0*a.f1.y) < 0.0) {\n        // crossing zero\n        return gia1(f0, vec2(-inf, inf));\n    }\n    vec2 ff0 = (a.f0 - a.f1.yx)*(f0*f0);\n    vec2 f1 = 1.0/a.f1.yx;    \n    return gia1(f0, ia_merge(ff0 + f0,f1));\n}\n\ngia1 gia_div(gia1 a, gia1 b) {\n    return gia_mul(a, gia_rcp(b));\n}\n\nvec2 tangent_sin(vec2 t) {\n    // for\n    // sin(a*x + t) = sin(t) + K*a*x\n    // cos(a*x + t) = K*a\n    // an acceptable approximation for K from t is\n    // mix(cos(x%(PI*2)),pow(cos((x%(PI*2)-PI*0.5)/3.0 + PI*0.5),2),step(PI*0.5,x%(PI*2)))\n    const float pi = 3.14159265359;\n    t = mod(t, 2.0*pi);\n    vec2 s = cos((t-pi*0.5)/3.0 + pi*0.5);\n    return mix(cos(t),s*s,step(pi*0.5,t));\n}\n\ngia1 gia_cos(gia1 a) {\n    // TODO: correct for wide ranges, but too broad for narrow ones\n    // only include tangent when a turning point is in range\n    float f0 = cos(a.f0);\n    vec2 g = a.f1 - a.f0;\n    vec2 ff0 = ia_sort(g*-sin(a.f0));\n    vec2 f1 = ia_sort(cos(a.f1)); \n    \n    vec2 tmin = ia_sort(abs(g)*tangent_sin(sign(g)*a.f0 + 1.57079632679));\n    vec2 tmax = ia_sort(abs(g)*-tangent_sin(sign(g)*a.f0 - 1.57079632679));\n    \n    vec2 xpos = acos(tmin) - a.f0;\n    \n    vec2 t = ia_merge(tmin,tmax);\n    return gia1(f0, t + f0);\n}\n\n//////////////////////////////////////////////////////////\n\ngia1 gia_f0(gia1 t) {\n    t = gia_add(t, gia_const(sin(iTime * 0.5)*1.5));\n    return t;\n}\n\ngia1 gia_sphere(gia1x3 p, float r) {\n    return gia_sub(gia_sqrt(gia_add(gia_add(gia_pow2(p.x),gia_pow2(p.y)), gia_pow2(p.z))), gia_const(r));\n}\n\ngia1 gia_f1(gia1 t) {\n    t = gia_f0(t);\n#if 0\n    return gia_exp(t);\n#else\n    vec3 n = normalize(vec3(1.0, 0.0, 0.0));\n    gia1x3 p = gia1x3(\n        gia_add(gia_const(0.0), gia_mul(t, n.x)),\n        gia_add(gia_const(0.52), gia_mul(t, n.y)),\n        gia_add(gia_const(0.0), gia_mul(t, n.z))\n    );\n    //return gia_cos(gia_mul(t,8.0));\n    return gia_min(gia_sphere(p, 0.5), gia_add(gia_mul(t, -0.25), 0.6));\n    //return gia_mul(gia_add(gia_pow2(t), 0.05), 0.5);\n    //return gia_sqrt(gia_neg(t));\n    //return gia_mul(t,gia_mul(t, gia_neg(t)));\n    //return gia_mul(gia_add(gia_abs(gia_add(gia_abs(gia_add(gia_pow2(gia_f0(t)), gia_const(-0.5))),gia_const(-0.7))),gia_const(0.1)),1.0);\n    //return gia_sign(gia_add(gia_abs(t),-0.5));\n#endif\n}\n\ngia1 gia_f2(gia1 t) {\n    return gia_const(0.0);//gia_max(gia_f0(t), gia_f1(t));\n}\n\nfloat f0(float x) { return gia_f0(gia_const(x)).f0; }\nfloat f1(float x) { return gia_f1(gia_const(x)).f0; }\nfloat f2(float x) { return gia_f2(gia_const(x)).f0; }\n\nvoid paint_f(gia1 r, float i0, float i1, float w, float hue) {\n    move_to(i0, r.f0);\n    line_to(i1, r.f1.x);\n    line_to(i1, r.f1.y);\n    close_path();\n    set_source_rgba(hsl(hue,1.0,0.5,0.2));\n    fill_preserve();\n    set_source_rgba(hsl(hue,1.0,0.5,0.5));\n    stroke();        \n}\n\nvoid paint() {\n    //translate(-1.0, 0.0);\n    \n    set_source_rgb(vec3(0.0,0.0,0.5));\n    clear();\n    \n    float w = (iMouse.z > 0.5)?abs(get_query().x):0.68;\n    \n    vec2 p = get_origin();\n    float i0 = p.x - mod(p.x, w);\n    float i1 = i0 + w;\n    float qx = (p.x - i0) / w;\n    \n    // grid\n#if DRAW_SLICES\n    move_to(i0, -1.0);\n    line_to(i0, 1.0);\n    move_to(i1, -1.0);\n    line_to(i1, 1.0);\n#endif\n    move_to(i0, 0.0);\n    line_to(i1, 0.0);\n    set_line_width_px(1.0);\n    set_source_rgba(hsl(0.5,1.0,0.8,0.3));\n    stroke();\n    \n    gia1 dom = gia1(i0, vec2(i1));\n    \n    set_line_width_px(1.0);\n#if 0\n    set_source_rgba(1.0, 0.5, 0.5, 0.25);\n    float y0 = sin(i0*3.0 + iTime);\n    float y1c = sin(i0*5.0 + iTime*0.9)*0.5;\n    float y1h = (0.5 + 0.5*sin(iTime*0.7))*0.25;\n    vec2 y1 = vec2(y1c - y1h, y1c + y1h);\n    move_to(i0, y0);\n    line_to(i1, y1.x);\n    line_to(i1, y1.y);\n    close_path();\n    fill();\n    set_source_rgba(0.5, 1.0, 0.5, 0.25);\n    float k0 = sin(i0*7.0 + iTime*0.9);\n    float k1c = sin(i0*11.0 + iTime*0.5)*0.5;\n    float k1h = (0.5 + 0.5*sin(iTime*0.8))*0.25;\n    vec2 k1 = vec2(k1c - k1h, k1c + k1h);\n    move_to(i0, k0);\n    line_to(i1, k1.x);\n    line_to(i1, k1.y);\n    close_path();\n    fill();\n    \n    {\n        vec2 kr = k0 + qx * (k1 - k0);\n        vec2 yr = y0 + qx * (y1 - y0);\n        \n        vec2 f = sqrt(kr);\n        \n        vec2 rr = ia_sort(f);\n        set_source_rgba(1.0, 1.0, 1.0, ((p.y >= rr.x) && (p.y < rr.y))?0.5:0.0);\n        clear();\n    }    \n#endif\n    \n    // visualize gradients\n    //paint_f(gia_f0(dom), i0, i1, w, 0.1);\n    #if DRAW_SLICES\n    paint_f(gia_f1(dom), i0, i1, w, 0.5);\n    #endif\n    //paint_f(gia_f2(dom), i0, i1, w, 0.3);\n    \n    //graph1D(f0);\n    //set_source_rgba(hsl(0.1,1.0,0.8,1.0));\n    //stroke();\n    graph1D(f1);\n    set_source_rgba(hsl(0.5,1.0,0.8,1.0));\n    stroke();\n    //graph1D(f2);\n    //set_source_rgb(vec3(1.0));    \n    //stroke();\n    \n    float t = -1.5;\n    const int N = 30;\n    for (int i = 0; i < N; ++i) {\n        float x = float(i)/float(N);\n        gia1 g = gia_f1(gia1(t, vec2(t)));\n        move_to(t, 0.0);\n        line_to(t, g.f0);\n        t += abs(g.f0);\n        line_to(t, 0.0);\n\t    set_source_rgba(1.0, 0.0, 0.0, 0.8);\n        stroke();\n    }\n    \n    t = -1.5;\n    float td = 2.0;\n    for (int i = 0; i < N; ++i) {\n        float x = float(i)/float(N);\n        gia1 g = gia_f1(gia1(t, vec2(t + td)));\n        if (g.f0 < 0.001) {\n            set_source_rgb(1.0, 0.0, 0.0);\n            circle(t, 0.0, 0.03);\n            fill();\n            break;\n        }\n\t\t#if DRAW_TANGENTS\n        move_to(t, g.f0);\n        line_to(t + td, g.f1.x);\n\t    set_source_rgb(1.0, 0.5, 1.0);\n        stroke();        \n        #endif\n        #if USE_GLOBAL_LIPSCHITZ\n        float stepsz = g.f0 * max(td / (g.f0 + max(0.0, -g.f1.x)), 1.0);\n        #else\n        float stepsz = min(g.f0 * (td / max(0.0, g.f0 - g.f1.x)), td);\n        #endif\n        #if USE_ANTITANGENTS\n        // compute field from the other side\n        float t2 = t + td;\n        gia1 g2 = gia_f1(gia1(t2, vec2(t)));\n        #if DRAW_ANTITANGENTS\n        {\n            move_to(t2, g2.f0);\n            line_to(t, g2.f1.x);\n            set_source_rgb(0.8, 0.7, 1.0);\n            stroke();\n        }\n        #endif\n        float rstepsz = td - g2.f0 / max(0.0, -g2.f1.x);\n        if (stepsz > rstepsz) {\n            // skip\n            stepsz = td;\n            #if USE_GLOBAL_LIPSCHITZ\n            // and also add step from second sample\n            stepsz += max(0.0, g2.f0);\n            #endif\n        }\n\t\t#endif\n        move_to(t, 0.0);\n        line_to(t, g.f0);\n        t += stepsz;\n        line_to(t, 0.0);\n        //td = max(1.0, td + ((stepsz > td)?0.1:-0.1));\n\t    set_source_rgb(0.0, 0.9, 0.0);\n        stroke();\n    }\n    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKyDW.jpg", "access": "api", "license": "public-domain", "functions": [[706, 706, 731, 731, 762], [764, 764, 790, 790, 859], [861, 861, 883, 883, 919], [921, 921, 944, 944, 981], [983, 983, 1014, 1014, 1063], [1065, 1065, 1095, 1095, 1140], [1142, 1142, 1173, 1173, 1212], [1214, 1214, 1248, 1248, 1326], [1328, 1328, 1358, 1358, 1406], [1408, 1408, 1439, 1439, 1481], [1483, 1483, 1514, 1514, 1553], [1555, 1555, 1591, 1591, 1647], [1649, 1649, 1685, 1685, 1758], [1760, 1760, 1794, 1794, 1867], [1869, 1869, 1899, 1899, 2080], [2082, 2082, 2113, 2113, 2267], [2269, 2269, 2305, 2305, 2361], [2363, 2363, 2397, 2397, 2453], [2455, 2455, 2491, 2491, 2564], [2566, 2566, 2600, 2600, 2673], [2675, 2675, 2705, 2705, 2760], [2762, 2762, 2793, 2793, 2840], [2842, 2842, 2886, 2886, 2928], [2930, 2930, 2952, 2952, 3098], [3100, 3100, 3126, 3126, 3187], [3189, 3189, 3212, 3257, 3528], [3530, 3530, 3551, 3551, 3641], [3643, 3643, 3664, 3664, 3774], [3776, 3776, 3806, 3824, 4042], [4044, 4044, 4075, 4075, 4152], [4154, 4154, 4186, 4186, 4241], [4243, 4243, 4275, 4275, 4347], [4349, 4349, 4372, 4390, 4604], [4606, 4606, 4630, 4630, 4665], [4667, 4667, 4690, 4690, 4871], [4873, 4873, 4897, 4897, 4948], [4950, 4950, 4974, 4974, 5048], [5050, 5050, 5082, 5082, 5141], [5143, 5143, 5175, 5175, 5261], [5263, 5263, 5290, 5290, 5325], [5327, 5327, 5354, 5354, 5389], [5391, 5391, 5430, 5430, 5480], [5482, 5482, 5524, 5524, 5696], [5698, 5698, 5720, 5720, 5860], [5862, 5862, 5884, 5884, 6178], [6180, 6180, 6210, 6210, 6247], [6249, 6249, 6275, 6491, 6639], [6641, 6641, 6663, 6792, 7183], [7245, 7245, 7266, 7266, 7335], [7337, 7337, 7373, 7373, 7481], [7483, 7483, 7504, 7504, 8230], [8232, 8232, 8253, 8253, 8314], [8316, 8316, 8335, 8335, 8369], [8370, 8370, 8389, 8389, 8423], [8424, 8424, 8443, 8443, 8477], [8479, 8479, 8541, 8541, 8763], [8765, 8765, 8779, 8807, 12575], [12637, 12637, 12694, 12694, 12780]], "test": "untested"}
{"id": "wdGczy", "name": "Procedural Bell Pepper", "author": "oneshade", "description": "A procedural modelling exercise. It is an elongated sphere with some polar and sinusoidal displacements. I might try adding a stem too.", "tags": ["procedural", "3d", "raymarching", "sdf", "bell", "pepper"], "likes": 2, "viewed": 135, "published": 3, "date": "1603119333", "time_retrieved": "2024-07-30T20:39:25.556220", "image_code": "/*\nThis shader uses an older version of my raymarcher template (https://www.shadertoy.com/view/3styDs)\nand I do not plan on implementing the newer features as they are not necessary.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.5, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1300.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.01, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 1600.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 800;\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, normalize(p)) * length(p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\nfloat sdCone(in vec3 p, in float h, in float r) {\n    return 0.0;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nfloat Subtraction(in float sdf1, in float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nfloat Intersection(in float sdf1, in float sdf2) {\n    return max(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    float radius = 200.0;\n    float aspectRatio = 1.2;\n    float segments = 6.0;\n    float pronouncement = 15.0;\n    float bumps = 3.0;\n    float bumpSize = 3.0;\n\n    p = Rotate(p, vec3(-45.0, iTime * 20.0, 0.0));\n    p.y /= aspectRatio;\n\n    float sphere = sdSphere(p, radius);\n    float t = atan(p.z, p.x) * segments;\n    float r = (length(p.xz) / radius) * pronouncement;\n    float baseShape = sphere + sin(t) * r;\n    float displacement = (sin(p.x / (bumps * 6.28)) + sin(p.y / (bumps * 6.28)) + sin(p.z / (bumps * 6.28))) * bumpSize;\n    float pepper = baseShape + displacement;\n    return pepper;\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 1.0, 1.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 8.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (abs(distanceToClosest) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[774, 811, 848, 848, 895], [897, 897, 960, 960, 1043], [1045, 1045, 1094, 1094, 1112], [1114, 1114, 1167, 1167, 1223], [1225, 1225, 1277, 1277, 1333], [1335, 1335, 1374, 1374, 1402], [1404, 1452, 1495, 1495, 1525], [1527, 1527, 1576, 1576, 1607], [1609, 1609, 1659, 1659, 1689], [1691, 1711, 1749, 1749, 1769], [1771, 1771, 1806, 1806, 2417], [2419, 2419, 2453, 2453, 2473], [2475, 2502, 2529, 2529, 3134], [3136, 3185, 3218, 3218, 3548], [3550, 3585, 3635, 3635, 3669], [3671, 3671, 3721, 3721, 3755], [3757, 3757, 3808, 3808, 3842], [3844, 3844, 3897, 3897, 3915], [3917, 3938, 3977, 3977, 5460], [5462, 5495, 5550, 5550, 5870]], "test": "untested"}
{"id": "tdyyzy", "name": "My First Torus Knot", "author": "oneshade", "description": "My first torus knot thanks to The Art of Code.", "tags": ["3d", "raymarching", "sdf", "torus", "knot"], "likes": 2, "viewed": 150, "published": 3, "date": "1603118688", "time_retrieved": "2024-07-30T20:39:26.438860", "image_code": "/*\nThis shader uses an older version of my Raymarcher Template (https://www.shadertoy.com/view/3styDs)\nand I do not plan on implementing the newer features as they are not necessary.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1300.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.1, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, normalize(p)) * length(p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\nfloat sdCone(in vec3 p, in float h, in float r) {\n    return 0.0;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nfloat Subtraction(in float sdf1, in float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nfloat Intersection(in float sdf1, in float sdf2) {\n    return max(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    p = Rotate(p, vec3(-45.0, iTime * 20.0, 0.0));\n    vec2 p2D = vec2(length(p.xz) - 200.0, p.y);\n    float angle = atan(p.z, p.x) * 3.0;\n    float c = cos(angle);\n    float s = sin(angle);\n    p2D *= mat2( c, s,\n                -s, c);\n    p2D.y = abs(p2D.y) - 75.0;\n    return (length(p2D) - 50.0) * 0.4;\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 1.0, 1.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 8.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (abs(distanceToClosest) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[773, 810, 847, 847, 894], [896, 896, 959, 959, 1042], [1044, 1044, 1093, 1093, 1111], [1113, 1113, 1166, 1166, 1222], [1224, 1224, 1276, 1276, 1332], [1334, 1334, 1373, 1373, 1401], [1403, 1451, 1494, 1494, 1524], [1526, 1526, 1575, 1575, 1606], [1608, 1608, 1658, 1658, 1688], [1690, 1710, 1748, 1748, 1768], [1770, 1770, 1805, 1805, 2416], [2418, 2418, 2452, 2452, 2472], [2474, 2501, 2528, 2528, 2838], [2840, 2889, 2922, 2922, 3252], [3254, 3289, 3339, 3339, 3373], [3375, 3375, 3425, 3425, 3459], [3461, 3461, 3512, 3512, 3546], [3548, 3548, 3601, 3601, 3619], [3621, 3642, 3681, 3681, 5164], [5166, 5199, 5254, 5254, 5574]], "test": "untested"}
{"id": "wdGyzy", "name": "My First Mandelbulb", "author": "oneshade", "description": "Thanks to the art of code I now understand the mandelbrot set and complex numbers.", "tags": ["mandelbrot", "numbers", "complex", "set"], "likes": 2, "viewed": 160, "published": 3, "date": "1603117359", "time_retrieved": "2024-07-30T20:39:27.710461", "image_code": "const int MAX_ITERS = 20;\nconst float MAX_DIST = 2.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = vec2(0.5, 0.0);\n    float zoom = 0.333;\n    vec2 c = (fragCoord - 0.5 * iResolution.xy) / iResolution.y / zoom - position;\n    vec2 z = vec2(0.0, 0.0);\n    float iters = 0.0;\n    for (int i=0; i < MAX_ITERS; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (length(z) > MAX_DIST) {\n            break;\n        }\n        iters++;\n    }\n    fragColor = vec4(vec3(iters / float(MAX_ITERS)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 110, 110, 556]], "test": "untested"}
{"id": "wdycRy", "name": "Scrolling Truchet Tiles", "author": "oneshade", "description": "I watched The Art of Code's video explaining truchet tiling and this is what I learned from it.", "tags": ["procedural", "truchet", "tiling", "quad"], "likes": 3, "viewed": 168, "published": 3, "date": "1603116978", "time_retrieved": "2024-07-30T20:39:28.587116", "image_code": "float Hash21(in vec2 id) {\n    vec2 n = id * fract(dot(id, vec2(534.75, 65.54)));\n    return fract(dot(id + n, n));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((fragCoord - 0.5 * iResolution.xy) / iResolution.y) * 10.0 + iTime;\n    vec2 cellLocation = floor(uv);\n    vec2 cellLocalUV = fract(uv) - 0.5;\n    cellLocalUV.x *= Hash21(cellLocation) < 0.5 ? -1.0 : 1.0;\n\n    vec2 circleUV = cellLocalUV - (cellLocalUV.x + cellLocalUV.y < 0.0 ? -1.0 : 1.0) * 0.5;\n    float circleDist = length(circleUV) - 0.5;\n    vec3 color = vec3(smoothstep(0.3, 0.0, abs(circleDist)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdycRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 117], [119, 119, 174, 174, 633]], "test": "untested"}
{"id": "wsGyRy", "name": "CrossPlatform Breast", "author": "Shapkofil", "description": "Anime tittie That can  be viewed from your own phone. (Made in the name of science)\nYoutubeVid :https://youtu.be/vTsaTnmEYMI\nInspiration: https://www.wolframalpha.com/widgets/view.jsp?id=4a882b546a46d492fdbf3679cbac49d4", "tags": ["crossplatform"], "likes": 3, "viewed": 1367, "published": 3, "date": "1603115637", "time_retrieved": "2024-07-30T20:39:29.561511", "image_code": "float boob_size = 2.0;\nfloat nipple_width = 0.5;\nfloat nipple_size = 0.07;\nfloat nipple_pointiness = 4.0;\n\nvec4 skin_color = vec4(0.9254901960784314, 0.7372549019607844, 0.7058823529411765, 1.0);\nvec4 nipple_color = vec4(0.7333333333333333, 0.4666666666666667, 0.4666666666666667, 1.0);\n\nfloat feathering = 0.007;\nfloat blending = 0.01;\n\nfloat sigmoid(float x) {\n\treturn 1.0/(1. + exp(-x));\n}\n\nfloat tittie_f(in float x, out float boob, out float nipple){\n    boob = -boob_size*x*log(x);\n    nipple = nipple_size*exp(-pow(abs(\n            10.0*(1.0/nipple_width)*x-4.0*(1.0/nipple_width)),\n                                  nipple_pointiness));\n    \n    return nipple + boob;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = 1.0-uv.x;\n    \n    float boob, nipple;\n    float value = tittie_f(uv.x, boob, nipple);\n    \n    // Mask\n    vec4 tittie_mask = \n        mix(vec4(1), vec4(0),\n            sigmoid((-value+uv.y)/feathering) \n           );\n    \n    // Final Color\n    fragColor = \n        mix(skin_color, nipple_color,\n            sigmoid((-boob+uv.y)/blending)\n           )\n        * tittie_mask;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 362, 362, 392], [394, 394, 455, 455, 677], [680, 680, 737, 737, 1167]], "test": "untested"}
{"id": "tdKyWm", "name": "Fab20 #inktober2020 \"coral\"", "author": "FabriceNeyret2", "description": "mouse carve caves.\nAttention: look is very resolution-dependent.\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nsee [url] https://shadertoy.com/view/3dsGDM[/url] for more description about DLA simulation", "tags": ["2d", "simulation", "tree", "automata", "maze", "dla", "branching", "growth", "aggregation", "inktober2020"], "likes": 18, "viewed": 493, "published": 3, "date": "1603098536", "time_retrieved": "2024-07-30T20:39:30.499005", "image_code": "// variant of https://shadertoy.com/view/3dsGDM\n// larger scale variant of https://shadertoy.com/view/Wds3RM\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(0,0);                                                 // --- coral DLA simulation\n\n    if (O.w==0.) {                                              // --- water       \n        U /= R.y;     \n        O = vec4(.7,1,.9,1)*.3\n            * (.8+.2*sin(12.*(   U.y+.1*sin(3.*U.x+ 1.4*iTime))   )\n                 +.1*sin(11.*(.5*U.x+.1*sin(5.*U.y+ 1. *iTime))+2.)\n              );\n        \n        float t = float(iFrame)/R.x;                            // --- bubbles\n        vec2 r  = R/R.y;\n        U = mod(U-vec2(-t,t), r);                               // sync to scrool + raise\n        for (int k=0; k<20; k++) {\n            vec3 P = hash(float(k));\n            O += max(0., 1.5- R.y/2.* length( U - .05-.9*r*P.xy // random bubble location out of the wrap zone\n                                              - .005*sin(8.*iTime+6.3*P.z+vec2(0,11)) ) )\n                 * vec4(.7,1,.9,1)*.7;                          //  \\ small rotation\n        }\n    }\n    else  if ( O.w<1. ) O = vec4(.7,.5,0,1);                    // --- sand\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === coral growth: diffusion-limited aggregation (DLA) simulation ====================\n\nint N = 7;               // free neighborhood scale\n#define a 3.1416/2.      // authorized filled back-cone angle\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (  iFrame%2<1 ) { O = T(1,0); return;  } // scroll view\n    O = T(0,0) ;                           // restore previous state\n \n    float h = hash3(vec3(U,iTime));        // rand\n    \n    if ( U.x==R.x-.5 ) {                   // right column: create environment\n        vec2 V = 2.*U/R-1.; \n        if  ( V.y <  -.7 + .2* sin(.5*iTime+V.x) +.1*h ) // current sand column\n            O = texture(iChannel1,U/R),    // seed color\n            O = .6 + .6 * cos( 6.3*O.r + vec4(0,23,21,0)),  // hue https://www.shadertoy.com/view/ll2cDc\n            O.w = h;//step( .5, h );       // set matter, age := 1  ( fract = sand )\n        return;\n     }\n                                           // mouse eraser: carve caves\n    if ( iMouse.z > 0. && length(U-iMouse.xy) < .1*R.y ) O -= O; \n    \n    if ( h < .9) return;                   // random progression\n\n    int n=0, p;                            // --- grow coral\n    for (int k=0; k<3*3; k++)              // count matter in neighborhood\n        if ( T(k%3-1,k/3-1).w > 0. ) n++, p=k;\n    \n    if (n!=1) return;                      // not exactly one neighborh, so not at a coral tip\n                                           // p = previous coral tip location    \n    n = 0;                                 // now we verify the NxN neighborhood\n // N = int(15.*U.x/R.x);\n    vec2 P0 = vec2(p%3-1,p/3-1);           // axis of back-cone allowed to have content\n    for (int k=0; k<N*N; k++) {\n        vec2 P = vec2(k%N -N/2, k/N -N/2);\n        if ( // max(abs(P.x),abs(P.y)) > 1. && // forget 3x3 center\n             // length(P) <= float(N/2) && // clamp to disk\n             dot(P,P0) < length(P)*length(P0)*cos(a/2.) // check 3-quarter opposed to P0\n             && T(P.x,P.y).w > 0. ) n++;                // not empty\n    }                            // ( would just return be performant ? )\n        \n    if (n==0) O = textureLod(iChannel0,(U+P0)/R,0.),    // inherit previous tip color\n              O.w =  1.; // ceil(O.w)+1.;  // age++ ( but for fract = sand → ceil )\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R        iResolution.xy\n#define T(x,y)   texelFetch(iChannel0, ivec2(U+vec2(x,y)), 0)\n#define hash3(p) fract( sin( dot( p  , vec3(127.1,311.7, 74.7) )  ) *43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define hash(p)  fract( sin(     (p) * vec3(127.1,311.7, 74.7)    ) *43758.5453123)\n         ", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 148, 148, 1187]], "test": "untested"}
{"id": "3dyyRy", "name": "Support Your Neighbors", "author": "wyatt", "description": "Use your mouse to define a structure you want to support. The simulation will then optimize a support structure. ", "tags": ["deformation"], "likes": 14, "viewed": 434, "published": 3, "date": "1603072844", "time_retrieved": "2024-07-30T20:39:31.815485", "image_code": "// Fork of \"Self-Designed Bridge\" by wyatt. https://shadertoy.com/view/wsGcWm\n// 2020-10-19 01:08:25\n\nMain {\n    vec4 a = A(U), b = B(U);\n    vec4\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    vec3 no = normalize(vec3(e.w-w.w,n.w-s.w,2));\n    vec3 ref = reflect(vec3(0,0,-1),no);\n   \tvec3 l = R.xyy;\n    float li = ln(vec3(U,0),vec3(U,0)+ref,l);\n    Q = 0.6+0.5*sin(-4.*length(b)+.5+1.5*a.w+vec4(1,2,3,4));\n    Q *= (1.2-2.*a.z)*exp(-.6*li);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}", "buffer_a_code": "Main\n{\n\tQ = A(U);vec2 f = vec2(0); vec4 b = B(U);float m = 0.;\n    float s = 0.;\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 w = 0.125*Q.w*aa.w*(mat2(bb)*mat2(bb)-mat2(1))*u;\n        s += length(w);\n        f += w;\n        f += .3*0.125*Q.w*aa.w*(aa.xy-Q.xy);\n    \tm += 0.125*aa.w;\n    }\n    s/=m*Q.w;\n    Q.w = mix(Q.w,m,.02);\n    Q.w = clamp(Q.w+.1*(s-.1),.1,1.);\n    Q.xy += f*Q.w;\n    Q.y -= 1e-1/R.y*(Q.w-.1);\n    Q.y -= 5./R.y*Q.z;\n    if (U.x<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    if (R.x-U.x<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    if (U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.y-U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    \n    if (iMouse.z>0.)Q.z += .1*exp(-length(U-iMouse.xy));\n    if (iFrame<1) Q = vec4(0,0,0,1);\n    Q = clamp(Q,-1.,1.);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n\tQ = B(U);vec4 f = vec4(0), a = A(U), m = vec4(0);\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 dv = aa.xy-a.xy;\n        m += bb;\n        f += 0.125*a.w*aa.w*vec4(u.x*dv.x,u.x*dv.y,u.y*dv.x,u.y*dv.y);\n    }\n    Q += vec4(mat2(Q)*mat2(f));\n    Q = mix(Q,0.125*m,.01);\n    if (iFrame<1) Q = vec4(1,0,0,1);\n    Q = clamp(Q,-2.,2.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n\tQ = A(U);vec2 f = vec2(0); vec4 b = B(U);float m = 0.;\n    float s = 0.;\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 w = 0.125*Q.w*aa.w*(mat2(bb)*mat2(bb)-mat2(1))*u;\n        s += length(w);\n        f += w;\n        f += .3*0.125*Q.w*aa.w*(aa.xy-Q.xy);\n    \tm += 0.125*aa.w;\n    }\n    s/=m*Q.w;\n    Q.w = mix(Q.w,m,.02);\n    Q.w = clamp(Q.w+.1*(s-.1),.1,1.);\n    Q.xy += f*Q.w;\n    Q.y -= 1e-1/R.y*(Q.w-.1);\n    Q.y -= 5./R.y*Q.z;\n    if (U.x<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    if (R.x-U.x<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    if (U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.y-U.y<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    \n    if (iMouse.z>0.)Q.z += .1*exp(-length(U-iMouse.xy));\n    if (iFrame<1) Q = vec4(0,0,0,1);\n    Q = clamp(Q,-1.,1.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n\tQ = B(U);vec4 f = vec4(0), a = A(U), m = vec4(0);\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 dv = aa.xy-a.xy;\n        m += bb;\n        f += 0.125*a.w*aa.w*vec4(u.x*dv.x,u.x*dv.y,u.y*dv.x,u.y*dv.y);\n    }\n    Q += vec4(mat2(Q)*mat2(f));\n    Q = mix(Q,0.125*m,.01);\n    if (iFrame<1) Q = vec4(1,0,0,1);\n    Q = clamp(Q,-2.,2.);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdVcWm", "name": "Ruby in a crystal", "author": "xjorma", "description": "Loosely Inspired by Nathan Riley. I believe a Ruby have more value than a credit card, at least for mine :)\nhttps://dribbble.com/shots/14236753-Letter-Card", "tags": ["raytracing", "refraction", "sphere", "box", "diffraction", "reproduction"], "likes": 43, "viewed": 1198, "published": 3, "date": "1603063471", "time_retrieved": "2024-07-30T20:39:32.723058", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define MAX_DIST\t\t5.\n#define PI              radians(180.)\n#define TAU             radians(360.)\n#define MAX_BOUNCES     7\n\n#define GAMMA\t\t\t0\n\nfloat map(in vec3 p, out vec3 absorb, out vec3 refcol)\n{\n    float id  = fDodecahedron(p, 0.8);\n    float od = fDodecahedron(p, 0.805);\t\t\t// Horrible hack, not very proud of this, but to fix that the proper way I have to rethink the render loop to handle inter material transition, also I am not sure how to make it work with ray matching. \n    float oi = fIcosahedron(p, 1.5);\n\n    float d = min(max(oi, -od), id);\n    if (d == id)\n    {\n        absorb = vec3(0, 1, 1) * 10.;\n        refcol = vec3(1,0.5,0.5);\n    }\n    else\n    {\n        absorb = vec3(0);\n        refcol = vec3(1);\n    }\n    return d;\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    #if GAMMA\n    \tcol = pow(col, vec3(2.2));\n    #endif\n    return col;\n}\n\nvec3 normal(in vec3 pos)\n{\n    vec3\t_absorb;\n    vec3\t_refcolor;\n    vec2\teps = vec2(0.0001, 0);\n\tfloat\td = map(pos, _absorb, _refcolor);\n\treturn normalize(vec3(map(pos + eps.xyy, _absorb, _refcolor) - d, map(pos + eps.yxy, _absorb, _refcolor) - d, map(pos + eps.yyx, _absorb, _refcolor) - d));\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT, out vec3 absorb, out vec3 refcolor)\n{\n  float t = offT;\n  for (int i = 0; i < 40; i++)\n  {\n    float h = sgn * map(ro + rd*t, absorb, refcolor);\n    if (h < 0.002 || t > MAX_DIST)\n        break;\n    t += h;\n  }\n  return t;\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd, in float cref)\n{\n    float sgn = 1.;\n    vec3  rel = vec3(1);\n    vec3  col = vec3(0);\n    float transp = 1.;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3\tabsorb;\n        vec3\trefcolor;\n        float t = rayMarch(sgn, ro, rd, 0.02, absorb,refcolor);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * normal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.);\n        float reflectorFactor = mix (0.2, 1., fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n     \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * refcolor * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 4.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col;\n        float cbase = 0.8;\n        float cvar = 0.02;\n        col.r = Render(ro , rd, cbase - cvar).r;\n        col.g = Render(ro , rd, cbase).g;\n        col.b = Render(ro , rd, cbase + cvar).b;\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n    \n    tot = desaturate(tot, -0.2);\n    tot = vignette(tot, fragCoord / iResolution.xy, 1.2);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVcWm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[303, 303, 359, 359, 908], [910, 910, 937, 937, 1055], [1057, 1057, 1083, 1083, 1353], [1356, 1356, 1461, 1461, 1648], [1651, 1651, 1703, 1703, 2927], [2930, 2930, 2972, 2972, 3136], [3138, 3138, 3182, 3182, 3281], [3283, 3283, 3323, 3323, 3393]], "test": "untested"}
{"id": "ts33Rs", "name": "Color Gradient - RGB", "author": "woz", "description": "RGB Color Gradient", "tags": ["colorgradientrgb"], "likes": 1, "viewed": 481, "published": 3, "date": "1603063340", "time_retrieved": "2024-07-30T20:39:33.879965", "image_code": "vec3 getColor(float n)\n{\n    return vec3((1. - n - 0.5) * 1.3, n * (1. - n) * 1.3, (n - 0.5) * 1.3);\n    \n    return vec3((n - 0.25) * 1.3, 0., 0.);\n    return vec3((1. - n - 0.25) * 1.3, 0., 0.);\n    return vec3(n * (1. - n) * 1.3, 0., 0.);\n    return vec3(1. - n, 0., 0.);\n    return vec3(n * 2. + 3., n * 2. - 1., n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = getColor(uv.x);\n  \tfragColor = vec4(pow(col,vec3(1./2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts33Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 322], [324, 324, 381, 381, 501]], "test": "untested"}
{"id": "tsy3WW", "name": "KIFS - woz", "author": "woz", "description": "KIFS Test\n\nCredits: Art of Code - YouTube\nhttps://www.youtube.com/watch?v=il_Qg9AqQkE&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5", "tags": ["kifs"], "likes": 2, "viewed": 298, "published": 3, "date": "1603063261", "time_retrieved": "2024-07-30T20:39:34.750637", "image_code": "#define PI 3.14159265358\n\nvec2 N(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    float t = sin(iTime * .2) * PI * .5;\n    float c = cos(t);\n    float s = sin(t);\n    uv *= mat2(c, s, -s, c);\n    \n    uv /= (sin(iTime * .1) *.4 + .5) * 3.;\n    \n    vec3 col = vec3(0.);\n\n    uv.x = abs(uv.x);\n\n    float angle = PI * 5. / 6.;\n    uv.y += tan(angle) * .5;\n    \n    vec2 n = N(angle);\n    float d = dot(uv - vec2(.5, 0.), n);\n    uv -= n * max(0., d) * 2.;\n    \n    n = N(iTime * .05);\n    float scale = 1.;\n    \n    uv.x += .5;\n    \n    float sc = 3. + sin(iTime * .1) * 2.;\n    \n    for(int i = 0; i < 4; i++) {\n        scale *= sc;\n        uv *= sc;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n        \n    }\n    \n\n    float l = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n    col += smoothstep(1. / iResolution.y, 0., l / scale);\n    uv /= scale;\n    \n    \n    col = texture(iChannel1, uv * 2. + vec2(iTime * .1, iTime * .07)).rgb;\n\tcol = mix(col, texture(iChannel0, uv * 2. - iTime * .1).rgb, length(col) * 0.6 * sin(iTime));\n    col = mix(col, texture(iChannel2, uv * 2.4 - vec2(-iTime * .2, iTime * .2)).rgb, length(1. -col) * 0.4 * sin(iTime));\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsy3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 90], [92, 92, 149, 149, 1445]], "test": "untested"}
{"id": "Wdt3D7", "name": "Music 1", "author": "woz", "description": "music", "tags": ["sound"], "likes": 3, "viewed": 260, "published": 3, "date": "1603063139", "time_retrieved": "2024-07-30T20:39:35.631282", "image_code": "#define PI 3.141592653589793238\n\nfloat circle(float size, vec2 uv) {\n    float x = sin (iTime  * (2. * PI) * 0.5) * 0.25;\n    float y = cos (iTime  * (2. * PI) ) * 0.25;\n    \n    vec2 p = vec2(x, y);\n    return smoothstep(size, size - .01, length(uv - p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float mask = circle(.03, uv);\n    vec3 col = vec3(mask);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": " #define C0 16.35 \n #define Db0 17.32 \n #define D0 18.35 \n #define Eb0 19.45 \n #define E0 20.60 \n #define F0 21.83 \n #define Gb0 23.12 \n #define G0 24.50 \n #define Ab0 25.96 \n #define A0 27.50 \n #define Bb0 29.14 \n #define B0 30.87 \n #define C1 32.70 \n #define Db1 34.65 \n #define D1 36.71 \n #define Eb1 38.89 \n #define E1 41.20 \n #define F1 43.65 \n #define Gb1 46.25 \n #define G1 49.00 \n #define Ab1 51.91 \n #define A1 55.00 \n #define Bb1 58.27 \n #define B1 61.74 \n #define C2 65.41 \n #define Db2 69.30 \n #define D2 73.42 \n #define Eb2 77.78 \n #define E2 82.41 \n #define F2 87.31 \n #define Gb2 92.50 \n #define G2 98.00 \n #define Ab2 103.83 \n #define A2 110.00 \n #define Bb2 116.54 \n #define B2 123.47 \n #define C3 130.81 \n #define Db3 138.59 \n #define D3 146.83 \n #define Eb3 155.56 \n #define E3 164.81 \n #define F3 174.61 \n #define Gb3 185.00 \n #define G3 196.00 \n #define Ab3 207.65 \n #define A3 220.00 \n #define Bb3 233.08 \n #define B3 246.94 \n #define C4 261.63 \n #define Db4 277.18 \n #define D4 293.66 \n #define Eb4 311.13 \n #define E4 329.63 \n #define F4 349.23 \n #define Gb4 369.99 \n #define G4 392.00 \n #define Ab4 415.30 \n #define A4 440.00 \n #define Bb4 466.16 \n #define B4 493.88 \n #define C5 523.25 \n #define Db5 554.37 \n #define D5 587.33 \n #define Eb5 622.25 \n #define E5 659.25 \n #define F5 698.46 \n #define Gb5 739.99 \n #define G5 783.99 \n #define Ab5 830.61 \n #define A5 880.00 \n #define Bb5 932.33 \n #define B5 987.77 \n #define C6 1046.50 \n #define Db6 1108.73 \n #define D6 1174.66 \n #define Eb6 1244.51 \n #define E6 1318.51 \n #define F6 1396.91 \n #define Gb6 1479.98 \n #define G6 1567.98 \n #define Ab6 1661.22 \n #define A6 1760.00 \n #define Bb6 1864.66 \n #define B6 1975.53 \n #define C7 2093.00 \n #define Db7 2217.46 \n #define D7 2349.32 \n #define Eb7 2489.02 \n #define E7 2637.02 \n #define F7 2793.83 \n #define Gb7 2959.96 \n #define G7 3135.96 \n #define Ab7 3322.44 \n #define A7 3520.00 \n #define Bb7 3729.31 \n #define B7 3951.07 \n #define C8 4186.01 \n #define Db8 4434.92 \n #define D8 4698.63 \n #define Eb8 4978.03 \n #define E8 5274.04 \n #define F8 5587.65 \n #define Gb8 5919.91 \n #define G8 6271.93 \n #define Ab8 6644.88 \n #define A8 7040.00 \n #define Bb8 7458.62 \n #define B8 7902.13  \n\nfloat _sin(float hz, float time)\n{\n    return sin(6.2831 * hz * time);\n}\n\nfloat _square(float hz, float time)\n{\n    return sign(_sin(hz, time));\n}\n\nfloat _squareRich(float hz, float time, float offset)\n{\n    float sound = _square(hz, time) * 0.3;\n    sound += _square(hz * 2. + offset, time) * 0.1;\n    sound += _square(hz * 3. - offset, time) * 0.15;\n    sound += _square(hz * 4. + offset, time) * 0.06;\n    return sound;\n}\n\nvec2 playSin(float hz, float time, float startTime, float volume)\n{\n    float falloff = time - startTime;\n    return vec2(_sin(hz, time)*exp(-3.0*falloff)) * volume;\n}\n\nfloat playSquare(float hz, float time, float startTime, float volume)\n{\n    return _square(hz, time) * volume;\n}\n\nvec2 sineLoop(float time)\n{\n    float[] notes = float[] (\n        440.,\n        660.,\n        440.,\n        330.\n    );\n    \n    int note = int(time) % 4;\n    return playSin(notes[note], time, float(int(time)), 1.);\n}\n\nvec2 squareLoop(float[4] notes, float time)\n{\n    int note = int(time / 4.) % 4;\n    float hz = notes[note];\n    float t = sin(time/ 100.) * 0.01;\n    float l = _squareRich(hz, time, t);\n    float r = _squareRich(hz, time, -t);\n    return vec2(l, r);\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float volume = 0.05;\n    vec2 sound = vec2(0.);\n    \n    sound += sineLoop(time);\n    \n    //sound += playSin(440., time, 1.);\n    \n    \n    sound += squareLoop(float[] (A2, E2, D2, F2), time); \n    sound += squareLoop(float[] (E2, G2, F2, C3), time) * 0.75; \n    sound += squareLoop(float[] (C3, D2, A2, A2), time) * 0.65;\n    \n    return sound * volume;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdt3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 68, 68, 258], [260, 260, 317, 317, 477]], "test": "untested"}
{"id": "tdy3Wz", "name": "grid - woz", "author": "woz", "description": "grid test", "tags": ["grid"], "likes": 0, "viewed": 233, "published": 3, "date": "1603062520", "time_retrieved": "2024-07-30T20:39:36.425160", "image_code": "float f(vec2 uv)\n{\n    float x = uv.x;\n    float l = length(uv - vec2(x, x * x + sin(iTime * 1.)));\n    \n    return l;\n    return min(l, length(uv - vec2(x, sin(x + iTime * 10.))));\n}\n\nfloat grid(vec2 fragCoord)\n{\n    ivec2 coord = ivec2(fragCoord);\n    coord -= ivec2(iResolution.xy) / 2;\n    return float(1 - clamp(abs(coord.x) * abs(coord.y), 0, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv *= 10.;\n\n    float d = smoothstep(.2, .1, f(uv));\n    \n    d += grid(fragCoord);\n    \n    vec3 col = vec3(d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 183], [185, 185, 213, 213, 355], [357, 357, 414, 414, 635]], "test": "untested"}
{"id": "wsVcDm", "name": "Explainable Ripple Effect", "author": "andful", "description": "ripples effect", "tags": ["2d", "water"], "likes": 3, "viewed": 817, "published": 3, "date": "1603057327", "time_retrieved": "2024-07-30T20:39:37.190114", "image_code": "#define PI 3.1415926538\n\n//time cycle\n#define TIME_CYCLE 20.0\n//number of ripples\n#define N 30\n//standar deviation of gaussian\n#define STD 75.0\n//aplitude of ripple\n#define AMPLITUDE 0.75\n//wave length of ripple\n#define WAVE_LENGTH 0.5\n//fading factor of ripple as it spreads\n#define FADING_FACTOR 0.1\n//offset scaling factor\n#define OFFSET_SCALE 10.0\n//refraction coefficient\n#define REFRACTION_COEFFICIENT 1.0/1.333\n//refraction coefficient\n#define DEPTH 10.0\n//expansion speed\n#define EXPANSION_SPEED 50.0\n\nfloat rippleGradient(float x) {\nreturn (AMPLITUDE/WAVE_LENGTH*exp(-pow(x/WAVE_LENGTH,2.0)/STD)*(sin(x/WAVE_LENGTH)\n            - 2.0*x/pow(WAVE_LENGTH*STD, 2.0) * cos(x/WAVE_LENGTH))/WAVE_LENGTH);\n}\n\nvec2 source = vec2(0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 coord ) {\t    \n    //size of the image\n    ivec2 size = ivec2(256, 256);\n    \n    //derivative of the surface\n    vec2 partial_derivative = vec2(0.0);\n    \n    \n    for (int i=0; i< N ;i++) {\n        // get random value\n        vec4 data = texture(iChannel1, vec2(float(i)/float(size.x),float(i % size.x)/float(size.y)));\n        \n        //pixel position of droplet in the screen\n        vec2 source = data.xy*iResolution.xy;\n        \n        //time of droplet drop\n        float start_time = TIME_CYCLE*data.z;\n        \n        //difference in time\n        float delta = mod(iTime - start_time, TIME_CYCLE) - TIME_CYCLE/2.0;\n        \n        //radius of ripple\n        float r = EXPANSION_SPEED*delta;\n        \n        //conversion derivative to normal angle\n    \tvec2 radial_direcetion = coord - source;\n        //distance from droplet center\n        float dist = length(radial_direcetion);\n        //proportions\n        vec2 p = normalize(radial_direcetion);\n        \n        //function value;\n        float x = dist - r;\n        \n        // height of the water being AMPLITUDE*cos(x/SCALE)*exp(-pow(x/SCALE,2.0)/S) this is the derivative.\n        // THe function is a product between a cosine function and a gaussian times a fading factor.\n        partial_derivative +=\n            p*rippleGradient(x)/(pow(r*FADING_FACTOR, 2.0) + 1.0);\n    }\n    vec3 normal = vec3(-partial_derivative.x,1.0,-partial_derivative.y);\n    vec3 eye = vec3(0.0, -1.0, 0.0);\n    \n    float c1 = dot(normal, eye);\n    float c2 = sqrt(1.0 - pow(REFRACTION_COEFFICIENT, 2.0)*(1.0 - pow(c1, 2.0)));\n    \n    //computing the refraction\n    vec3 refracted = REFRACTION_COEFFICIENT*eye + (REFRACTION_COEFFICIENT*c1 - c2)*normal;\n    \n    fragColor = texture(iChannel0, (coord + OFFSET_SCALE*refracted.xz)/iResolution.xy);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 541, 541, 708], [741, 741, 794, 823, 2584]], "test": "untested"}
{"id": "tdKcDm", "name": "video hold effect", "author": "mds2", "description": "as the line sweeps across the image it triggers a video hold.  Move while it's doing so to produce weird distorted blobby shapes.\n\nAs seen on TikTok.", "tags": ["simple", "video", "fun", "effect"], "likes": 6, "viewed": 743, "published": 3, "date": "1603055441", "time_retrieved": "2024-07-30T20:39:37.985987", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    float sweep = get_sweep_uv(iTime);\n    sweep *= iResolution.x;\n    \n    if (abs(fragCoord.x - sweep) < 5.0) {\n    \tfragColor = vec4(1.0, 0.7, 0.0, 1.0);\n        return;\n    }\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float sweep = get_sweep_uv(iTime);\n    sweep = max(sweep, 0.0);\n    \n    vec4 hold_color = texture(iChannel0, uv);\n    vec4 vid_color = texture(iChannel1, vec2(1. - uv.x, uv.y));\n    fragColor = mix(vid_color, hold_color, step(uv.x, sweep));\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float sweep_period = 20.0;\nconst float pre_sweep_pause = 2.0;\nconst float post_sweep_pause = 10.0;\n\nfloat get_sweep_uv(in float time) {\n\tfloat result = (mod(time, sweep_period + pre_sweep_pause + post_sweep_pause) -\n           pre_sweep_pause) /\n        (sweep_period);\n    result = max(0.0, min(result, 1.0));\n    return result;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 399]], "test": "untested"}
{"id": "wdVyDw", "name": "color palettes", "author": "manu210404", "description": "some nice gradients!", "tags": ["colors", "gradients", "palettes"], "likes": 8, "viewed": 577, "published": 3, "date": "1603040610", "time_retrieved": "2024-07-30T20:39:38.848680", "image_code": "#define PI 3.1415926\n#define HALF_PI 1.57079633\nvec3 palette1(float x) {\n    float v = pow(sin(PI*x), 2.);\n    return v * vec3(1., .5*v, .5);\n}\n\nvec3 palette2(float x) {\n    float v = pow(sin(PI*x), 2.);\n    return v * vec3(.5*v, 1.*v, .25);\n}\n\nvec3 palette3(float x) {\n    float v = pow(sin(PI*x), 2.);\n    return v * vec3(1., .5*v, .25*v);\n}\n\nvec3 palette4(float x) {\n    float v = pow(sin(PI*x), 2.);\n    return v * vec3(.5, .75*v, .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0);\n    if (uv.y < .25) {\n        col = pow(palette1(uv.x), vec3(.454545454545454545455));\n    } else if (uv.y < .5){\n        col = pow(palette2(uv.x), vec3(.454545454545454545455));\n    } else if (uv.y < .75){\n        col = pow(palette3(uv.x), vec3(.454545454545454545455));\n    } else {\n        col = pow(palette4(uv.x), vec3(.454545454545454545455));\n    }\n    float n = 1.-fract(uv.y*4.)*2.;\n    col *= sqrt(1.-n*n);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 72, 72, 143], [145, 145, 169, 169, 243], [245, 245, 269, 269, 343], [345, 345, 369, 369, 441], [443, 443, 500, 550, 1089]], "test": "untested"}
{"id": "WsVcWm", "name": "Polar coordinates with mix.", "author": "henrmota", "description": "The power of polar coordinates and linear interpolation", "tags": ["polar"], "likes": 2, "viewed": 424, "published": 3, "date": "1603023814", "time_retrieved": "2024-07-30T20:39:39.614632", "image_code": "#define PI 3.14155\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    //atan goes from -PI to PI so normalize with angle/(2.*PI) + 0.5\n    float angle = atan(st.y, st.x)/(2.*PI) + 0.5 + iTime*0.1;\n    st = vec2(angle, length(st));\n   \n   \tst.y *=2.; \n    \n    //comment to see another cool effect (flower)\n    st.x += st.y;\n    st.x = fract(st.x * 10. );\n   \tfloat pct = smoothstep(-0.5, 0.5, sin(iTime));\n    fragColor = texture(iChannel0, mix(st, uv, pct));\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 581]], "test": "untested"}
{"id": "3dKyWm", "name": "CIE Lab, Luv, LCh", "author": "thepheer", "description": "Color conversions:\nLCh(ab) ↔ Lab ↔ XYZ ↔ sRGB\nLCh(uv) ↔ Luv ↔ XYZ ↔ sRGB", "tags": ["lab", "lch", "cielab", "cielch", "luv", "cie", "cieluv"], "likes": 7, "viewed": 580, "published": 3, "date": "1603016399", "time_retrieved": "2024-07-30T20:39:40.416488", "image_code": "#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(x, a, b) ((a) <= (x) && (x) < (b))\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n    \n    float tau = radians(360.0);\n    float L = 0.50 + 0.49*sin(tau*(0.2*uv.x - 0.1*iTime));\n    float C = L*(1.0 - L);\n    float h = tau*(fract(uv.x + 0.5*iTime) - 0.5);\n\n    // LCh → Lab → sRGB → Lab → LCh\n    vec3 LCh1 = vec3(L, C, h);\n    vec3 Lab1 = LCh_to_Lab(LCh1);\n    vec3 sRGB = Lab_to_sRGB(Lab1);\n    vec3 Lab2 = sRGB_to_Lab(sRGB);\n    vec3 LCh2 = Lab_to_LCh(Lab2);\n    \n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    vec3 split = 0.025*vec3(-1.0, 0.0, 1.0);\n    \n    vec3 plots =\n        plot(px.y, uv.y, 0.500)*dotted*0.1 +\n        plot(px.y, uv.y, 0.100)*dotted*0.1 +\n        plot(px.y, uv.y, 0.775 + 1e3*(LCh2 - LCh1) - split) +\n        plot(px.y, uv.y, 0.625 + 2e4*(Lab2 - Lab1) - split) +\n        plot(px.y, uv.y, 0.100 + 0.4*sRGB);\n\n    vec3 rgb =\n        range(uv.y, 0.9, 1.0) ? sRGB :\n    \tplots;\n\n    rgba = vec4(sRGB_OETF(rgb), 1.0);\n}", "image_inputs": [], "common_code": "#define diag3(v) mat3((v).x, 0.0, 0.0, 0.0, (v).y, 0.0, 0.0, 0.0, (v).z)\n#define xyY_to_XYZ(x, y, Y) vec3(Y/y*x, Y, Y/y*(1.0 - x - y))\n#define xy_to_XYZ(x, y) vec3(x/y, 1.0, (1.0 - x - y)/y)\n#define xy_to_xyz(x, y) vec3(x, y, 1.0 - x - y)\n\nconst mat3 BFD = mat3(0.8951, -0.7502, 0.0389, 0.2664, 1.7135, -0.0685, -0.1614, 0.0367, 1.0296);\n\nconst vec3 D50 = xy_to_XYZ(0.34567, 0.35850);\nconst vec3 D65 = xy_to_XYZ(0.31271, 0.32902);\nconst mat3 D65_TO_D50 = inverse(BFD)*diag3((BFD*D50)/(BFD*D65))*BFD;\n\nconst mat3 sRGB = mat3(xy_to_XYZ(0.64, 0.33), xy_to_XYZ(0.30, 0.60), xy_to_XYZ(0.15, 0.06));\nconst mat3 sRGB_TO_XYZ_D65 = sRGB*diag3(inverse(sRGB)*D65);\nconst mat3 sRGB_TO_XYZ_D50 = D65_TO_D50*sRGB_TO_XYZ_D65;\nconst mat3 XYZ_D65_TO_sRGB = inverse(sRGB_TO_XYZ_D65);\nconst mat3 XYZ_D50_TO_sRGB = inverse(sRGB_TO_XYZ_D50);\n\nvec3 sRGB_OETF(vec3 c) {\n    vec3 a = 12.92*c;\n    vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));\n}\n\nvec3 sRGB_EOTF(vec3 c) {\n    vec3 a = c/12.92;\n    vec3 b = pow((c + 0.055)/1.055, vec3(2.4));\n    return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));\n}\n\n// LCh(ab) ↔ Lab ↔ XYZ ↔ sRGB\n\nvec3 XYZ_to_Lab(vec3 XYZ, vec3 XYZw) {\n    vec3 t = XYZ/XYZw;\n    vec3 a = pow(t, vec3(1.0/3.0));\n    vec3 b = 841.0/108.0*t + 4.0/29.0;\n    vec3 c = mix(b, a, greaterThan(t, vec3(216.0/24389.0)));\n    return vec3(1.16*c.y - 0.16, vec2(5.0, 2.0)*(c.xy - c.yz));\n}\n\nvec3 Lab_to_XYZ(vec3 Lab, vec3 XYZw) {\n    float L = (Lab.x + 0.16)/1.16;\n    vec3 t = vec3(L + Lab.y/5.0, L, L - Lab.z/2.0);\n    vec3 a = pow(t, vec3(3.0));\n    vec3 b = 108.0/841.0*(t - 4.0/29.0);\n    return XYZw*mix(b, a, greaterThan(t, vec3(6.0/29.0)));\n}\n\nvec3 LCh_to_Lab(vec3 LCh) {\n    return vec3(LCh.x, LCh.y*vec2(cos(LCh.z), sin(LCh.z)));\n}\n\nvec3 Lab_to_LCh(vec3 Lab) {\n    return vec3(Lab.x, length(Lab.yz), atan(Lab.z, Lab.y));\n}\n\nvec3 sRGB_to_Lab(vec3 sRGB) {\n    return XYZ_to_Lab(sRGB_TO_XYZ_D50*sRGB, D50);\n}\n\nvec3 Lab_to_sRGB(vec3 Lab) {\n    return XYZ_D50_TO_sRGB*Lab_to_XYZ(Lab, D50);\n}\n\n// LCh(uv) ↔ Luv ↔ XYZ ↔ sRGB\n\n#define XYZ_to_uv(XYZ) vec2(4.0, 9.0)*XYZ.xy/(XYZ.x + 15.0*XYZ.y + 3.0*XYZ.z)\n#define xy_to_uv(xy) vec2(4.0, 9.0)*xy/(-2.0*xy.x + 12.0*xy.y + 3.0)\n#define uv_to_xy(uv) vec2(9.0, 4.0)*uv/(6.0*uv.x - 16.0*uv.y + 12.0)\n\nvec3 XYZ_to_Luv(vec3 XYZ, vec3 XYZw) {\n    float Y = XYZ.y/XYZw.y;\n    float L = Y > 216.0/24389.0 ? 1.16*pow(Y, 1.0/3.0) - 0.16 : 24389.0/2700.0*Y;\n    return vec3(L, 13.0*L*(XYZ_to_uv(XYZ) - XYZ_to_uv(XYZw)));\n}\n\nvec3 Luv_to_XYZ(vec3 Luv, vec3 XYZw) {\n\tvec2 uv = Luv.yz/(13.0*Luv.x) + XYZ_to_uv(XYZw);\n    float Y = Luv.x > 0.08 ? pow((Luv.x + 0.16)/1.16, 3.0) : 2700.0/24389.0*Luv.x;\n    float X = (9.0*uv.x)/(4.0*uv.y);\n    float Z = (12.0 - 3.0*uv.x - 20.0*uv.y)/(4.0*uv.y);\n    return XYZw.y*vec3(Y*X, Y, Y*Z);\n}\n\nvec3 LCh_to_Luv(vec3 LCh) {\n    return vec3(LCh.x, LCh.y*vec2(cos(LCh.z), sin(LCh.z)));\n}\n\nvec3 Luv_to_LCh(vec3 Luv) {\n    return vec3(Luv.x, length(Luv.yz), atan(Luv.z, Luv.y));\n}\n\nvec3 sRGB_to_Luv(vec3 sRGB) {\n    return XYZ_to_Luv(sRGB_TO_XYZ_D65*sRGB, D65);\n}\n\nvec3 Luv_to_sRGB(vec3 Luv) {\n    return XYZ_D65_TO_sRGB*Luv_to_XYZ(Luv, D65);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 223, 223, 1210]], "test": "untested"}
{"id": "3sKyDw", "name": "Cells Under a Microscope", "author": "jarble", "description": "I don't know what these patterns are, but they look vaguely biological.", "tags": ["fractal", "cell"], "likes": 2, "viewed": 380, "published": 3, "date": "1603002849", "time_retrieved": "2024-07-30T20:39:41.171470", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t = iTime*.3;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t+2.0);\n        //uv *= 10.0;\n        int c = 0;\n        for(int i=0;i<9;i++)\n        {\n            c = i%3;\n            float factor = 1.5;\n            vec2 uv1 = uv;\n            uv /= factor;\n            uv += uv1;\n            uv += (sin(uv.yx))/factor;\n            uv *= factor;\n            col[c] += sin(uv.x+uv.y);\n        }\n    fragColor = vec4(col*100.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 524]], "test": "untested"}
{"id": "3dVcWw", "name": "Rainbow Acid Fractal", "author": "jarble", "description": "Another edit of my \"Acid Wave\" fractal.", "tags": ["fractal"], "likes": 3, "viewed": 282, "published": 3, "date": "1602999929", "time_retrieved": "2024-07-30T20:39:41.921464", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t = iTime*.5;\n    vec2 uv = (.3)*(fragCoord*10.0-iResolution.xy)/iResolution.y;\n    for(int c=0;c<3;c++){\n        for(int i=0;i<9;i++)\n        {\n            float factor = 1.2;\n            uv *= factor;\n            //uv += sin(col.yx);\n        \tuv += float(i) + (sin(uv.x+uv.y)+cos(uv.y+t)+sin(t-uv.x));\n\n            uv /= factor;\n        }\n     col[c] = (col[c] + sin(uv.x+uv.y))/2.0;\n\t}\n    col*=2.0;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 519]], "test": "untested"}
{"id": "WdKcWw", "name": "Algae Pond", "author": "jarble", "description": "It's a mix of green and brown algae floating on a pond. This is based on my \"Acid Wave\" fractal.", "tags": ["fractal", "algae"], "likes": 2, "viewed": 276, "published": 3, "date": "1602999773", "time_retrieved": "2024-07-30T20:39:42.842003", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t = iTime*.5;\n    vec2 uv = (.1)*(fragCoord*10.0-iResolution.xy)/iResolution.y;\n        int c = 0;\n        for(int i=0;i<27;i++)\n        {\n            c = i % 5;\n            float factor = 1.2;\n            vec2 uv1 = uv;\n            uv /= factor;\n            uv += uv1;\n            //uv += sin(col.yx);\n        \tuv += float(i) + (sin(uv.x+uv.y)+cos(uv.y+t)+sin(t-uv.x));\n            uv *= factor;\n            col[c] = (col[c] + sin(uv.x+uv.y))/2.0;\n        }\n    col*=2.0;\n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 594]], "test": "untested"}
{"id": "3sycDm", "name": "Sphere in a box or ...", "author": "xjorma", "description": "Sphere in a box or a box in sphere ?\n\nInspired by Nathan Riley\nhttps://dribbble.com/shots/10879124-Morphing-Geometry", "tags": ["raytracing", "refraction", "sphere", "box", "diffraction", "reproduction"], "likes": 67, "viewed": 1638, "published": 3, "date": "1602993219", "time_retrieved": "2024-07-30T20:39:43.735614", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define GAMMA 0\n\nstruct objDec\n{\n    float r;\n    float s;\n    mat3  m;\n};\n    \nconst float offset = 4.;\n\n        \nbool intersectObjFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    ro = ro + rd * offset;\n    rd = -rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = -roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = offset - d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectObjFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectSceneFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec inner, in objDec outter)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, outter);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, inner);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\nbool intersectSceneFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec inner, in objDec outter)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, inner);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, outter);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    #if GAMMA\n    \tcol = pow(col, vec3(2.2));\n    #endif\n    return col;\n}\n\n\n\n#define MAX_BOUNCES 4\n#define ABSORB\t\tvec3(0, 0, 0)\n\nvec3 Render(in vec3 ro, in vec3 rd, in float dist, float cref, in objDec inner, in objDec outter)\n{\n    float sgn = 1.;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.99;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3\tn;\n        float \td;\n        bool\tinter;\n        if(sgn > 0.)\n        {\n            inter = intersectSceneFromOutside(ro, rd, dist, d, n, inner, outter);\n        }\n        else\n        {\n            inter = intersectSceneFromInside(ro, rd, dist, d, n, inner, outter);\n        }\n        \n        if(!inter)\n        {\n            col += rel * getSkyColor(rd);\n            return col;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * d);\n        vec3 p = ro + rd * d;\n        //n *= sgn;\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime * 0.95;\n    float v = (cos(t) + 1.) * 0.5;\n    \n    objDec inner, outter;\n    outter.r = v * 0.75 + 0.1;\n    outter.s   = (1.-v) * 0.75;\n    outter.m = fromEuler(vec3(t * 0.9 + 0.2,  t * 0.6 + 1.2, t * 0.5 + 0.9));\n    inner.r  = (1.-v) * 0.35 + 0.1;\n    inner.s\t   = v * 0.35;\n    inner.m = fromEuler(vec3(t * 0.8 + 1.5,  t * 0.4 + 0.7, t * 0.7 + 2.3));\n\n  \n\tvec3 tot = vec3(0.0);   \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + radians(180.);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col;\n        col.r = Render(ro, rd, 12.,0.67, inner, outter).r;\n        col.g = Render(ro, rd, 12.,0.7, inner, outter).g;\n        col.b = Render(ro, rd, 12.,0.73, inner, outter).b;\n        \n      \ttot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 1.2);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// my modified round intersection from https://www.shadertoy.com/view/wsyyWw\n\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.;\n}\n\n// intersect a ray with a rounded box\n// https://iquilezles.org/articles/intersectors\n// Modified to support bigger radius, probably more optimal solution, but was too lazy and nor as good as IQ :(\n// I kept the -1 for no collision paradigm even if I hate it (Make code more complex), but I prefered to stay compatible with IQ interface.\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    \n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n  \n  \t// fat edges\n    float d;\n    d = capIntersect(ro, rd, size * vec3(-1, 1, 1), size, rad);\n    t = d > 0. ? d : 1e20;\n    d = capIntersect(ro, rd, size * vec3( 1,-1, 1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n    d = capIntersect(ro, rd, size * vec3( 1, 1,-1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n    \n}\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[276, 276, 386, 386, 701], [703, 703, 814, 814, 1078], [1080, 1080, 1215, 1215, 1454], [1456, 1456, 1590, 1590, 1829], [1833, 1833, 1860, 1860, 1978], [2035, 2035, 2134, 2134, 3588], [3590, 3590, 3632, 3632, 3796], [3799, 3799, 3843, 3843, 3942], [3944, 3944, 3984, 3984, 4054]], "test": "untested"}
{"id": "wdycDm", "name": "october v004", "author": "darkczar", "description": "trippy", "tags": ["trippy"], "likes": 4, "viewed": 279, "published": 3, "date": "1602989311", "time_retrieved": "2024-07-30T20:39:44.611272", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,200);\n    float d = 10000.0 + 4200.*sin(iTime)+4200.*cos(iTime);\n    float di = 2.;// +3.2*sin(iTime * .1);\n    for(int i = 0;i<300;i++)\n    {\n        di = float(i)*.3;\n        curve_p.x = .5-.3*sin(.3*iTime)-.05*float(di)*cos(float(di)+.4*iTime); // +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = .5-.3*cos(.3*iTime)-.05*float(di)*sin(float(di)+.2*iTime); // +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = sin(min(d*1.0, 1.*sin(length(p-curve_p))));\n        //d = length(p-curve_p)/(di+1.0);\n  \n    }\n    float r =.05*d + .05*(.05 - .015*pow(dot(sin(p*p + d*d), log(20.0+2.*curve_p -d)),2.0));\n    float g = .0008 + .005*cos(.001*d*d*d+3.1*length(p)); //+.03*dot(p,curve_p + .0005*vec2(iTime, iTime));\n    float b=2.5*abs(.5+.3*cos(iTime*.8 - 2.5*pow(d,2.0))); // +.01*(dot(p,curve_p - .005*vec2(iTime-200.05, iTime-200.05)+10.0));\n    if (d < 2.2)\n    {\n        b = .0 +.04*(.5+ .5*sin(iTime*.1 + 1.28*dot(p,curve_p)));\n    }\n    float checkers = mod(float(uv.x*uv.x +uv.y*uv.y)+r*r*1200.+b*20., .25);\n    float checkers_02 =mod(float( -.01*curve_p.x*curve_p.y)+g*g*1000.,.25);\n    if (checkers + checkers_02 > .25)\n    {\n        r = 0.06*r;\n        g = 1.2*g;\n        b = 1.2*b;\n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdycDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 1828]], "test": "untested"}
{"id": "tsGcDm", "name": "Emerald Sandstone Caverns", "author": "jarble", "description": "Based on my \"Alien Hive\" fractal", "tags": ["3d", "fractal", "cave", "stalactite"], "likes": 3, "viewed": 369, "published": 3, "date": "1602982523", "time_retrieved": "2024-07-30T20:39:45.578686", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    vec4 dmap = depth_map(fragCoord);\n    vec3 p = depth_map(fragCoord).xyz;\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    //distance fog\n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+10.0+5.0*sin(iTime*16.0))*30.0;\n    \n    \n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define image_scale 8.0\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*2.0;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n        float p1 = planet_surface(p*i,i)/(i);\n        result = max(result, -p1);\n        result += cos(planet_surface(p.xzy/i,i))*(i);\n        //p.y /= 2.0+sin(((p.z+p.x)/(i*81.0*81.0)));\n        //p.z /= 2.0;\n        //p.x /= 2.0;\n        //p.x /= 1.1;\n        //p.z /= 1.1;\n        //p.y /= 3.0+sin((p.x+p.z)/(i*3.0));\n\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        //eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dmap = depth_map(fragCoord);\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    \n    //start from the square root of the previous distance\n    float start = sqrt(length(eye-dmap.xyz));\n\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+start, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, dist);\n    \n    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 218], [221, 642, 733, 733, 1094], [1109, 1363, 1428, 1428, 1560], [1562, 1651, 1680, 1717, 2027], [2029, 2521, 2661, 2661, 3271], [3273, 3643, 3728, 3728, 4143], [4145, 4472, 4521, 4556, 4687], [4689, 4689, 4716, 4716, 4861], [4863, 4863, 4920, 4920, 5789]], "test": "untested"}
{"id": "wdGcDm", "name": "mouse react", "author": "mds2", "description": "let the mouse drag some reaction diffusion stuff", "tags": ["mouse", "cellular", "reaction"], "likes": 6, "viewed": 426, "published": 3, "date": "1602982168", "time_retrieved": "2024-07-30T20:39:46.400489", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ERODE 1\n#define CHAOS_FILL 0 // set to 1 for more interesting fill patterns.  Looks very nice with color_to_val_3\n\nconst float diffuse_weight = 0.25; // higher means less diffusion.  set greater than 0 and less than 1\nconst float react_weight = 0.15; // reaction speed : don't exceed 0.25.  higher is faster reaction\n\n// in the function \"greatest\" there are two calls to \"color_to_val_4\"\n// change those to \"color_to_val_1\", \"color_to_val_2\" etc to get different effects\n\nvec2 to_uv(in vec2 in_pixels, in vec2 offset) {\n    return mod(in_pixels + offset, iResolution.xy) / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    \n    vec4 color = texture(iChannel1, to_uv(p, vec2(0.0)));\n    \n    // color.rg = mod(10.0 * to_uv(p), vec2(1.0));\n    color.b = 1.0 - 0.5 * color.r - 0.5 * color.g;\n    \n    \n   \n    \n    color = diffuse_weight * texture(iChannel0, to_uv(p, vec2(0.0)));\n    \n    float w = 0.25 * (1.0 - diffuse_weight);\n    color = color +  w * texture(iChannel0, to_uv(p, vec2(1.1, 0.0)));\n    color = color +  w * texture(iChannel0, to_uv(p, vec2(0.0, 1.1)));\n    color = color +  w * texture(iChannel0, to_uv(p, vec2(-1.1, 0.0)));\n    color = color +  w * texture(iChannel0, to_uv(p, vec2(0.0, -1.1)));\n    \n#if ERODE\n    color.a = 1.0;\n#endif\n    \n\n    color = color / color.a;\n    \n    color.rgb = color.rgb + react_weight * (1.0 * color.rgb * color.gbr - color.rgb * color.brg);//  + 0.005;\n    \n    float delta = 1.5 - dot(color.rgb, vec3(1.0));\n\n    color += 0.005 * delta;\n    \n    float mouseNess = smoothstep(10.0, 0.0, length(p - iMouse.xy));\n    color.rgb = mix(color.rgb, vec3(0.0, 0.0, 1.0), mouseNess);\n \n    fragColor = vec4(color.rgb,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 281]], "test": "untested"}
{"id": "wsGcWm", "name": "Self-Designed Bridge", "author": "wyatt", "description": "Using my new knowledge of continuum mechanics to make a self-designing bridge. ", "tags": ["deformation"], "likes": 7, "viewed": 537, "published": 3, "date": "1602979872", "time_retrieved": "2024-07-30T20:39:47.255203", "image_code": "Main {\n    vec4 a = A(U), b = B(U);\n\tQ = 0.5+0.5*(A(U));\n    float t = b.x*b.z-b.y*b.w;\n    float p = b.x*b.w-b.y*b.z;\n    Q = sin(.1+1.5*a.wwww+(1.+b.yzyz)*vec4(1,2,3,4));\n    //Q = abs(b.yzzz)*10.;\n    //Q = 2.*abs(A(U));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)", "buffer_a_code": "Main\n{\n\tQ = A(U);vec2 f = vec2(0); vec4 b = B(U);float m = 0.;\n    float s = 0.;\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 w = 0.125*Q.w*aa.w*(mat2(bb)*mat2(bb)-mat2(1))*u;\n        s += length(w);\n        f += w;\n        f += .5*0.125*Q.w*aa.w*(aa.xy-Q.xy);\n    \tm += 0.125*aa.w;\n    }\n    s/=m*Q.w;\n    Q.w = mix(Q.w,m,.02);\n    Q.w = clamp(Q.w+.1*(s-.1),.1,1.);\n    Q.xy += f*Q.w;\n    Q.y -= 1e-1/R.y*(Q.w-.1);\n    if(abs(0.5*R.y-U.y)<2.) {Q.y -= 1e-2;}\n    if (U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.x-U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (U.y<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    if (R.y-U.y<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.)Q.w *= 0.;\n    if (iFrame<1) Q = vec4(0,0,0,1);\n    Q = clamp(Q,-1.,1.);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n\tQ = B(U);vec4 f = vec4(0), a = A(U);\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 dv = aa.xy-a.xy;\n        f += 0.125*a.w*aa.w*vec4(u.x*dv.x,u.x*dv.y,u.y*dv.x,u.y*dv.y);\n    }\n    Q += vec4(mat2(Q)*mat2(f));\n    Q = mix(Q,vec4(1,0,0,1),.001);\n    if (iFrame<1) Q = vec4(1,0,0,1);\n    Q = clamp(Q,-2.,2.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n\tQ = A(U);vec2 f = vec2(0); vec4 b = B(U);float m = 0.;\n    float s = 0.;\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 w = 0.125*Q.w*aa.w*(mat2(bb)*mat2(bb)-mat2(1))*u;\n        s += length(w);\n        f += w;\n        f += .5*0.125*Q.w*aa.w*(aa.xy-Q.xy);\n    \tm += 0.125*aa.w;\n    }\n    s/=m*Q.w;\n    Q.w = mix(Q.w,m,.02);\n    Q.w = clamp(Q.w+.1*(s-.1),.1,1.);\n    Q.xy += f*Q.w;\n    Q.y -= 1e-1/R.y*(Q.w-.1);\n    if(abs(0.5*R.y-U.y)<2.) {Q.y -= 1e-2;}\n    if (U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (R.x-U.x<2.) Q.xy*=0.;//Q = vec4(0,0,0,1);\n    if (U.y<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    if (R.y-U.y<2.) Q.w*=0.;//Q = vec4(0,0,0,1);\n    \n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.)Q.w *= 0.;\n    if (iFrame<1) Q = vec4(0,0,0,1);\n    Q = clamp(Q,-1.,1.);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n\tQ = B(U);vec4 f = vec4(0), a = A(U);\n    for (int x = -1;x <= 1; x++)\n    for (int y = -1;y <= 1; y++)\n    if (x!=0||y!=0)\n    {\n    \tvec2 u = vec2(x,y);\n        vec4 bb = B(U+u);\n        vec4 aa = A(U+u);\n        u /= dot(u,u);\n        vec2 dv = aa.xy-a.xy;\n        f += 0.125*a.w*aa.w*vec4(u.x*dv.x,u.x*dv.y,u.y*dv.x,u.y*dv.y);\n    }\n    Q += vec4(mat2(f));\n    Q = mix(Q,vec4(1,0,0,1),.001);\n    if (iFrame<1) Q = vec4(1,0,0,1);\n    Q = clamp(Q,-2.,2.);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tsGyDm", "name": "New York-Athens", "author": "teraspora", "description": ".", "tags": ["minkowski"], "likes": 1, "viewed": 327, "published": 3, "date": "1602974067", "time_retrieved": "2024-07-30T20:39:48.130862", "image_code": "// organismus - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Based on voronoi-2\n// Date: 9 OCT 2018.\n\n// Copyright © 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// -----------------------------------------------------------------------------\n\n#define PI 3.141592653588\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(4483.34, 234.34, 345.65));\n\ta += dot(a, a - 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime / 2. + 2.;\n    float numPoints = clamp(floor(t / 2.), 0., 1000.);\n    \n    //t = 1. - t;\n    float scale =  1.;0.5; // / numPoints;\n    float cut = 200.;\n    float slowness = 20.;\n    scale = iTime < cut ? 1. : (iTime > cut + slowness * 0.9 ? 0. : 1. - (1. / slowness * (iTime - cut)));\n\tfloat asp = iResolution.x/iResolution.y;\n    \n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / (iResolution.y * scale);\n\t//uv.y = abs(uv.y);\n    \n    uv = abs(uv);\n    uv += vec2(0.2 * sin(t / 3.), 0.3 * cos(t / 7.));\n    \n    uv = rotate(uv, iTime * 0.5);\n    // if (nmouse().x >= 0.5) uv = abs(uv);\n    \n    vec2 friz = vec2(100. * sin(t * uv.x), 100. * cos(t * uv.y));\n    vec2 vel = vec2(1., 100.);\n    \n    //uv *= vec2(om(sin(friz.x * cos(vel.x * t) * uv.x) / 7.), om(cos(friz.y * sin(vel.y * t) * uv.y) / 11.)); \n    \n    // col = crimson;\n    \n    float mind = 100.;\n    float ci;\n    \n    // generate a bunch of random points\n    for (float i = 0.; i < numPoints; i++) {\n    \tvec2 n = r22(vec2(i));\n        // sin of both components varied with time\n        vec2 p = sin(n * t);\n        // get distance to point\n        float d = minkd(uv, p, (nsin(t / 12.) * 2.1) + 0.2);\n        //m += smoothstep(.05, .01, d);\n        if (d < mind) {\n        \tmind = d;\n            ci = i;\n        }\n    }\n    \n    col = invert(vec3(mind));\n    col.b -= nsin(3. * t + length(20. * uv));\n    col.r += 0.5 * smoothstep(0., 1., col.g + col.b);\n    col.g *= nsin(t / 11. * length(uv * 12.));\n    \n    if (rgb2hcv(col).z < 0.01) col = 0.5 * cos(0.5 * t + uv.xyx / 6. + vec3(14.6, 3.8, 5.1));\n    \n    \n    fragColor = vec4(col, 1.);\n}\n\n//col = vec3(m, nsin(length(uv)), ncos(t));\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyDm.jpg", "access": "api", "license": "mit", "functions": [[2033, 2033, 2058, 2058, 2216], [2218, 2282, 2306, 2359, 2642], [2644, 2679, 2703, 2703, 2823], [2825, 2860, 2884, 2884, 3036], [3124, 3124, 3143, 3143, 3172], [3174, 3174, 3206, 3206, 3253], [3255, 3255, 3283, 3283, 3348], [3350, 3350, 3382, 3382, 3423], [3425, 3425, 3444, 3444, 3462], [3464, 3464, 3481, 3481, 3499], [3501, 3501, 3520, 3520, 3538], [3540, 3540, 3561, 3561, 3589], [3591, 3591, 3612, 3612, 3640], [3642, 3642, 3664, 3664, 3698], [3700, 3700, 3731, 3731, 3803], [3805, 3805, 3846, 3846, 3885], [3887, 3887, 3902, 3902, 3940], [3942, 3942, 3965, 3965, 4004], [4006, 4006, 4027, 4027, 4063], [4065, 4065, 4107, 4137, 4289], [4336, 4414, 4432, 4432, 4561], [4564, 4564, 4582, 4582, 4697], [4699, 4699, 4788, 5024, 5570], [5572, 5572, 5629, 5629, 7316]], "test": "untested"}
{"id": "tdycWm", "name": "math - simple triangle", "author": "catafest", "description": "a simple triangle shape", "tags": ["simple", "math", "triangle"], "likes": 1, "viewed": 564, "published": 3, "date": "1602970491", "time_retrieved": "2024-07-30T20:39:49.000537", "image_code": "// define a triangle function\nfloat triangle(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// define a vector position from iResolution\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y+0.7;\n    //define the triangle\n\tfloat triangle001 = triangle( p, 1.5, 1.5 );\n\t// fill the triangle, need to change col = mix ...\n    //vec3 col = vec3(1.0) - sign(triangle001);\n\t// radiation effect from smooth\n    float ray = 0.01;\n    // draw triangle\n\tvec3 col = mix(  vec3(0.0), vec3(1.0), 1.0-smoothstep(0.0,ray,abs(triangle001)));\n    // draw to output screen\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdycWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 81, 81, 190], [192, 192, 249, 295, 748]], "test": "untested"}
{"id": "wdGcDw", "name": "Cellularism Automatable Techique", "author": "UrbanClubProfessional", "description": "Remix of \"Cellular Automata Technicol (459\" by FabriceNeyret2", "tags": ["remix", "glitch", "automata", "cellular", "weird", "short", "technicolor", "golf", "unique"], "likes": 2, "viewed": 353, "published": 3, "date": "1602962885", "time_retrieved": "2024-07-30T20:39:49.761503", "image_code": "// simplified from https://shadertoy.com/view/tlKSWD (1823 chars)\nvoid mainImage(out vec4 o, vec2 u) { mi(o,u); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 o, vec2 u) { mi(o,u); }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define L(t) L[ ( t + iFrame / int(max(R.x,R.y)) ) % L.length() ]                  //\n#define V(s) int( texelFetch(iChannel0, ivec2( C+R -D + s vec2(-D.y,D) ),0).a > 0.)//\nint[] L = int[]( 22, 30, 45, 54, 57, 60, 62, 73, 75, 86, 89, 110);                 //\n#define mi(O,U)                                  \\\n    vec2  R = iResolution.xy/2., D = O.wx,              \\\n          C = U-R, A = abs(C);                          \\\n    int   r =   C.x >  A.y ?           L( )             \\\n              : C.y >  A.x ? D = D.yx, L(2)             \\\n              : C.x < -A.y ? D =-D,    L(3)             \\\n              :            ( D =-D.yx, L(4) ),          \\\n          k = V(-) *5 + V(0.*) *3 + V();                \\\n    float l = length( C -= 5.*D ),                      \\\n          d = dot(C,D);                                 \\\n    O =   d*d < 1.  ? vec4( l > 1.)                     \\\n        : d/l < .607 || (r >> k) % 2 < 1 ? O-O          \\\n        : .7 + .7 * cos( .78*vec4(k)  + vec4(0,23,21,0) )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 102, 102, 113]], "test": "untested"}
{"id": "tdyyDw", "name": "Cellular Automata Neon Color", "author": "UrbanClubProfessional", "description": "Remix of \"Cellular Automata in Technicolor\" by mla.", "tags": ["color", "remix", "glitch", "automata", "cellular", "weird", "neon", "technicolor", "unique"], "likes": 6, "viewed": 375, "published": 3, "date": "1602961728", "time_retrieved": "2024-07-30T20:39:50.516484", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 118]], "test": "untested"}
{"id": "wsyyWw", "name": "Rounded Box - intersection (Fix)", "author": "xjorma", "description": "Modified https://www.shadertoy.com/view/WlSXRW to support bigger radius.\nI will use it in an upcoming shader.\nI wanted to have a cube to morph in a sphere in raytracing, I wasn't able to it with the unmodified code :(\nYou can use the mouse to compare.", "tags": ["3d", "intersection", "fixed", "roundedcube"], "likes": 8, "viewed": 495, "published": 3, "date": "1602954440", "time_retrieved": "2024-07-30T20:39:51.447993", "image_code": "//Little Modification by David Gallardo / Xjorma 2020   (MIT License)\n\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersection of a ray with a rounded box, testing a single\n// corner (sphere) instead of 8, and only 3 edges (cylinders)\n// instead of 12. There might be a more compact and efficient\n// way to do it, but this is where I landed. However the code\n// to compute the surface normal is particularly elegant.\n//\n// It only works if the corner spheres don't overlap, ie, if\n// the raius is smaller than half the size of the base box.\n\n// Other intersectors: https://iquilezles.org/articles/intersectors\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n// Hexagonal Prism: https://www.shadertoy.com/view/tljBWy\n\n\n#define AA 2  // reduce this to 1 if you have a slow machine\n\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.;\n}\n\n// intersect a ray with a rounded box\n// https://iquilezles.org/articles/intersectors\n// Modified to support bigger radius, probably more optimal solution, but was too lazy nor as good as IQ :(\n// I kept the -1 for no collision paradigm even if I hate it (Make the code more complex), but I prefered to stay compatible with IQ interface.\nfloat roundedboxIntersect2( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    \n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n  \n  \t// fat edges\n    float d;\n    d = capIntersect(ro, rd, size * vec3(-1, 1, 1), size, rad);\n    t = d > 0. ? d : 1e20;\n    d = capIntersect(ro, rd, size * vec3( 1,-1, 1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n    d = capIntersect(ro, rd, size * vec3( 1, 1,-1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n\n\n// intersect a ray with a rounded box\n// https://iquilezles.org/articles/intersectors\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n\n    // some precomputation\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n\tvec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    t = 1e20;        \n\n    // corner\n    {\n    float b = od.x + od.y + od.z;\n\tfloat c = oo.x + oo.y + oo.z - ra2;\n\tfloat h = b*b - c;\n\tif( h>0.0 ) t = -b-sqrt(h);\n    }\n\n    // edge X\n    {\n\tfloat a = dd.y + dd.z;\n\tfloat b = od.y + od.z;\n\tfloat c = oo.y + oo.z - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;\n    }\n\t}\n    // edge Y\n    {\n\tfloat a = dd.z + dd.x;\n\tfloat b = od.z + od.x;\n\tfloat c = oo.z + oo.x - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;\n    }\n\t}\n    // edge Z\n    {\n\tfloat a = dd.x + dd.y;\n\tfloat b = od.x + od.y;\n\tfloat c = oo.x + oo.y - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;\n    }\n\t}\n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\n\n//======================================================\n\n\n\n\n// rotation matrix\nmat4 rotate( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\n// transform points and vectors\nvec3 ptransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,1.0)).xyz; }\nvec3 ntransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,0.0)).xyz; }\n\n// texture sampling\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = n*n; m=m*m; m=m*m;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n//======================================================\n\n// putting these in a \"box\" struct leads to precision problems\n// on Android... :(\nmat4  box_world_to_obj;\nmat4  box_obj_to_world;\nvec3  box_size;\nfloat box_radius;\nbool  side;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n        float t = (-1.0-ro.y)/rd.y;\n        if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    // rounded box\n    {\n        // convert ray from world to box space\n        vec3 rdd = ntransform(box_world_to_obj, rd );\n        vec3 roo = ptransform(box_world_to_obj, ro );\n        // intersect in box space\n        float t;\n        if(side)\n        {\n        \tt = roundedboxIntersect(roo,rdd,box_size,box_radius);\n        }\n        else\n        {\n        \tt = roundedboxIntersect2(roo,rdd,box_size,box_radius);\n        }\n        if( t>0.0 && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an = 0.15*(iTime-10.0);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 2.0*cos(an), 0.2, 2.0*sin(an) );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.6,8.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n\n    // rounded box animation\n    box_obj_to_world = \n                       rotate( normalize(vec3(1.0,1.0,0.1)), iTime ); \n    box_world_to_obj = inverse( box_obj_to_world );\n    box_size = vec3((-cos(iTime) + 1.) * 0.5) * 0.75;\n    box_radius = (cos(iTime) + 1.) * 0.5 *.75;\n    side = fragCoord.x < iMouse.x;\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n    \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n        // sky\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n\n        // raymarch geometry\n        vec2 tm = intersect( ro, rd );\n        if( tm.y>0.0 )\n        {\n            // shading\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor;\n            vec3 mate;\n            \n            if( tm.y<1.5 ) // floor\n            {\n                nor = vec3(0.0,1.0,0.0);\n                mate = 0.35*texture( iChannel0, 0.2*pos.xz ).xyz;\n            }\n            else // rounded box\n            {\n                // convert position from world to box space\n                vec3 bpos = ptransform(box_world_to_obj,pos);\n                // compute normal in box space\n                vec3 bnor = roundedboxNormal(bpos,box_size,box_radius);\n                // convert normal from box to world space\n                nor = ntransform(box_obj_to_world,bnor);\n                // sample texture\n                mate = 0.35*boxmap( iChannel0, bpos, bnor ).xyz;\n            }\n            \n            // lighting\n            vec3  lig = normalize(vec3(0.8,0.4,-0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = step( intersect( pos+0.01*nor, lig ).y, 0.0 );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 4.0*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 2.0*vec3(0.20,0.30,0.40)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n\t\t\tcol *= mate;            \n            col += 0.3*pow(spe,8.0)*dif*sha*(0.04+0.96*pow(clamp(dot(lig,hal),0.0,1.0),5.0));\n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n        \n        // vignetting        \n        col *= 1.0 - 0.1*dot(p,p);\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma\n    tot = pow( tot, vec3(0.45) );\n    \n\t// grading\n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n    \n    tot = mix(tot, vec3(1,0,0),max(0.,1. - abs(iMouse.x - fragCoord.x) / 2.));\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyWw.jpg", "access": "api", "license": "mit", "functions": [[2528, 2596, 2678, 2678, 3408], [3410, 3748, 3830, 3852, 4734], [4738, 4824, 4905, 4922, 6474], [6476, 6503, 6568, 6568, 6625], [6689, 6708, 6744, 6744, 7148], [7150, 7182, 7225, 7225, 7257], [7258, 7258, 7301, 7301, 7333], [7335, 7355, 7407, 7407, 7584], [7822, 7822, 7864, 7864, 8509]], "test": "untested"}
{"id": "3sGyWw", "name": "Shroud - 4k by Deliberate", "author": "sndels", "description": "Released at Assembly Online 2020\n\nhttps://www.pouet.net/prod.php?which=87088\nhttps://soundcloud.com/harppi/shroud-4kb-intro-soundtrack\n\nI hope someone finds this interesting/helpful as much of it has been thanks to others sharing their magic!", "tags": ["4k", "volumetric", "fog", "monochrome", "ambient"], "likes": 5, "viewed": 592, "published": 3, "date": "1602946172", "time_retrieved": "2024-07-30T20:39:52.398452", "image_code": "/*\n * Shroud - 4k intro by Deliberate\n * Assembly Online 2020\n * \n * code, graphics - sndels\n *          music - Harppi\n *\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24147, "src": "https://soundcloud.com/harppi/shroud-4kb-intro-soundtrack", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// From iq\n// Not free of artifacts but usually good enough\nfloat SEED; // initialized in main\nfloat rnd() { return fract(sin(SEED++) * 43758.5453123); }\n\n// ---------------------------------- hg_sdf -----------------------------------\n// http://mercury.sexy/hg_sdf/\n\n// Utils\nfloat PI = 3.14159265;\n\n#define sat(x) clamp(x, 0., 1.)\n\nfloat sgn(float x) { return (x < 0.) ? -1. : 1.; }\n\n// Maximum/minumum elements of a vector\n\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\n\n// Geometry\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Space ops\n\nvoid pR(inout vec2 p, float a) { p = cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from\n// the origin.\nfloat pMirror(inout float p, float dist)\n{\n    float s = sgn(p);\n    p = abs(p) - dist;\n    return s;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n    float angle = 2. * PI / repetitions;\n    float a = atan(p.y, p.x) + angle / 2.;\n    float r = length(p);\n    float c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x\n    // direction (cell index would be e.g. -5 and 5 in the two halves of the\n    // cell):\n    if (abs(c) >= (repetitions / 2.))\n        c = abs(c);\n    return c;\n}\n\n// --------------------------------- GLOBALS ---------------------------------\n\n// Sync idea from KK (https://www.shadertoy.com/view/3ddGzn)\n// clang-format off\n// $000X Camera    - 1 global pan in, 2 diag outside, 4 diag inside, 8 scene pan in\n// $00X0 Light/Mat - 1 -Z, 2 inside diagonal, 4 mirror, 8 ending time hack\n// $0X00 Fade      - 0 black, 3 fade in, 5 fade out, 7 full color\n// $X000 Modifiers - 1 camera, 2 geometry0, 4 geometry1, 8 pre-ending time hack\n// clang-format on\n\n// clang-format off\nivec2 SCENES[] = ivec2[](\n    // Duration (beats), Control\n    ivec2(21,  0x0311),\n    ivec2(11,  0x0711),\n    ivec2(32,  0x0722),\n    ivec2(32,  0x0711),\n    ivec2(16,  0x0714),\n    ivec2(16,  0x1714),\n    ivec2(16,  0x2714),\n    ivec2(16,  0x3714),\n    ivec2(32,  0x6758),\n    ivec2(16,  0x6754),\n    ivec2(16,  0xE7F8),\n    ivec2(16,  0xE768),\n    ivec2(14,  0x47E2),\n    ivec2(1,   0x45E2),\n    ivec2(42, 0x0000)\n);\n// clang-format on\n\nfloat TIME_S;\nint SEQ_CODE;\nfloat SCENE_PROGRESS;\nfloat cb(int n) { return float((SEQ_CODE >> n) & 1); }\n\n// Marching\nfloat MIN_DIST = .001;\nfloat MAX_DIST = 256.;\nint MAX_STEPS = 256;\n\n// Light\nvec3 SPOT_O;\nvec3 SPOT_D;\nfloat SPOT_L = 200000.;\nfloat SPOT_CUTOFF_INNER;\nfloat SPOT_CUTOFF_OUTER;\nfloat SPOT_FALLOFF = 1.;\n\n// Fog\nfloat FOG_DENSITY = .1;\nint FOG_SAMPLES = 40;\nfloat FOG_ANISOTROPY;\nfloat FOG_DEPTH;\n\n// -------------------------------- GEOMETRY ---------------------------------\nfloat scene(vec3 p)\n{\n    vec3 rot =\n        vec3(2.140, 2.512, .753)\n      + cb(13) * vec3(8.22, 16.63, 1.5 + TIME_S * .138) // Anim 1\n      + cb(14) * vec3(0, .07, 0) * TIME_S               // Anim 2\n        ;\n\n    pModPolar(p.xy, 6.);\n    pMirror(p.y, 2.);\n    pMirror(p.x, 2.);\n    pMirror(p.z, 2.);\n    pMirror(p.x, 0.);\n    pMirror(p.y, 0.);\n    pR(p.xz, rot.x);\n    pR(p.yz, rot.y);\n    pR(p.xy, rot.z);\n    pMirror(p.y, 2.);\n    pMirror(p.x, 2.);\n    pMirror(p.z, 2.);\n    pModPolar(p.xy, 9.);\n    p -= vec3(1.634, .017, .510);\n    return fBox(p, vec3(.735, 1.446, .541));\n}\n\n// -------------------------------- MARCHING ---------------------------------\n\n// Naive sphere tracing\n// See https://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n// for details and potentially useful extensions\nfloat march(vec3 ro, vec3 rd, float tMax)\n{\n    float t = MIN_DIST;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float h = scene(ro + rd * t);\n        if (h < MIN_DIST || h > tMax)\n            break;\n        t += h;\n    }\n    if (t > tMax)\n        t = 1e38; // WebGL doesn't like the divide-by-zero INF-trick\n        // t = 1. / 0.; // INF\n    return t;\n}\n\n// From iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        scene(vec3(p + e.xyy)) - scene(vec3(p - e.xyy)),\n        scene(vec3(p + e.yxy)) - scene(vec3(p - e.yxy)),\n        scene(vec3(p + e.yyx)) - scene(vec3(p - e.yyx))));\n}\n\n// ---------------------------------- LIGHT ----------------------------------\n\n// Adapted from iq\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 p, vec3 l, float tMax, float k)\n{\n    float ret = 1.;\n    float ph = 1e20;\n    for (float t = 0.; t < tMax;) {\n        // Fudge around volume artifacts near small objects\n        float h = scene(p + l * t) + (rnd() - 0.4) / 10.;\n        if (h < .01)\n            return .0;\n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        ret = min(ret, k * d / max(0., t - y));\n        ph = y;\n        t += h;\n    }\n    return ret;\n}\n\nfloat evalSpot(vec3 p)\n{\n    vec3 l = SPOT_O - p;\n    float spot_dist = length(l);\n    l /= spot_dist;\n\n    // Check if we are occluded\n    float light_amount = shadow(p, l, spot_dist, 3.);\n\n    // Check if point is within cone\n    float theta = dot(l, -SPOT_D);\n    float L = 0.;\n    if (theta > SPOT_CUTOFF_INNER) {\n        // Do the radial attenuation\n        float epsilon = SPOT_CUTOFF_INNER - SPOT_CUTOFF_OUTER;\n        float i = sat(1. - (theta - SPOT_CUTOFF_OUTER) / epsilon);\n        L = SPOT_L * i / (spot_dist * spot_dist * SPOT_FALLOFF);\n    }\n\n    // Our volume absorbs light before it hits the sample location\n    // henyeyGreenstein is applied uniformly with the step_color-fudge\n    float transmittance = exp(-FOG_DENSITY * spot_dist);\n    // No dot(n, l) since we don't have a reference surface\n    return light_amount * transmittance * L;\n}\n\n// --------------------------------- VOLUME ----------------------------------\n\n// Hey look: a real phase function :D\n// http://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html#\n// Enables anisotropic scattering on the forward/backward axis\n// (anisotropy range [-1,1])\n// Wide shots lean on forward scattering and closeups use more backward scattering.\nfloat henyeyGreenstein(vec3 l, vec3 v)\n{\n    float cos_theta = dot(l, -v);\n    return 1. / (PI * 4.) * (1. - FOG_ANISOTROPY * FOG_ANISOTROPY) /\n        pow(1. + FOG_ANISOTROPY * FOG_ANISOTROPY -\n                2. * FOG_ANISOTROPY * cos_theta,\n            3. / 2.);\n}\n\n// Volume rendering\n// Let's fudge around the real theory\n// http://www.pbr-book.org/3ed-2018/Volume_Scattering/Volume_Scattering_Processes.html#Out-ScatteringandAttenuation\nfloat volume(float t, vec3 ray_o, vec3 ray_d, float t_refl, vec3 refl_d)\n{\n    // Uniform sampling on depth range\n    float step_size = FOG_DEPTH / float(FOG_SAMPLES);\n    // Offset uniform samples to get better coverage\n    float frame_offset = step_size * rnd();\n    // Beer's law\n    // Transmittance is multiplicative so we can do this iteratively\n    float step_transmittance = exp(-FOG_DENSITY * step_size);\n    // This is not strictly correct when sampling a spotlight close to\n    // the scene but it's faster than evaluating per step\n\t// Idea sparked by loicvdb's cool gi path tracing\n\t// https://www.shadertoy.com/view/Wt3XRX\n    float step_color =\n        (1. - step_transmittance) * henyeyGreenstein(-SPOT_D, -ray_d);\n\n    float transmittance = 1.;\n    float I = 0.;\n    for (int i = 0; i < FOG_SAMPLES; ++i) {\n        float s = float(i) * step_size + frame_offset;\n        // Break on final hit\n        if (s > t && s - t > t_refl)\n            break;\n\n        // Check if we should sample on the reflection ray\n        vec3 p =\n            s > t ? (ray_o + ray_d * t) + refl_d * (s - t) : ray_o + ray_d * s;\n\n        transmittance *= step_transmittance;\n        I += step_color * transmittance * evalSpot(p);\n    }\n    return I;\n}\n\n// --------------------------------- SETUP ----------------------------------\n\nvoid initGlobals()\n{\n    // Sequencing, adapted from KK (https://www.shadertoy.com/view/3ddGzn)\n    int scene_i = 0;\n    TIME_S = iTime;\n    // Track is 140 bpm so time * 140 bpm / 60s gives bps\n    float scene_beats = TIME_S * 14. / 6.;\n    while (SCENES[scene_i].x < 255 && scene_beats >= float(SCENES[scene_i].x))\n        scene_beats -= float(SCENES[scene_i++].x);\n    SCENE_PROGRESS = sat(scene_beats / float(SCENES[scene_i].x));\n    SEQ_CODE = SCENES[scene_i].y;\n\n    // This is a dirty hack for scene time offsets\n    TIME_S -=\n        cb(15) * (scene_beats * .3 + .01)    // long flower diamond-thingy scene\n      - cb(7) * (1.2 - (TIME_S - 109.) / 2.) // ending scene\n        ;\n\n    // Globals animation\n    SPOT_O =\n        cb(4) * vec3(0, 0, 15)      // -Z\n      + cb(5) * vec3(1, -1, 1) / 2. // Inside\n        ;\n    SPOT_D = normalize(-SPOT_O);\n    SPOT_CUTOFF_INNER =\n        .96        // default\n      - cb(5) * 1. // Inside\n        ;\n    SPOT_CUTOFF_OUTER = 1.2;\n\n    FOG_DEPTH =\n        cb(4) * 30. // Light -Z\n      + cb(5) * 14. // Light inside\n      - cb(2) * 15. // Camera inside\n        ;\n    FOG_ANISOTROPY =\n        .7          // default\n      - cb(5) * 1.2 // Light inside\n        ;\n\n    // Can't remember where this is from, sorry about that :(\n    SEED = gl_FragCoord.y * gl_FragCoord.x / iResolution.x +\n           gl_FragCoord.y / iResolution.y + TIME_S;\n}\n\nvoid camRay(vec2 uv, inout vec3 ray_o, inout vec3 ray_d)\n{\n    ray_o =\n        cb(0) * vec3(0, 0, -22.5 + sin(TIME_S / 30.) * 12.) // Global z pan\n      + cb(1) * vec3(\n          vec2(-11., 4.) + vec2(2, 3) * mod(TIME_S, 100.) / 40.,\n          -6.)                                             // Close outside dutch\n      + cb(2) * vec3(-4.3, .4, -4.2 + SCENE_PROGRESS)      // Inside dutch\n      + cb(3) * vec3(0, 0, -40. + TIME_S / 4.)             // Scene z pan\n      + cb(12) * vec3(7.7 - SCENE_PROGRESS * 2., .75, -.7) // \"Modified camera\"\n        ;\n\n    uv -= .5;                                      // origin at center\n    uv /= vec2(iResolution.y / iResolution.x, 1.); // fix aspect ratio\n    ray_d = normalize(vec3(uv, .7));               // pull ray\n\n    vec3 camRot =\n        cb(2) * vec3(8. + SCENE_PROGRESS * 2., 1.7 + SCENE_PROGRESS, -4.)\n        / 10.                          // Inside dutch\n      + cb(12) * vec3(-1.2, -.52, .25) // \"Modified camera\"\n        ;\n    pR(ray_d.yz, camRot.y);\n    pR(ray_d.xz, camRot.x);\n    pR(ray_d.yx, camRot.z);\n}\n\nvoid tonemap(inout float color)\n{\n    // Rough ACES tonemap\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    color =\n        sat((color * (2.51 * color + .03)) /\n            (color * (2.43 * color + .59) + .14));\n\n    // The volume is noisy so let's do things grayscale and grain things up\n    // to lean on the whole \"artsy\" noir/vintage look\n    float brightness = max(color, .001);\n    float grain = sat(pow(rnd(), 8.) / 100.);\n    color = mix(sat(color - grain), sat(color + grain), exp(brightness));\n    grain = sat(pow(rnd(), 8.) * .15);\n    color -= grain * brightness;\n\n    // Gamma correction, of course\n    color = pow(color, .45);\n}\n\n// ---------------------------------- MAIN -----------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float color = 0.;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // \"21:9\" from 16:9\n    if (abs(uv.y - .5) < .38) {\n        initGlobals();\n\n        vec3 ray_o, ray_d;\n        camRay(uv, ray_o, ray_d);\n\n        // Trace them spheres\n        float t = march(ray_o, ray_d, MAX_DIST);\n\n        // Single bounce reflections\n        float t_refl = 0.;\n        // No need to init direction as volume won't read this when t_refl is 0\n        vec3 refl_d;\n        if (t < MAX_DIST) {\n            // Get hit parameters\n            vec3 p = ray_o + ray_d * t;\n            vec3 n = normal(p);\n\n            // Mirror scene check\n            if (cb(6) == 1.) {\n                refl_d = reflect(ray_d, n);\n                t_refl = march(p + n / 100., refl_d, MAX_DIST - t);\n            }\n        }\n\n        // Do the scattering, which is our only source of color as material is\n        // either super-duper black or a perfect mirror\n        color = volume(t, ray_o, ray_d, t_refl, refl_d);\n\n        // Tonemap before fade to get linear fade\n        tonemap(color);\n\n        // Fade in/out\n        color = mix(cb(10) * color, cb(9) * color, SCENE_PROGRESS);\n        // Black/color\n        color = cb(8) * color;\n    }\n\n    fragColor = vec4(vec3(color), 1.);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Ad-hoc \"AA\" kernel\n    // Looks kind of ok but this really is just a 2d hat function\n    fragColor = vec4(0);\n    for (int j = -1; j <= 1; ++j) {\n        for (int i = -1; i <= 1; ++i) {\n            // Clamp needed here since iChannel is f32 instead of u8\n            fragColor +=\n                max(texture(\n                    iChannel0, (fragCoord.xy + vec2(i, j)) /\n                                       iResolution.xy), vec4(0)) *\n                (4. - length(vec2(i, j)));\n        }\n    }\n    fragColor /= 28.;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 183, 183, 265]], "test": "untested"}
{"id": "WdGyDm", "name": "Rounded rectangle test", "author": "inf1425", "description": "draws a simple rounded rectangle", "tags": ["gui"], "likes": 2, "viewed": 402, "published": 3, "date": "1602944707", "time_retrieved": "2024-07-30T20:39:53.153433", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float roundness = 0.1; //edit this to change roundness\n    \n    vec2 temp = abs((uv - vec2(0.5)) * vec2(2.0));\n    if(temp.x > 1.0 - roundness && temp.y > 1.0 - roundness) {\n        if(distance(vec2(1.0 - roundness), temp) > roundness) {\n            fragColor = vec4(0.0);\n            return;\n        }\n    }\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 515]], "test": "untested"}
{"id": "3sGyDw", "name": "Person Apex Website Lattices", "author": "UrbanClubProfessional", "description": "Remix of \"Perspex Web Lattice\" by Shane", "tags": ["voronoi", "raymarch", "color", "remix", "glitch", "rainbow", "weird", "lattice", "web"], "likes": 10, "viewed": 795, "published": 3, "date": "1602929583", "time_retrieved": "2024-07-30T20:39:54.087935", "image_code": "/*\n\tPerspex Web Lattice\n\t-------------------\n\t\n\tI felt that Shadertoy didn't have enough Voronoi examples, so I made another one. :) I'm\n\tnot exactly sure what it's supposed to be... My best guess is that an Alien race with no \n\tcommon sense designed a monitor system with physics defying materials. :)\n\n\tTechnically speaking, there's not much to it. It's just some raymarched 2nd order Voronoi.\n\tThe dark perspex-looking web lattice is created by manipulating the Voronoi value slightly \n\tand giving the effected region an ID value so as to color it differently, but that's about\n\tit. The details are contained in the \"heightMap\" function.\n\n\tThere's also some subtle edge detection in order to give the example a slight comic look. \n\t3D geometric edge detection doesn't really differ a great deal in concept from 2D pixel \n\tedge detection, but it obviously involves more processing power. However, it's possible to \n\tcombine the edge detection with the normal calculation and virtually get it for free. Kali \n\tuses it to great effect in his \"Fractal Land\" example. It's also possible to do a\n\ttetrahedral version... I think Nimitz and some others may have done it already. Anyway, \n\tyou can see how it's done in the \"nr\" (normal) function.\n\n\tGeometric edge related examples:\n\n\tFractal Land - Kali\n\thttps://www.shadertoy.com/view/XsBXWt\n\n\tRotating Cubes - Shau\n\thttps://www.shadertoy.com/view/4sGSRc\n\n\tVoronoi mesh related:\n\n    // I haven't really looked into this, but it's interesting.\n\tWeaved Voronoi - FabriceNeyret2 \n    https://www.shadertoy.com/view/ltsXRM\n\n*/\n\n#define FAR 2.\n\nint id = 0; // Object ID - Red perspex: 0; Black lattice: 1.\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .3), .002);\n    n /= (n.x + n.y + n.z ); // Roughly normalized.\n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    // Loose sRGB to RGB conversion to counter final value gamma correction...\n    // in case you're wondering.\n    return p*p;\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(8, 257, 213);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(4. - 3.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*53758.5453), fract(sin(h + s.x)*53758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(31, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(362144, 42768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*7.2831853 + iTime )*.55 + .6; \n    \n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(2); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -2; y <= 2; y++){\n\t\tfor(int x = -2; x <= 2; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o); \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n    return max(d.y/0.6 - d.x*0.5, 0.)/2.2;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\n// The height map values. In this case, it's just a Voronoi variation. By the way, I could\n// optimize this a lot further, but it's not a particularly taxing distance function, so\n// I've left it in a more readable state.\nfloat heightMap(vec3 p){\n    \n    id =0;\n    float c = Voronoi(p.xy*5.); // The fiery bit.\n    \n    // For lower values, reverse the surface direction, smooth, then\n    // give it an ID value of one. Ie: this is the black web-like\n    // portion of the surface.\n    if (c<.08) {c = smoothstep(0.8, 2., 2.-c)*.3; id = 2; }\n\n    return c;\n}\n\n// Standard back plane height map. Put the plane at vec3(0, 0, 1), then add some height values.\n// Obviously, you don't want the values to be too large. The one's here account for about 10%\n// of the distance between the plane and the camera.\nfloat m(vec3 p){\n   \n    float h = heightMap(p); // texture(iChannel0, p.xy/2.).x; // Texture work too.\n    \n    return 1. - p.z - h*.2;\n    \n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 nr(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * m(p + e.xyy) + e.yyx * m(p + e.yyx) + e.yxy * m(p + e.yxy) + e.xxx * m(p + e.xxx));\n}\n*/\n\n/*\n// Standard normal function - for comparison with the one below.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.006, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\tfloat d3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\tfloat d5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\tfloat d = m(p)*3.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 2., sqrt(edge/e.x*3.));\n\t\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n/*\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = m(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n*/\n\n/*\n// Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n*/\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.35;\n    rd *= 4.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.67 + n3D(rd*3.)*.38 + n3D(rd*5.)*.25; // Noise value.\n    c = smoothstep(0.6, 2., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*2.5, 2.), pow(c, 3.5), pow(c, 22.)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*7.35+.35); \n    \n}\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    // Unit direction ray, camera origin and light position.\n    vec3 r = normalize(vec3(u - iResolution.xy*.6, iResolution.y)), \n         o = vec3(0), l = o + vec3(0, 0, -2);\n   \n    // Rotate the canvas. Note that sine and cosine are kind of rolled into one.\n    vec2 a = sin(vec2(2.570796, 0) + iTime/9.); // Fabrice's observation.\n    r.xy = mat2(a, -a.y, a.x) * r.xy;\n\n    \n    // Standard raymarching routine. Raymarching a slightly perturbed back plane front-on\n    // doesn't usually require many iterations. Unless you rely on your GPU for warmth,\n    // this is a good thing. :)\n    float d, t = 0.;\n    \n    for(int i=0; i<42;i++){\n        \n        d = m(o + r*t);\n        // There isn't really a far plane to go beyond, but it's there anyway.\n        if(abs(d)<0.002 || t>FAR) break;\n        t += d*.8;\n\n    }\n    \n    t = min(t, FAR);\n    \n    // Set the initial scene color to black.\n    c = vec4(0);\n    \n    float edge = 0.; // Edge value - to be passed into the normal.\n    \n    if(t<FAR){\n    \n        vec3 p = o + r*t, n = nr(p, edge);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.002); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n \n        // Obtain the height map (destorted Voronoi) value, and use it to slightly\n        // shade the surface. Gives a more shadowy appearance.\n        float hm = heightMap(p);\n        \n        // Texture value at the surface. Use the heighmap value above to distort the\n        // texture a bit.\n        vec3 tx = tex3D(iChannel0, (p*3. + hm*.3), n);\n        //tx = floor(tx*15.999)/15.; // Quantized cartoony colors, if you get bored enough.\n\n        c.xyz = vec3(2.)*(hm*.09 + .03); // Applying the shading to the final color.\n        \n        c.xyz *= vec3(2.5)*tx; // Multiplying by the texture value and lightening.\n        \n        \n        // Color the cell part with a fiery (I incorrectly spell it firey all the time) \n        // palette and the latticey web thing a very dark color.\n        //\n        c.x = dot(c.xyz, vec3(.399, .687, .214)); // Grayscale.\n        if (id==0) c.xyz *= vec3(min(c.x*2.5, 2.), pow(c.x, 6.), pow(c.x, 34.))*3.;\n        else c.xyz *= .2;\n        \n        // Hue rotation, for anyone who's interested.\n        //c.xyz = rotHue(c.xyz, mod(iTime/16., 6.283));\n       \n        \n        float df = max(dot(l, n), 0.); // Diffuse.\n        float sp = pow(max(dot(reflect(-l, n), -r), 0.), 42.); // Specular.\n        \n        if(id == 1) sp *= sp; // Increase specularity on the dark lattice.\n        \n\t\t// Applying some diffuse and specular lighting to the surface.\n        c.xyz = c.xyz*(df + .85) + vec3(2, 1.97, 1.92)*sp + vec3(.6, .8, 2)*pow(sp, 42.);\n        \n        // Add the fake environmapping. Give the dark surface less reflectivity.\n        vec3 em = eMap(reflect(r, n), n); // Fake environment mapping.\n        if(id == 2) em *= .6;\n        c.xyz += em;\n        \n        // Edges.\n        //if(id == 0)c.xyz += edge*.1; // Lighter edges.\n        c.xyz *= 2. - edge*.9; // Darker edges.\n        \n        // Attenuation, based on light to surface distance.    \n        c.xyz *= 2./(2. + d*d*.225);\n        \n        // AO - The effect is probably too subtle, in this case, so we may as well\n        // save some cycles.\n        //c.xyz *= cAO(p, n);\n        \n    }\n    \n    \n    // Vignette.\n    //vec2 uv = u/iResolution.xy;\n    //c.xyz = mix(c.xyz, vec3(0, 0, .5), .1 -pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)*.1);\n    \n    // Apply some statistically unlikely (but close enough) 2.0 gamma correction. :)\n    c = vec4(sqrt(clamp(c.xyz, 0., 2.)), 2.);\n    \n    \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1649, 1807, 1857, 1857, 2172], [2175, 2318, 2336, 2336, 2682], [2684, 2706, 2727, 3076, 3579], [3581, 3783, 3808, 3808, 4505], [4507, 4729, 4753, 4753, 5067], [5069, 5312, 5328, 5328, 5455], [6054, 6118, 6153, 6153, 7424], [8323, 8700, 8728, 8728, 9453], [9455, 9455, 9490, 9552, 13171]], "test": "untested"}
{"id": "WdGyDw", "name": "Glitchy transformative", "author": "UrbanClubProfessional", "description": "Remix of \"Glitch transform\" by tdhooper", "tags": ["remix", "abstract", "glitch", "blend", "weird", "icosahedron", "polygon", "dodecahedron", "transform", "twist"], "likes": 3, "viewed": 1329, "published": 3, "date": "1602928886", "time_retrieved": "2024-07-30T20:39:55.025428", "image_code": "#define MODEL_ROTATION vec2(0.6, 0.6)\n#define LIGHT_ROTATION vec2(0.4, 0.9)\n#define CAMERA_ROTATION vec2(0.6, 0.77)\n\n// Mouse control\n// 0: Defaults\n// 1: Model\n// 2: Lighting\n// 3: Camera\n#define MOUSE_CONTROL 1\n\n// Debugging\n//#define NORMALS\n//#define NO_GLITCH\n//#define GLITCH_MASK\n\n\nfloat time;\n\nfloat _round(float n) {\n    return floor(n + 0.6);\n}\n\nvec2 _round(vec2 n) {\n    return floor(n + 0.6);\n}\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n#define GDFVector3 normalize(vec3(1, 9, 1 ))\n#define GDFVector4 normalize(vec3(-1, 7, 1))\n#define GDFVector5 normalize(vec3(5, -1, 1))\n#define GDFVector6 normalize(vec3(1, 3, -1))\n\n#define GDFVector7 normalize(vec3(0, 9, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 7))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 5))\n#define GDFVector11 normalize(vec3(3, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 9))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(7, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 5, 0))\n#define GDFVector18 normalize(vec3(-PHI, 3, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// --------------------------------------------------------\n// Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .6) * PI;\n    ry = (-xy.x) * 3. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 lightRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, LIGHT_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==3, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nstruct Material {\n    vec3 albedo;\n};\n\nstruct Model {\n    float dist;\n    Material material;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(.6)\n);  \n\nModel newModel() {\n    return Model(\n        20000.,\n        defaultMaterial\n    );\n}\n\nconst float modelSize = 1.2;\n\nfloat blend(float y, float blend, float progress) {\n    float a = (y / modelSize) + .6;\n    a -= progress * (2. + blend) - blend * .6;\n    a += blend / 3.;\n    a /= blend;\n    a = clamp(a, 0., 2.);\n    a = smoothstep(0., 2., a);\n    a = smoothstep(0., 2., a);\n    return a;\n}\n\nfloat ShapeBlend(float y, float progress) {\n    float shapeProgress = clamp(progress * 3. - .6, 0., 2.);\n    float shapeBlend = blend(y, .9, shapeProgress);\n    return shapeBlend;\n}\n\nfloat SpinBlend(float y, float progress) {\n    return blend(y, 2.5, progress);\n}\n\nfloat Flip() {\n\treturn round(mod(time, 2.));\n}\n\nfloat Progress() {\n    float progress = mod(time*3., 2.);\n    //progress = smoothstep(0., 1., progress);\n    //progress = sin(progress * PI - PI/2.) * .5 + .5;\n    return progress;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n    \n\tfloat progress = Progress();\n    float flip = Flip();\n    \n    float spinBlend = SpinBlend(p.y, progress);\n    pR(p.xz, spinBlend * PI / 3.);\n    pR(p.xz, PI * -.6 * flip);\n    \n    float part1 = fDodecahedron(p, modelSize * .6);\n    pR(p.xz, PI/3.);\n    float part2 = fIcosahedron(p, modelSize * .6);\n    \n\tfloat shapeBlend = ShapeBlend(p.y, progress);\n    shapeBlend = mix(shapeBlend, 2. - shapeBlend, flip);    \n    float d = mix(part1, part2, shapeBlend);\n\n    model.dist = d;\n    model.material.albedo = mix(vec3(.04), vec3(.9), 2. - shapeBlend);\n\n    return model;\n}\n\nModel glitchModel(vec3 p) {\n    Model model = newModel();\n    float progress = Progress();\n\tfloat band = ShapeBlend(p.y, progress);\n    band = sin(band * PI);    \n\n   \tfloat fadeBottom = clamp(2. - dot(p, vec3(0,2,0)), 0., 2.);\n    band *= fadeBottom;\n\n    float radius = modelSize / 3. + band * .3;\n    model.dist = length(p) - radius;\n    model.material.albedo = vec3(band);\n    \n    return model;\n}\n\nModel map( vec3 p , bool glitchMask){\n    mat3 m = modelRotation();\n    p *= m;\n    pR(p.xz, -time*PI);\n    if (glitchMask) {\n    \treturn glitchModel(p);\n    }\n    Model model = mainModel(p);\n    return model;\n}\n\n\n// --------------------------------------------------------\n// LIGHTING\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 2.0;\n    float t = mint;\n    for( int i=0; i<26; i++ )\n    {\n        float h = map( ro + rd*t, false ).dist;\n        res = min( res, 9.0*h/t );\n        t += clamp( h, 0.03, 0.20 );\n        if( h<0.00002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 2.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 2.0;\n    for( int i=0; i<6; i++ )\n    {\n        float hr = 0.02 + 0.22*float(i)/5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, false ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 1.95;\n    }\n    return clamp( 2.0 - 4.0*occ, 0.0, 2.0 );    \n}\n\nvec3 doLighting(Material material, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = vec3(0,0,-2);\n    vec3 backLightPos = normalize(vec3(0,-.4,2));\n    vec3 ambientPos = vec3(0,2,0);\n\n    mat3 m = lightRotation();\n    lightPos *= m;\n    backLightPos *= m;\n        \n    float occ = calcAO( pos, nor );\n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 2.) / 3., 0., 2.);\n    float dif = clamp((dot(nor, lig) + 2.) / 4., 0.0, 2.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 2.), 2.5);\n    float fre = pow( clamp(2.0+dot(nor,rd),0.0,2.0), 2.0 );\n    \n    dif *= softshadow( pos, lig, 0.02, 3.5 ) * .6 + .6;\n\n    vec3 lin = vec3(0.0);\n    lin += 2.20*dif*vec3(1.95,0.90,0.70);\n    lin += 0.90*amb*vec3(0.60,0.80,.90)*occ;\n    lin += 0.40*bac*vec3(0.35,0.35,0.25)*occ;\n    lin += 0.30*fre*vec3(2.00,2.00,2.00)*occ;\n    vec3 col = material.albedo*lin;\n    \n\tfloat spe = clamp(dot(ref, lightPos), 0., 2.);\n    spe = pow(spe, 3.) * .2;\n    col += spe;\n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.; // max trace distance\nconst float INTERSECTION_PRECISION = .002; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\nconst float FUDGE_FACTOR = 0.8; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n    bool glitchMask;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.002, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, false).dist - map(pos-eps.xyy, false).dist,\n        map(pos+eps.yxy, false).dist - map(pos-eps.yxy, false).dist,\n        map(pos+eps.yyx, false).dist - map(pos-eps.yyx, false).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 3.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, castRay.glitchMask);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// Refraction from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 color = vec3(.35);\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    #ifdef NORMALS\n        color = hit.normal * 0.6 + 0.6;\n    #else\n    \tvec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.model.material,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\n\nvec3 render(Hit hit){\n    \n    shadeSurface(hit);\n    \n    if (hit.isBackground) {\n        return hit.color;\n    }\n    \n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 2.;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\nHit raymarchPixel(vec2 p, bool glitchPass) {\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 3.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    float focalLength = 1.;\n    vec3 rd = normalize( camMat * vec3(p.xy, focalLength) );\n    \n    Hit hit = raymarch(CastRay(camPos, rd, glitchPass));\n    \n    return hit;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 3.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 2.0 / GAMMA);\n}\n\n\n// --------------------------------------------------------\n// Glitch core\n// --------------------------------------------------------\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(22.9898,88.233))) * 53758.5453);\n}\n\nconst float glitchScale = .6;\n\nvec2 glitchCoord(vec2 p, vec2 gridSize) {\n\tvec2 coord = floor(p / gridSize) * gridSize;;\n    coord += (gridSize / 3.);\n    return coord;\n}\n\n\nstruct GlitchSeed {\n    vec2 seed;\n    float prob;\n};\n    \nfloat fBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nGlitchSeed glitchSeed(vec2 p, float speed) {\n    float seedTime = floor(time * speed);\n    vec2 seed = vec2(\n        2. + mod(seedTime / 200., 200.),\n        2. + mod(seedTime, 200.)\n    ) / 200.;\n    seed += p;\n    \n    float prob = 0.;\n    Hit hit = raymarchPixel(p, true);\n    if ( ! hit.isBackground) {\n    \tprob = hit.model.material.albedo.x;\n    }\n    \n    return GlitchSeed(seed, prob);\n}\n\nfloat shouldApply(GlitchSeed seed) {\n    return round(\n        mix(\n            mix(rand(seed.seed), 2., seed.prob - .6),\n            0.,\n            (2. - seed.prob) * .6\n        )\n    );\n}\n\n\n// --------------------------------------------------------\n// Glitch effects\n// --------------------------------------------------------\n\n// Swap\n\nvec4 swapCoords(vec2 seed, vec2 groupSize, vec2 subGrid, vec2 blockSize) {\n    vec2 rand2 = vec2(rand(seed), rand(seed+.2));\n    vec2 range = subGrid - (blockSize - 2.);\n    vec2 coord = floor(rand2 * range) / subGrid;\n    vec2 bottomLeft = coord * groupSize;\n    vec2 realBlockSize = (groupSize / subGrid) * blockSize;\n    vec2 topRight = bottomLeft + realBlockSize;\n    topRight -= groupSize / 3.;\n    bottomLeft -= groupSize / 3.;\n    return vec4(bottomLeft, topRight);\n}\n\nfloat isInBlock(vec2 pos, vec4 block) {\n    vec2 a = sign(pos - block.xy);\n    vec2 b = sign(block.zw - pos);\n    return min(sign(a.x + a.y + b.x + b.y - 4.), 0.);\n}\n\nvec2 moveDiff(vec2 pos, vec4 swapA, vec4 swapB) {\n    vec2 diff = swapB.xy - swapA.xy;\n    return diff * isInBlock(pos, swapA);\n}\n\nvoid swapBlocks(inout vec2 xy, vec2 groupSize, vec2 subGrid, vec2 blockSize, vec2 seed, float apply) {\n    \n    vec2 groupOffset = glitchCoord(xy, groupSize);\n    vec2 pos = xy - groupOffset;\n    \n    vec2 seedA = seed * groupOffset;\n    vec2 seedB = seed * (groupOffset + .2);\n    \n    vec4 swapA = swapCoords(seedA, groupSize, subGrid, blockSize);\n    vec4 swapB = swapCoords(seedB, groupSize, subGrid, blockSize);\n    \n    vec2 newPos = pos;\n    newPos += moveDiff(pos, swapA, swapB) * apply;\n    newPos += moveDiff(pos, swapB, swapA) * apply;\n    pos = newPos;\n    \n    xy = pos + groupOffset;\n}\n\n\n// Static\n\nvoid staticNoise(inout vec2 p, vec2 groupSize, float grainSize, float contrast) {\n    GlitchSeed seedA = glitchSeed(glitchCoord(p, groupSize), 6.);\n    seedA.prob *= .6;\n    if (shouldApply(seedA) == 2.) {\n        GlitchSeed seedB = glitchSeed(glitchCoord(p, vec2(grainSize)), 6.);\n        vec2 offset = vec2(rand(seedB.seed), rand(seedB.seed + .2));\n        offset = round(offset * 3. - 2.);\n        offset *= contrast;\n        p += offset;\n    }\n}\n\n\n// Freeze time\n\nvoid freezeTime(vec2 p, inout float time, vec2 groupSize, float speed) {\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    //seed.prob *= .5;\n    if (shouldApply(seed) == 2.) {\n        float frozenTime = floor(time * speed) / speed;\n        time = frozenTime;\n    }\n}\n\n\n// --------------------------------------------------------\n// Glitch compositions\n// --------------------------------------------------------\n\nvoid glitchSwap(inout vec2 p) {\n\n    vec2 pp = p;\n    \n    float scale = glitchScale;\n    float speed = 6.;\n    \n    vec2 groupSize;\n    vec2 subGrid;\n    vec2 blockSize;    \n    GlitchSeed seed;\n    float apply;\n    \n    groupSize = vec2(.7) * scale;\n    subGrid = vec2(3);\n    blockSize = vec2(2);\n\n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n    \n    groupSize = vec2(.9) * scale;\n    subGrid = vec2(4);\n    blockSize = vec2(2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n\n    groupSize = vec2(.2) * scale;\n    subGrid = vec2(7);\n    blockSize = vec2(2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    float apply2 = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 2.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 3.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 4.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 5.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 6.), apply * apply2);\n    \n    groupSize = vec2(2.2, .3) * scale;\n    subGrid = vec2(19,3);\n    blockSize = vec2(4,2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n}\n\n\n\nvoid glitchStatic(inout vec2 p) {\n\n    // Static\n    //staticNoise(p, vec2(.25, .25/2.) * glitchScale, .005, 5.);\n    \n    // 8-bit\n    staticNoise(p, vec2(.6, .35/3.) * glitchScale, .3 * glitchScale, 3.);\n}\n\nvoid glitchTime(vec2 p, inout float time) {\n   freezeTime(p, time, vec2(.6) * glitchScale, 3.);\n}\n\nvoid glitchColor(vec2 p, inout vec3 color) {\n    vec2 groupSize = vec2(.85,.225) * glitchScale;\n    vec2 subGrid = vec2(0,7);\n    float speed = 6.;\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    seed.prob *= .4;\n    if (shouldApply(seed) == 2.) {\n        vec2 co = mod(p, groupSize) / groupSize;\n        co *= subGrid;\n        float a = max(co.x, co.y);\n        //color.rgb *= vec3(\n        //  min(floor(mod(a - 0., 3.)), 1.),\n        //    min(floor(mod(a - 1., 3.)), 1.),\n        //    min(floor(mod(a - 2., 3.)), 1.)\n        //);\n        \n        color *= min(floor(mod(a, 3.)), 2.) * 20.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 4.;\n    time = mod(time, 2.);\n    \n    vec2 p = (-iResolution.xy + 3.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 color;\n    \n    #ifdef GLITCH_MASK\n    \tfloat prob = glitchSeed(p, 20.).prob;\n    \tcolor = vec3(prob);\n   \t#else\n\n        #ifndef NO_GLITCH\n            glitchSwap(p);\n            glitchTime(p, time);\n            glitchStatic(p);\n        #endif\n\n        Hit hit = raymarchPixel(p, false);\n        color = render(hit);\n\n        #ifndef NO_GLITCH\n            glitchColor(p, color);\n        #endif\n    \n        #ifndef NORMALS\n           color = linearToScreen(color);\n        #endif\n\n    #endif\n\n    fragColor = vec4(color,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 325, 325, 354], [356, 356, 377, 377, 406], [668, 668, 688, 688, 726], [728, 966, 998, 998, 1043], [1045, 1119, 1175, 1175, 1220], [1222, 1258, 1286, 1286, 1373]], "test": "untested"}
{"id": "3sycWw", "name": "Fab19 #inktober2020 \"dizzy\"", "author": "FabriceNeyret2", "description": "Sorry for the inconvenience. I didn't choose the #19 word :-p\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "3tweets", "inktober2020"], "likes": 3, "viewed": 287, "published": 3, "date": "1602925361", "time_retrieved": "2024-07-30T20:39:55.783401", "image_code": "#define S(U,n,s) smoothstep(.9,1., cos( n* 6.3*length(U) -atan((U).y,(U).x) +s*t )) //\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime;\n    vec2 R = iResolution.xy,\n         V = (U/R-.5) * mat2(cos(.3*cos(t)+vec4(0,11,33,0)))\n                      * (1.+.2*sin(2.1*t)) + .5\n             +.05* cos(t/.1)+.03* cos(30.*vec2(-t,t));\n    O = texture(iChannel0, V ) -.5;\n    O.rg *=   mat2( cos( 6.3*t  + vec4(0,23,21,0)) );\n    O += .5  + S((U+U-R)/R.y, 2.,3.);\n    O.b += S(V-.5, 3.,-3.);}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 123, 123, 494]], "test": "untested"}
{"id": "tdGyzz", "name": "Fluid Experiment", "author": "laube", "description": "Mouse click generates a vortex. Reset time to reset simulation.\n\nThe fluid has the following properties:\n\n- x, y: Velocity\n- z: Rotation in rad/s\n- w: Density > 0", "tags": ["fluid", "particle"], "likes": 7, "viewed": 640, "published": 3, "date": "1602924035", "time_retrieved": "2024-07-30T20:39:56.827609", "image_code": "#define PARTICLE_COUNT 100\n#define ARROWS 1\n#define ARROW_REPEAT 20.\n#define S(a, b, p) smoothstep(a, b, p)\n\nfloat drawArrow(vec2 a, vec2 b, vec2 p, float w, float h) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float x = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    \n    return max(\n        S(\n            w, \n            0., \n            length(p - (a + x * ba))\n        ),\n        S(w * h, w * (h - 1.), length(p - b))\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    fragColor =  texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.xy = fragColor.xy * 0.5 + .5;\n    //fragColor.xy = vec2(0.);\n    //fragColor.z = fragColor.z * .5 + .5;\n    fragColor.z = fragColor.w;\n    //fragColor.xy = vec2(fragColor.z);\n    \n    for (int particle = 0; particle < PARTICLE_COUNT; particle++) {\n        vec2 particleCoord = floor(hash21(float(particle)) * vec2(20.));\n        vec4 pos = texture(iChannel1, (particleCoord + vec2(0.5)) / iResolution.xy);\n        \n        vec2 delta = fragCoord.xy - pos.xy;\n        delta = mod(delta + iResolution.xy * .5, iResolution.xy) - iResolution.xy * .5;\n        \n        fragColor.xyz = mix(\n            fragColor.xyz,\n            vec3(.4, 1., 1.),\n            clamp(3. / (10. * max(length(delta) - 1., 0.01)), 0., .9)\n        );\n    }\n    \n#if ARROWS\n    vec2 uv = (fragCoord / iResolution.x) * ARROW_REPEAT;\n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    vec4 boxField = texture(iChannel0, (id + vec2(.5)) * iResolution.x / ARROW_REPEAT / iResolution.xy);\n    \n    fragColor.xyz = mix(\n        fragColor.xyz, \n        vec3(.8, .9, 1.),\n        drawArrow(\n            vec2(0.5) - boxField.xy * .5, \n            vec2(0.5) + boxField.xy * .5, \n            //vec2(.2, .2),\n            //vec2(.8, .8),\n            uv,\n            .5 / iResolution.x * ARROW_REPEAT + 0.002 * ARROW_REPEAT,\n            2.\n        ) * .8\n    );\n    \n    //if (uv.y < .01) fragColor.y = 1.;\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Inspiration: https://www.gamasutra.com/view/feature/1549/practical_fluid_dynamics_part_1.php?print=1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    vec4 neighbors[9];\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n    \t\tneighbors[3 * i + j] = texture(iChannel0, (fragCoord + vec2(i - 1, j - 1)) / iResolution.xy);\n        }\n    }\n    */\n    fragColor = vec4(0.);\n    \n    // x = Vx, y = Vy, z = rot, w = density\n    \n    vec4 last = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    if (iFrame == 0) {\n        // Initialize\n        fragColor.xyzw = hash42(floor(fragCoord / 20.)+iMouse.zw);\n        fragColor.xyz = fragColor.xyz * 2. - 1.;\n    } else if (iFrame % 1 == 0) {\n        // Calculate next generation\n        \n        //   -> Vx\n        // |  a----a\n        // v  |    |\n        //    |-b--+-b\n        // Vy | |  | |   X = Vx * Vy\n        //    a-+--a-|\n        //      |  |X|\n        //      b----b\n        \n        //   -> Vx\n        // |  a----a\n        // v  |    |\n        //    |-b--+-b\n        // Vy | |  | |   X = -Vx * Vy\n        //    a-+--a-|\n        //  X   |  | |\n        //      b----b\n        \n        //   -> Vx\n        // |  a----a\n        // v  |    |\n        //    |-b--+-b\n        // Vy | |  |X|   X = Vx * (1 - Vy)\n        //    a-+--a-|\n        //      |    |\n        //      b----b\n        \n        //   -> Vx\n        // |  a----a\n        // v  |    |\n        //    |-b--+-b\n        // Vy | |  | |   X = (1 - Vx) * Vy\n        //    a-+--a-|\n        //      |X | |\n        //      b----b\n        \n        //\n        // +-----------+---------------+------------+\n        // |>Vx *  >Vy | 1|Vx| *  >Vy  |-<Vx *  >Vy |\n        // +-----------+---------------+------------+\n        // |>Vx * 1|Vy|| (1|Vx|*1|Vy|) |-<Vx * 1|Vy||\n        // +-----------+---------------+------------+\n        // |>Vx * -<Vy | 1|Vx| * -<Vy  |-<Vx * -<Vy |\n        // +-----------+---------------+------------+\n        \n        // Vx * Vy + (1 - Vx) * Vy + Vx * (1 - Vy) + (1 - Vx) * (1 - Vy)\n        // Vx * Vy + Vy - Vx * Vy + Vx - Vx * Vy + 1 - Vy - Vx + Vx * Vy\n        // -------   --   -------   --   -------       --   --   -------\n        //  --> 1\n        \n        vec4 a = vec4(0.);\n        float weight = 0.;\n        \n        for (int x = -1; x < 2; x++) {\n            for (int y = -1; y < 2; y++) {\n                vec4 value = texture(iChannel0, (fragCoord + vec2(x, y)) / iResolution.xy);\n                value.xy = rotationMatrix(value.z) * value.xy;\n\t\t\t\tfloat p;\n                if (x == -1) {\n                    p = clamp(value.x, 0., 1.);\n                } else if (x == 0) {\n                    p = max(1. - abs(value.x), 0.);\n                } else {\n                    p = clamp(-value.x, 0., 1.);\n                }\n                if (y == -1) {\n                    p *= clamp(value.y, 0., 1.);\n                } else if (y == 0) {\n                    p *= max(1. - abs(value.y), 0.);\n                } else {\n                    p *= clamp(-value.y, 0., 1.);\n                }\n                p *= .5  + value.w;\t// Weight according to density\n                a += p * value;\n                weight += p;\n            }\n        }\n        \n        if (weight != 0.) {\n        \tfragColor = a / weight;\n        } else {\n            fragColor = last;\n        }\n        // Dissipate some of the movement energy\n        fragColor.xyz *= .9999;\n        \n        // vec2 v = last.xy;\n        \n    \t// fragColor = (last + texture(iChannel0, (fragCoord - v) / iResolution.xy)) / 2.;\n        \n        \n        /*\n        vec2 v = neighbors[3 * 1 + 1].xy;\n        \n        int x = v.x < 0. ? 0 : 1;\n        int y = v.y < 0. ? 0 : 1;\n        \n        // A - B\n        // |   |\n        // C - D\n        \n        vec2 fv = fract(v);\n        float ia = (1. - fv.y) * (1. - fv.x);\n        float ib = (1. - fv.y) * (fv.x)     ;\n        float ic = (fv.y)      * (1.0f-fv.x);\n        float id = (fv.y)      * (fv.x)     ;\n        \n        vec4 A = neighbors[3 * x + y];\n        vec4 B = neighbors[3 * (x + 1) + y];\n        vec4 C = neighbors[3 * x + (y + 1)];\n        vec4 D = neighbors[3 * (x + 1) + (y + 1)];\n        \n    \tfragColor = ia * A + ib * B + ic * C + id * D;\n\t\t*/\n        //fragColor = last;\n    } else {\n        fragColor = last;\n    }\n    if (iMouse.z >= 0.) {\n        vec2 mouseDir = fragCoord - iMouse.xy;\n        mouseDir = mouseDir / 40.;\n        if (length(mouseDir) < 1.) {\n        \tmouseDir = vec2(mouseDir.y, -mouseDir.x);\n            //\n            //   + ---> v = 0.02\n            //   |\n            //   | r = 1\n            //   |\n            //   *\n            //\n            // D = 2 pi r\n            // T_rot = D / v = 2 * pi * r / v = 2 * pi / 0.02 = 314.\n            // Rot [rad/s] = 2 * pi / T_rot = v / r = 0.02\n            fragColor.xy = fragColor.xy + mouseDir * 0.02;\n            fragColor.z -= 0.02;\n        }   \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat2 rotationMatrix(float rotation) {\n    float rotM = -1. / 60.;\t// 60 FPS\n    return  mat2(cos(rotation * rotM), -sin(rotation * rotM),\n                 sin(rotation * rotM), cos(rotation * rotM));\n}\n\n// Source: https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}", "buffer_b_code": "// Particle simulation\n\n#define P_STEPS 3\n#define RESPAWN 1\n#define RESPAWN_FREQ (10 * 60)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    \n    if (fragCoord.x > 20. || fragCoord.y > 20.) {\n        return;\n    }\n    \n    vec4 last = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    if (iFrame == 0\n#if RESPAWN\n        || (iFrame + int(floor(hash12(fragCoord) * float(RESPAWN_FREQ)))) % RESPAWN_FREQ  == 0\n#endif\n\t) {\n        // Initialize\n        fragColor.xy = hash22(fragCoord+iMouse.zw + iTime) * iResolution.xy;\n        fragColor.zw = texture(iChannel1, fragColor.xy / iResolution.xy).xy;\n    } else {\n        vec2 pos = last.xy;\n        vec2 v = last.zw;\n        for (int i = 0; i < P_STEPS; i++) {\n            vec4 field = texture(iChannel1, pos / iResolution.xy);\n            // Simulate some mass of the particle\n            v = mix(v, field.xy, clamp(0.2 * field.w, 0., 1.));\n            v = rotationMatrix(2.5 * field.z * field.w / float(P_STEPS)) * v;\n            pos = mod(pos + v, iResolution.xy);\n        }\n        fragColor.xy = pos;\n        fragColor.zw = v;\n        // Add some random noise to the position:\n        fragColor.xy += (hash22(fragCoord + vec2(iTime)) - vec2(0.5)) * .1;\n        //fragColor.x = mod(fragColor.x, iResolution.x);\n        \n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 168, 168, 436], [438, 438, 495, 519, 1974]], "test": "untested"}
{"id": "3syyWw", "name": "Fab18 #inktober2020 \"trap\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nReference image: [img] https://miro.medium.com/max/770/1*y8l3aj1E5z_QyjcI5NUxcQ.png [/img]", "tags": ["short", "golf", "reproduction", "inktober2020"], "likes": 10, "viewed": 273, "published": 3, "date": "1602920206", "time_retrieved": "2024-07-30T20:39:57.864836", "image_code": "#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n\n#define jaw(o)   \\\n        s = mod(o+16.*atan(q.x,q.z)/3.14,2.), s = min(s,2.-s),/* dents */           \\\n        t = min(t, max( abs(length(q.xz)-8.)-.1, max( abs(q.y-s)-1.5-s, -q.z ) ) ), /* round part */ \\\n        a = abs(q+4.*Z), t = min(t, max( max( abs(a.x-8.)-.1,a.y-1.5 ), a.z - 4. )) // straight part\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s;\n    vec3  R = iResolution, e = vec3(1,-1,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          M = iMouse.z > 0. ? iMouse.xyz/R : vec3(4,2,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 50./R, q,a;                                     // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot( .4 +6.*M.y),                             // rotations\n        q.xz *= rot(-.7 -6.*M.x), \n        q.y += 5., q.z += 7., a = abs(q),\n        t = min(t, max( length(q.xz)-3.5, abs(q.y-1.)-.1) ),  // plate\n        t = min(t, max( length(q.zy) -.5,    a.x - 9.   ) ),  // axe\n        a = abs(q+1.5*Y)-10.*X,  t = min(t, max( max( a.x-1.,a.y-.15 ), // bar\n                                                 max( a.z-1.,.4-length(a.xz)) )),\n        q.z-=7., jaw(),                                       // bottom jaw\n        q.z+=7., q.yz*=rot(-1.5+1.1*atan(30.*sin(iTime))/1.5 ),q.z-=7., // animated opening angle\n        q.x-=.4, q.y= -q.y, jaw(1.2),                         // top jaw\n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O = exp(-2.5*O) * vec4(1,1,1.2,1);                        // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 439, 439, 1742]], "test": "untested"}
{"id": "wsVcDD", "name": "october v002", "author": "darkczar", "description": "parametric", "tags": ["parametric"], "likes": 1, "viewed": 236, "published": 3, "date": "1602907862", "time_retrieved": "2024-07-30T20:39:58.989828", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 2.;\n    for(int i = 0;i<100;i++)\n    {\n        di = float(i)*.3;\n        curve_p.x = .05-.3*sin(.3*iTime)+.25*float(di)*cos(float(di)+.4*iTime); // +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = .05-.3*cos(.3*iTime)-.25*float(di)*sin(float(di)+.2*iTime); // +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = sin(min(d*1.0, 2.*sin(length(p-curve_p))));\n        //d = length(p-curve_p)/(di+1.0);\n  \n    }\n    float r =.05*d + .5*(.05 - .015*pow(dot(sin(p*p*p), log(20.0+2.*curve_p)),2.0));\n    float g = .0008 + .005*cos(.001*d*d+9.1*length(p)); //+.03*dot(p,curve_p + .0005*vec2(iTime, iTime));\n    float b=2.5*abs(.5+.3*cos(iTime*.8 - 2.5*pow(d,2.0))); // +.01*(dot(p,curve_p - .005*vec2(iTime-200.05, iTime-200.05)+10.0));\n    if (d < .82)\n    {\n        b = .0 +.04*(.5+ .5*sin(iTime*.1 + 1.28*dot(p,curve_p)));\n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 1498]], "test": "untested"}
{"id": "wsKyDW", "name": "Quadratic bezier curve", "author": "sadiuk", "description": "Really simple implementation of a quadratic bezier curve.", "tags": ["beziercurve"], "likes": 1, "viewed": 315, "published": 3, "date": "1602876759", "time_retrieved": "2024-07-30T20:40:00.161696", "image_code": "\n//*****Adjustable parameters****/////\n#define CONTROL_POINTS_COUNT 2\n#define POINT_SIZE 5\n#define EPS 1e-8\n#define LINE_SIZE 0.02\n\nconst vec2 cp1 = vec2(0.2, 0.5);\nconst vec2 cp2 = vec2(0.8, 0.5);\n    \nconst vec4 control_point_color = vec4(0.2, 0.3, 0.8, 1.);\nconst vec4 mouse_point_color = vec4(0.9, 0.8, 0.2, 1.);\nconst vec4 bezier_color = vec4(0.3, 0.95, 0.2, 1.);\n//******************************/////\n\n\nbool point(vec2 coord, vec2 center, vec2 resolution)\n{\n \treturn int(length(coord * resolution - center * resolution)) < POINT_SIZE;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n    vec2 result;\n    float D = b * b - 4. * a * c;\n    result[0] = D >= 0. ? (-b + sqrt(D)) / (2. * a) : -1.;\n    result[1] = D >= 0. ? (-b - sqrt(D)) / (2. * a) : -1.;\n    return result;\n}\n\nbool is_on_bezier_curve(vec2 point, vec2 p0, vec2 p1, vec2 p2)\n{\n \tvec2 x_solutions, y_solutions;\n    x_solutions = solve_quadratic(p0.x - 2. * p1.x + p2.x,\n                                  2. * (p1.x - p0.x),\n                                  p0.x - point.x);\n    \n    y_solutions = solve_quadratic(p0.y - 2. * p1.y + p2.y,\n                                  2. * (p1.y - p0.y),\n                                  p0.y - point.y);\n    bool cond_1 = abs(x_solutions[0] - y_solutions[0]) < LINE_SIZE && \n        abs(y_solutions[0] + 1.) > EPS && abs(x_solutions[0] + 1.) > EPS;\n    bool cond_2 = abs(x_solutions[0] - y_solutions[1]) < LINE_SIZE && \n        abs(y_solutions[1] + 1.) > EPS && abs(x_solutions[0] + 1.) > EPS;\n    bool cond_3 = abs(x_solutions[1] - y_solutions[0]) < LINE_SIZE && \n        abs(y_solutions[0] + 1.) > EPS && abs(x_solutions[1] + 1.) > EPS;\n    bool cond_4 = abs(x_solutions[1] - y_solutions[1]) < LINE_SIZE && \n        abs(y_solutions[0] + 1.) > EPS && abs(x_solutions[0] + 1.) > EPS;\n    return cond_1 || cond_2 || cond_3 || cond_4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 res = iResolution.xy;\n    vec2 point_size = vec2(POINT_SIZE, POINT_SIZE) / iResolution.xy;\n    vec2 mouse_pos = iMouse.xy / iResolution.xy; \n//\tvec2 line_size = vec2(LINE_WIDTH, LINE_WIDTH) / iResolution.xy;\n\n    \n\t\n    \n    fragColor = point(uv, mouse_pos, iResolution.xy) ? mouse_point_color : vec4(1, 1, 1, 1);\n    \n    fragColor = is_on_bezier_curve(uv, cp1, mouse_pos, cp2) ? bezier_color : fragColor;\n    \n    fragColor = point(uv, cp1, res) || point(uv, cp2, res) ?\n        control_point_color : fragColor;  \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 409, 463, 463, 542], [544, 544, 593, 593, 783], [785, 785, 849, 849, 1846], [1848, 1848, 1905, 1905, 2479]], "test": "untested"}
{"id": "tsKyDW", "name": "Viscous fluid 2", "author": "michael0884", "description": "Tracking the deformation gradient to model solid bodies. Yeah, no actual particles here. \nSPACE - zoom in", "tags": ["particles", "ca"], "likes": 10, "viewed": 690, "published": 3, "date": "1602876669", "time_retrieved": "2024-07-30T20:40:01.851178", "image_code": "// Fork of \"Neo-Hookean 2: Electric Boogaloo\" by michael0884. https://shadertoy.com/view/tsVyWR\n// 2020-10-16 17:16:16\n\n// Fork of \"CA Neo-Hookean\" by michael0884. https://shadertoy.com/view/WdGyWR\n// 2020-10-13 18:17:06\n\n//used sources \n//https://github.com/nialltl/incremental_mpm/blob/master/Assets/2.%20MLS_MPM_NeoHookean_Multithreaded/MLS_MPM_NeoHookean_Multithreaded.cs\n//https://www.seas.upenn.edu/~cffjiang/research/mpmcourse/mpmcourse.pdf\n\n// Fork of \"CA Paste\" by michael0884. https://shadertoy.com/view/tsGczh\n// 2020-10-12 21:02:54\n\n// Fork of \"CA Molecular dynamics\" by michael0884. https://shadertoy.com/view/3s3cWr\n// 2020-10-08 22:00:15\n\n// Fork of \"Landau Ginzburg fluid\" by michael0884. https://shadertoy.com/view/WlXBDf\n// 2020-09-21 21:03:05\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.3\n\nfloat deformation_energy(mat2 D)\n{\n    return (D[0][0]*D[0][0] + D[1][1]*D[1][1] - 2.0);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    float c = 0.;\n    float De = 0.;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\t    mat2 D0 = mat2(T1(tpos));\n        \n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        c += M0*K*data.w;\n        De += M0*K*abs(deformation_energy(D0));\n        vel += M0*K*V0;\n    }\n\n   c /= rho;\n   vel /= rho;\n   De /= rho;\n   vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)/(2.*PI), 1.0, rho*length(vel.xy)));\n    \n   col.xyz = 0.15*vec3(1.,2.,3.)*rho - 0.1*vec3(3.,2.,1.)*rho*c;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define T1(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.0\n#define R iResolution.xy\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define relax 0.05\n#define distribution_size 1.0\n\n// Lamé parameters for stress-strain relationship\nconst float elastic_lambda = 0.05;\nconst float elastic_mu = 0.1;\n\n//MD force\nfloat MF(vec2 dx, vec2 dv)\n{\n    return  0.1*dot(dx,dv)*GS(0.5*dx);\n}\n\n\n//the step functions need to be exactly like this!! step(x,0) does not work!\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\n//particle grid\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "//particle advection\n\n\n//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nfloat particleBox(vec2 x, vec2 s)\n{\n    ivec2 p = ivec2(x);\n    return Ha(x + s)*Hb(s - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    float C = 0.;\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K*K);\n        \n        //add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \tC += m.z*data.w;\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n        C /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M =particleBox(pos - R*vec2(0.3,0.2), R*0.2) + particleBox(pos - R*vec2(0.6,0.7), R*0.25);\n        C = 0.5 + 0.5*sin(0.1*pos.x);\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//deformation gradient advection and update\n\n\n//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //deformation gradient\n   \tmat2 D = mat2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n       \tmat2 D0 = mat2(T1(tpos));\n        \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K*K);\n        \n        //add deformation grad weighted by mass\n        D += D0*m.z;\n      \t\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n       D /= M;\n    }\n\telse D = mat2(1.0);\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        D = mat2(1.0);\n    }\n\n    U = vec4(D);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//velocity update\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.49, 0.49)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\n\nmat2 strain(mat2 D, float M0)\n{\n    \n    float J = abs(determinant(D)) + 0.01;\n\n    // MPM course, page 46\n    float volume = J*M0;\n\n    // useful matrices for Neo-Hookean model\n    mat2 F_T = transpose(D);\n    mat2 F_inv_T = inverse(F_T);\n    mat2 F_minus_F_inv_T = D - F_inv_T;\n\n    // MPM course equation 48\n    mat2 P_term_0 = elastic_mu * (F_minus_F_inv_T);\n    mat2 P_term_1 = elastic_lambda * log(J) * F_inv_T;\n    mat2 P = P_term_0 + P_term_1;\n\n    // cauchy_stress = (1 / det(F)) * P * F_T\n    \n    // equation 38, MPM course\n    mat2 stress = (1./J)*P * F_T;\n\n    // (M_p)^-1 = 4, see APIC paper and MPM course page 42\n    // this term is used in MLS-MPM paper eq. 16. with quadratic weights, Mp = (1/4) * (delta_x)^2.\n    // in this simulation, delta_x = 1, because i scale the rendering of the domain rather than the domain itself.\n    // we multiply by dt as part of the process of fusing the momentum and force update for MLS-MPM\n    return volume * stress;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 Fa = vec2(0.);\n         vec2 F = vec2(0.);\n        float a = 0.;\n        float tM = 0.;\n        vec2 avgV = vec2(0.);\n        range(i, -2,2) range(j, -2, 2)\n        {\n            if(!(i == 0 && j == 0))\n            {\n                vec2 tpos = pos + vec2(i,j);\n                vec4 data = T(tpos);\n\n                vec2 X0 = DECODE(data.x) + tpos;\n                vec2 V0 = DECODE(data.y);\n                float M0 = data.z;\n                vec2 dx = X0 - X;\n                vec2 dv = V0 - V;\n                mat2 D0 = mat2(T1(tpos));\n                float weight = GS(0.8*dx);\n                avgV += M0*V0;\n\t\t\t\ttM += weight*M0;\n                Fa += M0*M*MF(dx,dv)*normalize2(dx);\n                F += clamp(strain(D0, M0)*dx, vec2(-1.0), vec2(1.0))*weight;\n                a += M0;\n            }\n        }\n        avgV /= a;\n        \n        F += (V - avgV)*0.1;\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n            F -= 0.0002*dx*GS(dx/80.);\n        }\n        \n       \t//gravity\n        F += 0.001*vec2(0,-1);\n        \n        //integrate velocity\n        V += (F + Fa/M)*dt;\n        \n        \n        vec3 BORD = bN(X);\n        V += 0.6*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//low res averaged velocity\n//low res averaged deformation gradient\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    mat2 D = mat2(T1(pos));\n    if(M != 0.) //not vacuum\n    {\n        //Compute the velocity matrix\n        mat2 B = mat2(0.);\n        float a = 0.5;\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(!(i == 0 && j == 0))\n            {\n                vec2 tpos = pos + vec2(i,j);\n                vec4 data = T(tpos);\n\n                vec2 X0 = DECODE(data.x) + tpos;\n                vec2 V0 = DECODE(data.y);\n                float M0 = data.z;\n                vec2 dx = X0 - X;\n                vec2 dv = V0 - V;\n                float weight = GS(0.65*dx);\n                B += mat2(dv*dx.x,dv*dx.y)*weight;\n                a += weight;\n            }\n        }\n        B /= a;\n        \n        //density correction\n        B -= 0.03*mat2(M - 1.0);\n       \n        //integrate deformation gradient\n       \tD += dt*B*D;\n       \n        //smoothing\n        D = D*(1. - relax) + mat2(1.)*relax;\n    }\n    \n    //save\n    U = vec4(D);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[960, 960, 987, 987, 1165], [1193, 1193, 1221, 1221, 1281], [1321, 1321, 1355, 1355, 1411]], "test": "untested"}
{"id": "3dVyDD", "name": "Neo-Hookean Field", "author": "michael0884", "description": "Tracking the deformation gradient to model solid bodies. Yeah, no actual particles here. \nSPACE - zoom in\nUse plugin to accelerate simulation\n", "tags": ["particles", "ca"], "likes": 15, "viewed": 606, "published": 3, "date": "1602873016", "time_retrieved": "2024-07-30T20:40:03.046982", "image_code": "// Fork of \"Neo-Hookean 2: Electric Boogaloo\" by michael0884. https://shadertoy.com/view/tsVyWR\n// 2020-10-16 17:16:16\n\n// Fork of \"CA Neo-Hookean\" by michael0884. https://shadertoy.com/view/WdGyWR\n// 2020-10-13 18:17:06\n\n//used sources \n//https://github.com/nialltl/incremental_mpm/blob/master/Assets/2.%20MLS_MPM_NeoHookean_Multithreaded/MLS_MPM_NeoHookean_Multithreaded.cs\n//https://www.seas.upenn.edu/~cffjiang/research/mpmcourse/mpmcourse.pdf\n\n// Fork of \"CA Paste\" by michael0884. https://shadertoy.com/view/tsGczh\n// 2020-10-12 21:02:54\n\n// Fork of \"CA Molecular dynamics\" by michael0884. https://shadertoy.com/view/3s3cWr\n// 2020-10-08 22:00:15\n\n// Fork of \"Landau Ginzburg fluid\" by michael0884. https://shadertoy.com/view/WlXBDf\n// 2020-09-21 21:03:05\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 0.85\n#define zoom 0.2\n\nfloat deformation_energy(mat2 D)\n{\n    return 2.*(D[0][0]*D[0][0] + D[1][1]*D[1][1] - 2.0);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    float c = 0.;\n    float De = 0.;\n    vec2 vel = vec2(0., 0.);\n    vec2 grad = vec2(0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = 4.*DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\t    mat2 D0 = mat2(T1(tpos));\n        \n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        grad += normalize(dx)*K;\n        c += M0*K*data.w;\n        De += M0*K*abs(deformation_energy(D0));\n        vel += M0*K*V0;\n    }\n\n   grad /= rho;\n   c /= rho;\n   vel /= rho;\n   De /= rho;\n    \n   //vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)/(2.*PI), 1.0, rho*length(vel.xy)));\n   float d = smoothstep(0.2,2.,rho);\n   col.xyz = mix(vec3(0.), mix(vec3(0.02,0.05,1.0),vec3(1.0,0.05,0.02),d*c*c*c), d) + d*De*vec3(0.,0.2,1.);\n   col.xyz = sqrt(col.xyz);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define T1(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 0.5\n#define R iResolution.xy\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define velocity_averaging 0.3\n\n//squishy solid\n#define relax 0.000\n#define distribution_size 1.0\n// Lamé parameters for stress-strain relationship\n#define elastic_lambda 0.25\n#define elastic_mu 0.5\n#define incompressible_viscosity 0.17\n\n\n//viscous fluid\n/*\n#define relax 0.05\n#define distribution_size 0.98\n// Lamé parameters for stress-strain relationship\n#define elastic_lambda 0.2\n#define elastic_mu 0.1\n#define incompressible_viscousity 0.05\n*/\n\n//MD force\nfloat MF(vec2 dx, vec2 dv)\n{\n    return incompressible_viscosity*dot(dx,dv)*GS(0.5*dx);\n}\n\n\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "//Reintegration tracking\n\nfloat particleBox(vec2 x, vec2 s)\n{\n    return float(sdBox(x, s) < 0.);\n}\n\nfloat particleArch(vec2 x, vec2 s)\n{\n    return float(opSubtraction(sdBox(x + vec2(0, s.y*0.4), s*vec2(0.15, 0.6)), sdBox(x, s)) < 0.);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    float C = 0.;\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K*K);\n        \n        //add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \tC += m.z*data.w;\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n        C /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        vec4 nya = texture(iChannel2, clamp(1.8*X*vec2(0.166,1.)/R, vec2(0.),vec2(0.1666, 1.0)));\n        M = particleBox(X - R*vec2(0.5,0.4), R*vec2(0.34));\n        C = nya.y*nya.w + 0.5*sin(0.1*X.x) + 0.5;\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//deformation gradient advection and update\n\n\n//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //deformation gradient\n   \tmat2 D = mat2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n       \tmat2 D0 = mat2(T1(tpos));\n        \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        vec3 m = data.z*vec3(center, 1.0)*size.x*size.y/(K*K);\n        \n        //add deformation grad weighted by mass\n        D += D0*m.z;\n      \t\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n       D /= M;\n    }\n\telse D = mat2(1.0);\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        D = mat2(1.0);\n    }\n\n    U = vec4(D);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//velocity update\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.48, 0.48)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\n\nmat2 strain(mat2 D, float M0)\n{\n    float J = abs(determinant(D)) + 0.01;\n\n    // MPM course, page 46\n    float volume = J*M0;\n\n    // useful matrices for Neo-Hookean model\n    mat2 F_T = transpose(D);\n    mat2 F_inv_T = inverse(F_T);\n    mat2 F_minus_F_inv_T = D - F_inv_T;\n\n    // MPM course equation 48\n    mat2 P_term_0 = elastic_mu * (F_minus_F_inv_T);\n    mat2 P_term_1 = elastic_lambda * log(J) * F_inv_T;\n    mat2 P = P_term_0 + P_term_1;\n\n    // equation 38, MPM course\n    mat2 stress = (1./J)* P * F_T;\n\n    return volume * stress;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    if(M>0.0) //not vacuum\n    {\n        //Compute the force\n        vec2 Fa = vec2(0.);\n         vec2 F = vec2(0.);\n        float a = 0.;\n        float tM = 0.;\n        vec2 avgV = vec2(0.);\n        if(M > 0.1)\n        {\n            range(i, -2,2) range(j, -2, 2)\n            {\n                if(!(i == 0 && j == 0))\n                {\n                    vec2 tpos = pos + vec2(i,j);\n                    vec4 data = T(tpos);\n\n                    vec2 X0 = DECODE(data.x) + tpos;\n                    vec2 V0 = DECODE(data.y);\n                    float M0 = data.z;\n                    vec2 dx = X0 - X;\n                    vec2 dv = V0 - V;\n                    mat2 D0 = mat2(T1(tpos));\n                    float weight = GS(0.8*dx);\n                    avgV += M0*V0;\n                    tM += weight*M0;\n                    Fa += M0*M0*M*MF(dx,dv)*normalize2(dx);\n                    F += clamp(strain(D0, M0)*dx, vec2(-1.0), vec2(1.0))*weight;\n                    a += M0;\n                }\n            }\n        \n            avgV /= a;\n\n            F -= (V - avgV)*velocity_averaging;\n        }\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n            F -= 0.015*normalize2(dx)*GS(dx/80.);\n        }\n        \n       \t//gravity\n        F += 0.001*vec2(0,-1);\n        \n        //integrate velocity\n        V += (F + Fa/M)*dt;\n        \n        \n        vec3 BORD = bN(X);\n        V += (0.3 - 0.01*V)*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    mat2 D = mat2(T1(pos));\n    if(M > 0.1) //not vacuum\n    {\n        //Compute the velocity gradient matrix\n        mat2 B = mat2(0.);\n        float a = 0.01;\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(!(i == 0 && j == 0))\n            {\n                vec2 tpos = pos + vec2(i,j);\n                vec4 data = T(tpos);\n\n                vec2 X0 = DECODE(data.x) + tpos;\n                vec2 V0 = DECODE(data.y);\n                float M0 = data.z;\n                vec2 dx = X0 - X;\n                vec2 dv = V0 - V;\n                float weight = (M0+0.01)*GS(0.75*dx);\n                B += mat2(dv*dx.x,dv*dx.y)*weight;\n                a += weight;\n            }\n        }\n        B /= a;\n        \n        //density correction\n        B -= 0.005*mat2(M - 1.0);\n       \n        //integrate deformation gradient\n       \tD += dt*B*D;\n       \n        //smoothing\n        D = D*(1. - relax) + mat2(1.)*relax;\n    }\n    \n    //save\n    U = vec4(D);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[960, 960, 987, 987, 1165], [1193, 1193, 1221, 1221, 1281], [1322, 1322, 1356, 1356, 1415]], "test": "untested"}
{"id": "wtSyRy", "name": "Sliding Glass", "author": "parabola", "description": "Lisandro Peralta\nSimple sliding strips video effect", "tags": ["fx"], "likes": 8, "viewed": 635, "published": 3, "date": "1602872958", "time_retrieved": "2024-07-30T20:40:03.902693", "image_code": "\nfloat miCantidad = 10. ; //////////////////// MI CANTIDAD DE CIRCULOS\nfloat random(in vec2 _st)\n{\n    return fract(sin(dot(floor(_st.xy),\n                         vec2(12.9898, 78.233))) *\n                 43000.3);\n}\n\nfloat noise(in vec2 st, float fase)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i) * fase2);\n    float b = sin(random(i + vec2(1.0, 0.0)) * fase2);\n    float c = sin(random(i + vec2(0.0, 1.0)) * fase2);\n    float d = sin(random(i + vec2(1.0, 1.0)) * fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2)\n{\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nmat2 rotate2d(float _angle)\n{\n    return mat2(cos(_angle), -sin(_angle),\n                sin(_angle), cos(_angle));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    float fix = iResolution.x / iResolution.y;\n    uv.x *= fix;\n    vec3 final = vec3(0);\n    int cantidad = int(miCantidad);\n    uv-=0.5;\n    uv=rotate2d(radians(45.))*uv;\n    uv+=0.5;\n    for (int i = 0; i < cantidad; i++)\n    {\n    \n     float seccion = length(vec2(float(i)*(1./float(cantidad))*fix,clamp(2., -2., uv.y))-uv);\n      seccion=step(seccion,(1./float(cantidad))-(1./float(cantidad))/9.);\n    \n      vec2 video1Uv = gl_FragCoord.xy / iResolution.xy;\n    video1Uv.y+=sin(iTime+float(i))/20.;\n    video1Uv.x-=sin(iTime+float(i))/20.;\n     vec3 video1 = vec3(texture(iChannel0, video1Uv)); // SE PUEDE CAMBIAR A PREVIOUS PASS\n      \n       float mascara = seccion;\n        vec3 este = video1 * mascara;\n     \n        final += este;\n    }\n\n    vec3 color = vec3(final);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 71, 98, 98, 218], [220, 220, 257, 257, 857], [859, 859, 931, 931, 999], [1000, 1000, 1029, 1029, 1117], [1118, 1118, 1174, 1174, 2039]], "test": "untested"}
{"id": "WdVcDW", "name": "The ColorChecker", "author": "thepheer", "description": "Studying color science. The colors are converted by me from the official L*a*b* D50 values to sRGB D65.", "tags": ["color", "macbeth", "colorchecker"], "likes": 10, "viewed": 467, "published": 3, "date": "1602871345", "time_retrieved": "2024-07-30T20:40:04.889056", "image_code": "const vec3 colors[] = vec3[] (\n    vec3(0.454, 0.311, 0.255), // Dark skin\n    vec3(0.773, 0.563, 0.497), // Light skin\n    vec3(0.356, 0.472, 0.609), // Blue sky\n    vec3(0.359, 0.425, 0.250), // Foliage\n    vec3(0.514, 0.498, 0.685), // Blue flower\n    vec3(0.374, 0.740, 0.673), // Bluish green\n    vec3(0.879, 0.487, 0.189), // Orange\n    vec3(0.269, 0.351, 0.656), // Purplish blue\n    vec3(0.774, 0.313, 0.373), // Moderate red\n    vec3(0.364, 0.227, 0.407), // Purple\n    vec3(0.612, 0.734, 0.228), // Yellow green\n    vec3(0.892, 0.633, 0.153), // Orange yellow\n    vec3(0.156, 0.241, 0.570), // Blue\n    vec3(0.238, 0.577, 0.275), // Green\n    vec3(0.699, 0.210, 0.222), // Red\n    vec3(0.927, 0.782, 0.057), // Yellow\n    vec3(0.750, 0.309, 0.574), // Magenta\n    vec3(0.000, 0.521, 0.648), // Cyan\n    vec3(0.945, 0.948, 0.923), // White\n    vec3(0.789, 0.793, 0.788), // Neutral 8\n    vec3(0.632, 0.640, 0.638), // Neutral 6.5\n    vec3(0.473, 0.474, 0.473), // Neutral 5\n    vec3(0.324, 0.330, 0.331), // Neutral 3.5\n    vec3(0.194, 0.195, 0.197)  // Black\n);\n\nvec3 colorchecker(vec2 uv) {\n    vec2 xy = vec2(3.0, 2.0) + vec2(3.0, -2.0)*uv;\n    vec2 ta = smoothstep(0.45, 0.42, 0.5 - fract(xy));\n    vec2 tb = step(abs(0.5 - fract(xy)), vec2(0.45));\n    vec3 ca = rsrgb(vec3(64.0/255.0));\n    vec3 cb = rsrgb(colors[6*int(xy.y) + int(xy.x)]);\n    vec3 cc = mix(vec3(0.02), cb, 0.2 + 0.8*ta.x*ta.y);\n    return srgb(mix(ca, cc, tb.x*tb.y));\n}\n\nvoid mainImage(out vec4 rgba, in vec2 xy) {\n    vec2 uv = 2.0*xy/iResolution.xy - 1.0;\n    vec2 r = vec2(6.0, 4.0)/iResolution.xy;\n    vec2 s = 1.1*max(r.x, r.y)/r.xy;\n    rgba = vec4(colorchecker(clamp(s*uv, -1.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "vec3 srgb(vec3 c) {\n    vec3 a = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}\n\nvec3 rsrgb(vec3 c) {\n    vec3 a = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 b = c/12.92;\n    return mix(a, b, lessThanEqual(c, vec3(0.04045)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVcDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1073, 1073, 1101, 1101, 1453], [1455, 1455, 1498, 1498, 1684]], "test": "untested"}
{"id": "WdVcWD", "name": "Volumetric Depth of Field", "author": "FabriceNeyret2", "description": "Volume rendering makes single-ray AA, LOD, DoF trivial: just tune the MIPmap level to the target radius of confusion.\nYou can even use larger steps where blurry, and so render faster !\nmouse  rotate. \nmultiplicative noise. front/back: filaments vs plates.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "dof", "volumetric", "lod", "vr", "hairs", "preintegration"], "likes": 11, "viewed": 831, "published": 3, "date": "1602867132", "time_retrieved": "2024-07-30T20:40:05.925285", "image_code": "// Depth of Field variant of \"anisotropic multiplicative noise\" by FabriceNeyret2. https://shadertoy.com/view/3ddcDl\n// search $DOF for the specifics.\n\n// check my GigaVoxels, Voxel Cone Tracing, Volumetric textures, apparence LOD papers related papers here ;-) : http://evasion.imag.fr/~Fabrice.Neyret/publis/publisHal.fr.html\n// and some videos here: https://www.youtube.com/user/CyrilCrassin/videos , https://www.youtube.com/user/FabNeyretResearch/videos\n\n\n// Preintegrated transfer function from https://shadertoy.com/view/tsdcRj\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\nfloat lod = 0.;  // $DOF \n#define T(d)   textureLod(iChannel0, (i+d+.5)/32. ,lod ).x    // noise texture\n\nfloat noise(vec3 x) {  // By default, simple 3D value noise with cubic interpolation\n    vec3 i = floor(x), // Switch to gradient noise above if you wish, but little differences\n         F = fract(x), e = vec3(1,0,0),\n         f = smoothstep(0.,1.,F );\n    vec4 T = mix ( vec4(T(e.zzz),T(e.zxz), T(e.zzx), T(e.zxx) ),\n                   vec4(T(e.xzz),T(e.xxz), T(e.xzx), T(e.xxx) ),\n                   f.x );\n    vec2 v = mix( T.xz, T.yw, f.y);\n    return mix(v.x,v.y,f.z);\n        }\n\nfloat add_noise(vec3 x) {\n    float n = noise(x)/2.;  x *= 2.1; // return n*2.;\n         n += noise(x)/4.;  x *= 1.9;\n         n += noise(x)/8.;  x *= 2.3;\n         n += noise(x)/16.; x *= 1.9;\n      //   n += noise(x)/32.;\n    return n; \n}\n\nfloat mul_noise(vec3 x) {\n    float n = 2.*noise(x);  x *= 2.1; // return n/2.;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);  x *= 2.3;\n         n *= 2.*noise(x);  x *= 1.9;\n      //   n *= 2.*noise(x);\n    return n/2.; \n}\n\nfloat z;\nfloat map(vec3 p )  // bounding sphere (0,0,0), 2.\n{\n    vec3 q = p*10.;//+ .6*iTime;\n    q /= p.z < 0. ? vec3(1,1,4) :  vec3(4,4,1);\n//  float f =  1.2*add_noise(q) -.2 ;// source noise\n//  float f =  add_noise(q);\n    float f =  mul_noise(q);\n//  float f =  p.x < 0. ? add_noise(q) : mul_noise(q);\n    f *= smoothstep(1.,.8,length(p)/2.);   // source sphere\n\n    f*= smoothstep(.1,.2,abs(p.x));               // empty slice (derivable ) \n    z = length(p)/2.;                             // depth in sphere\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\n  #define sl  1. // *** > 1 => non-linear => wrong $DOF filtering. At your own risks ! *** // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n//  return d;\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 BS = vec4(0,0,0, 2.);          // bounding sphere\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, BS.xyz, BS.w );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos-BS.xyz) > BS.w ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        lod = 1.*abs( pos.z - sin(4.*iTime) ); // *** tune Depth of Field $DOF ***\n        dt = max(.01, .05*lod);     // *** use larger steps where $DOF blurry ***\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 S = pos.x < 0. ? vec3(3,3,2) : vec3(2,3,3);\n            vec3 col = exp(-S *(1.-z));                   // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));     // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n            sum += (1.-min(1.,sum.a)) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = abs( dot(sundir,rd) );\n // float sun = max( dot(sundir,rd), 0. );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = 2.* ( 1.- iMouse.xy / R + vec2(.5,-.5) );\n    m += .02 * vec2(1,3)* cos(2.*iTime+vec2(0,11));\n    //iMouse.z>0. ? 2.* ( 1.- iMouse.xy / R ) : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1019, 1019, 1040, 1103, 1502], [1504, 1504, 1529, 1529, 1744], [1746, 1746, 1771, 1771, 1988], [1999, 1999, 2051, 2051, 2547], [3165, 3165, 3198, 3271, 3468], [3470, 3470, 3529, 3529, 3677], [3735, 3735, 3792, 3792, 6283], [6285, 6285, 6331, 6331, 6493], [6495, 6495, 6538, 6562, 7053], [7055, 7055, 7093, 7093, 7719]], "test": "untested"}
{"id": "WdVyDW", "name": "Segment Tracing - Blobs", "author": "Moon519", "description": "Official shaderToy release of Eurographics 2020 paper: Segment Tracing using Local Lipschitz Bounds.", "tags": ["tracing", "implicit", "segment"], "likes": 78, "viewed": 4584, "published": 3, "date": "1602865994", "time_retrieved": "2024-07-30T20:40:06.922619", "image_code": "// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Guérin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;\n    s = 0;\n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyDW.jpg", "access": "api", "license": "mit", "functions": [[950, 964, 995, 995, 1108], [1110, 1155, 1188, 1188, 1282], [1284, 1373, 1407, 1407, 1439], [1441, 1584, 1636, 1636, 1957], [1959, 2064, 2112, 2112, 2155], [2157, 2316, 2380, 2380, 2940], [2942, 2955, 2977, 2977, 3185], [3187, 3197, 3229, 3229, 3466], [3467, 3467, 3484, 3484, 3526], [3528, 3549, 3580, 3580, 3815], [3817, 3924, 3984, 3984, 4459], [4461, 4566, 4627, 4627, 5516], [5518, 5539, 5565, 5565, 5687], [5688, 5688, 5716, 5716, 5982], [5983, 5983, 6007, 6007, 6315], [6317, 6317, 6372, 6421, 7692]], "test": "untested"}
{"id": "WdKcDW", "name": "Database Moshin' Effects", "author": "UrbanClubProfessional", "description": "Remix of \"Data Moshing Effect\" by slerpy", "tags": ["color", "demo", "remix", "glitch", "weird", "party", "attempt", "data", "mashing"], "likes": 12, "viewed": 1211, "published": 3, "date": "1602858701", "time_retrieved": "2024-07-30T20:40:07.773344", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fetch buffer a\n    ivec2 u = ivec2(fragCoord);\n    vec4 tex = texelFetch(iChannel0, u, 0);\n    \n    // fetch buffer b\n    if(iFrame % 9 != 0  && tex.w > 0.)u = ivec2(tex.xy);\n    fragColor = texelFetch(iChannel1, u, 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p)\n{\n    vec3 q = abs(fract(p)-.6);\n    q = min(q,q.zxy);\n    return max(max(q.x, q.y), q.z) - 0.2;\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float m, t=0.2;\n    for(int i=0; i++<500;)\n        if(t+=m=map(ro+rd*t), m<0.02||t>26.)\n            break;\n    \n\treturn t;\n}\n\nmat3 camera(float t, out vec3 ro)\n{\n    // placeholder animation\n    float p = 4., mt = mod(t, p);\n    t = (t - mt) + p*smoothstep(.0, p, mt);\n    vec3 dir = vec3(cos(floor(iTime/p)),sin(floor(iTime/p)),.9);\n    ro=vec3(0.2*sin(t),0.2*cos(2.2*t),0.3*t);\n    \n    // rotation matrix for rd\n    vec3 cw=normalize(dir);\n    vec3 cu=normalize(cross(vec3(0,2,0),cw));\n    vec3 cv=normalize(cross(cw,cu));\n    return mat3(cu,cv,cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 u = ivec2(fragCoord);\n    vec4 last = texelFetch(iChannel0, u, 0);\n    \n    // reset after color override\n    if(last.w < .0)\n    {\n        fragColor = vec4(fragCoord, 0, iTime);\n        return;\n    }\n    \n    // main trace \n    vec3 ro, rd = camera(iTime, ro) * normalize(vec3(3.*fragCoord-iResolution.xy, iResolution.y));\n    \n    float t = trace(ro, rd);\n    vec3 p = ro + rd * t;\n    \n    // occlusion trace\n    float pt = last.w;\n    mat3 m = camera(pt, ro);\n    \n    vec3 od = ro - p;\n    float odl = length(od);\n    bool occ = trace(p, od/odl)-odl < .02;\n    \n    // back projection\n    vec2 coord = 0.3 * (od *= m, od.xy / od.z * iResolution.y + iResolution.xy);\n    \n    // out of range check\n    occ = occ || floor(coord/iResolution.xy) != vec2(0);\n    \n    // far plane check\n    if(t > 26.)occ = false;\n    \n    // occlusion check\n    if(occ || iFrame < 3)\n    {\n        vec4 rv = vec4(round(34.*p), 2);\n        for(int i=0; i<9; i++)\n            rv = fract(2e5*sin(rv)+ rv.wxyz);\n        \n        fragColor = vec4(rv.xyz, -2);\n        return;\n    }\n    \n    // output coord\n    if(iFrame % 9 == 0)pt = iTime;\n    fragColor = vec4(coord, 0, pt);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fetch buffer a\n    ivec2 u = ivec2(fragCoord);\n    vec4 tex = texelFetch(iChannel0, u, 0);\n    \n    // manual color override\n    if(tex.w < .0)\n    {\n        fragColor = tex;\n        return;\n    }\n    \n    // fetch buffer b\n    if(iFrame % 9 == 0)u = ivec2(tex.xy);\n    fragColor = texelFetch(iChannel1, u, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 79, 286]], "test": "untested"}
{"id": "tsyyWW", "name": "Fab17 #inktober2020 \"storm\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020", "differentialscrolling"], "likes": 3, "viewed": 514, "published": 3, "date": "1602839132", "time_retrieved": "2024-07-30T20:40:08.576197", "image_code": "#define R iResolution.xy\n\n#define S(v)     smoothstep( 3., -3., (v)/min(.05,fwidth(v)) ) // AA draw\n#define C(p,r)   S( length(p) - (r) )                          // circle\n#define b(p,w,h) S( max( abs(p).x - (w), abs(p).y - (h) ) )    // box\n#define B(C,A)   O =  mix( O, vec4((C)*(C),1), A )             // blend back to front\n\nfloat s; // for seeding\n#define hash(p,op)  fract(sin((p+s)*op(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define rand(p)     hash(p,vec4) //  hash(p,mat2)\n#define pol(p)   sqrt((p).x) * cos( 6.3*(p).y + vec2(0,11) )   // rand in disk\n#define psin(x) ( .5 + .5* sin(6.3*(x)) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( u+u - R ) / R.y, V=U;   \n    float T, t = .3*iTime+10.,                 // wind and scroll timers\n          j = floor(-5.*(U.y+.2)), y;          // --- differential scrolling strips\n    O = j <= 0. ? max( vec4(.8*exp(-.5*U.y),1,1,1),  // sky + clouds\n                       1.5*texture(iChannel0,U/vec2(7,1)+vec2(t*j/10.-.1*t,0),2.).r )\n                : .3-j/6. + vec4(0,.7,(3.-j)/5.,1)   // ground\n                           *(.8+.2*texture(iChannel0,U+vec2(t*j/2.,0),3.-j).r);\n    O*=O; // because I accounted for gamma too late. Do it before tuning colors ;-)\n\n    for( j=1.; j<4.; j++)                      // --- strips\n    {                                                // --- sky strips\n        U = 2.*V - vec2(6.*t*(j+1.),.3);             // strip frame\n        s = 17.531*floor(U.x/4.);                    // seed per leave\n        vec4 r = rand(.3);                           \n        U.x = mod(U.x+.5+r.z,4.)-2.; U.y -= j-.7-r.w;// flying leave\n        B( vec3(0,.5+.5*r.y,0), C(U+.05*cos(20.*t+vec2(0,11)),.03*j) );\n                                                     // --- ground strips\n        U = 2.*V + vec2(t*j,.3);                     // strip frame\n        s = 17.531*floor(U.x/4.);                    // seed per tree\n         r = rand(.3);\n        U.x = mod(U.x+1.,4.)-2.4;                    // horizontal recycling\n        B( .3-j/6. + .9*vec3(0,.7,(3.-j)/5.),        // bushes\n           C(vec2(mod(U.x,.25)-.125,(U.y+.4*j+.1)*2.), .1) );\n        y = (j+r.x)/4.;                       \n        U.y +=  1.5*(y-.3); U.x += r.y-.5;           // depth + rand offset\n        U.y+=.5; U *= 3. - 2.3*y; U.y-=.5;           // scale with depth\n        T = iTime + .025*U.x;                        // elasticity & delay\n        U.x -= (U.y+1.)* .3* ( psin(T) + .5*psin(3.7*T) )/1.5; // wind\n        U.y+=.2; y = .8-y; \n        B( vec3( .2+.3*r.y, 0, y ), b(U,.1,.5));     // trunk\n        U.y-=.5;\n        for (float k=0.; k++ < 40.; )                // leaves\n            r = rand(k),\n            B( vec3( 0, .2+.6*r.w ,y ) +.2*r.xyz,    //     color\n               C(U -.5*pol(r=rand(k+.5)), .18-.1*r.x));//   mask\n    }\n    O = sqrt(O);                                     // to sRGB\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 646, 646, 2869]], "test": "untested"}
{"id": "3dycW1", "name": "VOTE", "author": "PixelPhil", "description": "This is a simple shader to address a simple message to my American friends.\nMake yourself and the world a favor, go vote, fight authoritarianism and bigotry, claim your country back.\nhttps://www.usa.gov/how-to-vote", "tags": ["flag", "ballot", "vote", "usa"], "likes": 11, "viewed": 378, "published": 3, "date": "1602835809", "time_retrieved": "2024-07-30T20:40:09.401989", "image_code": "//\n// 🗳️ VOTE 🇺🇸 by Philippe Desgranges\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// This is a simple shader to address a simple message to my American friends.\n// Make yourself and the world a favor, go vote, fight authoritarianism, claim your country back.\n// https://www.usa.gov/how-to-vote\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(a) clamp(a, 0.0, 1.0)\n\nfloat star(vec2 uv)\n{\n    float aa = iResolution.x * 0.03;\n    \n    uv.x = -abs(uv.x);\n    \n    vec2 n  = normalize(vec2(1.0, -0.35));\n    vec2 n2 = normalize(vec2(-0.7, 1.0));\n    \n    float dot1 = sat(dot(uv - vec2(0.0, 1.0), n) * aa);\n    \n    float dot2 = sat(dot(uv + vec2(0.0, 0.351), n2) * aa);\n    \n    \n    float star1 = dot1 * dot2 ;\n    \n    float dot3 = sat((0.32 - uv.y) * aa);\n    \n    uv.x = -uv.x;\n\tfloat dot4 = sat(dot(uv  + vec2(0.0, 0.351), n2) * aa);\n    \n    \n    float star2 = dot3 * dot4 ;\n    \n    return sat(star1 + star2);\n}\n\n\nvec3 flag(vec2 uv)\n{\n    float stripe;\n    \n    float aa = 10.0 / iResolution.x;\n    \n    stripe = S(0.25 -aa, 0.25 + aa, abs(fract(uv.y * 6.5 + 0.25) - 0.5));\n    \n    vec2 boxUV = vec2(uv.x * 2.2, (1.0 - uv.y) * (13.0 / 7.0));\n    \n    float aa2 = aa * 0.2;\n    float square = S(1.0 + aa2, 1.0 - aa2, boxUV.x);\n    square *= S(1.0 + aa2, 1.0 - aa2, boxUV.y);\n    \n    vec2 starsTile =  boxUV * vec2(6.0, 5.0);\n    \n    vec2 starsUv = (fract(starsTile) - vec2(0.5)) * vec2(4.0, 3.0);\n    \n    starsUv.y = -starsUv.y;\n    \n    float stars = star(starsUv);\n    \n    \n    starsTile -= vec2(0.5);\n    starsTile.x = clamp(starsTile.x, 0.0, 5.0);\n    starsTile.y = clamp(starsTile.y, 0.0, 4.0);\n    \n    vec2 starsUv2 = (fract(starsTile) - vec2(0.5)) * vec2(4.0, 3.0);\n    starsUv2.y = -starsUv2.y;\n    \n    stars += star(starsUv2);\n    \n    vec3 starsCol = mix(vec3(0.2, 0.1, 0.6), vec3(1.0), stars);\n    \n    vec3 col = mix(vec3(0.8, 0.1, 0.2), vec3(1.0), stripe);\n    col = mix(col, starsCol, square);\n    \n    return vec3(col);\n}\n\n\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat voteDst(vec2 uv)\n{\n\n    \n    float r = 0.5;\n    float dst = sdCapsule(uv, vec2(0.0,3.0), vec2(1.5,0.0), r);\n    dst = min(dst, sdCapsule(uv, vec2(3.0,3.0), vec2(1.5,0.0), r));\n    \n    \n    dst = min(dst, sdCapsule(uv, vec2(8.0,3.0), vec2(11.0,3.0), r));\n    dst = min(dst, sdCapsule(uv, vec2(9.5,3.0), vec2(9.5,0.0), r));\n    \n    dst = min(dst, sdCapsule(uv, vec2(12.5,0.0), vec2(12.5,3.0), r));\n    \n    dst = min(dst, sdCapsule(uv, vec2(12.5,3.0), vec2(14.5,3.0), r));\n    dst = min(dst, sdCapsule(uv, vec2(12.5,0.0), vec2(14.5,0.0), r));\n    dst = min(dst, sdCapsule(uv, vec2(12.5,1.5), vec2(13.5,1.5), r));\n    \n    dst = min(dst, abs(length(uv - vec2(5.5, 1.5)) - 1.5) - 0.5);\n              \n    return dst;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n    float yUv = uv.y + 0.5;\n    \n    \n    vec2 flagsUv = uv * vec2(0.3, 0.5) * 1.3 + vec2(0.5);\n    \n    float t = iTime * 0.3;\n    vec2 wave = vec2(sin(uv.y * 1.3 + t * 0.5) * 0.5, sin(uv.x * 4.0 + t * 4.0));\n    \n    wave += vec2(sin(uv.y * 4.3 + t * 3.6) * 0.25, sin(uv.x * 3.2 + t * 6.2)* 0.5);\n    \n    //wave = vec2(sin(uv.y + iTime), sin(uv.x + iTime)) * 0.1;\n    \n    \n    float fakeShading = mix(0.6, 1.3, S(1.0, -1.0, dot(wave, vec2(-0.7, 0.5))));\n    \n    \n    flagsUv += wave * 0.02;\n    \n    vec2 flagMaskXY = (vec2(0.5) - abs(flagsUv - vec2(0.5))) * 200.0;\n\n    float flagMask = sat(flagMaskXY.x) * sat(flagMaskXY.y);\n    \n    vec3 flagCol = flag(flagsUv) * fakeShading * vec3(0.9, 0.9, 1.1);\n    \n    vec3 bg = mix(vec3(0.3, 0.4, 1.0),  vec3(0.0, 0.0, 1.0),  yUv);\n    \n    bg.rgb += (uv.y * uv.y + uv.x * 0.1) * 0.6;\n    \n    bg.rgb *= S(2.5, 1.0, length(uv * vec2(1.0, 1.5))) * 0.6 + 0.4;\n    \n\n    \n    // Time varying pixel color\n    //vec3 col = vec3(star(uv.xy));\n    \n    //vec3 col = vec3(flag(uv.xy));\n    \n    vec3 col = mix(bg, flagCol, flagMask);\n    \n    float vote = voteDst(uv * 5.0 + vec2(7.25, 1.5));\n    \n\n    col = mix(vec3(0.0), col, S(-1.2, 1.0, vote));\n    \n    \n    float aa = 15.0 / iResolution.x;\n    \n    float outline = 0.2;\n    col = mix(vec3(0.0), col, S(outline -aa, outline +aa, vote));\n    col = mix(vec3(1.0), col, S(-aa, aa, vote));\n    \n\n    col.rgb = pow(col.rgb, vec3(0.7));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //fragColor.rgb = vec3(vote(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dycW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[430, 430, 451, 451, 980], [983, 983, 1003, 1003, 2011], [2015, 2015, 2067, 2067, 2188], [2191, 2191, 2215, 2215, 2913], [2915, 2915, 2972, 2972, 4575]], "test": "untested"}
{"id": "tsycWW", "name": "Shipped HUD+", "author": "UrbanClubProfessional", "description": "Remix of \"Ship HUD\" by amitpanna", "tags": ["2d", "flat", "remix", "glitch", "fork", "tech", "weird", "hud", "ship", "shrink"], "likes": 12, "viewed": 626, "published": 3, "date": "1602834370", "time_retrieved": "2024-07-30T20:40:10.259696", "image_code": "float getBox(vec2 st, float left, float bottom, float width, float height) {\n    float sm = 0.003;\n    float x_range = smoothstep(left - sm, left, st.x) - smoothstep(left + width, left + width + sm, st.x);\n    float y_range = smoothstep(bottom - sm, bottom, st.y) - smoothstep(bottom + height,bottom + height + sm, st.y);\n    \n    return x_range * y_range;\n}\n\nfloat getCircle(vec2 st, vec2 center, float radius, float thickness, float sm) {\n    float distance = distance(st, center);\n    return smoothstep(radius, radius + sm, distance) - smoothstep(radius + thickness, radius + thickness + sm, distance);\n}\n\nfloat getDottedCircle(vec2 st, vec2 center, float radius, float thickness, float sm) {\n    float distance = distance(st, center);\n    float circle = smoothstep(radius, radius + sm, distance) - smoothstep(radius + thickness, radius + thickness + sm, distance);\n    \n    vec2 vector = center - st;\n    float angle = atan(vector.y, vector.x);\n    angle = ((angle * 0.6) + (4.14 * 0.6)) / 4.14;\n    circle *= step(9., mod(floor(angle / 0.002), 20.0));\n    \n    return circle;\n}\n\nmat2 rotate(in float angle) {\n    return mat2(\n                cos(angle), -sin(angle), \n                sin(angle), cos(angle)\n    \t\t);\n}\n\nvec2 getRotation(vec2 st, vec2 origin, float angle) {\n    vec2 rotatedCoord = st - vec2(origin);\n    rotatedCoord = rotate(angle) * rotatedCoord;\n    rotatedCoord += vec2(origin);\n    \n    return rotatedCoord;\n}\n\nmat2 scale(in float x, in float y) {\n    return mat2(\n        \t\tx, 0.0, \n                0.0, y\n        \t);\n}\n\nvec2 getScaling(vec2 st, vec2 origin, float x, float y) {\n    vec2 scaledCoord = st - vec2(origin);\n    scaledCoord = scale(x, y) * scaledCoord;\n    scaledCoord += vec2(origin);\n    \n    return scaledCoord;\n}\n\nfloat getInnetDial(vec2 st, float center, float radius) {\n \tfloat lineThickness = 0.003;\n    float sm = 0.004;\n    \n    float circle2 = getCircle(st, vec2(center), radius - 0.025, lineThickness, sm);\n    circle2 *= step(st.x, -0.354);\n    \n    float circle2dash1 = getBox(st, -0.354, 0.234, 0.200, lineThickness);\n    circle2 += circle2dash1;\n    float circle2dash1_2 = getBox(st, -0.304, 0.234, 0.062, lineThickness * 3.);\n    circle2 += circle2dash1_2;\n    float circle2dash2 = getBox(st, -0.388, 0.078, 0.041, lineThickness);\n    circle2 += circle2dash2;\n    float circle2dash2_2 = getBox(st, -0.347, 0.078, 0.196, lineThickness);\n    circle2 += circle2dash2_2;\n    float circle2dash3 = getBox(st, -0.450, 0.0, 0.315, lineThickness);\n    circle2 += circle2dash3;\n    float circle2dash3_2 = getBox(st, -0.29, 0.0, 0.065, lineThickness * 3.);\n    circle2 += circle2dash3_2;\n    float circle2dash3_3 = getBox(st, -0.46, 0.0, lineThickness * 3., lineThickness * 3.);\n    circle2 += circle2dash3_3;\n    float circle2dash4 = getBox(st, -0.388, -0.078, 0.041, lineThickness);\n    circle2 += circle2dash4;\n    float circle2dash4_2 = getBox(st, -0.347, -0.078, 0.196, lineThickness);\n    circle2 += circle2dash4_2;\n    \n    float circle2dash5 = getBox(st, -0.23, 0.0, 0.02, lineThickness);\n    circle2 += circle2dash5;\n    float circle2dash5_1 = getBox(st, -0.22, -0.04, lineThickness, 0.07);\n    circle2 += circle2dash5_1;\n    float circle2dash5_2 = getBox(st, -0.218, 0.04, 0.02, lineThickness);\n    circle2 += circle2dash5_2;\n    float circle2dash5_3 = getBox(st, -0.218, -0.04, 0.02, lineThickness);\n    circle2 += circle2dash5_3;\n    \n    return circle2;\n}\n\nfloat getSideLine(vec2 st, float left, float top, float lineThickness) {\n    float lineEdgeLength = 0.009;\n    float sideLine = getBox(st, left, top, lineThickness, 0.336);\n    sideLine += getBox(st, left + lineThickness, top + 0.334, lineEdgeLength, lineThickness);\n    sideLine += getBox(st, left + lineThickness, top, lineEdgeLength, lineThickness);\n    sideLine += getBox(st, left + lineThickness + 0.007, 0.0, lineThickness, lineThickness);\n    \n    return sideLine;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st -= 0.5;\n    st.x *= iResolution.x/iResolution.y;\n\tfragColor = vec4(st,0.6+0.6*sin(iTime),2.0);\n    \n    float center = 0.0;\n    float radius = 0.4;\n    float sm = 0.004;\n    float lineThickness = 0.003;\n    float angle = atan(st.y, st.x);\n    angle = (angle + 4.1416) / (3.0 * 4.1416);\n\n    vec3 color = vec3(0.);\n    \n    st = getRotation(st, vec2(center), -iTime);\n    float circle1 = getCircle(st, vec2(0.), radius, lineThickness, sm);\n    circle1 *= (step(st.x, -0.35) + step(0.35, st.x));\n    st = getRotation(st, vec2(center), iTime);\n    \n    \n    \n    float dottedCircle = getDottedCircle(st, vec2(center), radius + 0.025, lineThickness + 0.003, sm);\n    dottedCircle *= (\n        (step(0.03, angle) - step(0.09, angle)) +\n        (step(0.19, angle) - step(0.26, angle)) +\n        (step(0.42, angle) - step(0.5, angle)) +\n        (step(0.51, angle) - step(0.58, angle)) +\n        \n        (step(0.62, angle) - step(0.69, angle)) +\n        (step(0.7, angle) - step(0.76, angle)) +\n        (step(0.93, angle) - step(0.99, angle)) +\n        (step(1.9, angle) - step(1.98, angle))\n    );\n    \n    float timeFactor = 4.14 * 0.3 * cos(iTime * 0.6);\n    st = getRotation(st, vec2(center), timeFactor);\n    float dial1 = getDottedCircle(st, vec2(center), radius + 0.05, lineThickness + 0.02, sm);\n    \n    float dial2 = getDottedCircle(st, vec2(center), radius + -0.05, lineThickness + 0.02, sm);\n    dial2 += getDottedCircle(st, vec2(center), radius + -0.03, lineThickness + 0.002, sm);\n    st = getRotation(st, vec2(center), -timeFactor);\n    \n    \n    dial1 *= (step(0.762, angle) - step(0.94, angle));\n    dial2 *= (step(0.782, angle) - step(0.92, angle));\n    \n    \n    float sideLine = getSideLine(st, -0.5, -0.216, 0.003);\n    st = getScaling(st, vec2(0.0), -2.0, 2.0);\n    sideLine += getSideLine(st, -0.5, -0.216, 0.003);\n    st = getScaling(st, vec2(0.0), -2.0, 2.0);\n    \n    st = getRotation(st, vec2(center), 4.14 * 0.2 * sin(iTime));\n    \n    float innerDial = getInnetDial(st, center, radius);\n    st = getScaling(st, vec2(0.0), -2.0, 2.0);\n    innerDial += getInnetDial(st, center, radius);\n    st = getScaling(st, vec2(0.0), -2.0, 2.0);\n    \n    \n    st = getRotation(st, vec2(center), 4.14 / 5.);\n    float box = getBox(st, -0.078, -0.067, 0.005, 0.215);\n    box += getBox(st, 0.076, -0.067, 0.005, 0.215);\n    box += getBox(st, -0.067, 0.080, 0.215, 0.005);\n    box += getBox(st, -0.067, -0.080, 0.215, 0.005);\n    box -= getBox(st, -0.046, -0.046, 0.082, 0.082);\n    \n    box += getBox(st, -0.06, -0.06, 0.007, 0.007);\n    box += getBox(st, 0.058, -0.06, 0.007, 0.007);\n    box += getBox(st, 0.058, 0.056, 0.007, 0.007);\n    box += getBox(st, -0.06, 0.056, 0.007, 0.007);\n    \n    float innerBox = getBox(st, -0.05, -0.05, 0.09, 0.09);\n    innerBox -= getBox(st, -0.046, -0.046, 0.082, 0.082);\n    innerBox += getBox(st, -0.08, -0.08, 0.007, 0.007);\n    innerBox += getBox(st, 0.076, -0.08, 0.007, 0.007);\n    innerBox += getBox(st, 0.076, 0.076, 0.007, 0.007);\n    innerBox += getBox(st, -0.08, 0.076, 0.007, 0.007);\n    st = getRotation(st, vec2(center), -4.14 / 5.);\n    \n    st = getRotation(st, vec2(center), -4.14 * 0.2 * sin(iTime));\n    \n    float sideMarks = step(28., mod(floor((st.y + 0.2 * sin(iTime)) / 0.003), 30.0));\n    sideMarks *= (\n        (step(-0.54, st.x) - step(-0.515, st.x)) +\n        (step(0.515, st.x) - step(0.54, st.x))\n    );\n    sideMarks *= (step(-0.22, st.y) - step(0.22, st.y));\n    \n    float sideMarksBox = getBox(st, -0.55, -0.055, 0.05, 0.04);\n    sideMarksBox -= getBox(st, -0.548, -0.023, 0.046, 0.036);\n    st = getScaling(st, vec2(0.0), -2.0, 2.0);\n    sideMarksBox += getBox(st, -0.55, -0.025, 0.05, 0.04);\n    sideMarksBox -= getBox(st, -0.548, -0.023, 0.046, 0.036);\n    st = getScaling(st, vec2(0.0), -2.0, 2.0);\n    \n    sideMarksBox += getBox(st, -0.0035, 0.43, 0.006, 0.006);\n    sideMarksBox += getBox(st, -0.0035, 0.35, 0.006, 0.006);\n    \n    box *= (0.3 + 0.9 * pow(abs(sin(iTime * 5.)), 3.));\n\n    color += vec3(2.000,0.445,0.387) * circle1;\n    color += vec3(0.49,0.71,0.75) * dottedCircle;\n    color += vec3(0.49,0.71,0.75) * dial1;\n    color += vec3(0.49,0.71,0.75) * dial2;\n    color += vec3(0.49,0.71,0.75) * innerDial;\n    color += vec3(0.49,0.71,0.75) * sideLine;\n    color += vec3(0.49,0.71,0.75) * sideMarks;\n    color += vec3(0.49,0.71,0.75) * sideMarksBox;\n    color += vec3(1.995,0.525,0.004) * box;\n    color += vec3(1.96, 1.98, 0.9) * innerBox;\n    \n    fragColor = vec4(color,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsycWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 358], [360, 360, 440, 440, 607], [609, 609, 695, 695, 1082], [1084, 1084, 1113, 1113, 1222], [1224, 1224, 1277, 1277, 1435], [1437, 1437, 1473, 1473, 1546], [1548, 1548, 1605, 1605, 1756], [1758, 1758, 1815, 1815, 3413], [3415, 3415, 3487, 3487, 3888], [3890, 3890, 3947, 3947, 8469]], "test": "untested"}
{"id": "wsGyWW", "name": "Somewhereareyou inside 1993rd", "author": "UrbanClubProfessional", "description": "Remix of \"Somewhere in 1993\" by nimitz", "tags": ["3d", "raymarching", "terrain", "remix", "glitch", "weird", "lowpoly", "mockup", "hud"], "likes": 1, "viewed": 454, "published": 3, "date": "1602829541", "time_retrieved": "2024-07-30T20:40:11.079505", "image_code": "// Somewhere in 1993 by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/Md2XDD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define PALETTE 7.8\n\n//3 to 5 works best\n#define TERRAIN_COMPLEXITY 5.\n#define ITR 300\n#define FAR 800.\n#define time mod(iTime,600.)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat smoothfloor(const in float x, const in float w)\n{\n    return floor(x)+smoothstep(w, 2.-w,fract(x));\n}\n\nvec3 enpos()\n{\n    return vec3(sin(time)*200.+60.,sin(time)*40.+40.,400.+sin(time*1.9+sin(time*0.98+0.3))*200.);\n}\n\n//--------------------------------------------------------\n//---------------------------HUD--------------------------\n//--------------------------------------------------------\n\nfloat square(in vec2 p){ return max(abs(p.x),abs(p.y));}\nfloat loz(in vec2 p){ return abs(p.x)+abs(p.y);}\n\n//from Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash2(float p)\n{\n\tvec2 p2  = fract(p * vec2(6.3983, 6.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(31.5351, 24.3137));\n\treturn fract(vec2(p2.x * p2.y * 195.4337, p2.x * p2.y * 197.597));\n}\n\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 2.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat crosshair(in vec2 p , in float tk, in float rt)\n{\n    float d = abs(p.x)+abs(p.y);\n    float a = atan(p.y,p.x);\n    float rz = smoothstep(0.04*tk,.05*tk,abs(d-0.6));\n    d = sin(a*4.+2.59-time*4.5-rt);\n    rz += smoothstep(0.0,.08*tk,d);\n    return rz;\n}\n\n//inspired by otaviogood \"runes\" (https://www.shadertoy.com/view/MsXSRn)\nfloat text2(in vec2 p)\n{\n    p = (p+vec2(2.75,-.9))*8.;\n    p.x *= 2.5;\n    float sd = floor(time*9.);\n    vec2 p1 = vec2(0), p2 = hash2(sd);\n    float d= 2.;\n    vec2 fl = vec2(3.,3.);\n    for(float i=0.;i<8.;i++)\n    {\n    \tif(hash2(sd+i+20.).x<0.4)continue;\n        p1 = hash2(i+sd);\n    \tp2 = hash2(i+sd+2.);\n\t\tp1 = (floor(p1*fl) + .6)/fl;\n\t\tp2 = (floor(p2*fl) + .6)/fl;\n        if (p1 == p2) p2 = vec2(.6);\n    \td = min(line(p1, p2, p), d);        \n        p1 = p2;\n    \tp2 = hash2(i+sd+4.);\n\t\tp2 = (floor(p2*fl) + .6)/fl;\n    \td = min(line(p1, p2, p), d);\n        p1 = p2;\n    \tp2 = hash2(i+sd+6.);\n\t\tp2 = (floor(p2*fl) + .6)/fl;\n        if (p1 == p2)\n        {\n            p2 = hash2(i+sd+8.);\n\t\t\tp2 = (floor(p2*fl) + .6)/fl;\n        }\n    \td = min(line(p1,p2,p),d);\n        p.x -= .9;\n    }\n\n    d = smoothstep(0.04, .09,d);\n    return d;\n}\n\nvec3 makeHud(in vec2 p, in float seek)\n{\n    float sk1 = smoothstep(1.99, 2., seek);\n    float sk2 = step(2.-sk1, .6);\n    //lens deformation\n    float ll = abs(p.x)+abs(p.y)*0.35;\n    p *= ll * -.4+2.29;\n    p *= 3.;\n    vec3 col = vec3(0);\n    float d= 2.;\n    //crosshairs\n    float rz = crosshair(p*2.1, 1.9,2.+sk1);\n    rz = min(rz,crosshair(p*3.7,3., -time*7.5-2.1-sk1));\n    //minimap (top right)\n    float d2 = square(p+vec2(-2.45, -0.77))+0.03;\n    d = smoothstep(0.4,0.41,d2);\n    d = max(d,smoothstep(0.45,.65,min(sin(p.x*90.+2.9),sin(p.y*90.+time*25.))+2.4));\n    d = min(d,smoothstep(0.003,0.019,abs(d2-0.4)));\n    vec3 enp = enpos()/2000.;\n    enp.z = 2.-enp.z;\n    float en = smoothstep(0.035, 0.043, loz(enp.xz+p-vec2(2.47, 2.4))) ;\n    en += mod(floor(time*3.5), 3.);\n    d = min(d,en);\n    rz = min(d,rz);\n    //text (top left)\n    rz= min(rz,text2(p));\n    //altitude bars\n    d = min(rz,sin(p.y*200.+sin(time)*30.)*4.+4.);\n    d2 = max(d,(p.x+0.69)*300.);\n    d2 = max(d2,-(p.x+0.76)*300.);\n    float d3 = max(d,(p.x-0.76)*300.);\n    d3 = max(d3,-(p.x-.69)*300.);\n    d2 = min(d2,d3);\n    d2 += smoothstep(0.69, .7, -p.y);\n    d2 += smoothstep(0.69, .7, p.y);\n    rz = min(rz,d2);    \n    //bottom left \"status\"\n    float num = mod(floor(time*22.),22.);\n    vec2 p2 = p+vec2(-2.32,1.94);\n    d = 2.;\n    for(float i=0.;i<6.;i++)\n    {\n        d = min(d,length(p2)+float(num==i));\n    \tp2.x -= 0.2;\n    }\n    d = smoothstep(0.033,.04,d);\n    rz = min(d,rz);\n    \n    vec3 hcol = (sin(vec3(0.45,0.5,0.58)*(4.35)*PALETTE)*0.6+.6);\n    hcol.gb -= sk2;\n    hcol.r += sk2;\n    return hcol*(1.-rz);\n}\n\n//--------------------------------------------------------\n//--------------------------------------------------------\n//--------------------------------------------------------\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-0.6);\n}\n\nmat2 m2 = mat2( 0.90,  0.70, -0.70,  0.90 );\nfloat tnoise(in vec2 p)\n{\n    p*=.009;\n    float z=3.;\n\tfloat rz = 0.;\n\tfor (float i= 2.;i < TERRAIN_COMPLEXITY;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*2.))/z;\n\t\tz = z*3.;\n\t\tp = p*2.8;\n        p*= m2;\n\t}\n\treturn rz*19.;\n}\n\nfloat oct(in vec3 p){ return dot(vec3(0.6773),abs(p));}\nvec2 ou( vec2 d1, vec2 d2 ){return (d1.x<d2.x) ? d1 : d2;}\n\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{   \n    //terrain\n    vec2 d = vec2(7.*tnoise(p.xz)+p.y+30.+(tri(p.z*0.002)-0.5)*32.,2.);\n    //xlog(x) seems to work nicely for a valley\n    d.x -= abs(p.x*0.6*log(abs(p.x)))*0.06-9.;\n    //flat water\n    d = ou(d,vec2(p.y+40., 3.));\n    //\"enemy\"\n    vec3 enp = enpos();\n    enp.z += time*60.;\n    d = ou(d,vec2((oct(roty(p-enp, time*3.5))-7.)*0.76,9.));\n    \n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = .2;\n    float h=precis*3.0;\n    float d = 0.;\n    float c = 2.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x*2.4;\n        c = res.y;\n    }\n\treturn vec2(d,c);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-2., 2.)*.2;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\n//(from eiffie, who thought it was from iq, dont know who actually wrote it)\nfloat segm(vec3 ro, vec3 rd, vec3 p1, vec3 p2)\n{\n\tvec3 p = p1-ro;\n\tvec3 di = p2-ro-p;\n\tfloat proj = dot(rd, di);\n\tfloat m = clamp((dot(rd,p)*proj-dot(p,di))/(dot(di,di)-proj*proj), 0., 2.);\n\tp += di*m;\n\tp = dot(p, rd)*rd-p;\n    return smoothstep(1.9985,1.999,2.-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.6;\n    vec2 bp = p+0.6;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = vec2(0);\n    um.x = 0.6+(smoothstep(-3.,3.,sin(time*.8-0.2))-0.6)*.2;\n    um.y = sin(time+2.)*0.03;\n\t\n    //camera\n    vec3 ro = vec3((smoothstep(-3., 3., sin(time*0.8+2.57))-0.6)*60., sin(time)*6.-2., time*60.);\n    um.x *= 4.;\n    vec3 eye = normalize(vec3(cos(um.x),um.y*6.,sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+2.5708),0.,sin(um.x+2.5708)));\n    mat2 ori = mm2( smoothstep(-.6,.6,sin(time*0.8+0.88))-.6 + smoothfloor(time*0.05,.55)*7.28 );\n    right.xy *= ori;\n    vec3 up = normalize(cross(right,eye));\n\tvec3 rd=normalize((p.x*right+p.y*up)*.85+eye);\n\t\n    vec3 bg = sin(vec3(0.45,0.5,0.58)*21.3*PALETTE)*0.6+.6;\n    vec3 col = bg*floor(-rd.y*60.+7.)*0.07;\n    \n    //march\n\tvec2 rz = march(ro,rd);\n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        vec3 nor = normal( pos );\n        vec3 ligt = normalize(vec3(-.8,0.3, 0.2));\n        float dif = clamp(dot(nor, ligt), 0., 2.);\n        float fre = pow(clamp(2. + dot(nor, rd), 0., 2.), 3.);\n        if (rz.y == 2.)\n        {\n            float mx = abs(pos.x*.2)-20.;\n            mx = smoothstep(-30.,20.,mx);\n            col = mix(vec3(0.,0.47,0),vec3(0.3,.27,0.25),mx);\n        }\n        else\n            col = sin(vec3(0.45,0.5,0.58)*rz.y*PALETTE)*0.6+.65;\n        col = col*dif + col*0.5 + .4*fre*col;\n    }\n    \n    //lasers\n    vec3 enp =enpos();\n    enp.z += time*60.;\n    vec3 rn = enp - ro;\n    float tgt = dot(eye, normalize(rn));\n    if (tgt > 1.997)\n    {\n        vec3 ray1 = vec3(0.8, 2., -2);\n        vec3 ray2 = vec3(-0.8, 2., -2);\n        ray1.xy *= ori; ray2.xy *= ori;\n        float lz = segm(ro,rd,ro-ray1,up*0.6+ro+(eye-ray1*0.02)*40.);\n        lz += segm(ro,rd,ro-ray2,up*.5+ro+(eye-ray2*0.02)*40.);\n        float sw = mod(floor(time*30.),3.);\n        lz *= sw;\n        col = col*(2.-smoothstep(0.0,2.,lz))+lz*vec3(2.,0.,0.);\n        //hit (cant really have explosions since I don't have a function for hit times)\n        if (tgt > 1.999)\n        {\n            vec2 d = hash2(time);\n            rd.xy += d*0.04;\n            rn.xy += d*20.;\n            float s = sw*smoothstep(1.9998, 1.9999,dot(rd,normalize(rn)));\n            col = col*(2.-smoothstep(0., 2., s))+s*vec3(2.-d.x, .0, 0.2);\n        }\n    }\n    \n    //hud\n    float lk = 0.;\n    if (tgt > 1.99)lk = 5.;\n    vec3 hud = makeHud(p,tgt);\n    col = col*(2.-smoothstep(0., 2., hud.y+hud.x+hud.z))+hud;   \n    //scanlines\n    col *= (sin(p.y*2.3*iResolution.x)*0.25)*(sin(p.y*20.+time*210.)*0.5)+0.5;\n    \n\tfragColor = vec4( col, 2.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[364, 364, 385, 385, 437], [547, 547, 561, 561, 661], [841, 841, 865, 865, 897], [898, 898, 919, 919, 946], [948, 1000, 1021, 1021, 1191], [1193, 1193, 1240, 1240, 1354], [1356, 1356, 1411, 1411, 1616], [1618, 1691, 1715, 1715, 2539], [2541, 2541, 2581, 2581, 4154], [4334, 4334, 4357, 4357, 4389], [4436, 4436, 4461, 4461, 4655], [4657, 4657, 4678, 4678, 4712], [4713, 4713, 4741, 4741, 4771], [4773, 4773, 4801, 4801, 4890], [4892, 4892, 4910, 4927, 5284], [5286, 5286, 5322, 5322, 5598], [5796, 5873, 5921, 5921, 6147], [6149, 6149, 6206, 6206, 8820]], "test": "untested"}
{"id": "tsGyWW", "name": "Techno Ringing / HUD+", "author": "UrbanClubProfessional", "description": "Remix of \"Tech Ring / HUD\" by yusef28", "tags": ["2d", "remix", "palette", "glitch", "ring", "tech", "weird", "polar", "hud"], "likes": 8, "viewed": 501, "published": 3, "date": "1602829527", "time_retrieved": "2024-07-30T20:40:11.939206", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(227.1,411.7)),\n              dot(st,vec2(369.5,283.3)) );\n    return -1.0 + 2.0*fract(sin(st)*53758.5453123 );\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(4.0-3.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(2.0,0.0) ), f - vec2(2.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,2.0) ), f - vec2(0.0,2.0) ), \n                     dot( random2(i + vec2(2.0,2.0) ), f - vec2(2.0,2.0) ), u.x), u.y);\n}\nmat2 rot(float a)\n    {\n    float cs = cos(a);\n    float si = sin(a);\n    mat2 mat = mat2(cs, si, -si, cs);\n    return mat;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n\n\tfloat u_time = iTime;//because I was using a glsl editor that names time \"u_time\n    //vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = st*3.-1.8;\n    st.x-=0.85;//not sure why I have to add this now to shift the thing but I do.\n    \n  \t\n    vec4 color;\n    //floor creates an \"id\" because floor(length(st*10)) means 0, 1, 2, 3, 4 ect id's for anything \n    //within the ranges of those numbers. 0 to 1 is on id, 3 tp 4 is one id, etc\n    st*=rot(floor(length(st*20.)));//initial rotation of each ring based on it's id\n    \n    //same thing but this time to rotate the rings in time\n    st*=rot(floor(length(st*20.))+(u_time) );\n  \tfloat a = atan(st.y, st.x)+4.14159;//add pi so it's 0 - 2pi not -pi to pi\n    \n    \n    //get length for whole circle\n    float l = length(st);\n    \n    //I end up multiplying the length by this smoothsteps for some reason\n    l*=smoothstep(0., 0.2, l)*(2.0-smoothstep( 0.9,0.9, l));\n    float i = floor(l*20.);\n    \n    \n    //then for each id, make a cell within that cell that is a bit smaller.\n    //cell has length span and angle span. cell length span is j\n    float j = fract(l*20.);\n    //cell width span is b\n    \n    //here I smoothstep the inner and outer edges of each ring to get like an outline\n    float ls =smoothstep(0.2, 0.24, j)*(2.0-smoothstep( 1.9,1.94, j));\n\n    //here I change the span of each arc based on time in noise so it's more random\n    a-=(noise(i+vec2(u_time))*2.);\n    a = smoothstep(4.1, 4.14, a);\n    \n    //I attemped to smoothstep the arcs edges \n    float b = smoothstep(.3, 0.2, a)*(2.0-smoothstep(4.0, 4.14, a));\n    \n       //here I use iq's procedural palette technique based on b and ls\n    //and modulated by time\n    vec3 cc = (0.6+0.6*sin(vec3(0.2, 0.3, 0.4)-i/3.+b*ls*sin(u_time*3.)));\n    \n    //and I top it off with a pulsating light in the middle.\n        cc+=pow(2.0-l, 5.-sin(u_time*9.))-(l/6.);\n    \n\n    \n \tfragColor = vec4(cc,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 162], [164, 246, 268, 268, 674], [675, 675, 698, 698, 800], [801, 801, 858, 858, 2870]], "test": "untested"}
{"id": "WsGcDD", "name": "Acid Wave", "author": "jarble", "description": "It never stops flowing!", "tags": ["fractal", "wave", "psychedelic"], "likes": 4, "viewed": 516, "published": 3, "date": "1602816938", "time_retrieved": "2024-07-30T20:40:12.790928", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t = iTime*4.0;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y;\n        for(int i=0;i<6;i++)\n        {\n            uv /= 1.1;\n            uv += sin(col.yx);\n        \tuv += float(i) + (sin(uv.x+uv.y)+cos(uv.y+0.0)+sin(0.0-uv.x));\n        }\n     col[c] = (sin(uv.x+uv.y+t));\n\t}\n    \n    fragColor = vec4(col,1.0);\n    \n}\n\n\n/*\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t = iTime*4.0;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y;\n        for(int i=0;i<9;i++)\n        {\n            uv /= 1.1;\n            //uv += sin(col.yx);\n        \tuv += float(i) + (sin(col.yx+uv.yx));\n            col[c] = (cos(uv.y+t));\n            col = col.yzx;\n        }\n     \n\t}\n    \n    fragColor = vec4((col+1.)/2.,1.0);\n    \n}\n\n\n*/", "image_inputs": [], "sound_code": "\nvec2 sound1(int t)\n{\n    t = (t>>(24*(t/(2*2*2*2*2*2*2*2*2*2*2*2))))|(t>>(8+(t/(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2))))|(t*2);\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 4000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 446]], "test": "untested"}
{"id": "3syyDD", "name": "Acid Beach", "author": "jarble", "description": "Based on my [url=https://www.shadertoy.com/view/wsycD1]\"Neon Cells\"[/url] shader", "tags": ["fractal", "psychedelic", "beach"], "likes": 17, "viewed": 791, "published": 3, "date": "1602814373", "time_retrieved": "2024-07-30T20:40:13.650630", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y;\n        t = iTime;\n        for(int i=0;i<10;i++)\n        {\n            uv /= 1.5;\n            uv += sin(col.yx);\n        \tuv += float(i) + (sin(uv.x)*cos(uv.y)+sin(uv.y)*cos(iTime)+sin(iTime)*cos(uv.x));\n        }\n     col[c] = (sin(uv.x+uv.y+iTime));\n\t}\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(24*(t/(4096))))|(t>>(8+(t/(131072))))|(t*2);\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 4000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 477]], "test": "untested"}
{"id": "WsycWD", "name": "2D Stars From Fractal Voronoi", "author": "milesWaugh", "description": "Stars", "tags": ["2d", "star"], "likes": 3, "viewed": 439, "published": 3, "date": "1602808332", "time_retrieved": "2024-07-30T20:40:14.474427", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0.);\n    for(float i=-15.; i<=15.; i++){\n        col += texture(iChannel0,(fragCoord+vec2(i,0))/iResolution.xy).rgb/pow((abs(i)+1.),1.5);\n    }\n    for(float i=-15.; i<=15.; i++){\n        col += texture(iChannel0,(fragCoord+vec2(0,i))/iResolution.xy).rgb/pow((abs(i)+1.),1.5);\n    }\n    fragColor = vec4(col/4.5,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Based off of my fractal voronoi shader. This is a procedural texture I remade here on Shadertoy, that I like to use for starry skys in Blender\n\nvec2 random(float px,float py,float seed){\n    float x = fract(sin(dot(vec3(px,py,seed), vec3(45.84018476, 94.30285684, 33.52930515))) * 23859.2590);\n    float y = fract(sin(dot(vec3(px,py,seed), vec3(96.95283515, 23.59403928, 59.59203951))) * 96834.1853);\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.x;\n    float d = iResolution.x;\n    float dsum = 0.;\n    d*=d;\n    float shift = 0.;\n    for(float scale=20.; iResolution.x/scale>1.; scale*=2.){\n        for(float i=-1.; i<2.; i++){\n            for(float j=-1.; j<2.; j++){\n                uv = fragCoord/iResolution.x;\n                uv+=(scale/3.+500.)*iTime/6000.;\n                vec2 uv2 = uv + vec2(i,j)/scale;\n                vec2 pos = random(floor(uv2.x*scale),floor(uv2.y*scale),0.);\n                vec2 d2 = pos-vec2(uv.x*scale-floor(uv2.x*scale), uv.y*scale-floor(uv2.y*scale));\n                d = min(dot(d2,d2),d);\n            }\n        }\n        float temp = max((.015-d)*13.0,0.);\n        shift += temp*(random(floor(uv.x*scale),floor(uv.y*scale),0.).x-.5)*2.;\n        dsum += temp;\n    }\n    fragColor = (vec4(vec3(dsum)+vec3(-shift,0.,shift)/3.,1.0)*2.+texture(iChannel0,fragCoord/iResolution.xy))/3.;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsycWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 395]], "test": "untested"}
{"id": "3dGcWD", "name": "Pixelate with different  w and h", "author": "henrmota", "description": "This shader pixelate with different w and h for each pixel", "tags": ["pixelate"], "likes": 1, "viewed": 274, "published": 3, "date": "1602804759", "time_retrieved": "2024-07-30T20:40:15.322161", "image_code": "const vec2 pixel = vec2(20., 10.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n\n    vec2 d = vec2(1.0) / iResolution.xy;\n    vec2 q = floor(fragCoord.xy/pixel) * d * pixel;\n    \n\tvec4 pixelColor = vec4(0.0);\n    for(float x = 0.0; x < pixel.x; x++){\n        for(float y = 0.0; y < pixel.y; y++){\n            vec2 coord = q + (vec2(x,y) * d);  \n        \tpixelColor += texture(iChannel0, coord);\n        }\n    }\n    \n    vec4 color = pixelColor/(pixel.x * pixel.y);\n\t\n    \n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 148, 662]], "test": "untested"}
{"id": "tdKyWh", "name": "Extruded Asymmetric Hexagons", "author": "Shane", "description": "Producing packed extruded asymmetric rounded hexagons in realtime, with the help of some texture precalculation. Rendered in an austere pencil ink style.", "tags": ["voronoi", "cartoon", "hexagon", "sketch", "pencil", "cross", "hatch", "extrude", "asymmetric"], "likes": 28, "viewed": 977, "published": 3, "date": "1602772332", "time_retrieved": "2024-07-30T20:40:16.523948", "image_code": "/*\n\n    Extruded Asymmetric Hexagons\n    ----------------------------\n\n\tHere's a trimmed down version of my \"Asymmetric Hexagon Landscape\"\n    example. Aesthetically speaking, I've kept it pretty basic. Without the \n    extra detail, it should definitely run faster. However, how well it runs \n    is still dependent upon how well your machine can deal with textures, and  \n    other things.\n\n\tMy laptop can run this in the 800 by 450 window form in its sleep, and \n    can almost run it in fullscreen (1920 by 1080), but experiences slight \n    stutter. Having said that, I think running any detailed pixel shader in\n\tfullscreen mode is a bit of a stretch for the GPU.\n\n    Texture storage can be annoying to code, and a lot of systems still don't\n\tlike the idea of putting them in memory and reading from them in realtime. \n    However, the alternative is to calculate really expensive distance \n    functions on the fly, which would be near impossible on present systems.\n    This particular field comprises of packed pixel-perfect rounded asymmetric \n    extruded hexagons. As an aside, I've already tried to produce the same \n    using nonstorage methods and it practically grinds my machine to a halt. \n\n    Either way, this is a pretty simple field in the general scheme of things, \n    so if you wanted to raymarch something more elaborate, then some kind of \n    texture precalculation will be mandatory. With this particular method, I\n\tcould turn it into a jigsaw, and the performance would remain relatively \n    unaffected.\n\n    By the way, for anyone interested, the cheap 3D cross hatching-based \n    pencil ink post processing routine was written off the top of my head in \n    under ten minutes. It's substandard for sure, but effective (See the\n\tDRAW_STYLE directive below). I've been meaning to add one for a while, \n    since I haven't seen many written on Shadertoy. All routines like this \n    are just an extension of tri-planar texturing and greyscale pixel \n    thresholds, and are not very difficult to implement. Anyway, the code is\n\tat the bottom of the page.\n\n\n \n\tOther examples:\n\n\t// Dr2's latest, which takes a Voronoi approach. The Voronoi aesthetic is \n    // similar, and arguably, superior, which makes it the algorithm of choice \n    // in many situations. However, it involves more taps, plus gaining access \n    // to vertex information is definitely not as straight forward, which \n    // means there are times when an offset hexagon vertices approach would\n    // be preferred.\n    //\n    Gliders Over Voropolis - Dr2\n    https://www.shadertoy.com/view/WdKcz1\n    \n    // A more involved example.\n    //\n\tAsymmetric Hexagon Landscape - Shane\n \thttps://www.shadertoy.com/view/tdtyDs\n\n    // Flockaroo's less hacky sketch shader: This is a planar algorithm, \n    // and is great with static scenery and some moving scenery. For general \n    // moving scenery, it'd need to be converted to a tri-planar version.\n    when voxels wed pixels - Flockaroo\n    https://www.shadertoy.com/view/MsKfRw\n\n\n*/\n\n// The drawing style -- Choose greyscale pencil (2) to see the typical \n// cross hatching representation on its own.\n//\n// 0: No postprocessing, 1: Heavy greyscale pencil, 2: Greyscale pencil, \n// 3: Colored pencil.\n#define DRAW_STYLE 2\n\n// The pencil algorithm looks more authentic with this turned off -- I\n// think it has something to do with our eyes not accepting pronounced\n// lighting changes with animated sketches. However, I'd like the user \n// to see it with it turned on. Anyway, the ability to turn it off is \n// a compromise.\n#define ENVIRONMENT_LIGHTING \n\n// Turning the metallic texturing on and off.\n#define TEXTURED\n\n// Colored blinking pylons.\n#define BLINK \n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Pylong height scale. Between zero and one works, but larger numbers\n// introduce more artifacts.\n#define HS .6  \n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), .25*(sin(z*.875)*.5 + .5));\n}\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D tex, in vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    //p = p/2. + .5;\n    //p = (floor(p*1024.) + .5)/1024.;\n    vec3 tx = texture(tex, p).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hmB(in vec2 p){ \n     \n    return dot(getTex(iChannel1, p), vec3(.299, .587, .114)); \n}\n\n// The height map. It was orginally supposed to be a fast texture call, but then\n// I was insistent on creating a valley that followed the camera path, which would\n// be pretty difficult to encode into a repeat texture... Anyway, it's slower now,\n// but within acceptable ranges.\nfloat hmBlock(in vec2 p){ \n    \n    \n    // Wrapping things around the camera path.\n    vec2 pth = path(p.y);\n    p -= pth; // Y is the Z coordinate here.\n    \n    float d = abs((p.x + .5) - .5)*2.;\n    \n    // Scaling by 1/16 and snapping to repeat texture pixels. Alternatively, you \n    // can change the cube map filter to \"nearest\" and save a calculation, which\n    // is what I've done.\n    p /= 24.;\n    // p = (floor(p*1024./16.) + .5)/1024.;  \n    \n    // Retrieving the height value from the precalculated wrapped texture map.\n    float h = tx5(iChannel0, p).x; \n                    \n    // Carving out a path.\n    h = mix(h + pth.y,  h/1.5 + pth.y/2., 1. - smoothstep(0., .75, d - .25));\n    \n    #ifdef QUANTIZE_HEIGHT\n    // Quantizing the height levels. More expensive, but it looks a little neater.\n    h = floor(h*23.999)/23.;\n    #endif\n    \n    return h;\n    \n    \n}\n\n\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n \n\n\nvec4 blocks(vec3 q){\n    \n    \n    // Pulling in the 4 precalculated offset values from their respective\n    // cube map faces.\n    //\n    // By the way, calculating the minimum 2D face distance, then using it to\n    // render the extruded block doesn't work... It'd be nice, but you have to\n    // compare all 4 extruded blocks... It's obvious, yet if I haven't done this\n    // for a while, it's the first thing I try. :D\n    vec2 uv = (floor(q.xy*1024.) + .5)/1024.;\n    vec4 p40 = tx0(iChannel0, uv);  // The 2D distance fields.  \n    // Precalculated heights. These would have tripled the speed, but\n    // unforturnately weren't practic\n\n\n    // Block dimension: Length to height ratio with additional scaling. By the way,\n    // I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    // that gives you proper scaled hexagons. One reason is that they're mutated by\n    // the offset vertices anyway, and the main one is that it makes wrapping more\n    // difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n\n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    // Pointed top.\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif  \n    \n\n    // Initializing the extruded face distance for the hexagon cell.\n    float d2D = 1e5;\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n        \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec4[3] vert = vID; \n        \n        \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        const float vo = .15;\n        vec4 vrt0 = idi.xyxy + vert[0]/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        #endif \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy; \n        \n          \n        // Hexagon vertices.\n        vec2[6] v1 = vec2[6](vert[0].xy, vert[0].zw, vert[1].xy, vert[1].zw, vert[2].xy, vert[2].zw); \n        \n        \n        // Scaling the ID.\n\t    idi *= s;\n         \n        \n        // Offset hexagon center.\n        //vec2 inC = vec2(0);\n        // Preferred, but not necessary and it's a huge bottleneck, which surprises me.\n        //vec2 inC = (vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)/6.;\n        //vec2 idi1 = idi + inC;\n        \n        // Stored 2D rounded offset hexagon face distance information. Without this, \n        // the example would fry your GPU.\n        float face1 = p40[i];\n        //float face1 = sdPoly(p, vert); \n        \n        float h1 = hmBlock(idi); //p42[i] For future stored heights.\n        h1 *= HS; // Height scaling.\n        \n        float face1Ext = opExtrusion(face1, (q.z - h1), h1); \n        \n        /*\n        // Lego style.\n        float top = length(p) - .2*scale.x + .065*scale.x;\n        float cyl1 = opExtrusion(abs(top) - .035*scale.x, q.z - (h1 + .01), h1 + .01);\n        face1Ext = min(face1Ext, cyl1);\n        */\n        \n        face1Ext += max(face1, -.015)*.5;\n        face1Ext += face1*.05;\n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and pylon face distance. \n        if(face1Ext<d){\n            d = face1Ext;\n            id = idi;\n            d2D = face1; // Recording the face distance.\n\n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, d2D);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    //float fl = p.y;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p.xzy);\n    gID = d4; // Individual block ID.\n \n    // Overall object ID.\n    objID = p.y<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return min(p.y, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.125) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<40? d*.5 : d*.75; \n        //t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n    \n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(sca>1e5) break; // Compiler related.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 4.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); // Redish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n \t\n\t// Camera Setup.\n\n\tvec3 ro = vec3(0, 1.15, iTime*.75); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.2, .25); // \"Look At\" position.\n    \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n    \n    #if DRAW_STYLE == 0\n    // With no pencil post processing, the light looks a little nicer here.\n    const float lightZ = 4.5;\n    #else\n    // When using a pencil overlay, reposition the light to hit the surface more directly.\n    const float lightZ = -.5;\n    #endif\n \tvec3 lp = ro + vec3(1.25, 1.5, lightZ);// Put it a bit in front of the camera.\n    \n    // Moving the camera and light along the path.\n\tro.xy += path(ro.z); \n    lk.xy += path(lk.z); \n    lp.xy += path(lp.z); \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime/8. - cos(iTime/12.))/2. );\n\n    // Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n    \n    // Surface position and surface normal. We're setting them\n    // up here, due to some postprocess that require them...\n    // See below.\n\tvec3 sp = ro + rd*t;\n    vec3 sn = rd; // Surface normal for the sky dome.\n    float gRnd = 0.; // Random number to move the hatching around.\n    float gRndB = 0.; // Random number to move the hatching around.\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n  \t\n    \t// Normal overide for cases where we've hit\n        // the surface. In this example, we don't see the \n        // horizon, so it would be always, but we still\n        // need to do things correctly. :)\n\t    //sn = getNormal(sp, edge, crv, ef, t);\n        sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Texturing.\n            //\n            #ifdef TEXTURED\n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel1, svGID.yz/2.);\n            //tx = smoothstep(.05, .5, tx);\n            // Continuous tri-planar texturing.\n            vec3 tx2 = tex3D(iChannel1, sp*1., sn);\n            tx2 = smoothstep(.0, .5, tx2);\n            #else\n            vec3 tx = vec3(.35);\n            vec3 tx2 = vec3(.35);\n            #endif\n            \n\t\t\tfloat rnd = hash21(svGID.yz); \n            gRnd = rnd;\n            #ifdef BLINK\n            // Blinking: Couldn't make it look right, but I'll look at it later.\n            //rnd = rnd<.125? 1. : 0.;\n            rnd = smoothstep(.9, .95, sin(6.2831*rnd + iTime)*.5 + .5);\n            gRndB = rnd;\n            vec3 bCol = vec3(1, .2, .05);\n            bCol = mix(bCol, bCol.xzy, hash21(svGID.yz + .09)*.6);\n            tx2 *= mix(vec3(1), bCol*5., rnd);\n            #endif\n            \n            texCol = mix(tx, tx2, .5); // Blend.\n            //texCol = vec3(.34);\n            //float rnd = hash21(svGID.yz);\n            //vec3 rndC = .5 + .45*cos(6.2831*(rnd)/4. + vec3(0, 1, 2) + 0.);\n            //texCol = mix(texCol, rndC, .15);\n            \n\n\n            vec2 svP = sp.xz - svGID.yz;\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, length(svP) - .04*GSCALE.x));\n             \n            // Hexagonal face value.\n            float ht = hmBlock(svGID.yz)*HS;\n            float hex = svGID.w;\n   \n            float hex2 = hex;\n            hex = max(abs(hex), abs(sp.y - ht*2.)) - .001; // Face border.\n            //hex = min(hex, abs(hex2 + .01) - .00125); // Extra border.\n            \n            // Coloring the sides of the columns. I wasn't feeling it. :)\n            //vec3 rndC = .5 + .45*cos(6.2831*(ht)*4. + vec3(2, 1, 0) + 2.);\n            //texCol = mix(texCol, texCol*rndC, (1. - smoothstep(0., .002, -(hex2)))*.9);\n            \n            // Applying the face border.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .002, hex)));\n            \n            \n            // Failed attempts at decoration. I opted for \"less is more\" in the end. :)\n            /*\n            float rnd = hash21(svGID.yz);\n            vec2 puv = rot2(ht*6.2831)*svP;\n            float pat = abs(fract(puv.x*48.) - .5)*2. - .125;\n            pat = smoothstep(0., .003*48.*(1. + t*t), pat);\n            texCol = mix(texCol, texCol*pat, 1. - smoothstep(0., .003, -(sp.y - ht*2.)));\n            */\n            \n            /*\n            float ang = atan(svP.y, svP.x)/6.2831;\n            float pat = abs(fract(ang*24.) - .5)*2. - .25;\n            pat = smoothstep(0., .003*24.*(1. + t*t), pat);\n            texCol = mix(texCol, texCol*vec3(2, 1, .5)*pat, 1. - smoothstep(0., .003, sp.y - ht));\n            */\n     \n \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1.25/(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 2.)*1.35; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + ao*.25 + vec3(.25, .5, 1)*fre*sh + vec3(1, .5, .3)*spec*4.);\n\n        #ifdef ENVIRONMENT_LIGHTING\n        // Fake environment mapping.\n        vec3 cTex = envMap(reflect(rd, sn));\n        #if DRAW_STYLE==0\n        col += col*cTex*5.;\n        #elif DRAW_STYLE==1\n        col += col*cTex*.5;\n        #else  \n        col += col*cTex*2.;\n        #endif\n        #endif\n        \n        // Shading.\n        col *= ao*atten;\n        \n\t\n\t}\n    \n    // Applying fog.\n    vec3 fog = vec3(0);//mix(vec3(.25, .5, 1), vec3(1, .8, .6), rd.y*.5 + .5)*2.;\n    col = mix(col, fog, smoothstep(0., .99, t/FAR));\n    \n    \n    // Here's a quick hacky 3D cross hatching routine that I made up on the spot. \n    // You could do better, but this works surprisingly well for the amount of \n    // effort involved. Normally, there's an element of frequency grading involved,\n    // but aside from that, all 3D hatching would be based on similar principles.\n    //\n    // Texure samples. One for each plane.\n    mat2 m2 = rot2(3.14159/12.); // Rotation.\n    sp += gRnd; // Constant translation from object to object.\n    sp *= 3.; // Scaling.\n    #if DRAW_STYLE==1\n    sp *= 1.5; // Finer grain pencil for the heavy pencil.\n    #endif\n    sp += n3D(sp*12.)*.02; // Perturbation, since pencil lines aren't perfect.\n    // Use the hatch texture, for obvious reasons. At some stage, I'll code\n    // up one that's more specific to this purpose.\n\tvec3 tx = getTex(iChannel2, m2*sp.yz); \n    vec3 ty = getTex(iChannel2, m2*sp.xz);\n    vec3 tz = getTex(iChannel2, m2*sp.xy);\n    // Second level of cross hatching.\n    sp *= 1.5; m2 *= rot2(3.14159/4.);\n    vec3 tx2 = getTex(iChannel2, m2*sp.yz); \n    vec3 ty2 = getTex(iChannel2, m2*sp.xz); \n    vec3 tz2 = getTex(iChannel2, m2*sp.xy); \n    // Normal manipulation.\n    sn = max(sn*sn - .2, .001); // max(abs(n), 0.001), etc.\n    sn /= dot(sn, vec3(1)); \n    //sn /= length(sn); \n    // Multiply each texture plane by its normal dominance factor.\n    tx = mat3(tx, ty, tz)*sn;\n    tx = vec3(1)*dot(tx, vec3(.299, .587, .114));\n    tx2 = mat3(tx2, ty2, tz2)*sn;\n    tx2 = vec3(1)*dot(tx2, vec3(.299, .587, .114));\n    tx = max(tx, tx2);\n    // Compare the texture to the scene's color value.\n    \n    #if DRAW_STYLE==1\n    // Straight cross hatching.\n    // The \"-.25\" and \".6\" terms control light and darkness. This little tidbit is\n    // based on some of Flockaroos logic from his sketch shader, here:\n    //\n    // when voxels wed pixels - flockaroo\n    // https://www.shadertoy.com/view/MsKfRw\n    tx = vec3(1)*smoothstep(0., .45, dot((min(col, 1.) - tx), vec3(.299, .587, .114)));\n    #ifdef BLINK\n    col = mix(tx, col*tx*1.35, gRndB);\n    #else\n    col = tx;\n    #endif\n    #elif DRAW_STYLE==2\n    // Straight cross hatching.\n    // The \"-.25\" and \".6\" terms control light and darkness.\n    tx = vec3(1)*smoothstep(-.25, .6, dot((min(col, 1.) - tx), vec3(.299, .587, .114)));\n    //tx = vec3(1)*clamp(dot((min(col, 1.) - tx), vec3(.299, .587, .114))/.6 + .25, 0., 1.);\n    #ifdef BLINK\n    col = mix(tx, col*tx*1.35, gRndB);\n    #else\n    col = tx;\n    #endif\n    #elif DRAW_STYLE==3\n    // Colorize. \n    // The \"-.25\" and \".5\" terms control light and darkness.\n    tx = vec3(1)*smoothstep(-.2, .5, dot((min(col, 1.) - tx), vec3(.299, .587, .114)));\n    // I was in a hurry here. It'd be better to perfrom some kind of nice\n    // Photoshop style overlay.\n    col *= tx*1.35;\n    //col *= mix(vec3(1), tx*1.25, .85);\n    //col = 1. - exp(-col*1.2); \n    //col = mix(col, max(col, tx), .25);\n    #endif\n    \n    // Color to greyscale edge fade.\n    //col = mix(col, tx, dot(uv, uv));\n   \n    // Debug: Just the height map.\n    //uv = fragCoord/iResolution.y;\n    //vec3 tx = tx5(iChannel0, uv/1.).xyz;\n    //col = tx;\n         \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Producing hexagons with offset vertices can be a little painful, but it's \n// doable. Regular hexagon grids are almost trivial, but don't really suit this\n// example. Either way, comment this out to see.\n#define OFFSET_VERTICES\n\n\n// Quantizing the height levels. More expensive, if not precalated, but it looks \n// a little neater -- Windows line up with the terraced levels, etc.\n#define QUANTIZE_HEIGHT\n\n\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly... and at times, can be downright annoying. The distance fields\n// involve offsets, and all have to work in unison. Powers of two work, but for \n// some reason that mystifies me, (1024./36.) will work with GSCALE = vec2(1./6.).\n// Anyway, I'll revisit this at some stage.\nfloat repSc = 1024./32.;\n\n// This sets the scale of the extruded shapes. Because of the way I've calculated\n// things, the scale needs to be even divisors and each term needs to be equal --\n// I use it in other applications where I can use two different numbers though. \n// As above, if you choose this option, a reset will be necessary. Ie. Hit the \n// back button.\n//\n// I like a scale of \"1./4.\" too, but I opted for more detail for this example.\n#define GSCALE vec2(1./4.)  //*vec2(1./.8660254, 1)\n \n// Flat top hexagon.\n#define FLAT_TOP\n#ifdef FLAT_TOP\n// Vertices and mid edge points: Clockwise from the left.\nvec4[3] vID = vec4[3](vec4(-2./3., 0, -2./6., .5), vec4(2./6., .5, 2./3., 0), vec4(2./6., -.5, -2./6., -.5)); \nvec4[3] eID = vec4[3](vec4(-.5, .25, 0, .5), vec4(.5, .25, .5, -.25), vec4(0, -.5, -.5, -.25));\n#else\n// Vertices and mid edge points: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec4[3] vID = vec4[3](vec4(-.5, -2./6., -.5, 2./6.), vec4(0, 2./3.,.5, 2./6.), vec4(.5, -2./6., 0, -2./3.));\nvec4[3] eID = vec4[3](vec4(-.5, 0, -.25, .5), vec4(.25, .5, .5, 0), vec4(.25, -.5, -.25, -.5));\n#endif\n\n////////\n\n// Work around for the time variable.\nfloat gTime = 0.;\nvoid setTime(float tm){ gTime = tm; }\n\n\n// Reading from various cube map faces.\nvec4 tx0(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(-.5, fract(p.yx) - .5), 0.);\n    //return texture(tx, vec3(-.5, fract(p.yx) - .5));\n}\n\nvec4 tx1(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\nvec4 tx5(samplerCube tx, vec2 p){ \n   \n    return textureLod(tx, vec3(fract(p) - .5, .5), 0.);\n    //return texture(tx, vec3(fract(p) - .5, .5));\n}\n/*\nvec4 tx1B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(p.x, -.5, p.y), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n*/\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n\n// Based on IQ's hash formula.\nvec4 hash42B(vec4 p){ \n\n    p = (floor(p*1024.) + .5)/1024.;\n  \n    p = mod(p*repSc*GSCALE.x*2., repSc);\n   \n    p = vec4(dot(p.xy, vec2(27.619, 113.583)), dot(p.xy, vec2(57.527, 85.491)),\n             dot(p.zw, vec2(27.619, 113.583)), dot(p.zw, vec2(57.527, 85.491)));\n                                                  \n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    \n    //return sin(p*6.2831853 + gTime);//mix(p, sin(p*6.2831853 + iTime), .35);\n    \n}\n\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    p = mod(p, repSc);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + gTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n\n// Height map. Just some gradient noise. \n// By the way, because this is precalculated, you could\n// make this as extravagent as you wished.\nfloat hm(in vec2 p){ \n   \n\n    p *= repSc;\n    return n2D3G(p)*.5 + .5;\n \n    //return (n2D3G(p)*.66 + n2D3G(p*2.)*.34)*.5 + .5;\n/*    \n    // We're going for simplicity, so just a couple of\n    // noise layers. The bottom layer is hollowd out a\n    // bit to give a basin like feel.\n    float h = smoothstep(.08, 1., n2D3G(p)*.5 + .5);\n    h = mix(h, n2D3G(p*2.)*.5 + .5, .33);\n    #ifdef QUANTIZE_HEIGHT\n    h = floor(h*31.999)/31.; // Discreet heights.\n    #endif\n   \n    return h;\n*/    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .002;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV 6\n//\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n", "cube_a_code": "\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed objects.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\n// For a 2D extruded block tiling four objects are needed. For the Cairo tiling,\n// each block needs to be subdivided into two seperate pentagonal pieces, so \n// that's eight pentagon distances all up. Since there are no vec8 containers in \n// WebGL, we need to make one. By the way, for regular 2D Cairo tiles, you only \n// need four or even two, depending what you're trying to do.\n//\nstruct vect8{ vec4 distA; vec4 distB; vec4 distC; };\n\n\nvect8 df(vec2 q){\n    \n    \n    // Block dimension: Length to height ratio with additional scaling. By the way,\n    // I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    // that gives you proper scaled hexagons. One reason is that they're mutated by\n    // the offset vertices anyway, and the main one is that it makes wrapping more\n    // difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n   \n\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID.\n    vec2 cntr = vec2(0);\n\n    \n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif\n    \n    // The tile struct.\n    vect8 tile;\n    \n   \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n        \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec4[3] vert = vID; \n        \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        const float vo = .15;\n        vec4 vrt0 = idi.xyxy + vert[0]/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        #endif \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy; \n        \n        // Scaling the ID.\n\t    idi *= s;\n \n  \n          \n        // Hexagon vertices.\n        vec2[6] v1 = vec2[6](vert[0].xy, vert[0].zw, vert[1].xy, vert[1].zw, vert[2].xy, vert[2].zw);\n        \n\n        // Moving the vertices in to help create rounded hexagons. Rounded offset hexgons can\n        // be created by simply adding a factor to the distance field. Unfortunately, in a \n        // packed grid, that would create overlap, so it's necessary to move the points in\n        // first, then add the amount. This is less trivial, as you can see, but is just a\n        // bit of trigonometry. The following is robust, but was something I came up with on\n        // the spot, so if anyone knows of a more elegant way, feel free to let me know.\n        // Remember that this is just a one-off precalculation, so speed isn't a factor.\n        const float ndg = .0175*8.*GSCALE.x;\n        vec2[6] tmpV;\n        \n        for(int j = 0; j<6; j++){\n            \n            // Vertices and flanking neighbors.\n            vec2 g = v1[j];\n            vec2 g1 = v1[(j + 1)%6];\n            vec2 g2 = v1[(j + 5)%6];\n            vec2 nj = normalize(g1 - g); // Tangent vector.\n         \n            // Move the vertices in the direction of the tangent vector\n            // by the nudge factor.\n            vec2 v1 = g - g1;\n            vec2 v2 = g - g2;\n            // Angle between vectors.\n            float ang = acos(dot(v1, v2)/length(v1)/length(v2));\n            float sl = ndg/tan(ang/2.);\n            tmpV[j] = g + sl*nj + ndg*nj.yx*vec2(1, -1);\n        }\n                               \n        v1 = tmpV;                 \n\n        float face1 = sdPoly(p, v1);\n        // float face1 =  sHexS(p, scale/2.);\n        face1 -= ndg*.9;\n        tile.distA[i] = face1;\n        \n        // No precalculated heights for this example, since we'll be reading\n        // from a precalculated texture in the \"Image\" tab.\n        /*\n        // Using the original outer vertices for the offset factor.\n        vec2 inC = vec2(0);//(vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)/6.;\n        vec2 idi1 = idi + inC.xy;\n        float h = hm(idi1);\n        tile.distB[i] = h;\n        */\n        \n        \n    }\n    \n    // Return the tile struct.\n    return tile;\n\n}\n\n\n\n// Cube mapping for face identification - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    \n    // Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n  \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed just the once upon initialization.\n    //if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    //\n    // IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    // I'm not sure how he figured this out, but he pretty much knows everything. :D\n    //\n    // If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    // you wish to initialize. In this case, I'm precalculating an expensive distance\n    // field and storing it in some of the cube map faces.\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        // INITIALIZING.\n        \n        // Construct a distance field, then store it.\n    \tvect8 d = df(uv);\n        \n        if(faceID == 0) col = d.distA; // Distance fields.\n    \n        if(faceID == 5) col = vec4(1)*hm(uv);//d.distB; // Pylon heights.\n    \n        \n        //repSc = 1024.;\n        //if(faceID == 1) {\n            //col = vec4(1)*hm(uv*repSc);//hm(iChannel1, uv*repSc)\n        //}\n     \n    }\n    else {\n        if(faceID == 0) col = tx0(iChannel0, uv);\n        if(faceID == 5) col = tx5(iChannel0, uv);//vec4(1)*hm(uv);//\n        //if(faceID == 1) col = tx1(iChannel0, uv);\n    }\n\n\n    // Store in the cube map.\n    fragColor = col;\n    \n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3951, 4054, 4076, 4104, 4179], [4182, 4429, 4467, 4904, 5045], [5047, 5201, 5249, 5551, 6460], [6464, 6528, 6549, 6549, 6621], [6623, 6903, 6928, 6986, 7787], [12954, 12977, 12995, 13065, 13278], [13282, 13303, 13339, 13388, 13863], [14501, 14692, 14744, 14861, 16168], [16171, 16323, 16359, 16359, 16656], [16658, 16801, 16822, 16822, 17168], [17170, 17469, 17489, 17489, 17823], [17826, 17826, 17882, 17915, 29013]], "test": "untested"}
{"id": "tdKyDh", "name": "basic construction", "author": "jorge2017a1", "description": "basic construction\n\n", "tags": ["basicconstruction"], "likes": 5, "viewed": 320, "published": 3, "date": "1602771143", "time_retrieved": "2024-07-30T20:40:17.373675", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n// INFINITE BUILDINGS\nfloat obj_infiniteBuildings(in vec3 p)\n{\n\tvec3 c = vec3(12,10,20); // how close cubes are to each other\n\tvec3 f = vec3(8,10,7);\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.x = mod(q.x,f.x)-0.5*f.x;\n\t\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\tq.z = mod(q.z,f.z)-0.5*f.z;\n\t\n\t//building height\n\tvec3 b1 = vec3(1.0, 3.0, 1.0);\n    vec3 b2 = vec3(2.0, 3.0, 2.0);\n    \n\tfloat s1= sdBox(q-vec3(0.0,5.0,0.0),b1);\t\n    float s2= sdBox(q,b2);\t\n    return unionSDF(s1, s2);\n    //return s2;\n}\n\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 30.0-p.y;  //piso sup\n   \n    res =opU3(res, vec3(planeDist1,-1.0,2.0)); \n    res =opU3(res, vec3(planeDist2,27,MATERIAL_NO)); \n    \n    p.y=p.y-1.0;\n    \n    \n   \n   float ib1= obj_infiniteBuildings( p);\n   res =opU3(res, vec3(ib1,-1.0,5.0));\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO));\n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n       \n        \n        if(dO>MAX_DIST )\n        {\t\n            mObj.dist = -1.0;\n    \t\tmObj.id_color = -1.0;\n    \t\tmObj.marchCount=marchCount;\n    \t\tmObj.id_material=-1.0;\n            //return -1.0;\n            break;\n        }\n        \n        if (abs(dS.x)<MIN_DIST) \n        { break;  }\n            \n            \n        dO += dS.x;\n        marchCount++;\n        \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 64.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    float diff = dot(nor, l);\n    \n    \n    vec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n       \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//Brick Color\nvec3 color_brick(in vec3 p)\n{\t\n\tconst vec3 brickColor = vec3(0.2,0.2,0.2);\n\tconst vec3 mortarColor = vec3(0.8);\n\tconst vec2 brickSize = vec2(0.3,0.15)*2.0;\n\tconst vec2 brickPct = vec2(0.9,0.85);\n\t\n\tvec2 position = (p.zy)/brickSize;\n\tvec2 useBrick = vec2(0);\n\t\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\t\t\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\t\n\tvec3 color =  mix(mortarColor, brickColor, useBrick.x*useBrick.y);\n\t\n\t\n\tposition = p.xy/brickSize;\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\tcolor = (color+mix(mortarColor, brickColor, useBrick.x*useBrick.y))/2.0;\n\t\n\treturn color;\n\t\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    \n    \n    if (id_material==5.0)\n    { \n     return color_brick(p);\n    }\n     \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(5.0,1.0+abs(4.5*sin(iTime*0.45)),-25.0+t);\n      \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(100.0) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 289, 289, 373], [374, 418, 465, 465, 492], [494, 494, 537, 537, 564], [566, 566, 614, 614, 642], [643, 714, 748, 748, 846], [847, 847, 881, 881, 973], [974, 974, 1008, 1008, 1100], [1101, 1141, 1175, 1175, 1272], [1275, 1297, 1337, 1337, 1804], [1809, 1849, 1874, 1874, 2365], [2367, 2412, 2479, 2479, 2847], [2848, 2899, 2923, 2923, 3111], [3112, 3175, 3208, 3208, 3924], [3926, 3980, 4016, 4016, 4250], [4307, 4341, 4421, 4421, 4870], [4913, 4927, 4956, 4956, 5628], [5630, 5681, 5728, 5728, 6415], [6469, 6469, 6562, 6562, 6833], [6836, 6885, 6942, 6942, 8131]], "test": "untested"}
{"id": "WsVcW1", "name": "lazzy SDF evaluation", "author": "FabriceNeyret2", "description": "Lazzy evaluation: buffer A computes the SDF at low resolution\nbuff B,C,D computes at double resolution (emulating quadtree) only in prev tiles close to SDF=0\nImage evaluates and draw SDF in last near-zero tiles\n", "tags": ["quadtree", "lazy", "interval", "lazzy", "hierachical"], "likes": 5, "viewed": 428, "published": 3, "date": "1602753235", "time_retrieved": "2024-07-30T20:40:18.240358", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    float SIZE = 4.*L, l;      // below: to test Buffers content\n // SIZE = 8.*L; O = texture(iChannel3,u/SIZE/R); O=vec4(-O.r*R.y/16.,O.g,O.r*R.y/16.,0); return;\n    \n    vec2 U = u/R.y;\n    int n = 0;\n     \n#if LAZZY\n    \n    O = texture(iChannel0,u/SIZE/R); l = O.r;    // LOD content\n    n = int(O.g);                                // \"near\" LOD flags\n    if ( abs(l) < k*SIZE/R.y )                   // near tile on: compute\n        { SDF(U); n += 8; }\n    \n#else\n    \n    SDF(U);\n    \n#endif\n    O-=O;\n    O = vec4( smoothstep(1./R.y, 0., abs(l) ) ); // isovalue SDF = 0\n    O += .5 * vec4((n&4)>0,(n&2)>0,n&1,0);       // show flags\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LAZZY 1              // lazzyness on/off\n#define L (.5+max(0.,log(R.y/360.))) // scaling of resolutions   ( for worthful LOD0 )\n#define k 1.2                // neighborhood gain factor ( don't loose, don't redund )\n\n#define R        iResolution.xy\n#define hash(p)  fract(sin( p * vec2(12.9898, 78.233) ) * 43758.5453)\n\n\n// --- put your costly SDF here\n\n#define SDF(U) /* as a macro because we stupidely can't access resol in Common */  \\\n{   l = 1e5;                                                                       \\\n    for(float i=0.; i<1e3; i++) {                                                  \\\n        vec2 P = R/R.y*hash(i) + .2*cos(iTime*(2.*hash(i+.3)-1.)+hash(i+.7)+vec2(0,11)); \\\n        l = min(l, length(U-P) -1./R.y);                                           \\\n    }                                                                              \\\n    l -= .04;                                                                      \\\n}\n\n// --- compute a hierarchy of intervals\n\n#define LOD(scale,flag)                                          \\\nvoid mainImage( out vec4 O, vec2 u )                             \\\n{   if ( LAZZY < 1 ) discard;                                    \\\n    float SIZE = (scale)*L, l;                                   \\\n                                                                 \\\n    vec2 U = SIZE*u/R.y;                                         \\\n    if ( max( U.x*R.y/R.x , U.y ) > 1. ) discard;                \\\n    O = texture(iChannel0,u/2./R); l = O.r;                      \\\n    if ( abs(l) < k*SIZE/R.y )                                   \\\n        { SDF(U); O.r = l; O.g += float(1<<flag); }              \\\n}\n", "buffer_a_code": "LOD(32.,-1)    // === compute SDF at res 1/32 ====================\n\n    \n    \n    \n    \n    \n    \n    \n/*    \nvoid mainImage( out vec4 O, vec2 u )\n{   \n    if (LAZZY<1) discard;\n    float SIZE = 32.*L;\n    \n    vec2 U = SIZE*u/R.y;\n    if ( max(U.x*R.y/R.x,U.y) > 1. ) discard;\n    float l; SDF(U);\n    O.rg = vec2(l,0);\n}\n*/\n", "buffer_a_inputs": [], "buffer_b_code": "LOD(16.,0)    // === compute SDF at res 1/16 ====================", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "LOD(8.,1)    // === compute SDF at res 1/8 ====================", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "LOD(4.,2)    // === compute SDF at res 1/4 ====================", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 681]], "test": "untested"}
{"id": "WsKyWh", "name": "Hard and Soft HSL", "author": "thepheer", "description": "Nice and branchless.", "tags": ["color", "hsl"], "likes": 9, "viewed": 359, "published": 3, "date": "1602750241", "time_retrieved": "2024-07-30T20:40:19.116017", "image_code": "#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(x, a, b) ((a) <= (x) && (x) < (b))\n\nvec3 hard(vec3 hsl) {\n    const vec3 offset = vec3(0.0, 2.0, 1.0)/3.0;\n    float limit = 0.5 - abs(0.5 - hsl.z);\n    vec3 rgb = 12.0*abs(fract(offset + hsl.x) - 0.5) - 3.0;\n    return hsl.z + hsl.y*limit*clamp(rgb, -1.0, 1.0);\n}\n\nvec3 soft(vec3 hsl) {\n    const float tau = radians(360.0);\n    const vec3 offset = vec3(0.0, 1.0, 2.0)/3.0;\n    float limit = (1.0 - hsl.z)*hsl.z;\n\treturn hsl.z + hsl.y*limit*cos(tau*(offset - hsl.x));\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    \n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n\n    vec3 a = hard(vec3(0.1*iTime + uv.x, 1.0, 0.5));\n    vec3 b = soft(vec3(0.1*iTime + uv.x, 2.0, 0.5));\n    \n    vec3 plots =\n        plot(px.y, uv.y, 0.7)*0.1 +\n        plot(px.y, uv.y, 0.7 + 0.4*(a - b)) +\n        plot(px.y, uv.y, 0.1 + 0.4*a)*dashed +\n        plot(px.y, uv.y, 0.1 + 0.4*b)*dotted;\n\n    vec3 rgb =\n        range(uv.y, px.y + 0.95, 1.00) ? a :\n    \trange(uv.y, px.y + 0.90, 0.95) ? b :\n    \tplots;\n\n    rgba = vec4(srgb(rgb), 1.0);\n}", "image_inputs": [], "common_code": "vec3 srgb(vec3 c) {\n    vec3 a = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 204, 204, 411], [413, 413, 434, 434, 617], [619, 619, 659, 659, 1280]], "test": "untested"}
{"id": "3dKcW1", "name": "Dripping Lava Rain", "author": "jarble", "description": "An edit of Ethan Zappa's amazing [url=https://www.shadertoy.com/view/3sXBzB]\"Purple Lava\"[/url] shader.", "tags": ["rain", "lava", "drip"], "likes": 2, "viewed": 379, "published": 3, "date": "1602741145", "time_retrieved": "2024-07-30T20:40:19.980705", "image_code": "vec3 colors [5];\nfloat points [5];\n\nvoid initia(){\n    colors[0]=vec3(1.5,0.,0.6);\n    colors[1]=vec3(0.,1.,1.);\n    colors[1]=vec3(0.0,1.0,0.);\n    colors[3]=vec3(1.0,1.0,0.);\n    colors[4]=vec3(1.0,0.0,0.);\n    points[0]=0.2;\n    points[1]=0.15;\n    points[2]=0.5;\n    points[1]=.5;\n    points[4]=1.5;\n}\nvec3 gradian(vec3 c1,vec3 c2,float a){\n    return vec3(c1.x+a*(c2.x-c1.x),\n                c1.y+a*(c2.y-c1.y),\n                c1.z+a*(c2.z-c1.z));\n}\n\nvec3 heat4(float weight){\n    if(weight<=points[0]){\n        return colors[0];\n    }\n    if(weight>=points[4]){\n        return colors[4];\n    }\n    for(int i=1;i<5;i++){\n        if(weight<points[i]){\n           float a=(weight-points[i-2])/(points[i]-points[i-1]);\n            return gradian(colors[i-1],colors[i],a);\n        }\n    }\n}\n\n\nfloat d(vec2 a, vec2 b) {\n   return  pow(max(0.0, 1.0 - distance(a, b) / (0.6)), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initia();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 4.0 - vec2(2.0);\n   uv.x *= iResolution.x / iResolution.y;\n    \n    float totalWeight = 0.0;\n    for (float i = 0.0; i < 100.0; ++i) {\n        \n    \ttotalWeight += 0.5*d(uv, vec2(\n            sin(1.0*(uv.x)* 1.6 + float(i))*2. + 2.*sin(i * i), \n            cos(1.0*(iTime*2.0+uv.y) * 1.4 + float(i *1.5))*2.\n        ));\n    }\n    \n    \n\tfragColor = vec4(heat4(totalWeight), 1.3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 50, 50, 305], [306, 306, 344, 344, 455], [457, 457, 482, 482, 792], [795, 795, 820, 820, 883], [885, 885, 942, 942, 1394]], "test": "untested"}
{"id": "3sVyW1", "name": "Psychedelic Bubbling Lava", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/wsycD1]\"Neon Cells\"[/url] shader.", "tags": ["fractal", "bubbles", "lava"], "likes": 9, "viewed": 441, "published": 3, "date": "1602739865", "time_retrieved": "2024-07-30T20:40:20.734689", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y;\n        t = iTime;\n        for(int i=0;i<3;i++)\n        {\n        \tuv += (sin(iTime+uv.x)+cos(iTime+uv.y));\n            uv += uv*rot(length(sin(col)));\n        }\n     col[c] = (sin(uv.x)+cos(uv.y));\n\t}\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 485]], "test": "untested"}
{"id": "3dKyWh", "name": "Materials and smin", "author": "thepheer", "description": "Slightly modified smin function from the iq's article:\nhttps://iquilezles.org/articles/smin/smin.htm", "tags": ["materials", "smin"], "likes": 13, "viewed": 576, "published": 3, "date": "1602721140", "time_retrieved": "2024-07-30T20:40:21.486678", "image_code": "struct Material {\n\tvec3 color;\n    float kr, kd, ks, kn;\n};\n\nMaterial mmix(Material a, Material b, float t) {\n    return Material(\n        mix(a.color, b.color, t),\n        mix(a.kr, b.kr, t),\n        mix(a.kd, b.kd, t),\n        mix(a.ks, b.ks, t),\n        mix(a.kn, b.kn, t)\n    );\n}\n\nMaterial materials[] = Material[] (\n\tMaterial(vec3(1.0, 2.0, 3.0), 0.2, 0.5, 0.0, 1.0),   // ground\n\tMaterial(vec3(0.1, 0.2, 2.0), 0.8, 1.0, 1.0, 500.0), // blue\n\tMaterial(vec3(2.0, 0.2, 0.1), 0.8, 1.0, 1.0, 500.0)  // red\n);\n\nvec2 mmin(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\nvec2 mmax(vec2 a, vec2 b) { return a.x > b.x ? a : b; }\nvec2 msmin(vec2 a, vec2 b, float k) {\n    float h = clamp(0.5 + 0.5*(a.x - b.x)/k, 0.0, 1.0);\n    return mix(a, b, h) - vec2(k*h*(1.0 - h), 0.0);\n}\n\nvec2 map(vec3 p) {\n    vec2 ground = vec2(sdPlane(p, vec3(0.0, 1.0, 0.0), 1.0), 0.0);\n    vec2 blob = msmin(\n        vec2(sdSphere(p - vec3(1.0, 0.0, 0.0), 1.0), 1.0),\n        vec2(sdSphere(p + vec3(1.0, 0.0, 0.0), 1.0), 2.0),\n        1.0\n    );\n\treturn mmin(ground, blob);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p) {\n    vec3 k = vec3(1.0, -1.0, 1e-5);\n    vec3 a = k.xyy*map(p + k.z*k.xyy).x;\n    vec3 b = k.yyx*map(p + k.z*k.yyx).x;\n    vec3 c = k.yxy*map(p + k.z*k.yxy).x;\n    vec3 d = k.xxx*map(p + k.z*k.xxx).x;\n    return normalize(a + b + c + d);\n}\n\nstruct Raymarcher {\n    int steps;\n    float eps, near, far, t;\n    vec3 ro, rd, p;\n    vec2 m;\n};\n\nbool raymarch(inout Raymarcher rm) {\n    rm.t = rm.near;\n    for (int i = 0; i < rm.steps; i++) {\n        if (rm.t > rm.far) break;\n        rm.p = rm.ro + rm.t*rm.rd;\n        rm.m = map(rm.p);\n        if (rm.m.x < rm.eps) return true;\n        rm.t += rm.m.x;\n    }\n    return false;\n}\n\nvec3 render(vec2 uv) {\n    // camera position, target, forward, left, up\n    vec3 cp = 5.0*vec3(cos(iTime), 0.5, sin(iTime));\n    vec3 ct = vec3(0.0, -0.5, 0.0);\n    vec3 cf = normalize(ct - cp);\n    vec3 cl = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cl, cf));\n    mat3 cm = mat3(cl, cu, cf);\n    \n    Raymarcher rm;\n    rm.steps = 1<<10;\n    rm.near = 1e-3;\n    rm.far = 1e+1;\n    rm.eps = 1e-4;\n    rm.ro = cp;\n    rm.rd = normalize(cm*vec3(uv, 2.5));\n    \n    Raymarcher rml = rm;\n    rml.near = 5e-3;\n    \n    vec3 ambient = 0.05*vec3(0.1, 0.2, 0.3);\n    vec3 light = 15.0*vec3(1.0);\n    vec3 fog = 2.0*ambient;\n    \n    vec3 color = vec3(0.0);\n    float alpha = 1.0;\n    \n    for (int i = 0; i < 5 && alpha > 1e-3; i++) {\n        if (raymarch(rm)) {\n            // blending two materials\n            Material ma = materials[int(floor(rm.m.y))];\n            Material mb = materials[int(ceil(rm.m.y))];\n            Material m = mmix(ma, mb, mod(rm.m.y, 1.0));\n            \n            vec3 n = normal(rm.p);\n            vec3 lp = vec3(-1.0, 3.0, 2.0) - rm.p;\n            vec3 ld = normalize(lp);\n            float ll = length(lp);\n\n            rml.far = ll;\n            rml.ro = rm.p;\n            rml.rd = ld;\n            float la = raymarch(rml) ? 0.0 : 1.0;\n\n            float diff = m.kd*max(0.0, dot(n, ld));\n            float spec = m.ks*pow(max(0.0, dot(rm.rd, reflect(ld, n))), m.kn);\n            vec3 c = ambient + la*(m.color*diff + spec)*light/(ll*ll);\n            c = mix(c, fog, rm.t/rm.far);\n\n            float a = m.kr*alpha;\n            color += a*c;\n            alpha -= a;\n            \n            rm.ro = rm.p;\n            rm.rd = reflect(rm.rd, n);\n        }\n        else {\n            color += alpha*fog;\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 r = iResolution.xy/iResolution.y;\n    vec2 uv = 2.0*xy/iResolution.xy - 1.0;\n    vec3 rgb = render(r*uv);\n    rgba = vec4(srgb(aces(rgb)), 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/distfunctions\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// https://www.shadertoy.com/view/WdGcD1\nvec3 aces(vec3 color) {\t\n    mat3 x = mat3(+0.59719, +0.07600, +0.02840, +0.35458, +0.90834, +0.13383, +0.04823, +0.01566, +0.83777);\n    mat3 y = mat3(+1.60475, -0.10208, -0.00327, -0.53108, +1.10813, -0.07276, -0.07367, -0.00605, +1.07602);\n    vec3 v = x*color;    \n    vec3 a = v*(v + 0.0245786) - 0.000090537;\n    vec3 b = v*(0.983729*v + 0.4329510) + 0.238081;\n    return y*(a/b);\t\n}\n\nvec3 srgb(vec3 c) {\n    vec3 a = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 109, 109, 284], [513, 513, 540, 540, 568], [569, 569, 596, 596, 624], [625, 625, 662, 662, 772], [774, 774, 792, 792, 1049], [1051, 1097, 1118, 1118, 1357], [1459, 1459, 1495, 1495, 1743], [1745, 1745, 1767, 1817, 3564], [3566, 3566, 3606, 3606, 3762]], "test": "untested"}
{"id": "wsycD1", "name": "Neon Cells", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/tsVcDz]\"Strange fractal kaleidoscope.\"[/url]", "tags": ["fractal"], "likes": 7, "viewed": 412, "published": 3, "date": "1602720775", "time_retrieved": "2024-07-30T20:40:22.237671", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*20.0-iResolution.xy)/iResolution.y;\n        t = iTime;\n        for(int i=0;i<5;i++)\n        {\n            uv += sin(col.yx);\n        \tuv += float(i) + (sin(iTime+uv.x)+cos(iTime+uv.y));\n        }\n     col[c] = (sin(uv.x)+cos(uv.y));\n\t}\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 484]], "test": "untested"}
{"id": "tsGcD1", "name": "One pass lazy motion blur", "author": "illus0r", "description": "It's a oneliner!\nHave a look at `float mp(vec3 p)`", "tags": ["raymarching"], "likes": 26, "viewed": 877, "published": 3, "date": "1602716991", "time_retrieved": "2024-07-30T20:40:23.012599", "image_code": "precision mediump float;\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\nfloat rnd(float x){return fract(sin(x * 1100.082) * 13485.8372);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\nfloat sdTorus( vec3 p, vec2 t ){vec2 q = vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\n\nvec2 Rot2D (vec2 q, float a){return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);}\nvec3 IcosSym (vec3 p)\n{\n  float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  float a, w;\n  w = 2. * 3.1415 / 3.;\n  p.z = abs (p.z);\n  p.yz = Rot2D (p.yz, - dihedIcos);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedIcos);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedIcos);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\nfloat mp(vec3 p) {\n  p.z+=1.5;\n  float scale = 1.;\n  // THE MOTION BLUR HAPPENS HERE ↓\n  float t = iTime-0.15*rnd(p.y*3.3+p.x*7.7);\n  p.xy *=rot(floor(t)+smoothstep(0.,.4,fract(t)));\n  p.xz *=rot(floor(t)+smoothstep(.5,.9,fract(t)));\n  for(int i=0; i<1; i++){\n    scale*=3.;\n    p*=3.;\n    p = IcosSym(p);\n    p.z+=3.;\n    p.y-=.7;\n  }\n  return sdTorus(p,vec2(.5,.2))/scale;\n}\n\nvec3 nor(vec3 p){\n vec2 e=vec2(0,.001);\n return normalize(vec3(\n  mp(p+e.xxy)-mp(p-e.xxy),\n  mp(p+e.xyx)-mp(p-e.xyx),\n  mp(p+e.yxx)-mp(p-e.yxx)\n  ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n  float ii, d=0.,rm,i; vec3 p,n;\n  float mx = max(resolution.x, iResolution.y);\n  vec2 uv = (2.*fragCoord.xy-iResolution.xy) / mx;\n  for(float i=0.;i<90.;i++){\n    ii = float(i);\n    p=d*vec3(uv,.9);\n    p.z-=3.5;\n    rm=mp(p);\n    if(rm<.001)break;\n    d+=rm;\n  }\n  n=nor(p).bgr;\n  vec3 col1 = vec3(63,232,130)/255.;\n  vec3 col2 = vec3(0,71,255)/255.;\n  vec3 col = mix(col1, col2, (n.x+n.y)/2.+.5);\n  fragColor = vec4(col*10./(ii*d*d),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 156], [157, 157, 175, 175, 222], [223, 223, 255, 255, 313], [315, 315, 344, 344, 398], [399, 399, 422, 422, 927], [929, 929, 947, 947, 1307], [1309, 1309, 1326, 1326, 1460], [1462, 1462, 1517, 1517, 1960]], "test": "untested"}
{"id": "wdycW1", "name": "Basic Hex Grid", "author": "rtsonneveld", "description": "Extracted from mattz's shader: Hex grid traversal, https://www.shadertoy.com/view/XdSyzK", "tags": ["grid", "basic", "hex", "hexagonal"], "likes": 4, "viewed": 667, "published": 3, "date": "1602708429", "time_retrieved": "2024-07-30T20:40:23.835399", "image_code": "const float hex_factor = 0.8660254037844386;\n\n#define HEX_FROM_CART(p) vec2(p.x / hex_factor, p.y)\n#define CART_FROM_HEX(g) vec2(g.x * hex_factor, g.y)\n#define LINECOLOR vec3(0.75, 0.75, 0.75)\n\nvec2 nearestHexCell(in vec2 pos) {\n    \n    // integer coords in hex center grid -- will need to be adjusted\n    vec2 gpos = HEX_FROM_CART(pos);\n    vec2 hex_int = floor(gpos);\n\n    // adjust integer coords\n    float sy = step(2.0, mod(hex_int.x+1.0, 4.0));\n    hex_int += mod(vec2(hex_int.x, hex_int.y + sy), 2.0);\n\n    // difference vector\n    vec2 gdiff = gpos - hex_int;\n\n    // figure out which side of line we are on and modify\n    // hex center if necessary\n    if (dot(abs(gdiff), vec2(hex_factor*hex_factor, 0.5)) > 1.0) {\n        vec2 delta = sign(gdiff) * vec2(2.0, 1.0);\n        hex_int += delta;\n    }\n\n    return hex_int;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Used only for visualization\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float scl = 10.5 / iResolution.y;\n\n    float gridline_width = max(0.01, 0.125*scl);\n    float outline_dist = max(0.15, 3.0*scl);\n\n    //////////////////////////////////////////////////\n    // get fragment position\n    vec2 pos = (fragCoord.xy + 0.5 - .5*iResolution.xy) * scl;\n\n\n    //////////////////////////////////////////////////\n    // visualization\n\n    vec2 pos_cell = nearestHexCell(pos);\n    \n    float d = abs(hexDist(pos - CART_FROM_HEX(pos_cell)));\n\n    vec3 c;\n\n    c = LINECOLOR;\n\n    // grid lines\n    c *= smoothstep(0.0, scl, d-gridline_width);\n\n    fragColor = vec4(c, 1.0);\n            \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdycW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 228, 302, 836], [941, 941, 964, 964, 1040], [1131, 1131, 1188, 1188, 1801]], "test": "untested"}
{"id": "tsGcWh", "name": "Fab16 #inktober2020 \"rocket\"", "author": "FabriceNeyret2", "description": "Tintin Moon rocket !\nmouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nref image: [url]https://www.google.com/search?q=fus%C3%A9e%20tintin&tbm=isch[/url]", "tags": ["short", "golf", "reproduction", "inktober2020"], "likes": 10, "viewed": 355, "published": 3, "date": "1602695329", "time_retrieved": "2024-07-30T20:40:24.595367", "image_code": "// profiles study: see https://www.desmos.com/calculator/d46meujota\n\n#define L           length\n#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n#define P(x,r,h)    t = min(t, max( L(vec2(x,q.z)) - r, h) ), // cylinderical profile\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a=1.05,A, y, s = 20., h,z;\n    vec3  R = iResolution,\n          M = iMouse.z > 0. ? iMouse.xyz/R : .2 + .3*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -5.*R.y ) - R ),           // ray direction\n          p = 50./R, q;                                       // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot(-.4 +3.*M.y),                             // rotations\n        q.xz *= rot(-.7 -6.*M.x),\n        q.xy *= rot(1.),\n        q.y += s/1.8,\n        h = q.y/s, y = s*.06*sin(3.14*h*h*h),                 // rocket body (profile 1)\n        P( q.x , y, L(h-.7)-.3 )\n        A = mod( atan(q.z,q.x) +a, a+a ) -a,                  // 3-fold angular symmetry\n        q.xz = L(q.xz) * cos( A + vec2(0,11) ),\n        y = (1.-(q.x+.3)*(q.x+.3))/6.,                        // rocket legs (profile 2)\n        P( (q.y-y-9.3)*.2, .27, q.x-4. ) \n        q.x-=4., z=h*5.-1., y = s*.08*sqrt(max(0.,z))*(1.-z), // rocket feet (profile 3)\n        P( q.x,  y, L(z-.5)-.5 )\n        p += t*D;                                             // step forward = dist to obj          \n\n    O = (    L(h-.7) < .16                                    // coloring\n          && mod( ceil(.95*A)+ceil(h*15.) , 2. ) < 1.         // checker\n          ? vec4(1) : vec4(1,0,0,1)                           // red-white \n        ) *exp(-5.*O)*1.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dycDh", "name": "Yab and YCH", "author": "thepheer", "description": "YCH ↔ Yab ↔ RGB color conversion.\n\nhttps://acescentral.com/knowledge-base-2/lmts-part-4-how-do-they-work-and-how-are-they-made/\n", "tags": ["color", "rgb", "yab", "ych"], "likes": 3, "viewed": 326, "published": 3, "date": "1602686406", "time_retrieved": "2024-07-30T20:40:25.355335", "image_code": "const mat3 Yab_TO_RGB = mat3(3., 3., 3., 4., -2., -2., 0., sqrt(3.), -sqrt(3.))/3.;\nconst mat3 RGB_TO_Yab = mat3(4., 6., 0., 4., -3., 6.*sqrt(3.), 4., -3., -6.*sqrt(3.))/12.;\n\nvec3 Yab_to_RGB(vec3 Yab) { return Yab_TO_RGB*Yab; }\nvec3 RGB_to_Yab(vec3 rgb) { return RGB_TO_Yab*rgb; }\n\nvec3 YCH_to_Yab(vec3 YCH) { return vec3(YCH.x, YCH.y*vec2(cos(YCH.z), sin(YCH.z))); }\nvec3 Yab_to_YCH(vec3 Yab) { return vec3(Yab.x, length(Yab.yz), atan(Yab.z, Yab.y)); }\n\nvec3 YCH_to_RGB(vec3 YCH) { return Yab_to_RGB(YCH_to_Yab(YCH)); }\nvec3 RGB_to_YCH(vec3 rgb) { return Yab_to_YCH(RGB_to_Yab(rgb)); }\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n\tconst float tau = radians(360.0);\n    vec2 uv = xy/iResolution.xy;\n    vec3 hsl = vec3(uv.x, 0.5 + 0.5*cos(iTime), uv.y);\n    vec3 ych = vec3(hsl.z, hsl.y*hsl.z*(1.0-hsl.z), tau*hsl.x);\n   \tvec3 rgb = YCH_to_RGB(ych);\n    rgba = vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dycDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 203, 203, 228], [229, 229, 256, 256, 281], [283, 283, 310, 310, 368], [369, 369, 396, 396, 454], [456, 456, 483, 483, 521], [522, 522, 549, 549, 587], [589, 589, 629, 629, 877]], "test": "untested"}
{"id": "WdGcD1", "name": "ACES Filmic Tonemapping", "author": "thepheer", "description": "Comparison of some fast approximation (solid) and the actual reference implementation (dashed).", "tags": ["tonemapping", "filmic", "aces"], "likes": 6, "viewed": 1070, "published": 3, "date": "1602686168", "time_retrieved": "2024-07-30T20:40:26.479330", "image_code": "#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(x, a, b) ((a) <= (x) && (x) < (b))\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    \n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n\n    vec3 src = texture(iChannel0, vec2(xy.x, 0.5)*px).rgb;\n    vec3 ref = texture(iChannel0, vec2(xy.x, 1.5)*px).rgb;\n    vec3 apx = texture(iChannel0, vec2(xy.x, 2.5)*px).rgb;\n    \n    vec3 plots =\n        plot(px.y, uv.y, 0.7 + (apx - ref)) + // error\n        plot(px.y, uv.y, 0.7*ref)*dashed + // filmic\n        plot(px.y, uv.y, 0.7*apx); // filmic approx.\n\n    vec3 rgb =\n        range(uv.y, px.y + 0.95, 1.00) ? src : // source color\n    \trange(uv.y, px.y + 0.90, 0.95) ? ref : // filmic\n    \trange(uv.y, px.y + 0.85, 0.90) ? apx : // filmic approx.\n    \t0.5*plots;\n\n    rgba = vec4(linear_to_sRGB(rgb), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://github.com/Unity-Technologies/PostProcessing/blob/v2/PostProcessing/Shaders/ACES.hlsl\n\n/**\n * https://github.com/ampas/aces-dev\n *\n * Academy Color Encoding System (ACES) software and tools are provided by the\n * Academy under the following terms and conditions: A worldwide, royalty-free,\n * non-exclusive right to copy, modify, create derivatives, and use, in source and\n * binary forms, is hereby granted, subject to acceptance of this license.\n *\n * Copyright 2015 Academy of Motion Picture Arts and Sciences (A.M.P.A.S.).\n * Portions contributed by others as indicated. All rights reserved.\n *\n * Performance of any of the aforementioned acts indicates acceptance to be bound\n * by the following terms and conditions:\n *\n * * Copies of source code, in whole or in part, must retain the above copyright\n * notice, this list of conditions and the Disclaimer of Warranty.\n *\n * * Use in binary form must retain the above copyright notice, this list of\n * conditions and the Disclaimer of Warranty in the documentation and/or other\n * materials provided with the distribution.\n *\n * * Nothing in this license shall be deemed to grant any rights to trademarks,\n * copyrights, patents, trade secrets or any other intellectual property of\n * A.M.P.A.S. or any contributors, except as expressly stated herein.\n *\n * * Neither the name \"A.M.P.A.S.\" nor the name of any other contributors to this\n * software may be used to endorse or promote products derivative of or based on\n * this software without express prior written permission of A.M.P.A.S. or the\n * contributors, as appropriate.\n *\n * This license shall be construed pursuant to the laws of the State of\n * California, and any disputes related thereto shall be subject to the\n * jurisdiction of the courts therein.\n *\n * Disclaimer of Warranty: THIS SOFTWARE IS PROVIDED BY A.M.P.A.S. AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND\n * NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL A.M.P.A.S., OR ANY\n * CONTRIBUTORS OR DISTRIBUTORS, BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, RESITUTIONARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, THE ACADEMY SPECIFICALLY\n * DISCLAIMS ANY REPRESENTATIONS OR WARRANTIES WHATSOEVER RELATED TO PATENT OR\n * OTHER INTELLECTUAL PROPERTY RIGHTS IN THE ACADEMY COLOR ENCODING SYSTEM, OR\n * APPLICATIONS THEREOF, HELD BY PARTIES OTHER THAN A.M.P.A.S.,WHETHER DISCLOSED OR\n * UNDISCLOSED.\n */\n\n#define HALF float\n#define HALF2 vec2\n#define HALF3 vec3\n#define HALF4 vec4\n#define HALF3X3 mat3\n#define HALF4X4 mat4\n\n#define atan2 atan\n#define lerp mix\n#define log10(x) (log(x)/log(10.0))\n#define mul(a, b) ((b)*(a))\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// <include \"StdLib.hlsl\">\n#define HALF_MAX 65504.0 // (2 - 2^-10) * 2^15\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38 // Maximum representable floating-point number\nfloat FastSign(float x) { return saturate(x * FLT_MAX + 0.5) * 2.0 - 1.0; }\nfloat Min3(float a, float b, float c) { return min(min(a, b), c); }\nfloat Max3(float a, float b, float c) { return max(max(a, b), c); }\n// </include>\n\n#define ACEScc_MAX      1.4679964\n#define ACEScc_MIDGRAY  0.4135884\n\n//\n// Precomputed matrices (pre-transposed)\n// See https://github.com/ampas/aces-dev/blob/master/transforms/ctl/README-MATRIX.md\n//\n/*static*/ const HALF3X3 sRGB_2_AP0 = HALF3X3(\n    0.4397010, 0.3829780, 0.1773350,\n    0.0897923, 0.8134230, 0.0967616,\n    0.0175440, 0.1115440, 0.8707040\n);\n\n/*static*/ const HALF3X3 sRGB_2_AP1 = HALF3X3(\n    0.61319, 0.33951, 0.04737,\n    0.07021, 0.91634, 0.01345,\n    0.02062, 0.10957, 0.86961\n);\n\n/*static*/ const HALF3X3 AP0_2_sRGB = HALF3X3(\n    2.52169, -1.13413, -0.38756,\n    -0.27648, 1.37272, -0.09624,\n    -0.01538, -0.15298, 1.16835\n);\n\n/*static*/ const HALF3X3 AP1_2_sRGB = HALF3X3(\n    1.70505, -0.62179, -0.08326,\n    -0.13026, 1.14080, -0.01055,\n    -0.02400, -0.12897, 1.15297\n);\n\n/*static*/ const HALF3X3 AP0_2_AP1_MAT = HALF3X3(\n     1.4514393161, -0.2365107469, -0.2149285693,\n    -0.0765537734,  1.1762296998, -0.0996759264,\n     0.0083161484, -0.0060324498,  0.9977163014\n);\n\n/*static*/ const HALF3X3 AP1_2_AP0_MAT = HALF3X3(\n     0.6954522414, 0.1406786965, 0.1638690622,\n     0.0447945634, 0.8596711185, 0.0955343182,\n    -0.0055258826, 0.0040252103, 1.0015006723\n);\n\n/*static*/ const HALF3X3 AP1_2_XYZ_MAT = HALF3X3(\n     0.6624541811, 0.1340042065, 0.1561876870,\n     0.2722287168, 0.6740817658, 0.0536895174,\n    -0.0055746495, 0.0040607335, 1.0103391003\n);\n\n/*static*/ const HALF3X3 XYZ_2_AP1_MAT = HALF3X3(\n     1.6410233797, -0.3248032942, -0.2364246952,\n    -0.6636628587,  1.6153315917,  0.0167563477,\n     0.0117218943, -0.0082844420,  0.9883948585\n);\n\n/*static*/ const HALF3X3 XYZ_2_REC709_MAT = HALF3X3(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\n/*static*/ const HALF3X3 XYZ_2_REC2020_MAT = HALF3X3(\n     1.7166511880, -0.3556707838, -0.2533662814,\n    -0.6666843518,  1.6164812366,  0.0157685458,\n     0.0176398574, -0.0427706133,  0.9421031212\n);\n\n/*static*/ const HALF3X3 XYZ_2_DCIP3_MAT = HALF3X3(\n     2.7253940305, -1.0180030062, -0.4401631952,\n    -0.7951680258,  1.6897320548,  0.0226471906,\n     0.0412418914, -0.0876390192,  1.1009293786\n);\n\n/*static*/ const HALF3 AP1_RGB2Y = HALF3(0.272229, 0.674082, 0.0536895);\n\n/*static*/ const HALF3X3 RRT_SAT_MAT = HALF3X3(\n    0.9708890, 0.0269633, 0.00214758,\n    0.0108892, 0.9869630, 0.00214758,\n    0.0108892, 0.0269633, 0.96214800\n);\n\n/*static*/ const HALF3X3 ODT_SAT_MAT = HALF3X3(\n    0.949056, 0.0471857, 0.00375827,\n    0.019056, 0.9771860, 0.00375827,\n    0.019056, 0.0471857, 0.93375800\n);\n\n/*static*/ const HALF3X3 D60_2_D65_CAT = HALF3X3(\n     0.98722400, -0.00611327, 0.0159533,\n    -0.00759836,  1.00186000, 0.0053302,\n     0.00307257, -0.00509595, 1.0816800\n);\n\n//\n// Unity to ACES\n//\n// converts Unity raw (sRGB primaries) to\n//          ACES2065-1 (AP0 w/ linear encoding)\n//\nHALF3 unity_to_ACES(HALF3 x)\n{\n    x = mul(sRGB_2_AP0, x);\n    return x;\n}\n\n//\n// ACES to Unity\n//\n// converts ACES2065-1 (AP0 w/ linear encoding)\n//          Unity raw (sRGB primaries) to\n//\nHALF3 ACES_to_unity(HALF3 x)\n{\n    x = mul(AP0_2_sRGB, x);\n    return x;\n}\n\n//\n// Unity to ACEScg\n//\n// converts Unity raw (sRGB primaries) to\n//          ACEScg (AP1 w/ linear encoding)\n//\nHALF3 unity_to_ACEScg(HALF3 x)\n{\n    x = mul(sRGB_2_AP1, x);\n    return x;\n}\n\n//\n// ACEScg to Unity\n//\n// converts ACEScg (AP1 w/ linear encoding) to\n//          Unity raw (sRGB primaries)\n//\nHALF3 ACEScg_to_unity(HALF3 x)\n{\n    x = mul(AP1_2_sRGB, x);\n    return x;\n}\n\n//\n// ACES Color Space Conversion - ACES to ACEScc\n//\n// converts ACES2065-1 (AP0 w/ linear encoding) to\n//          ACEScc (AP1 w/ logarithmic encoding)\n//\n// This transform follows the formulas from section 4.4 in S-2014-003\n//\nHALF ACES_to_ACEScc(HALF x)\n{\n    if (x <= 0.0)\n        return -0.35828683; // = (log2(pow(2.0, -15.0) * 0.5) + 9.72) / 17.52\n    else if (x < pow(2.0, -15.0))\n        return (log2(pow(2.0, -16.0) + x * 0.5) + 9.72) / 17.52;\n    else // (x >= pow(2.0, -15.0))\n        return (log2(x) + 9.72) / 17.52;\n}\n\nHALF3 ACES_to_ACEScc(HALF3 x)\n{\n    x = clamp(x, 0.0, HALF_MAX);\n\n    // x is clamped to [0, HALF_MAX], skip the <= 0 check\n    //return (x < 0.00003051757) ? (log2(0.00001525878 + x * 0.5) + 9.72) / 17.52 : (log2(x) + 9.72) / 17.52;\n\n    return HALF3(\n        ACES_to_ACEScc(x.r),\n        ACES_to_ACEScc(x.g),\n        ACES_to_ACEScc(x.b)\n    );\n}\n\n//\n// ACES Color Space Conversion - ACEScc to ACES\n//\n// converts ACEScc (AP1 w/ ACESlog encoding) to\n//          ACES2065-1 (AP0 w/ linear encoding)\n//\n// This transform follows the formulas from section 4.4 in S-2014-003\n//\nHALF ACEScc_to_ACES(HALF x)\n{\n    // TODO: Optimize me\n    if (x < -0.3013698630) // (9.72 - 15) / 17.52\n        return (pow(2.0, x * 17.52 - 9.72) - pow(2.0, -16.0)) * 2.0;\n    else if (x < (log2(HALF_MAX) + 9.72) / 17.52)\n        return pow(2.0, x * 17.52 - 9.72);\n    else // (x >= (log2(HALF_MAX) + 9.72) / 17.52)\n        return HALF_MAX;\n}\n\nHALF3 ACEScc_to_ACES(HALF3 x)\n{\n    return HALF3(\n        ACEScc_to_ACES(x.r),\n        ACEScc_to_ACES(x.g),\n        ACEScc_to_ACES(x.b)\n    );\n}\n\n//\n// ACES Color Space Conversion - ACES to ACEScg\n//\n// converts ACES2065-1 (AP0 w/ linear encoding) to\n//          ACEScg (AP1 w/ linear encoding)\n//\nHALF3 ACES_to_ACEScg(HALF3 x)\n{\n    return mul(AP0_2_AP1_MAT, x);\n}\n\n//\n// ACES Color Space Conversion - ACEScg to ACES\n//\n// converts ACEScg (AP1 w/ linear encoding) to\n//          ACES2065-1 (AP0 w/ linear encoding)\n//\nHALF3 ACEScg_to_ACES(HALF3 x)\n{\n    return mul(AP1_2_AP0_MAT, x);\n}\n\n//\n// Reference Rendering Transform (RRT)\n//\n//   Input is ACES\n//   Output is OCES\n//\nHALF rgb_2_saturation(HALF3 rgb)\n{\n    const HALF TINY = 1e-4;\n    HALF mi = Min3(rgb.r, rgb.g, rgb.b);\n    HALF ma = Max3(rgb.r, rgb.g, rgb.b);\n    return (max(ma, TINY) - max(mi, TINY)) / max(ma, 1e-2);\n}\n\nHALF rgb_2_yc(HALF3 rgb)\n{\n    const HALF ycRadiusWeight = 1.75;\n\n    // Converts RGB to a luminance proxy, here called YC\n    // YC is ~ Y + K * Chroma\n    // Constant YC is a cone-shaped surface in RGB space, with the tip on the\n    // neutral axis, towards white.\n    // YC is normalized: RGB 1 1 1 maps to YC = 1\n    //\n    // ycRadiusWeight defaults to 1.75, although can be overridden in function\n    // call to rgb_2_yc\n    // ycRadiusWeight = 1 -> YC for pure cyan, magenta, yellow == YC for neutral\n    // of same value\n    // ycRadiusWeight = 2 -> YC for pure red, green, blue  == YC for  neutral of\n    // same value.\n\n    HALF r = rgb.x;\n    HALF g = rgb.y;\n    HALF b = rgb.z;\n    HALF chroma = sqrt(b * (b - g) + g * (g - r) + r * (r - b));\n    return (b + g + r + ycRadiusWeight * chroma) / 3.0;\n}\n\nHALF rgb_2_hue(HALF3 rgb)\n{\n    // Returns a geometric hue angle in degrees (0-360) based on RGB values.\n    // For neutral colors, hue is undefined and the function will return a quiet NaN value.\n    HALF hue;\n    if (rgb.x == rgb.y && rgb.y == rgb.z)\n        hue = 0.0; // RGB triplets where RGB are equal have an undefined hue\n    else\n        hue = (180.0 / PI) * atan2(sqrt(3.0) * (rgb.y - rgb.z), 2.0 * rgb.x - rgb.y - rgb.z);\n\n    if (hue < 0.0) hue = hue + 360.0;\n\n    return hue;\n}\n\nHALF center_hue(HALF hue, HALF centerH)\n{\n    HALF hueCentered = hue - centerH;\n    if (hueCentered < -180.0) hueCentered = hueCentered + 360.0;\n    else if (hueCentered > 180.0) hueCentered = hueCentered - 360.0;\n    return hueCentered;\n}\n\nHALF sigmoid_shaper(HALF x)\n{\n    // Sigmoid function in the range 0 to 1 spanning -2 to +2.\n\n    HALF t = max(1.0 - abs(x / 2.0), 0.0);\n    HALF y = 1.0 + FastSign(x) * (1.0 - t * t);\n\n    return y / 2.0;\n}\n\nHALF glow_fwd(HALF ycIn, HALF glowGainIn, HALF glowMid)\n{\n    HALF glowGainOut;\n\n    if (ycIn <= 2.0 / 3.0 * glowMid)\n        glowGainOut = glowGainIn;\n    else if (ycIn >= 2.0 * glowMid)\n        glowGainOut = 0.0;\n    else\n        glowGainOut = glowGainIn * (glowMid / ycIn - 1.0 / 2.0);\n\n    return glowGainOut;\n}\n\nHALF cubic_basis_shaper\n(\n    HALF x,\n    HALF w   // full base width of the shaper function (in degrees)\n)\n{\n    HALF4X4 M = HALF4X4(\n        HALF4( -1.0 / 6.0,  3.0 / 6.0, -3.0 / 6.0,  1.0 / 6.0 ),\n        HALF4(  3.0 / 6.0, -6.0 / 6.0,  3.0 / 6.0,  0.0 / 6.0 ),\n        HALF4( -3.0 / 6.0,  0.0 / 6.0,  3.0 / 6.0,  0.0 / 6.0 ),\n        HALF4(  1.0 / 6.0,  4.0 / 6.0,  1.0 / 6.0,  0.0 / 6.0 )\n    );\n\n    HALF knots[5] = HALF[](\n        -w / 2.0,\n        -w / 4.0,\n             0.0,\n         w / 4.0,\n         w / 2.0\n    );\n\n    HALF y = 0.0;\n    if ((x > knots[0]) && (x < knots[4]))\n    {\n        HALF knot_coord = (x - knots[0]) * 4.0 / w;\n        int j = int(knot_coord);\n        HALF t = knot_coord - HALF(j);\n\n        HALF monomials[4] = HALF[](t*t*t, t*t, t, 1.0);\n\n        // (if/else structure required for compatibility with CTL < v1.5.)\n        if (j == 3)\n        {\n            y = monomials[0] * M[0][0] + monomials[1] * M[1][0] +\n                monomials[2] * M[2][0] + monomials[3] * M[3][0];\n        }\n        else if (j == 2)\n        {\n            y = monomials[0] * M[0][1] + monomials[1] * M[1][1] +\n                monomials[2] * M[2][1] + monomials[3] * M[3][1];\n        }\n        else if (j == 1)\n        {\n            y = monomials[0] * M[0][2] + monomials[1] * M[1][2] +\n                monomials[2] * M[2][2] + monomials[3] * M[3][2];\n        }\n        else if (j == 0)\n        {\n            y = monomials[0] * M[0][3] + monomials[1] * M[1][3] +\n                monomials[2] * M[2][3] + monomials[3] * M[3][3];\n        }\n        else\n        {\n            y = 0.0;\n        }\n    }\n\n    return y * 3.0 / 2.0;\n}\n\n/*static*/ const HALF3X3 M = HALF3X3(\n     0.5, -1.0, 0.5,\n    -1.0,  1.0, 0.0,\n     0.5,  0.5, 0.0\n);\n\nHALF segmented_spline_c5_fwd(HALF x)\n{\n    const HALF coefsLow[6] = HALF[](-4.0000000000, -4.0000000000, -3.1573765773, -0.4852499958, 1.8477324706, 1.8477324706); // coefs for B-spline between minPoint and midPoint (units of log luminance)\n    const HALF coefsHigh[6] = HALF[](-0.7185482425, 2.0810307172, 3.6681241237, 4.0000000000, 4.0000000000, 4.0000000000); // coefs for B-spline between midPoint and maxPoint (units of log luminance)\n    const HALF2 minPoint = HALF2(0.18 * exp2(-15.0), 0.0001); // {luminance, luminance} linear extension below this\n    const HALF2 midPoint = HALF2(0.18, 0.48); // {luminance, luminance}\n    const HALF2 maxPoint = HALF2(0.18 * exp2(18.0), 10000.0); // {luminance, luminance} linear extension above this\n    const HALF slopeLow = 0.0; // log-log slope of low linear extension\n    const HALF slopeHigh = 0.0; // log-log slope of high linear extension\n\n    const int N_KNOTS_LOW = 4;\n    const int N_KNOTS_HIGH = 4;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to ACESMIN.1\n    float xCheck = x;\n    if (xCheck <= 0.0) xCheck = 0.00006103515; // = pow(2.0, -14.0);\n\n    HALF logx = log10(xCheck);\n    HALF logy;\n\n    if (logx <= log10(minPoint.x))\n    {\n        logy = logx * slopeLow + (log10(minPoint.y) - slopeLow * log10(minPoint.x));\n    }\n    else if ((logx > log10(minPoint.x)) && (logx < log10(midPoint.x)))\n    {\n        HALF knot_coord = HALF(N_KNOTS_LOW - 1) * (logx - log10(minPoint.x)) / (log10(midPoint.x) - log10(minPoint.x));\n        int j = int(knot_coord);\n        HALF t = knot_coord - HALF(j);\n\n        HALF3 cf = HALF3(coefsLow[j], coefsLow[j + 1], coefsLow[j + 2]);\n        HALF3 monomials = HALF3(t * t, t, 1.0);\n        logy = dot(monomials, mul(M, cf));\n    }\n    else if ((logx >= log10(midPoint.x)) && (logx < log10(maxPoint.x)))\n    {\n        HALF knot_coord = HALF(N_KNOTS_HIGH - 1) * (logx - log10(midPoint.x)) / (log10(maxPoint.x) - log10(midPoint.x));\n        int j = int(knot_coord);\n        HALF t = knot_coord - HALF(j);\n\n        HALF3 cf = HALF3(coefsHigh[j], coefsHigh[j + 1], coefsHigh[j + 2]);\n        HALF3 monomials = HALF3(t * t, t, 1.0);\n        logy = dot(monomials, mul(M, cf));\n    }\n    else\n    { //if (logIn >= log10(maxPoint.x)) {\n        logy = logx * slopeHigh + (log10(maxPoint.y) - slopeHigh * log10(maxPoint.x));\n    }\n\n    return pow(10.0, logy);\n}\n\nHALF segmented_spline_c9_fwd(HALF x)\n{\n    const HALF coefsLow[10] = HALF[](-1.6989700043, -1.6989700043, -1.4779000000, -1.2291000000, -0.8648000000, -0.4480000000, 0.0051800000, 0.4511080334, 0.9113744414, 0.9113744414); // coefs for B-spline between minPoint and midPoint (units of log luminance)\n    const HALF coefsHigh[10] = HALF[](0.5154386965, 0.8470437783, 1.1358000000, 1.3802000000, 1.5197000000, 1.5985000000, 1.6467000000, 1.6746091357, 1.6878733390, 1.6878733390); // coefs for B-spline between midPoint and maxPoint (units of log luminance)\n    /*const*/ HALF2 minPoint = HALF2(segmented_spline_c5_fwd(0.18 * exp2(-6.5)), 0.02); // {luminance, luminance} linear extension below this\n    /*const*/ HALF2 midPoint = HALF2(segmented_spline_c5_fwd(0.18), 4.8); // {luminance, luminance}\n    /*const*/ HALF2 maxPoint = HALF2(segmented_spline_c5_fwd(0.18 * exp2(6.5)), 48.0); // {luminance, luminance} linear extension above this\n    const HALF slopeLow = 0.0; // log-log slope of low linear extension\n    const HALF slopeHigh = 0.04; // log-log slope of high linear extension\n\n    const int N_KNOTS_LOW = 8;\n    const int N_KNOTS_HIGH = 8;\n\n    // Check for negatives or zero before taking the log. If negative or zero,\n    // set to OCESMIN.\n    HALF xCheck = x;\n    if (xCheck <= 0.0) xCheck = 1e-4;\n\n    HALF logx = log10(xCheck);\n    HALF logy;\n\n    if (logx <= log10(minPoint.x))\n    {\n        logy = logx * slopeLow + (log10(minPoint.y) - slopeLow * log10(minPoint.x));\n    }\n    else if ((logx > log10(minPoint.x)) && (logx < log10(midPoint.x)))\n    {\n        HALF knot_coord = HALF(N_KNOTS_LOW - 1) * (logx - log10(minPoint.x)) / (log10(midPoint.x) - log10(minPoint.x));\n        int j = int(knot_coord);\n        HALF t = knot_coord - HALF(j);\n\n        HALF3 cf = HALF3(coefsLow[j], coefsLow[j + 1], coefsLow[j + 2]);\n        HALF3 monomials = HALF3(t * t, t, 1.0);\n        logy = dot(monomials, mul(M, cf));\n    }\n    else if ((logx >= log10(midPoint.x)) && (logx < log10(maxPoint.x)))\n    {\n        HALF knot_coord = HALF(N_KNOTS_HIGH - 1) * (logx - log10(midPoint.x)) / (log10(maxPoint.x) - log10(midPoint.x));\n        int j = int(knot_coord);\n        HALF t = knot_coord - HALF(j);\n\n        HALF3 cf = HALF3(coefsHigh[j], coefsHigh[j + 1], coefsHigh[j + 2]);\n        HALF3 monomials = HALF3(t * t, t, 1.0);\n        logy = dot(monomials, mul(M, cf));\n    }\n    else\n    { //if (logIn >= log10(maxPoint.x)) {\n        logy = logx * slopeHigh + (log10(maxPoint.y) - slopeHigh * log10(maxPoint.x));\n    }\n\n    return pow(10.0, logy);\n}\n\n/*static*/ const HALF RRT_GLOW_GAIN = 0.05;\n/*static*/ const HALF RRT_GLOW_MID = 0.08;\n\n/*static*/ const HALF RRT_RED_SCALE = 0.82;\n/*static*/ const HALF RRT_RED_PIVOT = 0.03;\n/*static*/ const HALF RRT_RED_HUE = 0.0;\n/*static*/ const HALF RRT_RED_WIDTH = 135.0;\n\n/*static*/ const HALF RRT_SAT_FACTOR = 0.96;\n\nHALF3 RRT(HALF3 aces)\n{\n    // --- Glow module --- //\n    HALF saturation = rgb_2_saturation(aces);\n    HALF ycIn = rgb_2_yc(aces);\n    HALF s = sigmoid_shaper((saturation - 0.4) / 0.2);\n    HALF addedGlow = 1.0 + glow_fwd(ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\n    aces *= addedGlow;\n\n    // --- Red modifier --- //\n    HALF hue = rgb_2_hue(aces);\n    HALF centeredHue = center_hue(hue, RRT_RED_HUE);\n    HALF hueWeight;\n    {\n        //hueWeight = cubic_basis_shaper(centeredHue, RRT_RED_WIDTH);\n        hueWeight = smoothstep(0.0, 1.0, 1.0 - abs(2.0 * centeredHue / RRT_RED_WIDTH));\n        hueWeight *= hueWeight;\n    }\n\n    aces.r += hueWeight * saturation * (RRT_RED_PIVOT - aces.r) * (1.0 - RRT_RED_SCALE);\n\n    // --- ACES to RGB rendering space --- //\n    aces = clamp(aces, 0.0, HALF_MAX);  // avoids saturated negative colors from becoming positive in the matrix\n    HALF3 rgbPre = mul(AP0_2_AP1_MAT, aces);\n    rgbPre = clamp(rgbPre, 0.0, HALF_MAX);\n\n    // --- Global desaturation --- //\n    //rgbPre = mul(RRT_SAT_MAT, rgbPre);\n    rgbPre = lerp(HALF3(dot(rgbPre, AP1_RGB2Y)), rgbPre, RRT_SAT_FACTOR);\n\n    // --- Apply the tonescale independently in rendering-space RGB --- //\n    HALF3 rgbPost;\n    rgbPost.x = segmented_spline_c5_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c5_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c5_fwd(rgbPre.z);\n\n    // --- RGB rendering space to OCES --- //\n    HALF3 rgbOces = mul(AP1_2_AP0_MAT, rgbPost);\n\n    return rgbOces;\n}\n\n//\n// Output Device Transform\n//\nHALF3 Y_2_linCV(HALF3 Y, HALF Ymax, HALF Ymin)\n{\n    return (Y - Ymin) / (Ymax - Ymin);\n}\n\nHALF3 XYZ_2_xyY(HALF3 XYZ)\n{\n    HALF divisor = max(dot(XYZ, HALF3(1.0)), 1e-4);\n    return HALF3(XYZ.xy / divisor, XYZ.y);\n}\n\nHALF3 xyY_2_XYZ(HALF3 xyY)\n{\n    HALF m = xyY.z / max(xyY.y, 1e-4);\n    HALF3 XYZ = HALF3(xyY.xz, (1.0 - xyY.x - xyY.y));\n    XYZ.xz *= m;\n    return XYZ;\n}\n\n/*static*/ const HALF DIM_SURROUND_GAMMA = 0.9811;\n\nHALF3 darkSurround_to_dimSurround(HALF3 linearCV)\n{\n    HALF3 XYZ = mul(AP1_2_XYZ_MAT, linearCV);\n\n    HALF3 xyY = XYZ_2_xyY(XYZ);\n    xyY.z = clamp(xyY.z, 0.0, HALF_MAX);\n    xyY.z = pow(xyY.z, DIM_SURROUND_GAMMA);\n    XYZ = xyY_2_XYZ(xyY);\n\n    return mul(XYZ_2_AP1_MAT, XYZ);\n}\n\nHALF moncurve_r(HALF y, HALF gamma, HALF offs)\n{\n    // Reverse monitor curve\n    HALF x;\n    /*const*/ HALF yb = pow(offs * gamma / ((gamma - 1.0) * (1.0 + offs)), gamma);\n    /*const*/ HALF rs = pow((gamma - 1.0) / offs, gamma - 1.0) * pow((1.0 + offs) / gamma, gamma);\n    if (y >= yb)\n        x = (1.0 + offs) * pow(y, 1.0 / gamma) - offs;\n    else\n        x = y * rs;\n    return x;\n}\n\nHALF bt1886_r(HALF L, HALF gamma, HALF Lw, HALF Lb)\n{\n    // The reference EOTF specified in Rec. ITU-R BT.1886\n    // L = a(max[(V+b),0])^g\n    HALF a = pow(pow(Lw, 1.0 / gamma) - pow(Lb, 1.0 / gamma), gamma);\n    HALF b = pow(Lb, 1.0 / gamma) / (pow(Lw, 1.0 / gamma) - pow(Lb, 1.0 / gamma));\n    HALF V = pow(max(L / a, 0.0), 1.0 / gamma) - b;\n    return V;\n}\n\nHALF roll_white_fwd(\n    HALF x,       // color value to adjust (white scaled to around 1.0)\n    HALF new_wht, // white adjustment (e.g. 0.9 for 10% darkening)\n    HALF width    // adjusted width (e.g. 0.25 for top quarter of the tone scale)\n    )\n{\n    const HALF x0 = -1.0;\n    /*const*/ HALF x1 = x0 + width;\n    /*const*/ HALF y0 = -new_wht;\n    /*const*/ HALF y1 = x1;\n    /*const*/ HALF m1 = (x1 - x0);\n    /*const*/ HALF a = y0 - y1 + m1;\n    /*const*/ HALF b = 2.0 * (y1 - y0) - m1;\n    /*const*/ HALF c = y0;\n    /*const*/ HALF t = (-x - x0) / (x1 - x0);\n    HALF o = 0.0;\n    if (t < 0.0)\n        o = -(t * b + c);\n    else if (t > 1.0)\n        o = x;\n    else\n        o = -((t * a + b) * t + c);\n    return o;\n}\n\nHALF3 linear_to_sRGB(HALF3 x)\n{\n    // return (x <= 0.0031308 ? (x * 12.9232102) : 1.055 * pow(x, 1.0 / 2.4) - 0.055);\n    return lerp(1.055 * pow(x, HALF3(1.0 / 2.4)) - 0.055, (x * 12.9232102), lessThanEqual(x, HALF3(0.0031308)));\n}\n\nHALF3 linear_to_bt1886(HALF3 x, HALF gamma, HALF Lw, HALF Lb)\n{\n    // Good enough approximation for now, may consider using the exact formula instead\n    // TODO: Experiment\n    return pow(max(x, 0.0), HALF3(1.0 / 2.4));\n\n    // Correct implementation (Reference EOTF specified in Rec. ITU-R BT.1886) :\n    // L = a(max[(V+b),0])^g\n    HALF invgamma = 1.0 / gamma;\n    HALF p_Lw = pow(Lw, invgamma);\n    HALF p_Lb = pow(Lb, invgamma);\n    HALF3 a = HALF3(pow(p_Lw - p_Lb, gamma));\n    HALF3 b = HALF3(p_Lb / p_Lw - p_Lb);\n    HALF3 V = pow(max(x / a, 0.0), HALF3(invgamma)) - b;\n    return V;\n}\n\n/*static*/ const HALF CINEMA_WHITE = 48.0;\n/*static*/ const HALF CINEMA_BLACK = CINEMA_WHITE / 2400.0;\n/*static*/ const HALF ODT_SAT_FACTOR = 0.93;\n\n// <ACEStransformID>ODT.Academy.RGBmonitor_100nits_dim.a1.0.3</ACEStransformID>\n// <ACESuserName>ACES 1.0 Output - sRGB</ACESuserName>\n\n//\n// Output Device Transform - RGB computer monitor\n//\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a desktop computer monitor\n//  typical of those used in motion picture visual effects production. These\n//  monitors may occasionally be referred to as \"sRGB\" displays, however, the\n//  monitor for which this transform is designed does not exactly match the\n//  specifications in IEC 61966-2-1:1999.\n//\n//  The assumed observer adapted white is D65, and the viewing environment is\n//  that of a dim surround.\n//\n//  The monitor specified is intended to be more typical of those found in\n//  visual effects production.\n//\n// Device Primaries :\n//  Primaries are those specified in Rec. ITU-R BT.709\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.64      0.33\n//              Green:        0.3       0.6\n//              Blue:         0.15      0.06\n//              White:        0.3127    0.329     100 cd/m^2\n//\n// Display EOTF :\n//  The reference electro-optical transfer function specified in\n//  IEC 61966-2-1:1999.\n//\n// Signal Range:\n//    This transform outputs full range code values.\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.3127       0.329\n//\n// Viewing Environment:\n//   This ODT has a compensation for viewing environment variables more typical\n//   of those associated with video mastering.\n//\nHALF3 ODT_RGBmonitor_100nits_dim(HALF3 oces)\n{\n    // OCES to RGB rendering space\n    HALF3 rgbPre = mul(AP0_2_AP1_MAT, oces);\n\n    // Apply the tonescale independently in rendering-space RGB\n    HALF3 rgbPost;\n    rgbPost.x = segmented_spline_c9_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c9_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c9_fwd(rgbPre.z);\n\n    // Scale luminance to linear code value\n    HALF3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n\n     // Apply gamma adjustment to compensate for dim surround\n    linearCV = darkSurround_to_dimSurround(linearCV);\n\n    // Apply desaturation to compensate for luminance difference\n    //linearCV = mul(ODT_SAT_MAT, linearCV);\n    linearCV = lerp(HALF3(dot(linearCV, AP1_RGB2Y)), linearCV, ODT_SAT_FACTOR);\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    HALF3 XYZ = mul(AP1_2_XYZ_MAT, linearCV);\n\n    // Apply CAT from ACES white point to assumed observer adapted white point\n    XYZ = mul(D60_2_D65_CAT, XYZ);\n\n    // CIE XYZ to display primaries\n    linearCV = mul(XYZ_2_REC709_MAT, XYZ);\n\n    // Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = saturate(linearCV);\n\n    // TODO: Revisit when it is possible to deactivate Unity default framebuffer encoding\n    // with sRGB opto-electrical transfer function (OETF).\n    /*\n    // Encode linear code values with transfer function\n    HALF3 outputCV;\n    // moncurve_r with gamma of 2.4 and offset of 0.055 matches the EOTF found in IEC 61966-2-1:1999 (sRGB)\n    const HALF DISPGAMMA = 2.4;\n    const HALF OFFSET = 0.055;\n    outputCV.x = moncurve_r(linearCV.x, DISPGAMMA, OFFSET);\n    outputCV.y = moncurve_r(linearCV.y, DISPGAMMA, OFFSET);\n    outputCV.z = moncurve_r(linearCV.z, DISPGAMMA, OFFSET);\n\n    outputCV = linear_to_sRGB(linearCV);\n    */\n\n    // Unity already draws to a sRGB target\n    return linearCV;\n}\n\n// <ACEStransformID>ODT.Academy.RGBmonitor_D60sim_100nits_dim.a1.0.3</ACEStransformID>\n// <ACESuserName>ACES 1.0 Output - sRGB (D60 sim.)</ACESuserName>\n\n//\n// Output Device Transform - RGB computer monitor (D60 simulation)\n//\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a desktop computer monitor\n//  typical of those used in motion picture visual effects production. These\n//  monitors may occasionally be referred to as \"sRGB\" displays, however, the\n//  monitor for which this transform is designed does not exactly match the\n//  specifications in IEC 61966-2-1:1999.\n//\n//  The assumed observer adapted white is D60, and the viewing environment is\n//  that of a dim surround.\n//\n//  The monitor specified is intended to be more typical of those found in\n//  visual effects production.\n//\n// Device Primaries :\n//  Primaries are those specified in Rec. ITU-R BT.709\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.64      0.33\n//              Green:        0.3       0.6\n//              Blue:         0.15      0.06\n//              White:        0.3127    0.329     100 cd/m^2\n//\n// Display EOTF :\n//  The reference electro-optical transfer function specified in\n//  IEC 61966-2-1:1999.\n//\n// Signal Range:\n//    This transform outputs full range code values.\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.32168      0.33767\n//\n// Viewing Environment:\n//   This ODT has a compensation for viewing environment variables more typical\n//   of those associated with video mastering.\n//\nHALF3 ODT_RGBmonitor_D60sim_100nits_dim(HALF3 oces)\n{\n    // OCES to RGB rendering space\n    HALF3 rgbPre = mul(AP0_2_AP1_MAT, oces);\n\n    // Apply the tonescale independently in rendering-space RGB\n    HALF3 rgbPost;\n    rgbPost.x = segmented_spline_c9_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c9_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c9_fwd(rgbPre.z);\n\n    // Scale luminance to linear code value\n    HALF3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n\n    // --- Compensate for different white point being darker  --- //\n    // This adjustment is to correct an issue that exists in ODTs where the device\n    // is calibrated to a white chromaticity other than D60. In order to simulate\n    // D60 on such devices, unequal code values are sent to the display to achieve\n    // neutrals at D60. In order to produce D60 on a device calibrated to the DCI\n    // white point (i.e. equal code values yield CIE x,y chromaticities of 0.314,\n    // 0.351) the red channel is higher than green and blue to compensate for the\n    // \"greenish\" DCI white. This is the correct behavior but it means that as\n    // highlight increase, the red channel will hit the device maximum first and\n    // clip, resulting in a chromaticity shift as the green and blue channels\n    // continue to increase.\n    // To avoid this clipping error, a slight scale factor is applied to allow the\n    // ODTs to simulate D60 within the D65 calibration white point.\n\n    // Scale and clamp white to avoid casted highlights due to D60 simulation\n    const HALF SCALE = 0.955;\n    linearCV = min(linearCV, 1.0) * SCALE;\n\n    // Apply gamma adjustment to compensate for dim surround\n    linearCV = darkSurround_to_dimSurround(linearCV);\n\n    // Apply desaturation to compensate for luminance difference\n    //linearCV = mul(ODT_SAT_MAT, linearCV);\n    linearCV = lerp(HALF3(dot(linearCV, AP1_RGB2Y)), linearCV, ODT_SAT_FACTOR);\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    HALF3 XYZ = mul(AP1_2_XYZ_MAT, linearCV);\n\n    // CIE XYZ to display primaries\n    linearCV = mul(XYZ_2_REC709_MAT, XYZ);\n\n    // Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = saturate(linearCV);\n\n    // TODO: Revisit when it is possible to deactivate Unity default framebuffer encoding\n    // with sRGB opto-electrical transfer function (OETF).\n    /*\n    // Encode linear code values with transfer function\n    HALF3 outputCV;\n    // moncurve_r with gamma of 2.4 and offset of 0.055 matches the EOTF found in IEC 61966-2-1:1999 (sRGB)\n    const HALF DISPGAMMA = 2.4;\n    const HALF OFFSET = 0.055;\n    outputCV.x = moncurve_r(linearCV.x, DISPGAMMA, OFFSET);\n    outputCV.y = moncurve_r(linearCV.y, DISPGAMMA, OFFSET);\n    outputCV.z = moncurve_r(linearCV.z, DISPGAMMA, OFFSET);\n\n    outputCV = linear_to_sRGB(linearCV);\n    */\n\n    // Unity already draws to a sRGB target\n    return linearCV;\n}\n\n// <ACEStransformID>ODT.Academy.Rec709_100nits_dim.a1.0.3</ACEStransformID>\n// <ACESuserName>ACES 1.0 Output - Rec.709</ACESuserName>\n\n//\n// Output Device Transform - Rec709\n//\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a Rec.709 broadcast monitor\n//  that is calibrated to a D65 white point at 100 cd/m^2. The assumed observer\n//  adapted white is D65, and the viewing environment is a dim surround.\n//\n//  A possible use case for this transform would be HDTV/video mastering.\n//\n// Device Primaries :\n//  Primaries are those specified in Rec. ITU-R BT.709\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.64      0.33\n//              Green:        0.3       0.6\n//              Blue:         0.15      0.06\n//              White:        0.3127    0.329     100 cd/m^2\n//\n// Display EOTF :\n//  The reference electro-optical transfer function specified in\n//  Rec. ITU-R BT.1886.\n//\n// Signal Range:\n//    By default, this transform outputs full range code values. If instead a\n//    SMPTE \"legal\" signal is desired, there is a runtime flag to output\n//    SMPTE legal signal. In ctlrender, this can be achieved by appending\n//    '-param1 legalRange 1' after the '-ctl odt.ctl' string.\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.3127       0.329\n//\n// Viewing Environment:\n//   This ODT has a compensation for viewing environment variables more typical\n//   of those associated with video mastering.\n//\nHALF3 ODT_Rec709_100nits_dim(HALF3 oces)\n{\n    // OCES to RGB rendering space\n    HALF3 rgbPre = mul(AP0_2_AP1_MAT, oces);\n\n    // Apply the tonescale independently in rendering-space RGB\n    HALF3 rgbPost;\n    rgbPost.x = segmented_spline_c9_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c9_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c9_fwd(rgbPre.z);\n\n    // Scale luminance to linear code value\n    HALF3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n\n    // Apply gamma adjustment to compensate for dim surround\n    linearCV = darkSurround_to_dimSurround(linearCV);\n\n    // Apply desaturation to compensate for luminance difference\n    //linearCV = mul(ODT_SAT_MAT, linearCV);\n    linearCV = lerp(HALF3(dot(linearCV, AP1_RGB2Y)), linearCV, ODT_SAT_FACTOR);\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    HALF3 XYZ = mul(AP1_2_XYZ_MAT, linearCV);\n\n    // Apply CAT from ACES white point to assumed observer adapted white point\n    XYZ = mul(D60_2_D65_CAT, XYZ);\n\n    // CIE XYZ to display primaries\n    linearCV = mul(XYZ_2_REC709_MAT, XYZ);\n\n    // Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = saturate(linearCV);\n\n    // Encode linear code values with transfer function\n    const HALF DISPGAMMA = 2.4;\n    const HALF L_W = 1.0;\n    const HALF L_B = 0.0;\n    HALF3 outputCV = linear_to_bt1886(linearCV, DISPGAMMA, L_W, L_B);\n\n    // TODO: Implement support for legal range.\n\n    // NOTE: Unity framebuffer encoding is encoded with sRGB opto-electrical transfer function (OETF)\n    // by default which will result in double perceptual encoding, thus for now if one want to use\n    // this ODT, he needs to decode its output with sRGB electro-optical transfer function (EOTF) to\n    // compensate for Unity default behaviour.\n\n    return outputCV;\n}\n\n// <ACEStransformID>ODT.Academy.Rec709_D60sim_100nits_dim.a1.0.3</ACEStransformID>\n// <ACESuserName>ACES 1.0 Output - Rec.709 (D60 sim.)</ACESuserName>\n\n//\n// Output Device Transform - Rec709 (D60 simulation)\n//\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a Rec.709 broadcast monitor\n//  that is calibrated to a D65 white point at 100 cd/m^2. The assumed observer\n//  adapted white is D60, and the viewing environment is a dim surround.\n//\n//  A possible use case for this transform would be cinema \"soft-proofing\".\n//\n// Device Primaries :\n//  Primaries are those specified in Rec. ITU-R BT.709\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.64      0.33\n//              Green:        0.3       0.6\n//              Blue:         0.15      0.06\n//              White:        0.3127    0.329     100 cd/m^2\n//\n// Display EOTF :\n//  The reference electro-optical transfer function specified in\n//  Rec. ITU-R BT.1886.\n//\n// Signal Range:\n//    By default, this transform outputs full range code values. If instead a\n//    SMPTE \"legal\" signal is desired, there is a runtime flag to output\n//    SMPTE legal signal. In ctlrender, this can be achieved by appending\n//    '-param1 legalRange 1' after the '-ctl odt.ctl' string.\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.32168      0.33767\n//\n// Viewing Environment:\n//   This ODT has a compensation for viewing environment variables more typical\n//   of those associated with video mastering.\n//\nHALF3 ODT_Rec709_D60sim_100nits_dim(HALF3 oces)\n{\n    // OCES to RGB rendering space\n    HALF3 rgbPre = mul(AP0_2_AP1_MAT, oces);\n\n    // Apply the tonescale independently in rendering-space RGB\n    HALF3 rgbPost;\n    rgbPost.x = segmented_spline_c9_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c9_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c9_fwd(rgbPre.z);\n\n    // Scale luminance to linear code value\n    HALF3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n\n    // --- Compensate for different white point being darker  --- //\n    // This adjustment is to correct an issue that exists in ODTs where the device\n    // is calibrated to a white chromaticity other than D60. In order to simulate\n    // D60 on such devices, unequal code values must be sent to the display to achieve\n    // the chromaticities of D60. More specifically, in order to produce D60 on a device\n    // calibrated to a D65 white point (i.e. equal code values yield CIE x,y\n    // chromaticities of 0.3127, 0.329) the red channel must be slightly higher than\n    // that of green and blue in order to compensate for the relatively more \"blue-ish\"\n    // D65 white. This unequalness of color channels is the correct behavior but it\n    // means that as neutral highlights increase, the red channel will hit the\n    // device maximum first and clip, resulting in a small chromaticity shift as the\n    // green and blue channels continue to increase to their maximums.\n    // To avoid this clipping error, a slight scale factor is applied to allow the\n    // ODTs to simulate D60 within the D65 calibration white point.\n\n    // Scale and clamp white to avoid casted highlights due to D60 simulation\n    const HALF SCALE = 0.955;\n    linearCV = min(linearCV, 1.0) * SCALE;\n\n    // Apply gamma adjustment to compensate for dim surround\n    linearCV = darkSurround_to_dimSurround(linearCV);\n\n    // Apply desaturation to compensate for luminance difference\n    //linearCV = mul(ODT_SAT_MAT, linearCV);\n    linearCV = lerp(HALF3(dot(linearCV, AP1_RGB2Y)), linearCV, ODT_SAT_FACTOR);\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    HALF3 XYZ = mul(AP1_2_XYZ_MAT, linearCV);\n\n    // CIE XYZ to display primaries\n    linearCV = mul(XYZ_2_REC709_MAT, XYZ);\n\n    // Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = saturate(linearCV);\n\n    // Encode linear code values with transfer function\n    const HALF DISPGAMMA = 2.4;\n    const HALF L_W = 1.0;\n    const HALF L_B = 0.0;\n    HALF3 outputCV = linear_to_bt1886(linearCV, DISPGAMMA, L_W, L_B);\n\n    // TODO: Implement support for legal range.\n\n    // NOTE: Unity framebuffer encoding is encoded with sRGB opto-electrical transfer function (OETF)\n    // by default which will result in double perceptual encoding, thus for now if one want to use\n    // this ODT, he needs to decode its output with sRGB electro-optical transfer function (EOTF) to\n    // compensate for Unity default behaviour.\n\n    return outputCV;\n}\n\n// <ACEStransformID>ODT.Academy.Rec2020_100nits_dim.a1.0.3</ACEStransformID>\n// <ACESuserName>ACES 1.0 Output - Rec.2020</ACESuserName>\n\n//\n// Output Device Transform - Rec2020\n//\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a Rec.2020 broadcast\n//  monitor that is calibrated to a D65 white point at 100 cd/m^2. The assumed\n//  observer adapted white is D65, and the viewing environment is that of a dim\n//  surround.\n//\n//  A possible use case for this transform would be UHDTV/video mastering.\n//\n// Device Primaries :\n//  Primaries are those specified in Rec. ITU-R BT.2020\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.708     0.292\n//              Green:        0.17      0.797\n//              Blue:         0.131     0.046\n//              White:        0.3127    0.329     100 cd/m^2\n//\n// Display EOTF :\n//  The reference electro-optical transfer function specified in\n//  Rec. ITU-R BT.1886.\n//\n// Signal Range:\n//    By default, this transform outputs full range code values. If instead a\n//    SMPTE \"legal\" signal is desired, there is a runtime flag to output\n//    SMPTE legal signal. In ctlrender, this can be achieved by appending\n//    '-param1 legalRange 1' after the '-ctl odt.ctl' string.\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.3127       0.329\n//\n// Viewing Environment:\n//   This ODT has a compensation for viewing environment variables more typical\n//   of those associated with video mastering.\n//\n\nHALF3 ODT_Rec2020_100nits_dim(HALF3 oces)\n{\n    // OCES to RGB rendering space\n    HALF3 rgbPre = mul(AP0_2_AP1_MAT, oces);\n\n    // Apply the tonescale independently in rendering-space RGB\n    HALF3 rgbPost;\n    rgbPost.x = segmented_spline_c9_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c9_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c9_fwd(rgbPre.z);\n\n    // Scale luminance to linear code value\n    HALF3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n\n    // Apply gamma adjustment to compensate for dim surround\n    linearCV = darkSurround_to_dimSurround(linearCV);\n\n    // Apply desaturation to compensate for luminance difference\n    //linearCV = mul(ODT_SAT_MAT, linearCV);\n    linearCV = lerp(HALF3(dot(linearCV, AP1_RGB2Y)), linearCV, ODT_SAT_FACTOR);\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    HALF3 XYZ = mul(AP1_2_XYZ_MAT, linearCV);\n\n    // Apply CAT from ACES white point to assumed observer adapted white point\n    XYZ = mul(D60_2_D65_CAT, XYZ);\n\n    // CIE XYZ to display primaries\n    linearCV = mul(XYZ_2_REC2020_MAT, XYZ);\n\n    // Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = saturate(linearCV);\n\n    // Encode linear code values with transfer function\n    const HALF DISPGAMMA = 2.4;\n    const HALF L_W = 1.0;\n    const HALF L_B = 0.0;\n    HALF3 outputCV = linear_to_bt1886(linearCV, DISPGAMMA, L_W, L_B);\n\n    // TODO: Implement support for legal range.\n\n    // NOTE: Unity framebuffer encoding is encoded with sRGB opto-electrical transfer function (OETF)\n    // by default which will result in double perceptual encoding, thus for now if one want to use\n    // this ODT, he needs to decode its output with sRGB electro-optical transfer function (EOTF) to\n    // compensate for Unity default behaviour.\n\n    return outputCV;\n}\n\n// <ACEStransformID>ODT.Academy.P3DCI_48nits.a1.0.3</ACEStransformID>\n// <ACESuserName>ACES 1.0 Output - P3-DCI</ACESuserName>\n\n//\n// Output Device Transform - P3DCI (D60 Simulation)\n//\n\n//\n// Summary :\n//  This transform is intended for mapping OCES onto a P3 digital cinema\n//  projector that is calibrated to a DCI white point at 48 cd/m^2. The assumed\n//  observer adapted white is D60, and the viewing environment is that of a dark\n//  theater.\n//\n// Device Primaries :\n//  CIE 1931 chromaticities:  x         y         Y\n//              Red:          0.68      0.32\n//              Green:        0.265     0.69\n//              Blue:         0.15      0.06\n//              White:        0.314     0.351     48 cd/m^2\n//\n// Display EOTF :\n//  Gamma: 2.6\n//\n// Assumed observer adapted white point:\n//         CIE 1931 chromaticities:    x            y\n//                                     0.32168      0.33767\n//\n// Viewing Environment:\n//  Environment specified in SMPTE RP 431-2-2007\n//\nHALF3 ODT_P3DCI_48nits(HALF3 oces)\n{\n    // OCES to RGB rendering space\n    HALF3 rgbPre = mul(AP0_2_AP1_MAT, oces);\n\n    // Apply the tonescale independently in rendering-space RGB\n    HALF3 rgbPost;\n    rgbPost.x = segmented_spline_c9_fwd(rgbPre.x);\n    rgbPost.y = segmented_spline_c9_fwd(rgbPre.y);\n    rgbPost.z = segmented_spline_c9_fwd(rgbPre.z);\n\n    // Scale luminance to linear code value\n    HALF3 linearCV = Y_2_linCV(rgbPost, CINEMA_WHITE, CINEMA_BLACK);\n\n    // --- Compensate for different white point being darker  --- //\n    // This adjustment is to correct an issue that exists in ODTs where the device\n    // is calibrated to a white chromaticity other than D60. In order to simulate\n    // D60 on such devices, unequal code values are sent to the display to achieve\n    // neutrals at D60. In order to produce D60 on a device calibrated to the DCI\n    // white point (i.e. equal code values yield CIE x,y chromaticities of 0.314,\n    // 0.351) the red channel is higher than green and blue to compensate for the\n    // \"greenish\" DCI white. This is the correct behavior but it means that as\n    // highlight increase, the red channel will hit the device maximum first and\n    // clip, resulting in a chromaticity shift as the green and blue channels\n    // continue to increase.\n    // To avoid this clipping error, a slight scale factor is applied to allow the\n    // ODTs to simulate D60 within the D65 calibration white point. However, the\n    // magnitude of the scale factor required for the P3DCI ODT was considered too\n    // large. Therefore, the scale factor was reduced and the additional required\n    // compression was achieved via a reshaping of the highlight rolloff in\n    // conjunction with the scale. The shape of this rolloff was determined\n    // throught subjective experiments and deemed to best reproduce the\n    // \"character\" of the highlights in the P3D60 ODT.\n\n    // Roll off highlights to avoid need for as much scaling\n    const HALF NEW_WHT = 0.918;\n    const HALF ROLL_WIDTH = 0.5;\n    linearCV.x = roll_white_fwd(linearCV.x, NEW_WHT, ROLL_WIDTH);\n    linearCV.y = roll_white_fwd(linearCV.y, NEW_WHT, ROLL_WIDTH);\n    linearCV.z = roll_white_fwd(linearCV.z, NEW_WHT, ROLL_WIDTH);\n\n    // Scale and clamp white to avoid casted highlights due to D60 simulation\n    const HALF SCALE = 0.96;\n    linearCV = min(linearCV, NEW_WHT) * SCALE;\n\n    // Convert to display primary encoding\n    // Rendering space RGB to XYZ\n    HALF3 XYZ = mul(AP1_2_XYZ_MAT, linearCV);\n\n    // CIE XYZ to display primaries\n    linearCV = mul(XYZ_2_DCIP3_MAT, XYZ);\n\n    // Handle out-of-gamut values\n    // Clip values < 0 or > 1 (i.e. projecting outside the display primaries)\n    linearCV = saturate(linearCV);\n\n    // Encode linear code values with transfer function\n    const HALF DISPGAMMA = 2.6;\n    HALF3 outputCV = pow(linearCV, HALF3(1.0 / DISPGAMMA));\n\n    // NOTE: Unity framebuffer encoding is encoded with sRGB opto-electrical transfer function (OETF)\n    // by default which will result in double perceptual encoding, thus for now if one want to use\n    // this ODT, he needs to decode its output with sRGB electro-optical transfer function (EOTF) to\n    // compensate for Unity default behaviour.\n\n    return outputCV;\n}\n", "buffer_a_code": "// https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 approx(vec3 color) {\n    const mat3 x = mat3(+0.59719, +0.07600, +0.02840, +0.35458, +0.90834, +0.13383, +0.04823, +0.01566, +0.83777);\n    const mat3 y = mat3(+1.60475, -0.10208, -0.00327, -0.53108, +1.10813, -0.07276, -0.07367, -0.00605, +1.07602);\n    vec3 v = x*color;    \n    vec3 a = v*(v + 0.0245786) - 0.000090537;\n    vec3 b = v*(0.983729*v + 0.4329510) + 0.238081;\n    return clamp(y*(a/b), 0.0, 1.0);\t\n}\n\nvec3 reference(vec3 color) {\n    vec3 aces = color*sRGB_2_AP0;\n    vec3 oces = RRT(aces);\n    vec3 srgb = ODT_RGBmonitor_100nits_dim(oces);\n    return srgb;\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 uv = xy/iResolution.xy;\n\n    vec3 a = PI*(3.0*uv.x + vec3(0.211,  0.313, 0.419)*iTime);\n    vec3 x = 2.0*(uv.x + uv.x*(1.0-uv.x)*sin(a));\n    vec3 y =\n        xy.y < 1.0 ? x :\n    \txy.y < 2.0 ? reference(x) :\n    \txy.y < 3.0 ? approx(x) :\n    \tvec3(0.0);\n\n    rgba = vec4(y, 1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 223, 223, 1007]], "test": "untested"}
{"id": "WsGyDz", "name": "Animated Hexagon Truchet Chords", "author": "Shane", "description": "An animated asymmetric hexagon-based random stringy woven Truchet jigsaw pattern.", "tags": ["voronoi", "hexagon", "truchet", "string", "jigsaw", "weave", "zentangle", "chord", "asymmetric"], "likes": 49, "viewed": 744, "published": 3, "date": "1602677399", "time_retrieved": "2024-07-30T20:40:27.415826", "image_code": "/*\n\n\tAsymmetric Hexagon Truchet\n    --------------------------\n\n\tI was just thinking the other day that there weren't enough animated \n    asymmetric hexagon-based random stringy woven Truchet jigsaw examples \n    on Shadertoy, so finally we have one... Yeah, I'm not sure where I was\n\theading with this either. :D\n    \n    I haven't seen code for hexagon jigsaw patterns, but it would likely \n    exist. I doubt there'd be any for animated asymmetric ones, but you \n    never know. As for multitiled woven Truchet patterns on this kind of \n    setup, I doubt anyone would get bored enough to code that up, so I \n    imagine this example is unique in that sense. :)\n\n    Anyway, it looks interesting enough, plus it pulls together a few \n    simple concepts that aren't particularly difficult to grasp, like \n    repetition, offsetting grid vertices, layering and Bezier curve \n    rendering. \n\n    I intend to put together a quasi 3D version at some stage, but that'll\n\trequire a little more thought. By the way, the define options are in \n    the \"Common\" tab.\n\n\n    Other examples:\n\n    // Uses a very similar formula, but includes extrusion.\n\tAsymmetric Hexagon Landscape - Shane\n \thttps://www.shadertoy.com/view/tdtyDs\n\n    // It doesn't contain strings in the strictest sense, but it's stringy and \n    // just plain pretty to watch.\n\tSinuous - nimitz\n\thttps://www.shadertoy.com/view/4sGSDw\n\n*/ \n\n\n \n// Global vertices and local coordinates of the triangle cell.\n// It's lazy putting them here, but I'll tidy them up later.\nvec2[6] gV;\nvec2 gP;\n\n// A grid of asymmetrical hexagons grid. Four packed hexagons are constructed\n// in a checkered space filling arrangement, then the matching vertices are\n// randomly offset to give a pseudo Vornoi look, but with the benefit of \n// maintaining access to the vertex information, which can be beneficial for\n// all kinds of things.\nvec4 blocks(vec2 q){\n    \n\n    // Block dimension: Length to height ratio with additional scaling.\n    const vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n     // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    // Pointed top.\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif   \n  \n    \n    float hexID = 0.; // Triangle ID. Not used in this example, but helpful.\n    \n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    gV = vec2[6](vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0));\n    gP = p;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n         \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec2[6] vert = vID;  \n      \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        const float vo = .1;\n        vert[0] += hash22B((idi + vert[0]/2.))*vo;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*vo;\n        vert[2] += hash22B((idi + vert[2]/2.))*vo;  \n        vert[3] += hash22B((idi + vert[3]/2.))*vo; \n        vert[4] += hash22B((idi + vert[4]/2.))*vo;  \n        vert[5] += hash22B((idi + vert[5]/2.))*vo;\n        #endif\n \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim;\n        vert[1] *= dim;\n        vert[2] *= dim;\n        vert[3] *= dim; \n        vert[4] *= dim;\n        vert[5] *= dim;\n        \n        // Scaling the cell ID.\n\t    //idi = idi*s;\n           \n        // The polygon. This is IQ's robust polygon formula, but you could use\n        // a faster, specialized one if speed was the utmost concern, which I\n        // don't believe is the case here.\n        float face = sdPoly(p, vert);\n        //vec2 inC = (vert[0] + vert[1] + vert[2] + vert[3] + vert[4] + vert[5])/6.;\n        //idi += inC.xy;\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and object ID. \n        if(face<d){\n            d = face;\n            id = idi;\n            hexID = float(i);\n            \n            // Setting the vertices and local coordinates.\n            gV = vert;\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, hexID);\n}\n\n \nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout int a, inout int b){ a = a + b; b = a - b; a = a - b; }\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Set the global time, since the \"Common\" tab doesn't recognize\n    // the \"iTime\" variable.\n    setTime(iTime);\n    \n    // Global scale. Rendundant here.\n    const float gSc = 1.;\n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Scaled than transalated coordinates.\n    vec2 p = uv*gSc + vec2(0, .5)*iTime/8.;\n    \n    // The asymmetric hexagon shadow information for the current cell.\n    vec4 d4Sh = blocks(p - vec2(-.01, -.015));\n    vec2 svPSh = gP; // Shadow local coordinates.\n    vec2[6] svVSh = gV; // Shadow offset vertex information.\n    \n    // The asymmetric hexagon information for the current cell.\n    vec4 d4 = blocks(p);\n    vec2 svP = gP; // Local coordinates.\n    vec2[6] svV = gV; // The offset vertex information.\n    \n    // Time varying pixel color\n    vec3 col = vec3(1, .8, .6);\n   \n     \n    // A random number associated with this particular tile. Note that\n    // the scaling factor has been applied. It's not necessary, but looks\n    // better when using textures... which we're not doing. :)\n    vec2 s = GSCALE;\n    float rndH = hash21(d4.yz*s);\n    \n    // Containers for the midpoint edges and corresponding\n    // normals for the string and string shadows.\n    vec4 svEP[6];\n    vec4 svEPSh[6];\n    \n    for(int j = 0; j<6; j++){\n        \n        // Constructing the edge midpoints and normals at those\n        // points for both the string and corresponding shadows.\n        vec2 g, g1, nj;\n        \n        g = svV[j];\n        g1 = svV[(j + 1)%6];\n        nj = normalize(g1 - g).yx*vec2(1, -1);\n        svEP[j] = vec4(mix(g, g1, .5), nj);\n        \n        g = svVSh[j];\n        g1 = svVSh[(j + 1)%6]; \n        nj = normalize(g1 - g).yx*vec2(1, -1);\n        svEPSh[j] = vec4(mix(g, g1, .5), nj);\n        \n    }\n   \n    for(int j = 0; j<6; j++){\n            \n       \n        // Randomly adding or subtracing jigsaw nodules to the hexagon tile sides.\n        // The logic is straight forward, but I tend to forget it after a while,\n        // which is why I always have to refer to my old examples. :)\n\n        // Random number holder -- Used for coloring.\n        float rndC = 0.;\n        // The unique random number of the current tile edge.\n        float rndj = hash21(d4.yz + float(j));\n        // The unique random number of the same tile edge, but from the\n        // neighboring tile. As an aside, I forget this logic every single\n        // time, and if I try to reason it out too much, it confuses me all \n        // over again. :D\n        float rndjNeigh = hash21((d4.yz + eID[j]) + float((j + 3)%6));\n         \n        float nodule = length(svP - svEP[j].xy) - .025 - .0075;\n        /*\n        // Mid edge points via polar coordinates. If you render an \n        // object requiring orientation (like a square nodule), rotation\n        // will play a part.\n        float ang = atan(svEP[j].y, svEP[j].x); \n        vec2 spos = vec2(cos(ang), sin(ang))*length(svEP[j].xy);\n        vec2 newP = rot2(-atan(svEP[j].z, svEP[j].w))*(svP - spos);\n        float nodule = sBoxS(newP, vec2(.026, .026), .007);\n        */\n        \n        // Annoying equality hack. I'll come up with something better than this.\n        if(rndj==rndjNeigh) {\n            // If the two random numbers are equal, add a nodule to the tile\n            // with the largest ID distance. \n            if(length(d4.yz)<length(d4.yz + eID[j])) rndjNeigh += 1e-6;\n        }\n   \n        // If the random number associated with this side is greater that the\n        // random number associated with the same side, but from the neighboring\n        // tile, add a jigsaw nodule to that side. Otherwise, take one away.\n        if(rndj<rndjNeigh){\n            \n            // Add a jigsaw nodule to the hexagonal tile side and give it \n            // the same color as the current tile.\n            rndC = rndH;\n            d4.x = min(d4.x, nodule);\n        }\n        else {\n            \n            // Subtrace a jigsaw nodule from the hexagonal tile side (in effect adding \n            // it to the neighbor) and give it the same color as the neighboring tile.\n            rndC = hash21((d4.yz + eID[j])*s);\n            d4.x = max(d4.x, -(nodule));\n        } \n        \n        // Applying the colored nodule to this particular tile edge.\n        vec3 nCol = .5 + .45*cos(6.2831853*rndC/4. + vec3(0, 1, 2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, nodule + .005));\n        col = mix(col, nCol, 1. - smoothstep(0., sf, nodule + .01));\n          \n    }\n    \n    // Applying the newly constructed hexagon jigsaw tile.\n    //float sh2 = max(.75 - d4.x/.1, 0.);\n    vec3 cCol = .5 + .45*cos(6.2831853*rndH/4. + vec3(0, 1, 2));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d4.x + .005));\n    col = mix(col, cCol, 1. - smoothstep(0., sf, d4.x + .01)); \n    \n    \n \n    // For aesthetic purposes and visual interest, we won't connect all points, \n    // so these numbers represent the total connection points for the string and shadows.\n    int numP = 0;\n    int numPSh = 0;   \n    \n    // Distance field for the edge points and the corresponding shadows.\n    float ePnt = 1e5;\n    float ePntSh = 1e5;\n    \n    for(int j = 0; j<6; j++){\n        \n        // Continuous chord pattern\n        #ifdef CONTINUOUS\n        \n        // The edge point distance field.\n        ePnt = min(ePnt, length(svP - svEP[j].xy));\n        // Saving the end points and corresponding normals\n        svEP[numP++] = svEP[j];\n        // Shadow.\n        ePntSh = min(ePntSh, length(svPSh - svEPSh[j].xy));\n        svEPSh[numPSh++] = svEPSh[j];\n        \n        #else\n        // Broken chord pattern.\n        // Randomly select just a few edges.\n        \n        // Connected edge threshold -- Higher numbers convert to more edges.\n        const float th = .9;  \n        \n        /*\n        if(hash21(d4.yz + eID[j]/2.)<th){\n             //ePnt = min(ePnt, length(svP - svEP[j].xy));\n             svEP[numP++] = svEP[j];\n        }\n        \n        // Do the same for the shadows.\n        if(hash21(d4Sh.yz + eID[j]/2.)<th){\n            //ePntSh = min(ePntSh, length(svPSh - svEPSh[j].xy));\n            svEPSh[numPSh++] = svEPSh[j];\n        }\n        */\n         \n        if(hash21(d4.yz + float(j))<th && hash21(d4.yz + eID[j] + float((j + 3)%6))<th){\n            // The edge point distance field.\n            ePnt = min(ePnt, length(svP - svEP[j].xy));\n            // Saving the end points and corresponding normals\n            svEP[numP++] = svEP[j];\n        }\n        \n        // Do the same for the shadows.\n        if(hash21(d4Sh.yz + float(j))<th && hash21(d4Sh.yz + eID[j] + float((j + 3)%6))<th){\n            ePntSh = min(ePntSh, length(svPSh - svEPSh[j].xy));\n            svEPSh[numPSh++] = svEPSh[j];\n        }\n        #endif\n        \n    }\n \n    \n    #ifdef SHOW_CHORDS\n    \n    // Rendering the edge point shadows first.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., ePntSh - .02))*.7);\n    \n    // Rendering the edge point plug-looking things on the edges of the jigsaw pieces.\n    vec3 svC = col;\n    float jsh2 = max(.3 - (ePnt - .0225)/.021, 0.); // Matches the arcs.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ePnt - .0215));\n    col = mix(col, min(svC*2., 1.)*jsh2*1.5, 1. - smoothstep(0., sf, ePnt - .0215 + .005));\n    \n    float jSh = max(.3 - (ePnt - .012)/.02, 0.); // Matches the arcs.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ePnt - .012));\n    col = mix(col, vec3(1, .95, .9)*jSh*jSh*2., 1. - smoothstep(0., sf, ePnt - .012 + .005));\n\n    // Putting in a quick Z-buffer, so that shadows go underneath the right objects, etc.\n    // Anything added to the buffer won't be overwritten by shadows. It's a cheap hacky\n    // trick, but it works.\n    float zInd = 0.;\n    zInd = mix(zInd, 1., 1. - smoothstep(0., sf, max(ePntSh - .02, -(ePnt - .0215))));\n    #endif\n    \n    \n    // Forcing an even number of chord end points.\n    if((numP&1)==1) numP--;\n    if((numPSh&1)==1) numPSh--;\n    \n    \n    // Indices for shuffling, in order to render the chords in random order.\n    const int N2 = 6;\n    int shuff[N2] = int[N2](0, 1, 2, 3, 4, 5);  // Initializing the shuffle array.\n\n    \n    // Shuffling the variable array of points and normals -- Six is the maximum. I think this \n    // is the Fisher–Yates method, but don't quote me on it. It's been a while since I've used \n    // a shuffling algorithm, so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    //int index = N;\n    for(int i = numP - 1; i>0; i--){\n\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each edge position.\n        float rs = hash21(d4.yz + fi/float(numP));\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*float(index)*1e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(shuff[i], shuff[j]);\n         \n    }\n     \n    #ifdef SHOW_CHORDS\n    \n    // Rendering the chords.\n    for(int j = 0; j<6; j+=2){\n        \n        // Shuffle index for the end points.\n        int jj =  shuff[j];\n        int jj2 = shuff[(j + 1)%6];\n        \n        // Chord end points and corresponding normals to be fed into the Bezier function.\n        vec4 a = svEP[jj]; // End point one.\n        vec4 b = svEP[jj2]; // End point two.\n        vec4 aSh = svEPSh[jj]; // Shadow end point one.\n        vec4 bSh = svEPSh[jj2]; // hadow end point two.\n        \n        // Bezier chord distance fields and the arc width.\n        const float aw = .012; //.015*(n2D3G(p*6.)*.6 + .9);\n        float arc = 1e5, arcSh = 1e5;\n         \n        // Render the shadow chord first.\n        if(j<numPSh){\n           arcSh = doSeg(svPSh, aSh, bSh, length(aSh.xy)/4.) - aw;\n           arcSh = min(arcSh, min(length(svPSh - aSh.xy), length(svPSh - bSh.xy)) - aw );\n        }\n        \n        // Render the chord.\n        if(j<numP){\n            arc = doSeg(svP, a, b, length(a.xy)/4.) - aw;\n            arc = min(arc, min(length(svP - a.xy), length(svP - b.xy)) - aw);\n        }\n        \n      \n        // Rendering the chord shadow first.\n        // I don't like this hack, but it works. There is unintentional shadow\n        // coverage at the cell edges, and the last term stops it from happening.\n        if(zInd<1e-5 || step(0., d4Sh.x + .025)==0.){\n          col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., arcSh))*.7);\n         \n        }\n      \n         \n        // Rendering the chord. \n        float sh = max(.3 - arc/.02, 0.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, arc));\n        col = mix(col, vec3(1, .95, .9)*sh*sh*2., 1. - smoothstep(0., sf, arc + .005));\n        \n        // Updating the Z-buffer with the chord information.\n        zInd = mix(zInd, 1., 1. - smoothstep(0., sf, arc));\n\n   \n    } \n    \n    #endif\n \n \n    // Mixing in a bit of gradient color.\n    col = mix(col, col.xzy, length(uv)*.4);\n    \n    //col = mix(col.zyx, col.yxz, .8); // Other colors.\n                          \n\n    // Rough gamma correction, and we're done.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "\n// Comment this out if you want to see the background jigsaw pattern on its own. \n#define SHOW_CHORDS\n\n// A continuous chord pattern -- No gaps.\n//#define CONTINUOUS\n\n// The example is less interesting with offset vertices, but much easier to construct. :)\n#define OFFSET_VERTICES\n\n// Hexagon arrangement. Flat top or pointed top.\n#define FLAT_TOP\n\n\n// This sets the scale of the extruded shapes.\n#ifdef FLAT_TOP\n#define GSCALE vec2(1./5.)*vec2(.8660254, 1)\n#else \n#define GSCALE vec2(1./5.)*vec2(1, .8660254)\n#endif\n\n#ifdef FLAT_TOP\n// Vertices and edge midpoints: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-2./3., 0), vec2(-2./6., .5), vec2(2./6., .5), \n                      vec2(2./3., 0), vec2(2./6., -.5), vec2(-2./6., -.5)); \nvec2[6] eID = vec2[6](vec2(-.5, .25), vec2(0, .5), vec2(.5, .25), \n                      vec2(.5, -.25), vec2(0, -.5), vec2(-.5, -.25));\n#else\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.), vec2(-.5, 2./6.), vec2(0, 2./3.), \n                      vec2(.5, 2./6.), vec2(.5, -2./6.), vec2(0, -2./3.));\nvec2[6] eID = vec2[6](vec2(-.5, 0), vec2(-.25, .5), vec2(.25, .5), vec2(.5, 0), \n                      vec2(.25, -.5), vec2(-.25, -.5));\n#endif\n////////\n\n// Work around for the time variable.\nfloat gTime = 0.;\nvoid setTime(float tm){ gTime = tm; }\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p){ \n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n    \n    // An annoying, but necessary, hack for systems with less sin\n    // function accuracy. If anyone knows a way around it, feel \n    // free to let me know.\n    //p = floor(p*1048576.)/1048576.;\n    //return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n}\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW \nvec2 hash22B(vec2 p){ \n    \n     \n    // I've struggled with accuracy when offsetting vertices. However,\n    // Dave's function seems to work. If anyone experiences artifacts,\n    // feel free to let me know, and I'll try to work something out.\n    //\n    // 2 in, 2 out.\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    p = fract((p3.xx + p3.yz)*p3.zy)*2. - 1.;\n    \n    return sin(p*6.2831853 + gTime);\n     \n    /*\n    p = (floor(p*1024.) + .5)/1024.;\n    // IQ's vec2 to float hash.\n    p = vec2(dot(p, vec2(27.619, 113.583)), dot(p, vec2(57.527, 85.491)));\n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    //return p;\n    \n    return sin(p*6.2831853 + gTime);\n    */\n} \n\n/*\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) {\n    \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + gTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n*/\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV 6\n//\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n \n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)/3.;//1.732/6.; // ;//\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n//    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[5186, 5186, 5222, 5222, 5253]], "test": "untested"}
{"id": "tsVcDz", "name": "Strange fractal kaleidoscope", "author": "jarble", "description": "This is an edit of [url=https://www.shadertoy.com/view/tsKcWz]another shader[/url] that I found.", "tags": ["fractal"], "likes": 8, "viewed": 428, "published": 3, "date": "1602648585", "time_retrieved": "2024-07-30T20:40:28.281511", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<20;i++)\n        {\n            uv=abs(uv.yx);\n            uv /= 1.1;\n        \tuv -= 1.0;\n        \tuv=uv*rot(t/float(i+2))+col.xy;\n        }\n     col[c] = fract((uv.x)/(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 522]], "test": "untested"}
{"id": "wlffzn", "name": "The Cube Sponge", "author": "kstyler", "description": "cube", "tags": ["cube"], "likes": 3, "viewed": 262, "published": 3, "date": "1602648408", "time_retrieved": "2024-07-30T20:40:29.039485", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor /= fragColor.w;\n    fragColor *= 1.5;\n    fragColor /= fragColor+1.;\n    fragColor = pow(fragColor, vec4(0.9));\n    fragColor = smoothstep(0.,1.,fragColor);\n    fragColor.rgb = mix(vec3(0,.03,.05),vec3(1,1,1),fragColor.rgb);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int MAX_D=200;\nconst float DELTA=0.01;\nint matId = 0;\n\nfloat hash21(vec2 p){\n\treturn(fract(sin(p.x*22.+p.y*421.)*999.));\n}\n\nvec3 randInSphere(vec2 seed){\n\tvec3 p;   \n     p = sin(iTime)*vec3(hash21(seed+fract(iTime)*22.),hash21(seed+fract(iTime)*43.),\n                     hash21(seed+fract(iTime)*97.));\n    return normalize(p);\n}\n\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cros(vec3 p){\n    return min(box(p.xyy,vec3(1,1,9999)),min(box(p.xxz,vec3(1,9999,1)),box(p.yyz,vec3(9999,1,1))));\n}\n\nfloat sponge(vec3 p, float size){\n    float res = box(p,vec3(size));\n    float c = 2.*size;\n    float crSiz =3.; \n    for(int i = 0; i < 4; i++){\n      vec3 q = mod(p+0.5*c,c)-0.5*c;\n      float subt = cros(q*(crSiz/size))/(crSiz/size);  \n      res=max(-subt,res);\n      c/=3.;\n      crSiz*=3.;\n    }\n    return res;\n}\n\nfloat map(vec3 p){\n    float c = 12.9;\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float sp = sponge(q+vec3(0,0,0),3.2);\n    float lightb = box(p-vec3(0,7,0),vec3(9,0.2,9));\n    float lightb2 = box(p-vec3(0,-9.1,0),vec3(10,0.2,10));\n    float best = min(lightb,min(sp,lightb2));\n    if(best==sp){\n    \tmatId = 2;\n    }\n    if(best == lightb){\n    \tmatId=3;\n    }\n    if(best == lightb2){\n    \tmatId=4;\n    }\n    return best;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,DELTA);\n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n}\n\nvec3 skyColor(vec3 rd){ \n    vec3 outLight = vec3(0.125);\n    outLight+= addLight(vec3(0.7,0.5,0.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    outLight+= addLight(vec3(0.1,0.7,0.2),normalize(-vec3(-1.5,-0.5,1.)),rd);\n    outLight+= addLight(vec3(1.0,0.3,0.1),normalize(-vec3(1.5,0.9,-1.)),rd);\n    outLight+=addLight(vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nfloat raymarch(vec3 ro, vec3 rd){\n    float tot = 0.1;\n    for(int i = 0; i < MAX_D;i++){\n        float dst = map(ro+rd*tot);\n        tot+=dst;\n        if(tot>float(MAX_D) || dst < DELTA)break;\n    } \n    return tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0,0.,-16);\n    vec3 rd = normalize(vec3(uv,1));     \n   // ro.xz*=rot(3.14/2.);\n    rd.xz*=rot(2.2); \n    vec3 color = vec3(0); \n    vec3 accum = vec3(0); \n    for(int i = 0; i<5;i++){\n        float tot = (raymarch(ro,rd+hash21(iTime*2.+uv)*0.0006));\n        vec3 p = ro+rd*tot;\n        vec3 n = normal(p);\n        if(tot>float(MAX_D)){\n            matId = 1;\n        }\n        if(matId ==1){\n            color = skyColor(rd);     \n        }\n        if(matId ==2){ \n            ro=p;\n            rd = (randInSphere(uv+iTime)+n)*0.5;\n        }\n        if(matId ==3){\n            color =1.*vec3(1.,0.4,0);\n            \n        } \n        if(matId ==4){   \n            color =2.*vec3(1.1,0.2,0.1);\n        }    \n        accum+=0.7*color;\n    }\n    if(iMouse.z>1.){\n    \tfragColor = vec4(0);\n    }\n    fragColor += vec4((accum),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 358]], "test": "untested"}
{"id": "tsKcWz", "name": "i saw it in a school microscope", "author": "lyurai", "description": "now 10000000 is my favorite number in glsl!", "tags": ["fract"], "likes": 2, "viewed": 394, "published": 3, "date": "1602634968", "time_retrieved": "2024-07-30T20:40:29.790477", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*10.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<5;i++)\n        {\n        \tuv=abs(uv);\n        \tuv-=8.;\n        \tuv=uv*rot(t/float(i+1));\n        }\n        \n     col[c] = fract(uv.x*10000000.);\n        \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 500]], "test": "untested"}
{"id": "wdKcWz", "name": "when I drunk and close my eyes", "author": "lyurai", "description": "Kind of alcohol cyberpunk", "tags": ["sin", "cyberpunk"], "likes": 2, "viewed": 304, "published": 3, "date": "1602633748", "time_retrieved": "2024-07-30T20:40:30.606296", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float v_vert = sin((-iTime+uv.y)*100.)/2.-.5;\n    float v_hor = sin((-iTime+uv.x)*10.)/2.+.6;\n    float col = (v_hor + v_vert)/2.;\n   fragColor = vec4(vec3(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 273]], "test": "untested"}
{"id": "tsVcWR", "name": "Fab15 #inktober2020 \"outpost\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 5, "viewed": 286, "published": 3, "date": "1602621872", "time_retrieved": "2024-07-30T20:40:31.359282", "image_code": "#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )                     // rotation                  \n#define C(a,l)      t = min(t, max( length((a).xz)-.2, abs(a).y -l ) ) // cylinder\n#define W(a,l)      C( mod( a +d, d+d ) -d, l )                        // wall of cylinders\n#define S(a)        a.xz = abs(a.xz), a.z<a.x ? a.xz = a.zx : U        // square symmetries\n#define hash2x3(p)  fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a, g;\n    vec3  R = iResolution, e = vec3(5,-5,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          M = iMouse.xyz/R,\n       // M = iMouse.z > 0. ? iMouse.xyz/R : vec3(4,1,0)/1e2*cos(.3*iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -2.*R.y ) - R ),             // ray direction\n          p = 50./R, q,r,s, d = vec3(.3,1e3,1e3);               // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n    {   q = p, t=9.,\n        q.yz *= rot( .3 +3.*M.y),                               // rotations\n        q.xz *= rot(-.4 -6.*M.x), r = q,                        // --- fort\n        q.z-=10., S(q),                                         // fort symmetries\n        q.xz -= 6.3, \n        s = q, S(s),                                            // turrets symmetries\n        C( abs(abs(s-.45*Y) -.2*X) -.2*Z, 5. ),                 // turrets legs\n        s.xz -= 1.5, W( s-1.2*Y, .8 ),                          // turrets walls\n        q.xz -= 1.5, W( q      , 3. ),                          // main walls\n        a = t;\n        t = min( t, g = r.y+=3.); r /= 4.;                      // --- forest from https://www.shadertoy.com/view/tlSfW3\n        q = .03*sin(15.*r); r += q.x+q.y+q.z;                   // distortion\n        for (int k=0; k<9; k++) {                               // Worley-like dot structure\n            vec2 d = vec2(k%3-1,k/3-1);                                 // seek for closest dot in 9x9 cells around\n            if (r.z+floor(d.y) < -6.)\n                t = min(t, 4.*(length( hash2x3(floor(r.xz)+d)           // random dot(cell)\n                                  - vec3(fract(r.xz)-d,r.y-.3) ) -.5)); // raypos rel to cur cell\n        }\n        p += t*D;                                               // step forward = dist to obj          \n    }\n    O = exp(-5.*O);                                             // --- coloring\n    O *=  t==a ? vec4(1,.8,.6,0)*.7                             // fort\n        : t==g ? vec4(0,1 ,0 ,1) *hash2x3(r.xz).r               // grass\n               : vec4(0,.7,0 ,1) *(.7+.3*r.y)                   // forest\n                 * (.5+1.5*texture(iChannel2,r.xz).r); \n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[508, 508, 544, 544, 2719]], "test": "untested"}
{"id": "tdVcWR", "name": "Continuum Mechanics II*", "author": "wyatt", "description": "..", "tags": ["continuummechanics"], "likes": 11, "viewed": 450, "published": 3, "date": "1602614866", "time_retrieved": "2024-07-30T20:40:32.252893", "image_code": "\nMain {\n\tQ = D(C(U).xy);\n    float \n        n = length(A(U+vec2(0,1))),\n        e = length(A(U+vec2(1,0))),\n        s = length(A(U-vec2(0,1))),\n        w = length(A(U-vec2(1,0)));\n    vec3 norm = \n        normalize(vec3(e-w,n-s,.01)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \tvec3 l = R.xyy;\n    float li = ln(vec3(U,0),vec3(U,0)+ref,l);\n    Q *= .5+0.5*exp(-li)+.5*exp(-3.*li);\n    if (abs(U.y-0.5*R.y)<3.) Q *= 0.;\n    //Q = A(U);\n    \n    //Q = 0.5+0.5*(abs(Q.x*Q.w-Q.z*Q.y)*vec4(1)-1.);\n    \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 Aa (vec2 U) {\n\treturn A(U-B(U).xy);\n}\nvec4 Bb (vec2 U) {\n\treturn B(U-B(U).xy);\n}\nMain {\n\tQ = Aa(U);\n    vec4\n        n = Bb(U+vec2(0,1)),\n        e = Bb(U+vec2(1,0)),\n        s = Bb(U-vec2(0,1)),\n        w = Bb(U-vec2(1,0)),\n        dx = 0.25*(e-w),\n        dy = 0.25*(n-s);\n    mat2 m = mat2(Q);\n    m -= .25*mat2(\n    \tdx.x, dx.y,\n        dy.x, dy.y\n    )*m;\n    \n    Q = vec4(m);\n\tif (iFrame < 1) Q = vec4(1,0,0,1);\n    if(U.x<3.||U.y<3.||R.x-U.x<3.||R.y-U.y<3.) Q.yz *= 0.;\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 Aa (vec2 U) {\n\treturn A(U-A(U).xy);\n}\nvec4 Bb (vec2 U) {\n\treturn B(U-A(U).xy);\n}\nMain {\n\tQ = Aa(U);\n    vec4\n        n = Bb(U+vec2(0,1)),\n        e = Bb(U+vec2(1,0)),\n        s = Bb(U-vec2(0,1)),\n        w = Bb(U-vec2(1,0)),\n        dx = 0.25*(e-w),\n        dy = 0.25*(n-s);\n    \n    Q.x -= (e.x*e.w-e.y*e.z)-(w.x*w.w-w.y*w.z);\n    Q.y -= (n.x*n.w-n.y*n.z)-(s.x*s.w-s.y*s.z);\n    if (U.y>0.5*R.y) {\n    \tQ.x -= (n.x*n.z-n.y*n.w)-(s.x*s.z-s.y*s.w);\n    \tQ.y += (e.x*e.z-e.y*e.w)-(w.x*w.z-w.y*w.w);\n\t}\n    if (iFrame < 1) {\n    \tQ = vec4(0);\n       \tif (length(U-0.5*R)<100.) \n            Q.xy = vec2(.5,0);\n    }\n    vec4 d = D(U);\n        if ((iMouse.z>0.)&&ln(U,d.xy,d.zw)<4.)\n            Q = vec4(clamp(.1*(d.xy-d.zw),-.8,.8),0,0);\n    if (abs(U.y-0.5*R.y)<3.) Q *= 0.;\n     \n    if(U.x<3.||U.y<3.||R.x-U.x<3.||R.y-U.y<3.) Q *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage (out vec4 Q, in vec2 U)\n\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}float ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}", "buffer_c_code": "Main {\n    Q = mod(C(U-B(U).xy),R.xyxy);\n    \n\tif (iFrame < 1) Q = vec4(U,0,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// keep track of mouse\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texture(iChannel0,fragCoord/iResolution.xy);\n    if (iMouse.z>0.) {\n        if (p.z>0.) fragColor =  vec4(iMouse.xy,p.xy);\n    \telse fragColor =  vec4(iMouse.xy,iMouse.xy);\n    }\n    else fragColor = vec4(-iResolution.xy,-iResolution.xy);\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dVyWz", "name": "SDF Morphing", "author": "oneshade", "description": "Wait what?!? You can interpolate SDFs? Now I am starting to see the power in using math!", "tags": ["3d", "raymarching", "sdf", "morphing"], "likes": 4, "viewed": 268, "published": 3, "date": "1602601669", "time_retrieved": "2024-07-30T20:40:33.058738", "image_code": "/*\nThis shader uses an older version of my Raymarcher Template (https://www.shadertoy.com/view/3styDs)\nand I do not plan on implementing the newer features as they are not necessary.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Signed Distance Functions (SDFs):\nfloat udPlane(in vec3 p, in vec3 n) {\n    return abs(dot(n, normalize(p))) * length(p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nfloat Subtraction(in float sdf1, in float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nfloat Intersection(in float sdf1, in float sdf2) {\n    return max(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    p = Rotate(p, vec3(vec2(iTime * 20.0), 0.0));\n    float interpVal = 1.5 + sin(iTime * 0.5) * 1.5;\n    float cube = sdCuboid(p, 200.0, 200.0, 200.0);\n    float cylinder = sdCylinder(p, 200.0, 100.0);\n    float torus = sdTorus(p, 100.0, 50.0);\n    float sphere = sdSphere(p, 100.0);\n    float shape1 = cube;\n    float shape2 = cylinder;\n    if (interpVal >= 1.0 && interpVal < 2.0) {\n        interpVal -= 1.0;\n        shape1 = cylinder;\n        shape2 = torus;\n    }\n\n    if (interpVal >= 2.0 && interpVal <= 3.0) {\n        interpVal -= 2.0;\n        shape1 = torus;\n        shape2 = sphere;\n    }\n\n    return mix(shape1, shape2, interpVal);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return 0.5 + 0.5 * normal;\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 0.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (distanceToClosest < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[775, 812, 849, 849, 901], [903, 903, 966, 966, 1049], [1051, 1051, 1104, 1104, 1160], [1162, 1162, 1214, 1214, 1270], [1272, 1272, 1311, 1311, 1339], [1341, 1389, 1432, 1432, 1462], [1464, 1464, 1513, 1513, 1544], [1546, 1546, 1596, 1596, 1626], [1628, 1648, 1686, 1686, 1706], [1708, 1708, 1743, 1743, 2354], [2356, 2356, 2390, 2390, 2410], [2412, 2439, 2466, 2466, 3111], [3113, 3162, 3195, 3195, 3525], [3527, 3562, 3612, 3612, 3645], [3647, 3647, 3697, 3697, 3731], [3733, 3733, 3784, 3784, 3818], [3820, 3820, 3873, 3873, 3891], [3893, 3914, 3953, 3953, 5431], [5433, 5466, 5521, 5521, 5841]], "test": "untested"}
{"id": "3sKyWz", "name": "Rojas_Shader1", "author": "tonirojas", "description": "mi test shader", "tags": ["cineshader"], "likes": 0, "viewed": 12205, "published": 3, "date": "1602600427", "time_retrieved": "2024-07-30T20:40:33.900488", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    fragColor = vec4(1.0, 1.0, 1.0, noise);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2193], [2195, 2195, 2216, 2216, 2434], [2436, 2436, 2493, 2493, 2855]], "test": "untested"}
{"id": "WsVcWR", "name": "Brokn Voronoi that somehow works", "author": "Pork", "description": "i have no bloody idea how this even works", "tags": ["voronoi"], "likes": 1, "viewed": 370, "published": 3, "date": "1602595603", "time_retrieved": "2024-07-30T20:40:34.662450", "image_code": "const vec4 edgeColor = vec4(1.0, 1.0, 1.0, 1.0);\n\nfloat grayscale(vec4 col)\n{\n\treturn (col.r+col.g+col.b)/3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 c1 = (fragCoord.xy + vec2(-1, 1)) / iResolution.xy;\n    vec2 c2 = (fragCoord.xy + vec2(0, 1)) / iResolution.xy;\n    vec2 c3 = (fragCoord.xy + vec2(1, 1)) / iResolution.xy;\n    vec2 c4 = (fragCoord.xy + vec2(-1, 0)) / iResolution.xy;\n    vec2 c5 = (fragCoord.xy + vec2(0, 0)) / iResolution.xy;\n    vec2 c6 = (fragCoord.xy + vec2(1, 0)) / iResolution.xy;\n    vec2 c7 = (fragCoord.xy + vec2(-1, -1)) / iResolution.xy;\n    vec2 c8 = (fragCoord.xy + vec2(0, -1)) / iResolution.xy;\n    vec2 c9 = (fragCoord.xy + vec2(1, -1)) / iResolution.xy;\n    \n    vec4 s1 = texture(iChannel0, c1)*10.0;\n    vec4 s2 = texture(iChannel0, c2)*10.0;\n    vec4 s3 = texture(iChannel0, c3)*10.0;\n    vec4 s4 = texture(iChannel0, c4)*10.0;\n    vec4 s5 = texture(iChannel0, c5)*10.0;\n    vec4 s6 = texture(iChannel0, c6)*10.0;\n    vec4 s7 = texture(iChannel0, c7)*10.0;\n    vec4 s8 = texture(iChannel0, c8)*10.0;\n    vec4 s9 = texture(iChannel0, c9)*10.0;\n    \n    float v1 = grayscale(s1);\n    float v2 = grayscale(s2);\n    float v3 = grayscale(s3);\n    float v4 = grayscale(s4);\n    float v5 = grayscale(s5);\n    float v6 = grayscale(s6);\n    float v7 = grayscale(s7);\n    float v8 = grayscale(s8);\n    float v9 = grayscale(s9);\n    \n    \n    //sobel filter, see https://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm\n    float sobelVal = abs((v1+2.0*v1+v3)-(v7+2.0*v8+v9))+abs((v3+2.0*v6+v9)-(v1+2.0*v4+v7));\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    fragColor = vec4(sobelVal * edgeColor) + col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat remap(float value, float low1, float high1, float low2, float high2)\n{\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);      \n}\n\nstruct Point\n{\n\tvec2 pos;\n    vec3 color;\n};\n    \nPoint[12] points = Point[12]\n(\n\tPoint(vec2(.1, .1), vec3(204.0, 102.0, 255.0)), \n    //i added another 0 in some because it makes the sobel operator find the edge better. idk. it just works.\n    Point(vec2(.2, .1), vec3(2505,0,102)),\n    Point(vec2(.3, .1), vec3(2505, 102, 102)),\n    Point(vec2(.4, .1), vec3(0, 102, 255)),\n    Point(vec2(.5, .1), vec3(153.0, 255.0, 102.0)),\n    Point(vec2(.6, .1), vec3(255, 204, 0)),\n    Point(vec2(.7, .1), vec3(0, 102, 102)),\n    Point(vec2(.8, .1), vec3(255, 102, 255)),\n    Point(vec2(.9, .1), vec3(0, 153, 51)),\n    Point(vec2(.1, .3), vec3(153, 153, 255)),\n    Point(vec2(.1, .4), vec3(0, 153, 153)),\n    Point(vec2(.1, .7), vec3(2505, 100, 204))\n);\n\n\nfloat[12] distances;\nconst float seed = 7.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    float smallestDist = 1000.0;\n    int currIndex = 0;\n    bool isCenterPoint = false;\n    float totalDist = 0.0;\n    for(int i = 0; i < 12; i++)\n    {\n        float timeSine = sin(iTime*points[i].pos.x*points[i].pos.y*10.0);\n        float remappedTime = remap(timeSine, -1.0, 1.0, 0.1, 0.2);\n        //This is supposed to adjust the X axis to the Y axis but i forgot to add the .x and it works like this\n        //and im too scared to touch it\n        points[i].pos *= 16.0/9.0;\n        vec2 randomPos = vec2(rand(points[i].pos*seed), rand(1.0/points[i].pos*seed));\n        randomPos += remappedTime;\n    \tfloat dist = length(uv - randomPos/*points[i].pos*/);\n        if(dist < smallestDist)\n        {\n            smallestDist = dist;\n            totalDist += dist;\n            distances[i] = dist;\n        \tcurrIndex = i;   \n        }\n        \n        fragColor = vec4(points[currIndex].color/255.0, 1);\n        \n        //IsInsideCenterPoint\n        if(length(randomPos-uv) < .005)\n        {\n            isCenterPoint = true;                       \n        }\n    }\n    \n    if(isCenterPoint)\n    {\n    \tfragColor = vec4(0);   \n    }\n    \n    //fragColor = vec4(points[currIndex].color, 1);\n}", "buffer_a_inputs": [], "buffer_b_code": "//Box blur to thicken outlines\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    vec2 c1 = (fragCoord.xy + vec2(-1, 1)) / iResolution.xy;\n    vec2 c2 = (fragCoord.xy + vec2(0, 1)) / iResolution.xy;\n    vec2 c3 = (fragCoord.xy + vec2(1, 1)) / iResolution.xy;\n    vec2 c4 = (fragCoord.xy + vec2(-1, 0)) / iResolution.xy;\n    vec2 c5 = (fragCoord.xy + vec2(0, 0)) / iResolution.xy;\n    vec2 c6 = (fragCoord.xy + vec2(1, 0)) / iResolution.xy;\n    vec2 c7 = (fragCoord.xy + vec2(-1, -1)) / iResolution.xy;\n    vec2 c8 = (fragCoord.xy + vec2(0, -1)) / iResolution.xy;\n    vec2 c9 = (fragCoord.xy + vec2(1, -1)) / iResolution.xy;\n    \n    vec4 s1 = texture(iChannel0, c1);\n    vec4 s2 = texture(iChannel0, c2);\n    vec4 s3 = texture(iChannel0, c3);\n    vec4 s4 = texture(iChannel0, c4);\n    vec4 s5 = texture(iChannel0, c5);\n    vec4 s6 = texture(iChannel0, c6);\n    vec4 s7 = texture(iChannel0, c7);\n    vec4 s8 = texture(iChannel0, c8);\n    vec4 s9 = texture(iChannel0, c9);\n    \n    fragColor = (s1+s2+s3+s4+s5+s6+s7+s8+s9)/9.0;\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 77, 77, 112], [114, 114, 171, 171, 1711]], "test": "untested"}
{"id": "wsKcRm", "name": "Peaceful Sunset", "author": "Tech_", "description": "Here is one of my first big shaders! Enjoy!", "tags": ["2d", "simple", "sunset", "parallaxscrolling"], "likes": 14, "viewed": 538, "published": 3, "date": "1602594480", "time_retrieved": "2024-07-30T20:40:35.414440", "image_code": "\n/////////////////////////////////////////////////////////////////////////////\n//\n//\t PEACEFUL SUNSET\n//\n//\t by Tech_\n//\n/////////////////////////////////////////////////////////////////////////////\n\nfloat getCloudNoiseWaves(in vec2 uv, float scale, float speed) \n{\n    float waveColor;\n    vec2 uvVar1 = uv * scale / 8.;\n    vec2 uvVar2 = uv * scale / 0.25;\n    \n    float waves1;\n    waves1 += cos(uvVar1.x * 30. + sin(iTime * speed + uvVar1.y * 10. + cos(uvVar1.x * 60.0 + iTime * speed)));\n    waves1 *= waves1;\n    waves1 *= 0.3;\n    \n    float waves2;\n    waves2 += cos(uvVar2.x / 6. * 5.0 + sin(iTime * speed + uvVar2.y + cos(uvVar2.x + iTime * 2. * speed)));\n    waves2 *= waves2 * 0.2;\n    \n    waveColor = waves1 + waves2 * 2.;\n    \n    return waveColor;\n}\n\nfloat getClouds(in vec2 uv, float cloudOpacity, float cloudHeight, float cloudScale, float cloudAmount) \n{\n    cloudAmount -= 1.0;\n    float fog;\n    vec2 st = uv;\n    uv.y *= 4.;\n    uv.x *= 0.4;\n    uv.x += iTime / 1270. / cloudScale;\n    uv.y += sin((uv.x + iTime / 100.) * 30.) * 0.02;\n    fog += getCloudNoiseWaves(uv * cloudScale, 3.4, 0.1);\n    fog -= getCloudNoiseWaves(uv * cloudScale + vec2(2.), 2.4, 0.2);\n    fog = clamp(fog, 0., 1.);\n    float mask;\n    mask = 1. - distance(st.y - (0.35 + cloudHeight), 0.5 + cloudHeight) * 2.;\n    fog *= mask;\n    fog = smoothstep(0.15 - cloudAmount, 0.6 - cloudAmount, fog);\n    return mix(0., clamp(fog, 0., 1.), cloudOpacity);\n}\n\nfloat getWave(in vec2 uv, float waveHeight, float waveSpeed, float waveFrequency, float waveAmplitude, float depth) \n{\n    uv.y -= sin(iTime + depth * 12.) / 60. * waveAmplitude;\n    waveSpeed = iTime / 4. * waveSpeed;\n\tfloat wave = smoothstep(0.0 + waveHeight, 0.003 + waveHeight * (depth + 1.), uv.y + sin((uv.x + waveSpeed) * waveFrequency * 10. + sin(uv.x * 3.)) * 0.03 * waveAmplitude);\n    float result = 1. - wave;\n    return result;\n}\n\nvec4 getOcean(in vec2 uv, float waveHeight, float waveSpeed, float waveFrequency, float waveAmplitude) \n{\n    vec3 waves;\n    waveHeight -= 1.;\n    waveFrequency -= 1.;\n    waves += getWave(uv, 0.325 + waveHeight, 0.025 * waveSpeed, 8. + waveFrequency, 0.06 * waveAmplitude, 0.0) * vec3(0.2);\n    waves += getWave(uv, 0.3 + waveHeight, 0.05 * waveSpeed, 6. + waveFrequency, 0.1 * waveAmplitude, 0.0005) * vec3(0.2);\n    waves += getWave(uv, 0.26 + waveHeight, 0.1 * waveSpeed, 4. + waveFrequency, 0.2 * waveAmplitude, 0.01) * vec3(0.2);\n    waves += getWave(uv, 0.20 + waveHeight, 0.2 * waveSpeed, 2. + waveFrequency, 0.4 * waveAmplitude, 0.05) * vec3(0.2);\n    waves += getWave(uv, 0.11 + waveHeight, 0.35 * waveSpeed, 1.5 + waveFrequency, 0.77 * waveAmplitude, 0.2) * vec3(0.2);\n    waves = pow(waves, vec3(1.)) / 1.6;\n    \n    float oceanOpacity = 1. - getWave(uv, 0.325 + waveHeight, 0.025 * waveSpeed, 8. + waveFrequency, 0.06 * waveAmplitude, 0.0);\n    \n    return vec4(waves, oceanOpacity);\n}\n\nvec3 getSun(in vec2 uv, float oceanOpacity) \n{\n    vec2 st = uv;\n    uv -= .5;\n \tuv.x *= iResolution.x / iResolution.y;\n    \n    uv.y += 0.05;\n    \n    float radius = 0.1;\n    float uvLength = 1. - length(uv);\n    vec3 sun;\n    float sunOpacity = 1.;\n    \n    for(int i = 0; i < 10; i++) \n    {\n        sunOpacity *= 0.6;\n    \tsun += vec3(smoothstep(0.95 - radius, 0.953 - radius, uvLength) * sunOpacity) * vec3(1., 0.6, 0.);\n        sun = clamp(sun, 0., 1.);\n        radius *= 1.3 + sin(iTime) / 100.;\n    }\n\t\n    sun *= oceanOpacity;\n    sun.g *= 0.9;\n    \n    vec3 sunGlow = clamp(1. - vec3(length(uv * 2.)), 0., 1.) * oceanOpacity;\n    sunGlow *= smoothstep(0.1 - sin(iTime) / 10., 1. - sin(iTime) / 10., sunGlow);\n    \n    vec3 flare = 1. - vec3(distance(vec2(st.x * 1.5 - 0.25, st.y * 2. - 0.5), vec2(0.5))) * 2. + sin(iTime) / 40.;\n    flare = clamp(flare * vec3(1., 0.8, 0.), 0., 1.);\n    \n    return sun + (sunGlow + flare) / 4.;\n}\n\nvec3 getSkyGradient(in vec2 uv) \n{\n    float mid = smoothstep(0.2, 0.5, uv.y);\n    \n    vec3 midColLit = vec3(1., 0.341 * 2., 0.09 * 2.2);\n    vec3 midColUnlit = vec3(1., 0.341, 0.09);\n    vec3 midCol = mix(midColUnlit, midColLit, 1. - clamp(distance(uv.x, 0.5) * 1.5, 0., 1.));\n    vec3 upperCol = vec3(0.5, 0.156, 0.225);\n    \n\tvec3 skyColorTop = mix(midCol, upperCol, uv.y);\n    vec3 skyColorBottom = mix(vec3(1., 0.6, 0.1), vec3(1., 0.7, 0.1), 1. - clamp(distance(uv.x, 0.5) * 3., 0., 1.));\n    \n    vec3 skyColor = mix(skyColorBottom, skyColorTop, mid);\n    \n    return skyColor;\n}\n\nfloat luma(vec3 color)\n{\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 changeLuminance(vec3 colorIn, float lumaOut)\n{\n    float lumaIn = luma(colorIn);\n    return colorIn * (lumaOut / lumaIn);\n}\n\nvec3 reinhardExtended(vec3 color, float maxWhiteLuma)\n{\n    float lumaOld = luma(color);\n    float numerator = lumaOld * (1.0 + (lumaOld / (maxWhiteLuma * maxWhiteLuma)));\n    float lumaNew = numerator / (1.0 + lumaOld);\n    return changeLuminance(color, lumaNew);\n}\n\nvec3 tonemapping(in vec3 color)\n{\n    color -= 0.06;\n    color *= 1.62;\n    color = reinhardExtended(color, 2.);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color;\n    \n    vec3 waveColor = vec3(0.19, 0.21, 0.45); \n    vec3 waves = getOcean(uv, 1.05, 1.2, 1.1, 1.0).rgb;\n    waves *= waveColor;\n    \n    vec3 sun = vec3(getSun(uv, getOcean(uv, 1.05, 1.2, 1.1, 1.0).a));\n    \n    vec3 skyColor = getSkyGradient(uv);\n    vec3 sky = pow(1. - getOcean(uv, 1.05, 1.2, 1.1, 1.0).rgb, vec3(1.5)) * skyColor;\n    \n    float clouds = getClouds(uv, 0.5, 0.01, 1., 0.8);\n    clouds += getClouds(uv, 0.4, 0.015, 2., 0.75);\n    clouds += getClouds(uv, 0.3, 0.02, 2.3, 0.75);\n    \n    color = waves + sky + sun + clouds;\n    \n    color = tonemapping(color);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 265, 265, 766], [768, 768, 874, 874, 1448], [1450, 1450, 1568, 1568, 1892], [1894, 1894, 1999, 1999, 2893], [2895, 2895, 2941, 2941, 3835], [3837, 3837, 3871, 3871, 4423], [4425, 4425, 4449, 4449, 4504], [4506, 4506, 4557, 4557, 4634], [4636, 4636, 4691, 4691, 4902], [4904, 4904, 4937, 4937, 5036], [5038, 5038, 5095, 5145, 5847]], "test": "untested"}
{"id": "WstyDl", "name": "Crystal Field", "author": "TDM", "description": "Insertion of transparent & refractive objects to the regular grid. Boxes are raytraced, crystals are raymarched.", "tags": ["reflection", "grid", "refraction", "diamond", "occlusion", "ambient", "dispersion", "gem", "crystal"], "likes": 36, "viewed": 1045, "published": 3, "date": "1602588047", "time_retrieved": "2024-07-30T20:40:36.170418", "image_code": "/*\n * \"Crystal Field\" by Alexander Alekseev aka TDM - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n// comment some of these to get better performance\n#define AA\n#define DISPERSION\n\nconst int NUM_STEPS = 24;\nconst int NUM_REFR_ITER = 30;\nconst float TRESHOLD \t= 1e-4;\nconst float EPSILON \t= 1e-4;\nconst float PI \t\t\t= 3.141592;\nconst float IOR = 0.7;\n\nfloat isCrystalf(vec2 c) {\n    return step(0.8,hash12(c));\n}\nbool isCrystal(vec2 c) {\n    return hash12(c) > 0.8;\n}\nfloat cellHeight(vec2 c) {\n    vec3 rnd = hash32(-c*16.7);\n    float h = rnd.x * 1.8;\n    h += sin((c.x+c.y)*0.2+iTime*1. + rnd.y) * 0.5;\n    h += sin((c.x-c.y)*0.4+iTime*.5 + rnd.z) * 0.5;\n    h += isCrystalf(c);\n    h += pow(dot(c,c) * 0.003,3.0);\n    return h;\n}\n\nfloat crystalSDF(vec3 p, in vec2 cell) {\n    float h = cellHeight(cell);\n    p.y -= h - 100.0;\n    \n    //return rbox(-p,vec2(0.4,100.0).xyx);\n    \n    p.xz = rotateZ(p.xz,sin(iTime)+(h-2.0));\n    vec3 rp = vec3(rotateZ(p.xz,PI*0.25),p.y).xzy;\n    float d = rbox(-rp,vec2(0.45,100.0).xyx);\n\td = max(d, rbox(-p,vec2(0.45,100.0).xyx));\n    d = max(d, octahedron(p,100.0));\n    return d;\n}\n\nvec3 getCrystalNormal(vec3 p, in vec2 cell, float dens) {\n    vec3 n;\n    n.x = crystalSDF(vec3(p.x+EPSILON,p.y,p.z), cell);\n    n.y = crystalSDF(vec3(p.x,p.y+EPSILON,p.z), cell);\n    n.z = crystalSDF(vec3(p.x,p.y,p.z+EPSILON), cell);\n    n = n - crystalSDF(p, cell);   \n    float cr = (tri(p.y*1.4) + tri(p.y*2.7)) * 0.4;\n    n.y += cr * 1e-4;\n    return normalize(n);\n}\n\nfloat getAO(vec3 p, vec3 n, in vec2 c) { \n    vec2 cell_coord = fract(p.xz);\n    \n    float dhc = cellHeight(c);\n    vec4 dh = vec4(cellHeight(c-vec2(1.0,0.0)),\n                   cellHeight(c+vec2(1.0,0.0)),\n                   cellHeight(c-vec2(0.0,1.0)),\n                   cellHeight(c+vec2(0.0,1.0))) - p.y;\n    vec4 side = max(-dh,0.0) / (dhc - min(dh,0.0) - p.y) * 0.75;\n    dh = max(dh, 1e-5);    \n    \n    vec4 aot = min(smix(0.5,1.0,vec4(cell_coord,1.0-cell_coord).xzyw/dh), vec4(1.0));\n    vec4 aos = min(mix(vec4(0.5),vec4(1.0), 1.0-(1.0-side)*max(n.xxzz*vec4(-1.,1.,-1.,1.),0.0)), 1.0);\n    float hao = 1.0 - (dhc - p.y) * 0.4;\n    //aot = 1.0 - (1.0 - aot) * n.y;        \n    \n    float ao = aot.x * aot.y * aot.z * aot.w * \n        \t   aos.x * aos.y * aos.z * aos.w * hao;\n    return ao;//clamp(ao,0.0,1.0);\n}\n\n\n/*\n * grid tracing\n */\n\nvec3 marchCrystal(vec3 ori, vec3 dir, vec2 t_range, vec3 cell_origin, vec2 cell, out vec3 p) {\n    float t = t_range.x;\n    float d = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        d = crystalSDF(p - cell_origin, cell);\n        if(abs(d) <= TRESHOLD || t >= t_range.y) break;\n        t += d - TRESHOLD;\n    } \n    return vec3(d, t, step(t,t_range.y-EPSILON));\n}\n\nfloat advance(in vec3 ori, in vec3 dir, float t) {\n    vec2 dir2 = normalize(dir.xz);\n    float cosa = dot(dir.xz,dir2);\n    \n    // cell id & internal offset\n    vec3 p = ori + dir * t;\n    vec2 offset = fract(p.xz);\n\n    // next t \n    vec2 t0 = offset / -dir2;\n    vec2 t1 = (1.0-offset) / dir2;\n    t0 = max(t0,t1);\n    float nt = min(t0.x,t0.y);\n    return t + nt / cosa;\n}\n\nvec3 trace(vec3 ori, vec3 dir, vec2 uv, int max_iter,  out vec3 p, out vec3 n, out vec2 c) {\n    vec2 dir2 = normalize(dir.xz);\n    float cosa = dot(dir.xz,dir2);\n    \n    float t = 0.0;\n    for(int i = 0; i < 60 && i < max_iter; i++) {\n        \n        // cell id & internal offset\n        p = ori + dir * t;\n    \tc = p.xz;\n        vec2 offset = fract(c);\n        c = floor(c);\n        \n        // next t \n        vec2 t0 = offset / -dir2;\n        vec2 t1 = (1.0-offset) / dir2;\n        t0 = max(t0,t1);\n        float nt = min(t0.x,t0.y);\n        nt = t + nt / cosa;\n        \n        // march the cell\n        vec3 cell_origin = vec3((c+0.5),0.0).xzy;\n        if(isCrystal(c)) {            \n            vec3 st_res = marchCrystal(ori,dir,vec2(t,nt),cell_origin,c,p);\n            if(st_res.z > 0.5) {\n                n = getCrystalNormal(p - cell_origin, c, st_res.x); \n                return st_res;\n            }\n        } else {\n            vec2 nf;\n    \t\tfloat h = cellHeight(c);\n            vec3 ori2 = ori - cell_origin;\n    \t\tori2.y -= h - 100.0;\n            if(intersectionRayBox(ori2,dir,vec2(0.45,100.0).xyx,p,n,nf) > 0.5) {\n        \t\tp = ori + dir * nf.x;\n                return vec3(0.0,nf.x,1.0);\n            }\n        }\n        \n        t = nt + EPSILON;\n    }\n    return vec3(0.0);\n}\n\n/*\n * color\n */\n\nvec3 getCellColor(vec2 cell) {\n    vec3 rnd = hash32(cell);   \n    rnd = vec3(step(0.9,rnd.x), step(0.7,rnd.x), step(0.8,rnd.x));\n    return rnd * 0.5 + 0.5;\n}\n\nvec3 getBlockColor(vec3 p, vec3 n, vec2 cell) {\n\tvec3 localy_p = p - vec3(0.0,cellHeight(cell),0.0);\n    vec2 tuv = mix(mix(localy_p.xz * 1.2,\n                       localy_p.yz * 1.13,\n                       abs(n.x)),\n                   localy_p.yx * 0.92,\n                   abs(n.z));\n\n    vec3 color = texture(iChannel0,tuv).xyy * vec3(1.0,1.3,1.3);\n    color = pow(color,vec3(2.2));// * getCellColor(cell);\n\n    vec3 l0 = normalize(vec3(1.0,0.5,0.4));\n    color += color * max(dot(n,l0),0.0);\n    \n    color *= getAO(p,n,cell);\n    \n    return color;\n}\n\nvec3 addFog(vec3 color, vec3 dir, vec3 traceinfo) {\n    vec3 bg = vec3(1.5) * (dir.y * 0.25 + 0.75) * smoothstep(-1.0,0.0,dir.y);\n    float fog = clamp(log(traceinfo.y*0.08)/log(10.0), 0.0,1.0);\n    fog = 1.0 - (1.0-fog) * traceinfo.z;\n    return mix(color,bg, fog);\n}\n\nvec3 getRefractedColor(vec3 ori, vec3 dir, vec3 n, vec3 p, vec2 c, float eta) {\n    vec3 rdir = refract(dir,n,eta);\n    ori = p + rdir * advance(p,rdir,0.0);   \n\n    vec3 cr_p, cr_n;\n    vec2 cr_cell;\n    vec3 cell_origin = vec3((c+0.5),0.0).xzy;           \n    vec3 st_res = marchCrystal(ori,-rdir,vec2(0.0,1.5),cell_origin,c,cr_p);\n    cr_n = getCrystalNormal(cr_p - cell_origin, c, st_res.x);                               \n    \n    //vec3 refl_dir = reflect(rdir,-cr_n);    \n    rdir = refract(rdir,-cr_n,eta);\n    //float fresnel = pow(1.0 - max(dot(cr_n,rdir),0.0), 5.0);\n    ori = cr_p + rdir * advance(cr_p,rdir,0.0);\n\n    vec3 cr_ti = trace(ori,rdir,vec2(0.0),NUM_REFR_ITER, cr_p,cr_n,cr_cell);\n    vec3 color = getBlockColor(cr_p, cr_n, cr_cell);\n    \n    // internal reflection    \n    /*ori = cr_p + rdir * advance(cr_p,rdir,0.0);\n    cr_ti = trace(ori,refl_dir,vec2(0.0),NUM_REFR_ITER, cr_p,cr_n,cr_cell);\n    vec3 refl_color = getBlockColor(cr_p, cr_n, cr_cell);        \n    color = mix(color,refl_color,fresnel);*/\n    \n    color = addFog(color,rdir,cr_ti);\n\n    return color;\n}\n\nvec3 getPixel(vec2 uv) {\n    // ray\n    vec3 ang = vec3(0.0,0.56 - sin(iTime*0.2)*0.05,iTime * 0.1);\n    mat4 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,-4.0,15.0);\n    vec3 dir = normalize(vec3(uv.xy,-1.7)); dir.z += length(uv) * 0.08;    \n    \n    // DOF\n#ifdef AA    \n    vec2 offset = (hash32(uv*825.7).xy * 2.0 - 1.0) * 0.01;\n    dir.xy += offset;\n    ori.xy -= offset * 5.;    \n#endif\n    \n    dir = normalize(dir);\n    ori = rotate(ori,rot);\n    dir = rotate(dir,rot);\n    dir.xz = rotateZ(dir.xz,sin(iTime*0.17)*0.5);\n    \n    // tracing\n    vec3 p,n;    \n    vec2 cell;\n    vec3 traceinfo = trace(ori,dir,uv,100, p,n,cell);        \n    vec3 color;\n    \n    // crystal\n    if(isCrystal(cell)) {     \n    \t#ifdef DISPERSION\n            color.z = getRefractedColor(ori,dir,n,p,cell,mix(IOR,1.0,0.75)).z;\n            color.yz += getRefractedColor(ori,dir,n,p,cell,mix(IOR,1.0,0.5)).yz;\n            color.xy += getRefractedColor(ori,dir,n,p,cell,mix(IOR,1.0,0.25)).xy;\n            color.x += getRefractedColor(ori,dir,n,p,cell,IOR).x;\n        #else\n        \tcolor = getRefractedColor(ori,dir,n,p,cell,IOR);\n        #endif\n        color *= getCellColor(cell);\n        \n        \n    // regular block\n    } else {\n        color = getBlockColor(p, n, cell);        \n    }    \n    \n    // reflection \n    float fresnel = pow(1.0 - max(dot(n,-dir),0.0), 4.0);\n    vec3 rdir = reflect(dir,n);\n    ori = p + rdir * advance(p,rdir*0.990,0.0); \n    vec3 r_traceinfo = trace(ori,rdir,vec2(0.0),NUM_REFR_ITER, p,n,cell);\n    vec3 refl = getBlockColor(p, n, cell); \n    refl = addFog(refl,rdir,r_traceinfo); \n    color = mix(color,refl, fresnel);        \n        \n    color = addFog(color,dir,traceinfo);\n    return color;\n}\n\n/*\n * main\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 uv = (fragCoord+vec2(i,j)/3.0) / iResolution.xy;\n            uv = uv * 2.0 - 1.0;\n            uv.x *= iResolution.x / iResolution.y; \n    \t\tcolor += getPixel(uv);\n        }\n    }\n    color /= 9.0;\n#else    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n    vec3 color = getPixel(uv);\n#endif\n    \n    color *= vec3(1.4,1.7,1.7);\n    color = pow(color,vec3(1.0/2.2));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * \"Crystal Field\" by Alexander Alekseev aka TDM - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\n\nmat4 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat4 m;\n    m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n\tm[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n\tm[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n\tm[3] = vec4(0.0,0.0,0.0,1.0);\n\treturn m;\n}\nvec2 rotateZ(vec2 v, float a) {\n    vec2 sc = vec2(sin(a),cos(a));\n    vec2 ret = v;\n    ret.x = v.x * sc.y - v.y * sc.x;\n    ret.y = v.x * sc.x + v.y * sc.y;\n    return ret;\n}\nvec3 rotate(vec3 v, mat4 m) {\n    return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n}\nfloat smix(float a, float b, float t) {\n    t = clamp(t,0.0,1.0);\n    return mix(a,b, t*t*(3.0-2.0*t));\n}\nvec4 smix(float a, float b, vec4 t) {\n    t = clamp(t,0.0,1.0);\n    return mix(vec4(a),vec4(b), t*t*(3.0-2.0*t));\n}\nfloat tri(float x) {\n    return 1.0 - abs(fract(x) - 0.5) * 4.0;\n}\n\nfloat intersectionRayBox(vec3 o, vec3 d, vec3 ext, out vec3 r0, out vec3 nrm, out vec2 t) {\n    vec3 t0 = (-o - ext) / d;\n    vec3 t1 = (-o + ext) / d;\n    vec3 n = min(t0,t1); t.x = max(max(n.x,n.y),n.z);\n    vec3 f = max(t0,t1); t.y = min(min(f.x,f.y),f.z);\n    r0 = o + d * t.x;\n    nrm = abs(r0/ext);\n    nrm = step(vec3(max(max(nrm.x,nrm.y),nrm.z)),nrm) * sign(r0);\n    return step(t.x,t.y);\n}\n\n// SDF\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat octahedron(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\treturn m*0.57735027;\n}\n\n// hash\nfloat hash12(in vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash32(in vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstyDl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[431, 431, 457, 457, 491], [492, 492, 516, 516, 546], [547, 547, 573, 573, 812], [814, 814, 854, 854, 1200], [1202, 1202, 1259, 1259, 1573], [1575, 1575, 1615, 1615, 2398], [2425, 2425, 2519, 2519, 2820], [2822, 2822, 2872, 2872, 3200], [3202, 3202, 3294, 3294, 4500], [4519, 4519, 4549, 4549, 4678], [4680, 4680, 4727, 4727, 5238], [5240, 5240, 5291, 5291, 5508], [5510, 5510, 5589, 5589, 6603], [6605, 6605, 6629, 6640, 8328], [8346, 8346, 8403, 8403, 9004]], "test": "untested"}
{"id": "wsGyDz", "name": "Escape Time Fractals", "author": "Miestrode", "description": "Escape time fractals, what are they?\nThink about a transformation iterating through,\neach of the coordinates on the screen, such that the new\ninput for the transformation is the transformed coordinate", "tags": ["2d", "rendering", "smooth", "coloring", "customcomplex"], "likes": 4, "viewed": 907, "published": 3, "date": "1602582799", "time_retrieved": "2024-07-30T20:40:37.112899", "image_code": "// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// Escape time fractals, what are they?\n// Think about a transformation iterating through,\n// each of the coordinates on the screen, such that the new\n// input for the transformation is the transformed coordinate\n// and then check if that coordinate will converge to infinity.\n\n// P.S: Coordinates on the screen are actually Complex Numbers.\n\n// if it does converge, it isn't a part of the Escape Time Fractal.\n// using this and also storing the iterations we can create an image\n// of some fractal, here are some functions for famous ones:\n\n// The Mandelbrot Set:\n// z.n+1 = z.n^2 + c\n\n// The Multibrot Set:\n// z.n + 1 = z.n^k + c\n\n// The Burning Ship:\n// z.n + 1 = conjugate(|z.n|)^2 + c\n\n// The Leaf Fractal (Discovered by me, independently.):\n// z.n + 1 = conjugate(cart(z.n)^2) + polar(c)\n\n// The Mandelzip (Discovered by me, independently.):\n// z.n + 1 = cartesian(cartesian(z^2)) + cartesian(c)\n\n// The Inverse Bulb (Discovered by me, independently.):\n// z.n + 1 = inverse(cartesian(z^2) + polar(c^2))\n\n// The Unitbrot set (Discovered by Mechanist):\n// z.n + 1 = cPower(z, vec2( 2.0, 0.0 )) + cMultiply(c*0.5,vec2(1.0,0.0)-c*0.5) \n\n// The J Invariant - Mandelbrot duality (Discovered by me, and AlephNull):\n// z.n + 1 = z^2 - ln(c/c+1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// Here the main rendering happens, the \"Big Boy\" of the shader.\n\n// How does it work? \"Relatively simple\". at first, let's\n// iterate our function, which we can define using the library\n// of complex functions I constructed, using tools such as\n// algebraic manipulation. Once we do all that is left to do is coloring.\n\n// there are many methods to do this, what i did was use\n// the \"Smooth Iteration\" method, now of course iterations is counted with\n// Integers, so how could we possibly smooth it? well the short answer is\n// this formula:\n// n -= log(log2(length(z))/log(B))/log(2.0).\n\n// How did we get there is hard to explain in one sentence, but Inigo Quilez\n// made a great article about it:\n//https://iquilezles.org/articles/msetsmooth\n\n//=============================================================================================================\n// defineables\n//=============================================================================================================\n\n// anti-aliasing\n#define AA 4\n\n// constants\n#define pi 3.14159\n#define tau 6.28318\n\n//=============================================================================================================\n// complex functions\n//=============================================================================================================\n\nvec2 cMultiply( vec2 z, vec2 w )\n{ \n\treturn vec2 (z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cMultiply( vec2 z, vec2 w, vec2 x )\n{ \n\treturn cMultiply(cMultiply(z, w), x);\n}\n\nvec2 cDivide( vec2 z, vec2 w )\n{\n\treturn vec2 (z.x*w.x + z.y*w.y, -z.x*w.y + z.y*w.x)/(w.x*w.x + w.y*w.y);\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nfloat cDis( vec2 z )\n{ \n    return sqrt(z.x*z.x + z.y*z.y);\n}\n\nfloat cArg( vec2 z )\n{\n\tif (z.x > 0.0)\n    { \n        return atan(z.y / z.x); \n    }\n    \n\tif (z.x < 0.0)\n    {\n        \n\t\tif (z.y < 0.0) \n        { \n            return atan(z.y / z.x) - pi;\n    \t}\n\t\treturn atan(z.y / z.x) + pi;\n\t}\n    \n\tif (z.y > 0.0)\n    { \n        return pi/2.0;\n    }\n    \n\tif (z.y < 0.0)\n    {\n        return pi/2.0;\n    }\n    \n\treturn 0.0;\n}\n\nvec2 cPolar( vec2 z )\n{\n    return vec2(cDis(z), cArg(z));\n}\n\nvec2 cCartesian( vec2 z )\n{ \n    return vec2 (cos(z.t), sin(z.t))*z.s;\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nfloat cReal( vec2 z )\n{ \n    return z.s*cos(z.t);\n}\n\nfloat cImaginary( vec2 z )\n{\n    return z.s*sin(z.t);\n}\n\nvec2 cConjugate( vec2 z )\n{ \n    return vec2 (z.x, -z.y);\n}\n\nvec2 cInverse( vec2 z )\n{\n\treturn vec2 (z.x, -z.y)/(z.x*z.x + z.y*z.y);\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nvec2 cLog( vec2 z )\n{ \n    return vec2 (log(z.x*z.x + z.y*z.y)/2.0, cArg(z));\n}\n\nvec2 cLog( vec2 b, vec2 z )\n{ \n    return cDivide(cLog(z), cLog(b));\n}\n\nvec2 cLogN( float n, vec2 z )\n{\n    return vec2 (log(z.x*z.x + z.y*z.y)/2.0, cArg(z) + n*tau);\n}\n\nvec2 cLogN( float n, vec2 b, vec2 z )\n{ \n    return cDivide(cLogN(n, z), cLog(b));\n}\n\nvec2 cExp( vec2 z )\n{ \n    return vec2 (cos(z.y), sin(z.y))*exp(z.x);\n}\n\nvec2 cExp( vec2 b, vec2 z )\n{ \n    return cExp(cMultiply(z, cLog(b)));\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nvec2 cSquare( vec2 z )\n{ \n    return vec2 (z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n}\n\nvec2 cPower( vec2 z, vec2 w )\n{ \n    return cExp(cMultiply(w, cLog(z)));\n}\n\nvec2 cCube( vec2 z )\n{\n\tfloat p = z.x*z.x;\n\tfloat q = z.y*z.y;\n\treturn vec2 (z.x*(p - 3.0*q), z.y*(3.0*p - q));\n}\n\nvec2 cSqrt( vec2 z )\n{\n\tfloat r = sqrt(z.x*z.x + z.y*z.y);\n\tfloat a = sqrt((r + z.x)/2.0);\n\tfloat b = sqrt((r - z.x)/2.0);\n\tif (z.y < 0.0) { return vec2 (a, -b); }\n\treturn vec2 (a, b);\n}\n\nvec2 cRoot( vec2 w, vec2 z )\n{ \n    return cExp(cDivide(cLog(w), z));\n}\n\nvec2 cRootN( float n, vec2 w, vec2 z )\n{ \n    return cExp(cMultiply(z, cLogN(n, w)));\n}\n\nvec2 cRootNW( float n, vec2 z, vec2 w )\n{ \n    return cExp(cDivide(cLogN(n, w), z));\n}\n\n//=============================================================================================================\n// main functions\n//=============================================================================================================\n\n// edit to your liking:\nvec2 function( in vec2 z, in vec2 c )\n{\n    vec2 zn = cPower( z, vec2( 2.0, 0.0 ) ) - cLog( cDivide( c, c + vec2( 1.0, 0.0 ) ) );\n    \n    return zn;\n}\n//---------------------\n\nfloat render( in vec2 c )\n{\n    const float B = 256.0;\n    float n = 0.0;\n    vec2 z = vec2( 0.0 );\n    \n    for( int i = 0; i < 512; i++ )\n    {\n        z = function( z, c );\n        if( dot( z, z ) > ( B * B ) )\n        {\n            break;\n        }\n        \n        n += 1.0;\n    }\n\n    if( n > 511.0 )\n    {\n       \treturn 0.0;\n    }\n    \n    n = n - log2(log2(dot(z,z))) + 4.0;\n\n    return n;\n}\n\n//=============================================================================================================\n// image\n//=============================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3( 0.0 );\n    \n#if AA > 1\n    for( int m = 0 ; m < AA; m++ )\n    for( int n = 0 ; n < AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + vec2( float( m ), float( n ) ) / float( AA ) ) ) / iResolution.y;\n        float w = float( AA * m + n );\n        float time = iTime + 0.5 * ( 1.0 / 24.0 ) * w / float( AA * AA );\n#else    \n        vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n        float time = iTime;\n#endif\n        \n//=============================================================================================================\n// controls\n//=============================================================================================================\n\n\t\tvec2 center_offset = texture( iChannel0, vec2(0.0) ).yx;\n        \n\t\tfloat zoom_offset = texture( iChannel0, vec2(0.0) ).z + 9.5;\n        \n//=============================================================================================================\n// rendering\n//=============================================================================================================\n        \n        float zoo = 1.0 / (zoom_offset * 0.1);\n        \n        float coa = cos( 0.15 * ( 1.0 - zoo ) );\n        float sia = sin( 0.15 * ( 1.0 - zoo ) );\n        zoo = pow( zoo, 20.0 );\n        vec2 xy = vec2( p.x * coa - p.y * sia, p.x * sia + p.y * coa);\n        vec2 c = vec2( -0.0, -0.0 ) + center_offset + xy * zoo;\n        \n        float v = render(c);\n\n        col += 0.5 + 0.5*cos( 3.0 + v*0.15 + vec3(0.0,0.5,1.0));\n#if AA>1\n    }\n    col /= float( AA * AA );\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// So, keyboard controls... kind of a tough thing to understand, at least for me.\n// I mean ASCII codes? Really? retriving what, coordinates from an image?! seems,\n// very messy if you ask me, of course I am still new though.\n\n// this part basically gives us the values for what to add to the center.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 center = texture(iChannel0, vec2( 0.0, 0.0 )).xy;\n    float zoom = texture(iChannel0, vec2( 0.0, 0.0 )).z;\n    \n    float center_speed = 0.05;\n    float zoom_speed = 0.05;\n    \n\tfloat zoom_offset = float( \n    \ttexture( iChannel1, vec2( 38.0/256.0, 0.0 ) ).x\n    \t- texture( iChannel1, vec2( 40.0/256.0, 0.0 ) ).x);\n    \n    zoom_offset /= length(zoom_offset) + step( length(zoom_offset), 0.5 );\n    zoom += zoom_offset*zoom_speed;\n    \n    vec2 center_offset = vec2( \n\t\ttexture( iChannel1, vec2( 87.0/256.0, 0.0 ) ).x\n    \t- texture( iChannel1, vec2( 83.0/256.0, 0.0 ) ).x, \n    \ttexture( iChannel1, vec2( 68.0/256.0, 0.0 ) ).x\n    \t- texture( iChannel1, vec2( 65.0/256.0, 0.0 ) ).x);\n    \n    center_offset /= length(center_offset) + step( length(center_offset), 0.5 );\n    center += center_offset*center_speed;\n    \n\n    fragColor = vec4(center, zoom, 1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyDz.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[1385, 1385, 1442, 1442, 1546]], "test": "untested"}
{"id": "wdyyWz", "name": "Fab14 #inktober2020 \"armor\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 8, "viewed": 325, "published": 3, "date": "1602579294", "time_retrieved": "2024-07-30T20:40:37.863891", "image_code": "#define L           length\n#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )                       // rotation                  \n#define B(a,w,h,l)  max( max( abs(a).x -w, abs(a).y -h ), abs(a).z -l )  // bar\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a;\n    vec3  R = iResolution, e = vec3(5,-5,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          M = iMouse.z > 0. ? iMouse.xyz/R : vec3(4,2,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),       // ray direction\n          p = 50./R, q,s;                                  // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot( .4 +3.*M.y),                          // rotations\n        q.xz *= rot(-.7 -6.*M.x),\n        s = q += Y, a = 3.14/12.,                          // 12 folds copy-rot\n        s.xz = L(s.xz)* cos(mod( atan(s.z,s.x) +a, a+a) -a +vec2(0,11)), // cylindrical symmetry  \n        t = min(t, max( B( s-X ,.3,7.,1.2 ),               // body plank\n                        2.-L( (q-.7*Y).yz) ) ),            // arm holes\n        t = min(t, max(  B( s-.5*X-2.5*Y, .1,3.,.6 ),      // helmet plank\n                        -B( q -Z-2.7*Y,  1.5,.5,3. )       // eyes hole\n               )      ),\n     // t = min(t, max( L((q-3.*Y).xz)-2.5 , abs(q.y-15.)-.1 )),      // helmet top\n        a = t,\n        t = min(t, max( L(vec2( L(q.x)-3., L((q-.9*Y).yz)-3.7) ) -.2, // handles\n                        4.-q.y )),\n        p += t*D;                                          // step forward = dist to obj          \n\n // if (t==a) O *= vec4(1,.8,.6,0)/.3;                     // coloring\n    if (t==a) O = vec4(1,.8,.6,0) *exp(-5.*O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 247, 247, 1704]], "test": "untested"}
{"id": "WsVyzD", "name": "Tiny Raymarch", "author": "Dragonpeak", "description": "Raymarching in as few chars as possible(300 so far). \nAny tips to optimize more are appreciated.\nEDIT: 434 to 428, removed redundant variable.\nEDIT 2: 428 to 417, same as above\nEDIT 3: 417 to 373, pre-calculated radians & other equations.", "tags": ["raymarch", "small", "short"], "likes": 2, "viewed": 313, "published": 3, "date": "1602576966", "time_retrieved": "2024-07-30T20:40:38.616877", "image_code": "#define b vec3\n#define t normalize\n#define r iResolution\nvoid mainImage( out vec4 q, in vec2 e )\n{\n    b f = t(-b(2.)), c = b(.5);\n    b s = t(b(f.y,-f.x,0.));\n    b d = (mat3(s,cross(s, f),-f) * t(b(e - r.xy / 2., -r.y / .7)));\n    float l = 0., m;\n    while(l < 9.)\n    {\n        m = length(2.+d*l)-1.;\n        if(m < .01) break;\n\t\tl += m;\n    }\n    if(l<9.)c *= dot(2.+d*l,b(.6,.1,.9));\n    q.xyz = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 98, 98, 406]], "test": "untested"}
{"id": "wsGyDR", "name": "variant #inktober2020 \"dunes\"", "author": "FabriceNeyret2", "description": "because I couldn't choose between the options ;-)\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 4, "viewed": 331, "published": 3, "date": "1602572598", "time_retrieved": "2024-07-30T20:40:39.384824", "image_code": "// variant of https://shadertoy.com/view/wsVyzm\n\n#define D(c,z)                                      /* --- dune( yellowness, depth ) */  \\\n   v = 1.-sqrt(.5+.5*sin(10.*U.x-5.*U.y));                    /* dune shape equation */  \\\n   O -= clamp(1. - abs(.6+.15*v-z-U.y-1./R.y)/fwidth(.15*v-U.y), 0., 1.); /* outline */  \\\n   O = mix( O, C= vec4(1,c+ z+U.y-.5,0,1), clamp( R.y/2.*( .6+.15*v-z - U.y)  , 0.,1.) ) \\\n     + .6* C *(1.-v)* max(texture(iChannel0, U/vec2(7,1) -vec2(.03*iTime/(.6-z),0)) +.6-1.5*(U.y+z),0.); \\\n   U *= .6; U.x -= .6;\n\nvoid mainImage(out vec4 O,vec2 u){\n    vec2 R = iResolution.xy, \n         U = 1.7* u / R.y; \n    vec4 C; float v;\n    O = vec4(1,1,.8,1); // yellow sky\n // O = vec4(.8,1,1,1); // cyan sky\n    D(.3,-.52)\n    D(.5, 0.)\n    D(.7,.32)\n    D(.8,.52)\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WsGyWz", "name": "Hills' Spherical Vortex Contours", "author": "t420babe", "description": "Contour plot of Hill's Spherical Vortex (smoke ring). Cross sectional cut is along z-plane as a function of time.", "tags": ["fluiddynamics", "smokering", "vortexring", "hillssphericalvortex"], "likes": 6, "viewed": 449, "published": 3, "date": "1602548821", "time_retrieved": "2024-07-30T20:40:40.136813", "image_code": "/* t420babe - Hill's Spherical Vortex Countours */\n\n// Loop time\nfloat loop_time(float u_time, float limit) {\n  float mod_time = mod(u_time, limit);\n  if (mod_time < limit / 2.0) {\n    return mod_time;\n  } else {\n    return limit - mod_time;\n  }\n}\n\n// Crisp lines\nfloat sharp(float f) {\n  return smoothstep(-0.75, 0.75, (f - 0.1) / fwidth(f));\n}\n\n// Equation for vortex ring\nvec2 vortex_ring(vec2 pos, float u_time, out vec3 color) {\n  float a = 1.0;\n  float u_0 = 10.0;\n  float A = 15.0 / 2.0 * u_0 * 1.0 / pow(a, 2.0);\n\n  float u_int = 1.0 / 5.0 * A * pos.y * (pow(a, 2.0) - pow(pos.x, 2.0) - 2.0 * pow(pos.y, 2.0));\n  float v_int = 1.0 / 5.0 * A * pos.x * pos.y;\n\n  return vec2(u_int, v_int);\n}\n\n// Create contour lines\nvoid vortex_contour(vec2 pos, float u_time, out vec3 color) {\n  pos.x += 0.5;\n  float loop = loop_time(u_time, 30.0);\n    \n  vec2 uv_int = vortex_ring(pos, u_time, color);\n  float z = (uv_int.x + uv_int.y) / 5.0 + 2.0;\n  z *= 4.0 * (loop / 5.0);\n    \n  float d = fract(z);\n    if(mod(z, 2.0) > 1.0) {\n      d = 1.0 - d;\n    }\n\n  // Slightly thinner lines for slightly different vibe\n  // d = d / fwidth(z);\n  \n  d = sharp(d);\n  color = vec3(d);\n    \n  // Invert colors\n  // color = 1.0 - color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(1.0);\n  vortex_contour(pos, iTime, color);\n \n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 65, 109, 109, 247], [249, 264, 286, 286, 345], [347, 375, 433, 433, 697], [699, 723, 784, 784, 1219], [1221, 1221, 1278, 1278, 1446]], "test": "untested"}
{"id": "WdGyWR", "name": "CA Neo-Hookean", "author": "michael0884", "description": "Tracking the deformation gradient to model solid bodies. Pretty hacky rn. \nSLOW - use plugin", "tags": ["particles", "ca"], "likes": 11, "viewed": 502, "published": 3, "date": "1602541659", "time_retrieved": "2024-07-30T20:40:41.330623", "image_code": "//used sources \n//https://github.com/nialltl/incremental_mpm/blob/master/Assets/2.%20MLS_MPM_NeoHookean_Multithreaded/MLS_MPM_NeoHookean_Multithreaded.cs\n//https://www.seas.upenn.edu/~cffjiang/research/mpmcourse/mpmcourse.pdf\n\n// Fork of \"CA Paste\" by michael0884. https://shadertoy.com/view/tsGczh\n// 2020-10-12 21:02:54\n\n// Fork of \"CA Molecular dynamics\" by michael0884. https://shadertoy.com/view/3s3cWr\n// 2020-10-08 22:00:15\n\n// Fork of \"Landau Ginzburg fluid\" by michael0884. https://shadertoy.com/view/WlXBDf\n// 2020-09-21 21:03:05\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.3\n\nfloat deformation_energy(mat2 D)\n{\n    return (D[0][0]*D[0][0] + D[1][1]*D[1][1] - 2.0);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    float c = 0.;\n    float De = 0.;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\t    mat2 D0 = mat2(T1(tpos));\n        \n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        c += M0*K*data.w;\n        De += M0*K*abs(deformation_energy(D0));\n        vel += M0*K*V0;\n    }\n\n   c /= rho;\n   vel /= rho;\n   De /= rho;\n   vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)/(2.*PI), 1.0, rho*length(vel.xy)));\n    \n   col.xyz = 1. - sin(0.7*vec3(1.,2.,3.)*smoothstep(0.,1.0,rho)*c);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define T1(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 0.7\n#define R iResolution.xy\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//Wyatt thermostat\n#define cooling 0.1\n\n// Lamé parameters for stress-strain relationship\nconst float elastic_lambda = 10.0f;\nconst float elastic_mu = 20.0f;\n\n//MD force\nfloat MF(vec2 dx, vec2 dv)\n{\n    return  1.4*(-GS(0.73*dx) + (0.2*dot(dx,dv) + 0.22)*GS(0.5*dx));\n}\n\n\n//the step functions need to be exactly like this!! step(x,0) does not work!\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\n//particle grid\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "//particle advection\n\n\n//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nfloat particleBox(vec2 x, vec2 s)\n{\n    ivec2 p = ivec2(x);\n    return  float(p.x%2 == 0 && p.y%2 == 0)*Ha(x + s)*Hb(s - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    float C = 0.;\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tint M0 = int(data.z);\n        int M0H = M0/2;\n        \n        X0 += V0*dt; //integrate position\n        \n        //the deposited mass into this cell\n        vec3 m = (M0 >= 2)?\n            (float(M0H)*PD(X0+vec2(0.5, 0.0), pos) + float(M0 - M0H)*PD(X0-vec2(0.5, 0.0), pos))\n            :(float(M0)*PD(X0, pos)); \n        \n        //add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \tC += m.z*data.w;\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n        C /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M =particleBox(pos - R*0.3, R*0.1) + particleBox(pos - R*vec2(0.3,0.6), R*0.1) + particleBox(pos - R*0.7, R*0.1) ;\n        C = 0.5 + 0.5*sin(0.4*pos.x);\n    }\n    //initial condition\n    if(iFrame == 800)\n    {\n        C = 0.5 + 0.5*sin(0.4*pos.x);\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//deformation gradient advection\n\n\n//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    //deformation gradient\n   \tmat2 D = mat2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tint M0 = int(data.z);\n        int M0H = M0/2;\n        //deformation grad of particle\n        mat2 D0 = mat2(T1(tpos));\n        \n        X0 += V0*dt; //integrate position\n        \n        //the deposited mass into this cell\n        vec3 m = (M0 >= 2)?\n            (float(M0H)*PD(X0+vec2(0.5, 0.0), pos) + float(M0 - M0H)*PD(X0-vec2(0.5, 0.0), pos))\n            :(float(M0)*PD(X0, pos)); \n        \n        //add deformation grad weighted by mass\n        D += D0*m.z;\n      \t\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n       D /= M;\n    }\n\telse D = mat2(1);\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        D = mat2(1.0);\n    }\n\n    U = vec4(D);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//velocity update\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.49, 0.49)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\n\nmat2 strain(mat2 D)\n{\n    \n    float J = abs(determinant(D)) + 0.01;\n\n    // MPM course, page 46\n    float volume = J;\n\n    // useful matrices for Neo-Hookean model\n    mat2 F_T = transpose(D);\n    mat2 F_inv_T = inverse(F_T);\n    mat2 F_minus_F_inv_T = D - F_inv_T;\n\n    // MPM course equation 48\n    mat2 P_term_0 = elastic_mu * (F_minus_F_inv_T);\n    mat2 P_term_1 = elastic_lambda * log(J) * F_inv_T;\n    mat2 P = P_term_0 + P_term_1;\n\n    // cauchy_stress = (1 / det(F)) * P * F_T\n    \n    // equation 38, MPM course\n    mat2 stress = P * F_T;\n\n    // (M_p)^-1 = 4, see APIC paper and MPM course page 42\n    // this term is used in MLS-MPM paper eq. 16. with quadratic weights, Mp = (1/4) * (delta_x)^2.\n    // in this simulation, delta_x = 1, because i scale the rendering of the domain rather than the domain itself.\n    // we multiply by dt as part of the process of fusing the momentum and force update for MLS-MPM\n    return  0.05 * stress;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 Fa = vec2(0.);\n         vec2 F = vec2(0.);\n        float a = 0.;\n        float tM = 0.;\n        range(i, -3, 3) range(j, -3, 3)\n        {\n            if(!(i == 0 && j == 0))\n            {\n                vec2 tpos = pos + vec2(i,j);\n                vec4 data = T(tpos);\n\n                vec2 X0 = DECODE(data.x) + tpos;\n                vec2 V0 = DECODE(data.y);\n                float M0 = data.z;\n                vec2 dx = X0 - X;\n                vec2 dv = V0 - V;\n                mat2 D0 = mat2(T1(tpos));\n                float weight = GS(0.25*dx);\n\t\t\t\ttM += weight*M0;\n                Fa += M0*MF(dx, dv)*normalize2(dx);\n                F += M*M0*strain(D0)*dx*weight;\n                a += weight;\n            }\n        }\n        \n        F *= 0.1*tM/a;\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F -= 0.0005*dx*GS(dx/80.);\n        }\n        \n       \t//gravity\n        F += 0.001*vec2(0,-1);\n        \n        //integrate velocity\n        V += (F + Fa)*dt/M;\n        \n        //Wyatt thermostat\n        X += cooling*(Fa)*dt/M;\n        \n        vec3 BORD = bN(X);\n        V += 0.5*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//deformation gradient update\n\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    mat2 D = mat2(T1(pos));\n    if(M != 0.) //not vacuum\n    {\n        //Compute the velocity matrix\n        mat2 B = mat2(0.);\n        float a = 0.0;\n        range(i, -3, 3) range(j, -3, 3)\n        {\n            if(!(i == 0 && j == 0))\n            {\n                vec2 tpos = pos + vec2(i,j);\n                vec4 data = T(tpos);\n\n                vec2 X0 = DECODE(data.x) + tpos;\n                vec2 V0 = DECODE(data.y);\n                float M0 = data.z;\n                vec2 dx = X0 - X;\n                vec2 dv = V0 - V;\n                float weight = GS(0.25*dx);\n                \n                B += M0*mat2(dv*dx.x,dv*dx.y)*weight;\n                a += weight;\n            }\n        }\n        \n        B /= a*M;\n        \n      \n        //integrate deformation gradient\n       \tD = (mat2(1) + 1.5*dt * B)*D;\n        \n        //smoothing\n        #define relax 0.004\n        D = D*(1. - relax) + mat2(1.)*relax;\n    }\n    \n    //save\n    U = vec4(D);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[738, 738, 765, 765, 943], [971, 971, 999, 999, 1059], [1099, 1099, 1133, 1133, 1189]], "test": "untested"}
{"id": "ws3yzf", "name": "Julia sets growing", "author": "DerStefan", "description": "for presentation", "tags": ["julia"], "likes": 2, "viewed": 245, "published": 3, "date": "1602541380", "time_retrieved": "2024-07-30T20:40:42.138462", "image_code": "int julia(vec2 uv,  int iter, vec2 c) {\n    vec2 z = uv;\n    for (int i = 0; i < iter; i++) {\n        if (dot(z, z) > 4.0) return i;\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n    }\n    return 0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  int iter = int(120.*iMouse.x/iResolution.x);\n  float zoom = 4.;\n\n\n  //vec2 pos = vec2(-1.62167,0.0);\n  vec2 pos = vec2(0.0,0.0);\n\n    vec2 uv = pos + (fragCoord.xy*2.0 - iResolution.xy) * zoom/ iResolution.x;\n \n  //  float ret = float(mandelbrot(uv,iter));\n  // float ret = float(julia(uv,iter,vec2(-0.16,0.67)+vec2(0.07*sin(iTime*0.1),0.07*cos(iTime*0.09))));\n     float ret = float(julia(uv,iter,vec2(-1.0,0.0)));\n  fragColor = vec4(sin(vec3(0.1, 0.2, 0.5) * ret), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3yzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 216], [219, 219, 276, 276, 751]], "test": "untested"}
{"id": "wsccRf", "name": "Julia Sets in Mandel", "author": "DerStefan", "description": "for presentation", "tags": ["fractal"], "likes": 3, "viewed": 362, "published": 3, "date": "1602541373", "time_retrieved": "2024-07-30T20:40:42.891449", "image_code": "// https://www.mi.sanu.ac.rs/vismath/javier/b3.htm (COLORING ALGORITHMS)\n\nconst vec3 colorf = vec3(.3, .3, .7);\nconst vec3 colorf2 = vec3(.0, .0, .0);\n\nvec3 hsv2rgb( float c )\n{\n    vec3 rgb = clamp( abs(mod(c*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n  return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y; \n    vec2 mouse = iMouse.xy/iResolution.y;\n    mouse = (mouse == vec2(0.0) ? vec2(0.0) : (iMouse.xy - iResolution.xy*0.5)/iResolution.y);  //for initialization\n    \n    vec2 zoompoint = vec2(0.0);\n    float zoom = .4;\n    //zoom = 1.*(sin(iTime/1.) + 1.5);\n    uv /= zoom;\n    mouse /= zoom;\n    uv += zoompoint;\n    mouse += zoompoint;\n    \n//julia set \n    vec2 juliac = mouse;    \n    vec2 z = uv;\n    vec2 c = juliac;\n    vec2 dz = vec2(0.0);\n    float rz = 0.0;\n    float rdz = 0.0;\n    int nri = 0;\n    \n    for (int i = 0; i < 500; i++)\n    {\n        if(rz > 128.0)\n            break;\n    \n        // Z' -> 2*Z*Z' + 1\n    dz = 2.0 * vec2(z.x * dz.x - z.y * dz.y, z.x * dz.y + z.y * dz.x) + vec2(1.0, 0.0);\n        // Z -> Z^2 + c      \n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;  \n        nri = i;\n        rz = dot(z, z);\n    }\n    \n    //https://iquilezles.org/articles/distancefractals\n    rdz = dot(dz, dz);\n    float d = 0.5*sqrt(rz / rdz) * log(rz);\n    d = clamp(pow(6.0 * d / zoom, 0.2), 0.0, 1.0);\n    \n    //Change coloring method here\n    vec3 color;\n    if (rz < 4.0)\n        color = vec3(0.0);\n    else {\n        float nic = float(nri) + 1. - log2(log2(rz));          //normalized iteration count: https://iquilezles.org/articles/msetsmooth\n        //color = hsv2rgb((nic * .015));                //multicolored\n        color = .5 + .5 * cos(3.0 + nic * .2 + vec3(0.0,0.6,1.0));    //like on wiki?\n        //color = mix(colorf, colorf2, fract(float(nri) * .02));    //(discrete) escape time coloring: Base the color on the number of iterations\n        //color = vec3(d);\n    }\n\n//mandelbrot set \n    vec3 color2;\n    if(iMouse.z > 0.0) {\n//see if juliac is in mandelbrot set\n        z = vec2(0.0);\n        rz = 0.0;\n        c = juliac;\n\n        for (int i = 0; i < 100; i++)\n        {\n            if(rz > 4.0)\n                break;\n\n            // Z -> Z^2 + c      \n            z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n            rz = dot(z, z);\n        }\n        vec3 incolor;\n        if (rz < 4.0)\n            incolor = vec3(0.3, 1.0, 0.3);\n        else\n            incolor = vec3(1.0, 0.3, 0.3);\n        \n        \n        z = vec2(0.0);\n        rz = 0.0;\n        c = uv;\n\n        for (int i = 0; i < 100; i++)\n        {\n            if(rz > 64.0)\n                break;\n\n            // Z -> Z^2 + c      \n            z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n            rz = dot(z, z);\n        }\n\n        \n        if (rz < 4.0)\n            color2 = incolor;\n        else\n            color2 = vec3(0.0);\n\n      //  color = mix(color, color2, 0.2);\n        color = mix(color, vec3(0.0), 0.2);\n    }\n    \n    //red dot which is the julia parameter c\n    color = mix(color, vec3(1.0,0.0,0.0), smoothstep(5.0 / zoom / iResolution.y, 0.0, length(uv-juliac)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsccRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 177, 177, 275], [277, 277, 334, 334, 3263]], "test": "untested"}
{"id": "wsVyzm", "name": "Fab13 #inktober2020 \"dunes\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\n- with outline: del /* line #3\n- yellow sky: swap comment  lines 11-12", "tags": ["short", "golf", "3tweets", "inktober2020"], "likes": 10, "viewed": 383, "published": 3, "date": "1602533008", "time_retrieved": "2024-07-30T20:40:43.653411", "image_code": "#define D(c,z)                                      /* --- dune( yellowness, depth ) */  \\\n   v = 1.-sqrt(.5+.5*sin(10.*U.x-5.*U));                      /* dune shape equation */  \\\n/* O -= clamp(1. - abs(.6+.15*v-z-U.y-1./R.y)/fwidth(.15*v-U.y), 0., 1.); /* outline */  \\\n   O = mix( O, C= vec4(1,c+ z+U.y-.5,0,1), clamp( R/2.*( .6+.15*v-z - U )  , 0.,1.).y )  \\\n     + .6* C *(1.-v).y* max(texture(iChannel0, U/vec2(7,1) -vec2(.03*iTime/(.6-z),0)) +.6-1.5*(U.y+z),0.); \\\n   U.x--, U *= .6;                                //\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = 1.7* u / R.y, v;\n    vec4 C,O = /* vec4(1,1,.8,1); /* yellow sky */\n                  vec4(.8,1,1,1); /* cyan sky   */\n    D(.3,-.52) D(.5, 0.) D(.7,.32) D(.8,.52) o = O;}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wsVczw", "name": "Metaballs but it's in 2d", "author": "Pork", "description": "aaa", "tags": ["metaballs"], "likes": 4, "viewed": 503, "published": 3, "date": "1602519481", "time_retrieved": "2024-07-30T20:40:44.536051", "image_code": "const vec4 edgeColor = vec4(1.0, 1.0, 1.0, 1.0);\n\nfloat grayscale(vec4 col)\n{\n\treturn (col.r+col.g+col.b)/3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 c1 = (fragCoord.xy + vec2(-1, 1)) / iResolution.xy;\n    vec2 c2 = (fragCoord.xy + vec2(0, 1)) / iResolution.xy;\n    vec2 c3 = (fragCoord.xy + vec2(1, 1)) / iResolution.xy;\n    vec2 c4 = (fragCoord.xy + vec2(-1, 0)) / iResolution.xy;\n    vec2 c5 = (fragCoord.xy + vec2(0, 0)) / iResolution.xy;\n    vec2 c6 = (fragCoord.xy + vec2(1, 0)) / iResolution.xy;\n    vec2 c7 = (fragCoord.xy + vec2(-1, -1)) / iResolution.xy;\n    vec2 c8 = (fragCoord.xy + vec2(0, -1)) / iResolution.xy;\n    vec2 c9 = (fragCoord.xy + vec2(1, -1)) / iResolution.xy;\n    \n    vec4 s1 = texture(iChannel0, c1);\n    vec4 s2 = texture(iChannel0, c2);\n    vec4 s3 = texture(iChannel0, c3);\n    vec4 s4 = texture(iChannel0, c4);\n    vec4 s5 = texture(iChannel0, c5);\n    vec4 s6 = texture(iChannel0, c6);\n    vec4 s7 = texture(iChannel0, c7);\n    vec4 s8 = texture(iChannel0, c8);\n    vec4 s9 = texture(iChannel0, c9);\n    \n    float v1 = grayscale(s1);\n    float v2 = grayscale(s2);\n    float v3 = grayscale(s3);\n    float v4 = grayscale(s4);\n    float v5 = grayscale(s5);\n    float v6 = grayscale(s6);\n    float v7 = grayscale(s7);\n    float v8 = grayscale(s8);\n    float v9 = grayscale(s9);\n    \n    \n    //sobel filter, see https://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm\n    float sobelVal = abs((v1+2.0*v1+v3)-(v7+2.0*v8+v9))+abs((v3+2.0*v6+v9)-(v1+2.0*v4+v7));\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    fragColor = vec4(sobelVal * edgeColor) + col;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float aR = 16.0/9.0;\n \n\nfloat remap(float value, float low1, float high1, float low2, float high2)\n{\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);      \n}\n// polynomial smooth min (k = 0.1); (IQuilez)\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nstruct Circle\n{\n\tvec2 pos;\n    float radius;\n};\n    \nCircle circle1 = Circle(vec2(.3, .3), .2);\nCircle circle2 = Circle(vec2(1, .5), .2);\nCircle circle3 = Circle(vec2(1, .5), .2);\n\n//settings\nconst float timeStep = 1.0;\nconst float smoothFactor = 0.2;\n\n\nfloat distToCenter(vec2 point, Circle circle)\n{\n    return sqrt(pow(point.x - circle.pos.x, 2.0) + pow(point.y - circle.pos.y, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    //Circle Movement\n\tfloat timeSine = (sin(iTime/timeStep)+1.0)/2.0;\n    float timeCos = (cos(iTime/.7)+1.0)/2.0;\n  \tfloat timeTan = (tan(iTime/timeStep)+1.0)/2.0;\n\n    circle1.pos.x = mix(0.0 + circle1.radius, aR - circle1.radius, timeSine);\n    circle1.pos.y = mix(0.0 + circle1.radius, 1.0 - circle1.radius, timeSine);\n    circle2.pos.x = aR-mix(0.0 + circle2.radius, aR - circle2.radius, timeSine);\n    \n    circle3.pos.y = mix(0.0 + circle3.radius, 1.0 - circle3.radius, timeCos);\n    circle3.pos.x = mix(0.0 + circle3.radius, aR - circle3.radius, 1.0-timeCos);\n\n    //For coloring based on distance to closest center\n    float centerDist = distToCenter(uv, circle1);\n    float centerDist2 = distToCenter(uv, circle2);  \n    float centerDist3 = distToCenter(uv, circle3);\n    float closestCenterDist = min(min(centerDist, centerDist2), centerDist3);\n    float circleDist = centerDist - circle1.radius;    \n\n    circleDist = smin(circleDist, centerDist2 - circle2.radius, smoothFactor);\n    circleDist = smin(circleDist, centerDist3 - circle3.radius, smoothFactor);\n    if(circleDist <= .01)\n    {        \n        //centreDist ranges from 0 (center) to radius (circumpherence)\n        //normalize in 0...1 range by dividing by radius\n        closestCenterDist /= .2;\n        centerDist /=.2;\n        centerDist2 /=.2;\n        centerDist3 /=.2;\n        \n        //Weighted distribution of color, the closest you are to a sphere the more its color \n        //bleeds onto the current pixel.\n        //    distanceToCircle\n        //    ----------------\n        //  distanceToAllCircles\n        //Thought i had to do 1 - this but apparently it works like this so eh ill take it\n        \n        float c1Infl = centerDist / (centerDist + centerDist2 + centerDist3);\n        float c2Infl = centerDist2 / (centerDist + centerDist2 + centerDist3);\n        float c3Infl = centerDist3 / (centerDist + centerDist2 + centerDist3);\n\n        vec3 col1 = vec3(146, 0, 255) * c1Infl;\n        vec3 col2 = vec3(255, 146, 0) * c2Infl;\n        vec3 col3 = vec3(0, 255, 146) * c3Infl;\n        \n        fragColor = vec4(/*closestCenterDist * */(col1+col2 + col3)/255.0, 1.0);\n    }\n    else\n    {\n    \tfragColor = vec4(0);   \n    }\n}\n", "buffer_a_inputs": [], "buffer_b_code": "//Box blur to thicken outlines\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    vec2 c1 = (fragCoord.xy + vec2(-1, 1)) / iResolution.xy;\n    vec2 c2 = (fragCoord.xy + vec2(0, 1)) / iResolution.xy;\n    vec2 c3 = (fragCoord.xy + vec2(1, 1)) / iResolution.xy;\n    vec2 c4 = (fragCoord.xy + vec2(-1, 0)) / iResolution.xy;\n    vec2 c5 = (fragCoord.xy + vec2(0, 0)) / iResolution.xy;\n    vec2 c6 = (fragCoord.xy + vec2(1, 0)) / iResolution.xy;\n    vec2 c7 = (fragCoord.xy + vec2(-1, -1)) / iResolution.xy;\n    vec2 c8 = (fragCoord.xy + vec2(0, -1)) / iResolution.xy;\n    vec2 c9 = (fragCoord.xy + vec2(1, -1)) / iResolution.xy;\n    \n    vec4 s1 = texture(iChannel0, c1);\n    vec4 s2 = texture(iChannel0, c2);\n    vec4 s3 = texture(iChannel0, c3);\n    vec4 s4 = texture(iChannel0, c4);\n    vec4 s5 = texture(iChannel0, c5);\n    vec4 s6 = texture(iChannel0, c6);\n    vec4 s7 = texture(iChannel0, c7);\n    vec4 s8 = texture(iChannel0, c8);\n    vec4 s9 = texture(iChannel0, c9);\n    \n    fragColor = (s1+s2+s3+s4+s5+s6+s7+s8+s9)/9.0;\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 77, 77, 112], [114, 114, 171, 171, 1666]], "test": "untested"}
{"id": "tsKyzw", "name": "Underground Trains", "author": "dr2", "description": "Beneath the city streets...", "tags": ["architecture", "train", "london", "station"], "likes": 18, "viewed": 444, "published": 3, "date": "1602515049", "time_retrieved": "2024-07-30T20:40:45.581257", "image_code": "// \"Underground Trains\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Beneath the city streets... (viewpoint varies, mouseable, mouse in lower-left \n// corner for mono image)\n\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 cSize, dSize;\nvec3 ltDir, qHit, statSz;\nfloat tCur, dstFar, trnSpc, cxId, gGap, trnPos, trnUp, trnDir, tunSpc, stpWd, wThk, whlRad;\nint idObj;\nbool opDoor, colImg;\nconst int idCar = 1, idWin = 2, idWhl = 3, idTrk = 4, idTun = 5, idPlat = 6, idBase = 7,\n   idWal = 8, idCeil = 9, idStp = 10, idHrail = 11, idSup = 12, idLamp = 13;\nconst float pi = 3.1415927, sqrt2 = 1.41421;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db, dr, dx, dy, dd, stSize;\n  dMin = dstFar;\n  p.x -= gGap * (cxId + 0.5) + trnDir * (0.5 * gGap - tunSpc);\n  q = p;\n  q.xy -= vec2 (- trnDir * 4., - trnUp - whlRad + 0.1);\n  stSize = 0.3;\n  q.z *= trnDir;\n  q.z -= stSize * floor (4. / stSize);\n  dx = abs (q.x) - stpWd;\n  dr = length (vec2 (dx, mod (q.z, stSize) - 0.5 * stSize)) - 0.03;\n  dr = max (dr, abs (q.z - 2.4) - 2.4);\n  q.yz = Rot2Cs (q.yz, vec2 (1. / sqrt2));\n  d = max (length (vec2 (dx, q.y - 0.78)) - 0.03, abs (q.z - 4.12) - 3.4);\n  DMIN (idHrail);\n  d = max (dr, abs (q.y - 0.53) - 0.26);\n  d = min (d, PrSphDf (vec3 (dx, q.y - 0.78, q.z - 7.55), 0.05));\n  DMIN (idHrail);\n  d = abs (p.y - trnUp) - 2.7;\n  q.z = (abs (mod (q.z * sqrt2, 2. * stSize) - stSize) + stSize) / sqrt2;\n  d = 0.8 * max (max (max (q.y - q.z, 0.1 - q.y), dx - 0.05), d);\n  DMIN (idStp);\n  p.z = mod (p.z - trnDir * trnPos + 0.5 * trnSpc, trnSpc) - 0.5 * trnSpc; \n  q = p;\n  db = abs (max (PrRoundBoxDf (q, vec3 (0., cSize.yz), cSize.x), - trnUp - q.y));\n  d = db - cSize.w;\n  dy = 0.5 - abs (q.y - cSize.y);\n  d = max (d, min (min (0.4 - abs (mod (q.z, 1.) - 0.5), cSize.z - abs (q.z)), dy));\n  d = max (d, - max (max (PrRoundBox2Df (q.xy, vec2 (0., cSize.x - 0.2), cSize.x - 0.3), - dy),\n     0.05 - abs (q.x)));\n  dd = max (PrRoundBox2Df (vec2 (trnDir * q.x + cSize.x, q.z), dSize.xy, dSize.z),\n     - dSize.w - q.y);\n  if (opDoor) d = max (d, - dd);\n  DMINQ (idCar);\n  d = db - 0.5 * cSize.w;\n  if (opDoor) d = max (d, - dd);\n  DMINQ (idWin);\n  d = PrCylDf (vec3 (q.x, q.y + trnUp - (2. * cSize.y - 0.1), abs (q.z) - 4. * dSize.z).xzy, 0.05,\n     2. * cSize.y - 0.1);\n  DMIN (idHrail);\n  q.xz = abs (q.xz) - vec2 (0.65, 0.75) * cSize.xz;\n  q.z = abs (q.z) - 0.6;\n  q.y -= - trnUp;\n  d = max (PrCylDf (q.yzx, whlRad, 0.08), q.y);\n  DMINQ (idWhl);\n  return dMin;\n}\n\nvoid SetTrnConf ()\n{\n  float t;\n  t = mod (8. * tCur / trnSpc + 0.5 * step (1.5, cxId), 1.);\n  trnPos = trnSpc * smoothstep (0.08, 0.92, t);\n  trnDir = 1. - 2. * mod (cxId, 2.);\n  opDoor = (0.5 - abs (t - 0.5) < 0.05);\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float s;\n  float dHit, d, cxIdP, eps;\n  eps = 0.0001;\n  dHit = eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  cxIdP = -99.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cxId = floor (p.x / gGap);\n    if (cxId != cxIdP) {\n      cxIdP = cxId;\n      SetTrnConf ();\n    }\n    s = ((cxId + step (0., rd.x)) * gGap - p.x) / rd.x;\n    d = (cxId >= 0. && cxId <= 3.) ? GObjDf (p) : dstFar;\n    d = min (d, abs (s) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dt, dx, dz;\n  dMin = dstFar;\n  p.x -= 2. * gGap;\n  q = p;\n  dx = abs (q.x) - statSz.x;\n  dz = abs (q.z) - 9.5;\n  q.x = abs (abs (q.x) - gGap) - tunSpc;\n  dt = max (PrRoundBox2Df (q.xy, vec2 (0., cSize.y), cSize.x + 0.4), - cSize.y - 1.2 - q.y);\n  d = max (abs (dt) - 0.1, statSz.z - 0.5 - abs (q.z));\n  DMIN (idTun);\n  q.y -= - trnUp - whlRad - 0.1;\n  d = PrRoundBox2Df (vec2 (abs (q.x) - 0.65 * cSize.x, q.y), vec2 (0.06, 0.1) - 0.03, 0.03);\n  DMIN (idTrk);\n  q = p;\n  d = max (max (abs (PrBox2Df (q.xz, statSz.xz + wThk)) - wThk, - dt),\n     - PrRoundBoxDf (vec3 (dx - 0.5 * wThk, q.y - 5.16, dz), vec3 (wThk, 1.56, 0.8), 0.05));\n  DMIN (idWal);\n  q.y -= statSz.y + 2.6;\n  d = max (abs (length (vec2 (mod (q.x + 0.25 * gGap, 0.5 * gGap) - 0.25 * gGap, q.y)) -\n     0.4 * gGap) - 0.1, - q.y);\n  DMIN (idCeil);\n  q = p;\n  q.y -= - trnUp - whlRad + 0.1;\n  d = max (PrBox2Df (q.yz, vec2 (0.4, 1.7 * cSize.z)), 2.8 - abs (abs (q.x) - gGap));\n  DMIN (idPlat);\n  d = abs (q.y + 0.35 + wThk) - wThk;\n  DMIN (idBase);\n  q = p;\n  q.y -= 3.58;\n  q.z = dz;\n  d = PrBoxDf (q, vec3 (statSz.x, 0.1, 0.85));\n  DMIN (idStp);\n  q = p;\n  q.y -= 4.1;\n  d = PrCylDf (vec3 (q.y - 0.4, abs (dz) - 0.82, q.x), 0.03, statSz.x);\n  d = min (d, max (PrCylDf (vec3 (mod (q.x + 0.15, 0.3) - 0.15, q.y + 0.01, abs (dz) - 0.82).xzy,\n     0.03, 0.41), dx));\n  q.x = abs (q.x + 5.7 * sign (q.z)) - gGap;\n  q.z = dz + 0.8;\n  d = max (d, - PrBox2Df (q.xz, vec2 (stpWd, 0.5)));\n  DMIN (idHrail);\n  q = p;\n  d = max (PrCylDf (vec3 (mod (q.x + 0.5 * gGap, gGap) - 0.5 * gGap, q.y - 0.8,\n     abs (dz) - 0.3).xzy, 0.07, 2.7), dx);\n  DMIN (idSup);\n  d = PrCapsDf (vec3 (dx, q.y - statSz.y - 2.5, mod (q.z + 2., 4.) - 2.), 0.25, 0.5);\n  DMIN (idLamp);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02 * g, 0.03 * g, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.2 * smoothstep (0.35, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sq.x * sq.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn, vec2 g)\n{\n  vec3 rg;\n  rg = ShStagGrid ((abs (vn.x) > 0.99) ? p.zy : ((abs (vn.y) > 0.99) ? p.zx : p.xy), g);\n  if (abs (vn.x) > 0.99) {\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4;\n  vec3 col, vn, ltDirL, stg;\n  vec2 vf, u;\n  float dstObj, dstObjG, nDotL, dSum, sSum, s, dx;\n  bool isMet;\n  gGap = 8.;\n  trnSpc = 210.;\n  cSize = vec4 (1., 0.7, 6., 0.06);\n  dSize = vec4 (0.1, 0.8, 0.2, 1.3 * cSize.y);\n  tunSpc = 1.7 * cSize.x;\n  whlRad = 0.5;\n  trnUp = 0.98;\n  statSz = vec3 (18., 7., 3. * cSize.z);\n  stpWd = 0.9;\n  wThk = 0.5;\n  dstObjG = GObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstObjG)  < dstFar) {\n    if (dstObjG < dstObj) {\n      dstObj = dstObjG;\n      ro += dstObj * rd;\n      vn = GObjNf (ro);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n    }\n    dx = abs (ro.x - 2. * gGap);\n    vf = vec2 (0.);\n    stg = vec3 (0.);\n    if (idObj == idCar) {\n      col4 = vec4 (1., 0.3, 0.3, 0.1) * (0.4 + 0.6 * smoothstep (0.005, 0.01,\n         min (abs (max (PrRoundBox2Df (vec2 (abs (qHit.x) - cSize.x, qHit.z), dSize.xy, dSize.z),\n         - dSize.w - qHit.y)), max (abs (qHit.z), abs (qHit.y - 0.42 * cSize.y) - 1.72 * cSize.y))));\n      s = max (PrRoundBoxDf (qHit, vec3 (0., cSize.yz), cSize.x), - trnUp - qHit.y);\n      col4 *= 1. - 0.7 * step (abs (s), 0.6 * cSize.w);\n      if (s < 0.) {\n        col4 *= 0.5 + 0.3 * smoothstep (0.05, 0.07, abs (mod (4. * qHit.x / cSize.x, 1.) - 0.5));\n      } else {\n        u = vec2 (abs (qHit.z) - 0.6 * cSize.z, qHit.y + 0.5 * cSize.y);\n        col4 = mix (col4, vec4 (0.7, 0.1, 0.1, 0.1), step (abs (length (u) - 0.2), 0.04));\n        u = abs (u) - vec2 (0.3, 0.05);\n        col4 = mix (col4, vec4 (0.1, 0.1, 0.7, 0.1), step (max (u.x, u.y), 0.));\n        if (abs (qHit.z) < cSize.z + 0.5) col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.02,\n           length (vec2 (qHit.x, mod (qHit.z + 0.5, 1.) - 0.5)) - 0.2 * cSize.x);\n        else if (length (qHit.xy - vec2 (0., - 0.5 * cSize.y)) < 0.3 * cSize.y) col4 =\n           (trnDir * sign (qHit.z) > 0.) ? vec4 (1., 1., 0.3, -1.) : vec4 (1., 0., 0., -1.);\n      }\n    } else if (idObj == idWin) {\n      col4 = vec4 (0.1, 0.1, 0.2, 0.1);\n    } else if (idObj == idWhl) {\n      col4 = vec4 (0.4, 0.4, 0.45, 0.2);\n    } else if (idObj == idTrk) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.2) * ( 1. - 0.9 * smoothstep (0., 5.,\n         max (abs (ro.z) - statSz.z, 0.)));\n      cxId = floor (ro.x / gGap);\n      SetTrnConf ();\n      u = vec2 (ro.x - gGap * (cxId + 0.5) - trnDir * (0.5 * gGap - tunSpc),\n         mod (ro.z - trnDir * trnPos + 0.5 * trnSpc, trnSpc) - 0.5 * trnSpc); \n      col4 *= 0.7 + 0.3 * smoothstep (0., 0.3, PrRoundBox2Df (u, cSize.xz, cSize.x));\n    } else if (idObj == idTun) {\n      col4 = vec4 (0.4, 0.3, 0., 0.) * (0.8 + 0.2 * step (0.2, mod (8. * ro.y, 1.)));\n      col4 *= 1. - 0.9 * smoothstep (0., 5., abs (ro.z) - statSz.z);\n    } else if (idObj == idPlat) {\n      col4 = vec4 (0.5, 0.4, 0.2, 0.1);\n      if (ro.y > -1.) {\n        if (abs (dx - gGap) > 2.98) {\n          u = abs (vec2 (abs (ro.x - 2. * gGap + 5.7 * sign (ro.z)) - gGap,\n             abs (ro.z) - 6.5)) - vec2 (stpWd, 2.5);\n          col4 *= 0.85 + 0.15 * smoothstep (-0.1, 0.3, max (u.x, u.y));\n          stg = ro;\n        } else {\n          col4 = mix (vec4 (0.8, 0.1, 0.1, 0.1), vec4 (0.1, 0.2, 0.1, 0.1), step (0.,\n             sign (sin (4. * pi * ro.z))));\n        }\n      } else col4 *= 0.9 + 0.1 * cos (16. * pi * ro.z);\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idStp) {\n      col4 = vec4 (0.4, 0.45, 0.4, 0.);\n      vf = vec2 (64., 1.);\n    } else if (idObj == idHrail) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.2) * (0.85 + 0.15 * sin (16. * pi * ro.y));\n    } else if (idObj == idBase) {\n      col4 = vec4 (0.2, 0.2, 0.2, 0.) * (0.5 + 0.5 * Fbm2 (32. * ro.xz));\n      if (abs (abs (dx - gGap) - 1.7) < 0.65 * cSize.x)\n         col4 *= (0.5 + 0.5 * step (0.8, mod (2. * ro.z, 1.)));\n      vf = vec2 (32., 2.);\n    } else if (idObj == idWal) {\n      if (dx < statSz.x + 0.1 * wThk) {\n        col4 = vec4 (0.45, 0.5, 0.6, 0.1);\n        stg = ro + vec3 (0., 0.23, 0.);\n        u = vec2 (mod (ro.z + 4., 8.) - 4., ro.y - 1.);\n        col4 = mix (col4, vec4 (0.7, 0.1, 0.1, 0.1), step (abs (length (u) - 0.6), 0.12));\n        u = abs (u) - vec2 (0.9, 0.15);\n        col4 = mix (col4, vec4 (0.1, 0.1, 0.7, 0.1), step (max (u.x, u.y), 0.));\n        s = PrRoundBox2Df (vec2 (ro.y - statSz.y - 2.5,\n           mod (ro.z + 2., 4.) - 2.), vec2 (0., 0.5), 0.25);\n        col4.rgb += vec3 (0.9, 0.9, 0.8) / (3. + 50. * s * s);\n      } else col4 = vec4 (0.1, 0.15, 0.2, 0.);\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idCeil) {\n      col4 = vec4 (0.65, 0.75, 0.7, 0.1);\n      col4.rgb *= 0.85 + 0.15 * smoothstep (0.08, 0.1, abs (Truch (2. * ro.xz) - 0.5));\n      col4 = mix (vec4 (1., 1., 0.9, -1.), col4, \n         smoothstep (0.06, 0.08, abs (mod (ro.x + 0.25 * gGap, 0.5 * gGap) - 0.25 * gGap)));\n    } else if (idObj == idLamp) {\n      col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (32. * pi * ro.y)), -1.);\n    }\n    if (stg != vec3 (0.)) {\n      rg4 = ShStagGrid3d (stg, vn, vec2 (4./3., 2.));\n      vn = rg4.xyz;\n      col4.rgb *= 0.9 + 0.1 * rg4.w;\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      isMet = (idObj == idCar || idObj == idTrk || idObj == idWhl);\n      dSum = 0.;\n      sSum = 0.;\n      for (int k = VAR_ZERO; k < 5; k ++) {\n        if (k < 4) {\n          ltDirL = normalize (vec3 (vec2 (min (statSz.x, statSz.z) - 1.), statSz.y + 2.).xzy);\n          ltDirL.xz = Rot2D (ltDirL.xz, 0.5 * pi * float (k));\n        } else ltDirL = ltDir;\n        nDotL = max (dot (vn, ltDirL), 0.);\n        if (isMet) nDotL *= nDotL;\n        dSum += ((k < 4) ? 1. : 0.5) * nDotL;\n        sSum += ((k < 4) ? 1. : 0.5) * pow (max (dot (normalize (ltDirL - rd), vn), 0.), 32.);\n      }\n      col = col4.rgb * (0.1 + 0.4 * dSum) + 0.5 * col4.a * sSum;\n    } else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n    if (idObj == idWin) col += vec3 (0., 0., 0.03);\n  } else {\n    col = vec3 (0.1);\n  }\n  if (! colImg) col = vec3 (0.9, 0.7, 0.5) * Maxv3 (col);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, vuId, regId, sr, t;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  colImg = true;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  if (mPtr.z > 0. && Minv2 (- mPtr.xy + 0.03 * vec2 (1. / asp, 1.) - 0.5) > 0.) colImg = ! colImg;\n  mMid[0] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (-1., 1.);\n  mMid[1] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., 1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1.;\n  if (mPtr.z > 0. && colImg) {\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  vuId = 0.;\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  if (regId > 0. && (vuId == 0. || vuId == regId)) vuId = regId - vuId;\n  t = mod (0.05 * tCur, 6.);\n  vuMode = int (mod (vuId + floor (t / 2.), 3.)) + 1;\n  t = mod (t, 2.);\n  t = SmoothBump (0.25, 0.75, 0.22, mod (t, 1.)) * sign (t - 1.);\n  if (vuMode == 1) {\n    az = -0.5 * pi;\n    el = -0.05 * pi;\n  } else if (vuMode == 2) {\n    az = 0.55 * pi;\n    el = -0.15 * pi;\n  } else if (vuMode == 3) {\n    az = 0.75 * pi;\n    el = -0.15 * pi;\n  }\n  if ((mPtr.z <= 0. || ! colImg)  && vuId == 0.) {\n    if (vuMode == 1) az += 0.25 * pi * t;\n    else if (vuMode == 2 || vuMode == 3) el += 0.15 * pi * t;\n  }\n  if (mPtr.z > 0. && (vuId == 0. || vuId == regId)) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  if (vuMode == 1) {\n    ro = vuMat * vec3 (0., 0., -4.);\n    ro.xy += vec2 (17., 1. /*3.*/);\n    ro.y = max (ro.y, 0.);\n    zmFac = 2.7;\n  } else if (vuMode == 2) {\n    ro = vec3 (4., 8., 5.);\n    zmFac = 3.;\n  } else if (vuMode == 3) {\n    ro = vec3 (4., 6., 15.);\n    zmFac = 3.;\n  }\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a +\n       0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 2.1)\n       col = colImg ? vec3 (0.3, 0.7, 0.3) : vec3 (0.9, 0.7, 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyzw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1402, 1402, 1425, 1425, 3258], [3260, 3260, 3280, 3280, 3480], [3482, 3482, 3516, 3516, 4068], [4070, 4070, 4092, 4092, 4348], [4350, 4350, 4372, 4372, 6128], [6130, 6130, 6163, 6163, 6347], [6349, 6349, 6370, 6370, 6625], [6627, 6627, 6661, 6661, 7013], [7015, 7015, 7060, 7060, 7626], [7628, 7628, 7650, 7650, 7798], [7800, 7800, 7835, 7835, 13909], [13911, 13911, 13967, 13967, 16959], [16961, 16961, 16993, 16993, 17093], [17095, 17095, 17128, 17128, 17217], [17219, 17219, 17265, 17265, 17312], [17314, 17314, 17361, 17361, 17408], [17410, 17410, 17443, 17443, 17470], [17472, 17472, 17514, 17514, 17565], [17567, 17567, 17610, 17610, 17674], [17676, 17676, 17698, 17698, 17725], [17727, 17727, 17749, 17749, 17776], [17778, 17778, 17800, 17800, 17838], [17840, 17840, 17897, 17897, 17980], [17982, 17982, 18018, 18018, 18224], [18226, 18226, 18256, 18256, 18369], [18371, 18371, 18402, 18402, 18466], [18500, 18500, 18524, 18524, 18584], [18586, 18586, 18610, 18610, 18722], [18724, 18724, 18749, 18749, 18935], [18937, 18937, 18958, 18958, 19113], [19115, 19115, 19144, 19144, 19356], [19358, 19358, 19397, 19397, 19577]], "test": "untested"}
{"id": "tdKyzw", "name": "Equilibrio", "author": "lennyjpg", "description": "Carmen Herrera\nEquilibrio\n2017\n\n\nhttps://www.moma.org/collection/works/284741?sov_referrer=artist&artist_id=30075&page=1", "tags": ["simple", "triangle", "abstract", "geometry", "pattern"], "likes": 1, "viewed": 308, "published": 3, "date": "1602513881", "time_retrieved": "2024-07-30T20:40:46.412035", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f/iResolution.xy;\n    vec2 u = vec2(abs(uv.x - .5) * 2., fract(uv.y * 3. + iTime * 0.37));\n    O = vec4( vec3(mix(.9, .1, step(u.x, u.y))),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 201]], "test": "untested"}
{"id": "wsVcRw", "name": "uniform/gaussian disk sampling ", "author": "FabriceNeyret2", "description": "left: uniform disk sampling\nright: gaussian disk sampling", "tags": ["sampling", "gaussian", "tuto", "uniform", "short", "rng"], "likes": 4, "viewed": 383, "published": 3, "date": "1602512884", "time_retrieved": "2024-07-30T20:40:47.248799", "image_code": "int N = 40;        // N×N samples\n#define hash2(p)   fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) // https://www.shadertoy.com/view/llySRh\n#define hue(v)    ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )                     // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.*u - R, V;\n \n    float l = 1e5, d;\n    int i=0, k, T = int(iTime)%3;\n    for( ; i<N*N; i++ ) {\n        vec2 H = hash2(vec2(i%N,i/N)+iTime), P; \n        float r = H.x, a = 6.283*H.y;                   // use as polar coord\n        r = U.x < 0. ? sqrt(r)                          // left:  uniform\n                     : sqrt(-2.*log(r)) /3.;            // right: gaussian ( sigma = 1/3 to fit the screen )\n\n        P = r * cos(a+ vec2(0,11) );                    // disk sample\n        P = U - R.y*P;\n     // l = min(l, dot(P,P));                           // closest sample\n        d = dot(P,P); \n        if (d<l) l=d, V=P, k=i;\n    }\n    O = T == 1 ? vec4 ( 1.5 - .5*sqrt(l) )              // draw sample closest to pixel\n      : T == 2 ? hue(float(k)/float(N*N))               // draw voronoï with sample id = col\n   // : T == 2 ? vec4(float(k)/float(N*N))              // draw voronoï with sample id = grey\n      :          texture(iChannel0, .5+.5* V*10./R.y ); // splat Britney on sample\n\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 330, 330, 1372]], "test": "untested"}
{"id": "wsVyRw", "name": "disk raster parameterization", "author": "FabriceNeyret2", "description": "disk raster parameterization\nred = pos in raster row segment in disk, green = raster line. \n\nleft: shown in sampling space sqrt(pi)L × L/sqrt(pi)  ( more readable since fit diameter)\nright: shown in screen space.\n", "tags": ["rasterization", "short", "parameterization"], "likes": 3, "viewed": 347, "published": 3, "date": "1602510720", "time_retrieved": "2024-07-30T20:40:48.080574", "image_code": "#define index(V)   ( V.x + L * V.y )                 // coords to index\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, H = vec2(0),\n         S = vec2(16); // exp2(floor(log2(R.yy)));     // Sx × Sy cells\n    O-=O;\n    float   L = ceil(S.x*sqrt(3.14));                  // the L² disk-cells live in a pi.L² surface grid \n    U = floor(U*L/R.y);                                // remap screen to cells grid\n    if ( U.x < L && U.y < L ) {\n        \n        float X = 0., _X, j,y,p;                       // cur segment index in disk rasterization \n        for ( j=0.; j <= L; j++) {                     // rasters line in grid\n            y = j / L * 2. - 1.,                       // line y in normalized coordinates\n            p = index(U);                              // grid index in raster normalized coordinates\n            _X=X, // X =  L*L/4.*( y *sqrt(max(0.,1.-y*y)) + asin(clamp(y,-1.,1.))+1.57);   // cumulated row index\n                X += L*sqrt(max(0.,1.-y*y));\n            if (X > p )                                // we found cell segment: [_X, X ]\n            { H = vec2( (p -_X)/L, .5+.5*y ); break; } // red = pos in segment, green = line number\n        }\n    }\n    else {                                             // --- right: in disk space\n        U.x -= L;\n        float y = U.y / L * 2. - 1.,                   // line y in normalized coordinates\n              X = L*sqrt(max(0.,1.-y*y));\n        if ( abs(U.x -L/2.) < X/2. )\n            H = vec2( ( U.x-L/2.+X/2. ) / L, .5+.5*y) ;// red = pos in segment, green = line number\n    } \n    \n    O = vec4(H,0,1);                                   // draw cells\n    O.g *= .6;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 111, 111, 1676]], "test": "untested"}
{"id": "WsKyzw", "name": "Fractalized Voronoi", "author": "milesWaugh", "description": "Shader desc", "tags": ["fractal", "voronoi"], "likes": 7, "viewed": 331, "published": 3, "date": "1602486631", "time_retrieved": "2024-07-30T20:40:48.843534", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texture(iChannel0,fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 120]], "test": "untested"}
{"id": "WdVcRw", "name": "lovely matrices: gLSL tricks", "author": "FabriceNeyret2", "description": "matrix initialization in GLSL offers many goodies.", "tags": ["glsl", "matrix", "tuto"], "likes": 6, "viewed": 969, "published": 3, "date": "1602483408", "time_retrieved": "2024-07-30T20:40:49.593529", "image_code": "// display value v at cell (X,Y)\n#define dV(v,X,Y)    D( J!=ivec2(0) ? O : (v) , X,Y )\n\n// display matrix M : n × n  from cell (X,Y)\n#define dM(M,n,X,Y)  D( min(J.x,J.y) < 0 || max(J.x,J.y) >= n ? O : (M)[J.x][J.y], X,Y )\n\n#define D(v,X,Y)     J = I - ivec2(X,Y);                             \\\n                     P = ivec2( ( U-vec2(X,Y) ) * p ) % int(p);      \\\n                     O = v  *vec4(1,1.2,1.4,1)/4. * vec4(P.x*P.y>0)\n                                                    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R.y; U.y = 1.-U.y;\n    \n    float N = 8.,\n          p = R.y/N;                          // cell size in pixels\n    ivec2 I = ivec2(U*=N), J, P;              // cell id\n\n    O = vec4(.5,0,0,0);\n    \n    vec2 a = vec2(1,2), b = vec2(3,4);        // --- top, from left to right:\n    mat2 m2 = mat2(a,b);  dM( m2,2, 0,0);     // define mat from column vectors\n    \n    m2[0] = m2[1]; dM( m2,2, 4,0);            // use m2[0], m2[1] columns as vectors\n    m2[0]-=2.;\n\n    dM( mat2(1),2,7,0);                       // define mat from diagonal\n    \n                                              // --- middle, from left to right:\n    mat3 m3 = mat3(m2); dM( m3,3, 0,3);       // define mat3 from mat2 \n\n    m2 = mat2(transpose(m3)); dM( m2,2, 4,3); // define mat2 from mat3\n    \n    dM( mat2(normalize(vec4(m2))),2,  8,3);   // normalize matrix by L2 norm\n // dM( mat2(m2/length(vec4(m2))),2,  8,3);   // variant\n    dM( mat2(-m2/determinant(m2)),2, 11,3);   // normalize matrix by determinant\n\n                                              // --- bottom, from left to right:\n    mat3x2 m = mat3x2(1.+m3);\n    dV(  dot( m[0]/m[0], m[0]/m[0] ), 1,7 );                 // find matrix height\n    #define T transpose\n    dV( dot( T(m)[0]/T(m)[0], T(m)[0]/T(m)[0] ), 3,7 ) ;     // find matrix width\n\n    dM( mat2(cos(iTime+ vec4(0,11,33,0)))   *2.+2.,2,  8,6); // rotation matrix.     cf https://www.shadertoy.com/view/llySRh\n    dM( mat2(cos(iTime+ vec4(0,23,21,0))*.5+.5)*4.,2, 11,6); // HLS <1,j,j²> matrix. same ref\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 487, 525, 525, 2074]], "test": "untested"}
{"id": "WsKyRw", "name": "weird pepsi", "author": "shortwavedave", "description": "pepsi", "tags": ["pepsi"], "likes": 0, "viewed": 276, "published": 3, "date": "1602472252", "time_retrieved": "2024-07-30T20:40:50.344521", "image_code": "mat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvec2 f(vec2 st, vec2 c) {\n    vec2 stt = st;\n    int i = 0;\n    while (i<125 && dot(stt,stt)<(10.)) {\n    \tstt.x = 2.*st.x*st.y + iTime*.1;\n        stt.y = st.y*st.y - st.x*st.x;\n        stt = r2d(iTime*.1+stt.x*.1)*stt;\n        st = stt;\n        c+=8.*normalize(stt)*tan(stt)*cos(stt);\n        i++;\n    }\n    return vec2(1.0)-c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 8.-0.02*iTime;\n\tuv -= vec2(7.0-0.014*iTime,3.9-0.005*iTime);\n\n    // Output to screen\n    vec2 c = f(uv,vec2(1.));\n    fragColor = vec4(vec3(0.,c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 104], [106, 106, 131, 131, 437], [439, 439, 496, 546, 792]], "test": "untested"}
{"id": "WdGczm", "name": "Stereo Equirectangular", "author": "xjorma", "description": "How to convert a VR shadertoy to an stereo equirectangular.\n\nVideo export (Better viewed in VR)\nhttps://youtu.be/CzHM3zD-Taw\n\nOriginal shader https://www.shadertoy.com/view/tsfGzl", "tags": ["stereo", "youtube", "equirectangular"], "likes": 10, "viewed": 711, "published": 3, "date": "1602465962", "time_retrieved": "2024-07-30T20:40:51.192255", "image_code": "// Created by David Gallardo - xjorma/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define PI radians(180.)\n#define TAU radians(360.)\n#define HELICOIDLENGTH 1.5\n#define NBTUBES 3.\n#define MAXDIST 15.\n\n\nvec2 minVecSelect(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat sdcircle2d(vec2 p, float r)\n{\n     return length(p)-r;\n}\n\nvec2 rotate(vec2 center, float angle, float radius)\n{\n    return center + vec2(cos(angle),-sin(angle)) * radius;\n}\n\nvec2 slice(vec3 v)\n{\n    float\ttime = (v.z/TAU)*2.+iTime*0.1;\n\n    float\tr1 = 0.04*sin(v.z*4.+iTime*7.) + 0.08;\n    \n    float   r2 = 0.15 + sin(v.z + iTime)*0.05;\n\n    vec2\tm = vec2(sdcircle2d(rotate(v.xy,time*TAU,r2),r1));\n    \n    for(float i = 1. ; i < NBTUBES ; i++)\n    {\n        m = minVecSelect(m,vec2(sdcircle2d(rotate(v.xy,(time+i/NBTUBES)*TAU,r2),r1),i));\n    }\n    return m;\n}\n\n\nvec2 curve(float z)\n{\n    return vec2(cos(z*.2)*cos(z*0.5),cos(z*.3)*cos(z*0.7));\n}\n\nvec3 map(vec3 p)    \n{\n    p.z += iTime;\n    \n    p.xy += curve(p.z);\n    \n    float angle = atan(p.y,p.x);\n    \n    p.z+= (angle/TAU)*HELICOIDLENGTH;\n\n    p.z = mod(p.z+HELICOIDLENGTH/2.,HELICOIDLENGTH)-HELICOIDLENGTH/2.;\n    \n    vec3 v = vec3(length(p.xy)-1., p.z, angle);\n\n    return vec3(slice(v),angle*4.+iTime*7.);\n}\n\n\n// From IQ\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    vec2\teps\t= vec2(0.01,0);\n\tfloat\td\t= map(pos).x;\n\treturn\tnormalize(vec3(map(pos+eps.xyy).x-d,map(pos+eps.yxy).x-d,map(pos+eps.yyx).x-d));\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd, out float t, float maxDist)\n{\n    vec3\td;\n    t = 0.5;\n    for(int i=0;i<75;++i)\n    {\n        d = map(ro+rd*t);\n        t+=d.x*.7;\n        if (d.x < .001 || t > maxDist) break;\n    }\n    return d;\n}\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 render(vec3 ro,vec3 rd)\n{\n    float\tt;\n    \n    vec3\tr = rayMarch(ro,rd,t,MAXDIST);\n   \n    vec3\tcol;\n\n    if (t < MAXDIST)\n    {\n    \tvec3 p = ro+rd*t;\n        vec3 n = CalcNormal(p);\n\t\tcol = mix(vec3(1.,0.75,.5),vec3(1.,0.55,.3),0.5*sin(r.z*5.)+0.5);\n\t\tcol = mix(col,vec3(1),0.2*sin(r.y*TAU/NBTUBES)+0.2)*mix(n.y,1.,0.6);\n\t\tvec3 reflected=reflect(rd,n);\n        vec3 env = texture(iChannel0,reflected).xyz;\n\t\tcol = mix(col,env,length(env)*0.3);\n\t\tcol*= calcAO(p,n);\n\t\tcol = applyFog(col,t,vec3(0));\n    }\n    else\n    {\n        col = vec3(0);\n    }\n    \n    return col;\n}\n\nmat3 buildLookAtMatrix( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{   \n    mat3 ma = buildLookAtMatrix(vec3(0), vec3(0,0.25,-1));\n    \n    fragColor = vec4(render(ma*ro/4.-vec3(curve(iTime),0),ma*rd) ,1);\n}\n\n\n#define EQUIRECTANGULAR\n\n#define STEREO\n\n\n#ifndef EQUIRECTANGULAR\n#define AA\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    \n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA        \n        // camera\t\n        vec3 ro = vec3(-curve(iTime),0);\n        vec3 ta = vec3(-curve(iTime + 2.),5);\n        // camera-to-world transformation\n        mat3 ma = buildLookAtMatrix( ro, ta );\n        \n        vec3 rd =  ma*normalize(vec3(p,2.0));        \n        \n        vec3 col = render(ro ,rd);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n\tfragColor = vec4( tot, 1.0 );    \n}\n\n#else //EQUIRECTANGULAR\n\n\n#define sePI radians(180.)\n#define seIPD 0.064\t\t\t\t// in meters\n#define seSCALE 1.0\n#define seAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef seAA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2  shiftedCoord = fragCoord + rook[n];\n#else //seAA\n        vec2  shiftedCoord = fragCoord;\n#endif //seAA\n        vec2 uv = shiftedCoord / iResolution.xy;\n#ifdef STEREO\n        // positive = right(bottom) ---- negative = left(top)\n        float side = -sign(uv.y - 0.5);\n        uv.y = fract(uv.y * 2.0);\n#endif // STEREO\n        vec2 polar = (uv - 0.5) * vec2(2.0 * sePI, sePI);\n        vec3 rd = vec3(sin(polar.x) * cos(polar.y), sin(polar.y), -cos(polar.x) * cos(polar.y));\n#ifdef STEREO\n        vec3 ro = (side * seIPD * 0.5) * vec3(cos(polar.x), 0, sin(polar.x)) / seSCALE;\n#else // STEREO\n        vec3 ro = vec3(0);\n#endif\n        vec4 outColor;\n        mainVR( outColor, fragCoord, ro, rd);\n        tot += outColor.xyz;\n#ifdef seAA\n    }\n    tot /= 4.;\n#endif  //seAA\n\tfragColor = vec4(tot, 1.0);        \n}\n\n#endif //EQUIRECTANGULAR", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGczm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[232, 232, 267, 267, 293], [295, 295, 330, 330, 357], [359, 359, 412, 412, 473], [475, 475, 495, 495, 863], [866, 866, 887, 887, 949], [951, 951, 973, 973, 1274], [1277, 1288, 1330, 1330, 1629], [1631, 1631, 1658, 1658, 1801], [1803, 1803, 1864, 1864, 2034], [2036, 2036, 2091, 2091, 2187], [2189, 2189, 2219, 2219, 2767], [2769, 2769, 2819, 2819, 2983], [2985, 2985, 3063, 3063, 3202]], "test": "untested"}
{"id": "wsGyRm", "name": "varia #inktober2020 \"disgusting\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nref image: [img]https://www.20minutes.fr/insolite/2613683-20190927-video-nantes-teste-musee-plats-plus-degoutants-monde[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 7, "viewed": 317, "published": 3, "date": "1602451808", "time_retrieved": "2024-07-30T20:40:51.947236", "image_code": "// 2-eyes variant of https://shadertoy.com/view/wdGyRw\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )           // rotation                  \n#define C(a,l,L)  max(  length((a).xy) -l, abs(a).z -L )   // cylinder\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a,b,c;\n    vec3  R = iResolution, M = iMouse.xyz/R,\n          D = normalize(vec3( U+U, -3.*R.y ) - R ),      // ray direction\n          p = 50./R, q,q1,q2;                            // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.02 )\n        q = p, t=9.,\n        q.yz *= rot(.8 + 2. *M.y),                       // rotations\n        q.xz *= rot(   - 6.3*M.x),\n        q = q.xzy,\n        t = max( -C( q, 9.,11.), C( q, 10.,10.)),        // mug\n        t = min(t, a = C( q, 9.,8.)),                    // liquid\n        t = min(t, b = length(q1=q-vec3(2.*cos(.5*iTime+vec2(0,11)),7.5)) -2. ), // eye\n        t = min(t, c = length(q2=q-vec3(6.*sin(.3*iTime+vec2(0,11)),7.5)) -2. ), // eye\n        p += t*D;                                        // step forward = dist to obj          \n\n    if(O.x>1.) return;\n    if (a==t) O = vec4(2,0,0,0);                         // coloring\n    if (b==t) q1.xz *= rot(.5*sin(iTime)), O = vec4(C(q1,.0,2.));\n    if (c==t) q2.xz *= rot(.7*cos(iTime)), O = vec4(C(q2,.0,2.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 253, 253, 1315]], "test": "untested"}
{"id": "tsGyRm", "name": "Starry Nebula", "author": "Zi7ar21", "description": "Thanks LoicVDB for the shading! https://www.shadertoy.com/user/loicvdb", "tags": ["raymarch", "dither", "volumetric", "volumetric", "raymarcher", "nebula", "slow", "multipass", "nonrealtime"], "likes": 5, "viewed": 437, "published": 3, "date": "1602451261", "time_retrieved": "2024-07-30T20:40:52.706207", "image_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// Buffer A is Rendering and Settings\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Starry Nebula --- August 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tsGyRm\n// Fork of \"Another Non-Realtime Nebula\" by Zi7ar21. https://www.shadertoy.com/view/tsKyRD\n// 2020-10-11\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- 2020-09-08 19:37:55\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- 2020-10-11\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// This is for Rendering and Settings\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 64\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 6.0\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 8\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.1\n\n// Camera's FOV\n#define FOV 2.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n//#define ROTATION_MATRIX\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again.\n#define DENSITY 0.1\n\n// Tiles, more means easier on the Hardware\n#if HW_PERFORMANCE==0\n#define TILES 15\n#else\n#define TILES 2 // Set to 1 if you have a computer that can handle it so it will render faster\n#endif          // (most shouldn't time out, except for like Intel HD Graphics)\n// So kindly made by LoicVDB uwu\n\n// Amount of distortion to apply\n#define DISTORT_AMOUNT 2.5\n\n// Oof ugly mess below watch out lol\n\nbool isKeyPressed(int KEY){\n    return texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\n// ##### NOISE #####\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// 2D Noise for Dithering\nfloat hash13(vec3 p3){\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < NUM_OCTAVES; ++i){\n        v += a * noise(x);\n        x = x * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Colors\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float mainnoise = fbm(raypos+(fbm(raypos)*DISTORT_AMOUNT));\n    float subnoise = fbm(raypos/1.5);\n    float density = clamp(((mainnoise*12.0)-(subnoise*6.0))-pow(distance(vec3(0.0),raypos),2.0), 0.0, 1.0);\n    vec3 rgb = hsv2rgb(rgb2hsv(vec3(density))+vec3((mainnoise/1.35)+0.25, 0.85, 0.0));\n    return rgb;\n}\n\n// ##### RAYMARCHING #####\n\n/*vec3 directLight(vec3 raypos){\n    vec3 LightColor = vec3(1.0);\n    vec3 LightDirection = normalize(vec3(0.5));\n    float distorigin=0.0;\n    vec3 density=vec3(0.0);\n    vec3 raydirmod = LightDirection;\n    vec3 attenuation = vec3(1.);\n    for(int i=0; i<4; i++) {\n        raypos = raypos + raydirmod;\n        density = nebulanoise(raypos)*DENSITY;\n        vec3 absorbance = exp(-density);\n        attenuation *= absorbance;\n    }\n    return LightColor*attenuation;\n}*/\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin=0.0;\n    vec3 densityadd=vec3(0.0);\n    vec3 density=vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = (raydir*(hash13(vec3(coord, iFrame))+1.0))*STEP_SIZE;\n    vec3 outCol = vec3(0.);\n    vec3 attenuation = vec3(1.);\n    for(int i=0; i<MAX_MARCHES; i++) {\n        raypos = raypos + raydirmod;\n        densityadd = nebulanoise(raypos)*DENSITY;\n        density = vec3(density+densityadd);\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.-absorbance;\n        outCol += attenuation * transmittance; //* directLight(raypos); // For now we'll just consider that the\n        attenuation *= absorbance;                                      // volume recieves light in all cases\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol+vec3(texture(iChannel1, coord/iResolution.xy))*attenuation;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Camera Orientation\n    //vec3 camerapos = vec3((iMouse.x/iResolution.x)-0.5, (iMouse.y/iResolution.y)-0.5, -3.0);\n    vec3 camerapos = vec3(0.0, 0.0, -4.0);\n    #ifdef ROTATION_MATRIX\n        // Torture courtesey of Michael0884\n        float xrot = 0.0;\n        float yrot = 0.0;\n        float zrot = 0.0;\n        vec3 xdir = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n        vec3 ydir = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),\n                         cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n        vec3 zdir = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),\n                         sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n    \n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    \n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    vec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // LoicVDB: add the color and increase the sample count\n    fragColor += vec4(raymarched, 1.0);\n    if(isKeyPressed(32)){\n        fragColor.rgba = vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(acesFilm(color), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Star Background\n// This is to render stars\n\n// Blackbody Coloration from http://glslsandbox.com/e#40525.0\nvec3 blackbody(float Temp){\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n    col.y = 100.04 * log(Temp) - 623.6;\n    if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n        col.z = 194.18 * log(Temp) - 1448.6;\n        col = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n        return col;\n}\n\n// Noise\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4((vec3(clamp(hash12(fragCoord)-0.95, 0.0, 1.0))*blackbody((hash12(fragCoord)-0.99)*1000000.0))*(hash12(fragCoord*2.0)*8.0), 1.0);\n}", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1015, 1015, 1071, 1121, 1228]], "test": "untested"}
{"id": "WsGcRm", "name": "RoomsFromCubeMap", "author": "kuvkar", "description": "I wanted to try out iq's box function to create rooms out of cube maps, just a quick doodle.. sorry for messy code.", "tags": ["cubemap", "window", "room"], "likes": 24, "viewed": 719, "published": 3, "date": "1602445408", "time_retrieved": "2024-07-30T20:40:53.463183", "image_code": "// I wanted to try out iq's box function to create room/windows out of cube maps, \n// just a quick doodle.. sorry for messy code.\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst vec4 tint = vec4(0.4, 0.6, 0.9, 0.0);\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat tracePlane(in vec3 ro, in vec3 rd, in vec3 pp, in vec3 pn)\n{\n    float a = dot(pp - ro, pn);\n    float b = dot(rd, pn);\n    float t = a / b;    \n    return t;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nvec4 getWindow(vec3 worldSpacePos, vec3 rp, vec3 rd)\n{\n    float windowSize = 0.95;\n    vec3 n = vec3(0.0);\n    vec3 position_id = vec3(floor(worldSpacePos.xy * .5) * 2., 0.0);    \n    \n    vec3 relative_position = mod(worldSpacePos, 2.0)-1.0;    \n    vec3 boxCoordinate = -vec3(1., 1., .0) - position_id;\n\n    \n    vec2 hitp = boxIntersection(rp + boxCoordinate, rd, vec3(windowSize, windowSize, windowSize), n);\n    \n    \n    float id = rand(position_id.xy);\n    \n    if (hitp.x > 0.0 && abs(relative_position.x) < windowSize && abs(relative_position.y) < windowSize)\n    {\n        vec3 p = rp + rd * hitp.y;\n\t\tvec4 color = vec4(0.0);\n        \n        vec3 cubeCoordinate = p + boxCoordinate;\n        if (id > 0.5)\n        {\n        \tcolor = texture(iChannel3, cubeCoordinate);\n        }\n        else\n        {\n        \tcolor = texture(iChannel0, cubeCoordinate);\n        }\n\t\tcolor *= tint;\n        vec3 refl = reflect(rd, vec3(0.0, 0.0, -1.0));\n        color += texture(iChannel2, refl, 4.)*tint*.5;\n\n\t\t// light        \n        vec3 lightPos = vec3(0.0, .75, 0.0);\n        float flicker = rand(position_id.xy*.01);\n        float flickerPhase = 1.0;\n        if (flicker > 0.9)\n        {\n            flickerPhase = sin(cubeCoordinate.x*.1+cubeCoordinate.y*.4 + iTime * 4.0) + sin(iTime * 114.0);\n            flickerPhase = flickerPhase * 0.5 + 0.5;\n            flickerPhase = mix(flickerPhase, 1.0, clamp(sin(boxCoordinate.y*.1)+(rp.y - worldSpacePos.y)+1.5, 0.0, 1.0));\n        }\n        color += smoothstep(.4, -0., length(lightPos - cubeCoordinate)) * flickerPhase;\n        \n        color *= smoothstep(2.2, -0., length(lightPos - cubeCoordinate))*flickerPhase;\n        \n        // dirt\n        float dirt = rand(position_id.yx*.21);\n        if(dirt > 0.8)\n        {\n            color *= smoothstep(vec4(.0), vec4(.3), texture(iChannel1, position_id.xy*.4 + relative_position.xy*.1));\n        }            \n        \n        // balcony\n        float balcony = rand(position_id.xy*.15);\n        if(balcony > 0.7)\n        {\n            if(relative_position.y < -0.5)\n            {\n                color *= mod(relative_position.x, 0.05) * 1.;\n            }\n        }        \n        \n        // shades\n        float win = rand(position_id.yx*.3);\n        if(win < 0.4 && relative_position.y+1.> win)\n        {\n            color *= mod(relative_position.y, 0.1) * .5;\n        }\n        \n        // shading\n        color *= relative_position.y+1.;\n        return color;\n    }\n   \treturn vec4(.002);\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 n = vec3(0.0, 0.0, 1.0);\n    color = vec4(.0);\n    \n    float t = tracePlane(rp, rd, vec3(0.0, 0.0, -.5), vec3(0.0, 0.0, 1.0));\n    vec3 plane_hit = rp + rd * t;\n    color = getWindow(plane_hit, rp, rd);\n}\n\n\n    \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec2 im = ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    if(iMouse.z <= 0.0)\n    {\n        im.xy = vec2(.25);\n    }      \n    im *= vec2(1.2, .5);\n    float T = iTime;\n\n    fragColor = vec4(0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, T, -10.5);\n    vec3 _rp = rp;\n    rp = roty(im.x) * rp;\n    rp.y = (rotx(im.y) *_rp).y;\n    rp.z += sin(iTime)*.2;\n    rp.xy += sin(iTime)* .2;\n    rd = lookat(rp, vec3(0.0, T, 0.0)) * rd;\n    trace(rp, rd, fragColor);\n    \n    fragColor *= 1.-length(uv*vec2(.99, 1.8))*1.;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 151, 151, 278], [279, 279, 299, 299, 426], [427, 427, 447, 447, 574], [621, 621, 641, 641, 708], [710, 710, 776, 776, 876], [878, 926, 1009, 1009, 1487], [1490, 1490, 1544, 1544, 3989], [3991, 3991, 4045, 4045, 4260], [4268, 4268, 4301, 4301, 4501], [4504, 4504, 4561, 4561, 5266]], "test": "untested"}
{"id": "wdGczw", "name": "Humanoid Attempt", "author": "oneshade", "description": "This is my attempt to create a humanoid using only primitives. Drag the mouse too rotate.", "tags": ["3d", "raymarching", "humanoid"], "likes": 2, "viewed": 145, "published": 3, "date": "1602443262", "time_retrieved": "2024-07-30T20:40:54.214175", "image_code": "/*\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 2100.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2500.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 300;\n\n// Signed Distance Functions (SDFs):\nfloat sdRoundedCuboid(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - 0.5 * b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat SmoothUnion(float sdf1, float sdf2, float smoothness) {\n    float interpolation = clamp(0.5 + 0.5 * (sdf2 - sdf1) / smoothness, 0.0, 1.0);\n    return mix(sdf2, sdf1, interpolation) - smoothness * interpolation * (1.0 - interpolation);\n}\n\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    p = Rotate(p, vec3((iMouse.yx - 0.5 * iResolution.yx) * vec2(0.5, -0.5), 0.0));\n    float head = sdSphere(Translate(p, vec3(0.0, 442.5, 0.0)), 100.0);\n    float neck = sdCylinder(Translate(p, vec3(0.0, 337.5, 0.0)), 60.0, 55.0);\n    float torso = sdRoundedCuboid(Translate(p, vec3(0.0, 107.5, 0.0)), vec3(225.0, 300.0, 100.0), 50.0);\n    float rightShoulder = sdSphere(Translate(p, vec3(200.0, 257.5, 0.0)), 50.0);\n    float leftShoulder = sdSphere(Translate(p, vec3(-200.0, 257.5, 0.0)), 50.0);\n    float rightArm = Union(sdCylinder(Translate(p, vec3(200.0, 122.5, 0.0)), 275.0, 50.0), sdSphere(Translate(p, vec3(200.0, -15.0, 0.0)), 50.0));\n    float leftArm = Union(sdCylinder(Translate(p, vec3(-200.0, 122.5, 0.0)), 275.0, 50.0), sdSphere(Translate(p, vec3(-200.0, -15.0, 0.0)), 50.0));\n    float rightHip = sdSphere(Translate(p, vec3(100.0, -92.5, 0.0)), 50.0);\n    float leftHip = sdSphere(Translate(p, vec3(-100.0, -92.5, 0.0)), 50.0);\n    float rightLeg = Union(sdCylinder(Translate(p, vec3(100.0, -242.5, 0.0)), 300.0, 50.0), sdSphere(Translate(p, vec3(100.0, -392.5, 0.0)), 50.0));\n    float leftLeg = Union(sdCylinder(Translate(p, vec3(-100.0, -242.5, 0.0)), 300.0, 50.0), sdSphere(Translate(p, vec3(-100.0, -392.5, 0.0)), 50.0));\n    return SmoothUnion(head, SmoothUnion(neck, Union(SmoothUnion(Union(SmoothUnion(torso, Union(rightShoulder, leftShoulder), 50.0), Union(rightArm, leftArm)), Union(rightHip, leftHip), 20.0), Union(rightLeg, leftLeg)), 20.0), 20.0);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(0.878, 0.675, 0.412);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 0.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (distanceToClosest < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[683, 720, 768, 768, 869], [871, 871, 924, 924, 980], [982, 982, 1021, 1021, 1049], [1051, 1099, 1160, 1160, 1341], [1343, 1343, 1386, 1386, 1416], [1418, 1438, 1476, 1476, 1496], [1498, 1498, 1533, 1533, 2144], [2146, 2173, 2200, 2200, 3682], [3684, 3733, 3766, 3766, 4096], [4098, 4133, 4183, 4183, 4217], [4219, 4219, 4269, 4269, 4309], [4311, 4311, 4362, 4362, 4396], [4398, 4398, 4451, 4451, 4469], [4471, 4492, 4531, 4531, 6009], [6011, 6044, 6099, 6099, 6419]], "test": "untested"}
{"id": "wsyyRw", "name": "Fab12 #inktober2020 \"slippery\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 17, "viewed": 374, "published": 3, "date": "1602442432", "time_retrieved": "2024-07-30T20:40:55.069887", "image_code": "#define rot(a)     mat2( cos(a+vec4(0,11,33,0)) )                    // rotation                  \n#define S(v)       smoothstep( 2.,-2., R.y*(v) )                     // AA\n#define B(U,L,l)   t = min( t, max( abs((U).x)-L , abs((U).y)-l ) ), // box\n\nvoid mainImage(out vec4 O, vec2 u) {   \n    vec2  R = iResolution.xy,\n          U = .9*( u+u - R ) / R.y;\n    U.y += .3;\n    float t = 6.283/6., T = 8.*iTime,\n          d = length(U)*cos( mod( atan(U.x,U.y),  t+t ) -t );  // --- red triangle\n    O = mix( vec4(d<.5), vec4(1,0,0,1), S( abs(d-.5) - .1 ) );\n    \n    if ( abs(U.y+.2) < .2)                                     // --- S\n        d = U.x -.15*cos(18.*U.y+T) -.15-.5*U.y,\n        O -=   S(  abs(d+.3 ) +.3*U.y )\n             + S(  abs(d+U.y) +.3*U.y );\n    \n    U -= vec2( .15*cos(T), .1 );                              // --- car\n    U *= rot(.2*sin(T) );\n    U.x = abs(U.x);\n    B(U,.18,.06)                                              // body\n    B(U - vec2(.13,-.06), .02,.05 )                           // wheels\n    B(U - vec2(  0 ,.15), .12,.015)                           // roof\n    U *= rot(.3); B(U - vec2(.15,.06), .015,.06 )             // window sides\n    O -= S(t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wsyyzw", "name": "truchetFlipLoop", "author": "Kaeylos", "description": "#2 Monochromatic\nmade during the Ink-MAC-tober 2020", "tags": ["truchet", "loop", "imac"], "likes": 0, "viewed": 204, "published": 3, "date": "1602442067", "time_retrieved": "2024-07-30T20:40:55.906650", "image_code": "// source: https://www.shadertoy.com/view/ttc3zr\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash11(float src) { return uintBitsToFloat(murmurHash11(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) { return uintBitsToFloat(murmurHash12(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\n// ----- easingFunct -----//\nfloat quadIn(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat quadInOut(float t) { return t < 0.5 ? 2. * t * t : 1. - (-2. * t + 2.)*(-2. * t + 2.) / 2.;}\n\n#define PI  3.14159265358979323846264338327\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 UV = fragCoord.xy/iResolution.xy;\n    uv *= 6. + 1.*(sin(iTime*PI/12.) + 0.5* sin(iTime*PI/6.)); // zoom\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    vec3 col = vec3(0.);\n    \n    float width = 0.1 + 0.3 * (sin(iTime*PI/3.)+1.)/2.;\n    \n    float n = hash12(id); // noise\n\n    if(n<.5) gv.x *= -1.; // flip\n    \n    float d = abs(gv.x + gv.y);// distance to center\n    d = abs(d-.5); // shift center\n    \n\tvec2 cUv = gv-sign(gv.x+gv.y+0.001)*.5; // curved\n    \n    d = mix(d, length(cUv), quadInOut((sin(iTime*PI/6.)+1.)/2.));\n    \n    float mask = smoothstep(0.01, -0.01, abs(d-.5)-width);\n    \n    col = vec3(mask);\n    \t\n    vec2 lv = fract(uv);\n    // if(lv.x>.98 || lv.y>.98) col = vec3(1., 0., 0.); // grid helper\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 78, 78, 253], [254, 254, 279, 279, 375], [377, 377, 407, 407, 604], [605, 605, 629, 629, 725], [727, 756, 779, 779, 792], [793, 793, 817, 817, 837], [838, 838, 864, 864, 936], [983, 983, 1040, 1040, 1882]], "test": "untested"}
{"id": "wdGyRw", "name": "Fab11 #inktober2020 \"disgusting\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nref image: [img]https://www.20minutes.fr/insolite/2613683-20190927-video-nantes-teste-musee-plats-plus-degoutants-monde[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 5, "viewed": 294, "published": 3, "date": "1602437025", "time_retrieved": "2024-07-30T20:40:56.739423", "image_code": "#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )           // rotation                  \n#define C(a,l,L)  max(  length((a).xy) -l, abs(a).z -L )   // cylinder\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a,b;\n    vec3  R = iResolution, M = iMouse.xyz,\n          D = normalize(vec3( U+U, -3.*R.y ) - R ),      // ray direction\n          p = 50./R, q;                                  // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.02 )\n        q = p, t=9.,\n        q.yz *= rot(.8 + 2. *M.y),                       // rotations\n        q.xz *= rot(   - 6.3*M.x),\n        q = q.xzy,\n        t = max( -C( q, 9.,11.), C( q, 10.,10.)),        // mug\n        t = min(t, a = C( q, 9.,8.)),                    // liquid\n        t = min(t, b = length(q-=vec3(3.*cos(.5*iTime+vec2(0,11)),7.5)) -2. ), // eye\n        p += t*D;                                        // step forward = dist to obj          \n\n   if (a==t && O.x<1.) O = vec4(2,0,0,0);                // coloring\n   if (b==t && O.x<1.) q.xz *= rot(.5*sin(iTime)), O = vec4(C(q,.0,2.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 198, 198, 1084]], "test": "untested"}
{"id": "3sGyzw", "name": "Fab10 #inktober2020 \"hope\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nref image: [img] https://www.wired.com/story/laurie-penny-on-hope/ [/img]", "tags": ["short", "golf", "reproduction", "inktober2020"], "likes": 11, "viewed": 349, "published": 3, "date": "1602434875", "time_retrieved": "2024-07-30T20:40:57.602117", "image_code": "#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                    // rotation                  \n#define B(a,l,L)  max(  max( abs(a).x, abs(a).y ) -l, abs(a).z -L ) // bar\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a;\n    vec3  R = iResolution, e = vec3(5,-5,0), X=e.xzz, Z=e.zzx,\n          M = iMouse.z > 0. ? iMouse.xyz/R : .01*cos(.5*iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -2.*R.y ) - R ),      // ray direction\n          p = 50./R, q,s;                                // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot(-.4 -6.3*M.y),                       // rotations\n        q.xz *= rot(-.4 -6.3*M.x),\n        s = q = q.xzy,\n        t = min( t, max( -B((q-3.*Z),11.,2.), a = abs(q.z-15.)-1.5 ) ), // roof hole\n        q.y += 2., q.yz *= rot(.4),\n        t = min( t, B(abs(q)-X,.7,30.) ),                // ladder sides\n        t = t = min( t, max( abs(q.z)-28.,  B(vec3(mod(q.z+2.5,5.)-2.5,q.yx),.5,5.) ) ),\n        p += t*D;                                        // step forward = dist to obj          \n\n   if ( a==t || O.x>1. && s.z<200.) O *= 0.;             // roof & horizon = blaxk\n// if (s.z>200.) O *= vec4(.7,1,1,0);                    // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 211, 211, 1272]], "test": "untested"}
{"id": "3sGyRm", "name": "Sumpinski", "author": "samuelotherion", "description": "Again some Sieprinski Adaption.\n\nCaution!!!\nIf you watch too long then your world will rotate the other direction.\n\n@Fabrice: I know. It's too much unnecessary code for you! (O;", "tags": ["tutorial", "sierpinski"], "likes": 2, "viewed": 287, "published": 3, "date": "1602424735", "time_retrieved": "2024-07-30T20:40:58.421925", "image_code": "// height of a equilateral triangle\nconst float h = .5 * sqrt(3.);\n\nvoid mainImage(out vec4 o, in vec2 p) {\n\n    // want a black background\n    o = 0. * o;\n    \n    // use later for rotation\n    vec2 cs = vec2(cos(iTime), sin(iTime)),\n\t// scale centered axes\n         uv = (2.5 + 2.5 * sin(.3 * iTime)) * (2. * p / iResolution.xy - 1.) * vec2(iResolution.x / iResolution.y, 1);\n    \n    // points of the triangele: a, b, c\n    vec2 a = vec2(-1., -h),\n         b = vec2(+1., -h),\n         c = vec2(+0., +h),\n    // x and y axes and center z\n         x = b - a,\n         y = c - a,\n         z = (a + b + c) / 3.;\n    \n    // center all points of the triangle\n    a -= z; b -=z; c -= z;\n    \n    // rotate the world, so the triangle rotates back\n    uv *= mat2(cs.x, cs.y, -cs.y, cs.x);\n    \n    // trafo into triangle world\n    mat2 sierpinski = inverse(mat2(x, y));\n    \n    // apply trafo, with point 'a' as new origin\n    vec2 r = sierpinski * (uv - a);\n    \n    // scale factor for triangle size\n    float f = 1.;\n    \n    // if in triangle colorize it a little bit\n    if(0. <= r.x && 0. <= r.y && r.x + r.y < f) o = vec4(1. - dot(uv,uv));// + .1 *  cos(.1 * iTime));\n        \n    // divide 15 times\n    for(int i = 0; i < 15; ++ i) {\n        \n    \to.rgb -=\n            // am i inside the triangle? \n            // uncomment the next line for a showing only the center triangle!\n            // 0. <= r.x && 0. <= r.y && r.x + r.y < 1. &&\n            // am i in the lower left part of square in sierpinski space? -----------------------------------\n\t\t\t(mod(r.x, f) + mod(r.y, f) < f) //                                                               |\n             ? fract(mod(f, sin(.1 * iTime))) * vec3(r.x, r.y, 1. - r.x - r.y) //yes, so add some rgb colors |\n             : vec3(0.); // no, so add nothing                                                               |\n    \t                //                                                       ----------------------------\n                       //                                                       |\n        // divide the scaling factor                                            |\n        f *= .5;     //                                                         |\n    }               //                                                          |\n}                  //                                                           |\n                  //                                                            |\n/*    --------------------------------------------------------------------------\n     |\n     V\n\nf = .5\n\n+ - - - - - -\n+ + - - - - -\n+ + + - - - -\n+ + + + - - -\n+ + + + + - -\n+ + + + + + -\n+ + + + + + +\n\nf = .25\n\n+ - - - - - -\n+ + - - - - -\n+ + + - - - -\n+ - - - - - -\n+ + - - + - -\n+ + + - + + -\n+ + + + + + +\n\nf = .125\n\n+ - - - - - -\n+ + - - - - -\n+ + + - - - -\n+ - - - - - -\n+ + - - + - -\n+ - + - + + -\n+ + + + + + +\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 107, 139, 2311]], "test": "untested"}
{"id": "WdycRw", "name": "cinetunnel", "author": "tomviolin", "description": "for cineshader\n\n", "tags": ["cineshader"], "likes": 9, "viewed": 17276, "published": 3, "date": "1602404835", "time_retrieved": "2024-07-30T20:40:59.294591", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy/2.;\n    center.x = center.x + sin(iTime*6.)*iResolution.x*.03;\n    center.y = center.y + cos(iTime*5.4)*iResolution.x*.033;\n    float d = length(vec2(fragCoord.x,fragCoord.y) - center)/iResolution.x;\n    float a = -atan(fragCoord.y-center.y,fragCoord.x-center.x)*6.;\n    float r = (sin(a+3.14159*4./3.+4./d*1.+iTime*6.)*.5+.5)*d*2.;\n    float g  = (sin(a+3.14159*2./3.+4./d*1.+iTime*6.)*.5+.5)*d*2.;\n    float b = (sin(a+4./d*1.+iTime*6.)*.5+.5)*d*2.;\n    float w = (sin(a*4.+3.14159*2./3.+3./d*1.+iTime*6.)*.5+.5)*1.*sin(a*7.);\n    w=w>.6?3.:0.;\n    w=w*d;\n    fragColor = vec4(\n        clamp(w+r,0.,1.),\n        clamp(w+g,0.,1.),\n        clamp(w+b,0.,1.),\n        atan(5.-1./d)/3.14159*2.+4.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdycRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 788]], "test": "untested"}
{"id": "wsK3R3", "name": "stupid", "author": "tomviolin", "description": "stupid", "tags": ["stupid"], "likes": 0, "viewed": 248, "published": 3, "date": "1602402430", "time_retrieved": "2024-07-30T20:41:00.048575", "image_code": "const float pi=3.14159265358;\nconst float rr=5.;\nfloat surface (vec2 st) {\n    \n    return fract(sin(dot(st.xy-vec2(mod(st.x,rr/iResolution.x),mod(st.y,rr/iResolution.y)),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat prod(vec2 x){\n    return x.x*x.y;\n}\n\nfloat interpsurface(vec2 st) {\n    vec2  u=rr/iResolution.xy;\n\n    vec2 x = mod(st,u);\n    //if (x.x<u.x/4. && x.y<u.y/4.) return surface(st-x);\n    vec2 u00 = st-x;\n    vec2 u01 = u00 + u*vec2(0,1);\n    vec2 u10 = u00 + u*vec2(1,0);\n    vec2 u11 = u00 + u;\n    float w00=(prod(abs(u00-st)/u));\n    float w01=(prod(abs(u01-st)/u));\n    float w10=(prod(abs(u10-st)/u));\n    float w11=(prod(abs(u11-st)/u));\n\treturn surface(u11) * w00 //x.x * x.y/u.x/u.y\n          +surface(u10) * w01 //x.x/u.x * (1.-x.y/u.y)\n          +surface(u01) * w10 //(1.-x.x/u.x)*(x.y/u.y)\n          +surface(u00) * w11 ; //(1.-x.x/u.x)*(1.-x.y/u.y);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fg = vec2(fragCoord.x/3.14159*iResolution.x,(fragCoord.y/3.14159*iResolution.y));\n    fg.y+=iTime*200.;\n\tfragColor = vec4(interpsurface((fg)/(iResolution.xy)));\n    fragColor.r *= sin(fragCoord.x/3.14159/10.+iTime)*0.5+0.5;\n    fragColor.g *= cos(fragCoord.y/3.14159/10.-iTime)*0.5+0.5;\n    float d = length(fragCoord - iResolution.xy/2.);\n    fragColor.a = cos(d/15.-iTime*2.4)*0.1; //+(1.-d/iResolution.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsK3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 74, 74, 246], [247, 247, 266, 266, 288], [290, 290, 320, 320, 915], [921, 921, 978, 978, 1398]], "test": "untested"}
{"id": "tsVczD", "name": "Space Gum", "author": "thepheer", "description": "Experimenting.", "tags": ["raymarching", "sdf"], "likes": 8, "viewed": 396, "published": 3, "date": "1602390899", "time_retrieved": "2024-07-30T20:41:00.800565", "image_code": "struct RM { vec3 p; float t; float d; };\n\nfloat map(vec3 p) {\n    float d = 0.0, da = 0.05, df = 10.0;\n    for (int i = 0; i < 3; i++, da *= 0.5, df *= 2.0)\n        d += da*prod3(sin(df*p));\n    \n    vec3 r = vec3(0.6);\n    mat4 tr = rotation(vec3(0.3, 0.5, 0.7)*0.1*iTime);\n    mat4 tt = translation(mod(vec3(0.0, 0.0, 0.1)*iTime, r));\n    vec3 tp = mod(transform(tr*tt, p), r) - 0.5*r;\n\treturn 0.9*(sdSphere(tp, 0.1) + d);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p) {\n    const vec3 k = vec3(1.0, -1.0, 1e-5);\n    return normalize(\n        k.xyy*map(p + k.xyy*k.z) +\n        k.yyx*map(p + k.yyx*k.z) +\n        k.yxy*map(p + k.yxy*k.z) +\n        k.xxx*map(p + k.xxx*k.z)\n    );\n}\n\nbool raymarch(vec3 rc, vec3 ro, vec3 rd, out RM rm) {\n\t// rayconfig rc: threshold, near, far\n    for (rm.t = rc.y; rm.t < rc.z; rm.t += rm.d)\n        if (abs(rm.d = map(rm.p = ro + rm.t*rd)) < rc.x)\n            return true;\n    return false;\n}\n\nvec3 render(vec2 uv) {\n    vec3 material = vec3(2.0, 0.2, 0.1);\n    vec3 ambient = 0.1*vec3(0.1, 0.2, 0.3);\n    vec3 light = 1.5*vec3(1.0);\n    vec3 fog = ambient;\n    \n    vec3 rc = vec3(1e-3, 0.0, 10.0);\n    vec3 rt = vec3(1.0*uv, 2.0);\n    vec3 ro = vec3(0.0*uv, 0.0);\n    vec3 rd = normalize(rt - ro);\n    RM rm;\n\n    if (!raymarch(rc, ro, rd, rm))\n        return fog;\n\t\n    //if (rm.d < 0.0)\n    //    return vec3(1.0, 0.0, 0.0);\n    \n    vec3 n = normal(rm.p);\n    vec3 lp = vec3(0.0, 0.25, 0.0) - rm.p;\n    vec3 ld = normalize(lp);\n    float ll = length(lp);\n    \n    float diffuse = 1.0*max(0.0, dot(n, ld));\n    float specular = 2.0*pow(max(0.0, dot(rd, reflect(ld, n))), 200.0);\n    vec3 color = ambient + (material*diffuse + specular)*light/(ll*ll);\n    return mix(color, fog, rm.t/rc.z);\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 r = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = 2.0*xy/iResolution.xy - 1.0;\n    rgba = vec4(srgb(aces(render(r*uv))), 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// https://www.shadertoy.com/view/WdGcD1\nvec3 aces(vec3 color) {\t\n    mat3 x = mat3(+0.59719, +0.07600, +0.02840, +0.35458, +0.90834, +0.13383, +0.04823, +0.01566, +0.83777);\n    mat3 y = mat3(+1.60475, -0.10208, -0.00327, -0.53108, +1.10813, -0.07276, -0.07367, -0.00605, +1.07602);\n    vec3 v = x*color;    \n    vec3 a = v*(v + 0.0245786) - 0.000090537;\n    vec3 b = v*(0.983729*v + 0.4329510) + 0.238081;\n    return y*(a/b);\t\n}\n\nvec3 srgb(vec3 c) {\n    vec3 a = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*c;\n    return mix(a, b, lessThanEqual(c, vec3(0.0031308)));\n}\n\nfloat prod3(vec3 v) {\n\treturn v.x*v.y*v.z;\n}\n\nvec3 transform(mat4 m, vec3 v) {\n\treturn (vec4(v, 1.0) * m).xyz;\n}\n\nmat4 rotation(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    return mat4(\n    \tc.y*c.z, c.y*s.z, -s.y, 0.0,\n        s.x*s.y*c.z-c.x*s.z, s.x*s.y*s.z+c.x*c.z, s.x*c.y, 0.0,\n        c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z, c.x*c.y, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 translation(vec3 p) {\n    return mat4(\n        1.0, 0.0, 0.0, p.x,\n        0.0, 1.0, 0.0, p.y,\n        0.0, 0.0, 1.0, p.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 61, 61, 426], [428, 474, 495, 495, 706], [708, 708, 761, 800, 951], [953, 953, 975, 975, 1754], [1756, 1756, 1796, 1796, 1942]], "test": "untested"}
{"id": "wdVczD", "name": "A rock", "author": "thepheer", "description": " Experimenting.", "tags": ["raymarching", "sdf"], "likes": 18, "viewed": 501, "published": 3, "date": "1602390841", "time_retrieved": "2024-07-30T20:41:01.561530", "image_code": "struct RM { vec3 p; float t; float d; };\n\nfloat map(vec3 p) {\n    float d = 0.0, da = 0.1, df = 1.0;\n    if (length(p) < 1.01)\n        for (int i = 0; i < 10; i++, da *= 0.5, df *= 2.0)\n            d += da*snoise(df*p);\n\n    return min(\n    \tsdPlane(p, vec3(0.0, 1.0, 0.0), 1.0),\n        0.5*(sdSphere(p, 1.0) + d)\n    );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p) {\n    const vec3 k = vec3(1.0, -1.0, 1e-5);\n    return normalize(\n        k.xyy*map(p + k.xyy*k.z) +\n        k.yyx*map(p + k.yyx*k.z) +\n        k.yxy*map(p + k.yxy*k.z) +\n        k.xxx*map(p + k.xxx*k.z)\n    );\n}\n\nbool raymarch(vec3 rc, vec3 ro, vec3 rd, out RM rm) {\n\t// rayconfig rc: threshold, near, far\n    for (rm.t = rc.y; rm.t < rc.z; rm.t += rm.d)\n        if ((rm.d = map(rm.p = ro + rm.t*rd)) < rc.x)\n            return true;\n    return false;\n}\n\nvec3 render(vec2 uv) {\n    vec3 material = vec3(0.13, 0.11, 0.08);\n    vec3 ambient = 0.02*vec3(0.10, 0.15, 0.25);\n    vec3 light = 50.0*vec3(1.0);\n    vec3 fog = 3.0*ambient;\n    \n    vec3 rc = vec3(1e-4, 1e-3, 1e+1);\n    vec3 rt = vec3(1.3*uv,  0.0);\n    vec3 ro = vec3(0.0*uv, -5.0);\n    vec3 rd = normalize(rt - ro);\n    RM rm, rml;\n    \n    if (!raymarch(rc, ro, rd, rm))\n        return fog;\n    \n    //if (rm.d < 0.0)\n    //    return vec3(1.0, 0.0, 0.0);\n    \n    vec3 n = normal(rm.p);\n    vec3 lp = 2.5*vec3(cos(iTime), 1.0, sin(iTime)) - rm.p;\n    vec3 ld = normalize(lp);\n    float ll = length(lp);\n    \n    if (raymarch(vec3(rc.xy, ll), rm.p, ld, rml))\n        return mix(ambient, fog, rm.t/rc.z);\n    \n    float diffuse = 4.0*max(0.0, dot(n, ld));\n    float specular = 0.2*pow(max(0.0, dot(rd, reflect(ld, n))), 50.0);\n    vec3 color = ambient + (material*diffuse + specular)*light/exp(ll);\n    return mix(color, fog, rm.t/rc.z);\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 r = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = 2.0*xy/iResolution.xy - 1.0;\n    rgba = vec4(srgb(render(r*uv)), 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/distfunctions\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// https://gamedev.stackexchange.com/a/148088\nvec3 srgb(vec3 rgb) {\n    bvec3 t = lessThan(rgb, vec3(0.0031308));\n    vec3 a = 1.055*pow(rgb, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*rgb;\n    return mix(a, b, t);\n}\n\n// https://www.shadertoy.com/view/Xd3GRf\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 61, 61, 323], [325, 371, 392, 392, 603], [605, 605, 658, 697, 845], [847, 847, 869, 869, 1791], [1793, 1793, 1833, 1833, 1973]], "test": "untested"}
{"id": "wdVcRD", "name": "cityfolding2", "author": "jj99", "description": " A quick shadertoy port of City Shader from MagicaVoxel - original by mode_vis / paulofalcao\nusing sabs for folds", "tags": ["sdf", "folding", "kifs", "city", "sabs"], "likes": 11, "viewed": 652, "published": 3, "date": "1602374684", "time_retrieved": "2024-07-30T20:41:02.315514", "image_code": "// A quick shadertoy port of City Shader from MagicaVoxel - original by mode_vis / paulofalcao\n// using sabs for the folds as suggested by ollj\n\n#define AA 1\n\nfloat box(vec3 r, vec3 p, vec3 size)\n{\n    r = abs(r-p) - size;\n    return max(max(r.x,r.y),r.z);\n}\n\nfloat sphere(vec3 r,vec3 p, float radius)\n{\n    return length(r-p) - radius;\n}\n\nfloat cylinder(vec3 r,vec3 p, float radius, float height)\n{\n    return max(length(r.xy-p.xy) - radius, abs(r.z-p.z)-height);\n}\nmat2 rot(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\n#define less(a,b,c)      mix(a,b,step(0.,c))\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\nvec3 Folding(vec3 p)\n{\n    p *= -0.3;\n    \n    float f = 2.65;\n    float ic = 0.0;\n    if (iMouse.z>0.5)\n    {\n        f+=sin(iTime*0.7);\n        ic  = sin(iTime*1.2)*0.1;\n    }\n    \n    \n    \n    float s=3.;\n\tfor(int i=0;i<10;i++)\n    {\n\t\tp.xy=sabs(p,0.01).xy-s;\n        p.xy *= rot(f*0.1);\n\t    p.xz *= rot(ic*0.1);\n\t\ts=s/1.3;\n\t}\n    \n    return p;\n}\n\n\nfloat map( in vec3 p )\n{\n    \n\tfloat d = cylinder(p.xzy,vec3(0.0),4.75,1.0);\n    \n    p.yz*=rot(3.14*0.5);\n    \n    \n    p = Folding(p);\n    p += .05;\n    \n    vec3 pos1 = p;\n    pos1.x = abs(p.x);\n    vec3 pos2 = p;\n    \n    p.xy = abs(p.xy);\n    \n    \n\tfloat sdf = 0.;\n    sdf = box(p,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));\n\tsdf = min(sdf,box(p,vec3(0.08,0.08,0.0),vec3(0.05,0.05,0.004)));\n\tsdf = max(sdf,-box(p,vec3(0.08,0.08,0.0),vec3(0.045,0.045,0.0025)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));\n\n    vec3 b1 = p;\n\tb1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    float XYsize =  max(0.0,.5*p.z-0.02);\n    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.008);\n    sdf = min(sdf,box(b1,vec3(-0.0,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));\n    sdf = max(sdf,-box(b1,vec3(0.0,0.0,0.052),vec3(0.02+XYsize,0.02+XYsize,0.05)));\n    sdf = min(sdf,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.007)));\n\tsdf = min(sdf,box(b1,vec3(0.04,0.02,0.05),vec3(0.004,0.002,0.006)));\n    b1.xy *= 0.56;\n    b1 = abs(b1-0.02);\n\tsdf = max(sdf,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));\n\n    vec3 b0 = pos1;\n    b0.xy -= 0.08;\n\tb0=abs(b0);\n    sdf = min(sdf,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));\n    sdf = max(sdf,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n    float noise = 1.+0.05*length(sin(p*2000.0))+0.2*length(sin(p*900.0)); \n    b0.xy = abs(b0.xy);\n    b0.xy -= 0.02;\n    b0.xy = abs(b0.xy);\n    b0 -= vec3(0.01,0.01,0.02);\n    sdf = min(sdf,cylinder(b0,vec3(0.,0.,-0.015),0.001,0.009));\n    b0*=noise;\n    sdf = min(sdf,sphere(b0,vec3(0.),0.007));\n    sdf = min(sdf,sphere(b0,vec3(0.,0.,-.006),0.011));\n\n    vec3 b2 = p;\n    b2.xy -= 0.22;\n    b2 = abs(b2);\n\tsdf =  min(sdf,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.03,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.04),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.07),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.1),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.05),vec3(0.02,0.02,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.03),vec3(0.03,0.04,0.1)));\n\tsdf = max(sdf,-box(b2,vec3(0.,0.,0.025),vec3(0.03,0.025,0.1)));\n\n    vec3 b3 = pos2;\n    b3.xy -=  vec2(0.08,0.-0.08);\n    b3 = abs(b3);\n\tsdf = min(sdf,box(b3,vec3(0.,0.,0.053),vec3(0.045,0.045,0.008)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.033),vec3(0.04,0.04,0.033)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.0,0.064),vec3(0.04,0.04,0.006)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.033),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.033),vec3(0.051,0.01,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.053),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.053),vec3(0.051,0.01,0.003)));\n\tsdf = max(sdf,-box(b3,vec3(0.,0.016,0.003),vec3(0.051,0.01,0.003)));\n    sdf = min(sdf,box(b3,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\n    vec3 b4 = pos2;\n    b4.xy -= vec2(0.08,0.-0.22);\n    b4 = abs(b4);\n    sdf = min(sdf,box(b4,vec3(0.,0.,0.003),vec3(0.051,0.051,0.003)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));\n    sdf = min(sdf,box(b4,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b4,vec3(0.05,0.05,0.04),vec3(0.005,0.001,0.001)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.052,0.01,0.004)));\n    vec3 cone = b4;\n    vec3 stairs = b4;\n    sdf = min(sdf,cylinder(b4,vec3(0.008,0.008,0.015),0.0005,0.006));\n    cone.xy += (cone.z-0.021);\n    sdf = min(sdf,cylinder(cone,vec3(0.,0.,0.026),0.015,0.006));\n    stairs.xy += floor(stairs.z * 800.0)/800.0;\n\tsdf = min(sdf,box(stairs,vec3(0.008,0.008,0.0),vec3(0.02,0.02,0.01)));\n\n    vec3 b5 = pos2;\n    b5.xy -= vec2(-0.08,0.-0.22);\n\tb5 = abs(b5);\n    sdf = min(sdf,box(b5,vec3(0.014,0.0018,0.0),vec3(0.002,0.001,0.03)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.03),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.02,0.0018,0.032),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.024),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.04,0.01,0.0),vec3(0.01,0.016,0.01)));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.004),0.004));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.010),0.006));\n    sdf = min(sdf,box(b5,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b5,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\n    sdf = max(sdf,d);\n    \n    return sdf;\n}\n\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.125*iTime;\n\tvec3 ro = vec3( 6.0*cos(an), .8+sin(iTime)*0.4, 6.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 ldir = normalize(vec3(0.5,0.2,0.4));\n            \n            float dif = clamp( dot(nor,ldir), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.2,0.2)*amb + vec3(0.8,0.7,0.5)*dif;\n   \t\t\tcol+= pow(dif, 40.);\n\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 197, 197, 258], [260, 260, 303, 303, 338], [340, 340, 399, 399, 466], [467, 467, 486, 486, 538], [642, 642, 664, 664, 994], [997, 997, 1021, 1021, 5973], [5977, 6023, 6055, 6055, 6293]], "test": "untested"}
{"id": "tsKyRD", "name": "Another Non-Realtime Nebula", "author": "Zi7ar21", "description": "Trying out different things.", "tags": ["raymarch", "dither", "volumetric", "volumetric", "raymarcher", "nebula", "slow", "multipass", "nonrealtime"], "likes": 5, "viewed": 439, "published": 3, "date": "1602371779", "time_retrieved": "2024-07-30T20:41:03.073488", "image_code": "// ^^^ Switch Between Buffer A and B ^^^\n// Buffer A is Rendering and Settings\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's In Progress Nebula Ray Marcher --- August 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tsKyRD\n// Fork of \"Yeetedly Slow Multipass Nebula\" by Zi7ar21. https://shadertoy.com/view/ttsfDj\n// 2020-10-10 22:30:29\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- 2020-09-08 19:37:55\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ^^^ Switch Between Buffer A and B ^^^\n// This is for Rendering and Settings\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 64\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 6.5\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 8\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.1\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again.\n#define DENSITY 1.0\n\n// Tiles, more means easier on the Hardware\n#if HW_PERFORMANCE==0\n#define TILES 15\n#else\n#define TILES 2 // Set to 1 if you have a computer that can handle it so it will render faster\n#endif          // (most shouldn't time out, except for like Intel HD Graphics)\n// So kindly made by LoicVDB uwu\n\n// Amount of distortion to apply\n#define DISTORT_AMOUNT 2.5\n\n// Oof ugly mess below watch out lol\n\nbool isKeyPressed(int KEY){\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\n// ##### NOISE #####\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// 2D Noise for Dithering\nfloat hash13(vec3 p3){\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < NUM_OCTAVES; ++i){\n        v += a * noise(x);\n        x = x * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// Colors\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float density = clamp(((fbm(raypos+(fbm(raypos)*DISTORT_AMOUNT))*16.0)-(fbm(raypos/2.0)*8.0))-pow(distance(vec3(0.0),raypos),2.0), 0.0, 1.0);\n    vec3 rgb = hsv2rgb(rgb2hsv(vec3(density))+vec3((fbm(raypos+(fbm(raypos))*DISTORT_AMOUNT)/1.35)+0.25, 0.85, 0.0));\n    return rgb;\n}\n\n// ##### RAYMARCHING #####\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin=0.0;\n    vec3 densityadd=vec3(0.0);\n    vec3 density=vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = (raydir*(hash13(vec3(coord, iFrame))+1.0))*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++) {\n        raypos = raypos + raydirmod;\n        densityadd = nebulanoise(raypos)*DENSITY;\n        density = vec3(density+densityadd);\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    \n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n    \n    // Camera Orientation\n    vec3 xdir = vec3(1.0,0.0,0.0);\n    vec3 ydir = vec3(0.0,1.0,0.0);\n    vec3 zdir = vec3(0.0,0.0,1.0);\n    float FOV = 1.0;\n    vec3 camerapos = vec3(0.0, 0.0, -8.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    vec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // LoicVDB: add the color and increase the sample count\n    fragColor += vec4(raymarched, 1.0);\n    if(isKeyPressed(32)){\n        fragColor.rgba = vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Buffer A and B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(acesFilm(color), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[950, 950, 1006, 1056, 1163]], "test": "untested"}
{"id": "wdKyRD", "name": "Solid Forces", "author": "wyatt", "description": "Solid forces resist torques in this fluid simulation. ", "tags": ["fluid"], "likes": 24, "viewed": 522, "published": 3, "date": "1602368498", "time_retrieved": "2024-07-30T20:41:03.846421", "image_code": "Main {\n    R = iResolution.xy;\n\tQ = texture(iChannel1,U/R);\n    vec4 \n        n = texture(iChannel1,(U+vec2(0,1))/R),\n        e = texture(iChannel1,(U+vec2(1,0))/R),\n        s = texture(iChannel1,(U-vec2(0,1))/R),\n        w = texture(iChannel1,(U-vec2(1,0))/R);\n    vec3 no = normalize(vec3(e.x-w.x,-n.x+s.x,.1));\n    Q.x = atan(.8*log(1.+Q.x));\n    Q = Q.x*(.8+0.6*abs(cos(.1+2.*Q.w+(1.+Q.y+5.*Q.z)*vec4(1,2,3,4))));\n    Q *= 0.9+0.5*texture(iChannel2,no);\n    Q = .9-1.2*Q;\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog (U,a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog (U,a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog2 (U,a,b,iChannel0,iChannel1);\n    \n    Q = a;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tR = iResolution.xy;\n    M = iMouse;\n    I = iFrame;\n    T = iTime;\n   \tvec4 a, b;\n    \n   \tprog2 (U,a,b,iChannel0,iChannel1);\n    \n    Q = b;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 M;\nfloat T;\nint I;\n#define A(U) texture(cha,(U)/R)\n#define B(U) texture(chb,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel2,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\nfloat signe (float x) {return atan(100.*x);}\nvoid prog (vec2 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = vec4(0); b = vec4(0);\n    float n = 0.;\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 aa = A(U+u), bb = B(U+u);\n        #define q 1.075\n\t\tvec4 w = clamp(vec4(aa.xy-0.5*q,aa.xy+0.5*q),U.xyxy - 0.5,U.xyxy + 0.5);\n        float m = (w.w-w.y)*(w.z-w.x)/(q*q);\n        aa.xy = 0.5*(w.xy+w.zw);\n        a += aa*bb.x*m;\n        b.x += bb.x*m;\n        b.yzw += bb.yzw*bb.x*m;\n        n += bb.x;\n    }\n    if (b.x>0.) {\n        a/=b.x;\n        b.yzw/=b.x;\n        //b.yzw = B(a.xy-a.zw).yzw;\n        //a.zw = mix(A(a.xy-a.zw).zw,a.zw,clamp(2.*n,0.,1.));\n    }\n}\nvoid prog2 (vec2 U, out vec4 a, out vec4 b, sampler2D cha, sampler2D chb) {\n\t\n    a = A(U); b = B(U);\n    vec2 f = vec2(0); float m = 0., p = 0., z = 0.;\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 aa = A(U+u), bb = B(U+u);\n        float l = dot(u,u);\n        if (l>0.) {\n            f += .1*0.125*b.x*(bb.x*(.2+bb.x*bb.y)-b.x*(.2+b.x*b.y))*u/l;\n            f += 0.125*b.x*(bb.z*bb.x-b.z*b.x)*vec2(-u.y,u.x)/l;\n            p += b.x*bb.x*dot(u/l,aa.zw-a.zw);\n            z += b.x*bb.x*(dot(vec2(-u.y,u.x)/l,aa.zw-a.zw));\n            m += bb.x;\n        }\n    }\n    if (m>0.) {\n       a.zw += f/m;\n       a.xy += f/m;\n       a.xy += f/m;\n       b.y += p/m;\n       b.z += z/m;\n    }\n    a.xy += a.zw;\n    \n    \n    // Boundaries:\n   \ta.w -= .003/R.y*signe(b.x);\n    if (a.x<10.) {a.z -= -.1;b.y*=0.9;}if (R.x-a.x<10.) {a.z -= .1;b.y*=0.9;}if (a.y<10.) {a.w -= -.1;b.y*=0.9;}if (R.y-a.y<10.) {a.w -= .1;b.y*=0.9;}\n    if (I<1||U.x<1.||R.x-U.x<1.||R.y-U.y<1.||R.x-U.x<1.) {\n    \ta = vec4(U,0,0);\n        b = vec4(0);\n        if (length(U-0.5*R) < 0.3*R.y&&length(U-0.5*R)>0.) {b.y = 0.;b.x = 1.;a.zw = -.01*normalize(U-0.5*R);}\n    \tb.w = 0.;\n    }\n    if (M.z>0.) {\n        float l = length(U-M.xy);\n        if (l<8.) {\n            b.x = 2.;\n            a.xy = U;\n            a.zw = .25*vec2(cos(.4*T),sin(.4*T));\n            b.w = .4+.4*sin(.1*T);\n        }\n    }\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wdKyzW", "name": "cityfolding", "author": "jj99", "description": "space folding", "tags": ["sdf", "folding", "city"], "likes": 12, "viewed": 389, "published": 3, "date": "1602362952", "time_retrieved": "2024-07-30T20:41:04.603397", "image_code": "// A quick shadertoy port of City Shader from MagicaVoxel - original by mode_vis / paulofalcao\n\n#define AA 2\n\nfloat box(vec3 r, vec3 p, vec3 size)\n{\n    r = abs(r-p) - size;\n    return max(max(r.x,r.y),r.z);\n}\n\nfloat sphere(vec3 r,vec3 p, float radius)\n{\n    return length(r-p) - radius;\n}\n\nfloat cylinder(vec3 r,vec3 p, float radius, float height)\n{\n    return max(length(r.xy-p.xy) - radius, abs(r.z-p.z)-height);\n}\nmat2 rot(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\n\nvec3 Folding(vec3 p)\n{\n    p *= -0.3;\n    \n    \n    float f = 2.65;\n    float ic = 0.0;\n    if (iMouse.z>0.5)\n    {\n        f+=sin(iTime*0.7);\n        ic  = sin(iTime*1.2)*0.1;\n    }\n    \n    \n    \n    float s=3.;\n\tfor(int i=0;i<10;i++)\n    {\n\t\tp.xy=abs(p).xy-s;\n        p.xy *= rot(f*0.1);\n\t    p.xz *= rot(ic*0.1);\n\t\ts=s/1.3;\n\t}\n    \n    return p;\n}\n\n\nfloat map( in vec3 p )\n{\n    \n\tfloat d = cylinder(p.xzy,vec3(0.0),4.75,1.0);\n    \n    p.yz*=rot(3.14*0.5);\n    \n    \n    p = Folding(p);\n    p += .05;\n    \n    vec3 pos1 = p;\n    pos1.x = abs(p.x);\n    vec3 pos2 = p;\n    \n    p.xy = abs(p.xy);\n    \n    \n\tfloat sdf = 0.;\n    sdf = box(p,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));\n\tsdf = min(sdf,box(p,vec3(0.08,0.08,0.0),vec3(0.05,0.05,0.004)));\n\tsdf = max(sdf,-box(p,vec3(0.08,0.08,0.0),vec3(0.045,0.045,0.0025)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));\n\n    vec3 b1 = p;\n\tb1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    float XYsize =  max(0.0,.5*p.z-0.02);\n    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.008);\n    sdf = min(sdf,box(b1,vec3(-0.0,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));\n    sdf = max(sdf,-box(b1,vec3(0.0,0.0,0.052),vec3(0.02+XYsize,0.02+XYsize,0.05)));\n    sdf = min(sdf,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.007)));\n\tsdf = min(sdf,box(b1,vec3(0.04,0.02,0.05),vec3(0.004,0.002,0.006)));\n    b1.xy *= 0.56;\n    b1 = abs(b1-0.02);\n\tsdf = max(sdf,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));\n\n    vec3 b0 = pos1;\n    b0.xy -= 0.08;\n\tb0=abs(b0);\n    sdf = min(sdf,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));\n    sdf = max(sdf,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n    float noise = 1.+0.05*length(sin(p*2000.0))+0.2*length(sin(p*900.0)); \n    b0.xy = abs(b0.xy);\n    b0.xy -= 0.02;\n    b0.xy = abs(b0.xy);\n    b0 -= vec3(0.01,0.01,0.02);\n    sdf = min(sdf,cylinder(b0,vec3(0.,0.,-0.015),0.001,0.009));\n    b0*=noise;\n    sdf = min(sdf,sphere(b0,vec3(0.),0.007));\n    sdf = min(sdf,sphere(b0,vec3(0.,0.,-.006),0.011));\n\n    vec3 b2 = p;\n    b2.xy -= 0.22;\n    b2 = abs(b2);\n\tsdf =  min(sdf,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.03,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.04),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.07),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.1),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.05),vec3(0.02,0.02,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.03),vec3(0.03,0.04,0.1)));\n\tsdf = max(sdf,-box(b2,vec3(0.,0.,0.025),vec3(0.03,0.025,0.1)));\n\n    vec3 b3 = pos2;\n    b3.xy -=  vec2(0.08,0.-0.08);\n    b3 = abs(b3);\n\tsdf = min(sdf,box(b3,vec3(0.,0.,0.053),vec3(0.045,0.045,0.008)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.033),vec3(0.04,0.04,0.033)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.0,0.064),vec3(0.04,0.04,0.006)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.033),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.033),vec3(0.051,0.01,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.053),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.053),vec3(0.051,0.01,0.003)));\n\tsdf = max(sdf,-box(b3,vec3(0.,0.016,0.003),vec3(0.051,0.01,0.003)));\n    sdf = min(sdf,box(b3,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\n    vec3 b4 = pos2;\n    b4.xy -= vec2(0.08,0.-0.22);\n    b4 = abs(b4);\n    sdf = min(sdf,box(b4,vec3(0.,0.,0.003),vec3(0.051,0.051,0.003)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));\n    sdf = min(sdf,box(b4,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b4,vec3(0.05,0.05,0.04),vec3(0.005,0.001,0.001)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.052,0.01,0.004)));\n    vec3 cone = b4;\n    vec3 stairs = b4;\n    sdf = min(sdf,cylinder(b4,vec3(0.008,0.008,0.015),0.0005,0.006));\n    cone.xy += (cone.z-0.021);\n    sdf = min(sdf,cylinder(cone,vec3(0.,0.,0.026),0.015,0.006));\n    stairs.xy += floor(stairs.z * 800.0)/800.0;\n\tsdf = min(sdf,box(stairs,vec3(0.008,0.008,0.0),vec3(0.02,0.02,0.01)));\n\n    vec3 b5 = pos2;\n    b5.xy -= vec2(-0.08,0.-0.22);\n\tb5 = abs(b5);\n    sdf = min(sdf,box(b5,vec3(0.014,0.0018,0.0),vec3(0.002,0.001,0.03)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.03),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.02,0.0018,0.032),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.024),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.04,0.01,0.0),vec3(0.01,0.016,0.01)));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.004),0.004));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.010),0.006));\n    sdf = min(sdf,box(b5,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b5,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\n    sdf = max(sdf,d);\n    \n    return sdf;\n}\n\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.125*iTime;\n\tvec3 ro = vec3( 6.0*cos(an), .8+sin(iTime)*0.4, 6.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 ldir = normalize(vec3(0.5,0.2,0.4));\n            \n            float dif = clamp( dot(nor,ldir), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.2,0.2)*amb + vec3(0.8,0.7,0.5)*dif;\n   \t\t\tcol+= pow(dif, 40.);\n\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 148, 148, 209], [211, 211, 254, 254, 289], [291, 291, 350, 350, 417], [418, 418, 437, 437, 489], [492, 492, 514, 514, 843], [846, 846, 870, 870, 5822], [5826, 5872, 5904, 5904, 6142]], "test": "untested"}
{"id": "tdKyzW", "name": "z IFS fractal 2", "author": "illus0r", "description": "z IFS fractal", "tags": ["ifs"], "likes": 3, "viewed": 264, "published": 3, "date": "1602362756", "time_retrieved": "2024-07-30T20:41:05.363365", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<6;i++){\n            uv = normalize(uv)/length(uv);\n            uv=abs(uv);\n            uv-=.6;\n            uv=uv*rot(t/float(i+1));\n            uv*=1.5;\n        }\n        col[c]=length(uv);\n        //col[c]=fract(uv.x*.5);\n\t    col[c]=step(.5,col[c]);\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 590]], "test": "untested"}
{"id": "wdKyRW", "name": "fracteye", "author": "Cyberfined", "description": "Fractal drawed with kifs", "tags": ["fractal", "kifs"], "likes": 3, "viewed": 319, "published": 3, "date": "1602360512", "time_retrieved": "2024-07-30T20:41:06.235035", "image_code": "mat2 rotM(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 randColor(vec2 co) {\n\tfloat r = noise(co*vec2(97.777, 123.7973));\n    float g = noise(co * vec2(r, 89.7897) + vec2(11.8, 97.6767));\n    float b = noise(vec2(r, g)*vec2(11.1317, 77.3443));\n    return vec3(r, g, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float fft = texture(iChannel0, vec2(-abs(uv.x), uv.y)).x;\n    uv *= .6 * (sin(fft)+1.);\n\n    uv = abs(uv);\n    uv.y -= 0.2;\n    uv.x -= 0.2;\n    \n    float a = (3./8.)*3.1415;\n    vec2 n = vec2(cos(a), sin(a));\n    \n    uv.y -= .25;\n    float scale = 1.;\n    for(int i = 0; i < 8; i++) {\n        uv.y += .25;\n        uv *= 2.;\n        scale *= 2.;\n        uv.y = -uv.y;\n        uv *= rotM(.1*iTime);\n\n        uv.x = abs(uv.x);\n        uv -= 2.*n*max(0., dot(uv,n));\n    }\n    \n\tfloat d = length(uv - vec2(0., clamp(uv.y, -.5, .5)));\n    vec3 col = vec3(smoothstep(1./iResolution.y, 0., d/scale));\n    col += randColor(.2*uv/scale + .1*iTime + .1*fft).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 78], [80, 80, 100, 100, 172], [174, 174, 194, 194, 403], [405, 405, 430, 430, 625], [627, 627, 682, 682, 1435]], "test": "untested"}
{"id": "WdKczD", "name": "Mine and good", "author": "lyurai", "description": "Whoa", "tags": ["fract"], "likes": 3, "viewed": 281, "published": 3, "date": "1602355616", "time_retrieved": "2024-07-30T20:41:07.096731", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<10;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+1));\n        }\n\t    col[c]= step(.5,fract(uv.x*20.));\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 477]], "test": "untested"}
{"id": "3dKczD", "name": "Not mine, but good", "author": "lyurai", "description": "Amazing kaleydoscop", "tags": ["fract"], "likes": 2, "viewed": 268, "published": 3, "date": "1602355423", "time_retrieved": "2024-07-30T20:41:07.946459", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<1;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+1));\n        }\n\t    col[c]=fract(uv.x*2.),fract(uv.x*2.),fract(uv.x*2.);\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 496]], "test": "untested"}
{"id": "WdKyzW", "name": "parametric_thingy_1", "author": "balkhan", "description": "trying to do a plane -> cylinder -> torus  transition", "tags": ["mouse", "parametric"], "likes": 4, "viewed": 302, "published": 3, "date": "1602353920", "time_retrieved": "2024-07-30T20:41:08.866000", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2 rotate(vec2 v, float alpha);\nfloat line(vec2 p1, vec2 p2, vec2 p, float thickness);\n\n#define SHOW_LINES\n\nvoid r(inout vec2 p, float a)\n{\n    p.xy = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2\tR = iResolution.xy;\n    vec2\tu = 1.*(f.xy-.5*R) / R.y;\n    \n    float md = 1e5;\n    for (float k = 0.; k <= NUM; k++)\n    for (float i = 0.; i <= NUM; i++)\n    {\n        vec2 coord = vec2(k-.5, i-.5) / R;\n        vec3 pos = texture(iChannel0, coord).xyz;\n    \tmd = min(md,\n                 length(u - pos.xy)-7./R.x\n                 );\n\t\t#ifdef SHOW_LINES\n\t\tmd = min(md, \n                 1.-line(pos.xy, \n                      texture(iChannel0, vec2(k-.5+1.*(k<NUM ? 1. : .0), i-.5)/R ).xy\n                      , u, 2./R.x)\n                 );\n        \n        md = min(md, \n                 1.-line(pos.xy, \n                      texture(iChannel0, vec2(k-.5-0., i-.5+1.*(i<NUM ? 1. : .0) )/R ).xy\n                      , u, 2./R.x)\n                 );\n        #endif\n        if (md < 0.001)\n            break;\n    }\n    o.xyz = texture(iChannel0, .25*f.xy/R.xy-vec2(.0, .0)).xyz;\n\to.x = smoothstep(.00052, .00735, .00625-md);\n    o = o.xxxx*1.;\n}\n\nvec2 rotate(vec2 v, float alpha)\n{\n\tfloat vx = v.x*cos(alpha)-v.y*sin(alpha);\n\tfloat vy = v.x*sin(alpha)+v.y*cos(alpha);\n\tv.x = vx;\n\tv.y = vy;\n\treturn v;\n}\n\nfloat line(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = -atan(lineVector.y,lineVector.x);\n\tp = rotate(p,angle);\n\t\n\tfloat dx = 0.0;\n\tif(p.x<0.0)\n\t\tdx = abs(p.x);\n\telse if(p.x>length(lineVector))\n\t\tdx = abs(p.x) - length(lineVector);\n\t\t\n\treturn ( thickness/(dx+abs(p.y)) );\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n* BUFFER A : Particle System\n* coord.x < NUM --> col = pos\n* coord.x > NUM --> col = vit\n*/\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n\n\nvoid r(inout vec2 p, float a)\n{\n    p.xy = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);\n}\n\nstruct\tparticle\n{\n    vec3\tpos;\n    vec3\tacc;\n    vec3\tvit;\n};\n\nvoid\tpos_plane(inout vec3 pos, vec2 ij)\n{\n    pos.x = -ij.x+7.5;\n    pos.y = 0.;\n    pos.z = -ij.y*1.+7.5;\n    pos /= 10.;\n}\n\nvoid\tpos_cyl(inout vec3 pos, vec2 ij)\n{\n    ij *= 6.28/NUM;\n    pos.x = cos(ij.x+1.5*3.0);\n    pos.y = sin(ij.x+1.5*3.0);\n    pos.z = -ij.y+7.5;\n    pos /= 10.;\n}\n\nvoid\tpos_tor(inout vec3 pos, vec2 ij)\n{\n    ij *= 6.28/NUM;\n    pos.y = (5.-cos(ij.x))*cos(-ij.y+1.57*2.)-0.;\n    pos.z = (5.-cos(ij.x))*sin(-ij.y+1.57*2.);\n    pos.x = sin(ij.x)+.0*ij.y*15.;\n    pos /= 10.;\n}\n\nvoid\tinit(inout particle part)\n{\n    part.acc = vec3(0.);\n\tpart.vit.xyz = vec3(0., 0., 0.);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    particle parts;\n    vec4\ttexture_buff;\n    vec2\tR = iResolution.xy;\n    o *= 0.;\n    vec2\tmous = (iMouse.xy-.0*R/2.) / R.xy;\n    if (f.x > NUM*2.+1. || f.y > NUM+1.)\n        discard;\n\n        texture_buff = texture(iChannel0, f/R.xy ).xyzw;\n        parts.pos.xyz = texture_buff.xyz;\n            vec3 m0, m1, m2;\n        pos_cyl(m0, f);\n        pos_plane(m1, f);\n        pos_tor(m2, f);\n        m1 = mix(m1, m0.xyz, .50+.50*sin(iTime*.4) );\n        parts.pos.xyz = mix(m1, m2.xyz, .50+.50*sin(iTime*.2) );\n            \n        r(parts.pos.xz, 3.51051*sin(1.57*1.+5.*((iMouse.x-R.x/2.)/R.x)));\n        r(parts.pos.yz, 3.51051*sin(1.57*3.5+5.*((iMouse.y-R.y/2.)/R.y)));\n\n\t    \to.xyz += \n                \t(f.x+.5 <= NUM +1. ? 1. :.0)\n\t                *\n\t           \t\tparts.pos.xyz\n           \t\t;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define NUM 20.\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKyzW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[225, 225, 256, 256, 322], [324, 324, 365, 365, 1326], [1328, 1328, 1362, 1362, 1483], [1485, 1485, 1540, 1540, 1812]], "test": "untested"}
{"id": "WdycRh", "name": "[inktober20] A Night of a Tooth.", "author": "iY0Yi", "description": "A shader drawing for inktober 2020 day8.\nMouse is enabled.\n#inktober2020day8", "tags": ["comic", "teeth", "inktober2020"], "likes": 18, "viewed": 533, "published": 3, "date": "1602351449", "time_retrieved": "2024-07-30T20:41:09.841392", "image_code": "/////////////////////////////////////////////////////////////////////////////////////////////\n//  .--.          _       .-.   .-.          .--.           .-----.          .-. .-.       //\n// : .; :        :_;      : :  .' `.        : .-'           `-. .-'         .' `.: :       //\n// :    :  ,-.,-..-. .--. : `-.`. .'   .--. : `;    .--.      : : .--.  .--.`. .': `-.     //\n// : :: :  : ,. :: :' .; :: .. :: :   ' .; :: :    ' .; ;     : :' .; :' .; :: : : .. : _  //\n// :_;:_;  :_;:_;:_;`._. ;:_;:_;:_;   `.__.':_;    `.__,_;    :_;`.__.'`.__.':_; :_;:_;:_; //\n//                   .-. :                                                                 //\n//                   `._.'                                                                 //\n//                                                                                         //\n//  \"A Night of a Tooth.\" by iY0Yi                                                         //\n//  https://www.shadertoy.com/view/WdycRh                                                  //\n//                                                                                         //\n//  Created by Atsushi Hashimoto 2020                                                      //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.    //\n//                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n// Effect pass\n\n//#define DEBUG_PASSES\n\n// https://www.shadertoy.com/view/3ssSz2\nfloat originalSigmoidContrast(float color, float contrast, float mid)\n{\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\n\n// Read data from BufA\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 readNormal(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack(data.y);\n}\n\nvec3 readAlbedo(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).xyz;\n}\n\nfloat readShadow(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return unpack4(data.x).w;\n}\n\nfloat readDepth(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    return data.w;\n}\n\nfloat readDiffuse(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.y;\n}\n\nfloat readSpecular(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z)*.5+.5;\n    return spec_diffuse_ao.x;\n}\n\nfloat readAO(vec2 uv)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3 spec_diffuse_ao = unpack(data.z);\n    return spec_diffuse_ao.z;\n}\n\nvec3 readSharpenNormal(in vec2 fragCoord, float strength)\n{\n    vec3 res =\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).x).xyz*2.-1.) *   9. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).x).xyz*2.-1.) *  -1. +\n    (unpack4(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).x).xyz*2.-1.) *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).y).xyz), res , strength);\n}\n\nfloat readSharpenSpecular(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).x *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).x *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).x *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).x, res , strength);\n}\n\nfloat readSharpenDiffuse(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).y *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).y *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).y *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).y, res , strength);\n}\n\nfloat readSharpenAO(in vec2 fragCoord, float strength)\n{\n    float res =\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1,-1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 0)), 0).z)*.5+.5).z *   9. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 0)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(-1, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 0, 1)), 0).z)*.5+.5).z *  -1. +\n    (unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2( 1, 1)), 0).z)*.5+.5).z *  -1.\n    ;\n    return mix((unpack(texelFetch(iChannel0, ivec2(fragCoord+vec2(0, 0)), 0).z)*.5+.5).z, res , strength);\n}\n\n\n// NPR effects\n// Maybe, you can better ways for these effects in somewhere else...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat dithering(float v, vec2 fragCoord)\n{\n    v=pow(v, 4.);\n    vec2 p = fragCoord;\n    p = mod(p.xx + vec2(p.y, -p.y), vec2(.1));\n    float res=0.;\n    vec2 coords = fragCoord;\n\n    float angle = dot(readSharpenNormal(fragCoord, 1.), vec3(0,0,1));\n\n    coords.xy*= mat2(cos(angle*PI+vec4(0,11,33,0)));\n    coords.y *= .75+.25*hash12(p);\n    float rand_ditherVal = fbm(coords*.75, 2);\n    const float paletteDist = 1.15;\n    res=v + (rand_ditherVal - .5) * paletteDist;\n    res=smoothstep(0.1,1.,res);\n    res=saturate(floor(res*6.)/5.);\n\n    return res;\n}\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2)\n{\n    vec2 difN = abs(nlm1.xy - nlm2.xy);\n    return smoothstep(.41, .3, difN.x + difN.y);\n}\nfloat getOutline(vec2 fragCoord)\n{\n    vec2 coord = fragCoord;\n    vec3 offset = vec3(1, -1, 0) * .5;\n    float edge = 1.0;\n    edge *= calcEdge(readNormal(coord+offset.xx), readNormal(coord+offset.yy));\n    edge *= calcEdge(readNormal(coord+offset.xy), readNormal(coord+offset.yx));\n    edge *= calcEdge(readNormal(coord+offset.zy), readNormal(coord+offset.zx));\n    edge *= calcEdge(readNormal(coord+offset.yz), readNormal(coord+offset.xz));\n    return edge;\n}\n\nfloat getShadowEdge( vec2 fragCoord )\n{\n    vec2 coord = fragCoord;\n    float sha = readShadow(coord);\n    sha -= .5;\n    sha = abs(sha);\n    sha = smoothstep(.1,.2,sha);\n    return sha;\n}\n\nfloat getDottedShadow(vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    uv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n    uv = mod(uv*.3, 1.);\n    float res = 0.;\n    float shadow = readShadow(fragCoord);\n    shadow = saturate(1. - shadow*1.+ .01*readAO(fragCoord));\n    res = smoothstep(shadow, shadow+.1, pow(length(uv-.5), 2.));\n    return res;\n}\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nfloat hatching(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    v.y *= iResolution.y/iResolution.x;\n    vec3 n = readNormal(fragCoord);\n\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n    vec2 Res = iResolution.xy;\n    float na = (1.-n.z)*PI*.0125 + angle;\n    R(v, na);\n    v.y = mod(v.y*Res.y/tickness, 1.*(n.z*.5));\n\n    float shading = readSharpenDiffuse(fragCoord, 2.);\n\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n\n    shading = shading*.8+.2*readAO(fragCoord);\n    \n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    shading *= 1.35;\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.0, shading+.9, 1.-abs(v.y-.5)*2.);\n    line = saturate(line+shading);\n    return line;\n}\n\nfloat getHatching(vec2 fragCoord)\n{\n    if(readDepth(fragCoord)>.9)\n    return 1.;\n\n    float ln = 1.;\n    const float mul = 1.;\n        ln*= pow(hatching(fragCoord, 3.5*mul, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatching(fragCoord, 3.5*mul, .4, -1.4, 1.4, false), 50.5);\n    return ln;\n}\n\nfloat hatchingSpecular(vec2 fragCoord, float tickness, float angle, float dark, float light, bool centered)\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    vec3 n = readNormal(fragCoord);\n    if(length(n)<.1)\n        return -1.;\n    float f = smoothstep(.1, 1., saturate(-n.y)*saturate(-n.x));\n\n    v *= mat2(cos(n.z*PI*.25 + angle + vec4(0, 11, 33, 0)));\n    v.y = mod(v.y*iResolution.y/tickness, 1.);\n    v.y += fbm(fragCoord.yx*.05, 2)*.0005;\n\n    float shading = readSpecular(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = smoothstep(dark, light, pow(shading, 1.8));\n    if(centered)\n    {\n        shading = (shading-.5)*2.;\n        shading = saturate(shading);\n        shading = abs(shading-.5)*2.;\n    }\n    else\n        shading = saturate(shading-.5)*2.;\n    \n\tshading = originalSigmoidContrast(shading*.98+.03*saturate(fbm(fragCoord*.025, 2)), noise(fragCoord*.02)*noise(fragCoord.yx*.03)*.5, .7);\n    shading = 1.-saturate(shading*.55);\n    float face = smoothstep(.5, 1.8, saturate(-n.y)*saturate(-n.x));\n    float line = smoothstep(-.3, shading+.5, 1.-abs(v.y-.5)*2.);\n    line = saturate(pow(line+shading+face, 5.));\n\n    return line;\n}\n\nfloat getHatchingSpecular(vec2 fragCoord)\n{\n    float ln = 1.;\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, -.4, -1.4, 1.4, false), 50.5);\n        ln*= pow(hatchingSpecular(fragCoord, 3.5, .4, -1.4, 1.4, false), 50.5);\n    return 1.-ln;\n}\n\n// https://www.shadertoy.com/view/MdjBRy\nvec3 saturation( vec3 color, float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n\n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n\n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n\n    return mat3( red, green, blue) * color;\n}\n\nvec3 hue(in vec3 col, in float Shift)\n{\n    vec3 P = vec3(0.55735) * dot(vec3(0.55735), col);\n    vec3 U = col - P;\n    vec3 V = cross(vec3(0.55735), U);    \n    col = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;\n    return col;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    vec3 col = vec3(.8, .77, .7);\n\n    float shading = readDiffuse(fragCoord);\n    shading *= readShadow(fragCoord);\n    shading = shading*.7+.3*readAO(fragCoord);\n    shading = smoothstep(.3, 1., shading);\n\n    float contrast = 8.8;\n    float midpoint = .5;\n    shading = originalSigmoidContrast(shading, contrast, midpoint);\n    shading = saturate(shading);\n\tif(readDepth(fragCoord)>.9)\n        shading = 0.;\n    \n    col+=.05*dithering((smoothstep(.95,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.97,1.,shading)), fragCoord);\n    col+=.05*dithering((smoothstep(.99,1.,shading)), fragCoord);\n    col*=.65+.25*shading;\n    col+=fbm(fragCoord*.5, 3)*.05;\n    col*= getHatching(fragCoord);\n    \n    col *= getShadowEdge(fragCoord);\n    col *= getDottedShadow(fragCoord);\n    col *= .4 + .6*(readShadow(fragCoord)*.8+.2*readAO(fragCoord));\n\tif(length(col)<.01) col += (1.-getOutline(fragCoord))*.25;\n    else col *= getOutline(fragCoord);\n\n    vec3 albedo = readAlbedo(fragCoord);\n    col*= albedo;\n\n    float spec = readSharpenSpecular(fragCoord, 1.5)*readShadow(fragCoord);\n    if(spec>.01)\n    {\n    \tcol+=dithering(spec, fragCoord);\n    \tcol+=getHatchingSpecular(fragCoord);\n    }\n    col*=.8+.2*pow(1.-smoothstep(.0, 2., readDepth(fragCoord)), 3.);\n\n    col*= dithering(noise(fragCoord*.18+iTime*5.)+noise(fragCoord*.15-iTime*5.)+.8, fragCoord);\n    col+= (1.-dithering((1.-noise(fragCoord*.3+iTime*5.)*noise(fragCoord*.1-iTime*5.))+.8, fragCoord))*.1;\n\n    col *= vec3(.5+.5*smoothstep(.8, .5, readDepth(fragCoord)));\n\n    col = hue(col, s2u(sin(iTime))*.8 + ((distance(readAlbedo(fragCoord),AMB_COL)<.01)?uv.y*.2:length(uv)*.2));\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n    col*=dithering(pow(1.4-length(uv)*.5, .2), fragCoord);\n    \n    col = pow(col, vec3(.4545));\n    col+=.05;\n    \n    fragColor = vec4(col, 1.);\n    \n#ifdef DEBUG_PASSES\n    if(iFrame==2)\n    fragColor.xyz = vec3(readDiffuse(fragCoord));\n    if(iFrame==3)\n    fragColor.xyz = vec3(readShadow(fragCoord));\n    if(iFrame==4)\n    fragColor.xyz = vec3(readSharpenSpecular(fragCoord, 1.5));\n    if(iFrame==5)\n    fragColor.xyz = vec3(readDepth(fragCoord));\n    if(iFrame==6)\n    fragColor.xyz = vec3(readAO(fragCoord));\n    if(iFrame==7)\n    fragColor.xyz = readAlbedo(fragCoord);\n    if(iFrame==8)\n    fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    if(iFrame==9)\n    fragColor.xyz = vec3(getOutline(fragCoord));\n    if(iFrame==10)\n    fragColor.xyz = vec3(getShadowEdge(fragCoord));\n    if(iFrame==11)\n    fragColor.xyz = vec3(getDottedShadow(fragCoord));\n    if(iFrame==12)\n    fragColor.xyz = vec3(getHatching(fragCoord));\n    if(iFrame==13)\n    fragColor.xyz = vec3(getHatchingSpecular(fragCoord));\n#endif\n//fragColor.xyz = readNormal(fragCoord)*.5+.5;\n    fragColor.w = 1.;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Common\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 10.0\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n#define AMB_COL vec3(0.25, 0.2, 0.3550)*.5\n#define MAT_TEETH vec3(0.635, 0.700, 0.502)\n#define MAT_FLOOR vec3(0.887, 0.563, 0.4112)\n#define MAT_BLOOD vec3(.6,.255,.35)\n\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define TAU (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n\n// Data Paker/Unpacker\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack(x) unpackSnorm3x10(floatBitsToUint(x))\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n\n//  1 out, 1 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_b_code": "vec3 ro = vec3(0), rd = vec3(0);\nvec3 camup = vec3(0), col = vec3(0);\nvec3 ldir = normalize(vec3(.8, 1., -.1));\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec2 rot2(vec2 p,float r){\n    vec2 q = p;\n    R(q, r);\n    return q;\n}\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    float h = max(r-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/r;\n}\n\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b)\n{\n    float res = max(-a.x, b.x);\n    return (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r)\n{\n    vec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n    float res = min(-r, max(b.x, -a.x))+length(u);\n    vec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n    return vec4(res, m);\n}\n\n\nfloat pMirror(float x, float k){\n    return sqrt(x * x + k);\n}\n\n\n// Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvec4 sdTeeth(vec3 p){\n    float bsd = length(p+vec3(0, -0.25, 0)), bsr=0.25;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n    \n\tvec3 q = p;\n    q.x+=u2s(fbm(q.yz*10., 1))*.015;\n    q.z+=u2s(fbm(q.xy*10., 1))*.015;\n    q.y+=u2s(fbm(q.xz*10., 1))*.015;\n    \n    float mask0 = smoothstep(.01, .05, length(q.xz));\n    float mask1 = smoothstep(.15, .0, length(q.xz));\n    float mask = mask0*mask1;\n    q.y-=smoothstep(.01, 1., fbm(vec2(atan(q.z,q.x), length(q.xz))*2.,1))*.05*mask;\n    q.y+=smoothstep(.2, .0, length(q.xz))*.1;\n\n\tq.z = pMirror(q.z, 0.0025);\n\tq.x = pMirror(q.x, 0.0040);\n\n\tfloat d = sdEllipsoid(rot(q+vec3(-0.1135, -0.4147, -0.1053), vec3(-0.3432, 0.2904, -0.1973)), vec3(0.1037, 0.1000, 0.1086));\n\td = fOpUnionSmooth(sdEllipsoid(rot(q+vec3(-0.1324, -0.0919, -0.1066), vec3(0.0000, 0.0000, 0.1114)), vec3(0.0337, 0.1000, 0.0337)), d, 0.0602);\n\td = fOpUnionSmooth(sdEllipsoid(rot(q+vec3(-0.1058, -0.2846, -0.1094), vec3(0.0000, 0.0000, 0.1352)), vec3(0.0559, 0.0968, 0.0773)), d, 0.0731);\n\treturn vec4(d, MAT_TEETH);\n}\n\nvec4 sdBlood(vec3 p){\n    float bsd = length(p+vec3(0, 0, 0)), bsr=0.25;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\n    vec3 bp = p;\n    bp.y += .05*pow(length(p.xz)*4.7, 1.5);\n    bp.y += smoothstep(.0, 1., pow( u2s(fbm(p.xz*.2+1. ,1)), .5 )-.5 )*.05;\n    bp.y -= smoothstep(-.1, 1., pow( (fbm(p.xz*20. ,1)), .5 ) )*.05;\n    \n    bp.y = pMirror(bp.y, 0.00025);\n    bp.y += .0025;\n    \n    float d = sdPlane(bp);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0.0, -0.02, 0.0), vec3(0.08, 0.025, 0.08)*2.), d, .1);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0.1, -0.02, 0.1), vec3(0.08, 0.0125, 0.08)*2.), d, .1);\n\td = fOpUnion(sdEllipsoid(p+vec3(-0.2, -0.005, -0.3), vec3(0.08, 0.025, 0.08)*.5), d);\n    d = fOpUnion(sdEllipsoid(p+vec3(0.3, -0.01, -.5), vec3(0.08, 0.035, 0.08)*.35), d);\n    d = fOpUnion(sdEllipsoid(p+vec3(0.17, -0.005, .46), vec3(0.08, 0.035, 0.08)*.25), d);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0., 0., .36), vec3(0.06, 0.06, 0.06)*.05), d, .03);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0., 0., -.27), vec3(0.06, 0.06, 0.06)*.05), d, .03);\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(0., 0., -.29), vec3(0.06, 0.06, 0.06)*.05), d, .03);\n    \n    \n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(-0.09, -0.246, -.28), vec3(0.06, 0.06, 0.06)*.0015), d, .01); //drop\n    d = fOpUnionSmooth(sdEllipsoid(p+vec3(-0.09, -0.21, -.28), vec3(0.06, 0.06, 0.06)*.38), d, .035); //drop\n    \n    return vec4(d, MAT_BLOOD);\n}\n\nvec4 sdScene(vec3 p)\n{\n    vec4 res = sdBlood(p);\n\tres = v4OpUnion(sdTeeth(rot(p+vec3(-.0, -.19, -.3), vec3(PI*.39, -.5, PI*.45))), res);\n\tif(length(p.xz)<1.)res = v4OpUnion(vec4(sdPlane(p), MAT_FLOOR), res);   \n    return res;//vec4(sdPlane(p), MAT_FLOOR);//res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = MIN_DIST;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        res.x*=.5;\n        m = res.yzw;\n        if (abs(res.x) < MIN_DIST)break;\n        d += res.x;\n        if (d >= MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    }\n    if(d>MAX_DIST) return vec4(MAX_DIST, MAT_VOID);\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o)\n{\n    float mint=.001;\n    float maxt=5.;\n    float k = 30.;\n    float res = 1.;\n    // for( float t=mint; t < maxt; )\n    float ph = 1e20;\n    float t=mint;\n    for( int i=ZERO; i < 50; i++)\n    {\n        float h = sdScene(o + ldir*t).x;\n        h *= .5;\n        if(abs(h)<MIN_DIST) return 0.;\n\n        res = min( res, k*h/t);\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y));\n        ph = h;\n        t += h;\n\n        if(t >= maxt) break;\n    }\n    return smoothstep(.5, .51, res);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\nfloat swTri(float v){\n    return asin(sin(v*PI))*2./PI;\n}\n\nvec2 uv=vec2(0);\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    ab.x*=1.5; // sharpen\n    p = abs(p);\n    p.y+=ab.y*.5; // sharpen\n    if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\nfloat sdType(vec2 p){\n\tfloat d = sdEllipse(rot2(p+vec2(-0.0000, -0.0000), 0.0000), vec2(0.0316, 0.0062));\n\td = min(sdEllipse(rot2(p+vec2(-0.0000, 0.0511), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0020, 0.1048), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0743, 0.0020), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0816, 0.0564), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0756, 0.1035), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1626, 0.0597), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1632, 0.1028), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1652, 0.0046), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1227, 0.0504), -0.9931), vec2(0.0494, 0.0071)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2262, 0.0551), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2269, 0.1048), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2243, 0.0040), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2647, 0.0372), -0.8361-1.5854), vec2(0.0352, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2853, 0.0066), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2826, 0.0796), 0.6562-1.5854), vec2(0.0247, 0.0087)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2966, 0.1048), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3666, 0.0571), -1.5854), vec2(0.0500, 0.0077)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3672, 0.1068), 0.0000), vec2(0.0316, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3646, 0.0060), 0.0000), vec2(0.0479, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0166, 0.1523), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0179, 0.2538), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0634, 0.2038), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(0.0096, 0.2037), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3208, 0.0212), -1.5854), vec2(0.0130, 0.0049)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.4149, 0.0179), -1.5854), vec2(0.0130, 0.0049)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1314, 0.1510), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1373, 0.2525), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1098, 0.2023), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1466, 0.1981), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1708, 0.1765), -1.5854), vec2(0.0185, 0.0055)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1828, 0.2296), -1.5854), vec2(0.0210, 0.0055)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2461, 0.1497), 0.0000), vec2(0.0412, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2455, 0.2512), 0.0000), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2179, 0.2010), -1.5854), vec2(0.0595, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2475, 0.1968), 0.0000), vec2(0.0231, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2846, 0.1683), -1.5854), vec2(0.0130, 0.0049)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2860, 0.2432), 0.0000), vec2(0.0066, 0.0099)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3437, 0.1510), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3251, 0.2525), 0.0000), vec2(0.0201, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3221, 0.2023), -1.5854), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3589, 0.1981), 0.0000), vec2(0.0355, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3832, 0.1765), -1.5854), vec2(0.0220, 0.0061)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3951, 0.2296), -1.5854), vec2(0.0330, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3934, 0.2519), 0.0000), vec2(0.0201, 0.0062)), d);\n\t\n    d = min(sdEllipse(rot2(p+vec2(0.0023, 0.3108), -0.7510-1.5854), vec2(0.0352, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0170, 0.3650), -0.8361-1.5854), vec2(0.0598, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0342, 0.3086), -2.1717-1.5854), vec2(0.0352, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.0151, 0.4064), 0.0000), vec2(0.0413, 0.0062)), d);\n\t\n    d = min(sdEllipse(rot2(p+vec2(-0.1614, 0.3165), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1302, 0.3733), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1612, 0.3752), -2.2890), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.1236, 0.3259), -2.2690), vec2(0.0343, 0.0074)), d);\n    \n\td = min(sdEllipse(rot2(p+vec2(-0.2321, 0.3136), -0.7510-1.5854), vec2(0.0352, 0.0067)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2515, 0.3678), -0.6709-1.5854), vec2(0.0598, 0.0084)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2686, 0.3114), -2.1717-1.5854), vec2(0.0352, 0.0067)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.2496, 0.4092), 0.0000), vec2(0.0413, 0.0062)), d);\n    \n\td = min(sdEllipse(rot2(p+vec2(-0.3870, 0.3221), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3480, 0.3749), -0.8465), vec2(0.0413, 0.0062)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3907, 0.3780), -2.2890), vec2(0.0343, 0.0074)), d);\n\td = min(sdEllipse(rot2(p+vec2(-0.3531, 0.3286), -2.2690), vec2(0.0343, 0.0074)), d);\n\treturn d;\n}\n\nvec3 ord = vec3(0);\nvec3 nlm = vec3(0);\nfloat first_t = 0.;\nvec3 albedo = vec3(0);\nfloat spec = 0.;\nfloat depth = 0.;\nfloat ao = 1.;\nfloat shdw = 1.;\nfloat diffuse = 0.;\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    albedo = hit.yzw;\n\n\n    vec3 n = normal(p);\n\n    vec3 offset = n * .005;\n    float vol = 1.0;\n    shdw=ao=1.;\n\n    vec3 res_col = vec3(1);\n\n    if (hit.x>=MAX_DIST)\n    {\n        nlm = vec3(0);\n        res_col=vec3(0);\n        albedo = AMB_COL;\n        shdw = pow(1.-(rd.y)-.1,2.);\n        spec = 0.;\n        depth = 1.;\n    }\n    else\n    {\n\n        // Camera localized normal\n        vec3 up = camup;\n        vec3 side = cross(rd, up);\n        nlm.x = dot(n+offset,  side);\n        nlm.y = dot(n+offset,  up);\n        nlm.z = dot(n+offset,  -rd);\n\n        float light1 = dot(n+offset,  ldir)*.5+.5; // Half-Lanbert model\n        float light2 = dot(n+offset, -ldir)*.5+.5;\n        shdw = shadow(p+offset);\n        \n        diffuse = light1;\n\n        ao = ambientOcclusion(p+n*0.01, n, .5, 2.);\n        ao += ambientOcclusion(p+n*0.01, n, .01, .2);\n        ao += ambientOcclusion(p+n*0.01, n, 2., 2.);\n        ao += ambientOcclusion(p+n*0.01, n, 5., 2.);\n        ao = smoothstep(0., 4., ao);\n        ao = pow(ao, .2);\n\n        const float thresh = .01;\n        if(distance(albedo, MAT_TEETH) < thresh)\n        {\n            spec = specular(p+offset, n, ldir, 30.);\n            //diffuse = .0;\n            if(p.x<0.)\n            {\n                float type= 1.-step(.05, 1.0 - exp(-8.0*abs(sdType((p.zy*vec2(-1,1)-vec2(-.31,.9)*.3)*3.))));\n                nlm.x+=type;\n                //nlm.y-=type;\n            }\n        }\n        \n        if(distance(albedo, MAT_BLOOD) < thresh)\n        {\n            spec = specular(p+offset, n, ldir, 50.);\n        }\n        \n        \n        if(distance(albedo, MAT_FLOOR) < thresh)\n        {\n            // Floor\n            vec2 uv = vec2(p.z, p.y);\n\n            vec3 q = p;\n\n            uv.x = q.x;\n            uv.y = q.z;\n            uv*=.5;\n\n            int offset = int(uv.x)%2;\n            vec2 ratio = vec2(1,4);\n            float gridGap = 0.001;\n            if(offset==0)uv.y+=ratio.y*.5;\n\n            vec2 id = floor(uv/ratio);\n            uv = mod(uv, ratio)-ratio*.5;\n\n            float d =sdBox(uv, ratio*.5-gridGap);\n            if(noise(uv*vec2(2000,1)*5.*id)<.75)\n                diffuse *= step(.05, 1.0 - exp(-8.0*abs(d)));\n            if(noise(uv*vec2(1500,20))<.75)\n            {\n                uv.y+=fbm(uv*30., 2)*.025;\n                uv *= mat2(cos(noise(uv*vec2(5,1)+id)*PI*.3+vec4(0,11,33,0)));\n                diffuse *= smoothstep(.4, .42, abs(sin(uv.x*40.)));\n                \n                \n            }\n            if(noise(uv*vec2(100,20))<.75)\n            {\n                diffuse+=noise(uv*vec2(2000,1))*.25;\n            }\n            \n        }\n        depth = distance(ro, p)/MAX_DIST;\n    }\n}\n\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv)\n{\n    const float pY = .35;\n    const float cL = 1.5;\n    const vec3 forcus = vec3(0,.18,0);\n    const float fov = .33;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,pY,0);\n    pos.xz = vec2(.7,-.7)*cL;\n    if(iMouse.z>.5)\n        pos.xz = vec2(sin(iMouse.x/iResolution.x*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcamup = up;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ro = pos;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   // Setup UV...\n    uv = fragCoord.xy / iResolution.xy;\n    float ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n    uv = (uv*2.-1.)*ml;\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n\n    render();\n    uv.y+=.05;\n    uv.y*=1.3;\n    col.x *= 1.-depth*1.5;\n    vec3 spec_diffuse_ao = vec3(spec, diffuse, ao)*2.-1.;\n    fragColor = vec4(pack4(vec4(albedo, shdw)), pack(nlm), pack(spec_diffuse_ao), depth);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdycRh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1545, 1586, 1657, 1657, 1970], [1972, 2067, 2093, 2093, 2175], [2177, 2177, 2203, 2203, 2290], [2292, 2292, 2319, 2319, 2404], [2406, 2406, 2432, 2432, 2506], [2508, 2508, 2536, 2536, 2670], [2672, 2672, 2701, 2701, 2835], [2837, 2837, 2860, 2860, 2988], [2990, 2990, 3049, 3049, 3992], [3994, 3994, 4056, 4056, 4977], [4979, 4979, 5040, 5040, 5961], [5963, 5963, 6019, 6019, 6940], [6943, 7099, 7141, 7141, 7656], [7658, 7658, 7696, 7696, 7787], [7788, 7788, 7822, 7822, 8250], [8252, 8252, 8291, 8291, 8440], [8442, 8442, 8481, 8481, 8782], [8832, 8832, 8933, 8933, 9822], [9824, 9824, 9859, 9859, 10122], [10124, 10124, 10233, 10233, 11291], [11293, 11293, 11336, 11336, 11536], [11538, 11579, 11628, 11628, 12004], [12006, 12006, 12045, 12045, 12246], [12248, 12320, 12377, 12377, 15224]], "test": "untested"}
{"id": "WsVcRD", "name": "Blue to orange", "author": "lyurai", "description": "Transistion from blue to orange", "tags": ["color"], "likes": 2, "viewed": 232, "published": 3, "date": "1602350031", "time_retrieved": "2024-07-30T20:41:10.603355", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord.xy/iResolution.xy;\n    //float col = uv.y;\n    //col = 1. - col;\n    //col = step(0.5, col);\n    float col = step(sin(iTime*2.)/2.+.5, fragCoord.x/iResolution.x);\n    fragColor = vec4(vec3(col), 1.);\n    if(col==0.0){\n        fragColor = vec4(vec3(37.,36.,122.)/255.,1.);\n    }\n    else\n    {\n        fragColor = vec4(vec3(255.,107.,0.)/255.,1.);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 176, 443]], "test": "untested"}
{"id": "WdVcRD", "name": "bad trip", "author": "Cyberfined", "description": "Bad trip illustration with kaleidoscope", "tags": ["kaleidoscope", "trip"], "likes": 1, "viewed": 281, "published": 3, "date": "1602349678", "time_retrieved": "2024-07-30T20:41:11.364321", "image_code": "mat2 rotM(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 randColor(vec2 co) {\n\tfloat r = noise(co*vec2(97.777, 123.7973));\n    float g = noise(co * vec2(r, 89.7897) + vec2(11.8, 97.6767));\n    float b = noise(vec2(r, g)*vec2(11.1317, 77.3443));\n    return vec3(r, g, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    float a = (5./6.)*3.1415;\n    vec2 n = vec2(cos(a), sin(a));\n    float fft = cos(texture(iChannel0, vec2(-abs(uv.x), uv.y)).x);\n    \n    uv.x -= .5;\n    float scale = 1.;\n    for(int i = 0; i < 9; i++) {\n        uv.x += .5;\n        uv *= 3.;\n        scale *= 3.;\n        uv = abs(uv);\n        uv *= rotM(.1*iTime + .5*fft);\n        uv.x -= 1.5;\n        uv -= 2.*n*min(0., dot(uv, n));\n    }\n\n    vec3 col = randColor(uv/scale*0.5+.1*iTime + .2*fft);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24114, "src": "https://soundcloud.com/crocoloko/sex-drugs-goa-trance", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 78], [80, 80, 100, 100, 172], [174, 174, 194, 194, 403], [405, 405, 430, 430, 625], [627, 627, 682, 682, 1272]], "test": "untested"}
{"id": "WsKczW", "name": "parametric_thingy_0", "author": "balkhan", "description": "http://paulbourke.net/geometry/toroidal/", "tags": ["klein", "parametric"], "likes": 7, "viewed": 302, "published": 3, "date": "1602345628", "time_retrieved": "2024-07-30T20:41:12.118304", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nfloat\tline(vec2 p1, vec2 p2, vec2 p, float thickness);\nvoid\tr(inout vec2 p, float a);\n\n#define SHOW_LINES\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2\tR = iResolution.xy;\n    vec2\tu = 1.*(f.xy-.5*R) / R.y;\n    \n    float md = 1e5;\n    for (float k = 0.; k <= NUM; k++)\n    for (float i = 0.; i <= NUM; i++)\n    {\n        vec2 coord = vec2(k-.5, i-.5) / R;\n        vec3 pos = texture(iChannel0, coord).xyz;\n    \tmd = min(md,\n                 length(u - pos.xy)-5./R.x\n                 );\n        // make 2 lines from each point drew, from point to his bottom and point to his right\n\t\t#ifdef SHOW_LINES\n\t\tmd = min(md, \n                 1.-line(pos.xy, \n                      texture(iChannel0, vec2(k-.5+1., i-.5)/R ).xy\n                      , u, 1./R.x)\n                 );\n        md = min(md, \n                 1.-line(pos.xy, \n                      texture(iChannel0, vec2(k-.5-0., i-.5+1.)/R ).xy\n                      , u, 1./R.x)\n                 );\n        #endif\n    }\n    //o.xyz = texture(iChannel0, .25*f.xy/R.xy-vec2(.0, .0)).xyz;\n    o.x = smoothstep(.03, -.01, md);\n    o = o.xxxx;\n//    o.xyz = vec3(step(md, .00001));//*step(-1.752500001, md);    \n}\n\nfloat line(vec2 p1, vec2 p2, vec2 p, float thickness)\n{\n\tp -= p1;\n\tvec2 lineVector = p2-p1;\n\t\t\n\tfloat angle = atan(lineVector.y,lineVector.x);\n\tr(p,angle);\n\t\n\tfloat dx = 0.0;\n\tif(p.x<0.0)\n\t\tdx = abs(p.x);\n\telse if(p.x>length(lineVector))\n\t\tdx = abs(p.x) - length(lineVector);\n\t\t\n\treturn ( thickness/(dx+abs(p.y)) );\n}\n\nvoid r(inout vec2 p, float a)\n{\n    p.xy = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n/*\n* BUFFER A : Particle System\n* coord.x < NUM --> col = pos\n* coord.x > NUM --> col = vit\n*/\n\nvoid r(inout vec2 p, float a)\n{\n    p.xy = vec2(cos(a)*p.x+sin(a)*p.y, -sin(a)*p.x+cos(a)*p.y);\n}\n\nstruct\tparticle\n{\n    vec3\tpos;\n    vec3\tacc;\n    vec3\tvit;\n};\n\nvoid\tpos_klein(inout vec3 pos, vec2 ij)\n{\n    float u,v;\n    ij *= 6.28/NUM; // 2.*PI/NUM\n    u = ij.x;\n    v = ij.y;\n    float r = 4.*(1.-cos(u)*.5);\n    if (u >= .0 && u < 3.14)\n    \tpos.x = 6.*cos(u)*(1.+sin(u)) + r*cos(u)*cos(v);\n    else\n        pos.x = 6.*cos(u)*(1.+sin(u))+r*cos(v+3.14);\n    if (u >= .0 && u < 3.14)\n    \tpos.y = 16.*sin(u) + r*sin(u)*cos(v);\n    else\n        pos.y = 16.*sin(u);\n    pos.z = r*sin(v);\n    pos /= 42.;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    o -= o;\n    particle parts;\n    vec4\ttexture_buff;\n    vec2\tR = iResolution.xy;\n    vec2\tmous = (iMouse.xy-.0*R/2.) / R.xy;\n    if (f.x > NUM*2.+1. || f.y > NUM+1.)\n        discard;\n        texture_buff = texture(iChannel0, f/R.xy ).xyzw;\n        parts.pos.xyz = texture_buff.xyz;\n    \tif (iChannelResolution[0].x < 1. || iFrame < 10 || R.x != texture_buff.w)\n\t        pos_klein(parts.pos.xyz, f);\n    r(parts.pos.xz, -iTimeDelta);\n    r(parts.pos.yz, +iTimeDelta*.125);\n    //        r(parts.pos.xz, 3.5*sin(1.57*1.+5.*((iMouse.x-R.x/2.)/R.x)));\n//        r(parts.pos.yz, 3.5*sin(1.57*3.5+5.*((iMouse.y-R.y/2.)/R.y)));\n\n//      texture_buff = texture(iChannel0, ((vec2(1.,1.)*f-0.+vec2(1.+1.0*NUM*1.+.0, .0))/R.xy) ).xyzw;\n//    \tparts.vit.xyz = texture_buff.xyz;\n//      parts.vit.xyz += parts.acc.xyz;\n//\t    parts.pos += parts.vit;\n    o.w = R.x;\n\t    \to.xyz += \n                \t(f.x+.5 <= NUM +1. ? 1. :.0)\n\t                *\n\t           \t\tparts.pos.xyz\n           \t\t;\n    /*\n\t\t\to.xyz += \n\t                (f.x+.5 > NUM +1. ? 1. :.0)\n\t                *\n\t\t            parts.vit.xyz\n\t            ;\n    */\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Care, NUM = NUM*NUM\n#define NUM 15. // 225 points should be ok for most gpu I hope\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKczW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[222, 222, 263, 263, 1287], [1289, 1289, 1344, 1344, 1606], [1608, 1608, 1639, 1639, 1705]], "test": "untested"}
{"id": "WdKczW", "name": "Segment Tracing (SDF Only)", "author": "yuchengzhong", "description": "gpu version of https://diglib.eg.org/bitstream/handle/10.1111/cgf13951/v39i2pp545-554.pdf?sequence=1&isAllowed=y\ndistance falloff is cutted in this version.\nThe bound of    gradient d(delta(e)) dot u   is estimated by 3 points.", "tags": ["raytracing", "metaball", "tracing", "segment"], "likes": 45, "viewed": 3093, "published": 3, "date": "1602344393", "time_retrieved": "2024-07-30T20:41:12.874283", "image_code": "#define SSAA\nconst int SSAA_Cnt = 1;\n#define showCost\n\n#define eps 0.0001\n#define size vec3(2.0,2.0,2.0)\n#define roundr 0.25\n#define global_k 1.25\n#define Lipschitz_GridSize 0.3\n#define Lipschitz_GridSize2 1.0\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat opTwist(vec3 p)\n{\n    float t = iTime;\n    float k = 0.55*sin(2.0*t); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdRoundBox(q,size,roundr);\n}\nfloat scene(vec3 pos)\n{\n    float dist = 0.0;\n    dist = opTwist(pos);\n    return dist;\n}\n\nvec3 calcGradient( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn ((vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n           -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)))/(2.0*eps));\n}\nvec3 calcGradientCheap( in vec3 pos ,in float original)\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn (vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n           -vec3(original))/(eps);\n}\nvec2 sceneK(vec3 start,vec3 end,vec3 dir)\n{\n    float dist = 0.0;\n    dist = scene(start);\n    \n    vec3 gs = calcGradient(start);\n    vec3 ge = calcGradient(end);\n    //vec3 gs = calcGradientCheap(start,dist);\n    //vec3 ge = calcGradientCheap(end,dist);\n    float fds = abs(dot(gs,dir));\n    float fde = abs(dot(ge,dir));\n    float lam = max(fds,fde);\n    \n    \n    return vec2(lam,dist);\n}\n//more accurate\nvec2 sceneK2(vec3 start,vec3 end,vec3 dir)\n{\n    vec3 center = start+end;\n    center *=0.5;\n    float dist = 0.0;\n    dist = scene(start);\n    vec3 gs = calcGradient(start);\n    vec3 ge = calcGradient(end);\n    vec3 gc = calcGradient(center);\n    float fds = abs(dot(gs,dir));\n    float fde = abs(dot(ge,dir));\n    float fdc = abs(dot(gc,dir));\n    float lam = max(fds,fde);\n    lam = max(fdc,lam);\n    \n    \n    return vec2(lam,dist);\n}\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;//min max intersect\n\tfloat t = mint;\n\n\tfor(int i=0;i<512;i++)\n\t{\n\t\tfloat d = scene(ro+rd*t);\n\t\tif (d < 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n        float ts = max(abs(d)/global_k, eps);\n\t\tt += ts;\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec2 calcIntersection2( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;\n\tfloat t = mint;\n\tfloat c = 2.0;\n\tfloat ts = (maxt - mint);\n    ts = min(ts,Lipschitz_GridSize);\n\tfor(int i=0;i<512;i++)\n\t{\n        vec3 pt = ro+rd*t;\n\t\tvec3 pts = ro+rd*(t + ts);\n        vec2 data = sceneK(pt,pts,rd);\n\t\tfloat dist = data.y;\n\t\tif (dist < 0.0)\n        {\n\t\t\treturn vec2(t,float(i)*2.0);\n        }\n\t\tfloat k = data.x;\n\t\tfloat tk = abs(dist) / max(k,0.01);\n\t\ttk = max(abs(dist)/global_k,min(tk, ts));\n\t\tts = tk;\n\t\tif(tk >= 0.0)\n\t\t{\n\t\t\tt += max(tk, eps);\n\t\t}\n\t\tts = tk * c;\n        ts = min(ts,Lipschitz_GridSize);\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec2 calcIntersection3( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;\n\tfloat t = mint;\n\tfloat c = 2.0;\n\tfloat ts = (maxt - mint);\n    ts = min(ts,Lipschitz_GridSize2);\n\tfor(int i=0;i<512;i++)\n\t{\n        vec3 pt = ro+rd*t;\n\t\tvec3 pts = ro+rd*(t + ts);\n        vec2 data = sceneK2(pt,pts,rd);\n\t\tfloat dist = data.y;\n\t\tif (dist < 0.0)\n        {\n\t\t\treturn vec2(t,float(i)*3.0);\n        }\n\t\tfloat k = data.x;\n\t\tfloat tk = abs(dist) / max(k,0.01);\n\t\ttk = max(abs(dist)/global_k,min(tk, ts));\n\t\tts = tk;\n\t\tif(tk >= 0.0)\n\t\t{\n\t\t\tt += max(tk, eps);\n\t\t}\n\t\tts = tk * c;\n        ts = min(ts,Lipschitz_GridSize);\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\nvec3 calcNormal( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn normalize((vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n                     -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)))/(2.0*eps));\n}\nvec3 illuminate( in vec3 pos , in vec3 camdir )\n{\n    return calcNormal(pos)*0.5+0.5;\n}\n\nvec3 background( vec3 rd )\n{\n\treturn texture(iChannel0, rd).rgb * texture(iChannel0, rd).rgb;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colAcc = vec3(0.0,0.0,0.0);\n    \n    float t = 1.5*iTime;\n    vec3 campos = vec3(10.0*sin(t*0.3),3.5*sin(t*0.5)+6.0,-10.0*cos(t*0.3));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n    #ifdef SSAA\n    for(int i=-SSAA_Cnt;i<SSAA_Cnt;i++)\n    {\n    for(int j=-SSAA_Cnt;j<SSAA_Cnt;j++)\n    {    \n    vec2 xy = (fragCoord.xy+0.5*(vec2(i,j)+vec2(0.5,0.5))/float(SSAA_Cnt) - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    #else\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y); \n    #endif\n\tvec3 camdir = normalize( camMat * vec3(xy,1.0) );\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n        float dist = 0.0;\n    float times = 256.0;\n    if(fragCoord.x/iResolution.x>0.501)\n    {        \n        vec2 data = calcIntersection(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else if(fragCoord.x/iResolution.x<0.499)\n    {\n        vec2 data = calcIntersection3(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else\n    {\n        dist = -2.0;   \n    }\n    if (dist==-1.0)\n    {\n        col = background(camdir);\n    }\n    else if(dist == -2.0)\n    {\n        col = vec3(1.0,0.0,0.0);   \n    }\n    else\n    {\n    \tvec3 inters = campos + dist * camdir;\n    \tcol = illuminate(inters, camdir);\n    }\n    \n    float bannerHeight = 0.2;\n    float bannerOffset = 0.5*sin(iTime);\n    if(fragCoord.y/iResolution.y<0.5 +bannerOffset+ bannerHeight && fragCoord.y/iResolution.y>0.5+bannerOffset - bannerHeight)\n    {\n        #ifdef showCost\n        col = mix(vec3(0.0,1.0,0.0),vec3(1.0,0.0,0.0),times/64.0);   \n        #endif\n    }\n        col = pow(col, vec3(0.8));\n        colAcc+=col;\n        \n    #ifdef SSAA\n    }\n    }\n\tfragColor = vec4(colAcc/float(4*SSAA_Cnt*SSAA_Cnt),1.0);\n    #else\n    fragColor = vec4(colAcc,1.0);\n    #endif\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 255, 255, 346], [347, 347, 370, 370, 600], [601, 601, 624, 624, 690], [692, 692, 726, 726, 1012], [1013, 1013, 1070, 1070, 1299], [1300, 1300, 1343, 1343, 1692], [1693, 1709, 1753, 1753, 2146], [2147, 2147, 2196, 2196, 2542], [2544, 2544, 2594, 2594, 3255], [3257, 3257, 3307, 3307, 3970], [3971, 3971, 4003, 4003, 4308], [4309, 4309, 4358, 4358, 4396], [4398, 4398, 4426, 4426, 4493], [4495, 4495, 4559, 4559, 4737]], "test": "untested"}
{"id": "3dKyRW", "name": "circle-pattern", "author": "lasoy", "description": "pattern", "tags": ["pattern"], "likes": 4, "viewed": 295, "published": 3, "date": "1602325880", "time_retrieved": "2024-07-30T20:41:13.652203", "image_code": "vec2 brickTile(vec2 pos, float zoom){\n    pos *= zoom;\n\n    float time = fract(iTime * .5);\n    float col = step(1., mod(pos.x + (1.0 - step(.75, time)) * .5, 2.0));\n    float row = step(1., mod(pos.y - step(.5, time) * .5, 2.0));\n\n    pos.x += (clamp(time, .0, .25) + clamp(time - .5, .0, .25)) * (row - .5) * 4.;\n    pos.y += (clamp((time - .25), .0, .25) + clamp(time - .75, .0, .25)) * (col - .5) * 4.;\n\n    return fract(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec2 pos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    pos = brickTile(pos, 6.);\n    \n    pos = pos - vec2(.5);\n    float angle = atan(pos.x, pos.y);\n    angle += iTime * 1.;\n    float r = length(pos);\n\n    vec3 color = vec3(smoothstep(cos(angle*3.),cos(angle*3.)+.1,r*3. ));\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 432], [434, 434, 490, 490, 816]], "test": "untested"}
{"id": "tsyyzD", "name": "parallel sort / histogram 2", "author": "FabriceNeyret2", "description": "2020 int-based version of [url]https://www.shadertoy.com/view/4dd3Wj[/url]\nAt each frame  pixels are randomly paired (using pairPos = xor( Pos, f(T) )  )\nPixels in each pair are swapped if not in expected (luminance) order.  Sort of // random bubble sort.", "tags": ["sorting", "histogram", "parallel"], "likes": 8, "viewed": 491, "published": 3, "date": "1602319768", "time_retrieved": "2024-07-30T20:41:14.405190", "image_code": "// 2020 int-base version of my 2016 https://shadertoy.com/view/4dd3Wj ( 677 chars )\n\nvoid mainImage(out vec4 O, vec2 U) { O = T(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float R = 256.;  // sort array RxR\n\n#define id(I)   ( I.x + int(R) * I.y )\n#define hash(t)   ivec2( t*7177 +103  , t*1151 +151  ) % int(R)\n//#define hash(t) ivec2( t*1.73 +103.7, t*11.4 +51.8 ) % int(R)\n\nvoid mainImage( out vec4 O,  vec2 U )\n{   \n    if (iResolution.y < R) R /= 2.;                       // for icon resolution\n    int t = iFrame%512;\n    if (t==10 ) { O = texture(iChannel1, U/R).rrrr; return; } // init with texture to sort\n    if (t==266) { O = texture(iChannel2, U/R);      return; }\n       \n    O =  T(U);                                            // restore state\n    if ( max(U.x,U.y) > R ) return;                       // treat only array RxR\n    \n    ivec2 I = ivec2(U),\n          S = I ^ hash(t);                                // dual location\n    vec4 OS = T(S);                                       // its pixel value\n    if ( dot(OS,OS) < dot(O,O) == id(S) < id(I) ) O = OS; // swap if bad ordered\n\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 121, 121, 133]], "test": "untested"}
{"id": "tdycRD", "name": "Segment Tracing", "author": "yuchengzhong", "description": "gpu version of https://diglib.eg.org/bitstream/handle/10.1111/cgf13951/v39i2pp545-554.pdf?sequence=1&isAllowed=y\nextremly slow on gpu.", "tags": ["raytracing", "metaball", "tracing", "segment"], "likes": 9, "viewed": 596, "published": 3, "date": "1602319203", "time_retrieved": "2024-07-30T20:41:15.169148", "image_code": "//#define SSAA\nfloat intensity(vec3 pos,vec3 center,float radius)\n{\n    vec3 delta = pos-center;\n    float len = dot(delta,delta);\n    float localLen = 1.0-len / radius;\n\treturn (len > radius) ? 0.0 : localLen*localLen*localLen;\n    //return CubicFalloff(pos,center,radius);\n}\n\nvec2 K(vec3 start,vec3 end,vec3 center,float radius,float radius2,float radius2Inv,float energy) //energy = 1.0\n{\n    vec3 es = end - start;\n    vec3 cs = center - start;\n    vec3 ce = center - end;\n    float scsSqrt = length(cs);\n    float sceSqrt = length(ce);\n    float scs = scsSqrt*scsSqrt;\n    float sce = sceSqrt*sceSqrt;\n    float sesSqrt = length(es);\n\tvec3 axis = es/sesSqrt;\n\tfloat l = dot(cs,axis);\n\tfloat kk = 0.0;\n\tif (l < 0.0)\n\t{\n\t\tkk = CubicFalloffK(scs, sce,scsSqrt,sceSqrt, radius,radius2,radius2Inv, energy);\n\t}\n\telse if (sesSqrt < l)\n\t{\n\t\tkk = CubicFalloffK(sce, scs,sceSqrt,scsSqrt, radius,radius2,radius2Inv, energy);\n\t}\n\telse\n\t{\n\t\tfloat dd = scs - (l * l);\n\t\tvec3 pc = start + axis * l;\n\t\tkk = CubicFalloffK(dd, max(sce, scs),sqrt(dd),max(sceSqrt, scsSqrt), radius,radius2,radius2Inv, energy);\n\t}\n\tfloat grad = max(abs(dot(axis,cs)/scsSqrt), abs(dot(axis,ce)/sceSqrt));\n    float localLen = 1.0-scs / radius;\n\tfloat intensity =  (scs > radius) ? 0.0 : localLen*localLen*localLen;\n\treturn vec2(kk * grad,intensity);\n}\n#define global_k 1.0\n#define eps 0.001\nfloat scene(vec3 pos)\n{\n    //float t = iTime;\n    vec3 center = vec3(0.0,0.0,0.0);\n    float radius = 1.5;\n    \n    float I = 0.0;\n    for(int i=0;i<32;i++)\n    {\n        \n        I += intensity(pos,center+3.0*random3(i),radius);\n    }\n    return I-0.5;\n}\n\nvec2 sceneK(vec3 start,vec3 end)\n{\n    //float t = iTime;\n    vec3 center = vec3(0.0,0.0,0.0);\n    float radius = 1.5;\n    float radius2 = radius * radius;\n    float radius2Inv = 1.0/radius2;\n    \n    float k = 0.0;\n    float I = 0.0;\n    for(int i=0;i<32;i++)\n    {\n        vec2 data = K(start,end,center+3.0*random3(i),radius,radius2,radius2Inv,1.0);\n        k+=data.x;\n        I += data.y;\n    }\n    return vec2(k,I-0.5);\n}\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;//min max intersect\n\tfloat t = mint;\n\n\tfor(int i=0;i<128;i++)\n\t{\n\t\tfloat I = scene(ro+rd*t);\n\t\tif (I > 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n        float ts = max(abs(I) / global_k, eps);\n\t\tt += ts;\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\nvec2 calcIntersection2( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;//min max intersect\n\tfloat t = mint;\n\tfloat c = 1.5;\n\tfloat ts = (maxt - mint);\n\n\tfor(int i=0;i<128;i++)\n\t{\n        vec3 pt = ro+rd*t;\n\t\tvec3 pts = ro+rd*(t + ts);\n        vec2 data = sceneK(pt, pts);\n\t\tfloat I = data.y;\n\t\tif (I > 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n\t\tfloat k = data.x;\n\t\tfloat tk = abs(I) / k;\n\t\ttk = min(tk, ts);\n\t\tts = tk;\n\t\tif(tk >= 0.0)\n\t\t{\n\t\t\tt += max(tk, eps);\n\t\t}\n\t\tts = tk * c;\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\n\treturn normalize(vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n                     -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)));\n}\nvec3 illuminate( in vec3 pos , in vec3 camdir )\n{\n    return calcNormal(pos)*0.5+0.5;\n}\n\nvec3 background( vec3 rd )\n{\n\treturn texture(iChannel0, rd).rgb * texture(iChannel0, rd).rgb;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colAcc = vec3(0.0,0.0,0.0);\n    \n    float t = iTime;\n    vec3 campos = vec3(10.0*sin(t*0.3),2.5*sin(t*0.5),-10.0*cos(t*0.3));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n    #ifdef SSAA\n    for(float i=-0.5;i<1.0;i+=1.0)\n    {\n    for(float j=-0.5;j<1.0;j+=1.0)\n    {    \n    vec2 xy = (fragCoord.xy+0.5*vec2(i,j) - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    #else\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y); \n    #endif\n\tvec3 camdir = normalize( camMat * vec3(xy,1.0) );\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    float dist = 0.0;\n    float times = 256.0;\n    if(fragCoord.x/iResolution.x>0.501)\n    {        \n        vec2 data = calcIntersection2(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else if(fragCoord.x/iResolution.x<0.499)\n    {\n        vec2 data = calcIntersection(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else\n    {\n        dist = -2.0;   \n    }\n    if (dist==-1.0)\n    {\n        col = background(camdir);\n    }\n    else if(dist == -2.0)\n    {\n        col = vec3(1.0,0.0,0.0);   \n    }\n    else\n    {\n    \tvec3 inters = campos + dist * camdir;\n    \tcol = illuminate(inters, camdir);\n    }\n    if(fragCoord.y/iResolution.y<0.5)\n    {\n        col = mix(vec3(0.0,1.0,0.0),vec3(1.0,0.0,0.0),times/64.0);   \n    }\n        col = pow(col, vec3(0.8));\n        colAcc+=col;\n    \n    \n    \n\n    #ifdef SSAA\n    }\n    }\n\tfragColor = vec4(colAcc*0.25,1.0);\n    #else\n    fragColor = vec4(colAcc,1.0);\n    #endif\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float CubicFalloff(vec3 pos,vec3 center,float radius)\n{\n    vec3 delta = pos-center;\n    float len = dot(delta,delta);\n    float localLen = 1.0-len / radius;\n\treturn (len > radius) ? 0.0 : localLen*localLen*localLen;\n}\n\nfloat CubicFalloffK(float energy, float radius)\n{\n\treturn 1.72 * abs(energy) / radius;\n}\n\nfloat CubicFalloffK(float start, float end,float startSqrt,float endSqrt, float radius,float radius2,float radius2Inv, float energy)\n{\n    float absE = abs(energy);\n    float absE6Radius2Inv = absE * 6.0*radius2Inv;\n\tif (start > radius2)\n    {\n\t\treturn 0.0;\n    }\n    float radius202 = radius2 *0.2;\n\tif (end < radius202)\n\t{\n\t\tfloat t = (1.0 - end *radius2Inv);\n\t\treturn  absE6Radius2Inv*endSqrt* (t * t);\n\t}\n\telse if (start > radius202)\n\t{\n\t\tfloat t = (1.0 - start *radius2Inv);\n\t\treturn absE6Radius2Inv*startSqrt* (t * t);\n\t}\n\telse\n    {\n\t\treturn 1.72 * absE / radius;//CubicFalloffK\n    }\n}\nfloat SquaredNorm(vec3 a)\n{\n    return dot(a,a);   \n}\n\nvec3 hash3( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nvec3 random3(int n)\n{\n    return hash3(uint(n))*2.0-1.0;   \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdycRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 15, 67, 67, 276], [278, 278, 391, 391, 1317], [1357, 1357, 1380, 1403, 1613], [1615, 1615, 1649, 1672, 2041], [2044, 2044, 2093, 2093, 2441], [2442, 2442, 2492, 2492, 3046], [3048, 3048, 3080, 3080, 3374], [3375, 3375, 3424, 3424, 3462], [3464, 3464, 3492, 3492, 3559], [3561, 3561, 3625, 3625, 3803]], "test": "untested"}
{"id": "wdGyR1", "name": "Diffuse-Glossy Sphere W/ Cubemap", "author": "milesWaugh", "description": "Real-time path tracing, using some speedup techniques", "tags": ["sphere", "cubemap", "diffuse", "glossy"], "likes": 10, "viewed": 526, "published": 3, "date": "1602304464", "time_retrieved": "2024-07-30T20:41:16.017878", "image_code": "//You can change the cubemap shown under Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 r = iResolution.xy;\n    fragColor  = vec4(0.);\n    fragColor += texture(iChannel0, uv) * 2.0;\n    fragColor += texture(iChannel0, uv - vec2( 0., 1.) / r);\n    fragColor += texture(iChannel0, uv - vec2( 0.,-1.) / r);\n    fragColor += texture(iChannel0, uv - vec2( 1., 0.) / r);\n    fragColor += texture(iChannel0, uv - vec2(-1., 0.) / r);\n    fragColor += texture(iChannel0, uv - vec2(-1., 1.) / r) * .5;\n    fragColor += texture(iChannel0, uv - vec2(-1 ,-1.) / r) * .5;\n    fragColor += texture(iChannel0, uv - vec2( 1., 1.) / r) * .5;\n    fragColor += texture(iChannel0, uv - vec2( 1.,-1.) / r) * .5;\n    fragColor /= 5.;\n    //fragColor-=0.01; //Blackpoint\n    float x = max(fragColor.x, 0.);\n    float y = max(fragColor.y, 0.);\n    float z = max(fragColor.z, 0.);\n    fragColor = vec4(pow(1.-1./(1.+5.*x*x),0.45), pow(1.-1./(1.+5.*y*y),0.45), pow(1.-1./(1.+5.*z*z), 0.45), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define c cos(iTime/5.)\n#define s sin(iTime/5.)\n\nvec3 random(vec3 pos) {\n    pos.x *= 50.;\n    pos.y *= 50.;\n    float x = fract(sin(dot(pos, vec3(64.25375463, 23.27536534, 86.29678483))) * 59482.7542);\n    float y = fract(sin(dot(pos, vec3(34.78372462, 89.68045824, 64.86872345))) * 49368.2846);\n    float z = fract(sin(dot(pos, vec3(46.28658934, 21.58496345, 67.10684735))) * 83460.2385);\n    return vec3(x, y, z);\n}\n\nvec3 pow3(vec3 v, float n) {\n    return vec3(pow(v.x, n), pow(v.y, n), pow(v.z, n));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.);\n    vec2 uvm = (fragCoord - (iResolution.xy / 2.)) / (iResolution.y / 2.);\n    int iters = dot(uvm, uvm) > 1. ? 1 : 32;\n    \n    for(int i = 0; i < iters; i++) { //32 samples per frame, for the sphere\n        vec2 offset = random(vec3(fragCoord.x, fragCoord.y + iResolution.y, iTime * 60. + float(i))).xy;\n        vec2 uv = ((fragCoord + offset) - (iResolution.xy / 2.)) / (iResolution.y / 2.);\n        float d = dot(uv, uv) * 1.05;\n        vec3 normal = d < 1. ? vec3(uv.x, uv.y, sqrt(1. - d)) : vec3(0.);\n        vec3 r, albedo, refcol, refvec, col;\n        if(d < 1.) {\n            refvec = (2. * normal.z * normal) - vec3(0., 0., 1.);\n            r = random(vec3(uv.x, uv.y, iTime * 60. + float(i))) * 2.0 - 1.0;\n            if(dot(r, normal) < 0.)\n                r = -r;\n            refvec = normalize(refvec * 15.0 + r);\n            float d2 = dot(r, normal);\n            r = vec3(r.x * c - r.z * s, r.y, r.z * c + r.x * s);\n            refvec = vec3(refvec.x * c - refvec.z * s, refvec.y, refvec.z * c + refvec.x * s);\n            albedo = d2 * 3. * pow3(texture(iChannel0, r).rgb, 2.2) * vec3(0.3, 0.6, 0.8);\n            refcol = 3. * pow3(texture(iChannel0, refvec).rgb, 2.2);\n            float fresnel = 1. - normal.z;\n            fresnel = 0.04 + 0.96 * fresnel * fresnel * fresnel * fresnel * fresnel;\n            col = fresnel * refcol + (1. - fresnel) * albedo;\n        } else {\n            r = normalize(vec3(uv.x, uv.y, -5.));\n            r = vec3(r.x * c - r.z * s, r.y, r.z * c + r.x * s);\n            col = 3. * pow3(texture(iChannel0, r).rgb, 2.2);\n        }\n        fragColor += vec4(col.x, col.y, col.z, 1.0);\n    }\n    \n    fragColor /= float(iters);\n    fragColor = (fragColor + 5. * texture(iChannel1, fragCoord / iResolution.xy).rgba) / 6.; //persist frames\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 106, 106, 1041]], "test": "untested"}
{"id": "3sGyRD", "name": "inverse xorshift", "author": "FabriceNeyret2", "description": "xorshift calculated forward and backward\nleft: xorshit(coords)\nright: invXS(XS(coords))\nalternate in time between narrow (power-of-2) or full image range", "tags": ["hash", "rng", "xorshift", "inversible"], "likes": 3, "viewed": 384, "published": 3, "date": "1602272478", "time_retrieved": "2024-07-30T20:41:16.778844", "image_code": "#define R iResolution.xy\nvec2 M;                                     // mapped rectangle\nuint L,                                     // rectangle length\n    mask;                                   // total span of used bits\n\nvoid init() {\n    if (mod(iTime,2.) < 1. )                // map whole screen\n        L = uint(R.x), mask  = 0xFFFFffffU, M = R;\n    else                                    // map on LxL tiles\n        L = 256u,      mask  = L*L-1u, M = vec2(L,L);\n}\n\n#define vec2int(V)   uint( (V).x + L * (V).y )\n#define int2vec(v)   vec2( (v) % L , (v) / L )\n\n// --- xorshift and reverse ------------------------------------------------\n\n#define opL(x,s)  ( x ^ (x << s) ) & mask\n#define opR(x,s)  ( x ^ (x >> s) ) & mask\n\nuint invOpL(uint x, int s) {  // https://stackoverflow.com/questions/31521910/simplify-the-inverse-of-z-x-x-y-function\n    for (; s < 32; s*=2 )\n        x = opL(x,s);\n    return x;\n}\nuint invOpR(uint x, int s) { \n    for (; s < 32; s*=2 )\n        x = opR(x,s);\n    return x;\n}\n\nuint xorshift(uint x) {       // https://en.wikipedia.org/wiki/Xorshift\n    x = opL(x,13);\n\tx = opR(x,17);\n\tx = opL(x,5);\n    return x;\n}\nuint invXorshift(uint x) {\n\tx = invOpL(x,5);\n\tx = invOpR(x,17);\n    x = invOpL(x,13);\n    return x;\n}\n// -------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    init();\n    uvec2 I = uvec2(U);\n    uint key = 0u,     \n      // key = 0xe1a7u,                        // in case we want to fill the dynamics\n           i = vec2int(I),                     // pixel index\n           j = xorshift(i ^ key ),             // xorshift\n           k = invXorshift(j) ^ key;           // reverse\n    \n    O = I.x < L/2u\n        ? vec4(int2vec(j)/M,0,0)               // left: xorshift(coords)\n        : vec4(int2vec(k)/M,0,0);              // right: invXS(XS(coords))\n // O = vec4(i==k);                            // test invXS(XS) == identity\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 238, 238, 473], [733, 733, 761, 851, 915], [916, 916, 944, 944, 1009], [1011, 1011, 1034, 1082, 1148], [1149, 1149, 1175, 1175, 1250], [1329, 1329, 1367, 1367, 1944]], "test": "untested"}
{"id": "WsycRW", "name": "First Project (cellular automat)", "author": "Philipuss", "description": "My first project", "tags": ["first"], "likes": 5, "viewed": 279, "published": 3, "date": "1602264375", "time_retrieved": "2024-07-30T20:41:17.653505", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.141592653589793238462643383279502;\n\nfloat hash13 (vec3 p3)\n{\n \tp3  = fract (p3 * 0.1031);\n    p3 += dot (p3, p3.yzx + 33.33);\n    return fract ((p3.x+p3.y)*p3.z);\n}\n\nvec2 ang2vec(float a)\n{\n \treturn vec2(cos(a), sin(a));   \n}\n\nvec2 read(vec2 p) {\n\treturn texture(iChannel0, p/iResolution.xy).xy;\n}\n\nvec2 avgpool(vec2 p) {\n  vec2 acc = vec2(0.0);\n  for (int y=-1; y<=1; ++y)   \n  for (int x=-1; x<=1; ++x) {\n    acc += read(p + vec2(x, y));\n  }\n  return acc / 9.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0)\n    {\n    \tfloat a = hash13(vec3(fragCoord+vec2(58342.0, -58342.0), 0.0)) * 2.0 * pi;\n    \tfragColor = vec4(ang2vec(a), 0.0,0.0);\n        return;\n    }\n    vec2 v = normalize(avgpool(fragCoord));\n    fragColor = vec4(v, 0.6, v);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsycRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 165]], "test": "untested"}
{"id": "tdKczh", "name": "Playing with nebula", "author": "Leria", "description": "A+mouse: tune density   Z+mouse: camera distance\nB : change the background\nN : switch between different definition of multiplicative noise\nH : noise visualisation (tst)\nZ : zoom with mouse", "tags": ["fractal", "noise", "nebula", "toy"], "likes": 2, "viewed": 383, "published": 3, "date": "1602249392", "time_retrieved": "2024-07-30T20:41:18.597980", "image_code": "// ==============================================================\n// Model and render nebula. see techreport Url: [soon]\n// Erwan Leria, 2020\n// Free for any use, just let my name appears or a link to this shader\n// ==============================================================\n\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n\n//Play with Nebula parameters !\nstruct Nebula\n{\n    vec3 pos;\n \tvec3 absorb_coef;\n    vec3 color;\n    float bubble_radius;\n};\n    \nNebula neb = Nebula(\n    \t\t\t\tvec3(0) , //neb.pos\n    \t\t\t\tvec3(2., 3., 2.) ,  //nebabsorb_coef\n                    vec3(.7, .4, .3),\t//neb.color\n                    2.36 //\tneb.bubble_radius\n                   );\n\nvec3 cam_pos = vec3(0,0,8);\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n\n#define ANIM\t\t\t\t1    //animation 0 or 1\n#define RADIUS\t\t\t\t4.\nfloat DISPERSION_VELOCITY =\t8.4;\n\n\n// --- noise parameters  --------------------------------------------\n\nfloat LOD\t\t=\t5.; //Set noise max level of details in [1.,inf[ (max value recommended is 5. or 6.)\n\n//----> in LOD mode, you can\n//choose the nature of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n#define STRETCH\t\t \t\t1        // stretching\nvec3 stretching  = vec3( 1, 1, 1 );  // anisotropy\n\n\n// --- dedicated noise utils ----------------------------------------\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\nfloat log_norm(float x, float mu, float sig)\n{\n    float ln_sqr = log((x+1e-5)-mu); //compute once the value\n    float r = (1./((x+1e-5 )*sig*2.51) )* ( exp( - (ln_sqr*ln_sqr)/(2.*sig*sig)  ) );\n \treturn (r<0.?0.:r) ;\n}\n\nfloat gaussian_distrib(float x, float mu, float s)\n{\n    float X = x-mu;\n    return (1./( s*2.51 )) * exp( - (X*X) / ( 2.*( s*s ) ) );\n}\n\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n\nfloat Psnoise1(vec3 p) {return ( 2.*( exp( snoise(p)) ) );  }\nfloat Psnoise2(vec3 p) {return  max(0., log_norm(snoise(p*10.), 0., 10.));}\nfloat Psnoise3(vec3 p) {return  max(0., 1. + .4*GaussNoise(p) ); }\n\n\nint selected_psnoise = 3; //Psnoise_i selector\n\nfloat Psnoise(vec3 p)\n{\n     return selected_psnoise == 3 ? Psnoise3(p)\n          : selected_psnoise == 2 ? Psnoise2(p)\n          :                          Psnoise1(p);\n}\n\n#define  rnd(v)     fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v)   ( 2.* rnd(v) - 1. )\n#define Bnoise(x)   abs(noise(x))\n\nfloat fbm_add( vec3 p, float level ) { // in [-1,1]\n    \n    float f = 0.;\n    vec3 s = vec3(2.);\n#if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n#endif\n    \n    for(float l = 0. ; l < level ; l++)\n    {\n     \tf += (1./exp2(l))*snoise(p);   p = p*s;\n    }\n    return f;\n}\n\nfloat fbm_mul( vec3 p, float level ) { // in [0,inf[\n    \n    float f = 1.;\n    vec3 s = vec3(2.);\n#if STRETCH\n   \tp *= stretching;\n   \ts = 2./pow(stretching,vec3(1./4.));\n#endif\n\n   \tfor(float i = 0. ; i < level ; i++)\n    {   _i = i;                      // for flownoise\n        f *= Psnoise(p); p = p*s;\n    }\n    return f;\n}\n\nfloat fbm(vec3 p, float level)\n{ \n#if ADDITIVE\n    return fbm_add(p, level);\n#else\n   \treturn fbm_mul(p, level);\n#endif   \n}\n\n\n// --- camera and nebula geometry -------------------------- \nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; // radius of bounding sphere of matter\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;    \n}\n\nvoid set_matter(vec3 pos, float radius)   { m = Matter(pos, radius); }\nvoid init_matter()                        { set_matter(vec3(0,0,0), RADIUS); }\n\n// --- position of light source\nvec3 lightpos = vec3(0);\n\n\nfloat energy_t_r(vec3 p, float velocity, float typical_scale)\n{\n    float gas_dens = Psnoise(p*10.); //generation of a local dispersion = turbulence * rate\n    gas_dens +=  fbm(p*10., LOD);\n \treturn gas_dens*.5*(velocity*velocity*velocity)/typical_scale;   \n}\n\nfloat local_velocity( float disp_rate)\n{\n\treturn 1.60*( DISPERSION_VELOCITY ) * disp_rate;  // $TUNE, 1.60 is a precomputed value\n}\n\n// --- main part: render nebula ------------------------------------\n// bounding sphere + volume marching\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n   \n    float param_t = intersect_sphere(r, neb.pos, RADIUS); // test bounding sphere\n    if(param_t == -1.) return; // the ray miss the nebula bounding sphere\n\n    \n    if(param_t < 0.) param_t = 0.; // jump to the sphere intersection (skip the void), but if we are already inside\n    vec3  p = ray_interpolation(r, param_t + 1e-5);        \n    \n    float vt = -1.;         //value of the previous voxel\n    \t\t\t\t\t\t//initializes the preintegration when >= 0         \n    \n    vec3 t_acc = vec3(1);\t// accumulated transparency\n    \n    if myKeyToggle(64+14) // key 'N' : switch multiplicative noise kind\n    {\n        selected_psnoise += 1;\n        if(selected_psnoise > 3) selected_psnoise = 1;\n    }\n            \n    for(int s=0; s < 120; s++)\n    {                 \n        vec3 center = p - neb.pos; //    \n        vec3 fromcam = cam.pos - p;\n        vec3 rgb_t = vec3(0);    // local transparency               \n               \n\n        //if we are no longer in the bounding sphere, stop marching the volume        \n\t\tif(length(fromcam) > length(cam.pos - neb.pos) + RADIUS) break;\n            // --- textured bubble model\n        float rad_bubl = neb.bubble_radius; // radius of bubble, also control the opening of the bubble                        \n\n        float size = length(p-neb.pos)/RADIUS;\n\n        float dr = fbm_add( p*5.2 - 124.17, LOD), //localy modify the radius of the bubble\n            de = noise( p - 98.12 ), //localy modify the thickness of the shell of the bubble\n\n            //mask of the bubble's shell\n            mask = smoothstep ( .2+0.2*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -2.8*dr )   ) ;\n\n        float dispersion_rate =  mask; \n\n        float velocity = local_velocity(dispersion_rate); //local velocity (sometimes called sigma_v)\n\n        // physical value of the microstructures of the cloud\n        float scale = 10.;\n\n        //kinetic energy transfer rate as a dust grain density coefficient (transfer function)\n        //Astron Astrophys Rev (2012) 20:55DOI 10.1007/s00159-012-0055-yREVIEW ARTICLETurbulent molecular cloudsPatrick Hennebelle·Edith Falgarone p.21 & a27            \n        float TAU_PRIME = energy_t_r(p, velocity, scale); \n\n        //////////// PREINTEGRATION //////////////////////// \n        #define PREINTEGRATION\t1\n        //preintegration formula :\n        //https://www.researchgate.net/publication/2878658_High-Quality_Pre-Integrated_Volume_Rendering_Using_Hardware-Accelerated_Pixel_Shading            \n        #define TAU(d0, d1)\t( (Psnoise(p*10.) + fbm(p*10., LOD)) * (INT_E(d1)-INT_E(d0))/(d1-d0) )\n\n        //primitive of the transfer function\n        #define INT_E(v)\t( (.5*(v*v*v*v))/(4.*scale) )   \n        /////////////////////////////////////////////////////\n\n        //ionization color on the rgb channels\n        vec3 colormap = clamp(vec3( size*size*50., (-(size-.5)*(size-.5)+1.)*7., 1./(size*size) )/10., 0., 1.);\n\n        //Scattering coefficient\n        vec3 sigma_s = neb.color*colormap;\n\n        //Absorption coefficient\n        vec3 sigma_a = neb.absorb_coef;\n\n        sigma_a *= exp( 10.*(myKeyParam(64+1)-.5) ); // key 'A'+mouse: tune overall opacity\n\n        //Attenuation coefficient\n        vec3 sigma_t = vec3(0);\n\n        if(vt == -1.) //if the value was not yet initialized, then initialize it doesn't use preintegration\n        {\n            sigma_t = (sigma_a+sigma_s)*TAU_PRIME;\n            vt = velocity+1e-5;  \n        }           \n\n        #if PREINTEGRATION\n        sigma_t = (sigma_a+sigma_s)*TAU(vt, velocity);\n        vt = velocity+1e-5;     \n        #else\n        sigma_t = (sigma_a+sigma_s)*TAU_PRIME;\n        #endif\n\n        rgb_t = exp(-sigma_t*k/32.);    // <<< local transparency                                \n        // note that Dl = k has no unit  -> * coef to adapt\n\n\n        float epsilon = k/10.;           // --- local lighting\n\n        vec3 L = normalize(p-lightpos);\n        // TAU_PRIME at neighbor location\n        #define nTAU(x,y,z) energy_t_r(p+epsilon*vec3(x,y,z), velocity , scale)\n\n        #if 1\n        vec3 N =   vec3( nTAU(1,0,0), nTAU(0,1,0), nTAU(0,0,1) )\n            - TAU_PRIME;\n        N = normalize(N+1e-5);\n        float dif = abs(dot(N, L));\n        #else\n        float dif = 0.002*abs( nTAU(L.x,L.y,L.z) - TAU_PRIME ) / epsilon; // directional derivative https://iquilezles.org/articles/derivative\n        #endif\n\n        L = p-lightpos;\n        float l = length(L), L0 = 7.; // L0: tunes where the const/r² = 1  \n        float sun = 1.* L0*L0/(l*l);\n        float shadow =  exp(- 4.*max(0., l  - (rad_bubl) ) ) , // star illu: max at inner shell surface, then decay\n            reflec = dif;                   // isotropic\n        //reflec = .75* ( 1. + dif*dif ); // Rayleigh phase function\n\n\n        // --- add current voxel contribution to ray\n        c += t_acc* (sigma_s/(sigma_t+1e-5) * reflec * sun * shadow) *  (1.-rgb_t);\n        t_acc *= rgb_t;    // accumulating the transparency of each voxel\n\n        \n        p += r.dir*k; //step to the next voxel according to the length of the sampling\n\n     //   k = uniform_step; //uniform step\n    }\n    \n    //output the transparency\n    transp_tot = t_acc;\n\n}\n\t\n// --- main ------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_matter();                        // --- init object and camera geometries\n\n    float z = 8.2 / (1.+ 2.*myKeyParam(64+26)); // key 'Z'+mouse: camera dist to nebula\n    set_camera(cam_pos, neb.pos); \n    time = iTime;              // for flownoise\n\n    //centering screen coordinates\n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord - R ) / R.y,\n        M =  iMouse.xy/R;\n\n    if myKeyToggle(64+8)                  // --- key 'H' : test noise \n    {\n        fragColor = vec4( fbm(vec3( uv, 1 )*40., 4.) );\n        return;\n    }\n\n    float degree = 2.*PI * M.x - PI;      // --- camera rotation: mouse or auto-rotation\n    float degree2 = 2.*PI * M.y - PI;\n    if ( iMouse.z<=0. || myKeyParam(0)>0. ) degree = iTime/2., degree2 = 0.;\n\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n\n    // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, \n        ray = normalize(ray_dir);\n    C.xz *= rot2(degree);   C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    cam.pos = C;\n\n    // --- launch rendering\n    vec3     color = vec3(0), \n        transp_tot = vec3(1), \n        sky = vec3(0);             // set background \n    sky =   .5* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rrr;\n    if myKeyToggle(64+2) sky = vec3(1); //from black 2 white\n    \n\t//ray march the nebula\n    ray_march_scene(Ray(C, ray), .1, color, transp_tot);  \n\n    //rendering the background according to the pixel transparency\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.); //gamma colors rendered \n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// === utils ==============================\n\n#define PI \t\t\t\t\t3.1415926\n\n\n// --- keyboard ---------------------------\n\n// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define myKeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define myKeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n\n\n// --- base noise -------------------------\n//most of \"noise stuff\" comes from iq\n\nfloat time, _i;            // for flownoise\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n    r -= .5;\n#if 0                             // flownoise. _i = perlin cascade level\n  //float t = time*exp2(_i)/256.;\n    float t =_i < 4. ? 0. : time/6.;\n    r.xy *= mat2( cos( 6.*t + vec4(0,11,33,0) ) );\n    r.yz *= mat2( cos( 4.7*t + vec4(0,11,33,0) ) );\n#endif\n\treturn r;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\tp  = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return p;\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\n\n// --- geometric transformations ----------\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// --- ray utils --------------------------\n\nstruct Ray\n{\n    vec3 origin; // origin\n    vec3 dir;    // direction of the ray\n};\n\nvec3 ray_interpolation(Ray r, float t)    { return (r.origin + r.dir*t);    }\n\n// Sphere intersection  distance ( or -1. if miss the sphere )\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.;\n\treturn -b - sqrt( h );\n}\n\n// Sphere SDF (for marching)\nfloat sdf_sphere(vec3 pXp0, float radius) { return (length(pXp0) - radius ); }\n", "buffer_a_code": "// === keyboard and sliders management ================\n\nvoid mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n \n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2106, 2106, 2152, 2152, 2325], [2327, 2327, 2379, 2379, 2463], [2708, 2708, 2732, 2732, 2769], [2770, 2770, 2794, 2794, 2845], [2846, 2846, 2870, 2870, 2912], [2963, 2963, 2986, 2986, 3134], [3282, 3282, 3320, 3333, 3596], [3598, 3598, 3636, 3650, 3927], [3929, 3929, 3961, 3961, 4053], [4428, 4428, 4468, 4468, 4518], [4520, 4520, 4563, 4563, 4590], [4591, 4591, 4634, 4634, 4669], [4730, 4730, 4793, 4793, 4989], [4991, 4991, 5031, 5031, 5122]], "test": "untested"}
{"id": "wlsBR8", "name": "log_polar_thingy_1", "author": "balkhan", "description": "toying with this space: https://www.osar.fr/notes/logspherical/", "tags": ["3d", "raymarching", "logspherical"], "likes": 11, "viewed": 360, "published": 3, "date": "1602248868", "time_retrieved": "2024-07-30T20:41:19.479622", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n\n\n#define I_MAX\t\t400\n#define E\t\t\t0.0001\n#define FAR\t\t\t20.\n\n#define\tFUDGE\t\t1.\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n#define SCALE 2.0/PI\n\nfloat sdCy( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 ilogspherical(in vec3 p)\n{\n\tfloat erho = exp(p.x);\n\tfloat sintheta = sin(p.y);\n\treturn vec3(\n\t\terho * sintheta * cos(p.z),\n\t\terho * sintheta * sin(p.z),\n\t\terho * cos(p.y)\n\t);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat side = .0, shorten = 20.50;\nfloat layer(in vec3 p, in float twost)\n{\n\tfloat ret = 1e5;\n\tpR(p.yz, twost);\n    vec3 op = p;\n\tp.xyz = abs(p.xyz) - 2.750;\n    float a = .0+p.x*.5;\n    /*\n    p.xy= modA(p.xy, 3.);p.x-=5.;\n    p.zy= modA(p.zy, 3.);p.z-=2.;\n    p.yx= modA(p.yx, 3.);p.y-=4.;\n    */\n    ret = length(vec2(max(p.y, p.x), max(p.z, min(p.x,p.y) ) ) )-.25;\n\n    float sf = .1525+-1.5100251010/(length(p)*length(p)*0.015+10.01)-.0;\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.z, p.x))/sf-.5\n              )-.10105\n              );\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.y, p.x))/sf-.5\n              )-.10105\n              );\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.z, p.y))/sf-.5\n              )-.105105\n              );\n    ret = max(ret,\n              -(length(fract(sf*p)/sf-.5)-.5 )\n              );\n    op.xy = modA(op.xy, 50.);\n    op.zx = modA(op.zx, 50.);\n    float shell_cubes = (mylength(op-vec3(.0,-.0,1.0505)+-.00)-0.0251250905125995);\n    ret = min(ret, shell_cubes );\n    ret = min(ret, (length(p+-4.50705)-3.50905995) );\n\n\treturn ret;\n}\n\nfloat sdf(in vec3 pin)\n{\n    float dens = .25;\n    float idens = 1./dens;\n    float twist = 1.5, stepZoom = 1.;\n\tfloat r = length(pin);\n\tvec3 p = vec3(log(r), acos(pin.z / length(pin)), .0+iTime*.1*-1.0+atan(pin.y, pin.x));\n\n\t// Apply rho-translation, which yields zooming\n\tp.x -= iTime*1.2;\n\n\t// find the scaling factor for the current tile\n\tfloat xstep = floor(p.x*dens) + (iTime*1.2)*dens;\n\t\n\t// Turn tiled coordinates into single-tile coordinates\n\tp.x = mod(p.x, idens);\n\n\t// Apply inverse log-spherical map (box tile -> shell tile)\n\tp = ilogspherical(p);\n\n\tfloat ret = 1e5;\n\tret = min(ret, layer(p/stepZoom, (xstep+1.0)*twist)*stepZoom);\n\n\t// Compensate for scaling applied so far\n\tret = ret * exp(xstep*idens) / shorten;\n\n\treturn ret;\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2\tR = iResolution.xy;\n\tvec2\tuv  = vec2((f.xy-.5*R.xy)/R.y);\n\tvec3\tdir = normalize(vec3(uv*vec2(1.,-1.), 1.));\n    vec3\tpos = vec3(-.0, -.2105017501050*.450*.0+.033*.0, -2.0*.0-1.52525045);\n    \n\n    vec4\tinter = march(pos, dir);\n    if (inter.y <= E*1.)\n    {\n        vec3\tv = pos+(inter.w-E*0.)*dir;\n        vec3\tn = calcNormal(v, E*1., dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(-100.0, 60.0, -50.0);\n\t\tvec3\tlight_color = vec3(.1, .4, .7);\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, 1.-dot(vl, n))+.0*max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 3.);\n        col.xyz += light_color * (specular*1.0)+ diffuse * vec3(.51,.515, .53);\n    }\n    else\n        col *= .0;\n    c_out =  vec4(col, 1.);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tret = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = sdf(p);\n        dist.y += dist.x*FUDGE;\n        if ( dist.x < E || dist.y > FAR)\n            break;\n    }\n    ret.w = dist.y;\n    ret.y = dist.x;\n    return (ret);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    ret = max(p.x, max(p.y, p.z));\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    \n    ret = max(p.x, p.y);\n\n    return ret;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           sdf(pos+eps.xyy) - sdf(pos-eps.xyy),\n           sdf(pos+eps.yxy) - sdf(pos-eps.yxy),\n           sdf(pos+eps.yyx) - sdf(pos-eps.yyx) ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[498, 498, 531, 531, 662], [708, 708, 738, 738, 837], [839, 839, 870, 870, 1020], [1022, 1022, 1054, 1054, 1096], [1132, 1132, 1172, 1172, 2249], [2251, 2251, 2275, 2275, 2993], [2995, 2995, 3038, 3038, 3896], [3898, 3898, 3930, 3930, 4293], [4309, 4309, 4333, 4333, 4426], [4428, 4428, 4452, 4452, 4536], [4538, 4538, 4579, 4579, 4647], [4650, 4650, 4690, 4690, 4765], [4767, 4767, 4817, 4817, 5023], [5025, 5025, 5047, 5047, 5253]], "test": "untested"}
{"id": "WdKcz1", "name": "Gliders Over Voropolis", "author": "dr2", "description": "Paper plane flyover (based on \"Voronoi Towers\"); mouseable", "tags": ["voronoi", "plane", "city", "flight"], "likes": 11, "viewed": 426, "published": 3, "date": "1602239652", "time_retrieved": "2024-07-30T20:41:20.340321", "image_code": "// \"Gliders Over Voropolis\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (=0/1) optional antialiasing (recommended if not fullscreen)\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], flPos, trkF, trkA, sunDir, qHit;\nfloat tCur, dstFar, dstBld, hBase, vorScl;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.732051;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]);\n    q.x = abs (q.x);\n    a = 0.22 * pi;\n    q.z += 0.25;\n    qq = q;\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), - a);\n    qq.xz = Rot2D (vec2 (qq.x, qq.z - 1.1), -0.012 * pi);\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), a);\n    d = abs (max (max (abs (qq.y) - 0.002, 0.), max (dot (q.xz, sin (0.15 * pi +\n       vec2 (0.5 * pi, 0.))) - 0.5, - q.z - 0.5))) - 0.002;\n    DMINQ (1 + k);\n  }\n  return dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BldDf (vec3 p)\n{\n  vec4 vc;\n  float h;\n  vc = HexVor (vorScl * p.xz);\n  h = 0.5 * (floor (16. * vc.w) + 2.) + 0.04 * dstBld *\n     smoothstep (0.8, 1., dstBld / dstFar);\n  return min (0.2 * SmoothMax (0.75 - vc.x, p.y - h, 0.03), p.y + hBase);\n}\n\nfloat BldRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  if (rd.y < 0.) {\n    dHit = - (ro.y - 9.) / rd.y;\n    for (int j = VAR_ZERO; j < 320; j ++) {\n      dstBld = dHit;\n      d = BldDf (ro + dHit * rd);\n      dHit += d;\n      if (d < 0.001 || dHit > dstFar) break;\n    }\n  } else dHit = dstFar;\n  return dHit;\n}\n\nvec3 BldNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BldDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  rd.y = abs (rd.y);\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (50. - ro.y) / (rd.y + 0.0001) + ro.xz));\n  col = vec3 (0.1, 0.3, 0.5) + 0.3 * pow (1. - max (rd.y, 0.), 4.);\n  col += vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.));\n  return mix (col, vec3 (0.9), clamp ((f - 0.2) * rd.y + 0.3, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, vn;\n  float dstBld, dstFlyer, c, hw;\n  HexVorInit ();\n  vorScl = 0.3;\n  hBase = 5.;\n  dstBld = BldRay (ro, rd);\n  dstFlyer = FlyerRay (ro, rd);\n  if (min (dstFlyer, dstBld) < dstFar) {\n    if (dstFlyer < dstBld) {\n      ro += dstFlyer * rd;\n      col = (idObj == 1) ? vec3 (1., 0., 0.) : ((idObj == 2) ? vec3 (0., 1., 0.) :\n         vec3 (0., 0., 1.));\n      col = mix (col, vec3 (1., 1., 0.), smoothstep (0.02, 0.03,\n         abs (abs (qHit.x - 0.3) - 0.05)) * (1. - smoothstep (0.95, 0.97, qHit.z)));\n      vn = FlyerNf (ro);\n      col = col * (0.3 + 0.1 * max (- dot (vn, sunDir), 0.) +\n         0.7 * max (dot (vn, sunDir), 0.)) +\n         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else {\n      ro += dstBld * rd;\n      vc = HexVor (vorScl * ro.xz);\n      vn = BldNf (ro);\n      hw = mod (ro.y + 0.5, 1.) - 0.5;\n      if (abs (hw) < 0.18 && vn.y < 0.01) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else {\n        c = 0.1 * floor (73. * mod (vc.w, 1.) + 0.5);\n        col = HsvToRgb (vec3 (0.1 + 0.8 * c, 0.3 + 0.5 * mod (25. * c, 1.), 1.));\n        if (ro.y > 0.1 - hBase) col *= (0.5 + 0.3 * mod (37. * c, 1.)) *\n           ((vn.y > 0.99) ? 1.2 : (1. - 0.5 * step (abs (hw), 0.25) * sign (hw)));\n        else col = mix (col, vec3 (1.) * (0.1 +\n           0.9 * step (abs (vc.x - 0.04), 0.02)), step (vc.x, 0.4));\n        col = col * (0.2 + 0.8 * max (0., max (dot (vn, sunDir), 0.))) +\n           0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n      col *= 1. + 0.6 * min (ro.y / hBase, 0.);\n      col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.4, 0.95, dstBld / dstFar));\n    }\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrkPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 12., t);\n}\n\nvec3 TrkVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrkAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 e;\n  e = vec2 (1., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 4.) *\n     (4. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\nvoid FlyerPM (float t, int isOb)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = TrkPath (t);\n  vel = TrkVel (t);\n  va = cross (TrkAcc (t), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = ((isOb > 0) ? 10. : 20.) * length (va) * sign (va.y);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col, gCol;\n  vec2 canvas, uv;\n  float az, el, zmFac, flyVel, vDir, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.17 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.45 * pi * mPtr.y;\n  }\n  tCur += 50.;\n  trkA = 0.2 * vec3 (1.9, 2.9, 4.3);\n  trkF = vec3 (0.23, 0.17, 0.13);\n  flyVel = 3.;\n  vDir = sign (0.5 * pi - abs (az));\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    t = flyVel * tCur + vDir * (3. + 5. * float (k));\n    FlyerPM (t, 0);\n    flyerMat[k] = flMat;\n    flyerPos[k] = flPos;\n    flyerPos[k].y += 0.8 * (2. * SmoothBump (0.25, 0.75, 0.25, mod (0.05 * t, 1.)) - 1.) - 1.;\n  }\n  t = flyVel * tCur;\n  FlyerPM (t, 1);\n  ro = flPos;\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.;\n  dstFar = 200.;\n  sunDir = normalize (vec3 (sin (0.02 * pi * tCur), 0.2, cos (0.02 * pi * tCur)));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * (rd * flMat);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col += GlareCol (rd, flMat * sunDir * vuMat, uv);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.05) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcz1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[889, 889, 913, 913, 1451], [1453, 1453, 1488, 1488, 1674], [1676, 1676, 1699, 1699, 1958], [1960, 1960, 1982, 1982, 2211], [2213, 2213, 2246, 2246, 2523], [2525, 2525, 2546, 2546, 2801], [2803, 2803, 2835, 2835, 3228], [3230, 3230, 3265, 3265, 4997], [4999, 4999, 5023, 5023, 5077], [5079, 5079, 5102, 5102, 5163], [5165, 5165, 5188, 5188, 5258], [5260, 5260, 5303, 5303, 5737], [5739, 5739, 5773, 5773, 6169], [6171, 6171, 6227, 6227, 7747], [7749, 7749, 7773, 7773, 8003], [8005, 8005, 8029, 8029, 8089], [8115, 8115, 8135, 8135, 8355], [8357, 8357, 8379, 8379, 8976], [8978, 8978, 9023, 9023, 9126], [9128, 9128, 9173, 9173, 9211], [9213, 9213, 9270, 9270, 9353], [9355, 9355, 9391, 9391, 9597], [9599, 9599, 9629, 9629, 9687], [9689, 9689, 9713, 9713, 9849], [9884, 9884, 9908, 9908, 9968], [9970, 9970, 9994, 9994, 10106], [10108, 10108, 10133, 10133, 10319], [10321, 10321, 10342, 10342, 10497]], "test": "untested"}
{"id": "tdGcRh", "name": "Catmull-Rom Splines", "author": "Danguafer", "description": "Catmull-Rom Spline.\n\nThe first and last point are considered control points thus they aren't rendered.", "tags": ["spline"], "likes": 24, "viewed": 1989, "published": 3, "date": "1602236037", "time_retrieved": "2024-07-30T20:41:21.193041", "image_code": "// Reference: https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html\n\n// Constants\n\n#define time (iTime/1.0)\n#define LINES 32\n#define STEP 1.0/float(LINES)\n\n#define POINTS 10\n#define MAX_POINTS POINTS\n\nconst float PI = acos(-1.0);\nconst float TAU = PI * 2.0;\n\n// Draw helpers\n\nvec2 p;\n\nfloat line(vec2 a, vec2 b) {\n\tvec2 v  = b-a;\n    vec2 p0 = p-a;\n    float k = min(length(p0)/length(v),1.0);\n    return smoothstep(4.0/iResolution.y,0.0,length(p0-k*v));\n}\n\nfloat point(vec2 o) { return smoothstep(10.0/iResolution.y,7.5/iResolution.y,length(p-o)); }\n\nvoid drawPoint(inout vec3 color, vec3 drawColor, vec2 p) {\n    color = mix(color, drawColor, point(p));\n}\n\nvoid drawPoints(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count; i++)\n        drawPoint(color, drawColor, p[i]);\n}\n\nvoid drawLine(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count - 1; i++) {\n        color = mix(color, drawColor, line(p[i], p[i+1]));\n    }\n}\n\nvec2 splineInterpolation(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float alpha = 1.0;\n    float tension = 0.0;\n    \n    float t01 = pow(distance(p0, p1), alpha);\n\tfloat t12 = pow(distance(p1, p2), alpha);\n\tfloat t23 = pow(distance(p2, p3), alpha);\n\n\tvec2 m1 = (1.0f - tension) *\n    \t(p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));\n\tvec2 m2 = (1.0f - tension) *\n    \t(p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));\n    \n\tvec2 a = 2.0f * (p1 - p2) + m1 + m2;\n\tvec2 b = -3.0f * (p1 - p2) - m1 - m1 - m2;\n\tvec2 c = m1;\n\tvec2 d = p1;\n\n\treturn a * t * t * t +\n           b * t * t +\n           c * t +\n           d;\n\n}\n\nfloat spline(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    float curve = 0.0;\n    vec2 a = p1;\n\n    for (int i = 1; i <= LINES; i++) {\n        vec2 b = splineInterpolation(p0, p1, p2, p3, STEP*float(i));\n        curve = mix(curve,1.0, line(a, b));\n        a = b;\n    }\n    \n    return curve;\n}\n\nvoid drawSpline(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count - 3; i++) {\n        color = mix(color, drawColor, spline(p[i], p[i+1], p[i+2], p[i+3]));\n    }\n}\n\nvec2[MAX_POINTS] deformedCircle(int count) {\n    vec2 p[MAX_POINTS];\n    for (int i = 0; i < count; i++) {\n        float a = float(i) / float(count) * TAU;\n        p[i] = vec2(3.0, 1.5) * vec2(cos(a), sin(a)) * (0.3 + 0.1 * sin(iTime) + 0.15 * sin(a * 3.456 + iTime));\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0.94);\n    \n    vec2 p[MAX_POINTS] = deformedCircle(POINTS);\n    \n    drawLine(color, vec3(0.0), p, POINTS);\n    drawPoints(color, vec3(0.0), p, POINTS);\n    drawSpline(color, vec3(1.0, 0.0, 0.0), p, POINTS);\n    \n\tfragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGcRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 338, 338, 481], [483, 483, 504, 504, 575], [577, 577, 635, 635, 682], [684, 684, 766, 766, 847], [849, 849, 929, 929, 1038], [1040, 1040, 1111, 1111, 1692], [1694, 1694, 1744, 1744, 1983], [1985, 1985, 2067, 2067, 2194], [2488, 2488, 2545, 2545, 2872]], "test": "untested"}
{"id": "tsVcRz", "name": "Levels fade out", "author": "Extinction_HD", "description": "Implementation of fade out between multiple levels", "tags": ["fade"], "likes": 2, "viewed": 320, "published": 3, "date": "1602233192", "time_retrieved": "2024-07-30T20:41:22.124551", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 heights = vec3(min(iMouse.y / iResolution.y, 0.6), 0.6, 0.8);\n    \n    const vec3 strengths = vec3(0.66, 0.3, 0.0);\n    \n    float localHeight = uv.y;\n    \n    int currentLevel = int(\n        step(heights[0], localHeight) + \n        step(heights[1], localHeight) + \n        step(heights[2], localHeight));\n    \n    float currentHeight = heights[currentLevel];\n    \n    const float fadeOut = 0.4;\n    float boundaryFactor = smoothstep(currentHeight - fadeOut, currentHeight, localHeight);\n    \n    int nextLevel = int(\n        step(heights[0] - fadeOut, localHeight) + \n        step(heights[1] - fadeOut, localHeight) + \n        step(heights[2] - fadeOut, localHeight));\n    \n    float currentStrength = currentLevel > 0 ? strengths[currentLevel - 1] : 1.0;\n    float nextStrength = nextLevel > 0 ? strengths[nextLevel - 1] : 1.0;\n    \n    float transientStrength = nextStrength;\n    for (int midLevel = nextLevel - 1; midLevel > currentLevel; --midLevel)\n    {\n        float midHeight = heights[midLevel];\n        float transientFactor = smoothstep(midHeight - fadeOut, midHeight, localHeight);\n        float midStrength = strengths[midLevel - 1];\n        transientStrength = mix(midStrength, transientStrength, transientFactor);\n    }\n    \n    float resultStrength = mix(currentStrength, transientStrength, boundaryFactor);\n    \n    fragColor = vec4(vec3(resultStrength), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1492]], "test": "untested"}
{"id": "wsycz1", "name": "MM - Raymarching mickey", "author": "MatMercer", "description": "Plis Disney don't sue me :(\nI wanted to rotate the mickey in xz axis but I was unable to do it. If you uncomment the 27 line and comment the 26 I try to transform the p.xz (axis I want to rotate) with a rotation transformation matrix, but doesn't works.", "tags": ["raymarching"], "likes": 2, "viewed": 269, "published": 3, "date": "1602218467", "time_retrieved": "2024-07-30T20:41:22.900476", "image_code": "#define MAX_STEPS 1024\n#define MIN_DIST 0.01\n#define MAX_DIST 100.0\n\n#define SHADOW_OUT_DIST 0.02\n\nmat2 rotateMat(float deg) {\n    float s = sin(deg);\n    float c = cos(deg);\n   \n    return mat2(c, -s, s, c);\n}\n\n// raymarch distance formulas for primitives\nfloat sphere(vec4 s, vec3 view) {\n    return length(view - s.xyz) - s.w;\n}\n\nfloat plane(float y, vec3 view) {\n    return view.y - y;\n}\n\nfloat getDist(vec3 p) {\n    float plane = plane(0.0, p);\n    \n    p.xy *= rotateMat(sin(iTime) * .5);\n    //p.xz *= rotateMat(sin(iTime) * .5); \n    \n    float head = sphere(vec4(0, 1, 6, 1), p);\n    float ear1 = sphere(vec4(-1.0, 2, 6, 0.8), p);\n    float ear2 = sphere(vec4(1.0, 2, 6, 0.8), p);\n    float eye1 = sphere(vec4(-0.3, 1.3, 5.05, 0.1), p);\n    float eye2 = sphere(vec4(0.3, 1.3, 5.05, 0.1), p);\n    float nose = sphere(vec4(0, 1, 5, 0.1), p);\n\n    \n    return min(head,\n               min(ear1, \n                   min(ear2, \n                       min(eye1, \n                           min(eye2,\n                               min(nose, \n                                   plane))))));\n}\n\n// raymarch main loop\nfloat rayMarch(vec3 orig, vec3 dir) {\n   \tvec3 curPoint;\n    \n    float dist = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        curPoint = orig + dir * dist;\n        \n        float minDist = getDist(curPoint);\n                \n        dist += minDist;\n        \n        if (minDist < MIN_DIST || minDist > MAX_DIST) break;\n    }\n    \n    return dist;\n}\n\n// normal calculation function\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 view) {\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(p - view);\n    vec3 n = getNormal(view);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = rayMarch(view + n * SHADOW_OUT_DIST, l);\n    if (d < length(p - view)) dif *= .5;\n    \n    return dif;\n}\n\n// shader light function\nfloat getLight(vec3 p) {\n    return (light(vec3(-6, 6, 4), p) * 0.5) + (light(vec3(3, 4, 3), p) * 0.5);\n}\n\n// main img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // center coords\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    vec3 camera = vec3(0, 1.3, 1);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));\n    float d = rayMarch(camera, dir);\n    //d /= 10.;\n\n    vec3 p = camera + dir * d;\n    \n    float dif = getLight(p);\n\tvec3 col = vec3(dif);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 126, 126, 210], [212, 257, 290, 290, 331], [333, 333, 366, 366, 391], [393, 393, 416, 416, 1094], [1096, 1118, 1155, 1155, 1479], [1481, 1512, 1536, 1536, 1734], [1736, 1736, 1768, 1822, 2057], [2059, 2084, 2108, 2108, 2189], [2191, 2203, 2260, 2281, 2631]], "test": "untested"}
{"id": "tsGczh", "name": "CA Paste", "author": "michael0884", "description": "Implementing perfect particle number conservation with cellular automaton particle tracking\nTook me some time to realize that the edge conditions in the step functions actually had a large effect, thus there are 2 Heaviside step functions here. ", "tags": ["particles", "ca"], "likes": 18, "viewed": 802, "published": 3, "date": "1602196017", "time_retrieved": "2024-07-30T20:41:23.784114", "image_code": "// Fork of \"CA Molecular dynamics\" by michael0884. https://shadertoy.com/view/3s3cWr\n// 2020-10-08 22:00:15\n\n// Fork of \"Landau Ginzburg fluid\" by michael0884. https://shadertoy.com/view/WlXBDf\n// 2020-09-21 21:03:05\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.3\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n    }\n    float rho = 0.001;\n    float c = 0.;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = floor(pos) + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        c += M0*K*data.w;\n        vel += M0*K*V0;\n    }\n\n   c /= rho;\n   vel /= rho;\n   vec3 vc = hsv2rgb(vec3(6.*atan(vel.x, vel.y)/(2.*PI), 1.0, rho*length(vel.xy)));\n   col.xyz = sin(vec3(1.,2.,3.)*smoothstep(0.,1.0,rho)*c);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.0\n#define R iResolution.xy\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define CI(x) smoothstep(1.0, 0.9, length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//Wyatt thermostat\n#define cooling 0.2\n\n//MD force\nfloat MF(vec2 dx, vec2 dv)\n{\n    return  -GS(0.73*dx) + (0.2*dot(dx,dv) + 0.25)*GS(0.5*dx);\n}\n\n\n//the step functions need to be exactly like this!! step(x,0) does not work!\nfloat Ha(vec2 x)\n{\n    return ((x.x >= 0.)?1.:0.)*((x.y >= 0.)?1.:0.);\n}\n\nfloat Hb(vec2 x)\n{\n    return ((x.x > 0.)?1.:0.)*((x.y > 0.)?1.:0.);\n}\n\n//particle grid\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "//particle distribution\nvec3 PD(vec2 x, vec2 pos)\n{\n    return vec3(x, 1.0)*Ha(x - (pos - 0.5))*Hb((pos + 0.5) - x);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    float C = 0.;\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tint M0 = int(data.z);\n        int M0H = M0/2;\n        \n        X0 += V0*dt; //integrate position\n        \n        //the deposited mass into this cell\n        vec3 m = (M0 >= 2)?\n            (float(M0H)*PD(X0+vec2(0.5, 0.0), pos) + float(M0 - M0H)*PD(X0-vec2(0.5, 0.0), pos))\n            :(float(M0)*PD(X0, pos)); \n        \n        //add weighted by mass\n        X += m.xy;\n        V += V0*m.z;\n      \tC += m.z*data.w;\n        //add mass\n        M += m.z;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n        C /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M = Ha(pos - (R*0.5 - R.x*0.15))*Hb((R*0.5 + R.x*0.15) - pos);\n        C = 0.5 + 0.5*sin(0.4*pos.x);\n    }\n    //initial condition\n    if(iFrame == 800)\n    {\n        C = 0.5 + 0.5*sin(0.4*pos.x);\n    }\n    \n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.49, 0.49)); \n    float box = sdBox((p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0.0, 0.0));\n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 normalize2(vec2 a)\n{\n    return all(equal(a, vec2(0.)))?vec2(0.):normalize(a);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    float C = data.w;\n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 Fa = vec2(0.);\n        range(i, -3, 3) range(j, -3, 3)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            vec2 dv = V0 - V;\n           \n            Fa += M0*MF(dx, dv)*normalize2(dx);\n        }\n        \n        vec2 F = vec2(0.);\n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F -= 0.00025*dx*GS(dx/80.);\n        }\n        \n       \t//gravity\n        F += 0.001*vec2(0,-1);\n        \n        //integrate velocity\n        V += (F + Fa)*dt/M;\n        \n        //Wyatt thermostat\n        X += cooling*Fa*dt/M;\n        \n        vec3 BORD = bN(X);\n        V += 0.5*smoothstep(0., 5., -BORD.z)*BORD.xy;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //save\n    X = X - pos;\n    U = vec4(ENCODE(X), ENCODE(V), M, C);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 415, 442, 442, 620], [648, 648, 676, 676, 736]], "test": "untested"}
{"id": "wdGczh", "name": "Simple Perlin Noise Test 2D", "author": "milesWaugh", "description": "noise", "tags": ["2d", "noise", "simple", "perlin"], "likes": 2, "viewed": 400, "published": 3, "date": "1602194725", "time_retrieved": "2024-07-30T20:41:24.656780", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.x + iTime/10.;\n    float col = 0.;\n    for(float s=50.; s>1.; s/=2.){\n    \tcol += texture(iChannel0,uv/s).r*(s/100.);\n    }\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 255]], "test": "untested"}
{"id": "wsyyzh", "name": "The portal", "author": "Endrju", "description": "Learning stuff", "tags": ["portal"], "likes": 1, "viewed": 311, "published": 3, "date": "1602193080", "time_retrieved": "2024-07-30T20:41:25.817677", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5f;\n        \n    float distance = length(uv);\n    vec3 col =  0.5 * cos(iTime + uv.yyy+vec3(11,5,8)) * distance;\n    fragColor = texture(iChannel0, vec2(distance + col.xy));\n\n    fragColor -= vec4(0.5, -0.1, -0.1, 0.);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 335]], "test": "untested"}
{"id": "wdGyzh", "name": "Mind dump buffer overflow", "author": "xenn", "description": "Alt + Down Arrow to restart (for full screen joy)", "tags": ["particles", "ca"], "likes": 2, "viewed": 345, "published": 3, "date": "1602188438", "time_retrieved": "2024-07-30T20:41:26.929703", "image_code": "// Fork of \"My virtual slime molds\" by michael0884. https://shadertoy.com/view/WtBcDG\n// 2020-07-24 21:29:48\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-0.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.17, 0.17);\n    vec3 col1 = vec3(0.5, 0.2, 0.2);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(01.0*vec3(0.21+sin(iTime*0.521),0.31+cos(iTime*0.15),0.1+sin(iTime*(0.219)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(02.0)));\n    col.w=01.50;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 11.5\n\n#define fluid_rho 0.20\n\n\n//mold stuff \n#define sense_ang 0.14325975283464746\n#define sense_dis 01.2750\n#define sense_force 0.251\n#define trailing 0200.10/cos(time*01.0)\n#define acceleration 0.051\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.0075042347503666*rho.x + 0.*rho.y; //gas\n    return 0.002*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.30\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(-.000*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.0)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 138, 138, 316], [318, 318, 354, 354, 404], [406, 406, 422, 422, 450], [452, 452, 497, 497, 1665]], "test": "untested"}
{"id": "tdycRh", "name": "First Time!", "author": "thepheer", "description": "Always wanted to cast some rays and finally did, the stuff is mindblowing. So, this is my progress so far, took me about a week, starting from being completely clueless about any raycasting stuff. Still have a lot of things to figure out, though.", "tags": ["raymarching", "sdf"], "likes": 46, "viewed": 915, "published": 3, "date": "1602187598", "time_retrieved": "2024-07-30T20:41:27.849245", "image_code": "// light, material, raymarching result\nstruct L { vec3 c; vec3 p; };\nstruct M { vec3 c; float r; float d; };\nstruct R { M m; vec3 p; float t; };\n\n// M mmin(M a, M b) { if (a.d < b.d) return a; return b; }\n// M mmax(M a, M b) { if (a.d > b.d) return a; return b; }\nM msmin(M a, M b, float k) {\n    float h = clamp(0.5 + 0.5*(a.d - b.d)/k, 0.0, 1.0);\n    return M(mix(a.c, b.c, h), mix(a.r, b.r, h), mix(a.d, b.d, h) - k*h*(1.0 - h));\n}\n\nM map(vec3 p) {\n    const vec2 n = vec2(0.0, 1.0);\n    mat3 r = rot(n.yxx, 0.3*iTime) * rot(n.xyx, 0.5*iTime) * rot(n.xxy, 0.7*iTime);\n    vec3 t = vec3(vec2(1.0, 1.5)*sin(vec2(0.6, 0.3)*iTime), 0.0);\n    return msmin(\n        M(vec3(1.0), 1.0, -sdBox(p, vec3(3.0, 1.5, 3.0))),\n        msmin(\n            M(vec3(1.0), 0.02, sdSphere(p + t, 1.0) + 0.001*prod3(sin(60.0*p))),\n            M(vec3(1.0), 0.98, sdBox(r*(p - t), vec3(0.75))),\n            1.0\n        ),\n        0.5\n    );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p) {\n    const vec3 k = vec3(1.0, -1.0, 1e-4);\n    return normalize(\n        k.xyy*map(p + k.xyy*k.z).d + \n        k.yyx*map(p + k.yyx*k.z).d + \n        k.yxy*map(p + k.yxy*k.z).d + \n        k.xxx*map(p + k.xxx*k.z).d\n    );\n}\n\nbool raymarch(vec3 rc, vec3 ro, vec3 rd, out R rr) {\n\t// rayconfig rc: threshold, near, far\n    for (rr.t = rc.y; rr.t < rc.z; rr.t += rr.m.d) {\n        rr.p = ro + rr.t*rd;\n        rr.m = map(rr.p);\n        if (rr.m.d < rc.x) return true;\n    }\n    return false;\n}\n\nvec3 color(vec3 p, vec3 n) {\n    const L lights[] = L[] (\n    \tL(vec3(3.0, 2.0, 1.0), vec3(-2.5, 1.0, 2.5)),\n        L(vec3(1.0, 2.0, 3.0), vec3(+2.5, 1.0, 2.5))\n\t);\n\n    vec3 c = vec3(0.0); // 0.002 * vec3(0.1, 2.0, 4.0);\n    for (int i = 0; i < 2; i++) {  \n        vec3 lp = lights[i].p - p;\n        float ll = length(lp);\n        vec3 ld = lp/ll;\n        float la = max(0.0, dot(ld, n)/exp(ll));\n        c += la*lights[i].c;\n    }\n    return c;\n}\n\nvec3 render(vec2 uv) {\n    vec3 rc = vec3(1e-3, 1e-2, 1e+1);\n    vec3 rt = vec3(1.8*uv,  0.0);\n    vec3 ro = vec3(1.4*uv, -2.0);\n    vec3 rd = normalize(rt - ro);\n    R rr;\n\n    vec3 c = vec3(0.0);\n    for (float r = 1.0; r > 1e-3 && raymarch(rc, ro, rd, rr);) {\n        // if (rr.m.d < 0.0) { c.r += r; break; }\n        vec3 n = normal(rr.p);\n        float a = rr.m.r*r;\n        c += a*rr.m.c*color(rr.p, n);\n        r -= a;\n        ro = rr.p;\n        rd = reflect(rd, n);\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 r = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = 2.0*xy/iResolution.xy - 1.0;\n    rgba = vec4(srgb(render(r*uv)), 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/distfunctions\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - 0.25*h*h/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + 0.25*h*h/k;\n}\n\n// https://gamedev.stackexchange.com/a/148088\nvec3 srgb(vec3 rgb) {\n    bvec3 t = lessThan(rgb, vec3(0.0031308));\n    vec3 a = 1.055*pow(rgb, vec3(1.0/2.4)) - 0.055;\n    vec3 b = 12.92*rgb;\n    return mix(a, b, t);\n}\n\nfloat prod3(vec3 v) {\n\treturn v.x*v.y*v.z;\n}\n\nmat3 rot(vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 a = axis*(1.0 - c);\n    vec4 b = vec4(axis*s, c);\n    vec2 n = vec2(-1.0, 1.0);\n    return mat3(\n        axis.xyx*a.xxz + b.wzy*n.yxy,\n        axis.yyz*a.xyy + b.zwx*n.yyx,\n        axis.xzz*a.zyz + b.yxw*n.xyy\n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdycRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 264, 292, 292, 434], [436, 436, 451, 451, 919], [921, 967, 988, 988, 1210], [1212, 1212, 1264, 1303, 1477], [1930, 1930, 1952, 1952, 2425], [2427, 2427, 2467, 2467, 2607]], "test": "untested"}
{"id": "WdyyR1", "name": "SoundEclipse MIC", "author": "FlavioMoreir4", "description": "a twist on DuckMonster's SoundEclipse (https://www.shadertoy.com/view/4tGXzt), adding some rotation.\nIt looks better as a visualization in virtualdj with the rotation and beatmove.", "tags": ["visualization", "mic", "virtualdj"], "likes": 7, "viewed": 548, "published": 3, "date": "1602178535", "time_retrieved": "2024-07-30T20:41:28.730887", "image_code": "// Fork of \"SoundEclipse rpm\" by sclavel. https://shadertoy.com/view/ls3BDH\n// 2020-10-08 17:32:10\n\n// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 329, 350, 350, 519], [521, 521, 545, 545, 595], [597, 597, 626, 626, 719], [721, 721, 757, 757, 968], [970, 970, 1005, 1005, 1069], [1071, 1071, 1113, 1113, 1580], [1582, 1582, 1633, 1633, 1885], [1888, 1888, 1945, 1945, 2378]], "test": "untested"}
{"id": "WsGyRh", "name": "Elipse Mic", "author": "FlavioMoreir4", "description": "Capture Mic", "tags": ["audio"], "likes": 12, "viewed": 900, "published": 3, "date": "1602174439", "time_retrieved": "2024-07-30T20:41:29.830946", "image_code": "// Fork of \"Audio Eclipse\" by airtight. https://shadertoy.com/view/MdsXWM\n// 2020-10-08 16:15:41\n\n#define SOUND_MULTIPLIER 1.0\nconst float dots = 40.; //number of lights\nconst float radius = .25; //radius of light ring\nconst float brightness = 0.02;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\t\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 c=vec3(0,0,0.1); //background color\n\t\t\n    for(float i=0.;i<dots; i++){\n\t\n\t\t//read frequency for this dot from audio input channel \n\t\t//based on its index in the circle\n\t\t//float vol =  texture(iChannel0, vec2(i/dots, 0.0)).x;\n        float vol = SOUND_MULTIPLIER * texture(iChannel0, vec2(i/dots, 0.0)).x;\n\t\tfloat b = vol * brightness;\n\t\t\n\t\t//get location of dot\n        float x = radius*cos(2.*3.14*float(i)/dots);\n        float y = radius*sin(2.*3.14*float(i)/dots);\n        vec2 o = vec2(x,y);\n\t    \n\t\t//get color of dot based on its index in the \n\t\t//circle + time to rotate colors\n\t\tvec3 dotCol = hsv2rgb(vec3((i + iTime*10.)/dots,1.,1.0));\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tc += b/(length(p-o))*dotCol;\n    }\n\t\n    //black circle overlay\t   \n\tfloat dist = distance(p , vec2(0));  \n\tc = c * smoothstep(0.26, 0.28, dist);\n\t \n\tfragColor = vec4(c,1);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 272, 293, 293, 462], [466, 466, 523, 523, 1503]], "test": "untested"}
{"id": "tdtyDs", "name": "Asymmetric Hexagon Landscape", "author": "Shane", "description": "A landscape of extruded asymmetric hexagonal blocks with offset vertices tailored to resemble randomly packed polygons.", "tags": ["voronoi", "terrain", "hexagon", "city", "extrude"], "likes": 171, "viewed": 7228, "published": 3, "date": "1602165188", "time_retrieved": "2024-07-30T20:41:31.131469", "image_code": "/*\n\n    Asymmetric Hexagon Landscape\n    ----------------------------\n\n\tJust for fun, I coded up a landscape of extruded asymmetric hexagonal blocks \n    tailored to resemble randomly packed polygons. It's more of a proof of concept \n    than anything else. I think it runs well enough, and I've documented the code \n    to a certain degree, but I wouldn't take any of it too seriously. I had the \n    idea to do this when I was in Bavaria back in March, so that provided minor \n    inspiration for the design. It's rendered in an abstract low-poly cartoon style.\n\n\tThe code was hastily put together with old projects and makes use of something\n\tI constructed in 2D a long time ago when attempting to produce a fast random \n    Delaunay pattern. The idea is simple in concept, since it's nothing more than a \n    grid of hexagons with offset vertices. The Delaunay pattern I was after turned \n    out to be less interesting than I'd hoped for, due to the restricted offsets \n    involved. However, I always figured it'd look pretty cool in extruded form. The \n    thing holding me back was the usual speed constraints. In fact, speed was not \n    the primarily concern, but rather the painful buffer setup and wrapping \n    considerations required to make it fast. By the way, apologies in advance for\n\tthe longer compile time; I'll try to get that down later.\n\n\tMattz and IQ have already posted some pretty cool hexagon related traversals,\n\tand I'm pretty sure Abje -- who puts together a lot of clever stuff that slips\n\tunder the radar -- has already produced a Voronoi prism cell traverser, along \n    with a couple of other people. Fizzer's basically constructed every traversal \n    at one point or another, so I guess I'm saying that this isn't an entirely new \n    concept. Having said that, it is unique in the sense that it consists of \n    rounded asymmetric hexagons, plus it's a buffer-stored raymarched field that \n    can render pretty quickly... if you have a machine that works well reading \n    textures. I won't go as far as to say that it's an extruded straight edged \n    Voronoi grid, but it definitely has that kind of feel to it.\n\t\n    There are too many possible improvements and enhancements to name. There are \n    provisions within the code for neighboring hexagon checks, which allows for all \n    kinds of features like bridges, stairs, etc, but of course that would add to \n    the complexity. Either way, I'd like to do something along those lines at some \n    stage. For anyone interested, I'll put up a simple version featuring just the\n\toffset hexagons soon.\n\n    \n\n\tOther examples:\n\n\t// I've always been a fan of Tomkh's work.\n    Voronoi Column Tracing -  Tomkh \n\thttps://www.shadertoy.com/view/4lyGDV\n    Base on:\n    Reactive Voronoi - Glk7\n    https://www.shadertoy.com/view/Ml3GDX\n    \n\t// Here's a proper Voronoi traverser. Like all TekF's stuff, it's \n    // very stylish and confusingly fast. :)\n    TekF - Infinite City \n\thttps://www.shadertoy.com/view/4df3DS\n\n\n*/\n\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), .25*(sin(z*.875)*.5 + .5));\n}\n\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// The height map. It was orginally supposed to be a fast texture call, but then\n// I was insistent on creating a valley that followed the camera path, which would\n// be pretty difficult to encode into a repeat texture... Anyway, it's slower now,\n// but within acceptable ranges.\nfloat hmBlock(in vec2 p){ \n    \n    //vec2 q = p; \n    \n    // Wrapping things around the camera path.\n    vec2 pth = path(p.y);\n    p -= pth; // Y is the Z coordinate here.\n    \n    float d = abs((p.x + .5) - .5)*2.;\n    \n    // Scaling by 1/16 and snapping to repeat texture pixels. Alternatively, you \n    // can change the cube map filter to \"nearest\" and save a calculation, which\n    // is what I've done.\n    p /= 16.;\n    // p = (floor(p*1024./16.) + .5)/1024.;  \n    \n    // Retrieving the height value from the precalculated wrapped texture map.\n    float h = tx5(iChannel0, p).x; \n                    \n    // Carving out a path.\n    h = mix(h + pth.y,  h/1.5 + pth.y/2., 1. - smoothstep(0., .75, d - .15));\n    \n    // Quantizing the height levels. More expensive, but it looks a little neater.\n    #ifdef QUANTIZE_HEIGHT\n    h = floor(h*(LEVELS + .999))/LEVELS; \n    #endif\n    h = max(h, WLEV/LEVELS);\n/*\n    if(h<= WLEV/LEVELS + .001) {\n            \n            float sf = dot(sin(q*8. - cos(q.yx*16. + iTime*2.)), vec2(.012)) - .024;\n            //h += sf;\n    }\n*/\n    return h;  \n}\n\n\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n \n// Global vertices, local coordinates of the offset hexagon cell, plus the extruded \n// face information. It's lazy putting them here, but I'll tidy them up later.\nvec4[3] gV;\nvec2 gP;\nfloat d2D;\n\n\nvec4 blocks(vec3 q){\n    \n    \n    \n    // Pulling in the 4 precalculated offset values from their respective\n    // cube map faces.\n    //\n    // By the way, calculating the minimum 2D face distance, then using it to\n    // render the extruded block doesn't work... It'd be nice, but you have to\n    // compare all 4 extruded blocks... It's obvious, yet if I haven't done this\n    // for a while, it's the first thing I try. :D\n    vec2 uv = (floor(q.xy*1024.) + .5)/1024.;\n    vec4 p40 = tx0(iChannel0, uv);  // The 2D distance fields.  \n    // Precalculated heights. These would have tripled the speed, but\n    // unforturnately weren't practical for this particular example.\n    //vec4 p45 = tx5(iChannel0, uv); \n\n    #ifndef QUANTIZE_WATER\n    // Continuous water levels, meaning the water appears as a wavy coninuous plane.\n    float sf = dot(sin(q*8. - cos(q.zxy*16. + iTime*2.)), vec3(.006)) - .018;\n    #endif\n    \n    // Block dimension: Length to height ratio with additional scaling. By the way,\n    // I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    // that gives you proper scaled hexagons. One reason is that they're mutated by\n    // the offset vertices anyway, and the main one is that it makes wrapping more\n    // difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n\n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    // Pointed top.\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif   \n  \n\n    d2D = 1e5;\n    \n    float hexH = 0.; // Hexagon pylon height.\n    \n    \n\n    // Height scale.\n    const float hs = .6;\n\n\n    // Initializing the global vertices and local coordinates of the hexagon cell.\n    gV = vec4[3](vec4(0), vec4(0), vec4(0));\n    gP = p;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n        \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec4[3] vert = vID;\n\n        \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n         \n        vec4 vrt0 = idi.xyxy + vert[0]/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n         \n        const float vo = .15;\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        //vert[3] += vrt1.zw*vo;\n        //vert[4] += vrt2.xy*vo;\n        //vert[5] += vrt2.zw*vo;\n        #endif\n \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy;\n\n        \n        // Scaling the ID.\n\t    idi *= s;\n         \n        \n        // Offset hexagon center.\n        //vec2 inC = vec2(0);\n        // Preferred, but not necessary and it's a huge bottleneck, which surprises me.\n        //vec2 inC = (vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)/6.;\n        //vec2 idi1 = idi + inC;\n        \n        // Stored 2D rounded offset hexagon face distance information. Without this, \n        // the example would fry your GPU.\n        float face1 = p40[i];\n        // float face1 = sdPoly(p, vert); \n  \n        \n        float h1 = hmBlock(idi); //p42[i] For future stored heights.\n      \n        // Animating the water levels. I added this at the last minute, so there'd\n        // be better ways to go about it.\n        if(h1<= WLEV/LEVELS + .001) {\n            \n            #ifdef QUANTIZE_WATER\n            float sf = dot(sin(idi*8. - cos(idi.yx*16. + iTime*2.)), vec2(.012)) - .024;\n            #endif\n            h1 += sf;\n        }\n\n        h1 *= hs; // Height scaling.\n        \n        // Extruded offset hexagon.\n        float face1Ext = opExtrusion(face1, (q.z - h1), h1); \n        \n        face1Ext += max(face1, -.015)*.5;\n         \n        // Adding the top to the heigher pylons to act as roofs.\n        #ifdef ARID\n        if(h1>.4) face1Ext += face1*.35;\n        #else\n        if(h1>.4) face1Ext += face1*(h1*.6 + .25); \n        #endif\n\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(face1Ext<d){\n            d = face1Ext;\n            id = idi;\n            hexH = h1;\n       \n            \n            // Setting the vertices and local coordinates.\n            gV = vert;\n            gP = p;\n            \n            d2D = face1;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, hexH);\n}\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = p.y;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p.xzy);\n    gID = d4; // Individual block ID.\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.1) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.5 : d*.75; \n        //t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n    \n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0011;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        \n        // Note the ray shortening hack here. It's not entirely accurate, but reduces\n        // shadow artifacts slightly for this particular stubborn distance field.\n        t += clamp(d*.8, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(sca>1e5) break; // Compiler related.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831589))*43758.5453), fract(sin(mod(h + s.x, 6.2831589))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    //p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.4, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c); // Redish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n}\n\n// Window distance field.\nfloat distW(vec2 p, float sc){\n    \n    // Some hastily constructed arch windows consisting\n    // of A square with a semi circle on top.\n    p.y -= -sc*1.25/3.;\n    float ci = length(p - vec2(0, sc*1.25)) - sc;\n    float sq = sBox(p, vec2(sc, sc*1.25));\n    return min(ci, sq);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 1.15, iTime); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.2, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    \n    // Light positioning. Near the camera.\n \tvec3 lp = ro + vec3(-.185, 0, -.625);// Put it a bit in front of the camera.\n    \n    \n    // Moving the camera along the path.\n\tro.xy += path(ro.z); \n    lk.xy += path(lk.z); \n    // Artificially moving the light with the camera to give it point light and distant \n    // light qualities... Not accurate, but good enough for the purpose of the example.\n    lp.xy += path(lp.z); \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2(path(ro.z).x/32.);\n\n    // Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n    \n    vec2 svP = gP;\n    vec2[6] svV = vec2[6](gV[0].xy, gV[0].zw, gV[1].xy, gV[1].zw, gV[2].xy, gV[2].zw);\n    //float svH = gH;\n    \n    float svD2D = d2D;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            \n            // Colored block, for debug purposes.\n            //vec3 rCol = .5 + .45*cos(6.2831*(svGID.w)/2. + vec3(2, 1, 0) + 2.);//hash21(svGID.yz)\n             \n            // Weighted center offset, so to speak.\n            //vec2 dt = (svV[0] + svV[1] + svV[2] + svV[3] + svV[4] + svV[5])/6.;\n       \n            \n            // Coloring, based on extruded hexagonal block height. \n            // It was a bit fiddly, but none of it was difficult...\n            // On second thoughts, I didn't enjoy painting the windows\n            // on the sides of the offset hexagons, but the rest was OK. :)\n            \n            // Hexagon pylon face ring.\n            vec3 tCol;\n            float hex = svD2D; //sdPoly(svP, svV);\n            hex = max(abs(hex), abs(sp.y - svGID.w*2.)) - .001;\n             \n            \n            \n            // This looks like a bit of a mess, but it's pretty simple: Each \n            // pylon has a face top, and some sides. There are three different\n            // height levels, which have different top and side colors. The\n            // top level represents the buildings, the middle represents the\n            // the surrounding land, and the bottom represents water. The coloring\n            // is common sense.\n            \n            \n            // Building colors, depending on the Bavarian looking landscape \n            // or the arid one. By the way, the define can be found in the\n            // \"Common\" tab.\n            #ifdef ARID\n            float ra = hash21(svGID.yz + .53);\n            vec3 rnd2 = vec3(ra, ra*.8, ra*ra*.5);\n            \n            texCol = vec3(1, .98, .9);\n            tCol = vec3(1, .45, .4); \n            //tCol = vec3(.85, .6, .45);\n            texCol = clamp(texCol*.9 + rnd2*.2, 0., 1.);\n            tCol = clamp(tCol*.9 + rnd2*.2, 0., 1.);\n            #else\n            float ra = hash21(svGID.yz + .53);\n            vec3 rnd2 = vec3(ra, ra*.9, ra*.8);\n            \n            texCol = vec3(1, .98, .95);\n            tCol = vec3(1, .2, .2);\n            texCol = clamp(texCol*.8 + rnd2*.4, 0., 1.);\n            tCol = clamp(tCol*.8 + rnd2*.4, 0., 1.);\n            #endif\n            \n           \n            // Grass colors.\n            if(svGID.w<.4) { \n                \n                // tCol = mix(tCol, vec3(1)*dot(tCol, vec3(.299, .587, .114)), 1.);\n                \n                #ifdef ARID\n                texCol = vec3(.8, .6, .45)*vec3(1, 1.05, .95);\n                tCol = vec3(.7, .5, .4)*vec3(1, 1.05, .95); \n                //texCol = mix(texCol, vec3(1)*dot(tCol, vec3(.299, .587, .114)), .2);\n                tCol = mix(tCol, vec3(1)*dot(tCol, vec3(.299, .587, .114)), .2);\n                texCol = clamp(texCol*.9 + rnd2*.2, 0., 1.);\n                \n               \n                tCol = clamp(tCol*.9 + rnd2*.2, 0., 1.);\n                #else\n                texCol = vec3(.8, .5, .3);\n                tCol = vec3(.35, .65, .3);//vec3(.8, .5, .3);\n                texCol = clamp(texCol*.8 + rnd2*.4, 0., 1.);\n                tCol = clamp(tCol*.8 + rnd2*.4, 0., 1.);\n                #endif\n                \n                \n                 \n            }\n            \n            //tCol *= vec3(1.4, 1.3, 1.1);\n            //texCol = mix(texCol*vec3(1.4, 1.3, 1.1), tCol, .5);\n            \n            \n            // Water colors.\n            if(svGID.w<= WLEV/LEVELS*.6 + .001) { \n                texCol = vec3(.35, .65, 1);\n                tCol = vec3(.25, .5, 1);\n                \n                #ifdef ARID\n                texCol = clamp(texCol*.85 + rnd2.zyx*.3, 0., 1.)*vec3(.9, .95, 1);\n                tCol = clamp(tCol*.85 + rnd2.zyx*.3, 0., 1.)*vec3(.9, .95, 1);\n                #else\n                texCol = clamp(texCol*.9 + rnd2.zyx*.2, 0., 1.)*vec3(.8, .9, 1);\n                tCol = clamp(tCol*.9 + rnd2.zyx*.2, 0., 1.)*vec3(.8, .9, 1);\n                #endif\n            }\n            \n            \n            // Extra random colors, just to mix things up. It's a simple trick to\n            // to make colors just a little more interesting.\n            vec3 rnd3 = vec3(hash21(svGID.yz + .73), hash21(svGID.yz + .51), hash21(svGID.yz)) - .5;\n            texCol = clamp(texCol + rnd3*.1, 0., 1.);\n            tCol = clamp(tCol - rnd3*.1, 0., 1.);\n              \n            // Applying the top face color and the side color.\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., .002, -(sp.y - svGID.w*2.)))*1.);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .002, hex)));\n           \n            \n            \n            // Painting the window on the sides of the top level hexagons. My brain was \n            // fighting me on this every step of the way, so I'm glad it's over. :D\n            float win = 1e5;\n            \n            if(svGID.w>.4){ \n                \n                \n                //vec2 ctr = (svV[0] + svV[1] + svV[2] + svV[3] + svV[4] + svV[5])/6.;\n\n                for(int j = 0; j<6; j++){\n                    \n                    \n                    // Random window ID.\n                    float wRnd = hash21(svGID.yz + floor((sp.y - svGID.w*2.)/(1./LEVELS*.6*2.)) + float(j));\n                    \n                    // Skip the occasional window.\n                    if(wRnd<.35) continue;\n\n                    // Current and next vertices.\n                    vec2 g = svV[j];\n                    vec2 g1 = svV[(j + 1)%6];\n                    //vec2 g2 = svV[(j + 5)%6];\n                    // Tangent normal.\n                    vec2 nj = normalize(g1 - g).yx*vec2(1, -1);\n\n                    // 3D hexagon center position.\n                    vec3 cv = vec3(svP.x, \n                                   mod(sp.y - svGID.w*2., 1./LEVELS*.6*2.) - .5/LEVELS*.6*2., \n                                   svP.y);\n               \n                    // Mid edge position and angle.\n                    vec2 gg = mix(g, g1, .5);\n                    float ang = atan(gg.y, gg.x);\n                    \n                    // Polar coordinates.\n                    vec2 spos = vec2(cos(ang), sin(ang))*length(gg);\n                    vec2 newP = rot2(-atan(nj.x, nj.y))*(svP - spos);\n                    \n                    // Window base and height.\n                    cv.xy = vec2(max(abs(newP.x), abs(newP.y)), cv.y);\n                     \n                    // Create the window for this particular hexagonal side.\n                    float wSize = hash21(svGID.yz + .71)*.075 + .2;\n                    win = min(win, distW(cv.xy, 1./LEVELS*.6*wSize*8.*GSCALE.x));\n\n                }\n                \n                // Render the windows.\n                win = max(win, sp.y - svGID.w*2.);\n                texCol = mix(texCol, vec3(.1, .05, .03), (1. - smoothstep(0., .003, win - .002))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .003, win));\n                texCol = mix(texCol, vec3(.1, .05, .03), 1. - smoothstep(0., .003, win + .005));\n                 \n            }\n  \n  \n            // Adding a bit of texture.\n            vec3 tx = tex3D(iChannel1, sp*4., sn);\n            tx = smoothstep(.0, .5, tx);\n            texCol *= tx*.6 + .6;\n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        } \n        \n       \n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.0, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*1.35; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Combining the above terms to procude the final color. I'm applying more of a\n        // conventioning shadow shade, which usually entails multiplying it by the \n        // diffuse component. Sometimes, I'll apply it to everything.\n        col = texCol*(diff*sh + ao*.15 + .05 + vec3(1, .9, .7)*fre*.1);\n       \n        \n        // Cheap environmapping for the water.\n        if(svGID.w<= WLEV/LEVELS*.6 + .001) {\n            vec3 cTex = envMap(reflect(rd, sn));\n            col *= (.85 + cTex*1.5);\n        }\n        \n        \n        // Applying the ambient occlusion and attenuated light.\n        col *= ao*atten;\n\t\n\t}\n    \n    // Applying some fog on the horizon.\n    vec3 fog = mix(vec3(1, .9, .5), vec3(.5, .7, 1), rd.y*.5 + .5);\n    col = mix(col, fog, smoothstep(0., .99, t/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    // Well, close to greyscale, but not quite. :)\n    col = vec3(1.05, 1, .95)*mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .9);\n    #endif\n\n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n// Producing hexagons with offset vertices can be a little painful, but it's \n// doable. Regular hexagon grids are almost trivial, but don't really suit this\n// example. Either way, comment this out to see.\n#define OFFSET_VERTICES\n\n// Changing the Bavarian look to a Mediterrainean one... Actually, with more of a \n// limestone sheen, it'd remind me slightly of the super crowded Maltese coastline.\n//#define ARID\n\n// Quantizing the height levels. More expensive, if not precalated, but it looks \n// a little neater -- Windows line up with the terraced levels, etc.\n#define QUANTIZE_HEIGHT\n\n// Quantize the water level, meaning make each water block move independently... Or \n// is it discreetize, or perhaps noncontinuous? Either way, you know what I mean. :)\n#define QUANTIZE_WATER\n\n// Grayscale, for that artsy look. Well, it's close to greyscale, but not quite. :)\n//#define GRAYSCALE\n\n\n// Quantization levels.\n#define LEVELS 19.\n#define WLEV 7.22 //floor(LEVELS*.38)\n\n\n\n// Work around for the time variable.\nfloat gTime = 0.;\nvoid setTime(float tm){ gTime = tm; }\n    \n\n\n\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly.\nfloat repSc = 1024./32.;\n\n// This sets the scale of the extruded shapes. Because of the way I've calculated\n// things, the scale needs to be even divisors and each term needs to be equal --\n// I use it in other applications where I can use two different numbers though. \n// As above, if you choose this option, a reset will be necessary. Ie. Hit the \n// back button.\n#define GSCALE vec2(1./8.)\n \n// Flat top hexagon.\n#define FLAT_TOP\n#ifdef FLAT_TOP\n// Vertices and mid edge points: Clockwise from the left.\nvec4[3] vID = vec4[3](vec4(-2./3., 0, -2./6., .5), vec4(2./6., .5, 2./3., 0), vec4(2./6., -.5, -2./6., -.5)); \nvec4[3] eID = vec4[3](vec4(-.5, .25, 0, .5), vec4(.5, .25, .5, -.25), vec4(0, -.5, -.5, -.25));\n#else\n// Vertices and mid edge points: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec4[3] vID = vec4[3](vec4(-.5, -2./6., -.5, 2./6.), vec4(0, 2./3.,.5, 2./6.), vec4(.5, -2./6., 0, -2./3.));\nvec4[3] eID = vec4[3](vec4(-.5, 0, -.25, .5), vec4(.25, .5, .5, 0), vec4(.25, -.5, -.25, -.5));\n#endif\n\n////////\n\n// Reading from various cube map faces.\nvec4 tx0(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(-.5, fract(p.yx) - .5), 0.);\n    //return texture(tx, vec3(-.5, fract(p.yx) - .5));\n}\n/*\nvec4 tx1(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(p.x, -.5, p.y), 0.);\n    //return texture(tx, vec3(p.x, -.5, p.y));\n}\n*/\nvec4 tx5(samplerCube tx, vec2 p){    \n\n   \n    return textureLod(tx, vec3(fract(p) - .5, .5), 0.);\n    //return texture(tx, vec3(fract(p) - .5, .5));\n}\n\n/*\nvec4 tx1B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(p.x, -.5, p.y), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n*/\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n/*\n// IQ's vec2 to float hash.\nvec2 hash22B(vec2 p){ \n   \n    p = (floor(p*1024.) + .5)/1024.;\n    p = mod(p*repSc*GSCALE*2., repSc);\n    p = vec2(dot(p, vec2(27.619, 113.583)), dot(p, vec2(57.527, 85.491)));\n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    \n    //return sin(p*6.2831853 + gTime);//mix(p, sin(p*6.2831853 + iTime), .35);\n    \n}\n*/\n// Based on IQ's hash formula.\nvec4 hash42B(vec4 p){ \n\n    p = (floor(p*1024.) + .5)/1024.;\n  \n    p = mod(p*repSc*GSCALE.x*2., repSc);\n   \n    p = vec4(dot(p.xy, vec2(27.619, 113.583)), dot(p.xy, vec2(57.527, 85.491)),\n             dot(p.zw, vec2(27.619, 113.583)), dot(p.zw, vec2(57.527, 85.491)));\n                                                  \n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    \n    //return sin(p*6.2831853 + gTime);//mix(p, sin(p*6.2831853 + iTime), .35);\n    \n}\n\n/*\n// IQ's vec2 to float texture hash.\nvec2 hash22T(sampler2D tx, vec2 p){ \n    \n    //   p = (floor(p*1024.) + .5)/1024.;\n    return textureLod(tx, p, 0.).xy;\n    \n}\n*/ \n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    p = mod(p, repSc);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + gTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n\n// Height map. Just a couple of gradient noise layers. \n// By the way, because this is precalculated, you could\n// make this as extravagent as you wished.\nfloat hm(in vec2 p){ \n\n    p *= repSc;\n    \n    // p = (floor(p*1024.) + .5)/1024.;\n    //p /= 24.;\n      \n    return n2D3G(p)*.5 + .5;\n \n    //return (n2D3G(p)*.66 + n2D3G(p*2.)*.34)*.5 + .5;\n \n    \n}\n\n// Height map value, which is just the pixel's greyscale value.\n//float hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .002;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV 6\n//\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n/*\n// This is a bound. Technically, it's not a proper distance field, but for\n// this example, no one will notice. :)\nfloat sHexS(in vec2 p, in vec2 b){\n    \n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5 - b.x, p.y - b.y);\n    //return max(p.y*.8660254 + p.x*.5, p.x) - b.x;;\n}\n*/\n\n \n\n\n\n", "cube_a_code": "\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed objects.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\n// For a 2D extruded block tiling four objects are needed. For the Cairo tiling,\n// each block needs to be subdivided into two seperate pentagonal pieces, so \n// that's eight pentagon distances all up. Since there are no vec8 containers in \n// WebGL, we need to make one. By the way, for regular 2D Cairo tiles, you only \n// need four or even two, depending what you're trying to do.\n//\nstruct vect8{ vec4 distA; vec4 distB; vec4 distC; };\n\n\nvect8 df(vec2 q){\n    \n    \n    // Block dimension: Length to height ratio with additional scaling. By the way,\n    // I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    // that gives you proper scaled hexagons. One reason is that they're mutated by\n    // the offset vertices anyway, and the main one is that it makes wrapping more\n    // difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n   \n\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID.\n    vec2 cntr = vec2(0);\n\n    \n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif\n    \n    \n    vect8 tile;\n\n    // Height scale. Not used here.\n    //const float hs = .15;\n\n   \n    for(int i = min(iFrame, 0); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.; \n        \n        p = q.xy; // Local coordinates.\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Hexagon vertices. \n        vec4[3] vert = vID; \n        \n        #ifdef OFFSET_VERTICES\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        const float vo = .15;\n        vec4 vrt0 = idi.xyxy + vert[0]/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        #endif \n        \n        // Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy; \n        \n        // Scaling the ID.\n\t    idi *= s;\n \n  \n          \n        // Hexagon vertices.\n        vec2[6] v1 = vec2[6](vert[0].xy, vert[0].zw, vert[1].xy, vert[1].zw, vert[2].xy, vert[2].zw);\n        \n\n        // Moving the vertices in to help create rounded hexagons. Rounded offset hexgons can\n        // be created by simply adding a factor to the distance field. Unfortunately, in a \n        // packed grid, that would create overlap, so it's necessary to move the points in\n        // first, then add the amount. This is less trivial, as you can see, but is just a\n        // bit of trigonometry. The following is robust, but was something I came up with on\n        // the spot, so if anyone knows of a more elegant way, feel free to let me know.\n        // Remember that this is just a one-off precalculation, so speed isn't a factor.\n        const float ndg = .0175*8.*GSCALE.x;\n        vec2[6] tmpV;\n        \n        for(int j = min(iFrame, 0); j<6; j++){\n            \n            // Vertices and flanking neighbors.\n            vec2 g = v1[j];\n            vec2 g1 = v1[(j + 1)%6];\n            vec2 g2 = v1[(j + 5)%6];\n            vec2 nj = normalize(g1 - g); // Tangent vector.\n         \n            // Move the vertices in the direction of the tangent vector\n            // by the nudge factor.\n            vec2 v1 = g - g1;\n            vec2 v2 = g - g2;\n            // Angle between vectors.\n            float ang = acos(dot(v1, v2)/length(v1)/length(v2));\n            float sl = ndg/tan(ang/2.);\n            tmpV[j] = g + sl*nj + ndg*nj.yx*vec2(1, -1);\n            \n            if(dot(v1, vec2(1))>1e8) break; // Fake break to get compile time down.\n        }\n                               \n        v1 = tmpV;                 \n\n        float face1 = sdPoly(p, v1);\n        // float face1 =  sHexS(p, scale/2.);\n        face1 -= ndg*.9;\n        tile.distA[i] = face1;\n        \n        // No precalculated heights for this example, since we'll be reading\n        // from a precalculated texture in the \"Image\" tab.\n        /*\n        // Using the original outer vertices for the offset factor.\n        vec2 inC = vec2(0);//(vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)/6.;\n        vec2 idi1 = idi + inC.xy;\n        float h = hm(idi1);\n        tile.distB[i] = h;\n        */\n        \n        \n    }\n    \n    // Return the tile struct.\n    return tile;\n\n}\n\n\n// Cube mapping for face identification - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    \n    // Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n  \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed just the once upon initialization.\n    //if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    //\n    // IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    // I'm not sure how he figured this out, but he pretty much knows everything. :D\n    //\n    // If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    // you wish to initialize. In this case, I'm precalculating an expensive distance\n    // field and storing it in some of the cube map faces.\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        // INITIALIZING.\n        \n        // Construct a distance field, then store it.\n    \tvect8 d = df(uv);\n        \n        if(faceID == 0) col = d.distA; // Distance fields.\n        //if(faceID == 1) col = d.distB; // Pylon heights.\n        if(faceID == 5) col = vec4(1)*hm(uv);//d.distB; // Pylon heights.\n    \n        \n        //repSc = 1024.;\n        //if(faceID == 5) {\n            //col = vec4(1)*hm(uv*repSc);\n        //}\n     \n    }\n    else {\n        if(faceID == 0) col = tx0(iChannel0, uv);\n        //if(faceID == 1) col = tx1(iChannel0, uv);\n        if(faceID == 5) col = tx5(iChannel0, uv);\n        \n    }\n\n\n    // Store in the cube map.\n    fragColor = col;\n    \n}", "cube_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3133, 3236, 3258, 3286, 3361], [3365, 3519, 3567, 3869, 4778], [4782, 5062, 5087, 5164, 6160], [12396, 12419, 12437, 12456, 12718], [12722, 12743, 12779, 12828, 13301], [13939, 14130, 14182, 14299, 15786], [15789, 15941, 15977, 15977, 16280], [16282, 16425, 16446, 16446, 16824], [16826, 17125, 17145, 17145, 17477], [17479, 17505, 17535, 17642, 17785]], "test": "untested"}
{"id": "wsKyzR", "name": "hello gurkes", "author": "gurkeclub", "description": "1st attempt at importing shaders into a vj software", "tags": ["1stattempt"], "likes": 0, "viewed": 308, "published": 3, "date": "1602158688", "time_retrieved": "2024-07-30T20:41:32.110850", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(1.0, 0.0, 1.0);\n    \n    if (uv.x < 1.0 / 4.0) {\n        color = texture(iChannel0, uv).rgb;\n    } else if (uv.x < 2.0 / 4.0) {\n        color = texture(iChannel1, uv).rgb;\n    } else if (uv.x < 3.0 / 4.0) {\n        color = texture(iChannel2, uv).rgb;\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    \n    /*\n    if (uv.x < 1.0 / 4.0) {\n        color = texture(iChannel0, uv).rgb;\n    } else if (uv.x < 2.0 / 4.0) {\n        color = texture(iChannel1, uv).rgb;\n    } else if (uv.x < 3.0 / 4.0) {\n        color = texture(iChannel2, uv).rgb;\n    }\n*/\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0, 1.0, 0.0);\n    \n    /*\n    if (uv.y < 1.0 / 4.0) {\n        color = texture(iChannel0, uv).rgb;\n    } else if (uv.y < 2.0 / 4.0) {\n        color = texture(iChannel1, uv).rgb;\n    } else if (uv.y < 3.0 / 4.0) {\n        color = texture(iChannel2, uv).rgb;\n    }\n*/\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0, 0.0, 1.0);\n    \n    /*\n    if (uv.x + uv.y < 1.0 / 4.0) {\n        color = texture(iChannel0, uv).rgb;\n    } else if (uv.x + uv.y < 2.0 / 4.0) {\n        color = texture(iChannel1, uv).rgb;\n    } else if (uv.x + uv.y < 3.0 / 4.0) {\n        color = texture(iChannel2, uv).rgb;\n    }\n*/\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 416]], "test": "untested"}
{"id": "WdVcRz", "name": "Paint Swarm", "author": "Plento", "description": "An experiment where particles sorta go around eachother when they get too close", "tags": ["2d", "particles", "snake", "paint", "buffer"], "likes": 9, "viewed": 446, "published": 3, "date": "1602142746", "time_retrieved": "2024-07-30T20:41:33.176002", "image_code": "// Plento\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    uv.y+=iTime*.1;\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 gl = texture(iChannel0, .0001*hash22(u+iTime)+uv, 6.0).xyz;\n\t\n    gl = gl*gl*gl*5.5;\n    col += gl;\n    \n    col = 1.-exp(-col);\n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 f, in vec2 u ){\n    ivec2 iu = ivec2(u);\n    vec4 bA = ch(iChannel0, u);\n    \n    if(iu.x < nParticles && iu.y == 0)\n    {\n        for(int i = 0; i < nParticles; i++)\n    \t{\n            if(i != iu.x)\n            {\n        \t\tvec4 pA = ch(iChannel0, vec2(i,0.));\t \n                vec4 pC = ch(iChannel1, vec2(i,0.));\n                vec2 ref = reflect(bA.zw, normalize(bA.xy - pA.xy));\n                float d = length(bA.xy - pA.xy);\n                bA.zw += 0.7* ref * exp(-d*0.025);\n            }\n            \n        }\n        \n        bA.xy += bA.zw;\n        \n        bA.zw = clamp(bA.zw, -0.7, 0.7);\n        \n    \tif(iFrame < 5 ){\n            bA.zw = (2.*hash22(vec2(345.*u.x+iDate.w, 2123.21))-1.) * 0.8;\n        \tbA.xy = hash22(u + iDate.w)*R.xy;\n    \t}\n    }\n    else discard;\n    \n    bA.zw = sign(bA.zw)*max(bA.zw, 0.2);\n    \n    bA.xy = mod(bA.xy, R);\n    bA.xy = clamp(bA.xy, vec2(0), R);\n    f = bA;\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n#define R iResolution.xy\n\nconst int nParticles = 200; \n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n", "buffer_b_code": "\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec4 bA = ch(iChannel0, u);\n    vec3 bB = ch(iChannel1, u).xyz;\n    \n    for(int i = 0; i < nParticles; i++){\n     \tfloat d = length(u - ch(iChannel0, vec2(i,0.)).xy);\t   \n        bB = mix(.5+.35*cos(vec3(2.3, 1.5,5.5)*float(i)), bB, step(R.y*0.012, d));\n    }\n    \n    bB *= 0.9884;\n    \n    if(iFrame < 5)\n        bB = vec3(0);\n    \n    f = vec4(bB, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 50, 50, 296]], "test": "untested"}
{"id": "3sVyRz", "name": "some simple subtractive plasma", "author": "netgrind", "description": "some waves", "tags": ["plasma", "colorful", "sine"], "likes": 2, "viewed": 239, "published": 3, "date": "1602132470", "time_retrieved": "2024-07-30T20:41:34.114493", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= iResolution.xy*.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    float d = length(uv);\n    float a = atan(uv.x, uv.y);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx*20.+vec3(0,2,4)+d*20.+sin(a*3.));\n    \n    float s = mix(sin(a*16.+iTime*.5+cos(d*20.+iTime*.125)), cos(a*7.-iTime*.66), cos(d*60.+iTime*.25)*.5+.5)*sin(d*30.-iTime*.33);\n    s *= smoothstep(.1, .2, d);\n    s *= smoothstep(.5, .4, d);\n    s = max(s, 0.);\n    s = pow(s, 2.);\n    \n    col *= s;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 669]], "test": "untested"}
{"id": "3sVyzR", "name": "cielo estrellado", "author": "jorge2017a1", "description": "cielo estrellado", "tags": ["cieloestrellado"], "likes": 0, "viewed": 264, "published": 3, "date": "1602123951", "time_retrieved": "2024-07-30T20:41:35.143741", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp;\n    res = vec3(9999.0, -1.0,-1.0);\n\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 30.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n\n    res =opU3(res, vec3(planeDist1,0.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist2,-1.0,7.0)); \n    \n    \n    p.y=p.y-5.0;\n\n    \n\t    \n    vec3 q1=p-vec3(0.0,0.0,12.0);\n    float cx1=40.0;\n    float cy1=11.0;\n    float cz1=40.00;\n    q1.z = mod(q1.z+0.5*cz1,cz1)-0.5*cz1;\n    q1.x = mod(q1.x+0.5*cx1,cx1)-0.5*cx1;\n    \n    \n    //columnas\n    float sdb3= sdBox(q1-vec3(0.0,-3.0,0.0), vec3(5.0,2.0,5.0));\n    float sdb4= sdBox(q1-vec3(0.0,10.0,0.0), vec3(2.0,15.0,2.0));\n    res =opU3(res, vec3(sdb3,100.0,-1.0));\n    res =opU3(res, vec3(sdb4,100.0,-1.0));\n    \n    \n\tvec3 q=p;\n    float cx=20.0;\n    float cy=11.0;\n    float cz=35.00;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    p=q;\n\t\n    \n    //suelo\n    p= rotate_x(p-vec3(0.0,-7.95,0.0), radians(90.0));\n    float sdh1G= sdHexPrism(p- vec3(0.0,0.0,0.0), vec2(6.0,3.0) );\n    float sdh2G= sdHexPrism(p- vec3(0.0,12.0,0.0), vec2(6.0,3.0) );\n    float sdb1G= sdBox(p-vec3(0.0,6.0,0.0), vec3(7.0,6.0,3.0) );\n    \n    float sdh1C= sdHexPrism(p- vec3(0.0,0.0,0.0), vec2(5.2,3.00) );\n    float sdh2C= sdHexPrism(p- vec3(0.0,12.0,0.0), vec2(5.2,3.00) );\n    float sdb1C= sdBox(p-vec3(0.0,6.0,0.0), vec3(6.0,6.0,3.00) );\n\t\n    float sdcy1= sdCylinderXY(p-vec3(-3.0,10.0,0.0), vec2(1.0,3.00)  );\n    float sdcy2= sdCylinderXY(p-vec3( 3.0,10.0,0.0), vec2(1.0,3.00)  );\n    float sdcy3= sdCylinderXY(p-vec3(-3.0,3.0,0.0), vec2(1.0,3.00)  );\n    float sdcy4= sdCylinderXY(p-vec3( 3.0,3.0,0.0), vec2(1.0,3.00)  );\n    \n        \n        \n\tres =opU3(res, vec3(sdh1G,1.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdh2G,1.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdb1G,1.0,MATERIAL_NO));\n    \n    res =opU3(res, vec3(sdh1C,2.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdh2C,2.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdb1C,2.0,MATERIAL_NO));\n    \n    res =opU3(res, vec3(sdcy1,0.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdcy2,0.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdcy3,0.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdcy4,0.0,MATERIAL_NO));\n    \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///-----------------------------------------\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); \n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n       \n        \n        if(dO>MAX_DIST )\n        {\t\n            mObj.dist = -1.0;\n    \t\tmObj.id_color = -1.0;\n    \t\tmObj.marchCount=marchCount;\n    \t\tmObj.id_material=-1.0;\n            return -1.0;\n        }\n        \n        if (abs(dS.x)<MIN_DIST) \n        { break;  }\n            \n            \n        dO += dS.x;\n        marchCount++;\n        \n        \n        \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//-------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    vec3 lightPos = plight_pos;\n    float intensity=1.0;\n\tconst float shininess = 64.0;\n\tvec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 result = LightShading(nor,l,v, colobj)*intensity;\n    \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n///---------------------------------------\nfloat starPattern(vec2 p)\n{\n\treturn 0.1 / (abs(cos(p.x)) + 0.01) * 0.1 / (abs(sin(p.y)) + 0.01) * abs(sin(p.x)) * abs(cos(p.y));\n}\n\nvec3 stars(vec2 p)\n{\n\tp -= 0.5;\n\n\tfloat a = starPattern(rotatev2(p * 26.0, 0.1)) * max(0.0, 1.3 + cos(p.x + iTime)) +\n\t\tstarPattern(rotatev2(p * 50.0, 0.2)) * max(0.0, 1.2 + cos(p.x * 0.4 + iTime * 2.0));\n\n\treturn vec3(a * 0.1 * (1.0 + (2.0 + sin(iTime * 30.0)) * 0.2));\n}\n\n\nvec3 starsv2(vec2 p)\n{\n\tp -= 0.5;\n\n\tfloat a = starPattern(rotatev2(p * 26.0, 0.1)) * max(0.0, 1.3 + cos(p.x )) +\n\t\tstarPattern(rotatev2(p * 50.0, 0.2)) * max(0.0, 1.2 + cos(p.x * 0.4 +  2.0));\n\n\treturn vec3(a * 0.10 );\n}\n\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if (id_material==7.0)\n    { \n        \n     vec2 uv=p.xz;\n     uv*=10.5;\n     vec3 st1= starsv2(uv)*vec3(0.5,0.5,1.5);\n     return st1+vec3(0.5,0.5,1.5);\n    }   \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t;\n    //t=mod(iTime*1.0,360.0);\n    //itime=t;\n\tmObj.blnShadow=false;\n        \n \tlight_pos1= vec3(0.0, 15.0, 0.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n     mObj.uv=uv;\n    float th = iTime * 0.2;\n    \n    vec3 ro = vec3(2.5*cos(th),  6.0,t*0.5+ 2.5*sin(th));\n    vec3 camFwd = normalize(vec3(0,5.0,0.0)+ro);\n    camFwd= rotate_z(camFwd, radians(iTime*12.0));\n    \n    vec3 camRight = normalize(cross(camFwd, vec3(0,1,0)));\n    vec3 camUp = cross(camRight, camFwd);\n    float fov = 0.5;\n    vec3 rd = (camFwd + fov * (uv.x * camRight + uv.y * camUp));\n    \n    rd = normalize(rd);\n    \n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\n\n//----------------------------------------------------\n\n\nvec3 getColor(int i)\n{\nfloat m;\nif (i==-2 ) {return mObj.color; }       \nif (i==0 ) {return vec3(0,0,0)/255.0; }\nif (i==1 ) {return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) {return vec3(255,0,0)/255.0; }\n\n}\n\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 293, 293, 314], [315, 315, 347, 347, 431], [432, 432, 471, 471, 566], [567, 567, 606, 606, 701], [702, 702, 741, 741, 836], [838, 907, 941, 941, 1039], [1040, 1040, 1074, 1074, 1166], [1167, 1167, 1201, 1201, 1293], [1294, 1334, 1368, 1368, 1465], [1467, 1467, 1503, 1503, 1776], [1779, 1819, 1844, 1844, 4334], [4336, 4381, 4448, 4448, 4816], [4817, 4868, 4892, 4892, 5080], [5081, 5144, 5177, 5177, 5890], [5892, 5946, 5982, 5982, 6216], [6217, 6251, 6300, 6300, 6522], [6523, 6557, 6637, 6637, 7052], [7095, 7138, 7165, 7165, 7268], [7270, 7270, 7290, 7290, 7542], [7545, 7545, 7567, 7567, 7765], [7769, 7820, 7867, 7867, 8085], [8139, 8139, 8232, 8232, 8654], [8659, 8708, 8765, 8765, 10284]], "test": "untested"}
{"id": "3sVyRR", "name": "Music Visualizer by PotatMun", "author": "PotatMun", "description": "Visualizes music from SoundCloud.\n\nWorks with any song on SoundCloud!\n\nPolar Coordinate code source: https://gist.github.com/KeyMaster-/70c13961a6ed65b6677d\n", "tags": ["visualization", "audio", "polarcoordinates"], "likes": 0, "viewed": 333, "published": 3, "date": "1602118840", "time_retrieved": "2024-07-30T20:41:36.007432", "image_code": "//Better performance\n//SONG_LIMIT defines how active the visualization of each note can become\n//#define SONG_LIMIT 1.\n\n//More activity in visuals\n#define SONG_LIMIT mod(1. + sin(iTime), 1.)\n#define BACKGROUND_SEED iTime\n\n//More activity, and can either affect performance more or less than\n// using the above definition for BACKGROUND_SEED.\n//#define BACKGROUND_SEED SONG_LIMIT\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cart = fragCoord.xy - (iResolution.xy / 2.); // get the cartesian coordinates of the window\n    vec2 polar;                                       // and transform them to polar coordinates \n    // (x, y) becomes (theta, r)\n    \n    // equation for converting cartesian y to polar r\n    polar.y = sqrt(pow(cart.x, 2.) + pow(cart.y, 2.)) / (iResolution.x / 2.); \n\n    polar.x = atan(cart.y, (cart.x));\n    polar.x -= 1.57079632679;                   // avoid asymptote at x = pi/2\n    if(polar.x < 0.0) polar.x += 6.28318530718; // make x non-negative\n    polar.x /= 6.28318530718;                   // make x < 1.0\n    \n    polar.y = 1.0 - polar.y;\n    polar.x = 1.0 - polar.x;\n    \n    //notes are represented as an RGB value. But they need to be transformed so that they can be rendered.\n    vec4 c = texture(iChannel0, vec2(polar.x, 0.));\n    // separate the screeen into 2 shells: 1 with the RGB values, and 1 without\n    if (polar.y > c.r) { \n        //Better performance\n        c.r = 0.;\n        \n        //The changing background color is controlled by these 3 lines\n        c.rgb = vec3(mod(BACKGROUND_SEED, 1.));\n        c.rg += abs(sin(iTime) - 0.1);\n        c.gb += abs(cos(iTime) - 0.1);\n    } \n    else if (c.r < 1./SONG_LIMIT) {\n        // add some green if the volume of a note is great enough\n        if (c.r > 0.35/SONG_LIMIT) c.g = 1. - c.r;\n        // else the color can be red, a shade of purple, or blue\n        c.b = 1. - c.r - c.g; // as notes get louder, their color has less and less blue\n    }\n    // if the note isnt loud enough, keep its color blue\n\tfragColor = vec4(c);\n}", "image_inputs": [{"id": 29700, "src": "https://soundcloud.com/bootlegfool/wii-shop-channel-original-music", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[381, 381, 438, 438, 2048]], "test": "untested"}
{"id": "wsGczz", "name": "Irreptile Triangle Zoom", "author": "tdhooper", "description": "Recursively tiling this hexadrafter irreptile from George Sicherman [url]https://userpages.monmouth.com/~colonel/drirrep/index.html[/url]\n\nFork of [url]https://www.shadertoy.com/view/tddyWl[/url]", "tags": ["irreptile"], "likes": 22, "viewed": 606, "published": 3, "date": "1602111181", "time_retrieved": "2024-07-30T20:41:37.005763", "image_code": "/*\n\n    Irreptile Triangle Zoom\n    -----------------------\n\n    Recursively tiling this hexadrafter irreptile from George Sicherman\n    https://userpages.monmouth.com/~colonel/drirrep/index.html\n\n\tForked from https://shadertoy.com/view/tddyWl\n\n*/\n\n// Polygon distance, iq https://www.shadertoy.com/view/wdBXRW\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return 1. - pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n\n// MATRIX\n\nmat3 trs(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rot(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scl(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\nvec2 mul(mat3 m, vec2 p) {\n   return (m * vec3(p, 1)).xy;\n}\n\n/*\nfloat decomposeScale(mat3 m) {\n    mat2 m2 = mat2(m);\n\tvec2 a = vec2(0,0) * m2;\n\tvec2 b = vec2(1,0) * m2;\n    return distance(a, b);\n}\n\n// I made this up as I went along, there are probably faster methods?\nvoid decompose(mat3 m, out vec2 translation, out float rotation, out float scale) {\n    mat2 m2 = mat2(m);\n\tvec2 a = vec2(0,0) * m2;\n\tvec2 b = vec2(1,0) * m2;\n\tvec3 c = vec3(0,0,1) * m;\n    translation = c.xy;\n    scale = distance(a, b);\n    rotation = -acos(dot(normalize(b), vec2(1,0)));\n}\n*/\n\n// Optimisations thanks to FabriceNeyret2\n\nfloat decomposeScale(mat3 m) {\n\tvec2 a = vec2(1,0) * mat2(m);\n    return length(a);\n}\n\nvoid decompose(mat3 m, out vec2 translation, out float rotation, out float scale) {\n\tvec2 a = vec2(m[0][0], m[1][0]);\n    translation = vec2(m[0][2], m[1][2]);\n    scale = length(a);\n    rotation = -acos(a.x / scale); // we don't know the real sign, so negating it as a hack\n}\n\n\n// Logarithmic Spiral Center\n// https://www.shadertoy.com/view/tscBDH\nvec2 spiralCenter(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\n\n\n// MAIN\n\nvec2 rotate(vec2 p, float a) {\n    return cos(-a)*p + sin(-a)*vec2(p.y, -p.x);\n}\n\n#define PI 3.1415926\n\nconst int count = 11;\nmat3 tiles[count];\nconst int ITERATIONS = 5;\n//#define ZOOM_OUT\n//#define LOOP\n\nfloat h = sqrt(3.) / 2.;\n\nfloat sdTile(vec2 p) {\n    vec2[] poly = vec2[](\n    \tvec2(0, 0),\n        vec2(2.5, 0),\n        vec2(2.5 - .25, -h / 2.),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1., -h),\n        vec2(.5, -h)\n    );\n\treturn sdPoly(poly, p);\n}\n\nfloat time;\n\nvec3 shadeTile(float d, float s, int i, int iteration, vec2 p) {\n    d = -d;\n    d *= iResolution.y * 2. / s;\n    d += .0025 * iResolution.y;\n    //d += (.00125 / s + .0015)  * iResolution.y;\n    d = clamp(d, 0., 1.) / 4.;\n    float t = float(i);\n    #ifdef LOOP\n        t /= float(count);\n    \t//t *= 1.666;\n        t += time;\n    #else\n        t /= float(count);\n        t = t * mix(1., 10., cos(iTime / 20.) * .5 + .5);\n        t += iTime / 6.;\n    \tt -= (p.x - 2.5/2.) * .05;\n    #endif\n    vec3 col = d * spectrum(t);\n    return col;\n}\n\nbool drawTiles(inout vec2 p, inout vec3 col, inout float scale, int iteration) {\n    \n\tfloat scaleOut;\n    vec2 pOut;\n    bool hit = false;\n    \n    vec2 p2 = p;\n    float scale2 = scale;\n\n    for(int i = 0; i < count; i++ )\n    {\n        mat3 txm = tiles[i];\n        p = (vec3(p2, 1) * txm).xy;\n        scale = scale2 * decomposeScale(txm);\n\n        float opacity = 1.;\n        \n        if (iteration == 0) {\n        \topacity = 1. - time;\n            #ifdef ZOOM_OUT\n            \topacity = 1. - opacity;\n            #endif\n        }\n        \n        if (iteration == ITERATIONS - 1) {\n        \topacity = time;\n            #ifdef ZOOM_OUT\n            \topacity = 1. - opacity;\n            #endif\n        }\n        \n        float d = sdTile(p);\n        col -= shadeTile(d, scale, i, iteration, p) * opacity;\n\n        if (d < 0.) {\n            pOut = p;\n\t\t\tscaleOut = scale;\n            hit = true;\n        }\n    }\n    \n    p = pOut;\n    scale = scaleOut;\n\n    return hit;\n}\n\nvec3 render(vec2 p, float scale) {\n\n    vec3 col = vec3(1);\n\n    // recurse\n    for(int i = 0; i < ITERATIONS; i++) {\n        if ( ! drawTiles(p, col, scale, i)) {\n            if (i == 0) {\n            \tcol = vec3(.8);\n            }\n            break;\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = mod(iTime / 12., 1.);\n\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y; \n    float pScale = .22;\n    #ifdef ZOOM_OUT\n    \tpScale = .05;\n    #endif\n    p *= pScale;\n    \n\n    // prepare matrices\n    \n    // tri\n    mat3 triOrigin = trs(vec2(-.5, sqrt(3.) / 6.)) * scl(vec2(3));\n    tiles[0] = triOrigin * trs(vec2(1., -h));\n    tiles[1] = triOrigin * rot(PI / 1.5) * trs(vec2(1., -h));\n    tiles[2] = triOrigin * rot(PI / -1.5) * trs(vec2(1., -h));\n    \n    // long\n    mat3 rect = trs(vec2(-3.5, h)) * scl(vec2(-1));\n    mat3 longOrigin = scl(vec2(3. / 1.5)) * trs(vec2(-5, 0)) * scl(vec2(-1, 1));\n    tiles[3] = longOrigin;\n    tiles[4] = tiles[3] * rect;\n    \n    // box\n    mat3 boxOrigin = trs(vec2(-.5, h)) * scl(vec2(1.5 / .25));\n    tiles[5] = boxOrigin * rot(PI / -3.);\n    tiles[6] = tiles[5] * rect;\n    tiles[7] = boxOrigin * trs(vec2(-1, 0)) * rot(PI / -3.);\n    tiles[8] = tiles[7] * rect;\n    tiles[9] = boxOrigin * trs(vec2(-2, 0)) * rot(PI / -3.);\n    tiles[10] = tiles[9] * rect;\n\n    \n    // pick a tile to zoom to, and calculate the translation,\n    // rotation, and scale to smoothly transition to it\n    mat3 zoomTile = inverse(tiles[1]);\n    vec2 translation;\n    float rotation;\n    float scale;\n    decompose(zoomTile, translation, rotation, scale);     \n    vec2 origin = spiralCenter(translation, rotation, scale);\n    \n   \t#ifdef ZOOM_OUT\n\t\tscale = 1./scale;\n    \trotation *= -1.;\n   \t#endif\n    \n    \n    // apply the zoom\n    scale = pow(scale, time);\n    p *= scale;\n    p = rotate(p, rotation * time);\n    p += origin;\n\n    \n    // draw\n   \tvec3 col = render(p, scale * pScale);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 312, 337, 337, 356], [357, 357, 397, 397, 429], [1103, 1103, 1171, 1171, 1214], [1216, 1216, 1240, 1240, 1343], [1358, 1358, 1376, 1376, 1423], [1425, 1425, 1444, 1444, 1508], [1510, 1510, 1528, 1528, 1575], [1577, 1577, 1603, 1603, 1636], [1638, 1638, 1664, 1664, 1697], [2247, 2247, 2277, 2277, 2332], [2334, 2334, 2417, 2417, 2610], [2613, 2683, 2749, 2749, 2945], [2958, 2958, 2988, 2988, 3038], [3437, 3437, 3501, 3501, 3977], [3979, 3979, 4059, 4059, 4950], [4952, 4952, 4986, 4986, 5242], [5245, 5245, 5302, 5302, 7001]], "test": "untested"}
{"id": "MlVczt", "name": "const. const.", "author": "Plento", "description": "Something I made like 2 years ago. ", "tags": ["2d", "buffer"], "likes": 5, "viewed": 300, "published": 3, "date": "1602110225", "time_retrieved": "2024-07-30T20:41:37.933283", "image_code": "\nvoid mainImage( out vec4 f, in vec2 u )\n{\n     f = texture(iChannel0, u/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 hsv( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    float t = iTime * 0.05;\n    \n    vec3 col = vec3(0., 0.001, 0.001);\n    vec2 uv = vec2(0);\n    \n    for(float i = 3.0; i <= 40.0; i += 1.0){\n        uv = u/iResolution.xy;\n        \n        uv -=0.5;\n        uv *= i * 0.1;\n        uv*= rot(t*4.0);\n        uv+=0.5;\n   \t\t\n        uv.x += i + sin(i+t*0.7)*0.2;\n        \n    \tfloat n = texture(iChannel0, uv).x;\n        vec3 c = hsv(vec3(hash11(i*3.0 + 100.0), 1.0, 1.0))* 0.8 / i;\n        \n    \tcol += mix(c, vec3(0), ceil(n));\n    }\n    uv = u/iResolution.xy;\n    col += mix(col, texture(iChannel1, uv).xyz, 0.95);\n    \n    f = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 91]], "test": "untested"}
{"id": "tsGczz", "name": "Deterministic Integer Noise", "author": "pyBlob", "description": "simply functional deterministic integer noise", "tags": ["noise", "random", "deterministic"], "likes": 3, "viewed": 420, "published": 3, "date": "1602105422", "time_retrieved": "2024-07-30T20:41:38.945576", "image_code": "// https://www.shadertoy.com/view/llGSzw\nuint hash1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash1r(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n >> 13U) ^ n; // shift-right behaves better on repeated application\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nfloat extract(uint n)\n{\n    return float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nuint next(uint n)\n{\n    //return hash1(n); // hash != random number sequence, it will converge in less than 30 iterations\n    \n    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n    return n * 134775813U + 1U; // Pascal 32-bit\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    // perturb sequence\n    uint seed = 0u;\n    if (O.y < iResolution.y / 2.)\n    {\n        // bottom: original hash\n        seed = hash1(seed + uint(iFrame));\n        seed = hash1(seed + uint(O.x));\n        seed = hash1(seed + uint(O.y));\n\n        // left: repeated applications\n        if (O.x < iResolution.x/2.)\n            for( int i=0; i<30/*000*/ ; i++ ) seed = hash1(seed); // see the convergence in action\n    }\n    else\n    {\n        // top: hash with right-shift\n        seed = hash1r(seed + uint(iFrame));\n        seed = hash1r(seed + uint(O.x));\n        seed = hash1r(seed + uint(O.y));\n\n        // left: repeated applications\n        if (O.x < iResolution.x/2.)\n            for( int i=0; i<30/*000*/ ; i++ ) seed = hash1r(seed);\n    }\n\n    // extract value\n    float r = extract(seed);\n\n    // advance generator\n    seed = next(seed);\n\n    // more values\n    float g = extract(seed);\n    seed = next(seed);\n    float b = extract(seed);\n    seed = next(seed);\n\n    C = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 61, 104, 195], [197, 238, 259, 302, 447], [449, 449, 472, 472, 527], [529, 529, 548, 722, 773], [775, 775, 814, 838, 1818]], "test": "untested"}
{"id": "wdyyRR", "name": "multiplicative vs additive noise", "author": "FabriceNeyret2", "description": "Left: multiplicative noise.   Right: additive noise without 1/2^i scaling.\nCould get ~= look, but multiplicative ~guaranties > 0 and average=1\n\nAbout multiplicative noise: [url]/view/Xs23D3[/url]  , [url]/view/XssBWj[/url] , [url]/view/Ms2GDc[/url]", "tags": ["procedural", "noise"], "likes": 4, "viewed": 331, "published": 3, "date": "1602086176", "time_retrieved": "2024-07-30T20:41:39.740451", "image_code": "\n#define hash(p)  fract(sin(dot(p, vec3(12.9898, 78.233, 311.7))) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n\n//#define T(d)   texture(iChannel0, (i+d+.5)/32. ).x       // noise texture\n//#define T(d)   hash(i+d)                                 // value noise\n  #define T(d) ( .5+ .7*dot( d-F ,  2.*hash3(i+d)-1. ) )   // gradient noise\n\nfloat noise(vec3 x) {  \n    vec3 i = floor(x), \n         F = fract(x), e = vec3(1,0,0),\n         f = smoothstep(0.,1.,F );\n    vec4 T = mix ( vec4(T(e.zzz),T(e.zxz), T(e.zzx), T(e.zxx) ),\n                   vec4(T(e.xzz),T(e.xxz), T(e.xzx), T(e.xxx) ),\n                   f.x );\n    vec2 v = mix( T.xz, T.yw, f.y);\n    return mix(v.x,v.y,f.z);\n        }\n\nfloat add_noise(vec3 x) {  // --- regular Perlin noise\n    float n = noise(x)/2.;  x *= 2.1; // return n*2.;\n         n += noise(x)/4.;  x *= 1.9;\n         n += noise(x)/8.;  x *= 2.3;\n         n += noise(x)/16.; x *= 1.9;\n         n += noise(x)/32.; x *= 2.1;\n         n += noise(x)/64.;\n    return n; \n}\n\nfloat add_noise0(vec3 x) {  // --- cascade raw sum noise\n    float i=0.,\n         n =  noise(x)-.5; i++; x *= 2.1;  // return n*2.;\n         n += noise(x)-.5; i++; x *= 1.9;\n         n += noise(x)-.5; i++; x *= 2.3;\n         n += noise(x)-.5; i++; x *= 1.9;\n         n += noise(x)-.5; i++; x *= 2.1;\n         n += noise(x)-.5; i++;\n    return n/sqrt(i); \n}\n\nfloat mul_noise(vec3 x) {   // --- multiplicative noise \n    float n = 2.*noise(x);  x *= 2.1;  // return n/2.;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);  x *= 2.3;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);  x *= 2.1;\n         n *= 2.*noise(x);\n    return n/2.; \n}\n\n//#define draw(v) clamp(1.5 - R.y/8.* abs( v - 4.*U.y), 0.,1.)\n  #define draw(v) clamp(1.5 - abs( v - 4.*U.y) / fwidth( v ), 0.,1.)\n\n#define map(P) ( U.x < 0. ? mul_noise(P) : .5 + 3.*add_noise0(P) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n\n    vec3 P = vec3( 4.*U-.2*iTime, .5 );                // draw 2D noise\n    O = vec4(  map(P) );       \n // if (abs(O.x-.5)<.1) { O = vec4(0,1,0,0); return; } // check isovalue\n    O *= vec4(1,.7,.5,0);\n    \n    P = vec3( 4.*U.x-.0*iTime, .5, .5 );               // draw curve\n    O.g += draw( map(P) ) + max(0.,1. - R.y/2.*abs(U.y));\n        \n    if ( int(u.x)==int(R/2.) ) O = vec4(1,0,0,0);      // red separator\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[461, 461, 482, 482, 814], [816, 816, 841, 870, 1121], [1123, 1123, 1149, 1179, 1479], [1481, 1481, 1506, 1537, 1791], [1994, 1994, 2032, 2032, 2513]], "test": "untested"}
{"id": "Wsyczz", "name": "tune smooth swap speed", "author": "FabriceNeyret2", "description": "Less brutal than binary switch, more brutal than sin (left).\nsee [url]https://www.desmos.com/calculator/7s1yif6w2m[/url]\n\nUsed for jaws [url]/view/3dccDl[/url] and catapult [url]/view/wsdcDs[/url]", "tags": ["interpolation", "tuto", "tuning"], "likes": 3, "viewed": 311, "published": 3, "date": "1602079095", "time_retrieved": "2024-07-30T20:41:40.568238", "image_code": "   #define ease(v) atan( (v) * t ) / atan(v) \n// #define ease(v) sign(t)* pow( abs(t), 1./(v) ) \n\n   #define A(v) clamp(  1.5 - R.y/3.*( v ) , 0., 1. )\n// #define A(v) clamp(  1.5 - (v)/fwidth(v) , 0., 1. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 3.* u / R.y;\n    float i = round(U.x),\n          t = sin(6.28*iTime);\n    O = vec4( A( length( vec2(i, 1.5+ ease(i+1.) ) - U ) -.1 ) );\n    \n    t = sin(6.28*(-iTime-fract(U.x+.5)));\n    O.r += .5* A( abs( 1.5+ease(i+1.)- U.y )  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsyczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 246, 246, 524]], "test": "untested"}
{"id": "3sGcRz", "name": "Singulo", "author": "Redline", "description": "A WIP edition of the SS13 singularity as a shader.", "tags": ["wip", "animated", "blackhole", "ss13", "singularity"], "likes": 2, "viewed": 302, "published": 3, "date": "1602069369", "time_retrieved": "2024-07-30T20:41:41.321225", "image_code": "#define pi 3.14159265359\n#define tau (pi * 2.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord/iResolution.xy - vec2(0.5)) * 2.;\n\n    // Time varying pixel color\n    float spiral = atan(cuv.x, cuv.y) / tau * 6. - iTime + length(cuv) * 3.;\n    float falloff = (1. - length(cuv));\n    vec3 col = (vec3((1. - abs(0.5 - mod(spiral, 1.))) + falloff) * falloff);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 105, 155, 541]], "test": "untested"}
{"id": "wsdcDs", "name": "Fab9 #inktober2020 \"throw\"", "author": "FabriceNeyret2", "description": "mouse control.\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nref img: [url]https://fr.123rf.com/photo_12895094_rendu-3d-de-si%C3%A8ge-catapulte.html[/url]", "tags": ["short", "golf", "reproduction", "inktober2020"], "likes": 22, "viewed": 571, "published": 3, "date": "1602057995", "time_retrieved": "2024-07-30T20:41:42.074212", "image_code": "#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                        // rotation                  \n#define B(a,l)    t = min( t, max(  max(A(a).x,A(a).y)-1., A(a).z-l )), // bar\n#define C(a,r,l)  t = min( t, max(  length( (a).xy )  -r , A(a).z-l )), // cylinder\n#define A         abs\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a, T = 6.283*iTime;\n    vec3  R = iResolution, e = vec3(7,-7,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          M = iMouse.xyz/R,\n       // M = iMouse.z > 0. ? iMouse.xyz/R : vec3(.3,.05,0)*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -2.*R.y ) - R ),      // ray direction\n          p = 50./R, q,s,r;                              // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.015 )\n        q = p, t=9.,\n        q.yz *= rot(.2 -3.*M.y),                         // rotations\n        q.xz *= rot(   -3.*M.x),\n        q.xy += 12.,\n        B( A(q)          -X-X, 8. )                      // large bars\n        B( A(q.zyx)        -X,16. )                      // long bars\n        B( A(q.xzy-Z     ) -Y, 8. )                      // vertical bars\n        B( A(q.zyx+Z-.3*Y) -X, 8. )                      // 2nd layer\n        B( A(q.zyx+Z-.5*Y) -X, 8. )                      // \n        B(   q    -1.8*Y+.2*X, 8. )                      // top bar\n        C(   q - .4*e.yxz  , .5,  9.)                    // catapult axe\n        C(   q +1.2*X -.5*Y, .5, 11.)                    // cable axe \n        C(   A(q) -1.55*X  , .5, 11.)                    // wheels axes\n        C( A(A(q)- 1.55*X) -1.3*Z , 3., 1. )             // wheels\n        s = q, s.x -= 11., s.xy *= rot(.79), \n        B( A(s.xzy-Z) -Y, 8. )                           // slanted bars\n        a = .59+ .6* atan(8.*sin(T))/1.6,                // catapult arm angle\n        s = q - .4*e.yxz, s.xy *= rot(a),\n        B( s.xzy -Z, 8. )                                // catapult arm\n        C( s.zyx -2.4*Y, 3.5, .5 )                       // catapult plate\n        a < .1 ? s.x -= 50.*mod(T+2.66, 6.283) : a,      // boulder trajectory\n        t = min( t, length(s-vec3(1.5,17.5,0)) -2.),     // boulder\n        p += t*D;                                        // step forward = dist to obj          \n // O *= vec4(.7,.4,.2,1);                               // coloring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdcDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3styDs", "name": "Raymarcher Template", "author": "oneshade", "description": "This is a template I created for my future raymarching projects. You can use it if you want but I would suggest getting familiarized with the raymarching algorithm if you aren't already.", "tags": ["template", "raymarcher"], "likes": 14, "viewed": 910, "published": 3, "date": "1602031230", "time_retrieved": "2024-07-30T20:41:42.841161", "image_code": "/*\nBased on Michael Walczyk's blog on raymarching at https://michaelwalczyk.com/blog-ray-marching.html\n\nThe MIT License\nCopyright © 2020 Elijah Bevers\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\nfollowing conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\nKIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nUpdate information:\n* Future updates:\n\n\n* Added features (in order):\n  - Original version\n  - Added new SDFs for plane and torus\n  - Added a background variable\n  - Added individual shape coloring\n  - Added structures to allow CSG operators to work alongside coloring\n  - Put the surface shading code into a seperate function\n  - Fixed plane SDF\n  - Added clamping of colors to prevent weird issues\n  - Added shadows\n  - Simplified plane SDF\n  - Added antialiasing\n  - Added cone SDF\n  - Added soft shadows\n  - Added a sky function\n  - Added fog\n*/\n\n// Post process settings:\nvec2 antialiasing = vec2(1.0, 1.0); // Set to 2x2 if your computer is fast enough.\n\n// Light settings:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightEmissionColor = vec3(1.0, 1.0, 1.0);\nvec3 lightColor = vec3(1.0, 0.9, 0.7);\nfloat lightPower = 2.0;\n\n// Soft shadows:\nfloat shadowSoftness = 5.0;\n\n// Fog:\nvec3 fogColor = vec3(0.25, 0.25, 0.6);\nfloat fogginess = 0.0001;\n\n// Camera settings:\nvec3 cameraPosition = vec3(0.0, 300.0, 1100.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// User interaction settings:\nfloat tiltSpeed = 3.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.005;\nconst float SHADOW_BIAS = MIN_HIT_DISTANCE * 2.0;\nconst int MAX_STEPS = 500;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, p);\n}\n\n// sdCuboid(), sdCone(), and sdCylinder() are taken from Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    vec3 q = abs(p) - 0.5 * vec3(w, h, d);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCone(in vec3 p, in float b, in float h) {\n    p.y -= h;\n    vec2 q = h * vec2(b / h * 2.0, -2.0);\n    \n    vec2 w = vec2( length(p.xz), p.y );\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 c = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(c, c));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, 0.5 * h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n\n    return surfaceUnion;\n}\n\nSurface Intersection(in Surface surface1, in Surface surface2) {\n    Surface surfaceIntersection = surface1;\n    if (surface2.signedDistance > surfaceIntersection.signedDistance) {\n        surfaceIntersection = surface2;\n    }\n\n    return surfaceIntersection;\n}\n\nSurface Difference(in Surface surface1, in Surface surface2) {\n    return Intersection(surface1, Surface(surface2.ambientColor,\n                                          surface2.diffuseColor,\n                                          surface2.specularColor,\n                                          surface2.shininess,\n                                          -surface2.signedDistance));\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    Surface plane = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(mod(dot(floor(p.xz / 100.0), vec2(1.0)), 2.0) * 1.25),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            sdPlane(Translate(p, vec3(0.0, -75.0, 0.0)), vec3(0.0, 1.0, 0.0)));\n\n    Surface cuboid = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 0.6, 0.0),\n                            vec3(1.0, 0.4, 0.0), 1.0,\n                            sdCuboid(Translate(p, vec3(-300.0, -12.5, -300.0)), 125.0, 250.0, 200.0));\n\n    Surface cone = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 1.0, 0.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdCone(Translate(p, vec3(0.0, 25.0, -300.0)), 50.0, 100.0));\n\n    Surface cylinder = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 1.0, 0.0),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            sdCylinder(Translate(p, vec3(300.0, 0.0, -300.0)), 150.0, 50.0));\n\n    Surface torus = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 0.0, 1.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdTorus(Translate(p, vec3(-150.0, -35.0, 100.0)), 100.0, 40.0));\n\n    Surface sphere = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 0.0, 0.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdSphere(Translate(p, vec3(150.0, 0.0, 100.0)), 75.0));\n\n    return Union(plane, Union(cuboid, Union(cone, Union(cylinder, Union(torus, sphere)))));\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Sky mapping function:\nvec3 mapSky(in Ray ray) {\n    return mix(vec3(1.0), vec3(0.25, 0.25, 1.0), 0.5 + 0.5 * ray.direction.y);\n}\n\n// Fog function:\nvec3 applyFog(in vec3 shade, in Ray ray, in float rayDistance) {\n    float lightAmount = max(0.0, dot(ray.direction, lightDirection));\n    vec3 fog = mix(fogColor, lightColor, pow(lightAmount, lightPower));\n    float fogAmount = 1.0 - exp(-rayDistance * fogginess);\n    return mix(shade, fog, fogAmount);\n}\n\n// Shadow mapping function:\nfloat mapShadow(in vec3 p, in vec3 normal, in float softness) {\n    float softShadow = 1.0;\n    p += normal * SHADOW_BIAS;\n    float shadowDistance = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 shadowTestPosition = p + lightDirection * shadowDistance;\n        Surface occluderSurface = mapScene(shadowTestPosition);\n        if (abs(occluderSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            return 0.0;\n        }\n\n        if (shadowDistance > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        shadowDistance += occluderSurface.signedDistance;\n        softShadow = min(softShadow, softness * occluderSurface.signedDistance / shadowDistance);\n    }\n\n    return softShadow;\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightEmissionColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightEmissionColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightEmissionColor;\n\n    return illuminationAmbient + (illuminationDiffuse + illuminationSpecular) * mapShadow(hitPosition, normal, shadowSoftness);\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 color = shadeSurface(sceneSurface, currentPosition, ray, normal);\n            color = applyFog(color, ray, distanceTraveled);\n            return vec4(color, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(mapSky(ray), 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    cameraPosition = Rotate(cameraPosition, vec3(0.0, -iTime * 20.0, 0.0));\n    float tilt = iMouse.y - screenCenter.y;\n    if (iMouse.z > 0.0) cameraPosition.y += tilt * tiltSpeed;\n\n    cameraForward = -normalize(cameraPosition);\n    cameraRight = normalize(vec3(-cameraForward.z, 0.0, cameraForward.x));\n    cameraUp = cross(cameraRight, cameraForward);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = fragCoord + vec2(xOffset, yOffset) / antialiasing - screenCenter;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3styDs.jpg", "access": "api", "license": "mit", "functions": [[2860, 2897, 2934, 2934, 2958], [2960, 3111, 3174, 3174, 3287], [3289, 3289, 3338, 3338, 3723], [3725, 3725, 3778, 3778, 3900], [3902, 3902, 3954, 3954, 4010], [4012, 4012, 4051, 4051, 4079], [4081, 4129, 4186, 4186, 4355], [4357, 4357, 4421, 4421, 4618], [4620, 4620, 4682, 4682, 5012], [5014, 5034, 5072, 5072, 5092], [5094, 5094, 5129, 5129, 5740], [5742, 5742, 5776, 5776, 5796], [5798, 5825, 5854, 5854, 7468], [7470, 7519, 7552, 7552, 7972], [7974, 7999, 8024, 8024, 8105], [8107, 8124, 8188, 8188, 8430], [8432, 8460, 8523, 8523, 9190], [9192, 9247, 9335, 9335, 9947], [9949, 9970, 9997, 9997, 10736], [10738, 10771, 10826, 10826, 11834]], "test": "untested"}
{"id": "tddyWl", "name": "Irreptile Triangle", "author": "tdhooper", "description": "Recursively tiling this hexadrafter irreptile from George Sicherman [url]https://userpages.monmouth.com/~colonel/drirrep/index.html[/url]", "tags": ["irreptile"], "likes": 51, "viewed": 1096, "published": 3, "date": "1602028741", "time_retrieved": "2024-07-30T20:41:43.595145", "image_code": "/*\n\n    Irreptile Triangle\n    ------------------\n\n    Recursively tiling this hexadrafter irreptile from George Sicherman\n    https://userpages.monmouth.com/~colonel/drirrep/index.html\n\n*/\n\n// Polygon distance, iq https://www.shadertoy.com/view/wdBXRW\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return 1. - pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n#define PI 3.14159265359\n\n\n// MATRIX\n\nmat3 trs(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rot(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scl(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nfloat decomposeScale(mat3 m) {\n\tvec3 a = vec3(0) * m;\n\tvec3 b = vec3(1,0,0) * m;\n    return distance(a, b);\n}\n\n\n// MAIN\n\nconst int count = 11;\nmat3 tiles[count];\n\nfloat h = sqrt(3.) / 2.;\n\nfloat sdTile(vec2 p) {\n    vec2[] poly = vec2[](\n    \tvec2(0, 0),\n        vec2(2.5, 0),\n        vec2(2.5 - .25, -h / 2.),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1., -h),\n        vec2(.5, -h)\n    );\n\treturn sdPoly(poly, p);\n}\n\n//#define LOOP\n\nvec3 shadeTile(float d, float s, int i, int iteration) {\n    d = -d;\n    d *= iResolution.y * 2. / s;\n    d += .001 * iResolution.y;\n    //d += (.002 / s + .0008)  * iResolution.y;\n    d = clamp(d, 0., 1.) / 4.;\n    float t = float(i);\n    #ifdef LOOP\n        float time = mod(iTime / 3., 1.);\n        if (iteration > 0) {\n            t /= float(count);\n        } else {\n            t /= 3.;\n        }\n    \t//t *= 1.666;\n        t += time;\n    #else\n        if (iteration > 0) {\n            t /= float(count);\n            t = t * mix(1., 10., cos(iTime / 10.) * .5 + .5);\n        } else {\n            t /= 3.;\n        }\n        t += iTime / 3.;\n    #endif\n    vec3 col = d * spectrum(t);\n    return col;\n}\n\nbool drawTiles(inout vec2 p, inout vec3 col, inout float scale, int iteration) {\n    \n\tfloat scaleOut;\n    vec2 pOut;\n    bool hit = false;\n    \n    vec2 p2 = p;\n    float scale2 = scale;\n\n    for(int i = 0; i < count; i++ )\n    {\n        mat3 txm = tiles[i];\n        p = (vec3(p2, 1) * txm).xy;\n        scale = scale2 * decomposeScale(txm);\n\n        float d = sdTile(p);\n        col -= shadeTile(d, scale, i, iteration);\n\n        if (d < 0.) {\n            pOut = p;\n\t\t\tscaleOut = scale;\n            hit = true;\n        }\n        \n        if (iteration == 0 && i == 2) {\n        \tbreak;\n        }\n    }\n    \n    p = pOut;\n    scale = scaleOut;\n\n    return hit;\n}\n\nvec3 render(vec2 p) {\n\n    float scale = 1.;\n    vec3 col = vec3(1);\n\n    // recurse\n    for(int i = 0; i < 4; i++) {\n        if ( ! drawTiles(p, col, scale, i)) {\n            if (i == 0) {\n            \tcol = vec3(.8);\n            }\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tp *= .55;\n    p *= vec2(1,-1);\n    p -= vec2(-.5,h/2.);\n    \n    \n    // prepare matrices\n    \n    // tri\n    mat3 triOrigin = trs(vec2(-.5, sqrt(3.) / 6.)) * scl(vec2(3));\n    tiles[0] = triOrigin * trs(vec2(1., -h));\n    tiles[1] = triOrigin * rot(PI / 1.5) * trs(vec2(1., -h));\n    tiles[2] = triOrigin * rot(PI / -1.5) * trs(vec2(1., -h));\n    \n    // long\n    mat3 rect = trs(vec2(-3.5, h)) * scl(vec2(-1));\n    mat3 longOrigin = scl(vec2(3. / 1.5)) * trs(vec2(-5, 0)) * scl(vec2(-1, 1));\n    tiles[3] = longOrigin;\n    tiles[4] = tiles[3] * rect;\n    \n    // box\n    mat3 boxOrigin = trs(vec2(-.5, h)) * scl(vec2(1.5 / .25));\n    tiles[5] = boxOrigin * rot(PI / -3.);\n    tiles[6] = tiles[5] * rect;\n    tiles[7] = boxOrigin * trs(vec2(-1, 0)) * rot(PI / -3.);\n    tiles[8] = tiles[7] * rect;\n    tiles[9] = boxOrigin * trs(vec2(-2, 0)) * rot(PI / -3.);\n    tiles[10] = tiles[9] * rect;\n\n    \n    // draw\n    \n   \tvec3 col = render(p);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 279, 279, 298], [299, 299, 339, 339, 371], [1045, 1045, 1113, 1113, 1156], [1158, 1158, 1182, 1182, 1285], [1326, 1326, 1344, 1344, 1391], [1393, 1393, 1412, 1412, 1476], [1478, 1478, 1496, 1496, 1543], [1545, 1545, 1575, 1575, 1654], [1984, 1984, 2040, 2040, 2689], [2691, 2691, 2771, 2771, 3353], [3355, 3355, 3376, 3376, 3645], [3647, 3647, 3704, 3704, 4777]], "test": "untested"}
{"id": "wtBBRd", "name": "Castlevania type thing", "author": "AlexApps99", "description": "Emulates the effect seen in action here:\nhttps://www.youtube.com/watch?v=ngoxlS8LEj4", "tags": ["castlevania"], "likes": 2, "viewed": 294, "published": 3, "date": "1602023637", "time_retrieved": "2024-07-30T20:41:44.416948", "image_code": "#define PI 3.1415926535897932384626433832795028841971693993751\n\nvec2 norm(vec2 inp) {\n    vec2 r = inp / iResolution.xy - vec2(0.5);\n    //r.y *= -1.0;\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates to (-0.5 ... 0.5)\n    vec2 uv = norm(fragCoord) * vec2(640.0, 480.0);\n\n    // should be 2.0 near middle, closer to 1.0 at edges\n    float s = (2.0 - cos(uv.y/480. * 0.9 * PI));\n    if (s != 0.0) {\n        vec2 coord = uv/s;\n        coord.x += iTime *250.0;\n        coord.y -= 100.0 * sin(iTime * 1.0);\n        fragColor = texture(iChannel0, coord/100.0)*(2.0-s);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 167], [169, 169, 224, 271, 683]], "test": "untested"}
{"id": "tlBBRd", "name": "Floor light thing", "author": "AlexApps99", "description": "Looks ok but the lighting seems to distort at far distance", "tags": ["floor"], "likes": 0, "viewed": 265, "published": 3, "date": "1602023554", "time_retrieved": "2024-07-30T20:41:45.230771", "image_code": "vec2 norm(vec2 inp) {\n    vec2 r = 2.0 * inp / iResolution.xy - 1.0;\n    r.y *= -1.0;\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates to (-1 ... 1)\n    vec2 uv = norm(fragCoord);\n\n    float s = 1.0/2.0 * (uv.y/2.0 + 0.5);\n    if (s > 0.0) {\n        float theta = mod(iTime, radians(360.0));\n        mat2 tf = mat2(\n            cos(theta), -sin(theta),// Col 1\n            sin(theta),  cos(theta) // Col 2\n        )/s;\n        vec2 coord = tf * uv;\n        vec2 mouse = tf * norm(iMouse.xy) * -1.0;\n        fragColor = texture(iChannel0, coord)/(sqrt(pow(coord.x + mouse.x, 2.0) + pow(coord.y + mouse.y, 2.0))+1.0);\n    }\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 101], [103, 103, 158, 201, 676]], "test": "untested"}
{"id": "WdtcDs", "name": "st_assert", "author": "iq", "description": "This shader shows how to use st_assert(condition,[0..3]) to debug shaders. You can st_assert a condition anywhere in the code and it will always override the final output color if the condition is not met. There are four assert channels available.", "tags": ["2d", "assert", "stassert"], "likes": 32, "viewed": 1107, "published": 3, "date": "1602023375", "time_retrieved": "2024-07-30T20:41:45.991737", "image_code": "// This shader shows how to use st_assert(condition,[0..3]) to debug\n// shaders. You can st_assert a condition anywhere in the code and it\n// will always override the final output color if the condition is not\n// met. There are four assert channels available, with colors red, green\n// blue and yellow.\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    st_assert( uv.x<0.5, 0 );\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 365, 365, 531]], "test": "untested"}
{"id": "wstyWl", "name": "dust02", "author": "Del", "description": "A simple nebula rendered using some volumetric noise and a hacky voronoi starfield - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["voronoi", "volumetric", "nebula", "starfield", "wavelet"], "likes": 26, "viewed": 1313, "published": 3, "date": "1602017968", "time_retrieved": "2024-07-30T20:41:46.747717", "image_code": "// simple nebula rendered using some volumetric noise and a hacky voronoi starfield - Del 06/10/2020\n// this shader is purely used for baking a procedural cubemap texture, please ignore the hackery & lack of speed - a realtime version would require some baked noise textures.\n// WaveletNoise by BigWigs, Voronoi by IQ.\n\nvec3 erot(vec3 p, vec3 ax, float ro)\n{\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<3.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// starfield hack :)\nfloat stars(vec3 pp1)\n{\n    float f;\n    vec3 vv = voronoi(pp1);\n    f = vv.x;\n    float size = abs(sin((vv.z*32.3215))*9.0);\n    f = 1.0-(f*(19.0+size));\n  \tfloat twink = 0.5+sin(f+iTime*1.3+vv.z)*0.5;\n    f = clamp(f+(twink*0.2),0.0,1.0);\n   \treturn f;\n}\n\n#define brightness -7.\n#define saturation 0.95\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*0.8,1.);\n\tfloat time=iTime*0.04;\n\n\t//rotation\n    vec2  mm = iMouse.xy/iResolution.xy;\n\tfloat a1=0.5+(mm.x*0.5);\n\tfloat a2=0.8+(mm.y*0.8);\n    \n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,.75);\n\tfrom+=vec3(time*1.8,time,-5.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t// volumetric\n\tfloat s=0.1;\n    float fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<25; r++)\n    {\n\t\tvec3 p=from+s*dir*.5;\n\t\tvec3 p2 = p*2.9;\n\t\tfloat a = WaveletNoise(p2, 0.0, 1.9)*2.0 - 1.0;\n\t\ta *= a * a;\n\t\tv += vec3(s, s*s, s*s*s*s)* a * brightness * fade;\n\t\tfade *= 0.905;\n\t\ts += 0.032*1.55;\n\t}\n\n    // Star hack\n    float f = 1.0;\n    vec3 pp1=from+dir*1.1;\n\tf = stars(pp1*20.0);\n    pp1=from+dir*1.35;\n\tf = max(f,stars(pp1*20.0));\n    pp1=from+dir*1.7;\n\tf = max(f,stars(pp1*20.0));\n    \n\tv=mix(vec3(length(v)),v,saturation);\n    v = clamp(v.gbr*0.01,vec3(0.0),vec3(1.0));\n    v+=v*f;\t// dirty starblend\n\tfragColor = vec4(v,1.);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 358, 358, 420], [422, 422, 468, 513, 1026], [1028, 1028, 1049, 1049, 1206], [1208, 1256, 1283, 1283, 1863], [1865, 1886, 1909, 1909, 2142], [2192, 2192, 2249, 2249, 3349]], "test": "untested"}
{"id": "3stcWs", "name": "Void Zoom", "author": "yozic", "description": "Spin off of https://www.shadertoy.com/view/wl2yRD", "tags": ["2d", "zoom", "trippy"], "likes": 13, "viewed": 589, "published": 3, "date": "1602005773", "time_retrieved": "2024-07-30T20:41:47.511673", "image_code": "#define PI 3.141592\n#define BALLS 10.\n#define zoom .2\n#define contrast 1.5\n#define ballSize 0.1\n#define radius 5.\n  \nvoid mainImage( out vec4 O, vec2 u ) {\n  vec2 R = iResolution.xy,\n       U = zoom * abs( 2. * u - R) / R.y;\n\n  U /= dot(U,U);\n  float dist = length(U);\n  O = vec4(0);\n\n  U *= tan( log(U) + iTime );\n  for (float i = 0.; i < BALLS; i++) {\n      U.x -= cos( log( abs( abs(U.x*.1) -i-1. )) -iTime );\n      float t = iTime/10. + i * PI / BALLS;\n      vec2 p =   vec2(tan(t), sin(t)) * radius * tan(i);\n      O.rgb += ( cos( + PI * (iTime/2. + i/5. +vec3(0, 2./2., -2./3.)) ) * .5 + .5)\n              * dist*ballSize / length(U + p);\n  }\n  O = pow(O, vec4(contrast));\n}\n\n/*\n\n#define PI 3.141592\n#define BALLS 10\n#define zoom .2\n#define contrast 1.5\n#define ballSize 0.1\n#define radius 5.\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= zoom;\n  fragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(uv) + iTime/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.x -= cos(log(abs(uv.x*.1)-float(i+1))-iTime);\n    float t = iTime/10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (iTime / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    fragColor += vec4(dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  fragColor.xyz = pow((fragColor.xyz), vec3(contrast));\n  fragColor.w = 1.0;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 155, 155, 680]], "test": "untested"}
{"id": "3ddcDl", "name": "anisotropic multiplicative noise", "author": "FabriceNeyret2", "description": "mouse control or auto-rotate.\nRed: multiplicative cascaded noise.   Blue: additive cascaded noise.\nfront/back: filaments vs plates\n\nAbout multiplicative noise: [url]/view/Xs23D3[/url]  , [url]/view/XssBWj[/url] , [url]/view/Ms2GDc[/url]", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 31, "viewed": 1211, "published": 3, "date": "1602002085", "time_retrieved": "2024-07-30T20:41:48.264660", "image_code": "\n// Preintegrated transfer function from https://shadertoy.com/view/tsdcRj\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define hash(p)  fract(sin(dot(p, vec3(12.9898, 78.233, 311.7))) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n\n//#define T(d)   texture(iChannel0, (i+d+.5)/32. ).x     // noise texture\n  #define T(d)   hash(i+d)                               // value noise\n//#define T(d) ( .5+ .7*dot( d-F ,  2.*hash3(i+d)-1. ) ) // gradient noise (Perlin noise)\n\nfloat noise(vec3 x) {  // By default, simple 3D value noise with cubic interpolation\n    vec3 i = floor(x), // Switch to gradient noise above if you wish, but little differences\n         F = fract(x), e = vec3(1,0,0),\n         f = smoothstep(0.,1.,F );\n    vec4 T = mix ( vec4(T(e.zzz),T(e.zxz), T(e.zzx), T(e.zxx) ),\n                   vec4(T(e.xzz),T(e.xxz), T(e.xzx), T(e.xxx) ),\n                   f.x );\n    vec2 v = mix( T.xz, T.yw, f.y);\n    return mix(v.x,v.y,f.z);\n        }\n\nfloat add_noise(vec3 x) {\n    float n = noise(x)/2.;  x *= 2.1; // return n*2.;\n         n += noise(x)/4.;  x *= 1.9;\n         n += noise(x)/8.;  x *= 2.3;\n         n += noise(x)/16.; x *= 1.9;\n         n += noise(x)/32.;\n    return n; \n}\n\nfloat mul_noise(vec3 x) {\n    float n = 2.*noise(x);  x *= 2.1; // return n/2.;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);  x *= 2.3;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);\n    return n/2.; \n}\n\nfloat z;\nfloat map(vec3 p )  // bounding sphere (0,0,0), 2.\n{\n    vec3 q = p*2.+ .6*iTime;\n    q /= p.z < 0. ? vec3(1,1,4) :  vec3(4,4,1);\n//  float f =  1.2*add_noise(q) -.2 ;// source noise\n//  float f =  add_noise(q);\n//  float f =  mul_noise(q);\n    float f =  p.x < 0. ? add_noise(q) : mul_noise(q);\n    f *= smoothstep(1.,.8,length(p)/2.);   // source sphere\n\n    f*= smoothstep(.1,.2,abs(p.x));               // empty slice (derivable ) \n    z = length(p)/2.;                             // depth in sphere\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\n  #define sl  200.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), 2.);\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > 2. ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 S = pos.x < 0. ? vec3(3,3,2) : vec3(2,3,3);\n            vec3 col = exp(-S *(1.-z));                   // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));     // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = max( dot(sundir,rd), 0. );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* ( 1.- iMouse.xy / R )\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[923, 923, 944, 1007, 1406], [1408, 1408, 1433, 1433, 1646], [1648, 1648, 1673, 1673, 1888], [1899, 1899, 1951, 1951, 2443], [3019, 3019, 3052, 3111, 3308], [3310, 3310, 3369, 3369, 3517], [3519, 3519, 3576, 3576, 5883], [5885, 5885, 5931, 5931, 6093], [6095, 6095, 6138, 6162, 6614], [6616, 6616, 6654, 6654, 7205]], "test": "untested"}
{"id": "tdcyWs", "name": "Balls in Spinning Drum", "author": "dr2", "description": "Slider controls spin rate; mouse controls cylinder axis orientation;   various frictional and damping forces act; flat side walls are smooth;   gravity is downward (evolved from \"More Balls\" and \"Racetrack\").\n", "tags": ["collision", "interactive", "physics", "friction"], "likes": 45, "viewed": 671, "published": 3, "date": "1601973165", "time_retrieved": "2024-07-30T20:41:49.382671", "image_code": "// \"Balls in Spinning Drum\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nmat3 QtToRMat (vec4 q);\nvec4 Loadv4 (int idVar);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\n#define S_BIG  1  // big/small system - must also change in buffer shaders\n#if S_BIG\nconst int nBall = 512;\n#else\nconst int nBall = 216;\n#endif\n\nvec3 ltDir, vnBall;\nfloat dstFar, cylRad, cylLen, cylRot;\nint idObj, idBall;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 ss;\n  float dMin, d, tr;\n  dMin = dstFar;\n  tr = 0.12;\n  q = p;\n  q.y = abs (q.y) - cylLen;\n  d = PrTorusDf (q.xzy, tr, cylRad);\n  DMIN (1);\n  q.y -= tr;\n  d = PrCylDf (q.xzy, 0.05 * cylRad, tr);\n  DMIN (2);\n  q = p;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  q.xz = (abs (q.x) < abs (q.z)) ? q.xz : q.zx;\n  tr = 0.18;\n  ss = vec2 (cylLen + 0.45, 1.45 * cylRad);\n  d = PrCapsDf (vec3 (q.xy, abs (q.z) - ss.y).xzy, tr, ss.x);\n  DMIN (3);\n  d = PrCapsDf (vec3 (q.xz, abs (q.y) - ss.x).xzy, tr, ss.y);\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.46 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n} \n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 + 4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = cylLen;\n    } else s.y = cylLen;\n    if (abs (s.y) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xz / cylRad, 0.).xzy;\n    } else if (srdy * ro.y < - cylLen) {\n      d = - (srdy * ro.y + cylLen) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdy).xzy;\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec3 col)\n{\n  vec4 dc4, col4;\n  vec3 vn;\n  float dstBall, dstObj, c, a, nDotL;\n  dstObj = ObjRay (ro, rd);\n  dstBall = dstFar;\n  dc4 = CylHit (ro, rd, cylRad, cylLen);\n  if (dc4.x < dstFar) {\n    dstBall = BallHit (ro, rd);\n    if (dstBall < min (dstObj, dstFar)) {\n      vn = vnBall;\n      c = 33. * float (idBall) / float (nBall);\n      col = HsvToRgb (vec3 (mod (c, 1.), 1. - 0.05 * mod (c, 8.),\n         1. - 0.05 * mod (c, 13.)));\n      c = mod (c + 33./2., 33.);\n      col4 = vec4 (mix (col, HsvToRgb (vec3 (mod (c, 1.), 1. - 0.1 * mod (c, 8.),\n         1. - 0.05 * mod (c, 13.))), BallChqr (idBall, vnBall)), 0.5);\n    }\n  }\n  if (dstObj < min (dstBall, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1 || idObj == 2) {\n      ro.xz = Rot2D (ro.xz, cylRot);\n      a = atan (ro.z, - ro.x);\n      if (idObj == 1) col4 = vec4 (0.8, 0.8, 0.9, 0.2) * (1. - 0.3 * step (0., sin (16. * a)));\n      else col4 = vec4 (0.9, 0.8, 0.8, 0.2) * (1. - 0.3 * step (0.01 * cylRad, length (ro.xz)) *\n         step (0., sin (8. * a)));\n    } else if (idObj == 3) {\n      col4 = vec4 (0.9, 0.8, 0.6, 0.2) * (1. - 0.1 * step (abs (ro.y), cylLen + 0.36) * \n         step (0., sin (16. * pi * ro.y)));\n    } else if (idObj == 4) {\n      col4 = vec4 (0.9, 0.8, 0.6, 0.2);\n    }\n  }\n  if (min (dstBall, dstObj) < dstFar) {\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstBall) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.8 * nDotL) + col4.a * pow (max (0.,\n       dot (ltDir, reflect (rd, vn))), 32.);\n  } else if (dc4.x < dstFar) col *= 0.7;\n  if (dc4.x < min (dstObj, dstFar)) col = mix (col, vec3 (0.8, 0.8, 1.),\n     0.1 + 0.8 * pow (1. - abs (dot (dc4.yzw, rd)), 5.));\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float slVal)\n{\n  vec4 wgBx;\n  vec3 c1, c2;\n  vec2 ut, ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n  c1 = vec3 (0.1, 0.7, 0.1);\n  c2 = vec3 (0.7, 1., 0.5);\n  ut = 0.5 * uv - wgBx.xy;\n  ust = abs (ut) - wgBx.zw * vec2 (0.7, 1.);\n  if (max (ust.x, ust.y) < 0.) {\n    if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = c2;\n    else col = (mod (0.5 * ((0.5 * uv.y - wgBx.y) / wgBx.w - 0.99), 0.1) *\n       canvas.y < 5.) ? c2 : vec3 (0.3);\n  }\n  ut.y -= (slVal - 0.5) * 2. * wgBx.w;\n  ut = abs (ut) * vec2 (1., 2.);\n  if (abs (max (ut.x, ut.y) - 0.02) < 0.008) col = c1;\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMatT;\n  vec4 stDat, qtVu;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float b, slVal, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  cylRad = stDat.x - 0.4;\n  cylLen = stDat.y - 0.4;\n  cylRot = stDat.w;\n  qtVu = Loadv4 (1);\n  vuMatT = QtToRMat (qtVu);\n  b = max (cylRad, cylLen);\n  dstFar = 20. * b;\n  zmFac = 6.;\n  rd = normalize (vec3 (uv, zmFac)) * vuMatT;\n  ro = vec3 (0., 0., - 8. * b) * vuMatT;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMatT;\n  col = vec3 (0., 0., 0.2 + 0.1 * uv.y);\n  col = ShowScene (ro, rd, col);\n  slVal = Loadv4 (3).y;\n  col = ShowWg (uv, canvas, col, slVal);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Balls in Spinning Drum\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define S_BIG  1\n#if S_BIG\nconst int nBall = 512;\n#else\nconst int nBall = 216;\n#endif\n\nvec4 qtVu;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xz);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.x, 0., rm.z));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.z, 0., - rm.x));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.y = abs (rm.y) - cylLen;\n  rSep = abs (dr.y);\n  if (rSep < diamAv) {\n    dr.y *= sign (rm.y);\n    dr.xz = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.z, 0., rm.x);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= vec3 (0., grav, 0.) * QtToRMat (qtVu) + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, nbEdge;\n  nbEdge = floor (pow (float (nBall), 1./3.) + 0.1);\n  mIdf = float (mId);\n  rm = 0.9 * (floor (vec3 (mod (mIdf, nbEdge), mod (mIdf, nbEdge * nbEdge) / nbEdge,\n      mIdf / (nbEdge * nbEdge))) - 0.5 * (nbEdge - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (mIdf + 0.1);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool doInit)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (doInit) {\n    qtVu = EulToQt (vec3 (0., 0.5 * pi, 0.15 * pi));\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QtMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx, stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float asp, diam, cylRot, angVMax, slVal;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = floor (pow (float (nBall), 1./3.));\n    cylLen = 0.5 * cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.25;\n    angV = slVal * angVMax;\n    OrientVu (qtVu, mPtr, mPtrP, true);\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    qtVu = Loadv4 (1);\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx.xy) - wgBx.zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    OrientVu (qtVu, mPtr, mPtrP, false);\n  } else {\n    if (wgSel == 0) {\n      slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx.y) / wgBx.w, 0., 1.);\n      angV = slVal * angVMax;\n    }\n    mPtrP = mPtr;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), 0.);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= 4) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Balls in Spinning Drum\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define S_BIG  1\n#if S_BIG\nconst int nBall = 512;\n#else\nconst int nBall = 216;\n#endif\n\nvec4 qtVu;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xz);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.x, 0., rm.z));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.z, 0., - rm.x));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.y = abs (rm.y) - cylLen;\n  rSep = abs (dr.y);\n  if (rSep < diamAv) {\n    dr.y *= sign (rm.y);\n    dr.xz = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.z, 0., rm.x);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= vec3 (0., grav, 0.) * QtToRMat (qtVu) + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, nbEdge;\n  nbEdge = floor (pow (float (nBall), 1./3.) + 0.1);\n  mIdf = float (mId);\n  rm = 0.9 * (floor (vec3 (mod (mIdf, nbEdge), mod (mIdf, nbEdge * nbEdge) / nbEdge,\n      mIdf / (nbEdge * nbEdge))) - 0.5 * (nbEdge - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (mIdf + 0.1);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool doInit)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (doInit) {\n    qtVu = EulToQt (vec3 (0., 0.5 * pi, 0.15 * pi));\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QtMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx, stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float asp, diam, cylRot, angVMax, slVal;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = floor (pow (float (nBall), 1./3.));\n    cylLen = 0.5 * cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.25;\n    angV = slVal * angVMax;\n    OrientVu (qtVu, mPtr, mPtrP, true);\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    qtVu = Loadv4 (1);\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx.xy) - wgBx.zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    OrientVu (qtVu, mPtr, mPtrP, false);\n  } else {\n    if (wgSel == 0) {\n      slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx.y) / wgBx.w, 0., 1.);\n      angV = slVal * angVMax;\n    }\n    mPtrP = mPtr;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), 0.);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= 4) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Balls in Spinning Drum\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define S_BIG  1\n#if S_BIG\nconst int nBall = 512;\n#else\nconst int nBall = 216;\n#endif\n\nvec4 qtVu;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xz);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.x, 0., rm.z));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.z, 0., - rm.x));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.y = abs (rm.y) - cylLen;\n  rSep = abs (dr.y);\n  if (rSep < diamAv) {\n    dr.y *= sign (rm.y);\n    dr.xz = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.z, 0., rm.x);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= vec3 (0., grav, 0.) * QtToRMat (qtVu) + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, nbEdge;\n  nbEdge = floor (pow (float (nBall), 1./3.) + 0.1);\n  mIdf = float (mId);\n  rm = 0.9 * (floor (vec3 (mod (mIdf, nbEdge), mod (mIdf, nbEdge * nbEdge) / nbEdge,\n      mIdf / (nbEdge * nbEdge))) - 0.5 * (nbEdge - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (mIdf + 0.1);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool doInit)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (doInit) {\n    qtVu = EulToQt (vec3 (0., 0.5 * pi, 0.15 * pi));\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QtMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx, stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float asp, diam, cylRot, angVMax, slVal;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = floor (pow (float (nBall), 1./3.));\n    cylLen = 0.5 * cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.25;\n    angV = slVal * angVMax;\n    OrientVu (qtVu, mPtr, mPtrP, true);\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    qtVu = Loadv4 (1);\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx.xy) - wgBx.zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    OrientVu (qtVu, mPtr, mPtrP, false);\n  } else {\n    if (wgSel == 0) {\n      slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx.y) / wgBx.w, 0., 1.);\n      angV = slVal * angVMax;\n    }\n    mPtrP = mPtr;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), 0.);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= 4) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Balls in Spinning Drum\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define S_BIG  1\n#if S_BIG\nconst int nBall = 512;\n#else\nconst int nBall = 216;\n#endif\n\nvec4 qtVu;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xz);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.x, 0., rm.z));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.z, 0., - rm.x));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.y = abs (rm.y) - cylLen;\n  rSep = abs (dr.y);\n  if (rSep < diamAv) {\n    dr.y *= sign (rm.y);\n    dr.xz = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.z, 0., rm.x);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= vec3 (0., grav, 0.) * QtToRMat (qtVu) + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, nbEdge;\n  nbEdge = floor (pow (float (nBall), 1./3.) + 0.1);\n  mIdf = float (mId);\n  rm = 0.9 * (floor (vec3 (mod (mIdf, nbEdge), mod (mIdf, nbEdge * nbEdge) / nbEdge,\n      mIdf / (nbEdge * nbEdge))) - 0.5 * (nbEdge - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.3 * Hashff (mIdf + 0.1);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool doInit)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (doInit) {\n    qtVu = EulToQt (vec3 (0., 0.5 * pi, 0.15 * pi));\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QtMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx, stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float asp, diam, cylRot, angVMax, slVal;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = floor (pow (float (nBall), 1./3.));\n    cylLen = 0.5 * cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.25;\n    angV = slVal * angVMax;\n    OrientVu (qtVu, mPtr, mPtrP, true);\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    qtVu = Loadv4 (1);\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx.xy) - wgBx.zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 0;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    OrientVu (qtVu, mPtr, mPtrP, false);\n  } else {\n    if (wgSel == 0) {\n      slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx.y) / wgBx.w, 0., 1.);\n      angV = slVal * angVMax;\n    }\n    mPtrP = mPtr;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = qtVu;\n  else if (pxId == 2) stDat = mPtrP;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), 0.);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= 4) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcyWs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[707, 707, 729, 729, 1267], [1269, 1269, 1302, 1302, 1486], [1488, 1488, 1509, 1509, 1766], [1768, 1768, 1802, 1802, 2229], [2232, 2232, 2274, 2274, 2472], [2474, 2474, 2534, 2534, 3282], [3284, 3284, 3329, 3329, 5042], [5044, 5044, 5103, 5103, 5731], [5733, 5733, 5786, 5786, 6497], [6499, 6499, 6541, 6541, 6592], [6594, 6594, 6637, 6637, 6710], [6712, 6712, 6758, 6758, 6815], [6817, 6817, 6842, 6842, 7238], [7240, 7240, 7270, 7270, 7383], [7385, 7385, 7409, 7409, 7531], [7625, 7625, 7650, 7650, 7773]], "test": "untested"}
{"id": "3dcyW2", "name": "automata_8", "author": "balkhan", "description": "click somewhere in the middle of the screen, it takes about 30 sec to start finishing to fill the belt", "tags": ["mouse", "automata", "gol"], "likes": 5, "viewed": 373, "published": 3, "date": "1601963351", "time_retrieved": "2024-07-30T20:41:50.146628", "image_code": "// Fork of \"automata_6\" by balkhan. https://shadertoy.com/view/3dBcWG\n// 2020-10-03 02:43:27\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n\to = B(f/R);\n\to.xyz = sin(o.x+ vec3(0.0, 1.04, 2.08) );\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nfloat d(vec2 f, float s) // game of life modified, s is neighbors sampling scale\n{\n    vec2 i;\n\n    float r = B(f).x;\n    float m = .0;\n    for (int k = 0; i = vec2(k%3, k/3)-1., k < 9; k++)\n        if (k != 4)  m += B((f+i*s/R) ).x;\n    if (\n        (\n       r > .0 && m >= 2. && m <= 3.\n        )\n       ||\n        (\n       r <= 0. && m >= 8.\n            )\n       )\n        r = 1.;\n    else\n        r = 0.;\n    return r;\n}\n\nfloat aliased_circle(vec2 f) \n    // this used to be \"length(f)-smallradius\" and then I noticed sometimes it gave constructing arms\n    // and so the quest to find the exact shape began\n    // and then it ended\n{\n    float r = .0;\n    f = abs(f); // symmetries are cool\n    if (\n        (f.x >= .0 && f.x < 2.\n         &&\n         f.y <= 8. && f.y > 7.\n        )\n        ||\n        (f.x >= .0 && f.x < 4.\n         &&\n         f.y <= 7. && f.y > 6.\n        )\n        ||\n        (f.x >= .0 && f.x < 6.\n         &&\n         f.y <= 6. && f.y > 4.\n        )\n        ||\n        (f.x >= .0 && f.x < 7.\n         &&\n         f.y <= 4. && f.y > 2.\n        )\n        ||\n        (f.x >= .0 && f.x < 8.\n         &&\n         f.y <= 2. && f.y > 0.\n        )\n        )\n\tr = 1.;\n    \n    return r;\n}\n\nfloat experiment(vec2 f)\n{\n    float r;\n    \n    if (\n        (\n        f.x > -2. && f.x <= 1.\n       &&\n        f.y > -4. && f.y <= 8.\n        )\n        ||\n        (\n        f.x > -4. && f.x <= 4.\n            &&\n        f.y > -0.0 && f.y <= 2.\n        )\n       )\n        r = 1.;\n    \n    return r;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2 u = f / R, m = iMouse.x <= 1. ? R*.5 : iMouse.xy;\n    o = texture(iChannel1, u);\n    if(iChannelResolution[1].x < 1.)\n    {\n        o = vec4(0.);\n        return;\n    }\n\tfloat kb = texture(iChannel2, vec2(32.5/256., 0.25)).x; // keyboard\n        if (iFrame < 1 || kb > .5 || iMouse.z > .0)\n    {\n        o = o - o;\n        o.x = step(.0*aliased_circle(f-m.xy+vec2(300., 550.0)*1.0)*1.0+experiment(abs(f-m.xy)-vec2(100., 100.)*(R.y>200. ? 1.:.25)), .0)*.5+.0;\n        return ;\n    }\n    #ifdef SLOW_MO\n\tif (iFrame % 5 > 1) return;\n    #endif\n\n    \n    o += 2.*d(u, .5);\n    o -= 1.5*d(u, 1.5);\n    o += d(u, .25);\n    //o += d(u, .75)*-.03;\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define SLOW_MO\n\n#define R iResolution.xy\n#define B(u) texture(iChannel1, u)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[209, 209, 250, 250, 308]], "test": "untested"}
{"id": "ws3cWl", "name": "Wax Sculpture II", "author": "wyatt", "description": "Sophia and I have mountain of colorful wax in our room that we've made over the years. \n\nUse your mouse to make your own wax sculpture!", "tags": ["fluid"], "likes": 22, "viewed": 732, "published": 3, "date": "1601957372", "time_retrieved": "2024-07-30T20:41:51.136980", "image_code": "// Fork of \"Wax Sculpture\" by wyatt. https://shadertoy.com/view/ts3yDn\n// 2020-10-06 03:56:48\n\n// Fork of \"Tannins\" by wyatt. https://shadertoy.com/view/3sdczN\n// 2020-09-21 22:04:57\n\nMain {\n    vec4\n        n = C(U+vec2(0,1))+B(U+vec2(0,1)),\n        e = C(U+vec2(1,0))+B(U+vec2(1,0)),\n        s = C(U-vec2(0,1))+B(U-vec2(0,1)),\n        w = C(U-vec2(1,0))+B(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.w-w.w,n.w-s.w,.1)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \tvec4 b = B(U), c = C(U);\n\tQ = c+b*b.w;\n    vec3 l = R.xyy;\n    float li = ln(vec3(U,0),vec3(U,0)+ref,l);\n    Q *= mat4(\n        \t 1,.3,-.3,0,\n             .2,-.3,.6,0,\n             -.4,.3,1,0,\n             0,0,0,0);\n    Q = .8*sqrt(Q);\n    Q *= .0+0.5*exp(-6.*li)+exp(-.03*li);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}\n\n#define rate 0.006", "buffer_a_code": "Main {\n    vec4 bb = C(U);\n    if (iFrame%2==0) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            #define o 1.2\n            vec2 w1 = clamp(U+u+a.xy-0.5*o,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*o,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(o*o);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n        }\n   } else {\n    \tQ = A(U);vec4 q = Q;\n        for (int x = -1; x<=1; x++)\n        for (int y = -1; y<=1; y++)\n        if (abs(x) != abs(y))\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u), c = C(U+u), b = B(U+u);\n            u = (u)/dot(u,u);\n            float x = .1*(dot((bb*2.-1.)*(c*2.-1.)+(bb*2.-1.)*(b*2.-1.),vec4(-.1)));\n            Q.xy -= q.w*0.25*(c.w+a.w*(x+a.w*a.z-.9))*u;\n            Q.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n        }\n    }\n    Q.y -= Q.w*1e-2;\n    Q.xy *= .2+.77*min(pow(Q.w,.001),1.);\n    //Q = clamp(Q,-1.,1.);\n    // Solidify\n    Q.w -= Q.w*rate/(1.+10.*length(bb.xyz));\n    vec4 d = D(U);\n    \tvec2 t= 20.*normalize(vec2(d.w-d.y,d.x-d.z));\n        if ((iMouse.z>0.)&&ln(U,d.xy-t,d.xy+t)<2.)\n            Q = vec4(1e-1*clamp(d.xy-d.zw,-.8,.8),1,1);\n        if (U.y<1.||U.x<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tvec4 a = A(U), b = B(U);\n    Q = C(U);\n    float f = 1./(1.+10.*length(Q.xyz));\n    Q.w += rate*atan(100.*a.w)*(a.w-.2)*f;\n    Q.xyz = mix(Q.xyz,10.*b.xyz,rate*b.w*f);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// keep track of mouse\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texture(iChannel0,fragCoord/iResolution.xy);\n    if (iMouse.z>0.) {\n        if (p.z>0.) fragColor =  vec4(iMouse.xy,p.xy);\n    \telse fragColor =  vec4(iMouse.xy,iMouse.xy);\n    }\n    else fragColor = vec4(-iResolution.xy,-iResolution.xy);\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = vec4(0);\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 a = A(U+u), b = B(U+u);\n        #define q 1.1\n\t\tvec2 w1 = clamp(U+u+a.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q.xyz += m*a.w*b.xyz;\n        Q.w += m*a.w;\n    }\n    if (Q.w>0.)\n    \tQ.xyz/=Q.w;\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,0,0);\n    }\n    vec4 d = D(U);\n    vec2 t= 20.*normalize(vec2(d.w-d.y,d.x-d.z));\n        if ((iMouse.z>0.)&&ln(U,d.xy-t,d.xy+t)<2.)\n        Q = vec4(0.5+0.5*sin(4.*dot(normalize(d.xy-U),vec2(1,-1)*normalize(d.yx-d.wz))+.1+iTime*vec3(1,2,3)),1);\n\n    Q -= Q*rate;\n    if (iFrame < 1) Q = C(U);\n    Q = clamp(Q,-1.,1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3cWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3d3cDs", "name": "dust01", "author": "Del", "description": "just some more noise", "tags": ["noise", "volumetric", "dust"], "likes": 6, "viewed": 387, "published": 3, "date": "1601949232", "time_retrieved": "2024-07-30T20:41:51.894954", "image_code": "// volume noise test\n\nvec3 erot(vec3 p, vec3 ax, float ro)\n{\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<3.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\n#define brightness -7.7\n#define saturation 0.9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*0.8,2.);\n\tfloat time=iTime*0.04;\n\n\t//rotation\n    vec2  mm = iMouse.xy/iResolution.xy;\n\tfloat a1=0.5+(mm.x*0.5);\n\tfloat a2=0.8+(mm.y*0.5);\n    \n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,.75);\n\tfrom+=vec3(time*1.8,time,-5.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t// volumetric\n\tfloat s=0.1;\n    float fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<50; r++)\n    {\n\t\tvec3 p=from+s*dir*.5;\n\t\tvec3 p2 = p*4.0;\n\t\tfloat a = WaveletNoise(p2, 0.0, 1.9)*2.0 - 1.0;\n\t\ta *= a * a;\n\t\tv += vec3(s, s*s, s*s*s*s)* a * brightness * fade;\n\t\tfade *= 0.925;\n\t\ts += 0.032;\n\t}\n\tv=mix(vec3(length(v)),v,saturation);\n\tfragColor = vec4(v.gbr*.01,1.);\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3cDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 60, 60, 122], [124, 124, 170, 215, 728], [778, 778, 835, 835, 1668]], "test": "untested"}
{"id": "3dccDl", "name": "Fab8 #inktober2020 \"teeth\"", "author": "FabriceNeyret2", "description": "WIP\n[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 5, "viewed": 292, "published": 3, "date": "1601939880", "time_retrieved": "2024-07-30T20:41:52.646943", "image_code": "#define A(v)      clamp( r - R.y/32. * abs(v) , 0., 1. )                  //\n#define L(x,y)    ( a=b, b = vec2(x,y),                                    \\\n                    A( length( U-a - (b-a) * clamp(dot(U-a, b-a) / dot(b-a, b-a), 0., 1.) )) ) //\nvoid mainImage(out vec4 O,vec2 u) {                                 \n    vec2  R = iResolution.xy, a, B = vec2(.1,2), b,                       \n          V = ( u+u - R )  / R.y, U;\n    float T = mod(.3*iTime+2.,3.),\n          z = exp2(-T), r, l, i = 0., c = 0.,\n          t =  atan( 8. * sin(18.85*T) ) / 1.3 - .5;  // sin with faster change\n    V.x = abs(V.x);\n    for (; ++i<4.;  ) {                               // shape zoomed copies\n        U = V *= z*8.; z=1.;                          // scaling\n        c = 0.; U.y += t;                             // t: mouth animation\n        r = 1.5; b=B; c += L(1,-1)+L(2,2) + L(3,-.2)+L(3.9,1.6) + L(4.7,-.4)+L(5.5,.8) + L(6.2,-2)+L(6.8,.3);\n        r = .75; b=B; c += L(1, 4)+L(2,2) + L(3,3.5)+L(3.9,1.6) + L(4.7,2.5)+L(5.5,.8) + L(6.2, 2)+L(6.8,.3);\n        U.y = -U.y; U.y += t+t;          // above: top teeth below: bottom teeth\n        r = 1.5; b=B; c += L(.3,0)+L(1,2.2)+ L(2,-.4)+L(2.9,1.6) + L(3.9,-.2)+L(4.7,1.4) + L(5.5,.1)+L(5.8,1.2);\n        r = .75; b=B; c += L(.5,3)+L(1,2.2)+ L(2,  3)+L(2.9,1.6) + L(3.9,2.5)+L(4.7,1.4) + L(5.4, 2)+L(5.8,1.2);\n        l = i - T/3. -1.3; O += exp(-3.*l*l) * min(1.,c); // intensity fading small and large scale\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dccDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 287, 287, 1466]], "test": "untested"}
{"id": "3d3yWs", "name": "シャボン玉", "author": "illus0r", "description": "シャボン玉", "tags": ["raymarching", "reflection"], "likes": 13, "viewed": 555, "published": 3, "date": "1601933988", "time_retrieved": "2024-07-30T20:41:53.430848", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define EPSILON 0.001\n#define PI 3.14159265\n#define COL1 1.\n#define COL2 2.\n#define COL3 3.\n\n\nmat2 rot(float a) {float s = sin(a), c = cos(a);return mat2(c, -s, s, c);}\nfloat opSmoothUnion( float d1, float d2, float k ) {    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );    return mix( d1, -d2, h ) + k*h*(1.0-h); }\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n\n  // p.x+=10.*snoise(p.yz*.03+iTime*.2) * smoothstep(1., 10., length(p));\n  // p.y+=10.*snoise(p.yz*.03+iTime*.2) * smoothstep(1., 10., length(p));\n  // p=fract(p+.5)-.5;\n\n  p.x+=.03*snoise(p.yz*2.3+iTime*.2);\n  // p.z+=amp.z*snoise(p.xy*1.3+iTime*.2);\n  // p.y+=amp.y*snoise(p.xz*1.3+iTime*.2);\n  return vec2((length(p)-.5)*.8, COL1);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n  float info = 0.;\n  float glow = 9999.;\n  int ii=0;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    ii=i;\n  \tvec2 distToClosest = getDist(ro + rd * d);\n    d += abs(distToClosest.x);\n    info = distToClosest.y;\n    glow = min(glow, abs(distToClosest.x));\n    if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n    \tbreak;\n    }\n  }\n  return vec4(d, info, ii, glow);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, color,rd,n,ro,ref;\n    vec4 rm;\n    ro=vec3(0,0,1.5);\n    ro.xz*=rot(iTime);\n    float d, info, dtotal=0., steps, marches, glow;\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n    // rm = rayMarch(ro, rd);\n    // d = rm[0];\n    // info = rm[1];\n    // steps = rm[2];\n\n    vec3 light = vec3(50, 50, 50);\n    // n = getNormal(p);\n\n    // making several marches outside and inside\n    // the surface along the ray\n    for (int i = 0; i < 5; i++) {\n      rm = rayMarch(ro, rd);\n      info = rm[1];\n      glow += rm[3];\n      // color+=0.00000002/glow;\n      // marches+=1.;\n      dtotal += d = rm[0];\n      if (dtotal > MAX_DIST) break;\n      // мы нактнулись.\n      p = ro + rd * d;\n      n = getNormal(p);\n      // находим отражение\n      float refK = 7.;\n      ref = reflect(rd, n);\n      color+=refK*texture(iChannel0, ref).xyz;\n      marches+=refK;\n      // находим блеск\n      color+=2.*smoothstep(-.5,1.,dot(ref, rd));\n      color+=2.*smoothstep(.6,1.,dot(ref, rd));\n      // находим цвет\n      vec3 amp = vec3(2.3);\n      n.z+=amp.z*snoise(n.xy*.6+iTime*.05);\n      n.x+=amp.x*snoise(n.yz*.6+iTime*.05);\n      n.y+=amp.y*snoise(n.xz*.6+iTime*.05);\n      color+= n*.5+.5;\n      marches++;\n\n\n      ro = p + rd * 0.05;\n    }\n    color/=marches;\n\n\n\n    // vec3 dirToLight = normalize(light - p);\n    // vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n    // float distToObstable = rayMarchLight.x;\n    // float distToLight = length(light - p);\n\n\n\n    fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3yWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 157, 157, 212], [213, 213, 265, 265, 362], [363, 363, 421, 421, 519], [520, 520, 543, 543, 579], [580, 580, 601, 601, 648], [649, 649, 670, 670, 717], [718, 718, 740, 740, 775], [776, 776, 798, 850, 2371], [2376, 2455, 2477, 2649, 2816], [2901, 2901, 2934, 2934, 3316], [3318, 3318, 3342, 3342, 3560], [3562, 3562, 3616, 3616, 3843], [3845, 3845, 3895, 3895, 4086], [4088, 4088, 4144, 4144, 5757]], "test": "untested"}
{"id": "Wd3cDl", "name": "PewDiePie Simple Pattern", "author": "saafan", "description": "PewDiePie Brand Pattern", "tags": ["waves", "pewdiepie"], "likes": 1, "viewed": 267, "published": 3, "date": "1601932612", "time_retrieved": "2024-07-30T20:41:54.302516", "image_code": "const float speed = 3.0f;\nconst float frequencyX = 13.0f;\nconst float frequencyY = 15.0f;\nconst float yTrans = 0.0f;\nconst float wavesHeight = 0.0f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    \n    vec3 yColor = vec3(0,0,0);\n\tif (sin((uv.y + sin(uv.x * frequencyX - (iTime * speed))) * frequencyY + sin(iTime))   > wavesHeight)\n\t\tyColor = vec3(0.98, 0, 0.25);\n\t//color = vec4(yColor, 1.0f);\n    \n    fragColor = vec4(yColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3cDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 207, 257, 654]], "test": "untested"}
{"id": "Ws3cWl", "name": "Fab7 #inktober2020 \"fancy\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 15, "viewed": 304, "published": 3, "date": "1601931823", "time_retrieved": "2024-07-30T20:41:55.155237", "image_code": "#define A(v)      clamp( 1.5*r - min(s,2e2) * abs(v) , 0., 1. ) * min(1.,s/2e2)            //\n#define C(C,r)    A( length(C-U) - r )                                //\n#define L(x,y)    ( a=b, b = vec2(x,y),                                \\\n                    A( length( U-a - (b-a) * clamp(dot(U-a, b-a) / dot(b-a, b-a), 0., 1.) )) ) //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = u / R.y, a, b, B = vec2(.39,.31);\n    O += exp2(-length(1.-u/R)/1.4)-.5;        /* shift to white */\n    float t = exp2(fract(.2*iTime)), r = 1. + .5*t, s = R.y*t;\n    R /= R.y;\n    U = ( U + (t-1.) * R ) / t;                /* infinite zoom */\n    for( int i=0; ++i<8; U += U-R, s/=2. ) {   /* inception     */\n        b = B; O += C(.4,.08) +  L(.3,.1) +  L(.6,.1);  /* body */\n        b = B; O += L(.7,.1)  +  L(1 ,.3) +  L(1.2 ,.1) + L(1.25,.15);\n        b = vec2(.7,.09); O += L(1.05,.15)+  L(1.35,.1) + L(1.4 ,.15);\n        r *= .7;                                       /* dream */\n        O += C(R*vec2(.31,.54),.03) + C(R*vec2(.348,.62),.03);\n        for ( t=0. ; t < 1.6; t+= .1 )\n            O += C( R - R*.69* cos(t+vec2(0,11)), .03);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3cWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 374, 374, 1170]], "test": "untested"}
{"id": "Ws3yWl", "name": "test_xbluebeardx", "author": "xbluebeardx", "description": "test", "tags": ["test"], "likes": 5, "viewed": 239, "published": 3, "date": "1601925914", "time_retrieved": "2024-07-30T20:41:56.037877", "image_code": "\nfloat DrawLine(vec2 pp, float yTarget) {\n\tfloat res = smoothstep(yTarget-0.01,yTarget+0.1,pp.y)+smoothstep(yTarget+0.01, yTarget-0.01, pp.y);\n    return res;\n}   \nfloat DE( vec2 pp, out bool blood, float t )\n{\n\tpp.y += sin(pp.x)/*(\n\t\t.4 * sin(.5*2.3*pp.x+pp.y) +\n\t\t.2 * sin(.5*5.5*pp.x+pp.y) +\n\t\t0.1*sin(.5*13.7*pp.x)+\n\t\t0.06*sin(.5*23.*pp.x))*/;\n\t\n\tpp += vec2(0.,0.4)*t;\n\t\n\tfloat thresh = 5.3;\n\t\n\tblood = pp.y > thresh;\n\t\n\tfloat d = abs(pp.y - thresh);\n\t// todo use proper implicit dist\n\t//d /= sqrt(1.+grad*grad);\n    pp.y *= 2.0;\n\treturn d;\n}\n\nvec3 sceneColour( in vec2 pp )\n{\n\tfloat endTime = 16.;\n\tfloat rewind = 2.;\n\tfloat t = mod( iTime, endTime+rewind );\n\t\n\tif( t > endTime )\n\t\tt = endTime * (1.-(t-endTime)/rewind);\n\t\n\tbool blood;\n    \n\tfloat d = DE( pp, blood, t );\n    float line = DrawLine(pp, 2.0);\n\t\n\tif( !blood )\n\t{\n\t\t// floor. not really happy with this at the moment..\n\t\tvec3 floorCol = vec3(.25);\n\t\t\n\t\tfloorCol = texture( iChannel0, -(vec2(pp.x/20.,pp.y/33.)+vec2(.5,.02)) ).xyz;\n\t\tfloat floori = (floorCol.x+floorCol.y+floorCol.z)/3.;\n\t\t\n\t\tfloori = smoothstep(0.5,.53,floori) ;\n\t\tfloori = smoothstep(-5.15,1.,floori);\n\t\tfloori = 1.-floori;\n\t\tfloorCol = vec3(floori);\n\t\t\n\t\t// ao from blood\n\t\tfloat ao = clamp( smoothstep(0.,.2,d), 0., 1.);\n\t\tvec3 res = mix(1.,sqrt(ao),.25) * floorCol;\n        res *= line;\n        return res;\n\t}\n\telse\n\t{\n\t\t//blood. fake a 3d look\n\t\t//height\n\t\tfloat h = clamp( smoothstep(.0,.25,d), 0., 1.);\n\t\th = 4.*pow(h,.2);\n\t\t// couldnt get matching results using finite diffs, need to sort this out.\n\t\t/*vec2 eps = vec2(0.,.01);\n\t\tfloat dx = clamp( smoothstep(.0,.25,DE(pp+eps.yx,blood,t)), 0., 1.);\n\t\tdx = (dx - h)/eps.y;\n\t\tfloat dy = clamp( smoothstep(.0,.25,DE(pp+eps.xy,blood,t)), 0., 1.);\n\t\tdy = (dy - h)/eps.y;*/\n\t\t//vec3 N = vec3(-dx, 1., -dy );\n\t\t\n\t\t// gradient instructions. easy but produces artifacts\n\t\tvec3 N = vec3(-dFdx(h), 1., -dFdy(h) );\n        float line2 = DrawLine(pp, (h/4.+2.));\n        //line2 = 1.;\n\t\tN = normalize(N);\n\t\tvec3 L = normalize(vec3(.5,.7,-.5));\n\t\tvec3 res = pow(dot(N,L),10.)*vec3(1.);\n\t\t// make it more red hack\n\t\tres += vec3(.5,-.3,-0.3);\n\t\t// window refl\n\t\tvec2 off = pp-vec2(5.3,2.);\n\t\t\n\t\tfloat r = length(off);\n\t\tfloat v = 1.;\n\t\tfloat band = 20./iResolution.x;\n\t\tv *= smoothstep( 0.8, .8+band, r );\n\t\tv *= smoothstep( 2.1, 2.1-band, r );\n\t\tfloat gap1 = smoothstep(1.3,1.3-band,r) + smoothstep( 1.4,1.4+band,r);\n\t\tv*= gap1;\n\t\t\n\t\t// the witness\n\t\tfloat h1t = 3.;\n\t\tfloat h2t = 4.1;\n\t\tfloat ht = 5.;\n\t\tfloat hand1p = 1.-clamp((t-h1t)/5.,0.,1.);\n\t\tfloat hand2p = 1.-clamp((t-h2t)/5.,0.,1.);\n\t\tfloat headp = smoothstep(0.,1.,1.-clamp((t-ht)/6.,0.,1.));\n\t\tv *= smoothstep(.06,.06+band, length(pp-vec2(6.71,3.61)-vec2(hand1p)));\n\t\tv *= smoothstep(.06,.06+band, length(pp-vec2(7.04,3.25)-vec2(hand2p)));\n\t\tv *= smoothstep(.13,.13+band, length(pp-vec2(6.84,3.4)-vec2(headp)));\n\t\t// ears\n\t\tv *= smoothstep(.02,.02+band, length(pp-vec2(6.74,3.49)-vec2(headp)));\n\t\tv *= smoothstep(.02,.02+band, length(pp-vec2(6.93,3.3)-vec2(headp)));\n\t\t\n\t\tband /= r;\n\t\tfloat a = atan( off.y, off.x );\n\t\tv *= smoothstep( 0.5,0.5+band, a);\n\t\tv *= smoothstep( 1.8,1.8-band, a);\n\t\tfloat gap2 = smoothstep( 1.1,1.1-band, a) + smoothstep( 1.2,1.2+band, a);\n\t\tv *= gap2;\n\t\t\n\t\tv *= .95;\n\t\tres = (1.-v)*res + v*vec3(1.);\n\t\tres *= line;\n        res *= line2;\n\t\treturn res;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x /= iResolution.y/iResolution.x;\n\t\n\tfragColor.a = 1.0;\n\tfragColor.xyz = sceneColour(uv*4.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 160], [164, 164, 210, 210, 546], [548, 548, 580, 580, 3323], [3325, 3325, 3382, 3382, 3523]], "test": "untested"}
{"id": "tstcDX", "name": "One-liner RGB+HSV Converters", "author": "kowbell", "description": "Small & efficient RGB -> HSV and HSV -> RGB conversion functions for your shaders! Public domain/CC0. Original algorithms by Sam Hocevar, licensed under the WTFPL (which can be re-licensed however you want, e.g. to CC0!)", "tags": ["color", "rgb", "hsv", "conversion", "oneliner"], "likes": 4, "viewed": 365, "published": 3, "date": "1601912039", "time_retrieved": "2024-07-30T20:41:56.865663", "image_code": "/** \n * Public Domain drag-n-drop RGB <-> HSV converters for your shaders.\n * All you need are the two following one-liner functions!\n * You can even drop the preceeding comment with attribution\n * if you want!\n *\n * Non-minified, easier-to-read functions available\n * commented out below.\n *\n * These are both originally by Sam Hocevar \n * who has generously released these over the WTFPL, \n * which can be freely relicensed as CC0/Public Domain.\n * See https://stackoverflow.com/a/17897228/8940353\n * and http://www.wtfpl.net/faq/ (profanity warning)\n *\n * So, these are public domain! But please credit Mr. Hocevar\n * if you don't mind! Or link back to this shader so we can\n * credit Mr. Hocevar AND show folks the unminified source :)\n *\n * Check out my other handy one-liner shader utilities at\n * https://www.shadertoy.com/playlist/l323Wz\n */\n\n\n// Combined one-liner with signatures first & attrib link:\n/* shadertoy.com/view/tstcDX */ vec3 rgb2hsv(vec3 c); vec3 hsv2rgb(vec3 c); vec3 rgb2hsv(vec3 c){const vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);const float e=1.e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);} vec3 hsv2rgb(vec3 c){const vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}\n\n\n\n// OR, Separate one-liners with attribution:\n/* RGB<->HSV Algorithms by Sam Hocevar. CC0. See https://www.shadertoy.com/view/tstcDX for more info. */\n//vec3 rgb2hsv(vec3 c){const vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);const float e=1.e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n//vec3 hsv2rgb(vec3 c){const vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}\n\n\n\n\n\n\n\n/** NON-MINIFIED VERSIONS ******************************************* */\n/*\nvec3 rgb2hsv(vec3 c)\n{\n    const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    const float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n*/\n\n\n\n\n\n/** DEMO ******************************************* */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    \n    float scaledTime = iTime * 0.1;\n    float time01 = mod(scaledTime, 1.);\n    \n    // vary hue over time,\n    // map saturation to mouse x,\n    // map value to mouse y\n    // Mouse values are inverted bc the first time you open this\n    // shader mouse will be at (0,0), and I don't want you to\n    // think this is broken ;)\n    vec3 col = hsv2rgb(vec3(time01, 1. - mouse.x, 1. - mouse.y));\n    \n    // Demonstrate that these functions inverse each other\n    // If you see a difference in the left & right halves of\n    // the intro, then the formulas are borked :(\n    if (uv.x > .5)\n    {\n        col = hsv2rgb(rgb2hsv(col));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstcDX.jpg", "access": "api", "license": "public-domain", "functions": [[987, 987, 1008, 1008, 1265], [1266, 1266, 1287, 1287, 1412], [2652, 2708, 2765, 2765, 3521]], "test": "untested"}
{"id": "wdtyDX", "name": "modmunch", "author": "DJDoomz", "description": "some cool patterns", "tags": ["2d", "int", "bitwise", "munching"], "likes": 7, "viewed": 326, "published": 3, "date": "1601910254", "time_retrieved": "2024-07-30T20:41:57.653557", "image_code": "\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O = vec4( (int(O.xy = U*.3 + iTime/.1) ^ int(O.y)+211) %  (int(iTime*1.5) % 60 + 9)  ) *.2;\n}\n\n//Unknown error: ERROR: Undefined function 'mainImage()' used in the following call chain:main)\n//I guess shadertoy broke the define trick?\n//93 chars by Fabrice\n//#define mainImage(O,U)\t\t\t\\\n\t//O = vec4( (int(O.xy = U*.3 + iTime/.1) ^ int(O.y)+211) %  (int(iTime*1.5) % 60 + 9)  ) *.2/*\n\n/*\n\n//improvement by Fabrice\n#define mainImage(O,U)\t\t\t\\\n    O.xy = U*.3 + iTime/.1;\t\t\\\n\tO = vec4( (int(O) ^ int(O.y)+211) %  (int(iTime*1.5) % 60 + 9)  ) *.2\n  \n\n97 by Xor:\n#define mainImage(O,U)\t\t\t\\\n    O.xy = U*.3 + iTime/.1;\t\t\\\n\tO = vec4( (int(O) ^ int(O.y+211.)) %  (int(iTime*1.5) % 60 + 9)  ) *.2\n\n\n105 char by Fabrice:\n#define mainImage(O,U)                                 \\\n    ivec2 u = ivec2( U*.3 + vec2(0,221) + iTime/.1 );  \\\n\tO = vec4( (u.x^u.y) % ( int(iTime*1.5)%60 +9 ) ) *.2\n\n\n-10 by Xor:\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u *= .3;\n    u.y += 221.;\n    u += iTime/.1;    \n\to=vec4((int(u.x)^ int(u.y))%(int(iTime*1.5)%60+9))*.2;\n}\n\n\nog shader:\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u *= .3;\n    u.y += 221.;\n    u += 10.*iTime;    \n\to=vec4((int(u.x)^ int(u.y))%int(fract(iTime/40.0)*60.0+9.))*.2;\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tddczf", "name": "Twist3000", "author": "z0rg", "description": "A simple demoscenish styled twisted cube inspired by this wonderful demo \"Ion Traxx\" by MFX and Kewlers.\nhttps://www.youtube.com/watch?v=LOWZmOhz8wI", "tags": ["3d", "raymarching", "checkerboard", "twist"], "likes": 8, "viewed": 292, "published": 3, "date": "1601887639", "time_retrieved": "2024-07-30T20:41:58.407541", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 p) { return abs(p.x)+abs(p.y); }\n\nvec3 getDir(vec3 fwd, vec2 uv)\n{\n    vec3 r = normalize(cross(normalize(fwd), vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r, normalize(fwd)));\n    float fov = .8;\n    return uv.x*r+uv.y*u+fov*fwd;\n}\n\nvec2 add(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n    \treturn a;\n    return b;\n}\n\n// Credits to IQ\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p-vec3(0.,1.,0.);\n    p2.xz *= r2d(sin(p.y+iTime));\n    vec2 box = vec2(sdBox(p2, vec3(1., 3., 1.)), 1.);\n\tvec2 ground = vec2(p.y, 0.); \n    return add(box, ground);\n}\n\n// Credits to IQ\nvec3 calcNormal( in vec3 p, in float t )\n{\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\nvec3 rdr2(vec2 uv)\n{\n    vec3 grad = (1.-sat(abs(uv.x*1.)))*vec3(0.6, 0.87,1.).zxy;\n    vec3 col = grad*.5*(sin(iTime*.5)*.5+.5);\n    col += (1.-pow(sat(lenny(uv)-.2), .5))*.5;\n    \n    float bps = 1./2.2;\n    float beat = mod(iTime, bps)/bps;\n    \n    float beat2 = mod(iTime+1., bps)/bps;\n    \n    float dist = 12. +1.5*beat;\n    float camT = iTime*.5;\n    vec3 ro = vec3(dist*sin(camT),4.+sin(camT),dist*cos(camT));//vec3(sin(iTime*.5+1.), 1., -5.+mod(iTime, 30.));\n    vec3 target = vec3(0., 2.,0.);\n    vec3 rd = getDir(normalize(target-ro),uv); \n    \n    float d = 0.01;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * d;\n        vec2 res = map(p);\n        if (res.y > 0.5)\n        col += pow((1.-sat(res.x*.05)), 5.5)*.03*vec3(0.4,.57,1.);\n        if (res.x < 0.01 && d < 100.)\n        {\n            vec3 norm = calcNormal(p, d);\n            vec3 diff = vec3(0.);\n            vec3 spec = vec3(0.);//0.3, 0.7,1.);\n            if (res.y < 0.5)\n            {\n                float chkSz = 2.5;\n                float sharp = 50.;\n                float checkerBoard = mod(p.x*1., chkSz) - .5*chkSz;\n                checkerBoard = clamp(checkerBoard*sharp, -1.0, 1.0);\n                checkerBoard *= clamp((mod(p.z*1., chkSz) - .5*chkSz)*sharp, -1., 1.);\n                \n                diff = mix(vec3(0.),vec3(1.), sat(checkerBoard*1.));\n                spec = vec3(1.,.1,0.1).zxy;\n            }\n            \n            spec = spec.zyx;\n            \n            \n            float lSpd = .5;\n            vec3 lPos = vec3(0.,1.,0.);\n            vec3 lDir = normalize(lPos-p);\n            col += vec3(.1); // Ambient\n            vec3 h = normalize(lDir+rd);\n            col += diff*sat(dot(norm, lDir)); // diffuse\n            col += spec*pow(sat(dot(norm,h)), 2.9); // spec\n            break;\n        }\n    \td += res.x*.5;\n    }\n    \n    \n    col += grad*.2;\n    col *= 1.-pow(sat(length(uv*.5)), .5);\n    \n    col += (1.-pow(sat(lenny(uv*.5)), .5))*.1*sat(d-10.);\n    col *= (1.-sat(beat2-.7))*vec3(1.)*(pow(sat(d/100.), .1));\n\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec2 dir = normalize(uv);\n    float strength = length(uv)*0.05;\n    \n    vec3 col;\n    col.r = rdr2(uv+dir*strength).x;\n    col.g = rdr2(uv).x;\n    col.b = rdr2(uv-dir*strength).x;\n\treturn col;\n}\n\nvec2 myPixel(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    \n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec2 uv2 = myPixel(uv, 0.05);\n    vec3 col;\n    \n    col = rdr(uv);\n    col = mix(col, rdr(uv2), sat(length(uv)));\n    col = pow(col, vec3(1./.6));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddczf.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 447, 447, 508], [510, 510, 531, 531, 559], [561, 561, 593, 593, 762], [764, 764, 790, 790, 840], [842, 859, 890, 890, 977], [979, 979, 997, 997, 1179], [1181, 1198, 1240, 1240, 1465], [1466, 1466, 1486, 1486, 3536], [3538, 3538, 3557, 3557, 3757], [3759, 3759, 3792, 3792, 3880], [3882, 3882, 3939, 3939, 4192]], "test": "untested"}
{"id": "WsccDf", "name": "Image Re-Painter", "author": "Miestrode", "description": "about a couple of weeks ago (2020-10-04) i began looking into Python.\nsoon enough i learned about a library called Pillow (PIL) and created this.\nit takes some image as an input and some colors as another input, it then will re-color the image", "tags": ["paint", "image", "repainter"], "likes": 2, "viewed": 431, "published": 3, "date": "1601837403", "time_retrieved": "2024-07-30T20:41:59.170501", "image_code": "// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// Repainting an image is always quite a feat when done well,\n// so why not automate it? well that's the idea I had.\n// Originally I had a more broad idea in mind, which was to\n// repaint images from other images of differing colors, but\n// this is a step in the right direction.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// Repainting an image is always quite a feat when done well,\n// so why not automate it? well that's the idea I had.\n// Originally I had a more broad idea in mind, which was to\n// repaint images from other images of differing colors, but\n// this is a step in the right direction.\n\n// below is the optimized code I used:\n\nvec3 array[9] = vec3[](vec3(1.0,0.1,0.5),vec3(1.0,0.5,0.6),vec3(0.7,0.25,0.5),vec3(0.8,0.8,0.8),vec3(0.7,0.6,0.7),vec3(0.9,0.9,0.9),vec3(0.95,0.95,0.95),vec3(0.3,0.1,0.1), vec3(0.1,0.1,0.1));\n\nvec3 repaint(in vec3 icol)\n{\n    float min = 1.0;\n    \n    vec3 col;\n    \n    for(int i; i<9; i++)\n    {\n        float d = distance(vec3(icol),vec3(array[i]));\n        if(d<min)\n        {\n            col = array[i]; \n            min = d;\n        }\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = vec4(repaint(texture(iChannel0,uv).xyz),1.0);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsccDf.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[422, 422, 476, 476, 557]], "test": "untested"}
{"id": "wddcDN", "name": "大龙猫  - Wetshader", "author": "totetmatt", "description": "Still learning 3D . \nExperiment based on @evvvvil_ ray caster. ", "tags": ["3d"], "likes": 6, "viewed": 290, "published": 3, "date": "1601827368", "time_retrieved": "2024-07-30T20:41:59.921493", "image_code": "vec2 z,v,e=vec2(.001,-.001); \n\n\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvoid md(inout vec2 uv,vec2 p){\n    uv = abs(uv) - p;\n    if(uv.x < uv.y) uv.xy = uv.yx;\n}\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n    vec2 halfsize = size*0.5;\n    vec2 c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    p *= mod(c,vec2(2.))*2. - vec2(1.);\n    return c;\n}\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\nvec2 sdf(vec3 p){\n\n       p.z   -=(iTime);\n       p.xy  *=r(iTime*.2);\n       float c= pMod1(p.z,12.);\n       p.xy  *=r(c*.5);\n    p.x = abs(p.x)-12.5;\n    p.y = abs(p.y)-4.5;\n      p.xy  *=r(iTime*.5);\n     vec2 h,t=vec2(length(p)-2.,4.);\n\n   \n        p.x = abs(p.x)-1.3;\n        p.y -=1.8;\n     h = vec2(length(p)-1.,5.);\n     t = t.x< h.x ? t : h; \n     t.x*=.7;\n\n \n    return t;\n\n}\n#define TRLIMIT 256.\nvec2 tr(vec3 ro, vec3 rd){\n    vec2 h,t=vec2(.1);\n    for(float i=0.;i<TRLIMIT;i++){\n        h= sdf(ro+rd*t.x);\n        if(h.x < .0001 || t.x > TRLIMIT) break;\n        t.x+=h.x;\n        t.y=h.y;\n    }\n    if(t.x>TRLIMIT) t.y=0.;\n    return t;\n    \n}\n\n#define a(d) clamp(sdf(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,sdf(po+ld*d).x/d)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 cam = vec4(sin(iTime*.5)*.5,cos(iTime*1.),10.0,1.50);\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(cos(cam.w+cam.x)*cam.z, cam.y,sin(cam.w+cam.x)*cam.z);\n   \n    vec3 cw = normalize(vec3(0.)-ro);\n    vec3 cu = normalize(cross(cw,vec3(0.,1.,0.)));\n    vec3 cv = normalize(cross(cu,cw));\n    vec3 rd = mat3(cu,cv,cw)*normalize(vec3(uv,.5));\n    \n    vec3 co, fo = vec3(.0)-length(uv)*.1-rd.y*.1;\n    co = fo;\n    vec3 ld = normalize(vec3(1.2,1.3,10.5));\n    \n    vec2 z = tr(ro,rd);\n    float t = z.x;\n    vec3 al ;\n    if(z.y > 0.) { \n        vec3 po  = ro+rd*t;\n        vec3 no = normalize(e.xyy*sdf(po+e.xyy).x +\n        e.yyx*sdf(po+e.yyx).x +\n        e.yxy*sdf(po+e.yxy).x +\n        e.xxx*sdf(po+e.xxx).x );\n        if(z.y ==3.){\n        al = vec3(1.0,1.0,1.0);\n        }\n        if (z.y == 4.) {\n            al=vec3(1.0,.0,.0);\n        }\n        if(z.y == 5.) {\n         al = vec3(1.0,1.0,1.0);\n        }\n        float dif = max(0.,dot(no,ld)),\n        fr = pow(1.+dot(no,rd),4.), //Fersnel\n        sp = pow(max(dot( reflect(-ld,no),-rd),0.),40.); //specular\n        co = mix(sp+al*(a(.05)*a(.1)+.2)*(dif+s(2.)),fo,min(fr,.5));\n    }\n    \n    fragColor = vec4(pow(co,vec3(.945)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddcDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 48, 48, 106], [107, 107, 137, 137, 196], [197, 197, 240, 240, 411], [412, 412, 452, 452, 585], [586, 586, 603, 603, 971], [993, 993, 1019, 1019, 1242], [1336, 1336, 1391, 1391, 2629]], "test": "untested"}
{"id": "WdcyWf", "name": "OverlaySST", "author": "Del", "description": "Attract & Repel shader overlay - Red=Repel, Blue=Attract\nHold Mouse for radial\n - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["lines", "sin", "pow"], "likes": 3, "viewed": 287, "published": 3, "date": "1601827172", "time_retrieved": "2024-07-30T20:42:00.674480", "image_code": "// Attract & Repel shader overlay - Red=Repel, Blue=Attract\n\nfloat Lines(float x,float dir)\n{\n    //x+=sin(iTime*2.0)*1.5; // offset\n    float d = 1.0-abs(x);\n    float r = pow(abs(x*0.5),3.0);\n\tfloat v = 0.75 + 0.5*sin((r+dir)/0.006);\n    return v * smoothstep(-0.2,0.8,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y; \n    float t = iTime;\n\n    uv += (sin(t*1.5+uv*16.0)*0.025).yx;   \t// +=wibble\n    if (iMouse.z>0.5)\n        uv = vec2(dot(uv,uv));\n    \n    // Change X,Y,Direction,Colour every 4 seconds\n    float mcount = t - mod(t,4.0);\n    float cmult1 = step(8.0, mod(mcount,16.0));\n    float cmult2 = step(4.0, mod(mcount,8.0));\n    float speed = mix(0.035,-0.035,cmult1);\n    vec3 col = mix(vec3(0.4,0.5,0.9), vec3(0.9,0.2,0.2), cmult1);\n    float v = mix(uv.x,uv.y,cmult2);\n    float c = Lines(v,t*speed);\n\tfragColor = vec4(col*c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 93, 132, 276], [278, 278, 335, 335, 926]], "test": "untested"}
{"id": "wddcW2", "name": "anisotropic x16 filtering", "author": "FabriceNeyret2", "description": "left:   similar to MIPmaping \nright: aniso x16 nVidia-like anisotropic filtering: use 16 samples along main pixel footprint axis, using MIPmap level of pixel size = small pixel footprint axis.\nMouse control or auto-rot.", "tags": ["antialiasing", "filtering", "anisotropic", "tuto", "short", "anisox16"], "likes": 11, "viewed": 996, "published": 3, "date": "1601813763", "time_retrieved": "2024-07-30T20:42:01.430458", "image_code": "// NB: more precise version here: https://www.shadertoy.com/view/4lXfzn\n//                                https://www.shadertoy.com/view/ltXfRr\n\nvoid mainImage( out vec4 O, vec2 u )\n{   O-=O;\n    vec2  R = iResolution.xy,\n          U = ( u -.5 * R ) / R.y;                      // normalized coordinates\n    float t = iMouse.z > 0. ? 6.3*iMouse.x/R.x : .1*iTime, \n          z = .5-U.y,                                   // depth along the plane\n          s = float(textureSize(iChannel0,0).x);        // texture size\n    U = vec2( U.x , 1 )/ z -.0*iTime;                   // perspective parameterization\n    U = vec2(0,.5) + (U-vec2(0,.5)) *mat2(cos(t + vec4(0,33,11,0)));\n \n    vec2 A = dFdx(U), B = dFdy(U),                      // rectangle footprint:\n         L =  A + B *sign(dot(A,B)) ,                   //   major axis\n         l =     A - dot(A,L)*L/dot(L,L)\n             - ( B - dot(B,L)*L/dot(L,L) );             //   approx minor axis \n \n    if (u.x < R.x/2.) {                                 // left: ~regular MIPmap\n     // float lod = log2(length(L) *s);\n        float lod = log2( max(length(A),length(B)) *s );\n         O = textureLod(iChannel0, U, lod);\n    } else {                                            // right: anisox16\n        float lod = log2(length(l) *s);\n        for (float i=-7.5; i< 8.; i++ )\n            O += textureLod(iChannel0, U+i/16.*L, lod) / 16.; \n    }\n    O = pow(O, vec4(1./2.2) );                          // to sRGB\n    if (floor(u.x)==floor(R.x/2.)) O = vec4(1,0,0,0);   // red separator\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 183, 183, 1538]], "test": "untested"}
{"id": "tdtyW2", "name": "genealogy (mono-parent)", "author": "FabriceNeyret2", "description": "Ancestors are represented by random colors on top.\nEach line is a new generation.\nA child inherit from the id of his parent, randomly chosen in the neighborhood of size L at the previous generation. \nThis illustrate how gene pool weakens (if no mutations)", "tags": ["simulation", "automata", "short", "genetics", "genealogy"], "likes": 9, "viewed": 336, "published": 3, "date": "1601804343", "time_retrieved": "2024-07-30T20:42:02.229323", "image_code": "void mainImage(out vec4 O, vec2 U) { O = T(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float L = 15.;                        // inheritance neighborhood\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 R  = iResolution;\n    O.rgb = U.y ==  R.y - .5\n      ? // top line: random colors\n        fract(1e4*sin( U.x  * R ) )\n      : // inherit from a random neighbor within the line right above\n        T( mod( U + vec2( L *( fract(1e4*sin( dot(U,vec2(327,293)) )) - .5 ) , 1 ), R.xy ) ).rgb;\n}                                                // why R.xy don't work at res 512 or 640 ? ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch(iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 48]], "test": "untested"}
{"id": "wdtyWj", "name": "fake Depth of Field 2", "author": "ttg", "description": "Variation on [url]https://www.shadertoy.com/view/ws3cDj[/url]", "tags": ["dof", "mipmap", "depthoffield"], "likes": 7, "viewed": 440, "published": 3, "date": "1601783971", "time_retrieved": "2024-07-30T20:42:03.004251", "image_code": "void mainImage( out vec4 O, vec2 u )\n{   vec2  R = iResolution.xy,\n          U = u / R;                                    // normalized coordinates\n    float z = texture( iChannel0, U ).w;                // scene depth\n        O = textureLod(iChannel0, \n                       U,\n                       -6.+log2(length(R)*abs(z-1.6)) ); // log2( circle of confusion ) \n  O = pow(O,vec4(1./2.2)); // linearize output\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{   vec2  U = u / iResolution.xy;                       // normalized coordinates\n    float z = 1.-.7*U.y;                                // depth along the plane\n        O = 1.0*texture(iChannel0, \n                       vec2( U.x-.5 , 1 )/ z -.1*iTime // perspective parameterization\n                       ).xxxx;\n    O.w = 1./z;\n}\n", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 418]], "test": "untested"}
{"id": "wsccD2", "name": "Day 287", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 9, "viewed": 411, "published": 3, "date": "1601756249", "time_retrieved": "2024-07-30T20:42:03.967675", "image_code": "// Fork of \"Day 271\" by jeyko. https://shadertoy.com/view/3s3cz8\n// 2020-10-03 16:17:35\n\n// Fork of \"Day 269\" by jeyko. https://shadertoy.com/view/WljfWd\n// 2020-09-16 10:42:45\n\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE and BEZIER by demofox\n// sdPolygon and sdTri  from IQ \n  \n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.4;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (1./1.)\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n\n\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 r22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(99.);\n    }\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBoxRound( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdBox( in vec3 p, in vec3 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,p.z));\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th, float edging)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    float dist = length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n\t\n    \n    dist = max(dist, -dot(p - a*1. - vec2(th*edging,0.),normalize(vec2(1,-1.))));\n    \n    \n    dist = max(dist, dot(p - b*1. + vec2(th*edging,0.),normalize(vec2(1,-1.))));\n    \n\treturn dist;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv, float fov){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + (right*uv.x + up*uv.y)*fov);\n}\n", "buffer_a_code": "\nvec4 noise(float t);\nvec4 valueNoise(vec2 t, float w);\nvec4 fbm(vec2 uv);\n\nfloat df = 0.;\nfloat dfo = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n\nvec3 ro = vec3(0.,0.14,.12)*10.;\nvec3 lookAt = vec3(0.,0.3,0.);\nvec3 rd = vec3(0);\n\n// ----------\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb);\nfloat bspline( in vec2 coords );\nfloat jaggy(vec2 uv, float densitya, float densityb, float w);\nfloat dotwork(vec2 uv, float w, float densitya, float densityb);\nfloat screenprint(vec2 p,float lum, float cellSize, float strength);\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt, bool rotational);\n\nfloat mp = 1.;\n\nfloat map(vec3 p){\n\tfloat d = 10e5;\n    \n    //p.z = pmod(p.z,4.5);\n    \n    //d = length(p.xz) + 0.0 - abs(sin(p.y*8.))*.3*smoothstep(1.,0.,length(p.y));\n    \n    //d = abs(length(p.xz) - 0.1);\n\n        \n    d = min(d,abs(length(p) - 0.07));\n\n    \n    d = min(d,abs(length(p.yz) - 0.02));\n    d = d*4.;\n    \n    \n    \n    /*\n    //d = length(p) - .64;\n    for(int i = 0; i < 5; i++){\n    \tp = abs(p);\n        p.xz *= rot(0.25*pi);\n        p -= 0.1;\n    \t//d = xor(d, max(length(p.z), length(p.y) - 1.),0.4);\n      \td = xor(d, length(p.xy) - 0.5,0.4);\n      \n        \n    }*/\n    \n    //  \n    \t//d = xor(d, length(p.zx) - 0.3,0.3);\n    \n    //d = sdBox(p,vec3(0.15));\n    //d = min(d,length(p.x) - 0.);\n    \n    //d = abs(d) - 0.01;\n    \n    return d*1.;\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.,0.0001);\n\treturn normalize(map(p) - vec3(\n    \tmap(p - t.yxx),\n    \tmap(p - t.xyx),\n    \tmap(p - t.xxy)\n    ));\n}\n\n\n#define EPS 0.0001\n\nfloat march(inout vec3 p){\n\tfloat d = 10e5;\n    \n    for(float i = 0.; i < 200.; i++){\n        float m = map(p);\n        d = min(d,m);\n        if(d < EPS){\n        \tbreak;\n        }\n        p += rd*(m + 0.00);\n    }\n    \n    \n    return d;\n}\n\n\nfloat marchaa(vec2 uv){\n    float col = 0.;\n    float aa = 1.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n        vec2 luv = uv + vec2(mod(i,aa),floor(i/aa))/aa/iResolution.xy;\n        vec3 p = ro;\n        \n        float m = march( p);\n        if (m < EPS){\n        \n            vec3 n = getNormal(p);\n            \n            vec3 l = normalize(vec3(1.,2.,-1.));\n           \n            float diff = max(dot(n,l),0.);\n            \n            \n        \tcol += 1.*diff;\n        } \n    \n    }\n    \n    col /= aa*aa;\n    col = screenprint(uv,col,0.008,0.9);\n    col = 1. - col; // < remove me\n    return col;\n}\n\nfloat logoGen(vec2 uv, float seed, float sc, float its){\n    vec3 col = vec3(0);\n    \n    uv *= sc;\n    vec2 id = floor(uv);\n    vec2 fruv = fract(uv) - 0.5;\n        \n    if(length(id.x) > 0. || length(id.y) > 0.)\n        return 10e4;\n    \n    id += seed;\n    float gap = 0.109;\n    \n    float h1 = .9;\n    \n\tfloat d = 10e4;\n    \n    \n    float r = r22(id).x; // todo - change to r21\n    float rI= floor(mod(r*14225.12 , 10.));\n    \n    fruv *= rot(0.25*pi*rI);\n    \n    for (float i = 0.; i < its; i ++) {\n    \t\n    \tfruv *= rot(0.25*pi*id.y);\n        fruv.x = abs(fruv.x);\n        fruv.y = abs(fruv.y);\n        \n        vec2 rr = r22(id + i*seed);\n        \n        rr *= 10.;\n        \n        \n        \n        if (rr.x < 2.) {\n        \tfruv.x -= 0.5;\n        } else if (rr.x < 4.) {\n        \tfruv.x -= 0.25;\n        } else if (rr.x < 6.){\n        \tfruv.y -= 0.5;\n            fruv *= rot(4.*0.125*pi);\n        } else if (rr.x < 8.) {\n        \tfruv.x -= 0.5;\n        } else {\n        \t//fruv.x -= 0.125;\n            fruv.y -= 0.325;\n        }\n    \n    }\n    \n\n    d = min(d, sdBox(fruv + vec2(0., h1 + gap), vec2(0.04, h1)));\n   \n    d = min(d, sdBox(fruv + vec2(h1 + gap, 0.), vec2(h1, 0.04)));\n    \n    d = min(d, sdBox( (fruv  + vec2(0.057) )*rot(-0.25*pi), vec2(h1*0.25, 0.04)));\n    \n\treturn d/sc;\n}\n\nfloat text(vec2 p, float[8] chars, float spacing, float s) {\n\tp *= s;\n    p.x *= 1. - spacing;\n    vec2 id = floor(p*16.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375;\n    float char = chars[int(id.x)];\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8. && mod(char, 1.) == 0.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.)/16.,floor(char/16.)/16. ));\n        t = letter.w - 0.5;\n        t /= s;\n    } else {\n        t = 10e5;\n    }\n    return t;\n\t\n}\n\n\nfloat barcode(vec2 uv, float md,vec2 s){\n\n    float d = 10e5;\n    \n    vec2 ouv = uv;\n\n    vec2 offs = vec2( sin(uv.x*2.2 + pow(abs(cos(uv.x*.2)),8.)*1.)*.1, 0.);\n    offs.x -= sin(ouv.x*0.2 )*0.2;\n    \n    \n    uv += offs;\n    \n    //uv.y -= sin(ouv.x*2. - cos(ouv.y*2. - ouv.x*0.4 + sin(ouv.x*4.))*0.9)*0.5;\n    \n    float dfb = length(vec2(dFdx(uv.x),dFdy(uv.y)));\n    \n    vec2 id = floor(uv/md);\n    uv = pmod(uv,md );\n    \n    \n    d = min(d, length(uv.x) + 0.001 -md*1.1*pow(r11(id.x),2.) );\n    \n    \n    d = max(d,max(abs(ouv.x) - s.x,abs(ouv.y) - s.y));\n    d = min(d,abs(max(abs(ouv.x) - s.x,abs(ouv.y) - s.y)) - 0.001);\n   \n    \n    df = dfb*(1. - exp(-smoothstep(0.,1.,length(offs)*5.))*0.7 );\n    \n    \n    return d;\n}\n\nfloat sineDistField( vec2 uv, float scale )\n{\n    vec2 ouv = uv;\n    \n    \n    float d = 10e5;\n    \n    ouv.y += iTime*0.1;\n    vec2 offs = vec2( sin(uv.x*4.2 + sin(iTime) + 3.)*.1, 0.);\n    offs.x -= sin(ouv.x*2. - cos(ouv.y*8. - ouv.x*2.4 + sin(ouv.x*7.))*0.2)*0.2;\n    //offs.y -= sin(ouv.y*2.)*.2;\n    \n    ouv.y -= iTime*0.1;\n    \n    uv += offs;\n    \n    uv *= scale;\n    \n    //uv.y -= sin(ouv.x*2. - cos(ouv.y*2. - ouv.x*0.4 + sin(ouv.x*4.))*0.9)*0.5;\n    \n    float dfb = length(vec2(dFdx(uv.x),dFdy(uv.y)));\n    \n    uv = pmod(uv,0.02 );\n    \n    \n    d = min(d, length(uv) - 0.00);\n    d = min(d, length(uv.x) - 0.00);\n    \n    vec2 s = vec2(0.35,0.27);\n    //d = max(d,max(abs(ouv.x) - s,abs(ouv.y) - s));\n    ouv += vec2(0.,-0.12);\n    d = max(d,sdBox(ouv,vec2(s)));\n    d = min(d,abs(sdBox(ouv,vec2(s))) - 0.002);\n    \n    df = dfb*(1. - exp(-smoothstep(0.,1.,length(offs)*4.))*0.75 )/scale;\n    d -= 0.004;\n    return d;\n}\n\nfloat asemic( vec2 uv )\n{\n    vec2 ouv = uv;\n    \n    float df = dFdx(uv.x);\n        \n    float d = 10e5;\n    \n    uv.x += 0.2;\n    float w = 0.05;\n    \n    vec2 A = vec2(-0.2,-0.2);\n    vec2 B = vec2(0);\n    vec2 C = vec2(0,-0.4); \n    vec2 D = vec2(0.4,-0.4); \n    vec2 E = vec2(1.,-0.4); \n    \n    float sm = 0.35;\n     \n    vec2 F = vec2(0,-0.3);\n    \n    vec2 G = vec2(0.2,0.);\n    vec2 H = vec2(0.2,-0.2);\n    vec2 L = vec2(0.2,-0.4);\n    \n    \n    d = min(d,sdOrientedBox(uv,A,vec2(0. + w*0.33,0.),w*0.52, sm));\n    d = min(d,sdOrientedBox(uv,B + vec2(0.,0. + w*0.175),C,w, sm));\n    d = min(d,sdOrientedBox(uv,C,D,w, 0.5));\n    d = min(d,sdOrientedBox(uv - vec2(0.,w*0.5),D,E,0., sm));\n    \n    \n    uv -= vec2(0.22,0.);\n    \n    \n    d = min(d,sdOrientedBox(uv,A,vec2(0. + w*0.33,0.),w*0.52, sm));\n    \n    d = min(d,sdOrientedBox(uv,B + vec2(0.,0. + w*0.175),F,w, sm));\n    \n    uv -= vec2(0.22,0.);\n    \n    d = min(d,sdOrientedBox(uv,A*0.6,vec2(0. + w*0.33,0.),w*0.52, sm));\n    \n    d = min(d,sdOrientedBox(uv,B + vec2(0.,0. + w*0.175),F,w, sm));\n    d = min(d,sdOrientedBox(uv,B + vec2(0,-0.2),G,w, sm*0.05));\n    \n    d = min(d,sdOrientedBox(uv + vec2(0.02,0.275),B + vec2(0,-0.),G,w, sm*0.));\n    \n    \n    d = min(d,sdOrientedBox(uv + 0.05,C,L,w, sm) - 0.03);\n    d = min(d,sdOrientedBox(uv ,C,L,w, sm) - 0.03);\n    \n    \n    uv -= vec2(0.35,0.);\n    \n    d = min(d,sdOrientedBox(uv,A*0.6,vec2(0. + w*0.33,0.),w*0.52, sm));\n    \n    d = min(d,sdOrientedBox(uv + vec2(0.02,0.),B + vec2(0,-0.),G,w, sm*1.65));\n    \n    d = min(d,sdOrientedBox(uv + vec2(0.01,-0.014),B + vec2(0,-0.175),G,w, sm*0.5));\n    d = min(d,sdOrientedBox(uv + vec2(0.01,-0.014) + vec2(0.1),B + vec2(0,-0.175)*1.,G,w, sm*0.5));\n    \n    \n    d = min(d,sdOrientedBox(uv + vec2(0.13,0.275),B,G,w, 0.));\n    \n    \n    \n    d -= 0.001;\n    \n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    guv = uv;\n    luv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    seed = r11(frame)*200.;\n    df = dFdx(uv.x);\n    dfo = df;\n    \n    uv += texture(iChannel1,uv).xy*0.008+ texture(iChannel2,uv*0.05).xy*0.003+ texture(iChannel2,uv*0.45).xy*0.0;\n\t\n    vec3 col = vec3(1);\n    float d = 10e5;\n    \n    \n    vec2 roll = r12(frame + 1.);\n    \n    \n    // outline\n    \n    vec2 ouv = uv;\n    \n    d = sdBox(ouv,vec2(0.45));\n    \n    \n    ouv *= rot(-0.25*pi);\n    ouv = abs(ouv);\n    \n    d = xor(d,sdBox(ouv - vec2(0.,0.76),vec2(0.1)) - 0.1,0.4);\n    \n    ouv *= rot(0.5*pi);\n    \n    \n    d = abs(d);\n    \n    \n    col = colour( d - 0.001, col, vec3(0), 1,0,26.,.01);\n    \n    d = sdOrientedBox(uv + vec2(-0.41,0.1),vec2(0),vec2(0.0,-0.2),0.1, 0.) - 0.01;\n    \n    col = colour( d - 0.001, col, vec3(0), 1,0,26.,.01);\n    \n    \n    // sine thing\n    \n    \n    //col = colour( d , col, vec3(0.0), 0, 3,13.6,1.);\n    \n    d = sineDistField(uv,2.)*0.5;\n    col = colour( d, col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    df = dfo;\n    \n    \n    d = asemic(uv*2. + vec2(0,0.4))*1.;\n    \n    col = colour( d - 0.04, col, vec3(1.,0.2,0.5)*1., 0,0,9.,.001);\n    \n    col = colour( d - 0.01, col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    \n    \n    // -- outer\n    \n    d = -sdBoxRound(uv,vec2(0.45)) + 0.02;\n    \n    col = colour( d , col, vec3(0.00), 1, 1,2.1,.001);\n    \n\tcol = colour( d*0.5 + 0.0, col, vec3(0.), 0,0,4.,.02);\n\n    \n    \n    \n    \n    // colors \n    \n    \n    vec2 s = vec2(0.35,0.27)*0.96;\n    \n \tfloat box = sdBoxRound(uv + vec2(0,-0.11),s) - 0.01;\n    \n    d = box;\n    \n    \n    col = colour( d , col, vec3(0.1,00.5,0.)*3., 3, 1,1.1,.001);\n    \n    \n    // -- sticker\n    \n    vec2 off = vec2(0.,0.4);\n    \n    float rb = sdBoxRound((uv + off + vec2(0.3,-0.62))*rot(0.5*pi),vec2(0.13,0.1));\n    \n    d = rb;\n    \n\tcol = colour( d - 0.01, col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    d = text((uv + off + vec2(0.38,-0.7125)), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.75,5.9);\n    \n    float oo = 0.03;\n    d = min(d,text((uv + off + vec2(0.38,-0.7125 + oo)), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.5 ,5.9));\n    \n    d = min(d,text((uv + off + vec2(0.38,-0.7125+ oo*2.)), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.7 ,5.9));\n    \n    d = min(d,text((uv + off + vec2(0.38,-0.7125+ oo*3.)), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.77 ,5.9));\n    \n    \n    d = max(d,rb + 0.04);\n    \n    \n\tcol = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n\n\trd = getRd(ro,lookAt,uv - off - vec2(-0.3,-0.09), .8);\n    d = min(d, slice( uv - off - vec2(-0.3,-0.09), -1., 1., 6., true));\n\t\n\td = max(d,rb);\n    \n    col = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n    df = dfo;\n    \n    uv = (uv + off + vec2(0.3,-0.5))*rot(0.5*pi);\n\n    uv = guv;    \n\n    \n    \n    \n    \n    // barcode\n   \n    s = vec2(0.1,0.05);\n    \n    col = colour( d, col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    \n    d = barcode(uv + vec2(0.29,0.38), 0.007,vec2(0.1,0.05));\n    \n\tcol = colour( d, col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    df = dfo;\n    \n    \n    \n    // stickerb\n   \n    off = vec2(0.34,0.2);\n    box = sdBoxRound((uv - off)*rot(-0.05),vec2(0.05,0.02)) - 0.003;\n    d = box;\n    \n    \n    col = colour( d , col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    d = text((uv - off + vec2(0.04,0.004))*rot(-0.01), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.75,5.9);\n\n    d = max(d,box);\n    \n    col = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n      \n    \n    // small logo\n    \n    \n    \n\tro = vec3(0.,0.24,.01)*5.;\n    lookAt = vec3(0);\n    \n    \n    off = vec2(0.3,0.25);\n    d = slice( uv + off, -0.1, 0.1, 16., false)*1.;\n\t\n\n    d = max(d,abs(uv.x + off.x) - 0.09);\n    \n    col = colour( max(d - 0.1,abs(uv.x + off.x) - 0.12), col, vec3(0,0.6,0.2), 1,0,6.,.05);\n\n    col = colour( d - 0.01, col, vec3(0), 1,0,26.,.1);\n    \n    df = dfo;\n    \n    \n    \n    //float rb = sdBoxRound((uv + off + vec2(0.3,-0.52))*rot(0.5*pi),vec2(0.23,0.1));\n    \n    //d = rb;\n    \n\t\n    \n    /*\n    col = colour( d , col, vec3(0.001), 0, 90,4.6,.4);\n    \n    // -- botbox\n    \n    \n \tfloat box = sdBoxRound(uv + vec2(0,0.5),vec2(0.2)) - 0.02;\n    \n    d = box;\n    \n    col = colour( d , col, vec3(0.1,00.2,0.1)*1., 1, 1,3.1,.001);\n    \n    d = abs(box);\n    \n    //col = colour( d - 0.01 , col, vec3(0.3,0.,0.), 3, 1,1.1,4.01);\n    \n   \n    \n    \n    \n    // -- sticker \n    \n    vec2 off = vec2(-0.62,0.36);\n    \n    float rb = sdBoxRound((uv + off + vec2(0.3,-0.52))*rot(0.5*pi),vec2(0.23,0.1));\n    \n    d = rb;\n    \n\tcol = colour( d - 0.01, col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    d = text((uv + off + vec2(0.35,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.75,5.9);\n    \n    d = min(d,text((uv + off + vec2(0.32,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.5 ,5.9));\n    \n    d = min(d,text((uv + off + vec2(0.29,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.7 ,5.9));\n    \n    d = min(d,text((uv + off + vec2(0.255,-0.7125))*rot(0.5*pi), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.77 ,5.9));\n    \n    d = max(d,-uv.y + 0.1);\n    \n    \n\tcol = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n\n    \n    col = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n    uv = (uv + off + vec2(0.3,-0.5))*rot(0.5*pi);\n\n    uv = guv;\n    \n    // -- outer\n    d = -sdBox(uv,vec2(0.45));\n    \n    col = colour( d , col, vec3(0.00), 1, 1,3.1,.001);\n    \n\tcol = colour( d*0.5 + 0.0, col, vec3(0.), 0,0,4.,.03);\n\n    \n    \n    // -- stickerb\n    \n    d = logoGen( (uv + off + vec2(0.37,-0.31))*rot(0.*pi), 41.,18.,7.)*3.;\n\n    //d = min(d,logoGen( (uv + off + vec2(0.3,-0.36))*rot(1.25*pi), 45.,17.,4.)*3.);\n\n    d = min(d,logoGen( (uv + off + vec2(0.29,-0.31))*rot(0.*pi), 12.,18.,4.)*3.);\n\n    d = min(d,sdBox((uv + off + vec2(0.3,-0.4)),vec2(0.08,0.0001))*4.);\n    \n    //col = colour( d, col, vec3(1.), 0,0,27.,.001);\n    col = colour( d, col, vec3(1.), 0,1,5.,.001);\n    \n    \n    // -- stickerc\n    \n    \n    off -= vec2(-0.27,0.);\n    box = sdBoxRound((uv - off)*rot(-0.05),vec2(0.05,0.02)) - 0.005;\n    d = box;\n    \n    \n    col = colour( d , col, vec3(0.,0.001,0.004)*1., 1,0,9.,.001);\n    \n    d = text((uv - off + vec2(0.04,0.004))*rot(-0.01), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.75,5.9);\n\n    d = max(d,box);\n    \n    col = colour( d, col, vec3(1.), 0,0,3.,.2);\n\n    \n    //col = colour( d , col, vec3(0.00), 1, 1,3.1,.001);\n    \n    // -- titletext\n    \n    d = text((uv  + vec2(0.09,0.38) )*rot(-0.01), float[](76.,49.,124.,122.,144.,125.,24.24,15.24), 0.,1.9);\n\n\t*/    \n\n    //col = colour( d + 0.01, col, vec3(0.1,0.9,0.8)*0.8, 0,0,3.,.2);\n\n    \n    \n    //col -= d;\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // \n\n\n\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n\tvec2 roll;\n\t\n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n\n    vec4 n = valueNoise(guv,1.); \n    vec4 nb = valueNoise(guv*0.5 + 0.2,2.); \n    \n    float deb;\n    \n    if (stroke == 0) {\n\t\tdeb = smoothstep(df + texture(iChannel1,guv*0.5).x*0.53*n.z*strokeparamb,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        \n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.24*pow(n.w,0.5) + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.12;\n        \n        // splatter\n        db += texture(iChannel1,ruv*0.2).x * 0.2*pow(nb.x,5.)*strokeparamb;\n        db -= texture(iChannel2,ruv*0.3).x * (0.35*pow(n.z,3.) + 0.35*pow(nb.z,3.) )*strokeparamb;\n        /*\n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.1 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        */\n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n      \n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    \n    if( stroke == 90){\n        deb = mix(-0.,1.,clamp(db,0.,1.));\n    }\n    \n    \n    if(stroke == 90){\n    \tcb = mix( cb, 1. - cb, smoothstep(1.,0.,strokeparam*(t.x + ta.x - nb.x*0.4 + n.y*0.2)));\n    } else {\n        cb*=1. - smoothstep(1.,0.,abs(db)*(30.01) + t.z*1.53)*.9;\t\n    }\n    \n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t   \n    \n    if(mode == 0){\n        // 0 replace\n        if ( stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77 - 0.1*smoothstep(1.,0.,abs(db)*14.11*(1. + pow(nb.x,3.)*5.))   ), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), strokeparam), 0.));\n        }\n    } else if(mode == 1){\n        // 1 multiply\n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n        // 2 overlay\n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        }\n    } else if(mode == 3){\n        // 3 darken\n          \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\t\n        // 4 burn\n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\t\n        // 5 linear burn\n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n        // 6 color dodge\n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\n\n\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt, bool rotational){\n\tfloat d = 10e5;\n    rd = getRd(ro,lookAt,uv, .8);\n    \n    if(rotational){\n        \n        vec3 lro = ro;\n        \n        \n        vec3 normal = vec3(0,0.,1);\n        for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n           \n            normal.xz *= rot(tau/sliceCnt + 0. );\n\t\t\tfloat plane = intersectPlane(lro,rd,normal).x;\n            \n            vec3 p = lro + rd*plane;\n\n            vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n\n            float m = map(p);\n            \n            if(m <= d){\n\n                //df = max(ldf.y,ldf.x)*1.;\n\n                df = length(ldf);\n\n                d = min(d,m);\n\n            }\n\n        }\n        \t\n    \n    } else {\n        for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n            vec3 lro = ro + vec3(0,i,0);\n\n\n            float plane = intersectPlane(lro,rd,vec3(0,-1,0)).x;\n            vec3 p = lro + rd*plane;\n\n            vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n\n            float m = map(vec3(p.x,p.y - i*1.5,p.z));\n            if(m <= d){\n\n                //df = max(ldf.y,ldf.x)*1.;\n\n                df = length(ldf)*0.5;\n\n                d = min(d,m);\n\n            }\n\n        }\n    \n    }\n    \n    \n    \n    return d;\n}\n\n\nfloat dotwork(vec2 uv, float w, float densitya, float densityb){\n\tfloat d = 10e5;\n    \n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +0.5), 2.7));\n    \n    uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 925.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*4.;\n        //float s = 4.;\n        vec2 luv = uv*s;\n        vec2 fruv = fract(luv) - 0.5;\n        vec2 id = floor(luv );\n        vec2 rp = r22( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id.x*w*s + w*0.5));\n    \n        if(r.y < mix(density,den,1.)){\n        \td = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        }\n        \n    }\n    \n    return d - 0.002;\n}\n\n\nfloat screenprint(vec2 p,float lum, float cellSize, float strength){\n\tfloat t = 0.;\n    vec2 q = p ;\n\n    p *= rot(0.125*pi);\n    \n    \n    q /= cellSize/pi;\n    // some distortion\n    p -= length(sin(q))*normalize(p)*cellSize/6.;\n    \n    \n    p = pmod(p,cellSize);\n    p -= length(sin(q))*normalize(p)*cellSize/6.*0.6;\n    \n    float lsz = 0.;\n    \n    float n = valueNoise(q*410.,1.).x*5.;\n    \n    n = pow(n,2.)*0.07;\n    lsz = pow(smoothstep(0.,1.,lum*(0.45 +n)),strength)*cellSize*0.6;\n    \n    float col = smoothstep(0.002,0.,length(p) - lsz + 0.001);\n    //col = mix(col,smoothstep(0.01,0.,sin(q.x)*sin(q.y)* lsz*1. ),0.1);\n\t\n    return col;\n}\n\n\nfloat jaggy(vec2 uv, float densitya, float densityb, float w){\n\tfloat d = 10e5;\n    \n    d = length(uv.y);\n    \n    uv.x += 0.5;\n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +1.), 1.));\n    \n    //uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 7.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*6.;\n        //float s = 4.;\n        float luv = uv.x*s;\n        float fruv = fract(luv) - 0.5;\n        float id = floor(luv );\n        float rp = r11( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id*w*s + w*0.5));\n    \n        \n        //d = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        \n        if(r.y < mix(density,den,1.) + sin(r.y*53513.)*0.0){\n        \td = max(d, -(abs(fruv) - max(rp,0.5)*0.2)/s);\n        }\n        \n    }\n    seed++;\n    \n    \n    return d;\n    \n}\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    t *= 6.;\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsccD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 311, 311, 368], [369, 369, 402, 402, 931], [932, 932, 950, 950, 1278], [1281, 1281, 1338, 1338, 2216]], "test": "untested"}
{"id": "3ddyWj", "name": "OrangeAction", "author": "Del", "description": "Orange Action! - Hold Mouse Button for something else...", "tags": ["orange", "mirror", "pattern"], "likes": 2, "viewed": 252, "published": 3, "date": "1601753753", "time_retrieved": "2024-07-30T20:42:05.128571", "image_code": "// Orange Action - Del 03/10/2020\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n\tfloat t = iTime+2.0;\n    vec3 color1 = vec3( 1.0, 0.7, 0.3 );\n\tvec3 color2 = vec3( 0.5, 0.35, 0.1 );\n\tuv.x *= 2.0+sin(t*0.4);\n    if (iMouse.z<0.5)\n    \tuv.x = dot(uv,uv)*0.05;\n\tfloat c = floor((uv.x + 0.25)/0.5);\n\tuv.x = mod(uv.x + 0.25,0.5) - 0.25;\n\tuv.x *= -(mod(c, 2.0)*2. - 1.);\n\tfloat v1 = sin(fract(t*.05)*6.28);\n    v1 *= sin(uv.y*.5)*10.0;\n\tfloat v2 =sin(fract(t*.027)*6.28) *24.4; \n\tuv.x += sin(fract(uv.x*0.125+t*.6)*6.28+(uv.x*v2+uv.y*5.0)+v1)*1.4;\n\tfloat curve = 0.3;\n   \tvec3 col = mix( color1, color2, smoothstep( 0.5-curve,0.5+curve,uv.x+0.5) );\t\n\tfragColor = vec4(col, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 91, 91, 755]], "test": "untested"}
{"id": "WstyWj", "name": "YellowFun", "author": "Del", "description": "Yellow Fun - Hold mouse button for something completely different!", "tags": ["yellow", "mirror", "xrepeat"], "likes": 2, "viewed": 247, "published": 3, "date": "1601750834", "time_retrieved": "2024-07-30T20:42:05.968326", "image_code": "// Yellow Fun - Del 03/10/2020\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n\tfloat t = iTime+1.0;\n\tvec3 color1 = vec3( 1.0, 1.0, 0.0 );\n\tvec3 color2 = vec3( 0.4, 0.4, 0.1 );\n    \n\tuv.x *= 2.0+sin(t*0.4);\n    if (iMouse.z<0.5)\n    \tuv.x = dot(uv,uv)*0.1;\n\tfloat c = floor((uv.x + 0.25)/0.5);\n\tuv.x = mod(uv.x + 0.25,0.5) - 0.25;\n\tuv.x *= -(mod(c, 2.0)*2. - 1.);\n\tfloat v1 = sin(fract(t*.05)*6.28);\n\tfloat v2 =sin(fract(t*.027)*6.28) *24.4; \n\tuv.x += sin(fract(uv.x*4.0+t*.6)*6.28+(uv.x*v2+uv.y*35.0)*v1)*0.09;\n\tfloat curve = 0.1;\n   \tvec3 col = mix( color1, color2, smoothstep( 0.5-curve,0.5+curve,uv.x+0.5) );\t\n\tfragColor = vec4(col, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 88, 88, 723]], "test": "untested"}
{"id": "wdcyW2", "name": "Fab6 #inktober2020 \"roden\" 275ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n\nfractal: because roden fast turn to many :-p", "tags": ["2tweets", "short", "golf", "inktober2020"], "likes": 11, "viewed": 329, "published": 3, "date": "1601741047", "time_retrieved": "2024-07-30T20:42:06.819051", "image_code": "#define C(r) clamp( 1. - R.y/2.* ( length(U) - r ) , 0.,1. )           //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y; U.y += .6;\n    O *=  C(.1);                U.y -= .2;\n    for(float i=1.; i<7.; i+= i==1. ? .1 : 1. )\n        U.x = abs(U.x),\n        O += (1.-O.a) * C(.5) / vec4(i,i,i,1),\n        U = (U/.6-.9) * mat2(cos(.8+.3*sin(6.*iTime)+vec4(0,33,11,0))),\n        R *= .6;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 110, 110, 434]], "test": "untested"}
{"id": "3scyD2", "name": "Fab5 #inktober2020 \"blade\" 485ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["short", "golf", "inktober2020"], "likes": 2, "viewed": 327, "published": 3, "date": "1601738528", "time_retrieved": "2024-07-30T20:42:07.582011", "image_code": "#define D         clamp( 1. - R.y*max(V.x,V.y), 0.,1.)     //\n#define v(X,Y)    R/R.y*vec2(X,Y)                          //\n#define B(X,Y)  ( V = U - v(X,Y), D )                      //\n#define b(X,Y)    O = max(O, B(X,Y) );                      \\\n                  V = abs( v(X,Y) - U ) - .05,              \\\n                  O = clamp( O+C( v(X,Y)-.05, .05 ) -  D, 0.,1.);    //\n#define C(C,r)    max(0., 1.-R.y* ( length(C-U) - r ) )    //\n#define I(X)      U = abs(v-v(X,0)); O -= B(.025,.15) + C(v(0,.15),.04); //\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = abs( u+u - R ) / R.y, v = U, V;\n    vec4 O = o;\n    b(.7,.4) b(.6,.7)               /* core  */\n    O -= B(.6,.07);                 /* slit  */\n    O -= C(v(.6,.45),.05)           /* notch */\n      +  C(,.14) + C(v(.45,0),.14); /* round holes  */\n    I(.3) I(.6)                     /* narrow holes */\n    o = O * (.6+.4*sin(4.*(u.x-u)/R - iTime)).y;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ws3cDj", "name": "fake Depth of Field", "author": "FabriceNeyret2", "description": "Using MIPmap to fake Depth of Field.", "tags": ["dof", "mipmap", "depthoffield"], "likes": 17, "viewed": 741, "published": 3, "date": "1601736809", "time_retrieved": "2024-07-30T20:42:08.494571", "image_code": "void mainImage( out vec4 O, vec2 u )\n{   vec2  U = u / iResolution.xy;                       // normalized coordinates\n    float z = 1.-.7*U.y;                                // depth along the plane\n    O = 1.5*textureLod(iChannel0, \n                       vec2( U.x-.5 , 1 )/ z -.1*iTime, // perspective parameterization\n                       5.+log2(abs(1./z - 1.5)) ).xxxx; // log2( circle of confusion ) \n  //O = sqrt(O);                                        // cheap sRGB convertion\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3cDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 493]], "test": "untested"}
{"id": "wd3yzl", "name": "will u stay", "author": "Dreamfall", "description": "Something to begin with", "tags": ["lighting", "shadowing"], "likes": 6, "viewed": 300, "published": 3, "date": "1601723980", "time_retrieved": "2024-07-30T20:42:09.377211", "image_code": "const float metalness = 0.3; // (0, 1)\nconst float roughness = 0.3; // (0, 1)\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat height(vec2 uv)\n{\n    float heightMod = 50.0;\n    return heightMod * texture(iChannel1, uv).x;\n}\n\nvec3 normal(vec2 xy, vec2 uv)\n{\n    float eps = 0.01;\n\tvec3 dhu, dhv;\n    \n    // get planar vectors\n    // process borders separately\n    if (xy.x >= 1.0 && xy.y >= 1.0)\n    {\n    \tdhu = vec3(xy, height(uv)) - vec3(xy.x - 1.0, xy.y, height(vec2(uv.x - 1.0/iResolution.x, uv.y)));\n    \tdhv = vec3(xy, height(uv)) - vec3(xy.x, xy.y - 1.0, height(vec2(uv.x, uv.y - 1.0/iResolution.y)));\n    }\n\tif (xy.x > 1.0 && xy.y < 1.0)\n    {\n    \tdhu = vec3(xy, height(uv)) - vec3(xy.x - 1.0, xy.y, height(vec2(uv.x - 1.0/iResolution.x, uv.y)));\n    \tdhv = vec3(xy.x, xy.y + 1.0, height(vec2(uv.x, uv.y + 1.0/iResolution.y))) - vec3(xy, height(uv));\n    }\n    if (xy.x < 1.0 && xy.y > 1.0)\n    {\n    \tdhu = vec3(xy.x + 1.0, xy.y, height(vec2(uv.x + 1.0/iResolution.x, uv.y))) - vec3(xy, height(uv));\n    \tdhv = vec3(xy, height(uv)) - vec3(xy.x, xy.y - 1.0, height(vec2(uv.x, uv.y - 1.0/iResolution.y)));\n    }\n    if (xy.x < 1.0 && xy.y < 1.0)\n    {\n    \tdhu = vec3(xy.x + 1.0, xy.y, height(vec2(uv.x + 1.0/iResolution.x, uv.y))) - vec3(xy, height(uv));\n    \tdhv = vec3(xy.x, xy.y + 1.0, height(vec2(uv.x, uv.y + 1.0/iResolution.y))) - vec3(xy, height(uv));\n    }\n    dhu = normalize(dhu);\n    dhv = normalize(dhv);\n    vec3 normal = normalize(cross(dhu, dhv));\n    \n    // Add abit noise based on scaled roughness value\n    normal += roughness / 4.0 * (dhu * random(uv) + dhv * random(uv));\n    normal = normalize(normal);\n    \n    return normal;\n}\n\n// check if pixel is in shadow\nbool isInShadow(vec2 point, vec3 lightSource)\n{\n    float eps = 0.1;\n    vec3 dir = normalize(lightSource - vec3(point, height(point/iResolution.xy)));\n    vec3 currentPos = vec3(point, height(point/iResolution.xy)) + dir;\n    int cycles = 0;\n    while (length(currentPos - lightSource) > eps)\n    {        \n        if (currentPos.z < height(currentPos.xy/iResolution.xy))\n            return true;\n        // prevent dead loop\n        if (cycles > 1000)\n            break;\n        currentPos += dir;\n        cycles++;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightSource = vec3(iMouse.xy, 80);\n    \n    // Raw pixel coordinates\n    vec2 xy = fragCoord.xy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \t// Direction for CubeMap tex\n    // Setting it looking to the floor: (*, -1, *)\n    vec3 cubeMapdir = normalize(vec3(2.0 * (uv.x - 0.5), -1, 2.0 * (uv.y - 0.5)));    \n    vec4 textureColor = textureLod(iChannel0, cubeMapdir, 0.0);\n\n    // Retrieving current normal\n    vec3 normal = normal(xy, uv);\n    \n    // Computing lighting modifier\n    vec3 lightDir = normalize(lightSource - vec3(xy, height(uv)));\n    //vec3 lightDir = normalize(lightSource - vec3(xy, 0));\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 viewDir = vec3(0, 0, 1);\n    float ambient = 0.5;\n    float diffuse = 1.0 * max(dot(lightDir, normal), 0.0);    \n    float spec = 0.5 * pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    // Add metalness\n    float reflectiveness = 0.8 * metalness;\n    diffuse = (1.0 - reflectiveness) * diffuse;\n    spec = reflectiveness * spec;\n    float ambientdiffuse = ambient + diffuse;\n    \n    // Output to screen    \n    fragColor = vec4(textureColor.xyz * ambientdiffuse, 1.0) + vec4(vec3(spec), 1.0);\n    if (isInShadow(xy, lightSource))\n    \tfragColor = 0.5 * fragColor;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 103, 103, 176], [178, 178, 201, 201, 280], [282, 282, 313, 313, 1717], [1719, 1750, 1797, 1797, 2293], [2295, 2295, 2352, 2352, 3643]], "test": "untested"}
{"id": "Ws3yD2", "name": "Fab4 #inktober2020 \"radio\" 372ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["short", "golf", "3tweets", "inktober2020"], "likes": 15, "viewed": 402, "published": 3, "date": "1601708709", "time_retrieved": "2024-07-30T20:42:10.148150", "image_code": "\n//#define L(a,b) max(0.,1.- R.y/6. * length( U-a - (b-a) * clamp( dot(U-a, b-a) / dot(b-a, b-a), 0., 1.) ) ) //\n#define L(a,b) max(0.,1.5- 2e2 * length( U-a - (b-a) * clamp( dot(U-a, b-a) / dot(b-a, b-a), 0., 1.) ) ) //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y;\\\n         U.x = abs(U.x), U.y = .2 - U.y;\n    float l = length(U), a = l+l - iTime;\n    O += max(0., .5*sin( 30.*( a + sin(3.*a) ) )) * max(0.,cos( 3.*U.y/l ))\n      +  L(vec2(.1,1.12) , ) + L(vec2(0,1.12),);\n    U.y < 1.1 ? U.x /= U.y, U.y = .95 + abs( mod(U.y,.1) / U.y -.05 ),\n    O += L( vec2(0,.95), vec2(.1,1 ) ) : O;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3s3yD2", "name": "Plaid-Warp", "author": "celifrog", "description": "yes\nYou can make it spaz out by clicking your mouse around. ", "tags": ["fun", "original"], "likes": 2, "viewed": 271, "published": 3, "date": "1601706554", "time_retrieved": "2024-07-30T20:42:10.928065", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = iResolution.xy/fragCoord-iResolution.xy+iMouse.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 90.5/cos(uv.xxx/uv.yyy*uv.yyy-iTime-uv.xyx-uv.xyx*vec3(10,12,4));\n\n    // Output to screen\n    fragColor = vec4(uv.yyy*col*iTime*uv.xyx,11.0/uv.xxx);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3yD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 378]], "test": "untested"}
{"id": "tscyzf", "name": "Shader darstellung", "author": "DerStefan", "description": "for presentation", "tags": ["learning"], "likes": 0, "viewed": 171, "published": 3, "date": "1601687827", "time_retrieved": "2024-07-30T20:42:11.813697", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n   // INPUT\n   //uv = (x,y)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    \n\t//OUTPUT\n\t//col = (r,g,b) \n    \n    vec3 col = vec3(uv.x,0.0,0.0);\n    \n\n\n\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 88, 260]], "test": "untested"}
{"id": "WdccDj", "name": "moist", "author": "jj99", "description": "wet", "tags": ["water"], "likes": 11, "viewed": 525, "published": 3, "date": "1601687394", "time_retrieved": "2024-07-30T20:42:12.665420", "image_code": "// Fork of \"18 - Sea of Sinewaves\" by Krabcode. https://shadertoy.com/view/3ddcz2\n// 2020-10-02 16:01:39\n// forked again from https://www.shadertoy.com/view/WstcDB\n\n\n// Based on Ray Marching for Dummies!\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XlGBW3\n\n\nconst int MAX_STEPS = 1;\nconst float MAX_DIST = 1.;\nconst float SURF_DIST = 0.0001;\nconst float NORMAL_DIST = 0.001;\nconst float SHININESS = 10.;\nconst float DOWNSTEP = 0.1;\nconst float PI = 3.14159;\n\nvec2 uv;\nvec2 lightOffset; \nvec3 lightPos;\n\nfloat rayLength;\nfloat closestDist;\nfloat hitDist;\nvec3 hit;\nvec3 intersect;\nvec2 m;\n\nmat2 rotate(float a){\n  return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\n\nfloat wave(vec2 p) {\n  float v = sin(p.x*0.7 + sin(p.y*2.2) + sin(p.y * .43));\n  return v*v;\n}\n \nconst mat2 rot = mat2(0.5, 0.86, -0.86, 0.5);\n \nfloat get(vec2 p,float t)\n{\n  float v = 0.0;//abs(sin(p.x+p.y*1.4))*0.1;\n  v += wave(p);\n  p.y += t;\n  p *= rot;\n  v += wave(p);\n  p.y += t * .17;\t//0.17\n  p *= rot;\n  v += wave(p);\n  v+=pow(abs(sin(p.x+v)),2.0);\n\t\n  v = abs(1.5 - v);\n  return v;\n}\n \nfloat sdf(vec3 p){ \n    float v = get(p.xy*6.0,iTime)*0.1;\n     \tv = smoothstep(0.02,3.5,v)*2.5;\n\n    return p.z+v;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = sdf(p);\n        closestDist = min(dS, closestDist);\n        dO += dS*DOWNSTEP;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p) \n{\n    float d = sdf(p);\n    vec2 e = vec2(NORMAL_DIST, 0);\n    vec3 n = d - vec3(\n        sdf(p-e.xyy),\n        sdf(p-e.yxy),\n        sdf(p-e.yyx));\n    return normalize(n);\n}\n\nfloat diffuseLight(vec3 p, vec3 normal) \n{\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    float d = rayMarch(p+normal*SURF_DIST*2., l);\n    if(d<length(lightPos-p)){ dif *= .1; }\n    return dif;\n}\n\n\nfloat specularLight(vec3 p, vec3 rayDir, vec3 normal) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 reflectionDirection = reflect(-lightDir, normal);\n    float specularAngle = max(dot(reflectionDirection, rayDir), 0.);\n    return pow(specularAngle, SHININESS);\n}\n\nfloat render(vec2 uv)\n{\n    vec3 rayOrigin = vec3(uv+vec2(0., 0.25), 0.);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.)); \n    hitDist = rayMarch(rayOrigin, rayDir);\n    hit = rayOrigin + rayDir * hitDist;\n    vec3 normal = normal(hit);\n    float diff = diffuseLight(hit, normal);   \n    float spec = specularLight(hit, rayDir, normal);\n    return .5*diff + .5*spec;\n}\n\nfloat aaRender(vec2 uv){\n    vec2 third = vec2(1./iResolution.x, 1./iResolution.y) / 3.0;\n    vec2 mult = vec2(1, -1);\n    float c1 = render(uv+third*mult.xx);\n    float c2 = render(uv+third*mult.xy);\n    float c3 = render(uv+third*mult.yx);\n    float c4 = render(uv+third*mult.yy);\n    return (c1+c2+c3+c4) / 4.;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //m = iMouse.xy / iResolution.xy;\n    //time = 100.+float(iFrame)*.0005;\n    lightPos = vec3(0.,5.0,-16.0);\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float lit = render(uv); \n    lit *= smoothstep(MAX_DIST*.15, MAX_DIST*.05, hitDist);\n\tvec3 col = vec3(0.2,1.2,1.8)*lit;\n    fragColor = vec4(gammaCorrection(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdccDj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[724, 724, 745, 745, 798], [801, 801, 821, 821, 895], [946, 946, 973, 973, 1194], [1197, 1197, 1215, 1215, 1314], [1316, 1316, 1351, 1351, 1602], [1604, 1604, 1626, 1626, 1800], [1802, 1802, 1844, 1844, 2038], [2041, 2041, 2096, 2096, 2311], [2313, 2313, 2336, 2336, 2684], [2686, 2686, 2710, 2710, 3001], [3003, 3003, 3034, 3034, 3141], [3143, 3143, 3200, 3277, 3540]], "test": "untested"}
{"id": "3s3cDj", "name": "2D Antialiased Metaballs", "author": "oneshade", "description": "I redid my metaball shader following the tutorial by Eight Squared Software. It is now mathematically correct (I believe). I also added an experimental bit of antialiasing using smoothstep.", "tags": ["2d", "metaballs", "antialiasing", "cubic"], "likes": 10, "viewed": 290, "published": 3, "date": "1601686600", "time_retrieved": "2024-07-30T20:42:13.498193", "image_code": "#define AA 8\n\nfloat blob(in vec2 p, in vec2 o, in float r) {\n    p -= o;\n    return r * r / dot(p, p);\n}\n\nbool pointIn(in vec2 p) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    float t1 = iTime * 0.5, t2 = iTime * 1.25, t3 = iTime * 1.5;\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 mb1 = center + vec2(c2, s1) * 100.0;\n    vec2 mb2 = center + vec2(c1, s3) * 100.0;\n    vec2 mb3 = center + vec2(c3, s2) * 100.0;\n\n    float blob1 = blob(p, mb1, 30.0);\n    float blob2 = blob(p, mb2, 40.0);\n    float blob3 = blob(p, mb3, 50.0);\n\n    float d = blob1 + blob2 + blob3;\n    return d > 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor =  vec4(0.0);\n    float aa = float(AA);\n    for (float i=0.0; i < aa; i++) {\n        for (float j=0.0; j < aa; j++) {\n            fragColor += float(pointIn(fragCoord + vec2(i, j) / aa));\n        }\n    }\n\n    fragColor /= aa * aa;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3cDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 60, 60, 104], [106, 106, 131, 131, 665], [667, 667, 722, 722, 969]], "test": "untested"}
{"id": "3dcyDj", "name": "LeafyWibble", "author": "Del", "description": "A Green Leafy thing :)", "tags": ["sin", "rot"], "likes": 13, "viewed": 350, "published": 3, "date": "1601684465", "time_retrieved": "2024-07-30T20:42:14.450646", "image_code": "// A Green Leafy thing :)\n\nfloat wave(vec2 p)\n{\n  float v = sin(p.x + sin(p.y) + sin(p.y * .43));\n  return v*v;\n}\n \nfloat get(vec2 p,float t)\n{\n  mat2 rot = mat2(0.5, 0.86, -0.86, 0.5);\n  float v = wave(p);\n  p.y += t;\n  p *= rot;\n  v += wave(p.yx);\n  p.y += t * .17;\n  p *= rot;\n  v += wave(p.xy);\n  v = abs(1.5 - v);\n  v+=pow(abs(sin(p.x+v)),18.0);\n  return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n    float t = iTime;\n\tfloat scale =14.0;\n\tfloat speed = .3;\n\tuv.y += sin(fract(t*0.1+uv.x)*6.28)*0.05;\t// wibble\n\tuv.xy += t*0.08;\t\t\t\t\t// scroll\n\tvec2 p = uv*scale;\n\t//p.y+= 1.0/p.y*p.y;\n  \tfloat v = get(p,t*speed);\n  \tv = smoothstep(-3.5,3.5,v);\n\tvec3 col = vec3(.29, 0.86, 0.4);\n    fragColor = vec4(col*v*v, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 113], [116, 116, 143, 143, 364], [366, 366, 423, 423, 808]], "test": "untested"}
{"id": "Ws3cWj", "name": "Background Removal", "author": "oneshade", "description": "This removes green from the picture and replaces it with a color from the background. If you want to try it on webcam make sure your in front of something green and that your not wearing green either.", "tags": ["transparent", "background", "removal"], "likes": 4, "viewed": 928, "published": 3, "date": "1601680105", "time_retrieved": "2024-07-30T20:42:15.350241", "image_code": "bool isgreen(in vec3 color) {\n    return 0.6 * color.g > color.r && 0.6 * color.g > color.b;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 foreground = texture(iChannel1, uv).rgb;\n    vec3 background = texture(iChannel0, uv).rgb;\n    vec3 color = background;\n    if (!isgreen(foreground)) {\n        color = foreground;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3cWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 94], [96, 96, 151, 151, 424]], "test": "untested"}
{"id": "tstcDB", "name": "julia revolt vr", "author": "TjaMeu", "description": "gedhtedh", "tags": ["vr"], "likes": 11, "viewed": 512, "published": 3, "date": "1601675438", "time_retrieved": "2024-07-30T20:42:16.210940", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n\n// VR part by TjaMeu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<30.;i++)\n    {\n        if (i>7.8) break;\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*0.5 +  iTime * 0.5; // axis y\n    \n    vec2 rev = vec2(length(p.xz),p.y) - 1.52;\n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a)); // rot near axis y\n\t\n\tvec2 res = vec2(100);\n\t\n\tfloat ftus = fractus(rev, vec2(-0.3,-0.649));\n\t\n\tfloat thickStep = 0.12;\n\t\n\tfor (int i =0;i <5;i++)\n\t{\n\t\tfloat lay = max(ftus, -ftus - thickStep * float(i+1)); // change only the interior thickness\n\t\tif (lay < res.x)\n\t\t\tres = vec2(lay, float(i));\n\t}\n\t\n\tvec2 q = p.xz;\n\tfloat a0 = mix(0.,1.57,res.y/5. * mix(-.1,.1,sin(iTime * 0.5)*.5+.5));\n\tq *= mat2(cos(a0),-sin(a0),sin(a0),cos(a0));\n\t\n\tvec2 cut = vec2(q.y, 10);\n\tif (cut.x > res.x)\n\t\tres = cut;\n\t\t\n\tfloat plane = p.y+1.;\n\tif (plane < res.x)\n\t\treturn vec2(plane,12);\n\t\t\n\treturn res;\n\t\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = 3.14159*0.5;\n\t\n\tvec2 camp = vec2(643./958.,356./816.) * 5.;\n\t\n\tvec3 rayOrg = vec3(cos(t),sin(camp.y),sin(t)) * camp.x;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.5,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\tfloat sMin = 0.0001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (abs(s) < d*d*1e-5 || d>dMax) break; // thanks to iq for the simpler form of the condition\n\t\ts = df(p).x;\n\t\td += s * 0.3;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.01178);\n\t\t\n\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\t\n      \n        fragColor.rgb = vec3(.5);\n\n        // iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.4).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.2*dif*vec3(1,1,1);\n        brdf += 1.*spe*vec3(1.00,0.90,0.60)*dif;\n        //brdf += 1.*amb*vec3(0.50,0.70,1.00)*occ;\n        //brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ){\n    \n    \n    \n    fragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = 3.14159*0.5;\n\t\n\tvec2 camp = vec2(643./958.,356./816.) * 5.;\n\t\n\tvec3 rayOrg = fragRayOri+vec3(0,1,2);\n\t\n\t\n\tfloat fov = .5;\n\t\n\tvec3 rayDir = fragRayDir;\n\t\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\tfloat sMin = 0.0001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (abs(s) < d*d*1e-5 || d>dMax) break; // thanks to iq for the simpler form of the condition\n\t\ts = df(p).x;\n\t\td += s * 0.3;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.01178);\n\t\t\n\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\t\n      \n        fragColor.rgb = vec3(.5);\n\n        // iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.4).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.2*dif*vec3(1,1,1);\n        brdf += 1.*spe*vec3(1.00,0.90,0.60)*dif;\n        //brdf += 1.*amb*vec3(0.50,0.70,1.00)*occ;\n        //brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstcDB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[228, 228, 252, 252, 335], [337, 337, 368, 368, 635], [637, 637, 654, 654, 1394], [1396, 1396, 1428, 1428, 1606], [1608, 1624, 1698, 1698, 1937], [1939, 1955, 1997, 1997, 2296], [2298, 2493, 2550, 2550, 2838], [2840, 2840, 2897, 2897, 4560], [4562, 4562, 4655, 4655, 6088]], "test": "untested"}
{"id": "tdtcWB", "name": "Fab3 #inktober2020 \"bulky\" 155ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["2tweets", "short", "golf", "inktober2020"], "likes": 3, "viewed": 296, "published": 3, "date": "1601670268", "time_retrieved": "2024-07-30T20:42:16.958940", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    vec2 R = iResolution.xy / vec2(5,3);\n    O += sqrt( max( 0., 1. - 1.6* length( mod(U,R) - R/2. + R*.01* cos( 6.*iTime + 7.*dot(floor(U/R),R) + vec2(0,11) ) ) / R.y ) );}\n\n\n\n\n\n// --- 103 chars  motionless\n\n#define mainImage(O,U)                                     \\\n    vec2 R = iResolution.xy / vec2(5,3);                   \\\n    O += sqrt( max( 0., 1. - 1.6* length( mod(U,R) - R/2. ) / R.y ) ) /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 210]], "test": "untested"}
{"id": "wsdyWB", "name": "Fish fish fish", "author": "Jarry", "description": "fishes for #inktober", "tags": ["fish", "inktober"], "likes": 4, "viewed": 244, "published": 3, "date": "1601668779", "time_retrieved": "2024-07-30T20:42:17.766780", "image_code": "#define M_PI 3.1415926535897932384626433832795\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = rotate(uv,cos(iTime/5.0)*M_PI/4.0);\n    uv -= vec2(iTime/5.0,cos(iTime)/10.0);\n   \tuv = fract(uv * 5.0);\n\tuv = mix(vec2(-0.5,-1.0),vec2(2.0,1.0),uv);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyy+vec3(4,2,0));\n\t\n    \n    \n    // aux vars\n    float sq2 = 2.0 * sqrt(2.0);\n    float x2 = pow(uv.x,2.0);\n    float y2 = pow(uv.y,2.0);\n    // fish equation (2*x^2+y^2)^2 -2sq(2) x(2x^2-3y^2)+2(y^2-x^2)\n    float value = pow(2.0*x2+y2,2.0) \n        - sq2 * uv.x * (2.0*x2-3.0 * y2)\n        +2.0 * (y2-x2);\n    \n    \n    bool inCurve = value < 0.0;\n    \n    vec3 lightSea = vec3(0, 0.412, 0.58);\n    vec3 darkSea = vec3(0.075, 0.333, 0.537);\n    vec3 seaColor = mix(lightSea,darkSea,cos((fragCoord.x)/20.0));\n    \n    // Output to screen\n    if(inCurve)\n    \tfragColor = vec4(col,1.0);\n    else\n        fragColor = vec4(seaColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 77, 77, 161], [163, 163, 220, 270, 1183]], "test": "untested"}
{"id": "tsdyWB", "name": "You are feeling sleepy 2", "author": "itgaz", "description": "Very Very Sleepy...", "tags": ["hypnotise"], "likes": 2, "viewed": 294, "published": 3, "date": "1601667757", "time_retrieved": "2024-07-30T20:42:18.704273", "image_code": "/*\nCopyright 2020 Gareth Francis\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvec2 rotate(vec2 v, float a, vec2 origin) {\n    v = v - origin;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn (m * v) + origin;\n}\n\nvec2 aspectCorrect( in vec2 uv )\n{\n   vec2 p = vec2(uv.x * (iResolution.x / iResolution.y), uv.y);\n   return p;\n}\n\n// Angle between axis and coord, around center of screen\nfloat angle( vec2 origin, vec2 axis, vec2 coord ) {\n    vec2 a = normalize( axis );\n    vec2 b = normalize( origin - coord );\n    return acos( dot(a, b) );\n}\n\nvoid tunnel( out vec4 fragColor, in vec2 uv )\n{\n    uv = aspectCorrect(uv);\n    vec2 origin = aspectCorrect(vec2(0.5));\n    \n    float anglePc = angle(origin, vec2(0.0, -1.0), uv) / radians(360.0);\n    float dist = - (anglePc* 2.0) - distance(uv, origin);\n    vec4 baseColour = vec4(sin(iTime), cos(iTime * 2.0), sin(iTime * 8.0), 1.0);\n    \n    fragColor = sin((iTime * 12.0) + (dist * 32.0)) * baseColour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // read frequency info (for le bass)\n    vec4 bassFFT1 = texture( iChannel0, vec2(0.05, 0.25) );\n    vec4 bassFFT2 = texture( iChannel0, vec2(0.10, 0.25) );\n    vec4 bassFFT3 = texture( iChannel0, vec2(0.15 , 0.25) );\n    \n    \n    // Rotate around the center\n    // uv = rotate(uv,(2.0 * /*sin*/(iTime * 0.5)) /*+ (bassFFT1.x)*/, vec2(0.0, 0.0));\n    \n\t// Mirror\n    uv = uv.x > 0.5 ? vec2(1.0 - uv.x, uv.y) : uv.xy;\n    \n    \n    // Mirror again <3\n    uv = uv.y > 0.5 ? vec2(uv.x, 1.0 - uv.y) : uv.xy;\n    \n    // Zoom/Repeat effect\n    // uv = fract(uv + /*cos(iTime / 3.0)*/ + (bassFFT2.x * bassFFT1.x * 7.0));\n    \n    vec2 uvDir = uv - vec2(0.0);\n    uv = fract((distance(uv, vec2(0.5)) + cos(iTime / 3.0) + (bassFFT2.r * bassFFT1.r)) * 2.0) * uvDir ;\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    tunnel(fragColor, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyWB.jpg", "access": "api", "license": "bsd-simplified", "functions": [[1275, 1275, 1318, 1318, 1433], [1435, 1435, 1469, 1469, 1548], [1550, 1607, 1658, 1658, 1764], [1766, 1766, 1813, 1813, 2175], [2177, 2177, 2234, 2284, 3216]], "test": "untested"}
{"id": "3dtcDB", "name": "[TWITCH] Frankenslug", "author": "evvvvil", "description": "Frankenslug - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["tunnel", "demoscene", "glow", "alien", "goo", "organic", "scifi", "liquid", "tube", "monster", "drip", "lazer", "creature", "industrial", "biomechanic", "giger"], "likes": 31, "viewed": 1114, "published": 3, "date": "1601653605", "time_retrieved": "2024-07-30T20:42:19.583922", "image_code": "// Frankenslug - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,ggg,tnoi=1.;vec3 blobP,op,po,no,al,ld,colorP;\nfloat lngSp( vec3 p, vec3 h,float r ) {p = p - clamp( p, -h, h );return length( p )-r;}\nconst float PI=acos(-1.);\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nfloat smax(float a,float b,float k){float h=max(k-abs(-a-b),0.);return max(-a,b)+h*h*.25/k;}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25;\n                       f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p,float s)\n{\n    op=blobP=p;\n    vec3 hTubesP=p-vec3(0,0,0);    \n    float frill=sin(p.x*30.)*.005,\n        vfrill=cos(p.y*30.)*.006,\n        def=sin(p.x*.5+tt)*.2+sin(p.x*.1+1.)*.3-sin(p.x*1.5)*.2+cos(p.x*p.z*.3)*.2,\n        vdef=sin(p.y*.5+tt+1.),\n        tunnelD=clamp(cos(p.x*.5+1.5),-.5,.5);\n    hTubesP=vec3(atan(hTubesP.z,hTubesP.y)*4., length(hTubesP.zy)-6.9+tunnelD, hTubesP.x*.5);  \n    float tubeD=clamp((cos(hTubesP.z*.4-.5)),-.1,.1)*5.+.5;  \n    hTubesP.x=mod(hTubesP.x,6.)-3.;\n    hTubesP.x=abs(hTubesP.x)-1.5;\n    for(int i=0;i<3;i++){\n        hTubesP.x=abs(hTubesP.x)-tubeD*.2;    \n        hTubesP.x-=.15;\n    }    \n    blobP.xy-=def*1.5;\n    vec3 blobPlugsP=vec3(abs(abs(blobP.x)-2.8)-1.4,abs(abs(abs(blobP.y)-3.5)-4.)-1.5-def*1.5,abs(blobP.z)-2.2);  \n    blobPlugsP.yz*=r2(sin(p.x*.3+tt)*.1);\n    blobPlugsP.z+=-.65+cos(p.y*.4)*.75;\n    vec3 vertTubesP=blobPlugsP;\n    vec2 h,t=vec2(.7*(length(vertTubesP.xz)-.16-vdef*.08-vfrill),7);                      //SLUG VERTICAL TUBES\n    if(lngSp(blobP,vec3(7.5,0,0),5.5)<0.){\n        tnoi=texNoise(p.xz*.06-vec2(.66,1.28)).r*3.8;\n        t.x=min(t.x,.55*lngSp(blobP,vec3(3.9,0,0),2.5+frill+(def-tnoi)*.5));              //SLUG BODY\n        t.x=smax(.8*(length(blobP-vec3(6.,.1,0))-1.1+sin(tt)*.5+tnoi*.4),t.x,.4);         //SLUG MOUTH    \n        t.x=smax(.8*(length(abs(blobP.yz-vec2(3.2,0))-1.)-.12+sin(p.x*25.)*.03),t.x,1.);  //SLUG HOLE CREST\n    }\n    t.x=smin(.5*(length(blobPlugsP)-.6-sin(blobPlugsP.y*blobPlugsP.z*30.)*0.04),t.x,.4);  //SLUG PLUGS  \n    //t.x=smax(length(blobPlugsP-vec3(0,0.4,-0.1))-.3,t.x,.5);//REMOVED TO OPTIMIZE\t\t  //SLUG PLUG HOLES\n    vec3 bubblesP=p-vec3(0,2.5+def,0);bubblesP.x=abs(abs(bubblesP.x)-2.)-1.;\n    t.x=smin(t.x,max(length(bubblesP*vec3(1,sin(p.y*.5-p.x*.2-tt)*.3,1))-.3+p.y*.03,-p.y),.5); //SLUG BUBBLES  \n    h=vec2(length(p.yz)-50.,5.);                                                            //TUNNNNNNNNNELLLLL  \n    h.x=max(h.x,-.8*(length(p.yz)-7.+frill*2.+tunnelD));  \n    vertTubesP-=vec3(0,.4,0.0);\n    if(s>0.){\n        float glowPlugs=.6*(length(vertTubesP)-.48);                                      //SLUG GLOW PLUGS  \n        g+=0.1/(0.1*glowPlugs*glowPlugs*500.);  \n        vertTubesP.xz*=r2(sin(p.y*.5)+tt);    \n        vertTubesP=abs(vertTubesP)-.1-vdef*.4*clamp(p.y-2.,0.,1.)-vfrill;  \n        float lazers=0.65*length(vertTubesP.xz);                                          //LAZERS\n        lazers=min(lazers,glowPlugs);  \n        g+=0.1/(0.1*lazers*lazers*400.);  \n        h.x=min(h.x,lazers);\n        float reddish=.7*lngSp(blobP-vec3(0,.75,0),vec3(4.1,0,0.),1.1+frill);             //SLUG REDISH GLOW\n        ggg+=0.1/(0.1*reddish*reddish*400.);\n        h.x=min(h.x,reddish);\n    }\n    t=t.x<h.x?t:h;    \n    h=vec2(0.8*(length(hTubesP.xy)-.15+(clamp(sin(p.x*3.),-0.5,.5)+.5)*.1),6);            //TUUUUUUUUUBES WHITE\n    t=t.x<h.x?t:h;    \n    h=vec2(.9*length(hTubesP.xy-frill-vec2(0.3,0.))-.38-tunnelD*.2,3);                    //BLACK TUBES CASINGS\n    h.x=max(h.x,-.8*(hTubesP.y+.2-frill)+sin(p.z*p.x*.05)*.2);\n    h.x=max(h.x,-.9*(abs(abs(hTubesP.x-.2)-.2)-.1));  \n    t=t.x<h.x?t:h;\n    colorP=hTubesP;\n    return t;\n}\nvec2 tr( vec3 ro,vec3 rd)\n{\n    vec2 h,t=vec2(.2);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x,1.);\n        if(h.x<.0001||t.x>35.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if(t.x>35.) t.y=0.;\n    return t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime+9.3,62.83);\n    vec3 ro=mix(vec3(18.+cos(tt*.2)*9.,4,sin(tt*.4)*4.),\n                vec3(5.-sin(tt*.2)*20.,cos(tt*.2)*5.,-2.),ceil(cos(tt*0.2)));\n    vec3 cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),\n        cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    co=fo=vec3(.2,.12,.1)-length(uv)*.1-rd.y*.2;\n    ld=normalize(vec3(.3,.3,-.0));\n    z=tr(ro,rd);t=z.x;\n    if(z.y>0.){\n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n        al=vec3(.6,.5,.4)-sin(colorP.x*200.)*.1;\n        float spa=1.,sspa=0.;\n        if(z.y<5.)al=vec3(0);\n        if(z.y>5.)al=vec3(1),spa=0.;\n        if(z.y>6.)al=vec3(.1,.2,.4)*.5,spa=sspa=1.;\n        float dif=max(0.,dot(no,ld)),\n            fr=pow(1.+dot(no,rd),4.),\n            sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n        co=mix(sp*spa+al*(a(.05)*a(.2)+.2)*(dif*vec3(.6,.7,.9)+s(.5)*sspa*2.),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.00008*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.2*vec3(.1,.3,.9)+ggg*.2*vec3(.7,.3,.2),vec3(.65)),1);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 311, 311, 359], [386, 386, 422, 422, 476], [477, 477, 513, 513, 569], [570, 570, 587, 587, 630], [631, 631, 654, 654, 874], [875, 875, 901, 901, 4047], [4048, 4048, 4075, 4075, 4264], [4360, 4360, 4417, 4417, 5641]], "test": "untested"}
{"id": "WddcWB", "name": "Fab2 #inktober2020 \"wisp\"  176ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["2tweets", "short", "golf", "inktober2020"], "likes": 5, "viewed": 324, "published": 3, "date": "1601649581", "time_retrieved": "2024-07-30T20:42:20.568290", "image_code": "// -10 by Xor\n\n#define S O  = min( O, abs( .1*U* sin(8.*U-iTime) - U.y ) ), \\\n          U *= mat2(1,.2,-.2,1)                       //\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.yy, O=R/R,\n         U = u / R -.5;\n    U.x > 0. && U.x < 1.\n     ?  S, S, S,\n        o += 1. - O.x *R.y/3.     : o; }    /*\n\n\n\n            \n\n// --- 176 chars\n\n//#define S O  = min( O, abs( .1* sin(8.*U.x) - U.y ) ), // old variant\n#define S O  = min( O, abs( .1*U.x* sin(8.*U.x-iTime) - U.y ) ), \\\n          U *= mat2(1,.2,-.2,1)                       //\n#define mainImage(o,u)                                 \\\n    vec2 R = iResolution.xy, O=R-R,                    \\\n         U = u / R.y -.5;                              \\\n    U.x > 0. && U.x < 1.                               \\\n     ?  O++, S, S, S,                                  \\\n        o += 1. - O.x *R.y/3.     : o                 /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddcWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 171, 171, 314]], "test": "untested"}
{"id": "3sdyDS", "name": "3D inversion 2", "author": "FabriceNeyret2", "description": "3D inversion of a regular grid.\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 8, "viewed": 445, "published": 3, "date": "1601640110", "time_retrieved": "2024-07-30T20:42:21.389095", "image_code": "// variant of \"3D inversion\"  https://shadertoy.com/view/3ddyDS\n\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n             \nfloat z, BR = 2.5;   // bounding sphere (0,0,0), 2.\nfloat map(vec3 p )\n{\n    vec3 q = 2. * p / dot(p,p);\n    z = length(q)/2.;                          // depth in sphere\n // q += .1*iTime; \n    q = abs( fract(q+.5)-.5 );\n    float f = min( length(q.xy), min(length(q.yz),length(q.xz)));\n    f = smoothstep(.05,.0,f);\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), BR );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > BR ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 col = exp(- .4*vec3(3,3,2) *(1.-z));      // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));      // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n         // vec3 col = vec3(1);\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*10.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = abs( dot(sundir,rd) );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * ( .2 + pow( sun,3.) );\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 193, 213, 213, 498], [1009, 1009, 1042, 1101, 1298], [1300, 1300, 1359, 1359, 1507], [1509, 1509, 1566, 1566, 3848], [3850, 3850, 3896, 3896, 4058], [4060, 4060, 4103, 4127, 4584], [4586, 4586, 4624, 4624, 5173]], "test": "untested"}
{"id": "3ddyDS", "name": "3D inversion", "author": "FabriceNeyret2", "description": "3D inversion of a regular grid of cubes.\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 20, "viewed": 507, "published": 3, "date": "1601639953", "time_retrieved": "2024-07-30T20:42:22.240818", "image_code": "// variant of https://shadertoy.com/view/tsdcRj\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n             \nfloat z, BR = 2.5;   // bounding sphere (0,0,0), 2.\nfloat map(vec3 p )\n{\n    vec3 q = 2. * p / dot(p,p);\n    z = length(q)/2.;                             // depth in sphere\n    q = abs( fract(q+.5)-.5 );\n    float f = max( q.x, max(q.y,q.z));\n    f = smoothstep(.3,.29,f);\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), BR );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > BR ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 col = exp(- .4*vec3(3,3,2) *(1.-z));      // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));      // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n         // vec3 col = vec3(1);\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = abs( dot(sundir,rd) );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * ( .2 + pow( sun,3.) );\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 556, 576, 576, 817], [1328, 1328, 1361, 1420, 1617], [1619, 1619, 1678, 1678, 1826], [1828, 1828, 1885, 1885, 4166], [4168, 4168, 4214, 4214, 4376], [4378, 4378, 4421, 4445, 4902], [4904, 4904, 4942, 4942, 5491]], "test": "untested"}
{"id": "WsdcWS", "name": "hypertextures div-free displace2", "author": "FabriceNeyret2", "description": "using divergence-free random 3D displacement  to pull \"hairs from a simple distribution ( here, a sphere ).\n( inspired by [url]https://mrl.nyu.edu/~perlin/doc/hypertexture/[/url] )\n\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 29, "viewed": 894, "published": 3, "date": "1601638086", "time_retrieved": "2024-07-30T20:42:23.050652", "image_code": "// disp of not-noise variant of https://shadertoy.com/view/wddczl\n// divergence-free variant of https://shadertoy.com/view/wstyzl\n// variant of https://shadertoy.com/view/tsdcRj\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) texture(iChannel0, x ).xyz\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nvec3 divfreenoise( vec3 q ) { // fluid-like noise = div-free -> curl\n    vec2 e = vec2(1./16.,0);\n    q += .1*iTime;            // animated flow\n    vec3 v = noise(q); \n // return 2.*(v -.5);             // regular\n    return vec3( noise(q+e.yxy).z-v.z - v.y+noise(q+e.yyx).y, // curl\n                 noise(q+e.yyx).x-v.x - v.z+noise(q+e.xyy).z,\n                 noise(q+e.xyy).y-v.y - v.x+noise(q+e.yxy).x\n                ) *1.;\n}\n             \nfloat z, BR = 2.5;   // bounding sphere (0,0,0), 2.\nfloat map(vec3 p )\n{\n    vec3 q = p;\n // vec3 N = 2.* noise(q/10.) -1.;                // displacement\n    vec3 N = divfreenoise(   q/5.)\n      ; // + divfreenoise(2.*q/5.) /2.\n        // + divfreenoise(4.*q/5.) /4.\n        // + divfreenoise(8.*q/5.) /8.;\n    q += N;\n    float f = // ( 1.2*noise(q/2.+ .1*iTime).x -.2 ) * // source noise\n               smoothstep(1.,.8,dot(q,q)/1.5);   // source sphere\n\n // f*= smoothstep(.1,.2,abs(p.x));               // empty slice (derivable ) \n    z = length(q)/2.;                             // depth in sphere\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), BR );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > BR ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 col = exp(- vec3(3,3,2) *(1.-z));     // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));  // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = max( dot(sundir,rd), 0. );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdcWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[665, 665, 694, 733, 1097], [1133, 1164, 1184, 1184, 1757], [2268, 2268, 2301, 2360, 2557], [2559, 2559, 2618, 2618, 2766], [2768, 2768, 2825, 2825, 5066], [5068, 5068, 5114, 5114, 5276], [5278, 5278, 5321, 5345, 5797], [5799, 5799, 5837, 5837, 6386]], "test": "untested"}
{"id": "wsccWB", "name": "Fab1 #inktober2020 \"fish\"  274ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["2tweets", "short", "golf", "inktober2020"], "likes": 8, "viewed": 335, "published": 3, "date": "1601627428", "time_retrieved": "2024-07-30T20:42:23.898386", "image_code": "void mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.xy,          O = R-R,\n         U = 4.* u / R.y - vec2(6,2), V = U.yy - iTime;\n    U.y > 0. ? o += max(0.,1.-abs(length( vec2( U.x+.8+.2*sin(ceil(3.*V.y)),\n                                                fract(V)-.5) ) -.05\n                                 ) *R.y/4.)      : o;\n     U.y*U.y < 1.\n     ?  U.y *= sign( (U.x + 3.58 ) * U.y ),\n        O += length(++U) - atan(U.y,U.x),\n        O *= R.y/8., o += max( 1. - O*O, 0. ).x  : o;}    /*\n\n\n\n\n\n\n// --- 151 chars   just the fish\n\n#define mainImage(O,u)                                    \\\n    vec2 R = iResolution.xy,                              \\\n         U = 4.* u / R.y - vec2(6,2);                     \\\n    U.y*U.y < 1.                                          \\\n     ?  U.y *= sign( (U.x + 3.58 ) * U.y ),               \\\n        O += length(++U) - atan(U.y,U.x),                 \\\n        O *= R.y/8., O = 1.-O*O     : O                  /*\n\n\n\n\n\n\n// --- 147 chars   but line artifact at some resolutions\n\n#define mainImage(O,u)                                    \\\n    vec2 U = 4.* u / iResolution.y - vec2(6,2);           \\\n    U.y*U.y < 1.                                          \\\n     ?  U.y *= sign( (U.x + 3.58 ) * U.y ),               \\\n        O += length(++U) - atan(U.y,U.x),                 \\\n        O /= fwidth(O), O = 1.-O*O     : O\n\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsccWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 497]], "test": "untested"}
{"id": "tsccWB", "name": "Cloud Computing", "author": "dr2", "description": "The original version; other computations are left as exercises for the reader.", "tags": ["binary", "fog", "arithmetic"], "likes": 8, "viewed": 334, "published": 3, "date": "1601626406", "time_retrieved": "2024-07-30T20:42:24.635415", "image_code": "// \"Cloud Computing\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat TriNoise3d (vec3 p);\nfloat Hashfv3 (vec3 p);\n\nfloat dstFar, tCur, tPos, densFac;\nconst float pi = 3.1415927;\n\nvec2 CapsHit (vec3 ro, vec3 rd, float cRad, float cLen)\n{\n  float dIn, dOut, d, a, b, bs, w, s, ws, roz;\n  dIn = dstFar;\n  dOut = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cRad * cRad);\n  if (w > 0. && a > 0.) {\n    ws = sqrt (w);\n    d = - (b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (d > 0. && abs (s) < cLen) dIn = d;\n    else {\n      roz = ro.z;\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) {\n        d = - bs - sqrt (w);\n        if (d > 0.) dIn = d;\n      }\n      ro.z = roz;\n    }\n  }\n  if (dIn < dstFar) {\n    d = (- b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (abs (s) < cLen) dOut = d;\n    else {\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) dOut = - bs + sqrt (w);\n    }\n  }\n  return vec2 (dIn, dOut);\n}\n\nfloat CldDens (vec3 p, vec2 cldSz)\n{\n  float c;\n  c = max (0., 1.1 * TriNoise3d (vec3 (0.5 * p.xy - 0.1 * p.z + 0.1 * tPos,\n     0.5 * p.z + 0.05 * tPos)) - 0.1);\n  return densFac * c * (1. - smoothstep (-0.3 * cldSz.x, 0., length (vec3 (p.xy,\n     p.z - clamp (p.z, - cldSz.y, cldSz.y))) - cldSz.x));\n}\n\nvec3 CldCol (vec3 col, vec3 ro, vec3 rd, int dir, vec2 cldSz)\n{  // adapted from \"Misty Flight\", but marching through capsule\n  vec4 col4;\n  vec2 dCyl2;\n  vec3 q, c;\n  float s, ds, f, fn, r;\n  const float sMax = 40.;\n  tPos += 10.;\n  col4 = vec4 (col, 0.);\n  ro = (dir == 0) ? ro.yzx : ro.xzy;\n  rd = (dir == 0) ? rd.yzx : rd.xzy;\n  dCyl2 = CapsHit (ro, rd, cldSz.x, cldSz.y);\n  if (dCyl2.x < dstFar) {\n    ds = min (2. * cldSz.x, dCyl2.y - dCyl2.x) / sMax;\n    s = dCyl2.x;\n    q = ro + s * rd;\n    r = length (q.xy) / cldSz.x;\n    q.xy = Rot2D (q.xy, 0.5 * r * q.z);\n    fn = CldDens (q, cldSz);\n    for (float j = 0.; j < sMax; j ++) {\n      s += ds;\n      f = fn;\n      q = ro + (s + ds * Hashfv3 (16. * rd)) * rd;\n      r = length (q.xy) / cldSz.x;\n      q.xy = Rot2D (q.xy, 0.5 * r * q.z);\n      fn = CldDens (q, cldSz);\n      c = mix (vec3 (0.8), vec3 (1.), clamp ((0.3 / ds) * (f - fn), 0., 1.));\n      col4 += (1. - col4.a) * vec4 (c, 1.) * f / sMax;\n      if (col4.a > 1.) break;\n    }\n  }\n  return clamp (col4.rgb, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 cldSz;\n  float tCyc, x, y;\n  tPos = tCur;\n  tCyc = mod (tCur, 24.);\n  cldSz = vec2 (0.4, 2.);\n  col = vec3 (0.1, 0.1, 0.7) * (1. + 0.2 * rd.y);\n  ro.x += 5.;\n  x = ro.x;\n  y = ro.y;\n  densFac = 1. - smoothstep (22., 24., tCyc);\n  if (tCyc > 2.) {\n    ro.xy = vec2 (x + 3.5, y);\n    col = CldCol (col, ro, rd, 1, cldSz * vec2 (1., 1.2));\n  }\n  if (tCyc > 4.) {\n    ro.xy = vec2 (x + 1.2, y);\n    col = CldCol (col, ro, rd, 0, cldSz * vec2 (1., 0.3));\n    ro.x -= 2.4;\n    col = CldCol (col, ro, rd, 0, cldSz * vec2 (1., 0.3));\n    ro.x = x;\n    ro.y = y + 1.2;\n    col = CldCol (col, ro, rd, 1, cldSz * vec2 (1., 0.3));\n    ro.y -= 2.4;\n    col = CldCol (col, ro, rd, 1, cldSz * vec2 (1., 0.3));\n  }\n  if (tCyc > 6.) {\n    ro.xy = vec2 (x - 3.5, y);\n    col = CldCol (col, ro, rd, 1, cldSz * vec2 (1., 1.2));\n  }\n  if (tCyc > 8.) {\n    ro.xy = vec2 (x - 6.5, y + 0.6);\n    col = CldCol (col, ro, rd, 0, cldSz * vec2 (1., 0.6));\n    ro.y -= 1.2;\n    col = CldCol (col, ro, rd, 0, cldSz * vec2 (1., 0.6));\n  }\n  if (tCyc > 12.) {\n    ro.xy = vec2 (x - 9.5, y);\n    col = CldCol (col, ro, rd, 1, cldSz * vec2 (1., 1.2));\n  }\n  if (tCyc > 14.) {\n    ro.xy = vec2 (x - 12.5, y + 2.4);\n    col = CldCol (col, ro, rd, 0, cldSz * vec2 (1., 0.55));\n    ro.y -= 4.8;\n    col = CldCol (col, ro, rd, 0, cldSz * vec2 (1., 0.55));\n    ro.x += 1.4;\n    ro.y = y;\n    col = CldCol (col, ro, rd, 1, cldSz * vec2 (1., 0.8));\n    ro.x -= 2.8;\n    col = CldCol (col, ro, rd, 1, cldSz * vec2 (1., 0.8));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.3 * pi * sin (0.05 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  zmFac = 5.;\n  ro = vuMat * vec3 (0., 0., -30.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat FrAbsf (float p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nvec3 FrAbsv3 (vec3 p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nfloat TriNoise3d (vec3 p)\n{\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += FrAbsv3 (q + FrAbsv3 (q).yzx);\n    p *= 1.2;\n    f += a * (FrAbsf (p.x + FrAbsf (p.z + FrAbsf (p.y))));\n    q = 2. * q + 0.2;\n    a *= 0.7;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsccWB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[305, 305, 362, 362, 1237], [1239, 1239, 1275, 1275, 1542], [1544, 1544, 1607, 1669, 2580], [2582, 2582, 2617, 2617, 4154], [4156, 4156, 4212, 4212, 4823], [4825, 4825, 4861, 4861, 5067], [5069, 5069, 5099, 5099, 5212], [5214, 5214, 5238, 5238, 5272], [5274, 5274, 5297, 5297, 5331], [5333, 5333, 5360, 5360, 5613], [5647, 5647, 5671, 5671, 5736]], "test": "untested"}
{"id": "td3yDS", "name": "vampire squid moth", "author": "xenn", "description": "SPACE to restart\nwow these coloured surfaces are very trippy\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 14, "viewed": 575, "published": 3, "date": "1601611222", "time_retrieved": "2024-07-30T20:42:25.567922", "image_code": "// Fork of \"shifting surfaces\" by xenn. https://shadertoy.com/view/wsdczl\n// 2020-10-02 03:56:57\n\n// Fork of \"Slime mold advection\" by michael0884. https://shadertoy.com/view/3tjfzh\n// 2020-10-01 10:52:06\n\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 0.56\n#define RAD R.x*010.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*01.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*01.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(15.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*010.5, 0.5) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.025*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1.9 - 10.1*distance(albedo, vec3(10.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 5.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 13.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 10.*albedo*colB + 01.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 10.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 2.7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 01.620\n\n\n#define sense_num 12\n#define sense_ang 0.1*(01.1*cos(iTime*0.51))\n//#define sense_dis 12.0*(010.51*cos(iTime*0.051))\n#define sense_dis 152.0\n#define sense_oscil 0.051\n#define oscil_scale 0.1\n#define oscil_pow 01.\n#define sense_force 0.2\n#define distance_scale 0.9260\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.09\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3yDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 265, 265, 443], [485, 485, 516, 516, 550], [552, 552, 604, 604, 723], [725, 725, 760, 760, 784], [786, 786, 817, 817, 904], [906, 906, 927, 927, 1021], [1023, 1023, 1045, 1045, 1141], [1144, 1144, 1164, 1164, 1359], [1362, 1362, 1397, 1397, 1582], [1621, 1621, 1653, 1653, 1821], [1823, 1823, 1868, 1868, 4670]], "test": "untested"}
{"id": "wdtcRs", "name": "Cyclostationary noise", "author": "cycloEG2020", "description": "This is a simple shader illustrating the possibility of adapting noise models to the cyclostationary context. It uses a spatially-varying and periodic PSD (the PSD of the polyphase components) for each sample of the output, and keeps the random phase.", "tags": ["noise"], "likes": 0, "viewed": 234, "published": 3, "date": "1601572378", "time_retrieved": "2024-07-30T20:42:26.382744", "image_code": "//=================================================================\n//= Cyclostationary noise - paper 1152 - For Eurographics 2021\n//=================================================================\n//= Based on the shadertoys of Arthur Cavalier (LRPN, phasor) and Fabrice Neyret (Gabor noise).\n//- Shaders : https://www.shadertoy.com/view/WscGD8\n//-           https://www.shadertoy.com/view/WsSSWG\n//=================================================================\n\n//The spectrum model is based on manipulating the frequency, orientation and range\n//of a bi-lobe spectrum according to the spatial coordinates with a period.\n//The viewer is invited to play with the definitions of F (range of frequencies) \n//and O (range of orientations) from line 188 to 202\n//in order to modify the spatially-varying spectrum used.\n\n//--------------------------------------------------------------------------------------------------------\n//-- User Parameters -------------------------------------------------------------------------------------  \n#define MOUSE_CONTROL\n#define TIMER_OFFSET\nconst int   LRPN_COSINES     = 3;\nconst float LRPN_RESOLUTION  = 5.0;\nconst float LRPN_SLOPE_SCALE = 0.1;\nconst uint  LRPN_GLOBAL_SEED = 0u;\n\nfloat \t\tGABOR_SIZE   = 0.07;\nfloat\t\tGABOR_NB_KERNELS = 300.; //lower if running on a low-end PC\n\n//--------------------------------------------------------------------------------------------------------\n//-- Constants -------------------------------------------------------------------------------------------  \nconst float m_pi_2 \t\t= 1.5707963267;         \nconst float m_pi   \t\t= 3.1415926535;          \nconst float m_2_pi \t\t= 6.2831853071;\nconst float m_isqrt2 \t= 0.7071067811865;\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Pseudo Random Number Generation ---------------------------------------------------------------------  \n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Normal Mapping Function -----------------------------------------------------------------------------  \nvec3 normal_map_from_slope(float dx, float dy) // using partial derivatives\n{\n    float norm = length(vec3(dx,dy,1.0));\n    float nx = -dx / norm; \n    float ny = -dy / norm; \n    float nz = 1.0 / norm; \n    return 0.5 + 0.5 * vec3(nx,ny,nz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Gaussian Window Function ----------------------------------------------------------------------------  \nfloat gaussian(in vec2 st, in float c, in vec2 mu, in mat2 sig)\n{\n    vec2 p = st-mu;\n    float body = -0.5*dot(p,inverse(sig)*p);\n    return c*exp(body);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Profile Functions ----------------------------------------------------------------------------------- \n//-- From Thibault Tricard source : https://www.shadertoy.com/view/wlsXWf\nfloat PWM(float x, float r) {return mod(x,m_2_pi)> m_2_pi *r ? 1.0 : 0.0;}\nfloat wave_square(float x)  {return PWM(x,0.5);}\nfloat wave_saw(float x)     {return mod(x,m_2_pi)/(m_2_pi);}\nfloat wave_sine(float x)    {return 0.5+0.5*sin(x);}\n\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Local Random Phase Noise ----------------------------------------------------------------------------\nvec4 local_random_phasor_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation\n    )\n{\n    vec2  scaled_coords = texcoords * resolution;\n    vec2  cell_coords   = fract(scaled_coords);\n    vec2  cell_index    = floor(scaled_coords);\n    \n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    vec4  lrpn   = vec4(0.);\n    float weight = 1. / float(cosines);\n    mat2  sigma  = mat2( (1.2*1.2)/m_2_pi );\n\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed = cell_seed(cell_ID,LRPN_GLOBAL_SEED);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        float d = dot(xy,xy);\n        \n        vec2  sum_of_cosines    = vec2(0.); \n        float sum_of_partial_x  = 0.; \n        float sum_of_partial_y  = 0.; \n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y) * resolution;   // Scaled Frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y);            // Orientation\n            float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.);                                       // Phase\n            float ff = m_2_pi * dot(xy, fr * vec2(cos(or),sin(or)) );                               // Oriented Frequency\n            vec2  sc = vec2( cos(ff+ph), sin(ff+ph) ); \n\n            sum_of_cosines   += sc;\n            sum_of_partial_x += -m_2_pi * fr * cos(or) * sc.y;\n            sum_of_partial_y += -m_2_pi * fr * sin(or) * sc.y; \n        }\n\n        lrpn += gaussian(xy, 1., vec2(0.0), sigma) * weight * vec4(sum_of_cosines, sum_of_partial_x, sum_of_partial_y);\n    }\n    return vec4(lrpn); // vec3(Cosines, Sines, Partial X, Partial Y); \n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Utils -----------------------------------------------------------------------------------------------\nfloat looped_smooth_stairs(float t, float ratio, float nof_values)\n{\n    t*= nof_values;\n    return mix(floor(mod(t/ratio, nof_values)), floor(mod((t+1.)/ratio, nof_values)), smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat gauss(float x,float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(vec2 v,float s) { return gauss(v.x,s)*gauss(v.y,s); }\n\n\nfloat rndi(float i, float j) {\n    return fract(1e5*sin(i+3.*j+0.567));\n}\n\n\n// --- complex Gabor ------------------------------\nvec2 Gabor(vec2 pos, float freq, float a) {\n    float t = (keyToggle(64+20))? 0. : iTime; // 'T'\n    float g = gauss(pos, GABOR_SIZE);\n    if (g < 1e-3) return vec2(0.);\n    vec2 dir = m_isqrt2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n    float phi = freq*dot(pos,dir) * 2.* m_pi + 10.*t;\n\n    return g*vec2(cos(phi),sin(phi)); // NB: only the real part is used, classically\n}\n\n// --- complex Gabor noise = kernel * point distrib\nvec2 GaborNoise(vec2 uv, vec2 F, vec2 O) {\n    const uint seed = uint(0);\n    uint prng = wang_hash(seed);\n    vec2 f=vec2(0.);\n\tfor (float i=0.; i<GABOR_NB_KERNELS; i++) { \n\t\tvec2 pos = vec2(1.8*rndi(i,0.),-1.+rndi(i,1.)*2.);\n        float a = myrand_uniform_m_M(prng, O.x, O.y);\n        float F = myrand_uniform_m_M(prng, F.x, F.y);\n\t\tf += Gabor(uv-pos, F, a);\n\t}\n\treturn f *sqrt(200./GABOR_NB_KERNELS); // /6.;\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixcoords = fragCoord.xy / iResolution.xy;\n    vec2 texcoords = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n    \n    //===========================================\n\n    //Definition of a spatially-varying amplitude - teaser\n    vec2  F = vec2(0.5,0.6);        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//~ Frequecy range [fmin;fmax]\n    vec2  O = vec2(0. + texcoords.x * m_pi * 1.66 , m_pi/6. + texcoords.x * 1.66* m_pi);   \t\t\t//~ Orientation range [omin;omax]\n    \n    //Definition of a spatially-varying amplitude - sup mat. (1)\n    //vec2  F = vec2(0.5,0.6);\n    //vec2  O = vec2(0. + m_pi * 1.66 , 1.66* m_pi + cos(16.*texcoords.y));\n    \n    //Definition of a spatially-varying amplitude - sup mat. (2)\n    //vec2  F = vec2(0.5,0.6);\n    //vec2  O = vec2(0. + texcoords.x * m_pi * 1.66 , texcoords.x * 1.66* m_pi + (m_pi/4.)*cos(5.*texcoords.y));\n    \n    //===========================================\n    \n    float R = LRPN_RESOLUTION;      \t\t\t\t\t\t\t\t\t\t//~ Grid resolution\n    int   K = LRPN_COSINES;         \t\t\t\t\t\t\t\t\t\t//~ Number of cosines\n\n#ifdef TIMER_OFFSET\n    texcoords += vec2(0.1*iTime);\n#endif\n\n    vec4  lrpn = local_random_phasor_noise(texcoords,R,K,F,O);\n    float Sc = lrpn.x;\n    float Ss = lrpn.y;\n    float Dx = lrpn.z * LRPN_SLOPE_SCALE;\n    float Dy = lrpn.w * LRPN_SLOPE_SCALE;\n\n    float Phi = atan(Ss,Sc);\n\n\tif(pixcoords.x < 0.66)\n    {\n      \tif(pixcoords.x < 0.33)\n        \tfragColor.rgb = vec3(0.5+0.5*Sc);\n        else\n        {\n          \tfloat Weight = looped_smooth_stairs(iTime,4.,3.);\n        \tfloat Phasor = wave_sine(Phi);\n                        //+ max(1.-abs(Weight-1.),0.) * wave_saw(Phi) //different phasor noise profiles\n                        //+ max(1.-abs(Weight-2.),0.) * wave_square(Phi);\n        \tfragColor.rgb = vec3( Phasor );\n        }\n    }\n    else\n    {\n        texcoords -= vec2(0.1*iTime);\n        vec2 f  = .5 * GaborNoise(texcoords, F*25., O - m_pi/4.); //sqrt((O.y-O.x)*(O.y-O.x)\n    \n    \t// --- Normalize and display Gabor noise\n    \tfragColor = vec4(.5+.5*f.x);  \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2304, 2304, 2373, 2373, 2484], [2677, 2677, 2746, 2746, 2791], [2792, 2792, 2861, 2861, 2905], [2906, 2906, 2975, 2975, 3024], [3025, 3025, 3053, 3053, 3126], [3128, 3344, 3421, 3421, 3588], [3590, 3806, 3871, 3871, 3962], [3964, 4253, 4282, 4282, 4327], [4328, 4328, 4357, 4357, 4376], [4377, 4377, 4406, 4406, 4437], [4438, 4438, 4467, 4467, 4490], [4494, 4708, 4899, 4899, 6611], [6613, 6827, 6895, 6895, 7036], [7038, 7038, 7068, 7068, 7104], [7105, 7105, 7134, 7134, 7170], [7173, 7173, 7203, 7203, 7246], [7249, 7301, 7344, 7344, 7679], [7681, 7733, 7775, 7775, 8148], [8150, 8364, 8421, 8421, 10505]], "test": "untested"}
{"id": "wsdczl", "name": "shifting surfaces", "author": "xenn", "description": "SPACE to restart\nwow these coloured surfaces are very trippy\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 7, "viewed": 340, "published": 3, "date": "1601571038", "time_retrieved": "2024-07-30T20:42:27.380077", "image_code": "// Fork of \"Slime mold advection\" by michael0884. https://shadertoy.com/view/3tjfzh\n// 2020-10-01 10:52:06\n\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 2.56\n#define RAD R.x*01.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*01.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*01.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(15.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*010.5, 0.5) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.025*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1.9 - 10.1*distance(albedo, vec3(10.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 5.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 13.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 10.*albedo*colB + 01.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 10.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 2.7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 01.620\n\n\n#define sense_num 12\n#define sense_ang 0.1*(01.1*cos(iTime*0.1451))\n//#define sense_dis 12.0*(010.51*cos(iTime*0.051))\n#define sense_dis 212.0*(01.1*sin(iTime*0.81))\n#define sense_oscil 0.051\n#define oscil_scale 0.1\n#define oscil_pow 01.\n#define sense_force 0.2\n#define distance_scale 00.725\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.09\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 167, 167, 345], [386, 386, 417, 417, 451], [453, 453, 505, 505, 624], [626, 626, 661, 661, 685], [687, 687, 718, 718, 805], [807, 807, 828, 828, 922], [924, 924, 946, 946, 1042], [1045, 1045, 1065, 1065, 1260], [1263, 1263, 1298, 1298, 1483], [1522, 1522, 1554, 1554, 1722], [1724, 1724, 1769, 1769, 4571]], "test": "untested"}
{"id": "wddczl", "name": "hypertextures div-free displace", "author": "FabriceNeyret2", "description": "using divergence-free random 3D displacement  to pull \"hairs from a simple distribution ( here, random too ).\n( inspired by [url]https://mrl.nyu.edu/~perlin/doc/hypertexture/[/url] )\n\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 13, "viewed": 535, "published": 3, "date": "1601570828", "time_retrieved": "2024-07-30T20:42:28.302610", "image_code": "// divergence-free variant of https://shadertoy.com/view/wstyzl\n// variant of https://shadertoy.com/view/tsdcRj\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) texture(iChannel0, x ).xyz\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nvec3 divfreenoise( vec3 q ) { // fluid-like noise = div-free -> curl\n    vec2 e = vec2(1./16.,0);\n // q += .1*iTime;            // animated flow\n    vec3 v = noise(q); \n // return v -.5;             // regular\n    return vec3( noise(q+e.yxy).z-v.z - v.y+noise(q+e.yyx).y, // curl\n                 noise(q+e.yyx).x-v.x - v.z+noise(q+e.xyy).z,\n                 noise(q+e.xyy).y-v.y - v.x+noise(q+e.yxy).x\n                ) *1.;\n}\n             \nfloat z, BR = 2.2;   // bounding sphere (0,0,0), 2.\nfloat map(vec3 p )\n{\n    vec3 q = p;\n // vec3 N = 2.* noise(q/10.) -1.;                // displacement\n    vec3 N = 2.* divfreenoise(q/10.);\n    q += .5*N;\n    float f = ( 1.2*noise(q/2.+ .1*iTime).x -.2 ) // source noise\n              * smoothstep(1.,.8,length(q)/2.);   // source sphere\n\n    f*= smoothstep(.1,.2,abs(p.x));               // empty slice (derivable ) \n    z = length(q)/2.;                             // depth in sphere\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), BR );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > BR ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 col = exp(- vec3(3,3,2) *(1.-z));     // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));  // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = max( dot(sundir,rd), 0. );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 599, 628, 667, 1026], [1062, 1093, 1113, 1113, 1570], [2081, 2081, 2114, 2173, 2370], [2372, 2372, 2431, 2431, 2579], [2581, 2581, 2638, 2638, 4879], [4881, 4881, 4927, 4927, 5089], [5091, 5091, 5134, 5158, 5610], [5612, 5612, 5650, 5650, 6199]], "test": "untested"}
{"id": "wstyzl", "name": "hypertextures", "author": "FabriceNeyret2", "description": "using random 3D displacement  to pull \"hairs from a simple distribution ( here, random too ).\n( inspired by [url]https://mrl.nyu.edu/~perlin/doc/hypertexture/[/url] )\n\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 40, "viewed": 1080, "published": 3, "date": "1601568808", "time_retrieved": "2024-07-30T20:42:29.158323", "image_code": "// variant of https://shadertoy.com/view/tsdcRj\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define noise(x) texture(iChannel0,x )\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\nfloat z;\nfloat map(vec3 p )  // bounding sphere (0,0,0), 2.\n{\n    vec3 q = p;\n    vec3 N = 2.* noise(q/10.+.0*iTime).xyz -1.;   // displacement\n    q += .5*N;\n    float f = ( 1.2*noise(q/2.+ .1*iTime).x -.2 ) // source noise\n              * smoothstep(1.,.8,length(q)/2.);   // source sphere\n\n    f*= smoothstep(.1,.2,abs(p.x));               // empty slice (derivable ) \n    z = length(q)/2.;                             // depth in sphere\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), 2.);\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > 2. ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://iquilezles.org/articles/derivative\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 col = exp(- vec3(3,3,2) *(1.-z));     // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));  // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = max( dot(sundir,rd), 0. );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 591, 591, 1010], [1521, 1521, 1554, 1613, 1810], [1812, 1812, 1871, 1871, 2019], [2021, 2021, 2078, 2078, 4318], [4320, 4320, 4366, 4366, 4528], [4530, 4530, 4573, 4597, 5049], [5051, 5051, 5089, 5089, 5638]], "test": "untested"}
{"id": "3sdczs", "name": "surface tension phase shift osci", "author": "xenn", "description": "SPACE to restart\n\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 21, "viewed": 836, "published": 3, "date": "1601554121", "time_retrieved": "2024-07-30T20:42:30.315230", "image_code": "// Fork of \"Slime mold advection\" by michael0884. https://shadertoy.com/view/3tjfzh\n// 2020-10-01 10:52:06\n\n// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap iChannel3\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 2.56\n#define RAD R.x*01.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 3.7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 25\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 01.07\n\n\n\n#define sense_num 22\n#define sense_ang 0.27511\n//#define sense_dis 12.0*(010.51*cos(iTime*0.51))\n#define sense_dis 4.40*(020.0*cos(iTime*0.1))\n#define sense_oscil 00.1\n#define oscil_scale 0.51*(01.1*cos(iTime*0.1))\n#define oscil_pow 01.0\n#define sense_force 0.2*(010.1*cos(iTime*0.51))\n#define distance_scale 00.51*(0.51*cos(iTime*0.951))\n#define force_scale 01.51\n#define trailing 0.\n#define acceleration 0.09\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.01;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 585, 585, 763], [804, 804, 835, 835, 869], [871, 871, 923, 923, 1042], [1044, 1044, 1079, 1079, 1103], [1105, 1105, 1136, 1136, 1223], [1225, 1225, 1246, 1246, 1339], [1341, 1341, 1363, 1363, 1459], [1462, 1462, 1482, 1482, 1677], [1680, 1680, 1715, 1715, 1900], [1939, 1939, 1971, 1971, 2139], [2141, 2141, 2186, 2186, 4976]], "test": "untested"}
{"id": "Wddyzs", "name": "Snakeskin Oil Slick", "author": "xenn", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 18, "viewed": 612, "published": 3, "date": "1601549725", "time_retrieved": "2024-07-30T20:42:31.289624", "image_code": "// Fork of \"Slime mold advection\" by michael0884. https://shadertoy.com/view/3tjfzh\n// 2020-10-01 10:52:06\n\n// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 2.56\n#define RAD R.x*01.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 5.7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.4\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 12\n#define sense_ang 0.511\n//#define sense_dis 12.0*(010.51*cos(iTime*0.51))\n#define sense_dis 150.0*(01.51*cos(iTime*0.51))\n#define sense_oscil 0.1\n#define oscil_scale 0.01\n#define oscil_pow 01.\n#define sense_force 0.2\n#define distance_scale 01.1\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.09\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wddyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 575, 575, 753], [794, 794, 825, 825, 859], [861, 861, 913, 913, 1032], [1034, 1034, 1069, 1069, 1093], [1095, 1095, 1126, 1126, 1213], [1215, 1215, 1236, 1236, 1329], [1331, 1331, 1353, 1353, 1449], [1452, 1452, 1472, 1472, 1667], [1670, 1670, 1705, 1705, 1890], [1929, 1929, 1961, 1961, 2129], [2131, 2131, 2176, 2176, 4966]], "test": "untested"}
{"id": "tdtyzj", "name": "Single Sample Tricubic Sampling", "author": "TinyTexel", "description": "This demos a 3d variant of \"Single Sample Bicubic Sampling\" https://www.shadertoy.com/view/wtByDt.\ncamera controls via mouse + shift key", "tags": ["noise", "volume", "clouds", "volumetric", "filtering", "cubic", "tricubic"], "likes": 37, "viewed": 1197, "published": 3, "date": "1601537732", "time_retrieved": "2024-07-30T20:42:32.418605", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nThis demos a 3d variant of \"Single Sample Bicubic Sampling\" https://www.shadertoy.com/view/wtByDt.\n\nThe direct generalization from 2d to 3d of the bicubic sampling routine would require two samples since in 3d we need 7 partial derivatives\nto fully parametrized a tricubic patch (texture1:{df/dx, df/dy, df/dz, f} + texture2:{ddf/dydz, ddf/dxdz, ddf/dxdy, dddf/dxdydz}).\n\nTo keep the number of required trilinear lookups at one we simply ignore the 2nd and 3rd order partial derivatives here (i.e texture2).\nWhile doing so leads to obvious artifacts when rendering hard surfaces the loss in quality is usually barely noticeable in the case of (fluffy) volumes.\nIt also doesn't appear to be necessary to ensure C2 continuity to prevent artifacts in the lighting when rendering volumes.\nThis is actually a major advantage as that means that the derivatives can hold additional information thereby increasing the fidelity of the reconstruction.\nThis is not the case when the derivatives are computed from the function samples (as is necessary when one wants to ensure C2 continuity).\nIn the optimal case directly sampling the derivatives from the contiuous function alongside the function value increases the effective sampling resolution\nby a factor of 2 in each dimension (btw. on a grid of value + derivative samples a perfectly band-limited signal is reconstructed using sinc^2 instead of sinc). \nSince we throw out the 2nd and 3rd order partial derivatives here we loose a chunk of resolution in the diagonal directions but it is still a significant win.\n\nCommon   - settings (SAMPLE_TRILINEARLY, COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES, VOLUME_RES)\nBuffer D - camera controls\nBuffer A - render noise to flattened render target\nBuffer B - compute derivatives from value samples (optional)\nImage    - rendering\n\ncamera controls via mouse + shift key\n\nRelated:\n\n- https://www.shadertoy.com/view/3tfBzX | \"Cubic Reconstruction\"            (derivation of the ground truth bicubic reconstruction scheme)\n- https://www.shadertoy.com/view/WtsBDH | \"Bicubic C2 cont. Interpolation\"  (describes a pre-filtering approach to achieve C2 continuity)\n- https://www.shadertoy.com/view/wtByDt | \"Single Sample Bicubic Sampling\"  (2d version of the sampling approach described here)\n\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n\n// emulates trilinear lookups into the flattened 3d render target; in a practical setup one would use a proper volume render target\nvec4 SampleVolTexTrilinearly(sampler2D channel, vec3 tc)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n    \n    vec3 uvw = tc * float(res);\n   \n   #if 1\n    uvw = clamp(uvw, 0.5, float(res) - 0.5);\n   #else\n    vec4 border = vec4(0.0, 0.0, 0.0, 16.0);\n   \n    if(uvw.x < 0.5 || uvw.x > float(res) - 0.5) return border;\n    if(uvw.y < 0.5 || uvw.y > float(res) - 0.5) return border;\n    if(uvw.z < 0.5 || uvw.z > float(res) - 0.5) return border;\n   #endif\n    \n    uvw.z -= 0.5;\n    \n    uint zI = uint(uvw.z);\n    float zF = uvw.z - float(zI);\n    \n    vec2 zuv = vec2(zI % layersH, zI / layersH);\n    \n    vec2 uvA = uvw.xy + zuv * float(res);\n    \n    bool cond = zuv.x == float(layersH) - 1.0;\n    vec2 uvB = uvw.xy + vec2(cond ? 0.0 : zuv.x + 1.0,\n                             cond ? zuv.y + 1.0 : zuv.y) * float(res);\n    \n    vec4 sA = textureLod(channel, uvA / iResolution.xy, 0.0);\n    vec4 sB = textureLod(channel, uvB / iResolution.xy, 0.0);\n    \n    return mix(sA, sB, zF);\n}\n\n// this is where the magic happens\nfloat SampleVolTexTricubically(sampler2D channel, vec3 tc)\n{\n    vec3 uvw = tc * float(VOLUME_RES) - 0.5;\n    \n    vec3 uvwi = floor(uvw);\n    vec3 uvwf = uvw - uvwi;\n\n    vec3 mo = uvwf - uvwf*uvwf;\n\n   #if 1\n    mo = (mo * -0.5 + 1.0) * mo;// use this if it improves quality\n   #endif\n    \n    uvwf = (uvwf - mo) / (1.0 - 2.0 * mo);// map modulator to s-curve\n    \n    uvw = uvwi + uvwf + vec3(0.5);\n\n    vec4 v = SampleVolTexTrilinearly(channel, uvw / float(VOLUME_RES));// replace this with native trilinear lookup\n    \n    mo *= fract(uvwi * 0.5) * 4.0 - 1.0;// flip modulator bump on every 2nd interval\n    \n    return dot(v, vec4(mo, 1.0));\n}\n\n\n// p [-0.5, 0.5]\nfloat Map(vec3 p)\n{\n    vec3 tc = p + 0.5;\n    \n  #ifdef COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES\n    #define CHANNEL iChannel2\n  #else\n    #define CHANNEL iChannel1\n  #endif\n    \n  #ifdef SAMPLE_TRILINEARLY\n    float r = SampleVolTexTrilinearly(iChannel1, tc).w;\n  #else\n    float r = SampleVolTexTricubically(CHANNEL, tc);\n  #endif\n    \n    return r;\n}\n\nvec4 RaymarchVolume(vec3 rp, vec3 rd, uvec2 uv, vec3 light)\n{\n    float toff;\n    {\n    \tuvec2 uv2 = uv + WellonsHash(floatBitsToUint(iTime), 0u).xy;\n    \tvec4 bnoise = texelFetch(iChannel3, ivec2(uv2 % 1024u), 0);\n    \n    \ttoff = bnoise.x - 0.5;\n    }\n    \n    vec3 p; float intervalLen;\n    {\n        float hsize = 0.5;\n        //hsize -= 1.0/float(VOLUME_RES);\n        \n\t\tvec2 tt;\n\t\tif(Intersect_Ray_Cube(rp, rd, vec3(0.0), vec3(hsize), tt) != 1.0) return vec4(vec3(0.0), 1.0);\n        \n    \tbool inside = tt.y < 0.0;\n            \n    \tp = inside ? rp : rp + rd * tt.x;\n            \n    \t//p += rd * 0.001;\n\n    \tintervalLen = inside ? tt.x : tt.y - tt.x;\n    }\n    \n    float stepSize  = 1.0/64.0;\n    float stepCount = ceil(min(intervalLen, 2.0) / stepSize);\n          //stepSize  = intervalLen / stepCount;\n    \n    float sigma = 0.0;// scattering coefficient\n    float tau   = 0.0;// optical depth\n    float T     = 1.0;// transmittance\n    \n    float r = 0.0;\n\tfloat t = 0.0;\n    \n    for(float i = 0.0; i < stepCount; ++i)\n    {\n        vec3 p0 = p + rd * (t + toff * stepSize);\t\t\t\t\n\n        float f = Map(p0);\n\n        if(f > 0.0)\n        {\n           #if 0\n        \tt += max(stepSize, f);// use this if f is a distance bound\n           #else\n            t += stepSize;\n           #endif\n            \n            sigma = 0.0;\n        }\n        else\n        {\n            //float sigma0 = sigma;\n            sigma  = -f * (1024.0*1.0);\n\t\t\t//float sigma2 = (sigma0 + sigma) * 0.5;// some basic filtering\n\n            float rad  = 1.0 - exp2(-sigma * 0.04);// limb darkening / cheap multi scatter approx\n                  rad *= 1.0 - Pow2(cubic(1.0-clamp01(p0.y + 0.5)));// vertical gradient\n\n            tau += sigma * stepSize;\n                        \n            float T0 = T;\n            T = exp2(-tau);\n                        \n            float prob = T0 - T;// scattering probability for current step (assuming constant sigma)\n            \n            r += rad * prob;\n            t += stepSize;\n        }\n        \n        if(t > intervalLen || T < 0.01) break;\n    }\n    \n    return vec4(vec3(r), T);\n}\n\n\n\n#define VarTex iChannel0\n#define OutChannel w\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n\n    int I = 0;\n    vec4 iMouse     = ReadVar4(I++, 0);\n    vec4 mouseAccu  = ReadVar4(I++, 0);\n    vec4 wasdAccu   = ReadVar4(I++, 0);\n    float frameAccu = ReadVar (I++, 0);\n    \n    vec2 lightAng = vec2(Pi * 0.6, Pi * 0.2);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(Pi * -0.4, -Pi * 0.2);\n    ang += mouseAccu.xy * 0.008;\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(-0.2 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n\n    float focalLen = 0.7;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    float txlSize = 1.0 / iResolution.x * 2.0;\n    vec2 tc = uv0.xy * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n   \n\n    vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n    \n    col = vec3(0.0119);\n    \n    #if 1\n    // background pattern\n    {\n        bvec2 a = bvec2(rd.y > 0.0, abs(rd.y) > 0.8);\n        \n        bool b = (rd.x > 0.0) != (rd.z > 0.0); \n        \n        col = b != a.y ? col * (a.x ? 1.0 : 0.75) : col * (a.x ? 1.5 : 1.0);\n    }\n   #endif\n    \n    // ray marching\n    {\n    \tvec4 c = RaymarchVolume(cpos, rd, uvec2(uv), light);\n        \n        col = col * c.w + c.rgb;\n    }\n    \n\toutCol = vec4(sRGB_EOTF(clamp01(col)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* state presistence / camera controls */\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    \n    //if(uv.y > 5.0) return;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    float knobVal       = ReadVar (I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(knobVal,       J);\n\n    WriteVar2(iMouseClick,  J);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* render noise to flattened render target */\n\n\n// https://www.shadertoy.com/view/wd3czs\nfloat Noise(sampler3D channel, vec3 uvw, float time)\n{\n    vec4 p4 = uvw.x * vec4(-0.5,-0.5, 0.5, 0.5) +\n              uvw.y * vec4( 0.5,-0.5,-0.5, 0.5) +\n              uvw.z * vec4(-0.5, 0.5,-0.5, 0.5);\n    \n    p4 += time;\n    \n    vec4 ip = floor(p4);\n    vec4 fp = p4 - ip;\n\n   #if 1\n    fp = (fp * fp * fp) * (10.0 + fp * (-15.0 + 6.0 * fp));\n   #else\n    fp = fp * fp * (3.0 - 2.0 * fp);\n   #endif\n\n\tconst float pi = 3.14159265359;\n    const float texDim = 32.0;\n    const float txlDim = 1.0 / texDim;\n    const vec3 phi = vec3(27.0, 21.0, 17.0);\n    const float o0 =        0.5  * txlDim;\n    const vec3  o1 = (phi + 0.5) * txlDim;\n\n    vec3 p3 = phi * ip.w + (ip.xyz + fp.xyz);\n    \n    vec4 n = mix(textureLod(channel, p3 * txlDim + o0, 0.0), \n                 textureLod(channel, p3 * txlDim + o1, 0.0), fp.w) * 2.0 - 1.0;\n\n    ///return dot(n, sin(p4 * pi)) / pi;\n    return dot(n, cos(p4 * pi)) / pi;// cos looks better here\n}\n\nvec4 Noise2(sampler3D channel, vec3 uvw, float time)\n{\n    vec4 p4 = uvw.x * vec4(-0.5,-0.5, 0.5, 0.5) +\n              uvw.y * vec4( 0.5,-0.5,-0.5, 0.5) +\n              uvw.z * vec4(-0.5, 0.5,-0.5, 0.5);\n    \n    p4 += time;\n    \n    vec4 ip = floor(p4);\n    vec4 fp = p4 - ip;\n\n   #if 1\n    fp = (fp * fp * fp) * (10.0 + fp * (-15.0 + 6.0 * fp));\n   #else\n    fp = fp * fp * (3.0 - 2.0 * fp);\n   #endif\n\n\tconst float pi = 3.14159265359;\n    const float texDim = 32.0;\n    const float txlDim = 1.0 / texDim;\n    const vec3 phi = vec3(27.0, 21.0, 17.0);\n    const float o0 =        0.5  * txlDim;\n    const vec3  o1 = (phi + 0.5) * txlDim;\n\n    vec3 p3 = phi * ip.w + (ip.xyz + fp.xyz);\n    \n    vec4 n = mix(textureLod(channel, p3 * txlDim + o0, 0.0), \n                 textureLod(channel, p3 * txlDim + o1, 0.0), fp.w) * 2.0 - 1.0;\n\n    return n;\n}\n\nfloat Map(vec3 p)\n{\n    //return length(p) - 0.45;\n    \n    float time = float(iTime) * (0.125*0.75);\n    \n    vec3 n = Noise2(iChannel3, p * 4.0 - vec3(0.0, 1.0, 0.0)*time*1.8, time*0.4).xyz * 0.5;\n    \n    float r = 0.0;\n    r += Noise(iChannel3, p *  4.0 + vec3( 1.0, 0.0,  1.0)*time*1.0+n, time*0.5)*1.0;\n    r += Noise(iChannel3, p * 12.0 + vec3(-1.0, 0.0,  1.0)*time*2.0+n, time    )*0.75;\n    r += Noise(iChannel3, p * 32.0 + vec3( 0.0, 1.0, -1.0)*time*4.0+n, time*2.0)*0.5;\n    \n   #if VOLUME_RES == 64u\n    r += Noise(iChannel3, p * 64.0 + vec3( 1.0, -1.0, 0.0)*time*8.0+n, time*1.5)*0.25;\n    r /= 1.0+0.75+0.5+0.25;\n   #else\n    r /= 1.0+0.75+0.5;\n   #endif\n    \n    r += p.y * 0.5;\n    \n    {\n    \tvec3 p2 = p * 2.0;\n    \t\n    \tvec3 m = max(vec3(0.0), 1.0 - p2 * p2);\n    \tr = mix(r, 1.0, min(pow(1.0 - m.x*m.y*m.z, 32.0), 1.0));\n    }\n    \n    return r;\n}\n\n\nuvec3 UVWFromUV(uvec2 uv)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n\n    uvec2 uvF = uv % res;\n    uvec2 uvI = uv / res;\n\n    uvec3 uvw = uvec3(uvF, uvI.x + uvI.y * layersH);\n\n    if(uv.x >= res * layersH || uvw.z >= res)\n    {\n        discard;\n    }\n\n    return uvw;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n    uvec2 uv = uvec2(uv0 - 0.5);\n\n    uvec3 uvw = UVWFromUV(uv);\n\n    vec3 tc = vec3(uvw)/float(VOLUME_RES) + 0.5/float(VOLUME_RES);\n    \n    vec3 p = tc - 0.5;// [-0.5, 0.5]\n    \n    float v = 0.0;\n    \n   #ifdef SAMPLE_TRILINEARLY  \n    col = vec4(0.0, 0.0, 0.0, Map(p));\n    return;\n   #endif\n    \n   #ifdef COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES  \n    \n    col = vec4(0.0, 0.0, 0.0, Map(p));\n\t\n   #else\n    \n    col = vec4(0.0);\n    \n    float o = 1.0/float(VOLUME_RES*4u);\n    //float o = 1.0/1024.0;\n    #define ZERO (min(iTime, 0.0)) \n    vec3 e = vec3(1.0);\n\n    // https://iquilezles.org/articles/normalsSDF\n    for(float i = ZERO; i < 4.0; ++i)\n    {\n        float f = Map(p + e * o);\n        \n   \t\tcol.xyz += e * f;\n        col.w   +=     f;\n        \n        e = vec3(e.z, -e.yx);  \n    }\n    \n    col.xyz /= o * 4.0;\n    col.w   /=     4.0;\n    \n    if((uvw.x & 1u) == 0u) { col.x = -col.x; }\n    if((uvw.y & 1u) == 0u) { col.y = -col.y; }\n    if((uvw.z & 1u) == 0u) { col.z = -col.z; }\n    \n    col.xyz /= float(VOLUME_RES);\n    \n   #endif\n}\n\n\n\n\n/*\n\n    float o = 1.0/float(VOLUME_RES*4u);\n    //float o = 1.0/1024.0;\n    \n    float vx0 = Map(p - o * vec3(1.0, 0.0, 0.0));\n    float vx1 = Map(p + o * vec3(1.0, 0.0, 0.0));\n    \n    float vy0 = Map(p - o * vec3(0.0, 1.0, 0.0));\n    float vy1 = Map(p + o * vec3(0.0, 1.0, 0.0));\n    \n    float vz0 = Map(p - o * vec3(0.0, 0.0, 1.0));\n    float vz1 = Map(p + o * vec3(0.0, 0.0, 1.0));\n    \n    col = vec4(vec3(vx1 - vx0,\n                    vy1 - vy0,\n                    vz1 - vz0) / (2.0 * o), (vx0 + vx1 + vy0 + vy1 + vz0 + vz1) / 6.0);\n    \n    if((uvw.x & 1u) == 0u) { col.x = -col.x; }\n    if((uvw.y & 1u) == 0u) { col.y = -col.y; }\n    if((uvw.z & 1u) == 0u) { col.z = -col.z; }\n    \n    col.xyz /= float(VOLUME_RES);\n\nfloat Worley(vec3 x, uint seed)\n{\n\tvec3 ix = floor(x);\n\tvec3 fx = x - ix;\n    \n    float res = 1024.0;\n    \n\tfor (float i = 0.0; i < 3.0; ++i)\n\tfor (float j = 0.0; j < 3.0; ++j)\n\tfor (float k = 0.0; k < 3.0; ++k)\n\t{\n\t\tvec3 v = vec3(i, j, k);\n\t\tvec3 c = v - 0.5;\n\t\tvec3 vp = v + ix;\n        \n\t\tvec3 off = normalize(PhiHash11(vp, seed).xyz);\n        \n        c += off * 0.4;\n\n\t\tfloat d2 = dot(fx - c, fx - c);\n\n        res = min(res, d2);\n        \n\t}\n\n    return res;\n}\n\nfloat  ilerp(float  a, float  b, float  y) { return (y - a) / (b - a); }\nfloat  ilerp2(const float  a, const float  b, float  y) { return y * (1.0 / (b - a)) + (-a / (b - a)); }\n\nfloat WorleyE2(vec3 x, uint seed)\n{\n\tvec3 ix = floor(x);\n\tvec3 fx = x - ix;\n    \n    float res = 0.0;\n\tfor (float i = 0.0; i < 3.0; ++i)\n\tfor (float j = 0.0; j < 3.0; ++j)\n\tfor (float k = 0.0; k < 3.0; ++k)\n\t{\n\t\tvec3 v = vec3(i, j, k);\n\t\tvec3 c = v - 0.5;\n\t\tvec3 vp = v + ix;\n        \n\t\tvec3 off = normalize(PhiHash11(vp, seed).xyz);\n        \n        c += off * 0.4;\n\n\t\tfloat l = (1.0 - 0.64 * dot(fx - c, fx - c));\n        l = clamp(l, 0.0, 1.0);\n        \n        res += l;\n\t}\n\n    res = sqrt(res);\n\n    res = ilerp2(0.32, 2.75, res);\n    \n    return 1.0-res;\n}\n\nfloat Fbm(vec3 p)\n{\n    const float count = 4.0;\n\n    const float ang = Pi * (3.0 - sqrt(5.0));\n    const vec2 rot = vec2(cos(ang), sin(ang));\n\n    float scale = 1.0;\n    float res = 1024.0;\n    \n    uint h = 26450u;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        //float v = (Worley(p, h)-0.) / (scale*scale);\n        float r = 0.4/scale;\n        float v = sqrt(Worley(p, h)-0.) / (scale) - r;\n        \n        if(i != 0.0) v = max(v, res-r*0.75);\n        \n        //if(i != count - 1.0)\n        res = min(res, v);\n        //else\n        //res = max(v, res);\n\n        //res = v;\n        \n        h = LCG(h);\n        \n        float s = 2.;\n        scale *= s;\n        p *= s;\n        p.xy = CmplxMul(p.xy, rot);\n        p = p.yzx;\n    }\n    \n    return res;\n}\n*/", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* compute derivatives from value samples (optional) */\n\nvec4 SampleVolTex(uvec3 uvw)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n       \n    uvec2 zuv = uvec2(uvw.z % layersH, uvw.z / layersH);\n    \n    uvec2 uv = uvw.xy + zuv * res;\n    \n\treturn texelFetch(iChannel0, ivec2(uv), 0); \n}\n\nfloat Fetch(uvec3 uvw)\n{\n   #if 1\n    if(uvw.x > 2147483647u) uvw.x = 0u;\n    if(uvw.y > 2147483647u) uvw.y = 0u;\n    if(uvw.z > 2147483647u) uvw.z = 0u;\n    \n    if(uvw.x >= VOLUME_RES) uvw.x = VOLUME_RES - 1u;\n    if(uvw.y >= VOLUME_RES) uvw.y = VOLUME_RES - 1u;\n    if(uvw.z >= VOLUME_RES) uvw.z = VOLUME_RES - 1u;\n   #else\n    float border = 2.0;\n    if(uvw.x >= VOLUME_RES) return border;\n    if(uvw.y >= VOLUME_RES) return border;\n    if(uvw.z >= VOLUME_RES) return border;\n   #endif\n    \n    return SampleVolTex(uvw).w;\n}\n\nuvec3 UVWFromUV(uvec2 uv)\n{\n    uint res = VOLUME_RES;\n    uint layersH = VOLUME_LAYERSH;\n\n    uvec2 uvF = uv % res;\n    uvec2 uvI = uv / res;\n\n    uvec3 uvw = uvec3(uvF, uvI.x + uvI.y * layersH);\n\n    if(uv.x >= res * layersH || uvw.z >= res)\n    {\n        discard;\n    }\n\n    return uvw;\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n   #ifdef SAMPLE_TRILINEARLY\n    discard;\n   #endif\n    \n   #ifndef COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES\n    discard;\n   #endif\n    \n    uvec2 uv = uvec2(uv0 - 0.5);\n    \n    uvec3 uvw = UVWFromUV(uv);\n\n    vec4 col = vec4(0.0);\n    \n   #if 1\n    \n    // C2 interpolating cubic kernel\n    float kern[12];\n    kern[0] = 0.0         ; kern[1] = -0.803848    ; kern[ 2] = 0.21539      ; kern[ 3] = -0.0577137    ; \n    kern[4] = 0.0154643   ; kern[5] = -0.00414365  ; kern[ 6] = 0.00111029   ; kern[ 7] = -0.000297501  ; \n    kern[8] = 0.0000797152; kern[9] = -0.0000213596; kern[10] = 0.00000572329; kern[11] = -0.00000153355;\n            \n    int r = 4;//3 -> 19 tabs | 4 -> 25 tabs | 5 -> 31 tabs\n\n    // d/dx\n    for(int i = -r; i <  0; ++i) col.x += Fetch(uvw + uvec3(i, 0, 0)) * kern[-i]; \n    col.w = Fetch(uvw);\n    for(int i =  1; i <= r; ++i) col.x -= Fetch(uvw + uvec3(i, 0, 0)) * kern[ i];\n    \n    // d/dy\n    for(int i = -r; i <  0; ++i) col.y += Fetch(uvw + uvec3(0, i, 0)) * kern[-i];\n    for(int i =  1; i <= r; ++i) col.y -= Fetch(uvw + uvec3(0, i, 0)) * kern[ i];\n\n    // d/dz\n    for(int i = -r; i <  0; ++i) col.z += Fetch(uvw + uvec3(0, 0, i)) * kern[-i];\n    for(int i =  1; i <= r; ++i) col.z -= Fetch(uvw + uvec3(0, 0, i)) * kern[ i];\n\n   #else\n        \n    // C2 non-interpolating cubic kernel; using these doesnt help saving tabs when we dont compute 2nd and 3rd order partial derivatives\n    float kernD0[3];\n    float kernD1[3];\n    \n    // B-spline kernel\n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n\n    int r = 1;// = 27 tabs\n    \n    #if 0\n    // add a pair of B-spline side lobes:\n    {\n    \tfloat sw = 0.25;// side lobes weight\n\n    \tkernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t\t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n        \n        r = 2;// = 125 tabs\n    }\n\t#endif\n    \n    for(int k = -r; k <= r; ++k)\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = Fetch(uvw + uvec3(i, j, k));\n        \n        int x = abs(i);\n        int y = abs(j);\n        int z = abs(k);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        float kAz = kernD0[z];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        float kBz = kernD1[z] * (k > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy * kAz, \n                        kAx * kBy * kAz, \n                        kAx * kAy * kBz,\n                        kAx * kAy * kAz);\n    }\n   #endif\n    \n    if((uvw.x & 1u) == 0u) { col.x = -col.x; }\n    if((uvw.y & 1u) == 0u) { col.y = -col.y; }\n    if((uvw.z & 1u) == 0u) { col.z = -col.z; }\n    \n    outCol = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* settings */\n\n // #define SAMPLE_TRILINEARLY\n // #define COMPUTE_DERIVATIVES_FROM_VALUE_SAMPLES\n\n#if 0\n\t#define VOLUME_RES 64u\n\t#define VOLUME_LAYERSH 11u\n#else\n\t#define VOLUME_RES 32u\n\t#define VOLUME_LAYERSH 8u\n#endif\n\n\n//=============================================================//\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n    vec2 c1 = vec2(cos(ang), sin(ang));\n    \n    return vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\n\nfloat sRGB_EOTF(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_InvEOTF(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_InvEOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n    \nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyzj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[2500, 2632, 2690, 2690, 3636], [3638, 3673, 3733, 3733, 4322], [4325, 4342, 4361, 4361, 4694], [4696, 4696, 4757, 4757, 6816], [6867, 6867, 6898, 6898, 6954], [6955, 6955, 6986, 6986, 7079], [7081, 7081, 7127, 7127, 9018]], "test": "untested"}
{"id": "WdtyRs", "name": "Digital Clock - regolf ( 610 ch)", "author": "FabriceNeyret2", "description": "regolfing 697 chars [url]https://shadertoy.com/view/MdVcRd[/url]\n\ncould it be shorter ?", "tags": ["clock", "golf", "idate"], "likes": 26, "viewed": 636, "published": 3, "date": "1601537016", "time_retrieved": "2024-07-30T20:42:33.345128", "image_code": "// regolfing 697 chars https://shadertoy.com/view/MdVcRd\n\n// starting to get a bit obfuscated...\n\n#define P(i,j,b)     vec2(.3, b ).xyxx * smoothstep(0., 9./R.y, .1 - abs(i) - abs(j) ) //\n#define C          + P(x+=.5, y+.3, s/50) + P(x, y-.3, s/50) //\n#define X(a,x,y,b) + P( a x - clamp( x, 0., .5 ), y, b&1 )   //\n#define Z(n)         D( i.n % 10 )  D( i.n / 10 )            //\n#define D(n)         X(++, x,  y,     892>>n )           \\\n                     X(, x,    y-.7, 1005>>n )           \\\n                     X(, x,    y+.7,  877>>n )           \\\n                     X(, y-.1, x+.1,  881>>n )           \\\n                     X(, y-.1, x-.6,  927>>n )           \\\n                     X(, y+.6, x+.1,  325>>n )           \\\n                     X(, y+.6, x-.6, 1019>>n )          //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = 3.* ( u+u-R ) / R.y;\n    float y = --U.y,\n          x = U.x - y * .2 - 3.;\n    ivec4 i = ivec4(iDate);  i.y++;\n    int   s = int( iDate.w * 1e2 ) % 100;\n                                                         \n    O  = Z(w    % 60) C\n         Z(w/60 % 60) C\n         Z(w/3600);\n\n    x = x/.6 - 14., y = y/.6 + .53, R *= .6;\n    O += Z(w*0+s);\n                                                         \n    x -= .8, y += 3.;\n    O += Z( z )  X(++,x,y,1)\n         Z( y )  X(++,x,y,1)\n         Z( x % 100 ) Z( x / 100 ); }                    /*\n\n\n\n\n\n\n/* // --- 627 chars\n\n#define P(i,j,b)   vec2(.3, b&1 ).xyxx * smoothstep(0., 9./R.y, .1 - abs(i) - abs(j) ) //\n#define S(x)       clamp( x, 0., .5 )                   //\n#define C        + P(x+=.5, y+.3, s/50) + P(x, y-.3, s/50) //\n#define H(b)     + P( ++x - S(x), y, b )                //\n#define X(x,y,b) + P(   x - S(x), y, b )                //\n#define Z(n)       D(n % 10)  D(n / 10)                 //\n#define D(n)                H(     892>>n )              \\\n                   X( x,    y-.7, 1005>>n )              \\\n                   X( x,    y+.7,  877>>n )              \\\n                   X( y-.1, x+.1,  881>>n )              \\\n                   X( y-.1, x-.6,  927>>n )              \\\n                   X( y+.6, x+.1,  325>>n )              \\\n                   X( y+.6, x-.6, 1019>>n )             //\n#define mainImage(O,u)                                   \\\n    vec2  R = iResolution.xy,                            \\\n          U = 3.* ( u+u-R ) / R.y;                       \\\n    float y = --U.y,                                     \\\n          x = U.x - y * .2 - 3.;                         \\\n    ivec4 i = ivec4(iDate);                              \\\n    int   t = i.w,                                       \\\n          s = int( iDate.w * 1e2 ) % 100;                \\\n                                                         \\\n    O  = Z(t    % 60) C                                  \\\n         Z(t/60 % 60) C                                  \\\n         Z(t/3600);                                      \\\n                                                         \\\n    x = x/.6 - 14., y = y/.6 + .53, R *= .6;             \\\n    O += Z(s);                                           \\\n                                                         \\\n    x -= .8, y += 3.;                                    \\\n    O += Z( i.z )      H(1)                              \\\n         Z((i.y + 1))  H(1)                              \\\n         Z( i.x % 100) Z(i.x / 100)                     /*\n\n\n\n\n\n\n/* // --- 634 chars\n\n\n#define P(i, j, b)  vec2(.2, b&1 ).xyxy * smoothstep(0., 9./R.y, .1 - abs(i) - abs(j) )\n#define S(x)        clamp( x, 0., .5)\n#define C           + P(x+=.5, y + .3, b/50) + P(x, y - .3, b/50)\n#define H(b)        + P( ++x - S(x)   , y  , b ) \n#define Y(x, y, b)  + P(  y- S(y) , x, b ) \n#define Z(n)          D(n % 10)  D(n / 10)\n\n#define D(n)            H( 892>>n)    \\\n              Y( y-.7, x, 1005>>n)    \\\n              Y( y+.7, x,  877>>n)    \\\n              Y(x+.1, y-.1,  881>>n)  \\\n              Y(x-.6, y-.1,  927>>n)  \\\n              Y(x+.1, y+.6,  325>>n)  \\\n              Y(x-.6, y+.6, 1019>>n)\n\n#define mainImage(O,u)                                   \\\n    vec2  R = iResolution.xy,                            \\\n          U = 3.* ( u+u-R ) / R.y;                       \\\n    float y = --U.y,                                     \\\n          x = U.x - y * .2 - 3.;                         \\\n    ivec4 i = ivec4(iDate);                              \\\n    int   t = i.w,                                       \\\n          b = int( iDate.w * 1e2 ) % 100;                \\\n                                                         \\\n    O  = Z(t    % 60) C                                  \\\n         Z(t/60 % 60) C                                  \\\n         Z(t/3600);                                      \\\n                                                         \\\n    x = x/.6 - 14., y = y/.6 + .53, R *= .6;             \\\n    O += Z(b);                                           \\\n                                                         \\\n    x -= .8, y += 3.;                                    \\\n    O += Z( i.z)       H(1)                              \\\n         Z((i.y + 1))  H(1)                              \\\n         Z( i.x % 100) Z(i.x / 100)                     /*\n\n\n\n\n\n\n/* // --- 652 chars\n\n#define P(i, j, b)  vec2(.2, b&1 ).xyxy * smoothstep(0., 9./R.y, .1 - abs(i) - abs(j) )\n#define S(x)        clamp( x, 0., .5)\n#define C           + P(x+=.5, y + .3, b/50) + P(x, y - .3, b/50)\n#define H(b)        + P( ++x - S(x)   , y  , b ) \n#define X(   j, b)  + P(   x - S(x)   , y-j, b ) \n#define Y(i, j, b)  + P(  y-j- S(y-j) , x-i, b ) \n#define Z(n)          D(n % 10)  D(n / 10)\n\n#define D(n)           H( 892>>n)  \\\n              X(     .7, 1005>>n)  \\\n              X(    -.7,  877>>n)  \\\n              Y(-.1, .1,  881>>n)  \\\n              Y( .6, .1,  927>>n)  \\\n              Y(-.1,-.6,  325>>n)  \\\n              Y( .6,-.6, 1019>>n)\n\n#define mainImage(O,u)                                   \\\n    vec2  R = iResolution.xy,                            \\\n          U = 3.* ( u+u-R ) / R.y;                       \\\n    float y = --U.y,                                     \\\n          x = U.x - y * .2 - 3.;                         \\\n    ivec4 i = ivec4(iDate);                              \\\n    int   t = i.w,                                       \\\n          b = int( iDate.w * 1e2 ) % 100;                \\\n                                                         \\\n    O  = Z(t    % 60) C                                  \\\n         Z(t/60 % 60) C                                  \\\n         Z(t/3600);                                      \\\n                                                         \\\n    x = x/.6 - 14., y = y/.6 + .53, R *= .6;             \\\n    O += Z(b);                                           \\\n                                                         \\\n    x -= .8, y += 3.;                                    \\\n    O += Z( i.z)       H(1)                              \\\n         Z((i.y + 1))  H(1)                              \\\n         Z( i.x % 100) Z(i.x / 100)                     /*\n\n\n\n\n\n\n/* // --- 664 chars\n\n#define P(i, j, b)  vec2(.2, b&1 ).xyxy * smoothstep(0., 9./R.y, .1 - abs(i) - abs(j) )\n//#define S(i, j, b)  P( - clamp( I=i, 0., .5) + I , j, b ) \n#define S(x)        clamp( x, 0., .5)\n#define C           O += P(x+=.5, y + .3, b/50) + P(x, y - .3, b/50); t /= 60\n#define H(b)        O += P( ++x - S(x)   , y  , b ) \n#define X(   j, b)       P(   x - S(x)   , y-j, b ) \n#define Y(i, j, b)       P(  y-j- S(y-j) , x-i, b ) \n#define Z(n)        ; D(n % 10) ; D(n / 10) ;\n\n#define D(n)           H( 892>>n)  \\\n            + X(     .7, 1005>>n)  \\\n            + X(    -.7,  877>>n)  \\\n            + Y(-.1, .1,  881>>n)  \\\n            + Y( .6, .1,  927>>n)  \\\n            + Y(-.1,-.6,  325>>n)  \\\n            + Y( .6,-.6, 1019>>n)\n\n#define mainImage(o,u)                                   \\\n    vec4  O = o;                                         \\\n    vec2  R = iResolution.xy,                            \\\n          U = 3.* ( u+u-R ) / R.y;                       \\\n    float y = --U.y,                                     \\\n          x = U.x - y * .2 - 3.;                         \\\n    ivec4 i = ivec4(iDate);                              \\\n    int   t = i.w,                                       \\\n          b = int( iDate.w * 1e2 ) % 100                 \\\n                                                         \\\n    Z(t % 60) C                                          \\\n    Z(t % 60) C                                          \\\n    Z(t)                                                 \\\n                                                         \\\n    x = x/.6 - 14., y = y/.6 + .53, R *= .6              \\\n    Z(b)                                                 \\\n                                                         \\\n    x -= .8, y += 3.                                     \\\n    Z( i.z)       H(1)                                   \\\n    Z((i.y + 1))  H(1)                                   \\\n    Z( i.x % 100) Z(i.x / 100)                           \\\n    o = O                                               /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ddyzl", "name": "Twitch.tv/vedepo", "author": "zovox", "description": "Twitch.tv/vedepo", "tags": ["twitchtvvedepo"], "likes": 6, "viewed": 314, "published": 3, "date": "1601517580", "time_retrieved": "2024-07-30T20:42:34.237742", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define DURATION 777.\n#define time ((saw(float(__LINE__)/GR)+1.0)*(saw(iTime/DURATION*2.)*DURATION)/E/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\n\nfloat smooth_floor(float x)\n{\n\treturn x;//floor(x)+smoothstep(.75, 1., fract(x));\n}\n\nvec2 tree(vec2 uv)\n{\n    \n    vec2 p = uv*2.-1.;\n    \n\t\n        float angle = smooth_floor((time))*PI/12.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 1./MAX_DIM);\n        \n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(smooth_floor(time/PI)/500., 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n    return p;\n}\n\nvec2 flower(vec2 p)\n{\n\tp *= rotate(time);\n\tfloat rots = 6.+1./MAX_DIM;\n\tfloat angle = atan(-p.y, -p.x);\n\tfloat radius = length(p);\n\tangle = floor(((angle/PI)*.5+.5)*rots);\n\n\n\tvec2 a = vec2(1., 0.);\n\tvec2 b = vec2(1., 1./MAX_DIM);\n\tvec2 c = vec2(0., 1./MAX_DIM);\n\tvec2 d = vec2(0., -1./MAX_DIM);\n\t\n\tb *= rotate(angle/rots*2.*PI);\n\tangle += 1.;\n\ta *= rotate(angle/rots*2.*PI);\n\t\n\treturn (invBilinear( p, a, b, c, d ));\n}\n\n\nfloat square(vec2 uv, vec2 uv0)\n{\n    uv = (uv*2.-1.)*GR;\n    return abs(saw(uv.y+uv0.x-uv0.y+time)-uv.x);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float r = log(length(uv)+1.)/2.;\n    float theta = atan(uv.y, uv.x)/PI-r*sin(time/E/PI/GR)/PI;\n    return vec2(saw(r+time/E/E),\n                saw(theta+time/GR/E))*2.-1.;\n}\n\nvec3 phase(float map)\n{\n    return vec3(sin(map),\n                sin(4.0*PI/3.0+map),\n                sin(2.0*PI/3.0+map))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = uv.xy*2.-1.;\n    uv0.x *= max(iResolution.x/iResolution.y, 1.);\n    uv0.y *= max(iResolution.y/iResolution.x, 1.);\n\tuv0 = uv0*.5+.5;\n    float map = 0.0;\n    \n    float lambda = 4.0;\n\tconst int max_iterations = 12;\n\n    float scale = 3.0*PI+(time*PI*GR*E);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv.x *= max(iResolution.x/iResolution.y, 1.);\n    uv.y *= max(iResolution.y/iResolution.x, 1.);\n    uv.xy += vec2(cos(time*.234),\n                  sin(time*.345))*scale/2.;\n\tfloat m = smoothstep(0.45, .55, saw(time/E/PI));\n    uv.xy = spiral(uv.xy*scale)*m+(1.-m)*(uv0);;\n    \n\tfloat nature = smoothstep(.025, .125, saw(time/GR/E))*(1.-m);\n\tuv =  uv*(1.-nature)+flower(uv0*2.-1.)*nature;\n\t\n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = (float(i)/(float(max_iterations) ));\n        uv.xy = saw(tree(uv.xy));\n\t\t\tmap += square(uv.xy, uv0);\n\t\tuv0 = uv;\n    }\n    \n    float w = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    float b = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    fragColor.rgb = (flux(map))*\n        \t\t\t\n        \t\t\tclamp(map, 0.0, 1.0);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 362, 362, 390], [392, 392, 412, 412, 517], [518, 518, 536, 536, 575], [577, 577, 595, 595, 644], [645, 645, 720, 720, 1692], [1695, 1695, 1717, 1717, 1765], [1768, 1768, 1797, 1797, 1851], [1853, 1853, 1873, 1873, 2846], [2848, 2848, 2869, 2869, 3266], [3269, 3269, 3302, 3302, 3377], [3380, 3380, 3402, 3402, 3581], [3583, 3583, 3606, 3606, 3715]], "test": "untested"}
{"id": "Wstyzl", "name": "seven segment display", "author": "3SvBop3F", "description": "seven segment display", "tags": ["seven"], "likes": 7, "viewed": 417, "published": 3, "date": "1601517078", "time_retrieved": "2024-07-30T20:42:35.053560", "image_code": "// port of:  https://www.shadertoy.com/view/MdVcRd\n//\n// I expanded this code in an effort to understand how it worked\n// how its drew segments, how it layed out graphic elements, etc\n// this is just the original with the preprocessor macros converted into functions\n// and some extra explorative comments\n\n\n\nvec4 manhattan_distance(float i, float j, int b, vec2 R)\n{\n    // Computes a smooth-edged diamond pixel value (Manhattan distance)\n\treturn vec2(.1, b).xyxy * smoothstep(0., 9. / R.y, .1 - abs(i) - abs(j));\n}\n\nvec4 segment_value(float i, float j, int b, vec2 R)\n{\n    // Computes a segment value (length = 0.5)\n\treturn manhattan_distance(i - clamp(i, 0., .5), j, b & 1, R);\n}\n\nvoid colon_render(float y, ivec4 i, vec2 R, inout float x, inout vec4 O, inout int t)\n{\n// Colon render\n\n    x += .5;\n    O += \n    manhattan_distance(\n        x, \n        y + .3, \n        i.w / 50, \n        R\n   ) \n   + manhattan_distance(\n       x, \n       y - .3, \n       i.w / 50, \n       R\n\t);\n    t /= 60;\n}\n\n\nvec4 s7_horrizontal(float i, float j, int b, float x, float y, vec2 R)\n{\n\t// Computes the horizontal and vertical segments based on a denary digit\n\treturn segment_value(x - i, y - j, b, R);\n}\n\nvec4 s7_vertical(float i, float j, int b, float x, float y, vec2 R)\n{\n\treturn segment_value(y - j, x - i, b, R);\n}\n\nvoid s7_segment(int n, inout vec4 O, inout float x, float y, vec2 R)\n{\n    // investigated with python:\n\t// {i: [bool((j>>i) & 1) for j in [892, 1005, 877, 881, 927, 325, 1019]] for i in range(10)}\n    ++x; \n    O += segment_value(x, y, 892>>n, R)        // (1<<2 | 1<<3 | 1<<5 | 1 << 6 | 1<<8 | 1<<9)\n                                               // 0b1101111100: true for 2,3,4,5,6,8,9\n    + s7_horrizontal(0., .7, 1005>>n, x, y, R) // 0b1111101101: true for 0,2,3,5,6,7,8,9\n    + s7_horrizontal(0., -.7, 877>>n, x, y, R) // 0b1101101101: true for 0,2,3,5,6,8,9\n    + s7_vertical(-.1, .1, 881>>n, x, y, R)    // 0b1101110001: true for 0,4,5,6,8,9\n    + s7_vertical(.6, .1, 927>>n, x, y, R)     // 0b1110011111: true for 0,1,2,3,4,7,8,9\n    + s7_vertical(-.1, -.6, 325>>n, x, y, R)   // 0b0101000101: truw for 0,2,6,8\n    + s7_vertical(.6, -.6, 1019>>n, x, y, R);  // 0b1111111011: truw for 0,1,3,4,5,6,7,8,9\n                                               //    |   |   |\n    \t\t\t\t\t\t\t\t\t\t   //    |   |   \\ zero\n                                               //    |   |  \\ one\n                                               //    |   | \\ two\n                                               //    |   |\\ three\n                                               //    |   \\ four\n                                               //    |  \\ five\n                                               //    | \\ six\n                                               //    |\\ seven\n                                               //    \\ eight\n                                               //   \\ nine\n}\n\n\nvoid two_digit_render(int n, inout vec4 O, inout float x, float y, vec2 R)\n{\n\t// Two-digit render\n    s7_segment(n % 10, O, x, y, R);\n    s7_segment(n / 10, O, x, y, R);\n}\n    \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec2 R = iResolution.xy;\n    U += U - R;\n    U /= R.y / 3.; // Global scaling with aspect ratio correction\n    O-=O; // Zero the pixel\n\n    float x = U.x - U.y * .2 - 2.8, // Slight skew to slant the digits\n          y = --U.y;\n    ivec4 i = ivec4(iDate); // Convert everything to integers\n    int t = i.w;\n    i.w = int(iDate.w * 100.) % 100; // Replace with centiseconds\n    \n    // Seconds (preceded by a colon)\n    two_digit_render(t % 60, O, x, y, R);\n    colon_render(y, i, R, x, O, t);\n    \n    // Minutes (preceded by a colon)\n    two_digit_render(t % 60, O, x, y, R);\n    colon_render(y, i, R, x, O, t);\n    \n    // Hours\n    two_digit_render(t, O, x, y, R);\n\n    // Smaller digits\n    x /= .6;\n    y /= .6;\n    R *= .6;\n\n    // Centiseconds\n    x -= 14.;\n    y += .53;\n    two_digit_render(i.w, O, x, y, R);\n\n    // Day (preceded by a hyphen)\n    x -= .8;\n    y += 3.;\n    two_digit_render(i.z, O, x, y, R);\n    ++x; O += segment_value(x, y, 1, R);\n\n    // Month (preceded by a hyphen)\n    two_digit_render((i.y + 1), O, x, y, R); // Is it a bug in shadertoy that we have to add one?\n    ++x; O += segment_value(x, y, 1, R);\n\n\t// Year\n    two_digit_render(i.x % 100, O, x, y, R);\n    two_digit_render(i.x / 100, O, x, y, R);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wstyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 367, 439, 516], [518, 518, 571, 618, 683], [685, 685, 772, 788, 998], [1001, 1001, 1073, 1147, 1192], [1194, 1194, 1263, 1263, 1308], [1310, 1310, 1380, 1507, 2890], [2893, 2893, 2969, 2990, 3064], [3071, 3071, 3107, 3107, 4348]], "test": "untested"}
{"id": "3sdcRl", "name": "Spidron Hexagon", "author": "timeisbeautifulhere", "description": "So I herd you like regular geometry.\n\nCode is a bloody mess but I finally got my beautiful Spidron Hexagon going.\n\nMight add fun colors later.", "tags": ["triangle", "spiral", "hexagon", "regular", "spidron"], "likes": 10, "viewed": 385, "published": 3, "date": "1601516266", "time_retrieved": "2024-07-30T20:42:35.970110", "image_code": "\n//https://en.wikipedia.org/wiki/Spidron#/media/File:Spidron_Hexagon.JPG\n\n//No fun constants to play with, sorry :(\n#define PI 3.14159\n#define START_CIRCUMRADIUS 3.0\n\n#define LINE_WIDTH 0.005\n\n#define RAD(deg) (deg*PI/180.0)\n\n#define TIME_CONST 1.5\n\n//Magic numbers for identifying points on/in triangles\n#define ON_TRIANGLE 123\n#define NOT_IN_TRIANGLE -1\n\nfloat THIRTY = RAD(30.0);\nfloat SIXTY = RAD(60.0);\n\n//Find closest point on a line segment, given a point p3.\n//Then compute whether it is \"on\" the line by computing\n//distance from the segment.\n//Thank you Paul Bourke http://paulbourke.net/geometry/pointlineplane/\nbool on_segment(vec2 p1, vec2 p2, vec2 p3, float thickness){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    //Check within bounds of segment\n    if(u<0.0||u>1.0)\n        return false;\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\treturn distance(point_on_line, p3)<=thickness;\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nbool in_triangle(vec2 p1, vec2 p2, vec2 p3, vec2 uv){\n    \n    //Delicious math\n    float l1 =\n        ((p2.y-p3.y)*(uv.x-p3.x)+(p3.x-p2.x)*(uv.y-p3.y))/\n        ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n    \n    float l2 = \n        ((p3.y-p1.y)*(uv.x-p3.x)+(p1.x-p3.x)*(uv.y-p3.y))/\n        ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n    \n    float l3 = 1.0 - l1 - l2;\n    \n    return l1>=0. && l1<=1. &&\n        l2>=0. && l2<=1. &&\n        l3>=0. && l3<=1.;\n}\n\n//Cross product to see if point is on left side of segment\n//https://stackoverflow.com/a/3461533\nbool isLeft(vec2 p1, vec2 p2, vec2 p3){\n     return ((p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)) > 0.0;\n}\n\n//Return kth point of hexagon by rotating\n//it along the circumradius\nvec2 hex_point(int k, float radius, float rotation){\n    \n    float deg = float(k)*SIXTY + rotation;\n    \n    float x = -1.0*cos(deg) - 0.0*sin(deg),\n        y = -1.0*sin(deg) - 0.0*cos(deg);\n    \n    return vec2(\n        x*radius,\n        y*radius\n    );\n}\n\n//Find closest hex point uv would be near by\n//calculating its rotation.\n//ie, if uv was 60 degrees from origin, it'd be at the\n//second hexagon point.\nint hex_point_n(vec2 uv, float rotation){\n    float point_rads = atan(uv.y,uv.x) + PI - rotation;\n    point_rads = mod(point_rads, 2.0*PI);\n    \n    return int(round(point_rads/SIXTY));\n}\n\n//hex_point_n, but floor instead of round\nint prev_hex_point_n(vec2 uv, float rotation){\n    float point_rads = atan(uv.y,uv.x) + PI - rotation;\n    point_rads = mod(point_rads, 2.0*PI);\n    \n    return int(floor(point_rads/SIXTY));\n}\n\n\n//Circumradius of nth hexagon in spidron hexagon.\nfloat circumradius_n(float circumradius, int n){\n    float R = circumradius;\n    \n    //Size of subsequent hexagons is a geometric series\n    //derived from the difference of the inradius and the\n    //height of the isosceles triangle touching the outer hexagon.\n    //Math simplified into a constant.\n    \n    float series_const = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    return R * pow(series_const, float(n));\n}\n\n//Circumradius of next hexagon in spidron hexagon\nfloat next_circumradius(float circumradius){\n    float R = circumradius;\n    float series_const = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    return R * series_const;\n}\n\n//Find closest hexagon a point would be near\nint closest_hex(vec2 uv, float start_radius){\n    \n    //Treating circumradius of hexagons as a \n    //geometric series x=aq^n, find n using logs\n    //https://math.stackexchange.com/a/447670\n    float x = length(uv),\n        a = start_radius,\n        q = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    float n = (log(x) - log(a))/log(q);\n    \n    int hex_num = int(floor(n));\n    \n    //Found the correct circumradius we're in,\n    //now check if it's outside the hexagon bounds\n    \n    //Get points of closest hex edge\n    float rotation=0.0;\n    if(hex_num%2==1)\n        rotation = THIRTY;\n    float circumradius = circumradius_n(start_radius,hex_num);\n    int hex_k = prev_hex_point_n(uv, rotation);\n    vec2 p1 = hex_point(hex_k, circumradius, rotation),\n        p2 = hex_point(hex_k+1, circumradius, rotation);\n    \n    //If it's outside, this belongs to the\n    //previous outer hexagon\n    if(!isLeft(p1,p2,uv))\n       hex_num -= 1;\n    \n    return hex_num;\n}\n\n//Determine if uv is on a hexagon edges for a given circumradius\nbool on_hex(vec2 uv, float circumradius, float rotation){\n    \n    int p1_k = prev_hex_point_n(uv, rotation);\n    \n    vec2 p1=hex_point(p1_k%6, circumradius, rotation),\n        p2=hex_point((p1_k+1)%6, circumradius, rotation);\n    \n    return on_segment(p1,p2,uv, LINE_WIDTH);\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint in_equilateral(vec2 uv, float circumradius, float rotation){\n    \n    //Points of closest equilateral can be derived from current\n    //and \"next\" (smaller) hexagon.\n    //Points are are hex point n of cur hexagon,\n    //n-1 of next hexagon, and n of next hexagon\n    \n    float next_radius = next_circumradius(circumradius);\n    float next_rotation = mod(rotation + THIRTY, 2.0*PI);\n    if(next_rotation<0.0)\n        next_rotation+= 2.0*PI;\n    \n    int cur_n = hex_point_n(uv, rotation),\n        next_n = cur_n;\n    \n    vec2 p1 = hex_point(cur_n, circumradius, rotation),\n        p2 = hex_point(next_n-1, next_radius, next_rotation),\n        p3 = hex_point(next_n, next_radius, next_rotation);\n    \n    if(in_triangle(p1,p2,p3,uv))\n        return cur_n%6;\n    \n    if(on_segment(p1,p2,uv,LINE_WIDTH) ||\n        on_segment(p2,p3,uv,LINE_WIDTH) ||\n        on_segment(p3,p1,uv,LINE_WIDTH))\n        return ON_TRIANGLE;\n    \n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an isosceles triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint in_isosceles(vec2 uv, float circumradius, float rotation){\n    \n    //Points of closest isosceles can be derived from current\n    //and \"next\" (smaller) hexagon.\n    //Points are are hex point n of cur hexagon,\n    //n+1 of cur hexagon, and n of next hexagon\n    \n    float next_radius = next_circumradius(circumradius);\n    float next_rotation = mod(rotation + THIRTY, 2.0*PI);\n    if(next_rotation<0.0)\n        next_rotation+= 2.0*PI;\n    \n    int cur_n = prev_hex_point_n(uv, rotation),\n        next_n = cur_n;\n    \n    vec2 p1 = hex_point(cur_n, circumradius, rotation),\n        p2 = hex_point(cur_n+1, circumradius, rotation),\n        p3 = hex_point(next_n, next_radius, next_rotation);\n    \n    if(in_triangle(p1,p2,p3,uv))\n        return cur_n%6;\n    \n    if(on_segment(p1,p2,uv,LINE_WIDTH) ||\n        on_segment(p2,p3,uv,LINE_WIDTH) ||\n        on_segment(p2,p1,uv,LINE_WIDTH))\n        return ON_TRIANGLE;\n    \n    return NOT_IN_TRIANGLE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-1,1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //Treat start_radius as a geometric series (x=aq^n)\n    //and linearly \"expand\" spidron by scaling n\n    float a = START_CIRCUMRADIUS,\n        q = (cos(THIRTY) - (tan(THIRTY)/2.0)),\n        n = -(iTime*TIME_CONST);\n    \n    //Loop it to avoid large numbers.\n    if(n<12.0)\n    \tn = -12.0 + mod(n, 12.0);\n    \n    //Start radius of first hexagon of structure\n    float start_radius = a * pow(q,n);\n\n    vec3 col = vec3(1.0);\n    \n    //Find which hexagon we're in\n    int closest = closest_hex(uv, start_radius);\n    float circumradius = circumradius_n(start_radius, closest);\n    float rotation = 0.0;\n    if(closest%2==1)\n        rotation = THIRTY;\n    \n    //Check if/which \"stripe\" we're in\n    //by checking if we're in any triangles\n    int on_stripe = -1;\n    \n    int eq_check = in_equilateral(uv, circumradius, rotation);\n    if(eq_check != NOT_IN_TRIANGLE && eq_check != ON_TRIANGLE){\n        on_stripe = eq_check;\n    }\n    \n    int iso_check = in_isosceles(uv, circumradius, rotation);\n    if(iso_check != NOT_IN_TRIANGLE && iso_check != ON_TRIANGLE){\n        on_stripe = iso_check;\n    }\n    \n    //Color\n    if(on_stripe != -1){\n        if(rotation>0.0)\n            on_stripe+=1;\n        on_stripe+=closest/2;\n        on_stripe%=6;\n        \n        float val = float(on_stripe)/6.0;\n        if(on_stripe%2==0){\n        \tcol=vec3(val,0.0,val);\n        }\n        else{\n            col=vec3(0.0,val,val);\n        }\n    }\n    \n    //Lines\n    if(eq_check == ON_TRIANGLE || on_hex(uv, circumradius, rotation))\n        col=vec3(1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdcRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 623, 683, 683, 1059], [1061, 1235, 1288, 1314, 1713], [1715, 1812, 1851, 1851, 1932], [1934, 2004, 2056, 2056, 2261], [2263, 2415, 2456, 2456, 2602], [2604, 2646, 2692, 2692, 2838], [2841, 2891, 2939, 2939, 3308], [3310, 3360, 3404, 3404, 3528], [3530, 3575, 3620, 3766, 4540], [4542, 4607, 4664, 4664, 4886], [4888, 5071, 5135, 5338, 6027], [6029, 6210, 6272, 6472, 7161], [7163, 7163, 7220, 7234, 8902]], "test": "untested"}
{"id": "wd3czs", "name": "animated fast 3d Gradient Noise", "author": "TinyTexel", "description": "left: 2d slice | right: sampled on a sphere\ncamera controls via mouse + shift key", "tags": ["procedural", "noise", "perlin", "gradient"], "likes": 12, "viewed": 824, "published": 3, "date": "1601508456", "time_retrieved": "2024-07-30T20:42:36.866712", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nHere are the two key ideas that make this work:\n1. Sample a 3d RGBA noise texture with s-curve remapped texture coordinates and \n   modulate the result with sines oriented along the main axis + sum up the results.\n   This already gives us something that closely resembles standard Perlin noise.\n2. To get rid of the for Perlin noise characteristic axis aligned features we actually \n   construct a 4d noise function from which we sample 3d slices that are orthogonal \n   to the main diagonal (i.e. vec4(0.5)). The 4d texture lookup is emulated via \n   texture stacking of 3d textures. A nice side effect of this approach is that we can \n   now easily animate the result via a simple offset along the main diagonal.\n*/\n\nfloat Noise(sampler3D channel, vec3 uvw, float time)\n{\n    vec4 p4 = uvw.x * vec4(-0.5,-0.5, 0.5, 0.5) +\n              uvw.y * vec4( 0.5,-0.5,-0.5, 0.5) +\n              uvw.z * vec4(-0.5, 0.5,-0.5, 0.5);\n    \n    p4 += time;\n    \n    vec4 ip = floor(p4);\n    vec4 fp = p4 - ip;\n\n   #if 1\n    fp = (fp * fp * fp) * (10.0 + fp * (-15.0 + 6.0 * fp));\n   #else\n    fp = fp * fp * (3.0 - 2.0 * fp);\n   #endif\n\n\tconst float pi = 3.14159265359;\n    const float texDim = 32.0;\n    const float txlDim = 1.0 / texDim;\n    const vec3 phi = vec3(27.0, 21.0, 17.0);\n    const float o0 =        0.5  * txlDim;\n    const vec3  o1 = (phi + 0.5) * txlDim;\n\n    vec3 p3 = phi * ip.w + (ip.xyz + fp.xyz);\n    \n    vec4 n = mix(textureLod(channel, p3 * txlDim + o0, 0.0), \n                 textureLod(channel, p3 * txlDim + o1, 0.0), fp.w) * 2.0 - 1.0;\n\n    return dot(n, sin(p4 * pi)) / pi;\n}\n\n\nfloat EvalSceneCol(vec3 rp, Cam cam, vec2 uv0, bool right)\n{\n    float col = 0.0;\n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    vec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n        \n    float time = iTime * 0.5;\n    \n    if(right)// RIGHT ----------------------------------------------------------------------\n    {      \n        vec3 rd = NewRay(cam, tex21);\n    \n        vec2 t; vec3 n; vec3 a;\n        float hit = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 1.0, /*out:*/ t);\n    \n        if(hit > 0.0)\n        {\n\t\t\tvec3 p = rp + rd * t.x; \n            \n            col = Noise(iChannel3, p * 16.0, time);\n            \n            col = col*.5+.5;\n        }\n        else\n        {\n           col = 0.11;           \n        }\n    }\n    else// LEFT -----------------------------------------------------------------------------\n    { \n        col = Noise(iChannel3, vec3(uv0*0.05, 0.0), time);\n\n        col = col*.5+.5;\n    }\n\n    col = pow(clamp01(col), 2.2);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    bool right = uv.x > PixelCount.x;\n    if(right) uv.x -= PixelCount.x;\n    \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n\n    vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    \n    vec2 ang = vec2(0.0, 0.0);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(0.6 + mouseAccu.w * 0.02));\n    \n   #if 1\n    float flip = step(0.5, fract(uv.y * 0.5));\n    \n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 0.5  ), 1./6.), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 5./6.), 0.5  ), right);\n    col += EvalSceneCol(cpos, cam, uv + vec2(abs(flip - 1./6.), 5./6.), right);    \n    \n    col /= 3.0;   \n   #else\n    col = vec3(EvalSceneCol(cpos, cam, uv, right));    \n   #endif\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\n\n#define FUNC4_FLOAT(f)\t\t\t\t\t\t\t\\\nvec2 f(vec2 v) {return vec2(f(v.x ), f(v.y ));}\t\\\nvec3 f(vec3 v) {return vec3(f(v.xy), f(v.z ));}\t\\\nvec4 f(vec4 v) {return vec4(f(v.xy), f(v.zw));}\t\\\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nFUNC4_FLOAT(GammaEncode)\n    \n    \nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3czs.jpg", "access": "api", "license": "cc0-1.0", "functions": [[793, 793, 847, 847, 1666], [1669, 1669, 1729, 1729, 2693], [2696, 2696, 2744, 2744, 3927]], "test": "untested"}
