{"id": "fltGzH", "name": "Warped noise with shadows", "author": "arthehaxxor", "description": "one day i had the bright idea to color warped noise with not the value but the difference between the value at one pixel and the value at an offset from that pixel. this creates some nice shading-like effects. NGL, pretty satisfying as a screensaver", "tags": ["2d", "noise", "procedual"], "likes": 8, "viewed": 272, "published": 3, "date": "1635715544", "time_retrieved": "2024-07-30T18:51:27.464620", "image_code": "// copy from https://www.shadertoy.com/view/4l2GzW\n#define CONT 0.1\n\nfloat r(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); \n}\nfloat worley(vec2 n,float s)\n{\n    float dis = 2.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            vec2 p = floor(n/s)+vec2(x,y);\n            float d = length(r(p)+vec2(x,y)-fract(n/s));\n            if (dis>d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    return 1.0 - dis;\n\t\n}\n\n// copy from https://www.shadertoy.com/view/4sc3z2\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat noise(vec2 v) {\n    float dis = (1.0+perlin_noise(vec3(v, sin(iTime*0.15))*5.0)) \n        * (1.0+(worley(v, 32.0)+\n        0.5*worley(2.0*v,32.0) +\n        0.25*worley(4.0*v,32.0) ));\n        \n    return dis*0.25;\n}\n\nfloat frct(vec2 v) {\n    return noise((v) + noise(v - noise(v)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c =(frct(fragCoord/iResolution.xy) - frct((fragCoord+CONT)/iResolution.xy))/CONT + 0.5;\n    \n\tfragColor = vec4(vec3(abs(sqrt(c))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 87, 87, 126], [127, 127, 143, 143, 220], [221, 221, 251, 251, 569], [663, 663, 685, 685, 837], [838, 838, 866, 866, 1805], [1807, 1807, 1828, 1828, 2028], [2030, 2030, 2050, 2050, 2097], [2099, 2099, 2156, 2156, 2304]], "test": "untested"}
{"id": "stcGRH", "name": "Persian carpet 7", "author": "jarble", "description": "A Persian carpet fractal pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 3, "viewed": 323, "published": 3, "date": "1635688861", "time_retrieved": "2024-07-30T18:51:28.390146", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(1.0+c2,.5+c2,-1.5,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = 45.87+iTime/2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/2.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/4.;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((t+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = -.05;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = .7;\n            float factor1 = 8.;\n            \n            uv = -triangle_wave(uv.yx+scale,scale)+triangle_wave(uv,scale);\n            //uv.y /= .9;\n            uv.x *= factor;\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv*(1.+offset)),scale);\n            }\n            uv.x /= -factor;\n            \n            if(i>0) col = abs(col.yzx*col.x + col_prev*col.y)/(col.x-col.y);\n            \n            col[c] = fract((uv.x*(1.+col.x/factor1))-(uv.y*(col.y/factor1+1.)));\n        }\n    }\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 285, 307, 352, 485], [487, 487, 526, 526, 571], [573, 573, 630, 630, 1788]], "test": "untested"}
{"id": "Nt3GzH", "name": "[ConcoursJFIG2021] - Antibes", "author": "H4w0", "description": "Stylized rendering of the Antibes bay", "tags": ["concoursjfig2021"], "likes": 1, "viewed": 190, "published": 3, "date": "1635684555", "time_retrieved": "2024-07-30T18:51:29.436348", "image_code": "void compute_region(in vec2 uv, in vec2 offset, in float size, out vec4 mean, out vec4 stddev )\n{\n    mean = texture(iChannel1,uv+offset,size);\n    vec4 moment = texture(iChannel2,uv+offset,size);\n    vec4 variance = moment - mean*mean;\n    stddev = sqrt(variance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (fragCoord - (iResolution.xy-iResolution.y)*0.5) / iResolution.y;\n    if(U.x < 0.0 || U.x > 1.0) {fragColor.rgb = vec3(0.0); return;}\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ts = max(iResolution.x,iResolution.y);\n    \n    float size = 2.3;\n    float quad = 1.2;\n    vec4 m1, std1; compute_region(uv, vec2(-quad,-quad)/ts, size, m1, std1);\n    vec4 m2, std2; compute_region(uv, vec2(-quad,+quad)/ts, size, m2, std2);\n    vec4 m3, std3; compute_region(uv, vec2(+quad,-quad)/ts, size, m3, std3);\n    vec4 m4, std4; compute_region(uv, vec2(-quad,+quad)/ts, size, m4, std4);\n    \n    \n    vec4 minStd = std1;\n    vec4 minMean = m1;\n    \n    if(std2.a < minStd.a)\n    {\n        minStd = std2;\n        minMean = m2;\n    }\n    \n    \n    if(std3.a < minStd.a)\n    {\n        minStd = std3;\n        minMean = m3;\n    }\n    \n    \n    if(std4.a < minStd.a)\n    {\n        minStd = std4;\n        minMean = m4;\n    }\n        \n    \n    /* Pixel value is the mean value of the region with the minimal standard deviation */  \n    fragColor = vec4(minMean.rgb,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- IDs ----------------------------------------------------------------------\nconst float SKY_ID = 0.2;\nconst float SEA_ID = 0.3;\nconst float FOREGROUND_ID = 0.4;\nconst float BACKGROUND_ID_1 = 0.5;\nconst float BACKGROUND_ID_2 = 0.6;\nconst float ANTIBES_CITY_ID = 0.9;\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi_2 \t\t= 1.5707963267;  \nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */            \nconst float m_2_pi \t\t= 6.2831853071; \nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_2f    = 0.01;     \nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;     \n\n//----------------------------------------------------------------------------------\n//-- Ray ---------------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- IQ Intersection Functions ------------------------------------------------\nvec2 intersection_axis_aligned_box(in vec3 ray_origin, in vec3 ray_direction, in vec3 box_parameters) \n{\n    vec3 m  = 1.0/ray_direction;\n    vec3 n  = m*ray_origin;\n    vec3 k  = abs(m)*box_parameters;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2(tN,tF);\n}\n\nfloat intersection_plane(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n//----------------------------------------------------------------------------------\n// IQ SDF functions ----------------------------------------------------------------\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w; // n must be normalized\n}\n\n//----------------------------------------------------------------------------------\n// SDF Operators -------------------------------------------------------------------\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat opUnn(float d1, float d2) \t{ return min(d1,d2); }\nfloat opSub(float d1, float d2) \t{ return max(-d1,d2); }\nfloat opInt(float d1, float d2) \t{ return max(d1,d2); }\nfloat opSUnn(float d1, float d2) \t{ return sminCubic(d1,d2,0.1); }\nvec2  opU(vec2 d1, vec2 d2)         { return((d1.x < d2.x) ? d1 : d2);}\n\n//----------------------------------------------------------------------------------\n// HSV to RGB courtesy of IQ -------------------------------------------------------\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+m_eps_3f)), d / (q.x+m_eps_3f), q.x);\n}\n\n//----------------------------------------------------------------------------------\n// hg_sdf functions, courtesy of Mercury -------------------------------------------\n\nvoid pR(inout vec2 p, float a) \n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.*m_pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n//----------------------------------------------------------------------------------\n// noises --------------------------------------------------------------------------\n\nfloat u_hash_1_1(in float p) {return fract(cos(p*89.42)*343.42);}\nfloat s_hash_1_1(in float p) {return -1.0+2.0*u_hash_1_1(p);}\nvec2  s_hash_2_2(in vec2  p) {return vec2(s_hash_1_1(p.x*23.62-300.0+p.y*34.35),s_hash_1_1(p.x*45.13+256.0+p.y*38.89));}\n\n\nfloat noise1( in float p )\n{\n    float i = floor(p);\n    float f = fract(p);\n    float u = f*f*(3.0-2.0*f);\n\n    float g0 = s_hash_1_1(i+0.0);\n    float g1 = s_hash_1_1(i+1.0);\n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\nfloat fbm_1D( in float x, in float amplitude, in int octaves )\n{    \n    float n = 0.0;\n    float a = amplitude;\n    for( int i=0; i<octaves; i++ )\n    {\n        n += a*noise1(x);\n        a *= 0.5;\n        x *= 2.0;\n    }\n    return n;\n}\n\n// Candycat's Perlin Noise Implementation :: Noise Lab (2D)\n// https://www.shadertoy.com/view/ldc3RB\nfloat perlin_noise_2D(in vec2 p)\n{\n    vec2 pi = floor(p);\n\tvec2 pf  = p-pi;\n    vec2 w = pf*pf*(3.0-2.0*pf);\n    return mix(mix(dot(pf - vec2(0, 0), s_hash_2_2(pi + vec2(0, 0))), \n                   dot(pf - vec2(1, 0), s_hash_2_2(pi + vec2(1, 0))), w.x), \n               mix(dot(pf - vec2(0, 1), s_hash_2_2(pi + vec2(0, 1))), \n                   dot(pf - vec2(1, 1), s_hash_2_2(pi + vec2(1, 1))), w.x),\n               w.y);\n}\n\nfloat fbm_2D(in vec2 p, in float amplitude, in int octaves)\n{\n    float f = 0.0;\n    float a = amplitude;\n\tfor (int i = 0; i < octaves; i++) \n    {\n\t\tf += perlin_noise_2D(p) * a;\n\t\ta *= 0.5;\n        p *= 2.0;\n\t}\n\treturn(f);\n}\n", "buffer_a_code": "//-----------------------------------------------------------------------------\n//-- Constantes ---------------------------------------------------------------\nconst float EPSILON             = m_eps_3f;\nconst float SAMPLES_WORLD       = 32.;\nconst vec3  WORLD_BOUNDING_BOX  = vec3(2.5,1.0,2.5);\nconst vec3  WORLD_LIGHT_DIRECTION = normalize(vec3(1.0,1.1,0.7));\n\n\nvec2 map_city(in vec3 P)\n{\n    float SDF = 1.;\n    vec3 O = P;\n\n    /* 1. MuseePicasso & Horloger */\n    vec3 CB1 = vec3(0.15, 0.7, 0.15 );\n    vec3 C1 = P - vec3(0.3,0.7,0.3);\n    vec3 CB2 = vec3(0.15, 0.8, 0.15);\n    vec3 C2 = P - vec3(1.9,0.8,0.0);\n    vec3 CB3 = vec3(0.6, 0.6, 0.3 );\n    vec3 C3 = P - vec3(0.9,0.6,0.3);\n    SDF = opUnn( SDF, sdBox(C1,CB1) );\n    SDF = opUnn( SDF, sdBox(C2,CB2) );\n    SDF = opUnn( SDF, sdBox(C3,CB3) );\n\n\n    /* 2. Ville */\n    float cellid = pModPolar(P.xz,6.0);\n    float h = 0.4*u_hash_1_1(cellid);\n    float offset = 0.38;\n\n    float inner_radius = 0.3;\n    float outer_radius = 1.0;\n    float border_wall  = 2.1; \n    float building_size = 0.1 + 0.8*h;\n\n    \n    vec3 B1 = vec3(building_size, 0.1+h, building_size );\n    vec3 Q1 = P - vec3(offset+0.3,0.3+h,0.0);\n    vec3 B2 = vec3( building_size, 0.12+h, building_size );\n    vec3 Q2 = P - vec3(offset+1.0,0.2+h,0.4);\n    vec3 B3 = vec3( building_size, 0.15+h, building_size );\n    vec3 Q3 = P - vec3(offset+1.35,0.2+h,-0.1);\n    SDF = opUnn( SDF, sdBox(Q1,B1) );\n    SDF = opUnn( SDF, sdBox(Q2,B2) );\n    SDF = opUnn( SDF, sdBox(Q3,B3) );\n\n    /* 3. Murs */\n    pModPolar(O.xz,12.0);\n    SDF = opUnn( SDF, sdBox(O-vec3(0.1,0.0,0.0),vec3(2.0,0.1,1.0)) );\n    pR(O.xy,0.3); \n    SDF = opUnn( SDF, sdBox(O-vec3(border_wall,-0.7,0.0),vec3(0.1,0.35,0.7)) );\n    return vec2(SDF,ANTIBES_CITY_ID);\n}\n\n\nvec2 MAP(in vec3 P)\n{      \n    return map_city(P);\n}\n\n//-----------------------------------------------------------------------------\n//-- Raymarching code ---------------------------------------------------------\nvec3 \tworld_get_light_direction() { return WORLD_LIGHT_DIRECTION; }\n\nvec2 world_intersect(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float t = 0.01;\n    vec2  R = vec2(-1.);\n    for(float istep=0.; istep<SAMPLES_WORLD && t<tmax; istep+=1.)\n    {\n        vec2 H = MAP(ro + t * rd);\n        if( H.x < EPSILON )\n        {\n            R = vec2(t,H.y);\n            break;\n        }\n        t += H.x;\n    }\n    return R;\n}\n\nvec3 world_get_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*MAP( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*MAP( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*MAP( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*MAP( pos + e.xxx ).x );  \n}\n\nvec2 raymarch(vec3 ro, vec3 rd, vec3 rl)\n{ \n    float dist_max = distance(ro,rl);\n    vec2  hitinfo = world_intersect(ro, rd, dist_max);\n    float hit_dis = hitinfo.x;\n    float hit_obj = hitinfo.y;\n\n    if(hit_dis<0.) \n    {\n    \treturn vec2(-1);\n    }\n\n    return hitinfo;\n}\n\nvec2 launch_ray(inout vec3 ro, in vec3 rd)\n{\n    vec2 hitinfo = vec2(-1);\n    \n    float tmin = 0.0;\n    float tmax = 50.0;\n\n    /* First the sea level plane */\n    vec3 plane_normal = vec3(0.0,1.0,0.0);\n    float plane_hit = intersection_plane(ro,rd,vec4(plane_normal,0.0));\n    if(plane_hit>0.0)\n    {\n        tmax = min(tmax,plane_hit);\n        hitinfo = vec2(plane_hit,SEA_ID);\n    }\n\n    /* Foreground mountains */\n    vec2 foreground = intersection_axis_aligned_box(ro-vec3(-4.0,0.0,4.5), rd, vec3(5.0,1.5,0.2));    \n    bool foreground_miss = (foreground.x > foreground.y || foreground.y < 0.0);\n    bool foreground_closest = (foreground.x < tmax);\n    if( !foreground_miss  && foreground_closest ) \n    {\n        vec3 hit_pos = ro+rd*foreground.x;\n        float v = 0.2+0.6*fbm_1D( 0.13 + hit_pos.x*0.1,2.0,9);\n        if( hit_pos.y < 1.5*v )\n        {\n            tmax = min(tmax,foreground.x);\n            hitinfo = vec2(foreground.x,FOREGROUND_ID);\n        }\n    }\n    \n    /* Then the simplified montains landscape */\n    vec2 background = intersection_axis_aligned_box(ro-vec3(0.0,5.0,-5.0), rd, vec3(30.0,5.0,0.2) );   \n    bool back_miss = (background.x > background.y || background.y < 0.0);\n    bool back_closest = (background.x < tmax);\n    if( !back_miss  && back_closest ) \n    {\n        tmax = min(tmax,background.x);\n        hitinfo = vec2(background.x,BACKGROUND_ID_1);\n    }\n\n    /* Then the simplified Antibes city */\n    vec3 offset = vec3(0.0,1.0,0.0);\n    vec2 box = intersection_axis_aligned_box(ro-vec3(0.0,1.0,0.0), rd, WORLD_BOUNDING_BOX);    \n    bool box_miss = (box.x > box.y || box.y < 0.0);\n    bool box_closest = (box.x < tmax);\n    if( !box_miss  && box_closest ) \n    {\n        tmin = max(box.x,tmin);\n        tmax = min(box.y,tmax);\n\n        vec3  O = ro+tmin*rd; \n        vec3  E = ro+tmax*rd; \n        vec2 march = raymarch(O,rd,E);\n        if(march.y > 0.0)\n        {\n            hitinfo = march;\n            ro = O;\n        }\n    }\n\n    return hitinfo;\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in vec2 coords, in vec2 coords2)\n{   \n    float HUE = 240.0/360.0;\n    float OBJ = SKY_ID;\n    float DIS = 0.0;\n    float SAT = 0.8;\n    float VAL = 0.5;\n\n    float snow_factor = 0.0;\n    float wave_factor = 0.0;\n    float shade_factor = 0.0;\n    \n    vec3 ro_tmp = ro;\n\n    vec2 hitinfo = launch_ray(ro,rd);\n    float hit_dis = hitinfo.x;\n    float hit_obj = hitinfo.y;\n\n\n    if(hit_dis<0.) /* background color */\n    {\n        SAT = 0.5;\n        VAL = 1.0;\n    }\n\n    if(hit_obj == SEA_ID) /* sea level */\n    {\n        DIS = hit_dis;\n        HUE = 216.0/360.0;\n        OBJ = hit_obj;\n        SAT = 0.8;\n        VAL = 0.6;\n        wave_factor = 1.0;\n    }\n\n    if(hit_obj == FOREGROUND_ID) /* foreground coast   */\n    {\n        DIS = hit_dis;\n        HUE = 05.0/360.0;\n        OBJ = hit_obj;\n        SAT = 1.0;\n        VAL = 0.54;\n    }\n\n    if(hit_obj == ANTIBES_CITY_ID) /* city */\n    {\n        vec3 hit_pos = ro+rd*hit_dis;\n        vec3 hit_nor = world_get_normal(hit_pos);\n        \n        DIS = (hit_dis + distance(ro_tmp,ro));\n        HUE = 50.0/360.0 * dot(hit_nor, world_get_light_direction());\n        OBJ = hit_obj;\n        SAT = 0.8;\n        VAL = 0.5;\n    }\n\n    if(hit_obj == BACKGROUND_ID_1) /* mountains */\n    {\n        vec3 hit_pos = ro+rd*hit_dis;\n        float v = 0.4+0.2*fbm_1D(hit_pos.x*0.1,2.0,9);\n        float w = 0.5+0.2*fbm_1D( 1.1 + hit_pos.x*0.05,2.0,9);\n        \n        if(hit_pos.y < 5.*v )\n        {\n            HUE = 220.0/360.0;\n            OBJ = hit_obj;\n            DIS = hit_dis;\n            \n            SAT = 0.88;\n            VAL = 0.25;\n            shade_factor = 1.0;\n        }\n        else if( hit_pos.y < 5.5*w )\n        {\n            HUE = 200.0/360.0;\n            OBJ = BACKGROUND_ID_2;\n            DIS = (hit_dis+0.5);\n            SAT = 0.45;\n            VAL = 0.35;\n            snow_factor = 1.0;\n        }\n    }\n    \n    float hue_noise = 0.5+0.5*fbm_2D(coords+vec2(OBJ),1.0,3);\n    HUE += 0.1*hue_noise;\n    \n    \n    /* */\n    vec3 color = vec3(0.0);\n    float noise = fbm_2D(coords+2.0*vec2(SAT,VAL),1.2,5);\n    float warp1 = fbm_2D(coords.xx+2.0*noise,1.0,5);\n    float warp2 = fbm_2D(coords.yy+2.0*warp1+0.2*iTime,1.0,5);\n    /* Shading */\n    float shade = shade_factor*0.2*smoothstep(0.2,0.7,coords2.y+1.0*noise);\n    /* Wave */ \n    float wave = wave_factor*0.2*smoothstep(0.0,0.85,coords2.y+warp2);\n    /* Color */ \n    color = hsv2rgb( vec3(HUE + 0.1*noise + wave + shade,SAT,VAL) );\n    /* Snow */ \n    color += snow_factor*smoothstep(0.55,0.75,coords2.y+0.1*noise);\n    /* Final Color */\n    color = clamp(color,0.0,1.0);  \n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 U = (fragCoord - (iResolution.xy-iResolution.y)*0.5) / iResolution.y;  \n    vec2 screen_coords = (2.*fragCoord - iResolution.xy)/iResolution.y; \n    \n    \n    vec3 ta = vec3(0.,0.65,0.0);\n    vec3 ro = vec3( -1.1, 0.13, 7.0 );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, ta, 0.0);\n      \n    vec3 color = render(ro,rd, screen_coords, U);\n    fragColor = vec4(color,1.0);\n}\n\n", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rgbcolor = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    vec3 hsvcolor = rgb2hsv(rgbcolor);\n    float value = hsvcolor.b;    \n    fragColor = vec4(rgbcolor,value);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = texture(iChannel0,fragCoord/iResolution.xy);\n    vec4 moment = value*value;\n    fragColor = moment;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3GzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 97, 97, 267], [269, 269, 326, 326, 1398]], "test": "untested"}
{"id": "NdVXDw", "name": "Pale Silk", "author": "R3N", "description": "A simple silky cloth effect.\nI haven't worried much about size but it can probably be golfed down to a lot less.", "tags": ["cloth", "fabric", "silk"], "likes": 28, "viewed": 724, "published": 3, "date": "1635684392", "time_retrieved": "2024-07-30T18:51:30.340930", "image_code": "void mainImage(out vec4 col, vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.y;\n    float t = 0.3*iTime;\n\tuv.y += 0.03*sin(8.0*uv.x-t);\n    float f = 0.6+0.4*sin(5.0*(uv.x+uv.y+cos(3.0*uv.x+5.0*uv.y)+0.02*t)+sin(20.0*(uv.x+uv.y-0.1*t)));\n    col = vec4(0.9,0.95,1,1)*vec4(f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 282]], "test": "untested"}
{"id": "Nl3GzH", "name": "Fab31 #inktober2021 \"risk\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]", "tags": ["raymarching", "sdf", "short", "inktober2021"], "likes": 26, "viewed": 362, "published": 3, "date": "1635675187", "time_retrieved": "2024-07-30T18:51:31.237532", "image_code": "#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))         // rotation\n\nfloat line(vec3 p, vec3 a,vec3 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\n#define limb(a,z)                                                       /* leg */   \\\n        A = vec3(0,1.5,z.3), B = vec3(.3*cos(a+2.*iTime+vec2(0,11)),z.3), l = length(L=(B-A)/2.), \\\n        K = (A+B)/2. + vec3(L.y,-L.x,0)*sqrt(1.-l*l)/l,                             \\\n        t = min(t, min( min(line(q,A,K) -.15, line(q,K,B) -.1 ) , line(q,B,B-vec3(.4,0,0))-.07 ) ), \\\n        L = vec3( .65*sin( .3*sin(a+2.*iTime)+vec2(0,11)), z.5 ),       /* arm */   \\\n        B = .8* normalize(vec3(-.5,-L.y-1.1,0)),                                    \\\n        t = min(t, min( line(q, A+1.1*Y,A+Y+L )-.1 , line(q,A+Y+L,A+Y+L+B) -.07 ) )\n           \n        \nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., r,x,y,z,l,a=.4; \n    vec3  R = iResolution, d, A,B,K,L, Y=vec3(0,1,0),\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),       // ray direction\n          p = vec3(0,0,14), q,                            // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(.05*iTime,.1*sin(.5*iTime)+.05,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                          // rotations\n        q.xz *= rot(-6.3*M.x),\n        t = length(vec2(length(q.xy)-1.,q.z)) -.1,        // wheel\n        limb(,), limb(3.14, - ),                          // limbs\n        t = min(t, line(q, A,vec3(A.xy,-A.z))-.2),        // pelvis\n        A.z=0., t = min(t, line(q, A+.1*Y,A+Y)-.3),       // body\n        t = min(t, length((q-A-1.8*Y)/vec3(1,1.5,1))-.3), // head\n        A.x+=.1,t = min(t, line(q, A+Y,A+1.5*Y) -.1 ),    // neck\n        q.x = abs(q.x), t = min(t, line(q, vec3(.2,-1.05,0), vec3(10,0,0)) -.01 ), // cable\n        p += .25*t*D;                                     // step forward = dist to obj\n // O *= 1.5*abs(O);\n    if (O.x<0.) O = texture(iChannel0,q);                 // background\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 102, 102, 190]], "test": "untested"}
{"id": "7ld3zr", "name": "3D Erdős–Rényi Random Graphs", "author": "gauravity", "description": "Forked from 2d version\nGenerates random graphs and runs a physics simulation!\nUse mouse to drag vertex\nArrow keys to rotate graph\nR to toggle auto-rotate\nL to toggle drawing edges (faster off)\nGo to Common for params to change!", "tags": ["simulation", "physics", "graphs"], "likes": 10, "viewed": 322, "published": 3, "date": "1635668648", "time_retrieved": "2024-07-30T18:51:32.063324", "image_code": "\nvec3 light = normalize(vec3(1, -1, 1));\n//assumes you want first sphere intersection \n\n\nvoid circle(inout vec4 fragColor, in vec2 x, vec3 c, float r, vec3 color) {\n\n\n    vec4 i = sphereIntersect(c, r, vec3(dims/2., 0), vec3(x, 1)-vec3(dims/2.,0));\n    if (i == vec4(0)){\n        return;\n    }\n    vec3 normal = normalize(i.xyz-c);\n    float diff = clamp(dot(-light, normal), 0., 1.);\n    if (i.w < fragColor.w) {\n        fragColor = vec4(color * (diff + .3), i.w);\n    }\n    \n}\n\nvoid line(inout vec4 fragColor, in vec2 x, vec3 pp1, vec3 pp2, float thicc, vec3 color) {\n    vec2 p1 = (pp1.xy - dims/2.)/pp1.z + dims/2.;\n    vec2 p2 = (pp2.xy - dims/2.)/pp2.z + dims/2.;\n    vec2 relx = x - p1;\n    vec2 dir = p2 - p1;\n    float projFactor = dot(relx, dir)/dot(dir, dir);\n    vec2 proj = projFactor*dir;\n    vec2 diff = proj - relx;\n    float z = pp1.z  + projFactor*(pp2.z - pp1.z);\n    if (dot(diff, diff) < thicc*thicc/z/z && projFactor > 0. && projFactor < 1. && z < fragColor.a) {\n        fragColor = vec4(color, z);\n        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    fragColor = vec4(209.,205., 219., 255.)/255.;\n    vec2 uv = fragCoord / iResolution.x;\n    vec4 blu =  vec4(.3, .8, 1, 1);\n    fragColor.a = 3.;\n\n\n    if (texelFetch(iChannel1, ivec2(KEY_L, 2), 0).x < 0.5) {\n\n        for(int i =0; i < n; i++){\n            vec3 c = hsv2rgb(vec3(rand(vec2(i, i)),0.5, 1.));\n        \n            for(int j=0; j < n; j++){\n                if(j <= i){\n                    continue;\n                }\n                if (getEdge(i, j)) {\n                    line(fragColor, uv, getVertex(i).xyz, getVertex(j).xyz,lineThickness, vec3(1));\n                }\n            }\n        }\n    }\n    for(int i =0; i < n; i++){\n        vec3 c = hsv2rgb(vec3(rand(vec2(i, i)),0.5, 1.));\n        circle(fragColor, uv, getVertex(i).xyz, radius, c);\n    }\n    fragColor.a = 1.;\n     \n}\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Comment out the following line to disable drawing the lines between vertices\n// Drawing lines is the most expensive operation, without it you can simulate\n// Hundreds of vertices (even while simulating the springs)\n#define drawLines \n//change seed for different random graph\n#define seed vec2(420., 69.)\n//number of vertices (up to min(iResolution.x, iResolution.y)\n#define n 30\n//probability that any two vertices have a edge between them. \n// p*n is the average degree of a vertex (best results around p*n = 3)\n#define p 0.1\n// radius of each vertex\n#define radius 0.015\n// attracting force between vertices with spring (hooks law)\n#define k 7.\n// repellant force between vertices (q/r^2)\n#define q .01\n// velocity wil *= drag once per second, lower = more drag\n#define drag 0.01\n// strength of edge connected to the center (as a fraction of k)\n#define centerRatio 5.\n// thickness of line\n#define lineThickness 0.0015\n#define dims (iResolution.xy/iResolution.x)\n#define rayOrigin vec3(dims/2., 0)\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_R = 82;\nconst int KEY_L = 76;\n\n\n\n\nfloat quadSolveMin(float a, float b, float c) {\n    return (-b-sqrt(b*b - 4.*a*c))/(2.*a);\n}\n\nfloat disc(float a, float b, float c) {\n    return b*b - 4.*a*c;\n}\nvec4 sphereIntersect(vec3 c0, float r, vec3 ray0, vec3 rayDir) {\n    vec3 relc = c0-ray0;\n    float a = dot(rayDir, rayDir);\n    float b = -2.*dot(rayDir, relc);\n    float c = dot(relc, relc) - r*r;\n    if (disc(a, b, c) < 0.) {\n        return vec4(0.);\n    }\n    float solve = quadSolveMin(a, b, c);\n    return vec4(ray0 + solve*rayDir, solve);\n}\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n// Official HSV to RGB conversion \n//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy + seed,vec2(12.9898,78.233))) * 43758.5453); }\n\n\nvoid line(inout vec4 fragColor, in vec2 x, vec2 p1, vec2 p2, float thicc, vec4 color) {\n    vec2 relx = x - p1;\n    vec2 dir = p2 - p1;\n    float projFactor = dot(relx, dir)/dot(dir, dir);\n    vec2 proj = projFactor*dir;\n    vec2 diff = proj - relx;\n    if (dot(diff, diff) < thicc*thicc && projFactor > 0. && projFactor < 1.) {\n        fragColor = color;\n    }\n}\n// https://www.shadertoy.com/view/tdGBDG\n// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\n\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n\n#define fetchData(addr) texelFetch(iChannel0, addr, 0)\n#define getPos(i) fetchData(ivec2(i, i))\n#define getVelocity(i) fetchData(ivec2(i+n, i+n))\n\n\n#define getVertex(i) fetchData(ivec2(i, i))\n\n\n#define getEdge(i, j) (fetchData(ivec2(i, j)).x>0.5)\n\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n", "buffer_a_code": "//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define PI 3.14159265\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    ivec2 index = ivec2(fragCoord);\n    if(index.x >= 2*n || index.y >= 2*n || index.x > index.y) {\n        return;\n    }\n    if(index.x != index.y && (index.x >= n || index.y >= n )) {\n        return;\n    }\n    // edge, initialize once\n    if (index.x != index.y) {\n        fragColor = vec4(0., 0., 0., 0.);\n        if(rand(fragCoord) < p) {\n            fragColor += 1.;\n        }\n        return;\n    }\n    \n    float theta = 2.*PI*float(index.x)/float(n);\n    if(index.x < n) {\n        fragColor.xyz = vec3(dims/2., 1.5) + vec3(cos(theta),sin(theta),cos(2.*theta))*.1;\n    } else {\n        fragColor.zw = vec2(0,0);\n    }\n    if (iFrame < 1) {\n        return;\n    }\n    \n    fragColor = fetchData(index);\n    if(index.x < n) {\n        if (texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x > 0.5) {\n            fragColor = rotationMatrix(vec3(-1,0,0), iTimeDelta) * (fragColor - vec4(dims/2., 1.5, 0))+vec4(dims/2., 1.5, 0);\n        }\n        if (texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5) {\n            fragColor = rotationMatrix(vec3(1,0,0), iTimeDelta) * (fragColor - vec4(dims/2., 1.5, 0))+vec4(dims/2., 1.5, 0);\n        }\n        if (texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5) {\n            fragColor = rotationMatrix(vec3(0,-1,0), iTimeDelta) * (fragColor - vec4(dims/2., 1.5, 0))+vec4(dims/2., 1.5, 0);\n        }\n        if (texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x > 0.5) {\n            fragColor = rotationMatrix(vec3(0,1,0), iTimeDelta) * (fragColor - vec4(dims/2., 1.5, 0))+vec4(dims/2., 1.5, 0);\n        }\n        if (texelFetch(iChannel1, ivec2(KEY_R, 2), 0).x < 0.5) {\n            fragColor = rotationMatrix(vec3(0,1,0), iTimeDelta) * (fragColor - vec4(dims/2., 1.5, 0))+vec4(dims/2., 1.5, 0);\n        }\n        vec4 mouse = iMouse;\n        if(sign(mouse.z) == 1.) {\n            vec2 screenUV = mouse.xy /iResolution.x;\n            vec3 dir = vec3(screenUV, 1)-vec3(dims/2.,0);\n            vec4 i = sphereIntersect(fragColor.xyz, radius, vec3(dims/2., 0), dir);\n            if (i != vec4(0)) {\n                fragColor = vec4(rayOrigin + dir*fragColor.z, 1);\n                return;\n            }\n            \n        }\n\n        fragColor = vec4(iTimeDelta * getVelocity(index.x).xyz + fragColor.xyz, 1.);\n        fragColor.xyz = clamp(fragColor.xyz, vec3(0,0, 1), vec3(dims, 2));\n        return;\n\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x > 0.5) {\n        fragColor = rotationMatrix(vec3(-1,0,0), iTimeDelta) * fragColor;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5) {\n        fragColor = rotationMatrix(vec3(1,0,0), iTimeDelta) * fragColor;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5) {\n        fragColor = rotationMatrix(vec3(0,-1,0), iTimeDelta) * fragColor;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x > 0.5) {\n        fragColor = rotationMatrix(vec3(0,1,0), iTimeDelta) * fragColor;\n    }\n    if (texelFetch(iChannel1, ivec2(KEY_R, 2), 0).x < 0.5) {\n            fragColor = rotationMatrix(vec3(0,1,0), iTimeDelta) * fragColor;\n        }\n    vec3 pos = getPos(index.x - n).xyz;\n    for(int i =0; i < n; i++) {\n        if (i == index.x - n) {\n            continue;\n        }\n        if (length(pos-getVertex(i).xyz) == 0.) {\n            fragColor.xy += fragCoord.xy*.00001;\n        }\n        float chargeForce = q/pow(length(pos - getVertex(i).xyz), 2.);\n        vec3 direction = normalize(pos - getVertex(i).xyz);\n        fragColor.xyz += direction*chargeForce*iTimeDelta;\n        if (getEdge(i, index.x -n) || getEdge(index.x-n, i)) {\n            fragColor.xyz += k*(getVertex(i).xyz - pos)*iTimeDelta;\n        }\n        \n    }\n    vec3 relpos = pos - vec3(0, 0, 1);\n    \n    fragColor.xyz += iTimeDelta * centerRatio *(vec3(dims/2., 1.5) - pos);\n    fragColor.xyz *= pow(drag, iTimeDelta);\n    fragColor.xyz = clamp(fragColor.xyz, -1., 1.);\n    vec2 mouseProj = iMouse.xy/iResolution.x;\n    /*if (length(mouseProj-fragColor.xy) < radius) {\n        fragColor = vec4(mouseProj, 0, 0);\n    }*/\n    \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ld3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 164, 164, 478], [480, 480, 569, 569, 1037], [1039, 1039, 1096, 1096, 1901]], "test": "untested"}
{"id": "fl33z8", "name": "Embossed wallpaper", "author": "Plento", "description": "Decorative. ", "tags": ["2d", "fractal", "mouse", "bump"], "likes": 26, "viewed": 487, "published": 3, "date": "1635668179", "time_retrieved": "2024-07-30T18:51:32.952946", "image_code": "// Cole Peterson\n\n\n#define R iResolution.xy\n\nvec3 t(vec2 p){\n    return texture(iChannel0, p).xyz;   \n}\n\nfloat height(vec2 p){\n    return t(p).r;\n}\n\nvec3 bump(vec2 uv, float strength){\n    float h = 0.004;\n    \n    vec3 p = t(uv); \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    \n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 lp = vec3(cos(iTime*.5)*.1, sin(iTime*.5)*.1, -1.0);\n    vec3 sp = vec3(nuv, 0.0);\n    vec3 ro = vec3(0, 0, -1.0);\n    vec3 rd = normalize(sp - ro);\n    vec3 ld = lp - sp;\n    \n    float dist = max(length(ld), 0.001);\n    ld /= dist;\n    vec3 objCol = t(uv) * vec3(.99, .95, .9);\n    vec3 norm = bump(uv, 5.);\n  \t\n    float dif = max(dot(norm, ld), 0.);  \n    float spec = pow(max(dot( reflect(-ld, norm), -rd), 0.), 16.); \n    float fal = 0.85 / (dist*dist);\n    \n    vec3 col = (objCol*(dif + .2))*fal;\n    col += vec3(0.6, 0.6, 0.6)*spec*.12*fal;\n        \n    col = pow(col*1.5, vec3(1.6));\n    col *= smoothstep(0.8, .35, abs(nuv.y));\n\n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n\nvoid mirror(inout vec2 p){\n    p = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    if(int(id.x) % 2 == 0){\n        p.x *= -1.;\n    }\n    if(int(id.y) % 2 == 0){\n        p.y *= -1.;\n    }\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    vec2 uv2 = u / R;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv -= .5;\n    uv *= .3;\n    uv.x *= 2.;\n    if(iMouse.z > 0.)\n        uv *= max((m.y+.3) * 5., .1);\n    uv += .5;\n    \n    uv.x-=200.;\n    uv += .4*vec2(cos(iTime*.3)*.3, -iTime*0.05);\n    uv = (uv + vec2(-uv.y,uv.x) ) / 1.4;\n    mirror(uv);\n    \n    float a = -.093;\n    vec2 v = vec2(cos(a), sin(a));\n    \n    for(float i = 0.; i < 35.; i++){\n        uv -= .5;\n        uv *= 1.1;\n        uv += .74;\n        \n        uv = abs(uv - .5);\n        uv.x -= .505;\n        uv -= v*min(0., dot(uv, v))*2.;\n        \n    }\n\n    float k = (dot(uv, uv))*18. + 3.;\n    float t = 1.8*(uv.x*2. + uv.y*3.);\n    vec3 col = .5+.6*cos(vec3(2.4, 2., 5.)*t + k*.6);\n    col -= .3*texture(iChannel0, uv*.5).xyz;\n    col += .2*texture(iChannel0, uv*0.4).xyz;\n    \n    col = mix(col.bbb, col.ggg, .5+.5*sin(iTime*.5 + dot(uv, uv)*12.));\n    \n    col = clamp(col, .25, .9);\n    col = 1.-exp(-col);\n    \n    f = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 60, 60, 103], [105, 105, 126, 126, 147], [149, 149, 184, 184, 416], [419, 419, 459, 459, 1202]], "test": "untested"}
{"id": "Ntc3z8", "name": "Psychedelicx", "author": "function", "description": "x*y", "tags": ["xy"], "likes": 1, "viewed": 224, "published": 3, "date": "1635659589", "time_retrieved": "2024-07-30T18:51:33.855533", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col, col2, col3, col4;\n    vec4 color;\n    col = (fragCoord.x - iResolution.x / 2.0) * (fragCoord.y - iResolution.y / 2.0) * (150.0 + iTime / 300.0) / 10000.0;\n    col2 = mod(col + iTime / 0.3 + fragCoord.x / iResolution.x * 50.0, 2.0) ;\n    col3 = mod(col + iTime / 0.4 + fragCoord.y / iResolution.y * 50.0, 2.0) ;\n    col4 = mod(col + iTime / 0.5 + fragCoord.y / iResolution.x * 50.0, 2.0) ;\n    if (col2 > 1.0){ col2 = 2.0 - col2;}\n    if (col3 > 1.0){ col3 = 2.0 - col3;}\n    if (col4 > 1.0){ col4 = 2.0 - col4;}\n    fragColor = vec4(col2, col3, col4, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 631]], "test": "untested"}
{"id": "ftcGz8", "name": "[live] Inercia 2021 royale", "author": "w23", "description": "Coded live at Inercia 2021 shader royale compo. Continued coding after being wiped out 2nd, and this is what I ended up with.\nPoV VoD: https://www.youtube.com/watch?v=EZNpgjQnXVg", "tags": ["dof", "livecoding"], "likes": 16, "viewed": 433, "published": 3, "date": "1635654545", "time_retrieved": "2024-07-30T18:51:34.760115", "image_code": "float t;\n#define pi 3.1415927\n#define TT(t,v) texture(t, ((v)+.5)/vec2(textureSize(t,0)))\n//float fft(float f){return TT(texFFT,f).r;}\n//float ffts(float f){return TT(texFFTSmoothed,f).r;}\n//float ffti(float f){return TT(texFFTIntegrated,f).r;}\n\n//float fft(float f){return TT(iChannel0, vec2(f, t*32.)).r;}//TT(texFFT,f).r;}\nfloat ffts(float f){return .02 * pow(TT(iChannel0, vec2(f/1., t*10.)).r, 2.5);}//TT(texFFTSmoothed,f).r;}\n//float ffti(float f){return 0.;}//TT(texFFTIntegrated,f).r;}\n\n\n#define rep(v,s) (mod(v,s)-(s)*.5)\nfloat hash(float f){return fract(sin(f)*54353.42347);}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec3 circ(vec2 uv, float h) {\n  float r=length(uv);\n  float a=atan(uv.x,uv.y);\n  a/=pi;a+=1.;\n  a+=2.;\n  float f = 4. * ffts(floor(a*(5. + 50. * hash(h))));\n  r -= f;\n  \n  float mask = step(abs(r-.3), .1);\n  float masz = .2 * hash(h+.1);\n  mask *= step(mod(a + sin(t+h*4.),.1+masz),.04+.1*masz);\n  \n  return mix(vec3(.1,.2,.3),vec3(.5,.2,.3),min(f*40., 3.)) * mask;\n}\n\nvec3 dots(vec2 p) {\n  //p = fract(p) - .5;\n  p = rep(p,vec2(.2));\n  return vec3(.1,.4,.6) * step(length(p), .01);\n}\n\nvec3 plane(float O, float D, float S, vec2 ouv, vec2 duv, float n) {\n  float l = (S - O) / D; if (l < 0.) return vec3(0.);\n  vec2 uv = ouv + duv * l;\n  \n  if (n == 1.)\n     uv.y += floor(t) + pow(fract(t), 2.);\n  \n  float xoffc = floor(uv.y);\n  float xoffp = t * (.2 - 1. * sin(2. * pi * hash(xoffc+.3))) + hash(xoffc);\n  //xoffp = \n  float xoff = floor(xoffp/2.)*2. + 2. * pow(fract(xoffp), 3.);\n  uv.x += xoff;\n  \n  vec2 pc = floor(uv);\n  vec2 p = fract(uv) - .5;\n  \n  vec3 c = vec3(0.);\n  \n  c += circ(p*1.5, hash(pc.x*.18+pc.y*34.)) * 4.;\n  \n  //c += vec3(.1, .2, .3) * step(length(p), .1);\n  c += dots(uv) * 4.;\n  \n  //c +\n  \n  return c / l;\n}\n\n\n/*void main(void) {\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy - .5; uv.x *= iResolution.x/iResolution.y;\n  \n  vec3 C=vec3(0.);\n  \n  //t = iTime; fragColor.rgb = circ(uv, 1.); return;\n  \n  float seed = uv.x*45.43278 + uv.y*17.643 + iTime*3.4;\n\n  const float foc = 6.;\n  const float fov = 1./2.;\n  const float ls = .05;\n\n  const int NS = 16;\n  ///float tt = iTime;// * 130./120.;\n  for(int si = 0; si < NS; ++si) {\n    seed = fract(seed);\n    vec3 O,D;\n\n    t = iTime - hash(seed+=.01) * iTimeDelta;\n    vec2 dp = vec2(hash(seed+=.1), hash(seed+=.2));\n    \n    vec3 at = vec3(uv, fov) * foc;\n    O = vec3(dp * ls, 0.);\n    D = normalize(at - O);\n    \n    vec3 S=vec3(1., 1.1, 10.), DS=vec3(2.);\n    //O += vec3(.1 + .4*sin(t*.17 + ffti(.3)*.1), .4, 5.);\n    \n    float tp = t / 2.;\n    float tc = floor(tp);\n    float tct = /*1. -*/ pow(fract(tp), 1.);\n    \n    vec3 o0 = S * .9 * (1. - 2. * vec3(hash(tc   ),hash(tc+ .1),hash(tc+ .2)));\n    vec3 o1 = S * .9 * (1. - 2. * vec3(hash(tc+1.),hash(tc+1.1),hash(tc+1.2)));\n\n    O += mix(o0, o1, tct);\n    \n    D.xz *= rot(-.3 + .2 * (1. - 2. * mix(hash(tc+.3), hash(tc+1.3), tp)));\n    D.yz *= rot(-.2 + .3 * (1. - 2. * mix(hash(tc+.5), hash(tc+1.5), tp)));\n    D.xy *= rot(-.1 + .4 * (1. - 2. * mix(hash(tc+.6), hash(tc+1.6), tp)));\n    D = normalize(D);\n    //D.yz *= rot(-.2);\n\n\n    S *= sign(D);\n    DS *= sign(D);\n    \n    //C += circ(uv);\n    for (float ip = 0.; ip < 2.; ++ip, S+=DS) {\n      C += plane(O.y, D.y, S.y, O.xz, D.xz, 0.);\n      C += plane(O.x, D.x, S.x, O.yz, D.yz, 1.);\n      C += plane(O.z, D.z, S.z, O.xy, D.xy, 2.);\n    }\n  }\n  \n  C /= float(NS);\n  \n\t//out_color = vec4(sqrt(C), 0.);\n    fragColor = vec4(sqrt(C), 0.);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 326, 346, 346, 405], [531, 531, 551, 551, 585], [586, 586, 604, 604, 647], [649, 649, 678, 678, 1016], [1018, 1018, 1037, 1060, 1133], [1135, 1135, 1203, 1203, 1783], [1786, 1953, 2010, 2010, 3673]], "test": "untested"}
{"id": "flcGz8", "name": "Persian carpet 6", "author": "jarble", "description": "A Persian carpet fractal pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 209, "published": 3, "date": "1635654487", "time_retrieved": "2024-07-30T18:51:35.682647", "image_code": "\n//change these constants to get different patterns!\n#define c2 1.5\n\n#define c1 vec4(3.0+c2,2.5+c2,-1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n    float t = 45.87+iTime/2.;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/128.0/2.;\n    uv += vec2(t/2.0,t/3.0)/t1/128.0/4.;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((t+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = -.1;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = 1.1;\n            \n            uv = triangle_wave(uv.yx+c1.z,scale)+triangle_wave(uv,scale);\n            //uv.y /= .9;\n            uv.x *= .9;\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv*(1.+offset)),scale);\n            }\n            uv.x /= -.9;\n            \n            if(i>0) col = abs(col.yzx*col.x + col_prev*col.y)/(col.x-col.y);\n            \n            col[c] = fract((uv.x*(1.+col.x/8.))-(uv.y*(col.y/8.+1.)));\n        }\n    }\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 457, 479, 524, 657], [659, 659, 698, 698, 743], [745, 745, 802, 802, 1908]], "test": "untested"}
{"id": "ft3Gz8", "name": "Porcelain", "author": "jarble", "description": "A porcelain glaze pattern.", "tags": ["fractal", "porcelain"], "likes": 2, "viewed": 207, "published": 3, "date": "1635650776", "time_retrieved": "2024-07-30T18:51:36.496472", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,-1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/4.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/16.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((iTime+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = -.1;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = 1.1;\n            \n            uv = triangle_wave(uv.yx+c1.z,scale)+triangle_wave(uv,scale);\n            for(int j = 0; j < 2;j++){\n                uv = triangle_wave((uv*(1.+offset)),scale);\n            }\n            scale /= 1.+col.x;\n            uv.x /= -.9;\n            \n            if(i>0) col = abs(col.yzx*col.x + col_prev*col.y)/(col.x-col.y);\n            \n            col[c] = fract((uv.x*(1.+col.x/8.))-(uv.y*(col.y/8.+1.)));\n            \n\n        }\n        \n\n            //random3 = (hash31(2.+t3)-vec3(.5))/4.;\n            //random4 = (hash31(3.+t3)-vec3(.5))/4.;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3Gz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 457, 479, 524, 657], [659, 659, 698, 698, 743], [745, 745, 802, 802, 1990]], "test": "untested"}
{"id": "7tdGzr", "name": "Quantum Annihilation", "author": "SnoopethDuckDuck", "description": "really overusing tanh(cos) but its nice", "tags": ["e"], "likes": 7, "viewed": 245, "published": 3, "date": "1635639005", "time_retrieved": "2024-07-30T18:51:37.387090", "image_code": "// sigmoid function (not in use)\nfloat sig(float x) {\n    return x / (1. + abs(x));\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// smooth \"square\" wave, tends to cos() as a->0\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    // uv.y += 0.02 * cos(40. * uv.x + iTime);\n    \n    float k = 2. * thc(4., 0.5 * iTime);\n    float time = thc(4., k * uv.x + iTime) + iTime;\n        \n    // vertical wobble\n    uv.y += 0.025 * thc(0.5, 16. * uv.x + 2. * time);\n    \n    // only used for vertical sections (I think?)\n    float rand = h21(vec2(floor(100. * uv.y))); // 20. * uv.y\n    \n    // position of blob\n    float f = 0.5 * thc(4., 0.5 * rand + time); // 10. * rand\n    vec2 p = vec2(f, 0.);\n    \n    // distance from blob + noise\n    float d = length(uv-p) - 0.1 + 0.08 * thc(1.5, 100. * pow(h21(uv),4.) + 3. * time);\n    float s = step(d, 0.1 + 0.025 * thc(4., 0.4 * rand - 2. * time));\n    \n    vec3 col = s * pal(f + 0.1 * iTime, vec3(0.5), vec3(0.5), vec3(1.5), vec3(0.,0.333,0.666));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 53, 53, 85], [87, 87, 107, 107, 182], [184, 184, 252, 252, 295], [297, 345, 374, 374, 415], [417, 417, 474, 474, 1339]], "test": "untested"}
{"id": "7td3Rr", "name": "pumpkin zome", "author": "netgrind", "description": "pumpkin", "tags": ["halloween", "pumpkin"], "likes": 9, "viewed": 566, "published": 3, "date": "1635635402", "time_retrieved": "2024-07-30T18:51:38.432296", "image_code": "// spooky pumpkin fork of https://www.shadertoy.com/view/lt2SRt\n// lighting & other ray stuff via IQ\n// additional ray ops via MERCURY\n// happy halloween\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 ca;\nvec3 ta;\nvec3 ro;\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0., 1.,0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 map( in vec3 pos )\n{\n    float size = 4.;\n    vec3 r = pos;\n    pos-=size*.5;\n    vec3 index = pMod3(pos, vec3(size));\n    \n    \n    //pos*=sin(index.x*20.+index.z*30.+index.y+iTime*2.)*.05+1.;\n    vec3 p = pos;\n    p.y = -p.y;\n    p = setCamera(vec3(cos(iTime+index.z)*.3, sin(iTime+index.x)*.3, .1), r-ro)*p;\n    p.y = -p.y;\n    \n    float a = atan(p.z, p.x);\n    float f = fTorus(p*(cos(a*12.)*.03+1.), .75, .3);\n    \n    p.z +=.9;\n    //mouth\n    p.y-=.1;\n    float cut = fCylinder(p.xzy, .6, .5);\n    p.y-=.5;\n    cut = max(cut, -fCylinder(p.xzy, .9, .6));\n    //nose\n    p.y+=.7;\n    cut = min(cut, fTriPrism(p, vec2(.1, .5)));\n    //eyes\n    p.x = abs(p.x);\n    p.x -= .3;\n    p.y -= .2;\n    cut = min(cut, fTriPrism(p, vec2(.2, .5)));\n    \n    //hollow\n    cut = min(cut, (f+.2));\n    //face\n    float m = 2.;\n    if(f<-cut){\n        m = pow(sin(index.z+index.y*2.34+iTime+3.*cos(iTime*5.+index.x*234.352))*.5+.5, .5);\n    }\n    f = max(f, -cut);\n    \n    return vec2(f, m);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 50.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<30; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0., 0.1 );\n        if(t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0., 0., 0.);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = vec3(1., .8, 0.);\n\t\t\n        if( m<1.5 )\n        {\n            \n            col = vec3(5., 5.,0.)*(1.+smoothstep(10., 20., t)*5.)*(m+.8);\n        }\n        \n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(0.60,0.10,0.0);\n\t\tbrdf += 1.20*spe*vec3(01.0,0.40,0.20)*dif;\n        brdf += 0.30*amb*vec3(0.70,0.50,0.0)*occ;\n        brdf += 0.40*fre*vec3(1.00,.10,.30)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n    \tcol = mix( col, vec3(.0,0.0,.0), 1.0-exp( -0.01*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tro = vec3( 0.,2.+time*.5,time );\n\tta = ro+vec3( sin(time*.2),cos(time*.5)*.2,1. );\n\t\n\t// camera-to-world transformation\n    ca = setCamera( ro, ta);\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,1.) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define PHI (1.618033988749895)\n     // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI, 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle*.5+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\t\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\t\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7td3Rr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[270, 270, 312, 312, 479], [481, 481, 506, 506, 1470], [1472, 1472, 1512, 1512, 2064], [2067, 2067, 2141, 2141, 2386], [2388, 2388, 2420, 2420, 2640], [2642, 2642, 2684, 2684, 2982], [2987, 2987, 3026, 3026, 4226], [4228, 4228, 4285, 4285, 4809]], "test": "untested"}
{"id": "7dVXDt", "name": "Twisted^4 Tunnel", "author": "Tater", "description": "A shader I made during practice for inercia shader royale. ", "tags": ["3d", "raymarching", "twisty", "rope"], "likes": 37, "viewed": 683, "published": 3, "date": "1635634032", "time_retrieved": "2024-07-30T18:51:39.183288", "image_code": "#define MDIST 60.0\n#define STEPS 178.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//My poor mans version of Javad Taba's helix function\nvec3 spiral(vec3 p, float R){\n   \n    p.xz*=rot(p.y/R);\n    vec2 s = sign(p.xz);\n    p.xz=abs(p.xz)-R*0.5;\n    \n    p.xz*=rot(iTime*pi/3.);\n    \n    float poy = p.y;\n    p.y=0.;\n    //This is supposed to correct for the distortion that happens\n    //when you twist a shape by rotating it over an axis.\n    //In my head it should work a lot better than it does, but\n    //it definitely helps a little bit so I guess it's better than nothing\n    p.yz*=rot(mix(0.,pi/4.,1./(R*0.5+1.5)))*-sign(s.x*s.y);\n    p.y=poy;\n    return p;\n}\n\n\nvec2 map(vec3 p){\n    float t = iTime*0.5;\n    //p.y+=sin(-p.z*0.1)*2.;\n    p.y-=p.z*p.z*0.008;\n    \n    p.zy*=rot(pi/2.);\n    vec3 po = p;\n\n    p.y-=t*pi*4.339;\n    \n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    p.xz*=rot(-0.05*(iTime/3.));\n    p = spiral(p,6.6);\n    p = spiral(p,2.);\n    p = spiral(p,1.);\n    p = spiral(p,0.4);\n    //there are some small artifacts but you dont notice them ;) \n    \n    \n    //p = spiral(p,0.1);\n    //vec2 d = abs(p.xz);\n    //a.x = max(d.x,d.y)-1.0;\n    a.x = length(p.xz)-0.1;\n    //a.x = max((abs(po.y)-7.),a.x);\n    a.x*=0.6;\n    return vec2(a);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,0.,-1.)*1.5;\n    if(iMouse.z>0.){\n    ro.yz*=rot(3.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.9)+uv.x*r+uv.y*cross(f,r));  \n    vec3 p = ro;\n    float dO = 0.;\n    bool hit = false;\n    vec2 d= vec2(0);\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n\n        if(abs(d.x)<0.005||i>STEPS-1.5){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    if(hit)\n    {\n        vec3 ld = normalize(-vec3(p.x,p.y,p.z-5.));\n      \n        //sss from nusan\n        float sss=0.01;\n        for(float i=1.; i<20.; ++i){\n            float dist = i*0.35;\n            sss += smoothstep(0.,1.,map(p+ld*dist).x/dist)*0.18*1.25;\n        }\n        for(float i=1.; i<5.; ++i){\n            float dist = i*0.7;\n            sss += smoothstep(0.,1.,map(p-ld*dist).x/dist)*0.25;\n        }\n        vec3 al = vec3(0.204,0.267,0.373);\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        float diff = max(0.,dot(n,ld));\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),40.0);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n\n        col = al*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3;\n        col+=sss*hsv(vec3(0.76,0.9,1.35));\n        col*=mix(ao,1.,0.5);\n        col = pow(col,vec3(0.7));\n    }\n    vec3 bg = mix(vec3(0.094,0.000,0.200),vec3(0.600,0.000,0.600),length(rd.xy)-0.65);\n    \n    col = mix(col,bg,pow(dO/MDIST,2.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 169, 169, 338], [339, 393, 422, 422, 921], [924, 924, 941, 941, 1515], [1516, 1516, 1534, 1534, 1662], [1664, 1664, 1721, 1721, 3637]], "test": "untested"}
{"id": "sld3zn", "name": "Tater @ Inércia Shader Royale", "author": "Tater", "description": "My shader from the 2021 Inércia Shader Royale, I got eliminated just a few seconds before I finished the blue twisty and voronoi effect, but I finished it afterwards and include it here. \n\nVOD: [url]https://www.youtube.com/watch?v=6xvZTxv6QYc[/url]", "tags": ["3d", "raymarching", "voronoi", "terrain", "demoscene", "showdown", "livecode", "inercia", "royale"], "likes": 31, "viewed": 582, "published": 3, "date": "1635632184", "time_retrieved": "2024-07-30T18:51:39.979160", "image_code": "#define STEPS 128.0\n#define MDIST 128.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.,1.)\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define fGlobalTime iTime\n#define fft texelFetch( iChannel0, ivec2(10,0), 0 ).x*20.0\nfloat psin(float x, float b){\n  float xx = floor(b*x)/b;\n  return sin(xx)+(sin(floor(b*x+1.0)/b)-sin(xx))*mod(b*x,1.0);\n}\n//Voronoi Found in https://www.shadertoy.com/view/3ddGzn\n//Adapted it to 3d and fixed some of the artifacts\nvec2 vor(vec2 m, vec3 p, vec3 s){\n  float scl = 0.2;\n  vec3 c = round(scl*p+s);\n  c+=sin(fract(72985.*sin(dot(c,c.yzx+33.3)))*6.+fGlobalTime*3.)*0.3;\n  c*=(1./scl);\n  float v = length(c - p);\n  return v<m.x?vec2(v,m.x):v<m.y?vec2(m.x,v):m;\n}\n//I failed to understand Javad Taba's \n//Artical on rope fractals so this is my shitty\n//approximation\nvec3 spiral(vec3 p, float R){\n  p.xz*=rot(p.y/R);\n  vec2 s = sign(p.xz);\n  p.xz = abs(p.xz)-R*0.5;\n  p.xz*=rot(fGlobalTime);\n  float poy = p.y;\n  p.y = 0.;\n  p.yz*=rot(mix(0.,pi/4.,1./(R*0.5+1.5)))*-sign(s.x*s.y);\n  p.y = poy;\n  return p;\n}\nfloat wavey = 0.;\nvec2 map(vec3 p){\n\n  float t = mod(fGlobalTime,150.);\n  vec3 po2 = p;\n  p.z+=t*30.;\n  p.xz*=rot(0.4);\n  vec3 po = p;\n  vec2 a = vec2(1);\n  vec2 b = vec2(2);\n  vec2 c = vec2(3);\n  \n  //TRIANGLE PLANE\n  p.xz*=0.9;\n  p.y+=psin(p.x*0.1,2.)*4.*sin(t+p.x*0.01);\n  p.xz*=rot((2.*pi)/3.);\n  p.y+=psin(p.x,0.2)*3.*sin(t*2.+p.x*0.05);\n  p.xz*=rot((2.*pi)/3.);\n  p.y+=psin(p.x,0.2)*3.*sin(t*2.+p.x*0.04);\n  p.xz*=rot((2.*pi)/3.);\n  \n  //HEX LATTICE\n  vec3 p2 = p;\n  p2.y+=fft*0.01;\n  float m = 5.;\n  p.x = pmod(p.x-m*0.5,m);\n  b.x = length(p.xy)-0.2;\n  p = p2;\n  p.xz*=rot((2.*pi)/3.);\n  p.x = pmod(p.x-m*0.5,m);\n  b.x = min(b.x,length(p.xy)-0.2);\n  p = p2;\n  p.xz*=rot((2.*pi)/3.);\n  p.xz*=rot((2.*pi)/3.);\n  p.x = pmod(p.x-m*0.5,m);\n  b.x = min(b.x,length(p.xy)-0.2);\n \n  a.x = p.y+1.;\n  \n  a = (a.x<b.x)?a:b;\n  \n  //BIAS THE LATTICE\n  p = po;\n  a.x*=0.7;\n  c.x = p.y;\n  a.x = mix(c.x,a.x+0.1,1.15); //this was a lucky find\n  \n  //VORONOI\n  vec3 r = po2;\n  \n  r.y-=t*0.5;\n  r.xy*=rot(pi/4.);\n  vec2 s = vec2(0.5,-0.5);\n  vec2 vd =\n  vor(vor(vor(vor(vor(vor(vor(vor(vec2(5),\n  r,s.xxx) ,r,s.xxy) ,r,s.xyx) ,r,s.xyy),\n  r,s.yxx) ,r,s.yxy) ,r,s.yyx) ,r,s.yyy);\n  float h = vd.y-vd.x;\n  \n  //WAVES\n  p = po2;\n  float wav = 0.;\n  p.xz*=0.5;\n  wav+=sin(p.z*0.8+t)*0.1+sin(p.x*0.8+t)*0.2;\n  wav+=sin(p.z*0.3-t*2.)*0.2+sin(p.x*0.3-t*2.)*0.2;\n  wav+=sin(length(p.xz)*0.3+t*3.0);\n  p.y+=wav*5.0;\n  b.x = p.y;\n  \n  float v = mix(b.x,0.01,sat(1.-h));\n  b.x = max(b.x,v+0.1);\n  \n  //TWIST\n  p = po2;\n  p = spiral(p,25.+fft*0.3);\n  p = spiral(p,10.);\n  p = spiral(p,4.);\n  p = spiral(p,1.5);\n  \n  c.x = length(p.xz)-0.5;\n  c.x*=0.8;\n  b = (b.x<c.x)?b:c;\n  \n  \n  a.x = mix(a.x,b.x*0.8,wavey);\n  a.y = mix(a.y,b.y,wavey);\n  \n  return a;\n}\n\n//Anti-unroll normals (not live coded) \n#define ZERO (min(iFrame,0))\nvec3 norm(vec3 p){\n    \n   \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.2);\n  float t= fGlobalTime+1.5;\n  wavey = smoothstep(-0.25,0.3,sin(t*0.4));\n  //wavey = 1.;\n  uv-=0.2*(1.0-wavey);\n  \n  uv.xy*=rot((1.0-wavey)*sin(t*1.5+pi/2.)*0.05);\n\n  vec3 ro = vec3(0,3,-5)*5.5;\n  ro.zy+=(sin(t*1.5)*8.+3.);\n  \n  vec3 ro2 = vec3(0,5,7)*10.;\n  ro2.xz*=rot(t*0.3);\n  ro = mix(ro,ro2,wavey);\n  \n  vec3 lk = vec3(0,0.+wavey*6.,30.*(1.0-wavey));\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = normalize(f*mix(0.3,0.7,wavey)+uv.x*r+uv.y*cross(f,r));\n  \n  vec3 p = ro;\n  vec2 d= vec2(0);\n  float dO = 0.;\n  float shad = 0.;\n  bool hit = false;\n  for(float i = 0.; i<STEPS; i++){\n    p = ro+rd*dO;\n    d = map(p);\n    dO+=d.x;\n    if(abs(d.x)<0.005||i==STEPS-1.){\n      shad = i/STEPS;\n      hit = true;\n      break;\n    }\n    if(dO>MDIST){\n      dO = MDIST;\n      break;\n    }\n  }\n  vec3 bg = mix(vec3(0.5,0.4,0.85),vec3(0.45,0.45,0.9),clamp(rd.y*5.,-1.,1.));\n  if(hit){\n    vec3 n = norm(p);\n    vec3 ld = normalize(vec3(20,45,0)-p);\n    vec3 rr = reflect(rd,n);\n    float diff = max(0.,dot(n,ld));\n    float amb = dot(n,ld)*0.5+0.5;\n    float spec = pow(max(0.,dot(rr,ld)),40.);\n    vec3 al = vec3(0.2,0.25,0.75);\n    #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n    float ao = AO(0.3,n,p)*AO(0.5,n,p)*AO(0.9,n,p);\n    float sss = 0.;\n    for(float i = 0.; i<20.; i++){\n      float dist = i*0.09;\n      sss+=smoothstep(0.,1.,map(p+ld*dist).x/dist)*0.033; \n    }\n    \n    \n    if(d.y==2.0) al*=2.;\n    col = vec3(1.0-shad);\n    col = al*mix(vec3(0.3,0,0.3),vec3(1),mix(diff,amb,0.25));\n    col+=spec*0.3*bg;\n    col+=sss*0.3;\n    col*=mix(ao,1.0,0.3);\n    col = pow(col,vec3(0.7));\n    \n    //WAVEY COLOR\n    sss = 0.1;\n    float ssmag = 1.;\n    ld = normalize(vec3(0,120,0)-p);\n    if(d.y==3.0){ld = normalize(vec3(p.x,0,p.z));\n    ssmag = 1.5;\n    sss = 0.2;\n    }\n    spec = pow(max(.0,dot(rr,ld)),20.0);\n    vec3 wcol = vec3(0);\n    al = vec3(0.2,0.6,1);\n    //sss by nusan\n    for(float i = 0.; i<20.; i++){\n      float dist = i*0.3;\n      sss+=smoothstep(0.,1.,map(p+ld*dist).x/dist)*0.06*ssmag; \n    }\n    wcol = mix((1.0-shad),1.,0.5)*vec3(sss)*al;\n    wcol+=spec*0.3;\n    col = mix(col,wcol,wavey);\n  }\n  col = mix(col,bg,pow(dO/MDIST,2.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sld3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 295, 295, 387], [388, 496, 529, 529, 737], [738, 841, 870, 870, 1081], [1100, 1100, 1117, 1117, 2813], [2884, 2884, 2902, 3009, 3212], [3215, 3215, 3272, 3272, 5590]], "test": "untested"}
{"id": "Ntt3Rr", "name": "Fractal weirdness 4", "author": "jarble", "description": "A fractal pattern that looks almost 3-dimensional.", "tags": ["fractal", "parallax", "illusion"], "likes": 9, "viewed": 278, "published": 3, "date": "1635618139", "time_retrieved": "2024-07-30T18:51:40.800963", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv1 = ((fragCoord)*10.0-iResolution.xy)/iResolution.y/60.;\n    uv1.y -= 2.3;\n    //uv1 += iTime/160.;\n    for(int c=0;c<3;c++){\n        vec2 uv = uv1;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract((uv.y+uv.x+uv-iTime/8.))-.5;\n            uv *= (uv.y-uv.x)*(3.);\n            col[c] += (uv.y-uv.x);\n            col.yx += (uv.xy/16.);\n            col = col.yzx;\n        }\n\n\t}\n    \n    fragColor = vec4(fract(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntt3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 547]], "test": "untested"}
{"id": "NldGRr", "name": "Footwear Design 002", "author": "yasuo", "description": "・Improved the outsole and upper shape\n・Added the herringbone traction pattern\n", "tags": ["footwear"], "likes": 8, "viewed": 228, "published": 3, "date": "1635616255", "time_retrieved": "2024-07-30T18:51:41.634733", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL_OUTSOLE 0\n#define MATERIAL_MIDSOLE1 1\n#define MATERIAL_MIDSOLE2 2\n#define MATERIAL_UPPER 3\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    vec3 prevP = p;\n    float d = baseOutsole(p,0.02);\n    \n    // herringbone traction\n    p.xz*=2.3;\n    p.xz = mod(p.xz,0.1)-0.05;\n    p.x=abs(p.x)-0.03;\n    p.xz*=Rot(radians(45.0));\n    float d2 = sdBox(p,vec3(0.01,0.02,0.06))*0.6;\n    \n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.01,0.0),0.01);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec2 midsole(vec3 p){\n    float d = baseOutsole(p-vec3(0.0,0.06,0.0),0.04);\n    \n    p.yz*=Rot(radians(-3.0));\n    float mask = p.y-0.07;\n    d = max(mask,d);\n    \n    vec2 model = vec2(d,MATERIAL_MIDSOLE1);\n    \n    return model;\n}\n\nfloat upperBase(vec3 p){\n    vec3 prevP = p;\n\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.09);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-3.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.13),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.12));\n    d = opSmoothUnion(d,d2,0.15);\n\n    p = prevP;\n    p.yz*=Rot(radians(-15.0));\n    d2 = sdBox(p-vec3(0.0,0.14,-0.378),vec3(0.02,0.11,0.0005))-0.005;\n    d = opSmoothUnion(d,d2,0.03);\n\n    p = prevP;\n    p.yz*=Rot(radians(-3.0));\n    d2 = baseOutsole(p-vec3(0.0,0.08,0.0),0.01);\n    d = opSmoothUnion(d,d2,0.015);\n\n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.4;\n    \n    \n    float d2 = upperBase(p-vec3(0.0,-0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.8;\n    p.z*=0.9;\n    \n    d2 =sdCappedCone(p-vec3(0.0,0.3,-0.14),0.13,0.15,0.09)*0.6;\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\n\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*300.0)*0.001;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n   // p.z+=0.1;\n    float d = outsole(p);\n    \n    vec2 model = vec2(d,MATERIAL_OUTSOLE);\n    \n    vec2 model2 = midsole(p);\n    \n    \n    d = upper(p);\n    \n    vec2 model3 =vec2(d,MATERIAL_UPPER);\n    \n    return combine(model,combine(model2,model3));\n    \n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 upperTex(vec2 uv, vec3 col){\n        vec2 prevUV = uv;\n        uv = mod(uv,0.08)-0.04;\n        uv.y-=0.03;\n        uv.x=abs(uv.x)-0.05;\n        uv*=Rot(radians(45.0));\n        \n        float d = B(uv,vec2(0.01,0.08));\n        col = mix(col,vec3(0.2,0.3,0.5),S(prevUV,d,0.0));\n        return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    float nn = noise3d(p*160.0)*0.05;\n     float nn2 = noise3d(p*20.0)*0.2;\n    if(mat == MATERIAL_OUTSOLE){\n        col = diffuseMaterial(n,rd,p,vec3(1.0,1.0,0.9))+nn;\n    } else if(mat == MATERIAL_MIDSOLE1){\n        col = diffuseMaterial(n,rd,p,vec3(0.4,0.3,0.5))+nn;\n    } else if(mat == MATERIAL_MIDSOLE2){\n        col = diffuseMaterial(n,rd,p,vec3(0.6,0.6,0.6))+nn;\n    } else if(mat == MATERIAL_UPPER){\n        \n        col = diffuseMaterial(n,rd,p,vec3(0.3,0.5,0.6)-upperTex(p.xz,col)+nn2+nn2);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 504, 504, 523], [524, 524, 549, 549, 568], [569, 569, 621, 621, 721], [723, 835, 860, 860, 1199], [1201, 1201, 1237, 1237, 1279], [1281, 1330, 1382, 1382, 1489], [1491, 1540, 1571, 1571, 1658], [1660, 1709, 1746, 1746, 1829], [1831, 1880, 1939, 1939, 2252], [2254, 2254, 2303, 2303, 2376], [2378, 2378, 2413, 2413, 2821], [2823, 2823, 2845, 2845, 3210], [3212, 3212, 3233, 3233, 3444], [3446, 3446, 3470, 3470, 4313], [4315, 4315, 4335, 4335, 4643], [4647, 4647, 4669, 4669, 5002], [5004, 5004, 5062, 5062, 5329], [5331, 5331, 5355, 5355, 5556], [5558, 5558, 5600, 5600, 5795], [5797, 5838, 5887, 5887, 6178], [6180, 6180, 6237, 6237, 6856], [6858, 6858, 6891, 6891, 7160], [7162, 7162, 7221, 7221, 7747], [7749, 7749, 7806, 7806, 8850]], "test": "untested"}
{"id": "Nlt3zn", "name": "WaveTable RayMarch LookingGlass", "author": "PsyPhi", "description": "Edited from rory618's https://www.shadertoy.com/view/4tdXR8. The idea is to use a limiting shape to create different cymatics.\n\nMouse X change view, Mouse Y change frequency. R resets, W turns off the generation of new waves, E removes restriction.\n", "tags": ["wave"], "likes": 2, "viewed": 252, "published": 3, "date": "1635609742", "time_retrieved": "2024-07-30T18:51:42.390712", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n//Wave Pattern\nfloat Wave(vec2 uv, vec2 res)\n{\n    vec2 w = texture(iChannel0, uv / res).xy;\n\tvec4 col = vec4(w.x,-w.x,w.y*w.y*2.,1.);\n   // col = mix(col,texture(iChannel1, uv / res),1.-iMouse.x/iResolution.x);\n    //fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy); //view BW\n    //fragColor = texture(iChannel2, fragCoord.xy / iResolution.xy); //view boarder\n    \n    float height = col.r-col.g;\n    \n    return height;\n}\n\n\n\n// Distance calculations\n\nfloat GetDist(vec3 p)// function for calculating distance. This is where the atual objects are coded\n{\n    \n vec2 size = iResolution.xy*vec2(0.0065,0.010);\n    \n float planeDist = p.z-0.5; // this genirates the floor plane. it is calculated by seeing how high the ray is from the ground.\n planeDist += Wave(p.xy+(size/2.),size)*0.75;\n \n float shapeMix = planeDist;   \n\n    \n    return shapeMix;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat dO=0.0; // dO is the distance to the origin\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd*dO; //current ray postion. Move in the direction of the ray (rd), by the distance the object is from the origin (dO or camera)\n        float ds = GetDist(p); //calculates distance the currenmt ray position is from the object\n        dO += ds;\t\t\t//moves the current ray position by the distance it is from the object\n        if(dO>MAX_DIST || ds<SURF_DIST) break; // has the ray position moved past the max distance, or gotten close enough to the object to stop?\n        \n    }\n    \n    return dO;\n        \n}\n\nvec3 GetNormal(vec3 p)\n{\n \tfloat d = GetDist(p);\n    vec2 e = vec2( 0.1,0);\n    \n    vec3 n = d - vec3        //this moves 0.1 in eash direction from the point and takes a distance sample used to calculate the slope of the surface\n        (\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n \tvec3 lightPos = vec3(1,0,-10); //postion of the light source\n    //lightPos.xy += vec2(sin(iTime), cos(iTime))*2.;//move light over time\n \tvec3 l = normalize(lightPos-p); //at direction is the surface from the light source\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l),0.,1.); //diffrence in angle between the normal and light vectors. clamps to 0 and 1 to prevent neg numbers\n    \n    //Shadows\n    float d = RayMarch(p+n*SURF_DIST*2., l);    //raymarch from the point towards the light. the n*SURF_DIST moves it just far enough away from the surface so that it does not stop the march due to already being at a surface.\n    if(d<length(lightPos-p))\t//Does the ray hit an object before hiting the light?\n    \t{\n            dif *= 1.;\t\t\t//If so make the point 10 times darker. Not true right now 0.1 would be 10 times.\n        }\n    \n    return dif;\n    \n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);// camera w\n    vec3 cp = vec3(sin(r), cos(r), 0.);// camera up\n    vec3 cu = normalize(cross(cw, cp));// camera u\n    vec3 cv = normalize(cross(cu, cw));// camera v\n    return mat3(cu, cv, cw);\n}\n\n\n\nvoid render( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd )\n{\n\n //vec4 color = Wave(fragCoord.xy, iResolution.xy);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //Camera\n    vec3 ro = vec3(0,0,-20); //Ray origin. Edit this to change the camera position.\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.0, 1)); //Ray direction. Normalize function returns the direction with a lenth of 1. edit this to change the direction the camera is facing\n\n    vec3 tar = vec3(0.);// eye target\n    \n    \n    \n    ro = _ro;\n    rd = _rd;\n    \n       // float f = iMouse.x/iResolution.x;\n   float f = 1.; //switches from Orth to perspective\n    \n    rd = lookAt(ro, tar, 0.)*normalize(vec3(uv, 1.0));// ray direction\n    vec3 rd_orth = lookAt(ro, tar, 0.)*normalize(vec3(0., 0., 1.0));// ray direction via orthographic projection\n    rd = mix(rd, rd_orth, f);\n\n    //float orthRectSize = 2.0 + 3.0*iMouse.y/iResolution.y;\n    float orthRectSize = 5.0;\n    vec3 ro_orth = ro + vec3(uv * orthRectSize, 0.);// ray origin \n    ro = mix(ro, ro_orth, f);\n    \n\n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd * d; //location that the raymarch function determined is the surface\n    \n    float dif = GetLight(p);// dif mean defused light\n    \n//    dif /=6.0;  //brings the distance value into the visable range?? used for testing REMOVE\n\tcol = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n    }\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(1.0);\nconst float\thorizontalAngle = radians(5.0);\nconst float\tcameraSize      = 4.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\t//vec4\tcolor = vec4( vec3(valueId), 1 );\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\trender( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n    fragColor += .05;\n    fragColor /= (1.01+5.*abs(texture(iChannel0,fragCoord/iResolution.xy).y));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float KEY_R  = 82.5/256.0;\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_E  = 69.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 l = texture(iChannel0, (fragCoord-vec2(2.5,0))/iResolution.xy).xy;\n    vec2 r = texture(iChannel0, (fragCoord+vec2(2.5,0))/iResolution.xy).xy;\n    vec2 u = texture(iChannel0, (fragCoord-vec2(0,2.5))/iResolution.xy).xy;\n    vec2 d = texture(iChannel0, (fragCoord+vec2(0,2.5))/iResolution.xy).xy;\n    vec2 ur = texture(iChannel0, (fragCoord-vec2(2.5, 2.5))/iResolution.xy).xy;\n    vec2 ul = texture(iChannel0, (fragCoord-vec2(-2.5, 2.5))/iResolution.xy).xy;\n    vec2 dr = texture(iChannel0, (fragCoord-vec2(2.5, -2.5))/iResolution.xy).xy;\n    vec2 dl = texture(iChannel0, (fragCoord-vec2(-2.5, -2.5))/iResolution.xy).xy;\n    \n    vec2 t = texture(iChannel0, fragCoord/iResolution.xy).xy; //Contains last frame\n        \n    t = mix(t,(l+r+u+d)/4.,.01); // mixes lastframe with the 4 px around it.\n    t = mix(t,(ur+ul+dr+dl)/4.,.0075); // mixes lastframe with the 4 px around it.\n        \n\tfloat DL = l.x-t.x;  //diffrences left with the last frame?\n\tfloat DR = r.x-t.x;\n\tfloat DU = u.x-t.x;\n\tfloat DD = d.x-t.x;\n    float DUR = ur.x-t.x;\n    float DUL = ul.x-t.x;\n    float DDR = dr.x-t.x;\n    float DDL = dl.x-t.x;\n    \n    t.y += (DL+DR+DU+DD+DUR+DUL+DDR+DDL)/8.; //adds the diffrenced frames?\n    t.x += t.y;\n    //t.y *= .999;\t\t\t//reduces frame for FB loop\n    \n   // float f = iMouse.y/40.;\t\t//Gets mouse y for frequency\n    float f = 1.;\n    if(iResolution.y < 285.)\n        f = 10.;\n\n    \n    if (keyIsDown(KEY_W) == false) //Adds in new wave      \n    \tt = mix(t, vec2(sin(iTime*f), cos(iTime*f)), .5*exp(-.2*length(fragCoord-iResolution.xy/2.)));\n\n    \n    vec2 border = vec2(0,0);\n    \n    if (keyIsDown(KEY_E))\n        border = texture(iChannel2, fragCoord/iResolution.xy).xy; //adds in the custom border shape\n\n    \n    if(fragCoord.x<1. || fragCoord.y<1. || fragCoord.x>iResolution.x-1. || fragCoord.y>iResolution.y-1. || border.x == 1.0 )\n        t*=0.;\n\n    \n    if ( keyIsDown(KEY_R))\n        t *= 0.;\n\n    \n    \n    fragColor = vec4(t.x,t.y,0,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat circle = step(0.25,distance(vec2(0.5),fragCoord/iResolution.xy));\n    fragColor = vec4(circle,circle,circle,1.0);\n}", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlt3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 83, 114, 114, 505], [535, 535, 637, 637, 931], [933, 933, 967, 967, 1598], [1600, 1600, 1624, 1624, 1976], [1978, 1978, 2002, 2002, 2879], [2881, 2881, 2931, 2931, 3163], [3167, 3167, 3247, 3351, 4659], [4970, 4970, 5026, 5026, 5792]], "test": "untested"}
{"id": "7l33zr", "name": "iYOYi - Ambient Occlusion ", "author": "iY0Yi", "description": "For the last few years I've been borrowing and using the ao function found on Shadertoy.\nI decided to write my own ao function and give it a try.", "tags": ["ao", "occlusion", "ambient"], "likes": 17, "viewed": 457, "published": 3, "date": "1635605571", "time_retrieved": "2024-07-30T18:51:43.144696", "image_code": "// Shoe Model from my shader.\n// \"A man from 'A LOST MEMORY'\" by iYOYi:\n// https://www.shadertoy.com/view/Ws3yW4\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MIN_DIST 0.0001\n#define MAX_DIST 30.0\n#define ITERATION 100\n\n#define SHOW_ANIM 0\nvec3 ro = vec3(0), rd = vec3(0), camup;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per) {\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdBox(vec3 p,vec3 b) {\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b) {\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b) {\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpSubstraction(in float a,in float b) {\n    return max(-a, b);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r) {\n    vec2 u = max(vec2(r + b,r + -a), vec2(0));\n    return min(-r, max (b, -a)) + length(u);\n}\n\nvoid pElongate(inout float p, in float h ) {\n    p = p-clamp(p,-h,h);\n}\n\nfloat sdFoot(vec3 p) {\n\tfloat d = MAX_DIST;\n\tfloat bsd = length(p), bsr=0.2500;\n\tif (bsd > 2.*bsr) return bsd-bsr;\n    \n\tvec3 cpFoot = p;\n\t{\n\t\tvec3 q = cpFoot;\n#if SHOW_ANIM\n        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;\n#else\n        float patapata = -.3;\n#endif\n        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));\n        cpFoot=q;\n\t}\n\tvec3 cpFoot_Main = cpFoot;\n\tcpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);\n\tpElongate(cpFoot_Main.y, 0.0125);\n\t{\n\t\tvec3 q=cpFoot_Main;\n        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n        float ycl = smoothstep(.002,.2,q.y);\n        float zcl = 1.-smoothstep(-.2,.5,q.z);\n        float zcl2 = smoothstep(-.2,.0,q.z);\n        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.075*ycl*zcl*zcl2;\n        cpFoot_Main=q;\n\t}\n\n    // Shoe\n    float d1,d2;\n\td1 = sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214));\n\td1 = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d1, 0.1438);\n\td1 = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d1, 0.0100);\n    d1 = fOpSubstractionSmooth(dot(cpFoot_Main, vec3(0,1,0)) - .00001, d1, 0.0080);\n\td1 = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d1);\n\td1 = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d1, 0.0100);\n\t\n\t// Shoe lace\n\td2 = sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d2);\n\t\n\treturn min(d1,d2);\n}\n\nfloat sdScene(vec3 p) {\n\n    return min(dot(p-vec3(0,-.026,0), vec3(0,1,0)) - .0001, sdFoot(p));\n}\n\nfloat intersect() {\n    float d = MIN_DIST;\n\n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + d * rd;\n        float res = sdScene(p);\n        res*=.5;\n        if (abs(res) < MIN_DIST)break;\n        d += res;\n        if (d >= MAX_DIST) return MAX_DIST;\n    }\n    if(d>MAX_DIST) return MAX_DIST;\n    return d;\n}\n\n// from iq's shader\nvec3 normal(vec3 p) {\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e);\n    }\n    return normalize(n);\n}\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// I found \"gain\" function in iq's article.\n// https://iquilezles.org/articles/functions\n// And modify it smoothstep like function.\nfloat gainstep(float edge0, float edge1, float x, float k) {\n    x = clamp((x-edge0)/(edge1-edge0), 0., 1.);\n    float a = .5*pow(2.*((x<.5)?x:1.-x), k);\n    return (x<.5)?a:1.-a;\n}\n\n// For the last few years I've been borrowing and using the ao function found on Shadertoy.\n// I decided to write my own ao function and give it a try.\n// I vaguely remembered the basic algorithm from various references I read about 10 years ago,\n// but I've forgotten the details and I'm sure it's incomplete.\nfloat ao(vec3 p, vec3 n, float radius, float threshold) {\n    \n    const float MAX_SAMP = 32.;\n    float ao = 0.;\n    \n    for(float i=0.; i<=MAX_SAMP; i++) {\n        vec2 rnd = hash21(i);\n        rnd = texture(iChannel0, vec2(i+1.,i-1.)/iChannelResolution[0].xy).xy;\n        // The contribution is adjusted according to the distance from the origin.\n        // http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n        float scale = i/MAX_SAMP;\n        scale = mix(.1, 1., scale*scale);\n        \n        // radians for rotate normal in hemisphere.\n        rnd.x = (rnd.x*2.-1.)*PI*.5; // (-90 to 90 degrees)\n        rnd.y = (rnd.y*2.-1.)*PI*1.;    // (-180 to 180 degrees)\n        vec3 rd = n;\n        rd.yz *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n        rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n        float raylen = radius * scale;\n        vec3 rndp = p + rd * raylen; // sampling position\n        float res = min(max(sdScene(rndp)/radius, 0.), 1.); // linear step 0 to 1\n        //res = pow(res, scale);\n        ao += res;\n    }\n    \n    ao /= float(MAX_SAMP) * threshold;\n    \n    return (ao<.5) ? min(max(ao, 0.), 1.) : gainstep(0., 1., ao, 1.5); // smooth threshold.\n}\n\n\n// \"camera\": create camera vectors.\nvoid camera(vec2 uv) {\n    const float pY = .5;\n    const float cL = 10.;\n    const vec3 forcus = vec3(0,.06,-.137);\n    const float fov = .0175;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,5.8,0);\n    pos.xz = vec2(sin(iTime*.6),cos(iTime*.6))*cL;\n    if(iMouse.z>.5)\n        pos = vec3(sin(iMouse.x/iResolution.x*TAU),sin(iMouse.y/iResolution.y*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcamup = cv;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    float hit = intersect();\n    vec3 p = ro + hit * rd;\n\n    vec3 n = normal(p);\n\n    //float ao = ao(p, n, (sin(iTime*2.)+1.1)*.05, iMouse.y/iResolution.y);\n    float ao = ao(p, n, .035, .35);\n    \n    fragColor.rgb = vec3(pow(ao, .4545));\n\tfragColor.a = 1.;\n}\n\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l33zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[526, 526, 550, 550, 620], [622, 622, 642, 642, 714], [716, 716, 742, 742, 1078], [1080, 1080, 1107, 1107, 1278], [1280, 1467, 1486, 1486, 1524], [1526, 1526, 1563, 1563, 1643], [1645, 1645, 1686, 1686, 1740], [1742, 1742, 1790, 1790, 1973], [1975, 1975, 2003, 2003, 2084], [2086, 2086, 2125, 2125, 2147], [2149, 2149, 2186, 2186, 2212], [2214, 2214, 2261, 2261, 2352], [2354, 2354, 2400, 2400, 2425], [2427, 2427, 2482, 2482, 2576], [2578, 2578, 2622, 2622, 2649], [2651, 2651, 2673, 2673, 4939], [4941, 4941, 4964, 4964, 5039], [5041, 5041, 5060, 5060, 5359], [5361, 5381, 5402, 5500, 5697], [5700, 5781, 5803, 5803, 5932], [5933, 5933, 5955, 5955, 6088], [6090, 6222, 6282, 6282, 6403], [6405, 6716, 6773, 6773, 7953], [7956, 7992, 8014, 8014, 8726], [8728, 8728, 8783, 8783, 9172]], "test": "untested"}
{"id": "NdVXWy", "name": "Glass And Metal Tubing", "author": "Shane", "description": "Creating an antialiased, glass and metal, animated two-tiled hexagonal Truchet scene in realtime.", "tags": ["reflection", "refraction", "glass", "truchet", "metal", "reprojection"], "likes": 65, "viewed": 1045, "published": 3, "date": "1635602979", "time_retrieved": "2024-07-30T18:51:44.314569", "image_code": "/*\n\n\tGlass And Metal Tubing\n\t----------------------\n    \n    See Buffer A.    \n\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // The other buffer has a maximum Y-resolution of 540 set, which \n    // means any pixels outside that are mot rendered. On a 1980x1080\n    // fullscreen resolution, this means roughly a quarter of the pixels\n    // are rendered, which is a huge saving. Of course, this also means\n    // that the scene needs to be upscaled, which will make things less\n    // crisp, but you can't have everything. :)\n    //\n    // By the way, this tip came from Shadertoy user, spalmer, who has\n    // a heap of interesting work for anyone interested:\n    // https://www.shadertoy.com/user/spalmer\n    //\n    const float maxRes = 540.;\n    vec2 uv = fragCoord/iResolution.xy;\n    // If the resolution exceeds the maximum, upscale.\n    if(iResolution.y>maxRes) uv = (fragCoord/iResolution.xy - .5)*maxRes/iResolution.y + .5;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = sqrt(col);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n\tGlass And Metal Tubing\n\t----------------------\n\n    Creating an antialiased, glass and metal, animated two-tiled \n    hexagonal Truchet scene in realtime. I put this together some \n    time ago, but took a while to put in the finishing touches. It \n    runs at full speed in the large canvas window on my laptop, but \n    it's pretty GPU intensive, so apologies in advance for anyone \n    who experiences slowdown.\n    \n    There are more than a few challenges associated with creating\n    glassy materials in a shader. For anything but the simplest of\n    scenes, execution speed is definitely one of them, as you require \n    multiple bounces -- For this particular example, any fewer than 5 \n    won't look right. On top of that, the finished product tends to \n    look more sparkly and aliased than usual due to contrasty edges. \n    There's an easy solution, and that is to use multisampling on \n    each frame.\n    \n    Unfortunately, that's not viable. Rendering slightly offset pixel\n    samples to a buffer then combining can help mitigate the aliasing\n    to a degree, but with a moving camera, you're then left with \n    temporal camera ghosting. That too can be mitigated with IQ's \n    awesome temporal camera reprojection code -- Speaking of helpful \n    material, going to fullscreen won't utterly slay performance\n    thanks to spalmer's maximum resolution and upscaling idea.\n    \n    Once you've solved those problems, you're still left with ghosting\n    due to objects that move relative to the camera, and unfortunately,\n    there's not a lot that can be done about it... so I'm declaring any\n    motion blur effects a feature. :D Seriously though, if someone\n    knows a way around that, I'd love to hear it.\n    \n    I guess the last thing I should mention is that the distance\n    field is an animated two-tiled hexagon Truchet, which wasn't as\n    difficult to produce as I thought it'd be. However, it wasn't \n    particularly easy either. Anyway, hopefully the code will make\n    it easier for the next person who wants to try it. :) By the way,\n    I have one that includes a crossover tubing tile that I'll\n    post later.    \n    \n\n    \n    Useful examples:\n\n\t// An old favorite. Simple and pretty.\n    Spout - P_Malin\n\thttps://www.shadertoy.com/view/lsXGzH\n\n    // If you're trying to implement a basic multipass refraction and reflection \n    // example, I'd recommend this one. There are subtle differences, but I'm\n    // using similar logic. I adopted some of the naming conventions as well.\n    Glass Polyhedron - Nrx\n    https://www.shadertoy.com/view/4slSzj\n    \n    // 3D temporal reprojection: IQ puts up a lot of difficult to find code with\n    // very little fanfare. This is one example.\n    Some boxes - iq\n    https://www.shadertoy.com/view/Xd2fzR\n    \n    // A fullscreen upscaling example, amongst other things.\n    Lights, Camera, Action! - spalmer \n    https://www.shadertoy.com/view/sdKXD3\n \n*/\n\n// Make use of IQ's well written temporal reprojection code. Unfortunately, \n// if you have a slow machine, all you'll see is blur, so you'll need\n// to turn it off.\n#define REPROJECTION\n\n// Use the simpler (and faster) square Truchet tiles. In fact, I prefer\n// this, since it's faster and looks more antialiased. However, I figured \n// people would appreciate the alternative two tiled animated hexagon \n// Truchet, which is by far the more unique of the two.\n//#define SQUARE_TRUCHET\n\n// Ray passes: For this example, this is about the minimum I could\n// get away with. However, not all passes are used on each pixel, so\n// it's not as bad as it looks.\n#define PASSES 5\n\n// Far plane, or max ray distance.\n#define FAR 20.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(23.527, 57.683)))*43758.5453); }\n\n/*\n// Based on the UE4 random function: I like this because it incorporates a modulo\n// 128 wrap, so in theory, things shouldn't blow up with increasing input. Also, \n// in theory, you could tweak the figures by hand to get a really scrambled output... \n// When I'm feeling less lazy, I might do that.\n//\n// By the way, GPU's are fickle things, so if this isn't working on your\n// system, feel free to let me know.\nfloat hash21(vec2 p) {\n    \n    p -= floor(p/128.)*128. + vec2(64.340627, 72.465623);\n    return fract(dot(p.xyx*p.xyy, vec3(20.390625, 60.703123, 2.4281207)));\n    \n    // My own experimental hash. Seems to work for the right range, but \n    // I don't trust it yet.\n    //p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    //return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n    \n    // Another, based on the \"17*17 = 289\" thing.\n    //float x = dot(p, vec2(97, 37));\n    //x *= 288./289.;                \n    //x = (x - floor(x))*289.;                         \n    //x = (x*34. + 113.)*x/289.;                       \n    //return x - floor(x);    \n \n}\n*/\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// Vector container for the object IDs. We make a note of the individual\n// identifying number inside the main distance function, then sort them\n// outside of it, which tends to be faster.\nvec4 vObjID; \n\n\n#ifdef SQUARE_TRUCHET\n\n// The scene. All of it is pretty standard. There's a wall, extruded\n// hollowed out Truchet tubing and some metallic elements. To be honest, \n// this was a little rushed, but the field doesn't have a lot going on, \n// so tightening it up wasn't as important as it sometimes is.\nfloat map(vec3 p){\n    \n    // Back wall\n    float wall = -p.z + .01; // Thick wall: abs(p.z - .2) - .21;\n     \n    // Truchet object and animated metallic balls: This is just a\n    // standard 2D animated Truchet with an extruded factor. If you're\n    // not sure how it works, myself and others have plenty of \n    // animated Truchet examples on Shadertoy to refer to.\n    //\n    // Grid construction: Cell ID and local cell coordinates.\n    const vec2 GSCALE = vec2(1./3.);\n    const vec2 sc = 1./GSCALE, hsc = .5/sc;    \n    vec2 iq = floor(p.xy*sc) + .5;    \n    vec2 q = p.xy - iq/sc; // Equivalent to: mod(p.xy, 1./sc) - .5/sc;\n    \n    // Flip random cells. This effectively rotates random cells,\n    // but in a cheaper way.\n    float rnd = hash21(iq + .37);\n    if(rnd<.5) q.y = -q.y;\n      \n    // Circles on opposite square vertices.\n    vec2 d2 = vec2(length(q - hsc), length(q + hsc));\n    // Using the above to obtain the closest arc.\n    float crv = abs(min(d2.x, d2.y) - hsc.x);\n    \n    // Flipping the direction on alternate squares so that the animation\n    // flows in the right directions -- It's a standard move that I've\n    // explained in other examples.  \n    float dir = mod(iq.x + iq.y, 2.)<.5? -1. : 1.;\n    // Using repeat polar coordinates to create the moving metallic balls.\n    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);\n    pp *= rot2(iTime*dir); // Animation occurs here.\n    float a = atan(pp.y, pp.x); // Polar angle.\n    a = (floor(a/6.2831853*8.) + .5)/8.; // Repeat central angular cell position.\n    // Polar coordinate.\n    vec2 qr = rot2(a*6.2831853)*pp; \n    qr.x -= hsc.x;\n     \n    // Ridges, for testing purposes.\n    //crv += clamp(cos(a*16. + dir*iTime)*2., 0., 1.)*.003;\n    \n    // A rounded square Truchet tube. Look up the torus formula, if you're\n    // not sure about this. However, essentially, you place the rounded curve\n    // bit in one vector position and the Z depth in the other, etc. Trust me,\n    // it's not hard. :)\n    float tr = length(vec2(crv, (p.z) + .05/2. + .02)) - .05;\n    //float tr = sBoxS(vec2(crv, (p.z) + .05/2. + .02), vec2(.05, .05), .035);\n    \n    \n \n    // Metallic elements, which includes the joins, metal ball joints\n    // and the tracks they're propogating along. This operation needs to be\n    // performed prior to hollowing out the tubes. See below.\n    q = abs(abs(q) - .5/sc);\n    float mtl = min(q.x, q.y) - .01;\n    mtl = max(max(mtl, tr - .015), -(tr - .005));\n    \n    // Adding in the railing.\n    float rail = tr + .035 + .01;\n    \n\n    // 3D ball position.\n    vec3 bq = vec3(qr,  p.z + .05/2. + .02);\n    //float ball = max(length(bq.zx) - .02, abs(bq.y) - .03);\n    float ball = length(bq) - .02; // Ball.\n    //ball = abs(ball + .005) - .005; // Hollow out.\n    \n    float mtl2 = ball;//max(ball, -(rail - .0025));\n    mtl = min(mtl, rail);\n    \n    // Hollowing out the Truchet tubing. If you don't do this, it can cause\n    // refraction issues, but I wanted the tubes to be hollow anyway.\n    tr = max(tr, -(tr + .01 + .01));\n\n    // Debug: Take out the glass tubing.\n    //tr += 1e5;\n    \n    // Storing the object ID.\n    vObjID = vec4(wall, tr, mtl, mtl2);\n    \n    // Returning the closest object.\n    return min(min(wall, tr), min(mtl, mtl2));\n \n}\n\n#else\n\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    //vec4 h = p.xyxy - vec4(hC.xy + .5, hC.zw)*s.xyxy;\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n\n// The hexagon field.\nfloat map(vec3 q){\n\n    // Debug usage to compare rigid moving objects with\n    // objects that flow with the Truchet tubing.\n    #define RIGID_OBJECTS\n\n    // Scaling factor.\n    const float sc = 2.;\n    \n    // Moving object time; A bit redundant here, but helpful when \n    // you want to change the speed without having to refactor everywhere.\n    float tm = iTime;\n  \n\n    // Back wall\n    float wall = -q.z + .1; // Thick wall: (abs(p.z - .2) - .2) + .1;\n\n\n    // Local hexagonal cell coordinate and cell ID.\n    vec4 h = getGrid(q.xy*sc);\n    \n    // Using the idetifying coordinate - stored in \"h.zw,\" to produce a unique random number\n    // for the hexagonal grid cell.\n    float rnd = hash21(h.zw + vec2(.11, .31));\n    //rnd = fract(rnd + floor(iTime/3.)/10.); // Periodically changing the random number.\n    float rnd2 = hash21(h.zw + vec2(.37, 7.83)); // Another random number.\n   \n    \n    // It's possible to control the randomness to form some kind of repeat pattern.\n    //rnd = mod(h.z + h.w, 2.)/2.;\n    \n    \n    // Storing the local hexagon cell coordinates in \"p\". This serves no other\n    // purpose than to not have to write \"h.xy\" everywhere. :)\n    vec2 p = h.xy;\n    \n\n    // Using the local coordinates to render three arcs, and the cell ID\n    // to randomly rotate the local coordinates by factors of PI/3.\n    rnd = floor(rnd*144.);\n    \n    // Random rotation and flow direction..\n    float dir = mod(rnd, 2.)*2. - 1.;\n    float ang = rnd*3.14159/3.;\n\n    p = rot2(ang)*p; // Random rotate.\n    \n    \n    // Arc radii and thickness variables.\n    const float rSm = s.y/6.; // .5/1.732 -> 1.732/2./3.\n    const float th = .1; // Arc thickness.\n\n    // The three segment (arc) distances.\n    vec3 d;\n    \n   \n    // Metal.\n    float mtl = 1e5;\n \n    #ifndef RIGID_OBJECTS\n    // Angle for non rigid objects.\n    float a3;\n    #endif\n    \n    // The Truchet distance.\n    float tr = 1e5;\n    \n    // A scaling constant.\n    const float aSc = 1.;\n    \n    // Is the piece and arc or not. This is an orientation hack that I'll\n    // fix later.\n    float isArc = 1.;\n    \n    // Z-based value and a redundant height value that gets used in\n    // another example.\n    vec3 qZ3, hgt = vec3(0);\n    \n    // Rotation and minimum coordinate.\n    vec2 qR, minP;\n    \n    if(rnd2<.5){\n    \n        // Relative local coordinate centers of the two arc and line.\n        vec2 p0 = p - vec2(0, -s.y/3.);\n        vec2 p1 = p - vec2(0, s.y/3.);\n        vec2 p2 = p;\n        // Distances.\n        d.x = length(p0) - rSm;\n        d.y = length(p1) - rSm;\n        d.z = abs(p2.y);\n        \n        d = abs(d)/sc; // Turning the circles into arc segments and scaling.\n\n        // Move the Z-position out to the correct position for all three tubes. \n        // There's a redundant relative height value there for crossover tubes.\n        qZ3 = q.z + .045 + hgt;\n\n        // A rounded or square Truchet tube. Look up the torus formula, if you're\n        // not sure about this. However, essentially, you place the rounded curve\n        // bit in one vector position and the Z depth in the other, etc. Trust me,\n        // it's not hard. :)\n\n        // Technically, I could get away with using the minimum 2D arc length and \n        // calculate just one of these, but I'll be extending to include crossover\n        // arcs, so I'll leave it in this form.\n        d.x = length(vec2(d.x, qZ3.x)) - .05;\n        d.y = length(vec2(d.y, qZ3.y)) - .05;\n        d.z = length(vec2(d.z, qZ3.z)) - .05;\n    /*    \n        d.x = sBoxS(vec2(d.x, qZ3.x), vec2(.05, .05), .025);\n        d.y = sBoxS(vec2(d.y, qZ3.y), vec2(.05, .05), .025);\n        d.z = sBoxS(vec2(d.z, qZ3.z), vec2(.05, .05), .025);\n    */    \n\n        \n        \n        // Arc segment angle calculation.\n        if(min(d.x, d.y)<d.z){\n            \n            // Minimum \n            minP = p1;\n            \n            // Reverse the direction of the first arc.\n            if(d.x<d.y) {\n               minP = p0; \n               dir *= -1.;\n            }\n            \n            #ifdef RIGID_OBJECTS\n            minP *= rot2(dir*tm); // Animation occurs here.\n            float a = atan(minP.y, minP.x); // Polar angle.\n            a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.\n            // Polar coordinate.\n            qR = rot2(a*6.2831853)*minP; \n            qR.x -= rSm; \n            #else\n            a3 = atan(minP.x, minP.y);\n            a3 = (a3*(6./6.2831)*aSc - tm*dir);\n            #endif\n            \n        }\n        else {\n            \n            // I guessed a time dialation figure of 3.14159 based on the relative \n            // length of a full circle tube (broken into thirds) and a straight\n            // tube (broken into thirds). Pure fluke, but I'll take it. :)\n            // Circle tube: length = diameter*PI;\n            // Straight tube:  length = diameter;\n            // Basically, the objects in the tube will travel just a few percentage\n            // points slower than those in the arcs in order to meet up perfectly, \n            // but you'll never notice.\n            minP = p2;\n            #ifdef RIGID_OBJECTS\n            qR = p2;\n            qR.x = mod(qR.x - dir*tm/3.14159, 1./3.) - 1./6.;\n            isArc = 0.; // Not an arc piece.\n            #else\n            a3 = minP.x;\n            a3 = (a3*(3.)*aSc - tm*dir - aSc*.5);\n            #endif\n            \n        }\n\n    }\n    else {\n    \n        vec2 p0 = p - vec2(-.5, -.5/s.y);\n        vec2 p1 = p - vec2(.5, -.5/s.y);\n        vec2 p2 = p - vec2(0, s.y/3.);\n        d.x = length(p0) - rSm;\n        d.y = length(p1) - rSm;\n        d.z = length(p2) - rSm;\n        \n        d = abs(d)/sc; // Turning the circles into arc segments and scaling.\n\n        // Move the Z-position out to the correct position for all three tubes.\n        qZ3 = q.z + .045 + hgt;\n\n        // A rounded or square Truchet tube.\n        d.x = length(vec2(d.x, qZ3.x)) - .05;\n        d.y = length(vec2(d.y, qZ3.y)) - .05;\n        d.z = length(vec2(d.z, qZ3.z)) - .05;\n    /*    \n        d.x = sBoxS(vec2(d.x, qZ3.x), vec2(.05, .05), .025);\n        d.y = sBoxS(vec2(d.y, qZ3.y), vec2(.05, .05), .025);\n        d.z = sBoxS(vec2(d.z, qZ3.z), vec2(.05, .05), .025);\n    */    \n        \n        // Since the moving objects reside within the tubes, the minimum 3D arc \n        // distance should provide the minimum coordinate upon which to calculate \n        // the angle of the object flowing through it... It will work with this \n        // example, but sometimes, you'll have to calculate all three.\n        minP = d.x<d.y && d.x<d.z? p0 : d.y<d.z? p1 : p2;\n        \n        ///// \n        #ifdef RIGID_OBJECTS\n        \n        minP *= rot2(dir*tm); // Animation occurs here.\n        float a = atan(minP.y, minP.x); // Polar angle.\n        a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.\n        // Polar coordinate.\n        qR = rot2(a*6.2831853)*minP; \n        qR.x -= rSm; \n        \n        #else\n      \n        // Calculating, scaling and moving the angles.\n        a3 = atan(minP.x, minP.y);\n        a3 = (a3*(6./6.2831)*aSc - tm*dir);\n        \n        #endif\n        ///// \n    \n    }\n    \n    // The Truchet tube distance is the minimum of all. I could save a couple\n    // of \"min\" calls and set this above, but this will do.\n    tr = min(min(d.x, d.y), d.z);\n \n\n    ///// \n    #ifdef RIGID_OBJECTS\n    \n    // 3D ball position. \"qR\" is based on \"p,\" which has been scalle\n    // by the factor \"sc,\" so needs to be scaled back. \"q.z\" has not been\n    // scaled... Yeah, it can be confusing. :)\n    vec3 bq = vec3(qR/2.,  qZ3.x); // All heights are equal, in this example.\n    //if(isArc==0.) bq = bq.yxz;\n    //float obj =  max(length(bq.zx) - .02, abs(bq.y) - .04); // Cylinder.\n    float obj = length(bq) - .02; // Ball.\n    // obj = min(tr + .035 + .01, ball); // Adding in the railing.\n    \n    #else\n   \n    a3 = abs(fract(a3) - .5) - .25;\n    a3 /= (6.*aSc/sc);\n    float obj = max(tr + .0325, a3);\n    \n    #endif\n    ///// \n    \n    \n    // Metallic elements, which includes the joins, metal ball joints\n    // and the tracks they're propogating along.\n    //\n    // Joins.\n    vec2 rp = p;\n    rp *= rot2(-3.14159/6.); // Animation occurs here.\n    float a = atan(rp.y, rp.x); // Polar angle.\n    a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.\n    // Polar coordinate.\n    rp = rot2(a*6.2831853)*rp; \n    rp.x -= .5; // Moving the element along the radial line to the edge.\n\n    // Construct the joiner rings.\n    rp = abs(rp);\n    mtl = rp.x - .02;//max(rp.x, rp.y) - .025;\n    mtl = max(max(mtl, tr - .015), -(tr - .005));\n    \n    // Tracks.\n    mtl = min(mtl, tr + .045);\n    \n\n    \n    \n    // Hollowing out the Truchet tubing. If you don't do this, it can cause\n    // refraction issues, but I wanted the tubes to be hollow anyway. I've \n    // made the walls kind of thick. Obviously, the thickness can effect\n    // the way light bounces around, and ultimately the look.\n    tr = max(tr, -(tr + .02)); \n    \n    \n   \n    // Debug: Take out the glass tubing, brackets, tracks, etc, to see the inner\n    // objects unobstructed.\n    //tr += 1e5;\n    //mtl += 1e5;\n    \n   \n    // Storing the object ID.\n    vObjID = vec4(wall, tr, mtl, obj);\n    \n    // Returning the closest object.\n    return min(min(wall, tr), min(mtl, obj));\n\n\n\n}\n#endif\n \nfloat trace(vec3 ro, vec3 rd, float distanceFactor){\n\n    float tmin = 0.;\n    float tmax = FAR;\n    \n    // IQ's bounding plane addition, to help give some extra performance.\n    //\n    // If ray starts above bounding plane, skip all the empty space.\n    // If ray starts below bounding plane, never march beyond it.\n    const float boundZ = -.11;\n    float h = (boundZ - ro.z)/rd.z;\n    if(h>0.){\n    \n        if( ro.z<boundZ ) tmin = max(tmin, h);\n        else tmax = min(h, FAR);\n    }\n \n    float t = tmin;\n    for(int i = 0; i<72; i++){\n    \n        float d = map(ro + rd*t)*distanceFactor;\n        if( abs(d)<DELTA ) return t;\n        if( t>tmax) break; \n        t += d*.9; \n    }\n\n    return FAR;\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        //if (d<0. || t>end) break; \n        // Bounding plane optimization, specific to this example. Thanks to IQ. \n        if (d<0. || t>end || (ro.z + rd.z*t)<-0.11) break;\n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n/* \n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n\n// Random hash setup.\nvec2 seed = vec2(.13, .27);\n\nvec2 hash22() {\n    \n    seed += vec2(.723, 643);\n    seed = fract(seed);\n    return fract(sin(vec2(dot(seed.xy, vec2(12.989, 78.233)), dot(seed.xy, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    #ifdef REPROJECTION\n    // Initial hit point and distance.\n    vec3 resPos = vec3(0);\n    float resT = 1e8;\n    #endif\n    \n    \n    // Setting a maximum resolution, then upscaling. I picked up this tip when\n    // looking at one of spalmer's examples, here:\n    // https://www.shadertoy.com/view/sdKXD3\n    const float maxRes = 540.;\n    float iRes = min(iResolution.y, maxRes);\n    ivec2 iR = ivec2(fragCoord);\n    if(iR.y > 0 || iR.x>3){\n        fragColor = vec4(0, 0, 0, 1);\n        vec2 uv2 = abs(fragCoord - iResolution.xy*.5) - iRes/2.*vec2(iResolution.x/iResolution.y, 1.);\n        if(any(greaterThan(uv2, vec2(0)))) return;  // if(uv2.x>0. || uv2.y>0.) return;\n       \n    }\n    \n    \n    // Screen coordinates.\n    seed += fract(iTime)*113.87;\n\t//vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 uv = (fragCoord - iResolution.xy*.5 + (hash22() - .5)/4.)/iRes;\n    \n    \n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/48.*s.y, iTime/64.*s.x, -1); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.04, -.03, .25); \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(-.5, 1, 0); \n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    mat3 mCam = mat3(rgt, up, fwd);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    // Global shadow variable and a reflection power variable. The reflection\n    // power also applies to refracted objects.\n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n   \n    // The refraction ratio for the Truchet tubing. Normally, you'd have\n    // diferent ones for different objects, but we only need one for this example.\n    float refractionRatio = 1./1.5;\n    float distanceFactor = 1.;\n     \n    float alpha = 1.;\n    \n    // Intersection and coloring for each ray and subsequent bounces.\n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd, distanceFactor);\n\n        // Objtain the ID of the closest object: With more objects, you'd use a looping\n        // mechanism, but I'd imagine this hideous expression is a little faster.\n        float svObjID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z && vObjID.x<vObjID.w)? 0. : \n                        vObjID.y<vObjID.z && vObjID.y<vObjID.w? 1. : vObjID.z<vObjID.w? 2. :  3.;\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n         \n         \n            #ifdef REPROJECTION\n            if(j==0){\n                // Only save the initial hit point and \n                // distance. Ignore other bounces.\n                resPos = sp;\n                resT = t;\n            }\n            #endif\n            \n            // Surface normal. Refractions, and therefore ray traversal inside\n            // of object surfaces are now possible, to the direction of the\n            // normal matters... This is yet one of many things that I forget\n            // when I haven't done this for a while. :)\n            vec3 sn = getNormal(sp)*distanceFactor; // For refractions.\n            \n            \n            // Texture size factor.\n            float sz0 = 2.;\n            /*\n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel1, sp*sz0, sn, .007);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            \n            vec3 reflection = reflect(rd, sn);\n            vec3 refraction = refract(rd, sn, refractionRatio);\n       \n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            float sh = 1.;\n            #if 0\n            // Shadows on each bounce.\n            sh = softShadow(sp, lp, sn, 12.);\n            gSh = min(sh + .5, 1.); // Adding brightness to the shadow.\n            #else\n            // Shadows on just two bounces.\n            if(j < 2){ \n                sh = softShadow(sp, lp, sn, 12.);\n                gSh = min(gSh, min(sh + .53, 1.)); \n            }\n            #endif\n            \n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            //float fre = clamp(1. - abs(dot(rd, sn))*.7, 0., 1.); // Fresnel reflection term.\n            \n            // Fresnel.\n            float Schlick = pow(1. - clamp(dot(rd, normalize(rd + ld)), 0., 1.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n            \n            \n            // Object color.\n            vec3 oCol;\n            \n             \n           if(svObjID == 0.){ // Back wall.\n               \n               // Texturing. \n               vec3 tx = tex3D(iChannel1, sp, sn);\n               tx = smoothstep(-.05, .5, tx);\n      \n               // Stripes.\n               vec2 q = rot2(-3.14159/3.)*sp.xy;\n               float str = abs(fract(q.x*12.) - .5)*2. - .4;\n               str = min(str, abs(str - .15) - .05);\n               oCol = mix(vec3(.5), vec3(.05), 1. - smoothstep(0., .05, str));\n               \n               oCol *= min(tx*2., 1.);\n\n               // The wall has no reflection of refraction, so setting the\n               // reflective or transmission power to zero will cause the\n               // loop to terminate early, which saves a lot of work.\n               objRef = 0.;\n\n               spe *= freS;\n\n               // Reflection only override. This ensures that no refraction\n               // will occur... It's hacky, but it works. :)\n               refraction *= 0.; \n            }\n            else if(svObjID == 1.) {  // Glass Truchet tubes.\n\n                // Coloring the glass tubes. Note that we keep the object\n                // color dark, in order to look transparent.\n                vec3 tx = tex3D(iChannel1, sp, sn);\n                tx = smoothstep(.05, .5, tx);\n                oCol = tx*.125;//*vec3(1, 2, 3); // Color.\n                objRef = 1.; \n                \n                // Faking more of a glass look.\n                oCol *= tx;\n                objRef = 1.2; \n                \n            }\n            else { // Metallic stuff.            \n            \n                // Technically, I should be moving the texture\n                // hit point of the metallic moving objects in\n                // relation to their movement, but I wanted to\n                // save the calculations. Hopefully, the sliding\n                // texture movement isn't too perceptable.\n                \n                // Joins, tracks and animated metal objects.\n                vec3 tx = tex3D(iChannel1, sp, sn);\n                tx = smoothstep(.05, .5, tx);\n                oCol = tx*vec3(.5);//*vec3(3, 1.6, .8);\n                \n                \n                objRef = .25; // Only a bit of reflectance.\n                \n                // Ramping up the diffuse on the metal joins.\n                dif = pow(dif, 4.)*4.; \n                \n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n                \n                /*\n                // The moving metal objects.\n                if(svObjID==3.){\n                   oCol *= vec3(3, 1.5, .8); // Gold option.\n                   //objRef = 1.;\n                }\n                */\n                \n            }\n            \n            // Simple coloring for this particular ray pass.\n            colL = oCol*(dif + .2 + vec3(1, .4, .2)*spe*32.);\n            \n            // Shading.\n            colL *= gSh*ao*att;\n            \n            // Used for refraction (Beer's Law, kind of), but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected or refracted direction, and \n            // bump the ray off of the hit point by a fraction of the normal distance. \n            // Anyone who's been doing this for a while knows that you need to do this to \n            // stop self intersection with the current launch surface from occurring... It \n            // used to bring me unstuck all the time. I'd spend hours trying to figure out \n            // why my reflections weren't working. :)\n \n            // You see this in most refraction\\reflection examples. If refraction is possible\n            // refract, reverse the distance factor (inside to outside and vice versa) and \n            // bump the ray off the surface. If you can't refract (internal reflection, a \n            // non-refractive surface, etc), then reflect in the usual manner. If the surface\n            // neither reflects nor refracts, the object reflectance factor will cause the\n            // loop to terminate... I could check for that here, but I want to keep the \n            // decision making simple.\n            //\n            if (dot (refraction, refraction)<DELTA){\n                rd = reflection;\n                // The ray is just behind the surface, so it has to be bumped back to avoid collisions.\n                sp += sn*DELTA*2.; \n            }   \n            else {\n\n                rd = refraction;\n                distanceFactor = -distanceFactor;\n                refractionRatio = 1./refractionRatio;\n                sp -= sn*DELTA*2.;//1.1;\n            } \n            \n \n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // Additive blend. Makes more sense for this example.\n        col += colL*alpha;///float(PASSES);\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break. Breaking saves cycles, so it's important to \n        // terminate the loop early when you can.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Object based breaking. Also possible, but I prefer the above.\n        //if(svObjID == 0.)break; \n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n        \n    }\n    \n    \n    \n    // This is IQ's temporal reprojection code: It's well written and\n    // it makes sense. I wrote some 2D reprojection code and was not\n    // looking forward to writing the 3D version, and then this \n    // suddenly appeared on Shadertoy. If you're interested in rigid \n    // realtime path traced scenes with slowly moving cameras, this is \n    // much appreciated. :)\n    //\n    #ifdef REPROJECTION\n    //-----------------------------------------------\n\t// Reproject to previous frame and pull history.\n    //-----------------------------------------------\n    \n    float kFocLen = 1./FOV;\n    vec3 pos = resPos;\n    ivec2 q = ivec2(fragCoord);\n    col = clamp(col, 0., 1.);\n\n    // fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4(texelFetch(iChannel0, ivec2(0, 0), 0),\n                           texelFetch(iChannel0, ivec2(1, 0), 0),\n                           texelFetch(iChannel0, ivec2(2, 0), 0));\n    // World space point.\n    vec4 wpos = vec4(pos, 1.);\n    // Convert to camera space (note inverse multiply).\n    vec3 cpos = wpos*oldCam;\n    // Convert to NDC space (project).\n    vec2 npos = (kFocLen*2.)*cpos.xy/cpos.z*iRes/iResolution.y;\n    // Convert to screen space.\n    vec2 spos = .5 + .5*npos*vec2(iResolution.y/iResolution.x, 1);\n\t// Convert to raster space.\n    vec2 rpos = spos*iResolution.xy;\n\n    // Read color+depth from this point's previous screen location.\n    vec4 ocolt = textureLod( iChannel0, spos, 0.);\n    // If we consider the data contains the history for this point.\n    if(iFrame>0 && resT<FAR && (rpos.y>1.5 ||rpos.x>3.5)){\n    \n        // Blend with history (it's an IIR low pas filter really).\n        col = mix( ocolt.xyz, col, 1./4.);\n    }\n    \n    // Color and depth.\n    fragColor = vec4(col, resT);\n    \n    // Output.\n\tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) fragColor = vec4(mCam[0], -dot(mCam[0], ro));\n        else if(q.x == 1) fragColor = vec4( mCam[1], -dot(mCam[1], ro));\n        else fragColor = vec4( mCam[2], -dot(mCam[2], ro));\n    } \n    #else\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    //fragColor = vec4(max(col, 0.), 1);\n    #endif\n    \n    \n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 139, 734, 1123]], "test": "untested"}
{"id": "7lcGRr", "name": "Happy Pumpkin", "author": "space928", "description": "It's a 3D pumpkin!", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 236, "published": 3, "date": "1635597016", "time_retrieved": "2024-07-30T18:51:45.559240", "image_code": "const int MARCHSTEPS = 128;\nconst float MAX_DIST = 64.;\nconst float EPSILON = 0.01;\nconst vec3 pos = vec3(0.,0.0,-3.);\nconst vec3 posTime = vec3(0.,0.0,0.);\nconst vec3 lightDir = vec3(0.6,0.6,-0.6);\nconst float rotRate = 1.;\nconst float pi = 3.1415926535;\n\n//https://iquilezles.org/articles/smin\nvec2 sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat map(vec3 p)\n{\n    //Body\n    vec3 pa = p-pos;\n    p.y *= 1.1;\n    float angle = atan(p.x, p.z);\n    float centreDist = length(p.xz);\n    float radMod = sin(angle*16.)*0.03;\n    radMod += sin(angle*120.)*0.001;\n    radMod *= (centreDist*centreDist);\n    radMod -= (smoothstep(1.2, -.8, centreDist))*0.5;\n    float d = sdSphere(p, 1. + radMod);\n    \n    //Stem\n    //Domain bending from:\n    float radMod2 = sin(angle*9.)*0.03;\n    radMod2 += sin(angle*23.)*0.005;\n    radMod2 *= smoothstep(0.02, 0.1, centreDist*centreDist);\n    radMod2 += sin(-p.x*12.)*0.05+sin(p.y*5.-1.)*0.03+sin(p.z*25.)*0.01;\n    d = sminCubic(d, sdVerticalCapsule(p, 1.1, 0.15+radMod2), 0.1).x;//sminCubic();\n    \n    //Eyes\n    d = max(d, -sdTriPrism(vec3(abs(p.x),p.y,p.z)-vec3(0.3,0.2,-1.), vec2(0.15, 1.5)));\n    \n    //Mouth\n    vec2 c = vec2(sin(0.5), cos(0.5));\n    d = min(d, sdCappedTorus(vec3(p.x,-p.y,p.z)-vec3(0.,-0.2,-0.97), c, 0.35, 0.08));\n    \n    return d;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    \n    for( int i=0;i<MARCHSTEPS;i++ ) {\n        vec3 p = o + r * t;\n        \n        float d = map(p);\n        \n        if(t > MAX_DIST) {\n            t = -1.0;\n            break;\n        }\n        \n        t += d;\n    }\n    return t;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 rotY(float x)\n{\n    return mat3(cos(x), 0., sin(x),\n                0., 1., 0.,\n                -sin(x), 0., cos(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 2.0))*rotY(iTime*rotRate);\n    vec3 o = pos*rotY(iTime*rotRate) + (iTime*posTime);\n    vec3 t = vec3(trace(o, r));\n    vec3 p = (o+r*t);\n    vec3 nrm = estimateNormal(p);\n\n    vec3 fog = vec3(0.);\n    if(t != vec3(-1.))\n    {\n        fog = 1.0 / (1.0 + t * t * 0.05);\n        fog *= clamp(dot(lightDir, nrm), 0., 1.) + vec3(0.1,0.1,0.15);\n        fog *= vec3(1., .5, .02);\n    }\n\n    // Output to screen\n    fragColor = vec4(fog,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 296, 341, 341, 488], [490, 538, 608, 608, 748], [750, 798, 851, 851, 910], [912, 960, 996, 996, 1079], [1081, 1081, 1114, 1114, 1140], [1142, 1142, 1161, 1172, 2095], [2097, 2097, 2126, 2126, 2385], [2387, 2387, 2416, 2416, 2696], [2698, 2698, 2718, 2718, 2822], [2824, 2824, 2881, 2931, 3509]], "test": "untested"}
{"id": "7t3GRr", "name": "simple cream", "author": "lomateron", "description": "just discovered kernel convolution that translates\nclick to add cream\nkey A to apply image\nkey S to delete cream", "tags": ["fluid", "convolution"], "likes": 15, "viewed": 384, "published": 3, "date": "1635594766", "time_retrieved": "2024-07-30T18:51:46.321203", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,u);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel2,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  a = A(u);\n    float b = 0.;\n    //kernel convolution\n    {\n        float z    = 4.;//kernel convolution size\n        float blur = 1./z;\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          float t  = dot(A(u+vec2(i,j)),vec4(1,0,0,0));\n          float dl = t*6.+1.5; dl = min(dl,5.);    //creaminess\n          float f  = dot(B(u+vec2(i,j)),vec4(.5)); //wall friction\n          vec2  mv =(f*t*.4)*vec2(0,1);            //translation amount\n          float s = 0.;\n          for(float i2 = -z; i2<=z;++i2){\n          for(float j2 = -z; j2<=z;++j2){\n            vec2 c = (mv+vec2(i2,j2))*blur*dl;\n            s += 1./exp(dot(c,c));\n          }}\n          if(s==0.){s = 1.;}\n          vec2 c = (mv-vec2(i,j))*blur*dl;\n          b += t/s/exp(dot(c,c));\n        }}\n    }\n    a = vec4(b,a.xyz);\n    \n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    float keyS  = texture( iChannel1, vec2(83.5/256.,.25) ).x;\n    if(keyA!=0.)a = texture( iChannel2, u/iResolution.xy);\n    if(keyS!=0.)a = vec4(0);\n    if(iMouse.z>0.)\n    {\n        vec2 m1 = 2.*(u-iMouse.xy)/iResolution.y;\n        a += .1/exp(dot(m1,m1)*222.);\n    }\n    if(iFrame==0){a = vec4(.5)*float(u.y/iResolution.y>.5);}\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3GRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 136]], "test": "untested"}
{"id": "st3GRr", "name": "octtree truchet", "author": "flockaroo", "description": "multiscale octtree truchet", "tags": ["truchet", "multiscale", "octtree"], "likes": 38, "viewed": 801, "published": 3, "date": "1635594250", "time_retrieved": "2024-07-30T18:51:47.078180", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// 3D-generalization of multi-scale-truchets (Octtree truchet)\n//\n// ...like Shanes 2D version (not sure, but i think he did it first in 2D)\n// \"Quadtree Truchet\" https://www.shadertoy.com/view/4t3BW4\n//\n// wasnt sure if it works visually in 3D - kind of crowded, but i like it a lot...\n// different regions with different truchet-scale can easily be seen.\n//\n// golfed it down, but i guess there's still potential...\n//\n// also here a (only single-scale) version on twigl in under 1 tweet:\n// https://twitter.com/flockaroo/status/1454405159224754184\n\n//my original version:\n//\n//#define Res iResolution.xy\n//#define ROT(v,x) v=mat2(cos(x),sin(x),-sin(x),cos(x))*v;\n//#define R(p) cos(((p)+(p).zxy*1.1+(p).yzx*1.3)*10.)\n//#define L(n,c) for(int i=0;i<n;i++){c;}\n//#define t iTime\n//\n//#define dd(X,p2) \\\n//{ \\\n//    vec3 p=p2; \\\n//    p+=R(p*.3)*.05; float l,d=1e3,s=2.; \\\n//    vec3 q,r; \\\n//    L(4,s*=.5;q=floor(p/s)*s;r=R(q);if(r.x<.5) break) \\\n//    p=((p-q)/s-.5)*sign(r); s*=8.; \\\n//    L(3,l=length(p.xy+.5)*s; d=min(d,length(vec2(l-(min(floor(l),s-1.)+.5),(fract(p.z*s+.5*s)-.5)))/s); p.zxy=p*vec3(-1,-1,1) ) \\\n//    X+=(d*s/8.-2e-3)*.6; \\\n//}\n//\n//void mainImage( out vec4 C, in vec2 FC )\n//{\n//    vec3 p,d=vec3((FC-Res*.5)/Res.x*2.,-.7);\n//    ROT(d.yz,t*.2);\n//    ROT(d.xy,t*.07);\n//    p=vec3(7,2,1)*t/1e2;\n//    float x=0.;\n//    L(200,dd(x,p+d*x))\n//    C=-C+1.-exp(-x/3.);\n//    C.w=1.;\n//}\n\n// wow!! fabrices take with 548 chars:\n//\n//#define R2(a)  mat2(cos( iTime*a +vec4(0,33,11,0)))\n//#define H(p)   cos( p/.1 +p.zxy*11. + p.yzx*13. )\n//#define L(n)   for( int i=0 ; i++ < n ; )\n//\n//void mainImage( out vec4 C, vec2 U )\n//{\n//    vec3 R = iResolution,\n//         P = vec3(7,2,1) * iTime/1e2, q,r,p,\n//         D = vec3( ( U+U - R.xy ) / R.x, -.7 );\n//    D.yz *= R2(.2);\n//    D.xy *= R2(.07);\n//  \n//    float x=0.,l,d,s;\n//    L( 200 ) { \n//        p = P+D*x;\n//        p += H(.3*p)*.05;\n//        d=1e3; s=2.; r=R/R;\n//        L( 4 && r.x>.5 ) { s*=.5; q = floor(p/s)*s; r = H(q); }\n//        p = ( (p-q)/s - .5 ) * sign(r);\n//        s *= 8.;\n//        L( 3 ) { \n//           l = length(p.xy+.5)*s;\n//           d = min(d, length(vec2( l - min(floor(l),s-1.) , \n//                                   fract(p.z*s+.5*s) ) -.5\n//                            ) /s);\n//           p.zxy = p * vec3(-1,-1,1) ;\n//        }\n//        x += d*s*.075 -1.2e-3 ;\n//    }\n//    C = 1.-C-exp(-x/3.);\n//}\n\n//!!!and even smaller Xor with 539 chars:\n//(and i took another 11 off by (sloppily) replacing the exp by a linear fog\n// and using fabrices loop condition) - so now 526 chars:\n// ...and a lot of fabrice changes added!\n#define A    mat2( cos(vec4(0,33,11,0)+t*//\n#define R(p) cos( p/.1+p.zxy*11.+p.yzx*13. )//\n#define L(n) for(int i=0; i++<n;)\n\n\nvoid mainImage(out vec4 C, vec2 F)\n{\n    float t = iTime,l,D,s;C-=C;\n    vec3 R = iResolution,\n    d = vec3((F+F-R.xy)/R.x,-.7),\n    p = vec3(7,2,1)*t/1e2,P,q,r;\n    \n    d.yz *= A .2));\n    d.xy *= A .07));\n    \n    L(200)\n    {\n        P = p+d*C.x*3.;\n        P += R(.3*P)*.05;\n        l = D = 1e3, s = 2., r=R;\n        \n        L(4 && r.x>.5)\n            s *= .5,\n            q = floor(P/s),\n            r = R(s*q);\n        \n        P = (P/s-q-.5)*sign(r); s*=8.;\n        \n        L(3)\n            D = min(D,length(.5-vec2(min(ceil(l=length(P.xy+.5)*s),s)-l,fract(P.z*s+.5*s)))/s),\n            P.zxy=P,P.zx*= -1.;\n        \n        C += D*s*.025-4e-4;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3GRr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "stc3zn", "name": "Reveal Sound Spire Knob", "author": "Lastminute", "description": "https://www.reveal-sound.com/plug-ins/spire", "tags": ["knob"], "likes": 13, "viewed": 325, "published": 3, "date": "1635592467", "time_retrieved": "2024-07-30T18:51:48.002707", "image_code": "precision lowp float;\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\n#define PI 3.1415926\n\nvec4 overlay(vec4 a, vec4 b)\n{\n\tfloat f = a.a + b.a * (1.0 - a.a);\n\treturn vec4((a.rgb * a.a + b.rgb * b.a * (1.0 - a.a)) / f, f);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h);\n}\n\nmat2 rotate2d(float angle)\n{\n\treturn mat2(-cos(angle), sin(angle), -sin(angle), -cos(angle));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aa = 1.0 / ((iResolution.x + iResolution.y) / 2.0);\n\tfloat range = 0.75;\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * 1.25;\n\n\tfloat av = (1.0 - range) * PI + (iMouse.x / iResolution.x) * 2.0 * PI * range;\n\tfloat avn = (iMouse.x / iResolution.x);\n\tfloat a = atan(uv.x, uv.y) - av;\n\tfloat l = length(uv);\n\n\tfloat a2 = fract((atan(uv.x, uv.y) + PI * 0.75) / (2.0 * PI));\n\n\tfloat arc = smoothstep(a2 - 0.001, a2 + 0.001, 0.75);\n\tfloat arcm = smoothstep(a2 - aa / 2.0, a2 + aa / 2.0, 0.75 * avn);\n\tfloat line_df = line(uv * rotate2d(av), vec2(0.0, 0.325), vec2(0.0, 0.0));\n\n\tvec4 colour = vec4(0.0);\n\n\tfloat cap_df = l - (smoothstep(1.0, -1.0, sin(a * 12. + PI / 2.0) -1.0)) * 0.05;\n\tvec4 border = vec4(vec3(0.737,0.733,0.733), smoothstep(l - aa, l + aa, 0.5));\n\tvec4 bttm = vec4(vec3(0.0), smoothstep(l - aa, l + aa, 0.485));\n\tvec4 bttm_arc = vec4(vec3(0.22), arc);\n\tvec4 bttm_arc2 = vec4(vec3(0.361), arc);\n\tvec4 top_arc1 = vec4(vec3(1.0, 0.498, 0.0), arcm);\n\tvec4 top_arc2 = vec4(vec3(1.0, 0.831, 0.0), arcm);\n\tvec3 capct = vec3(0.961);\n\tvec3 capcb = vec3(0.333);\n\tvec3 capg = mix(capct, capcb, length(0.5 - uv.y));\n\tvec4 metal = vec4(vec3(1.0), max(smoothstep(sin((atan(uv.x, uv.y) - av * 0.05) * 2.0) - 0.5, sin((atan(uv.x, uv.y) - av * 0.025) * 4.0) + 3.0, 0.75) * 0.5, 0.0));\n\tvec4 line = vec4(vec3(1.0), smoothstep(line_df - aa, line_df + aa, 0.025));\n\tvec4 line_s = vec4(vec3(0.0), smoothstep(line_df - 0.025, line_df + 0.025, 0.025) * 0.25);\n\n\tcolour = overlay(vec4(vec3(0.863), 1.0), colour);\n\tcolour = overlay(border, colour);\n\tcolour = overlay(bttm, colour);\n\tcolour = overlay(bttm_arc * smoothstep(length(uv) - aa, length(uv) + aa, 0.475), colour);\n\tcolour = overlay(bttm_arc2 * smoothstep(length(uv) - aa, length(uv) + aa, 0.435), colour);\n\tcolour = overlay(vec4(vec3(0.0), smoothstep(cap_df - 0.05, cap_df + 0.05, 0.325)) * 0.25, colour);\n\tcolour = overlay(vec4(vec3(0.0), smoothstep(length(uv + vec2(0.0, 0.2)) - 0.3, length(uv + vec2(0.0, 0.2)) + 0.3, 0.3)), colour);\n\tcolour = overlay(vec4(top_arc1.rgb, top_arc1.a * smoothstep(length(uv) - aa, length(uv) + aa, 0.475) * smoothstep(length(uv) + aa, length(uv) - aa, 0.385)), colour);\n\tcolour = overlay(vec4(top_arc2.rgb, top_arc2.a * smoothstep(length(uv) - 0.025, length(uv) + 0.025, 0.45) * smoothstep(length(uv) + 0.025, length(uv) - 0.025, 0.42)), colour);\n\tcolour = overlay(vec4(capg, smoothstep(cap_df - aa, cap_df + aa, 0.325)), colour);\n\tcolour = overlay(vec4(vec3(0.0), smoothstep(l - aa, l + aa, 0.32)), colour);\n\tcolour = overlay(vec4(vec3(0.1), smoothstep(l - aa, l + aa, 0.31)), colour);\n\tcolour = overlay(metal * smoothstep(l - aa, l + aa, 0.32), colour);\n\tcolour = overlay(line_s, colour);\n\tcolour = overlay(line, colour);\n\n\tfragColor =  colour;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stc3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 125, 125, 227], [229, 229, 265, 265, 381], [383, 383, 411, 411, 478], [481, 481, 536, 536, 3299]], "test": "untested"}
{"id": "NlcGzr", "name": "Self tangling wires", "author": "NLIBS", "description": "This is what wires do when you're not looking", "tags": ["2d", "repetition", "wires"], "likes": 30, "viewed": 483, "published": 3, "date": "1635569190", "time_retrieved": "2024-07-30T18:51:48.763673", "image_code": "#define pi acos(-1.)\n#define M1 1597334677U\n#define hash(n) float(n*(n^(n>>15)))/float(0xffffffffU)\n\nvoid mainImage(out vec4 O,vec2 U) {\n    vec2 R = iResolution.xy,\n         uv = (2.*U-R)/R.x;\n    \n    O = vec4(0.);\n    for (int k = 0; k<3; k++) { //Loop over layers of wires\n        for (int i = -10; i<=12; i++) { //Loop over neighboring wires\n            vec2 s = uv+vec2(i,0)/40.;\n            float sx0 = floor(s.x*40.+1e-4);\n            \n\n            vec2 p = vec2(0.);\n            float f = hash(uint(float(k*100)+s.x*40.+100.)*M1)*0.1;\n            for (int j = 1; j<10; j++) { //Create a wave function\n                f = f*1.3+.1;\n                float t = (s.y*f+iTime*(1.-s.y*.5)*.1)*12.+f*100.;\n                p += vec2(sin(t),(f-.04*iTime)*cos(t))/f*.1;\n            }\n            float x = uv.x*40.-p.x*float(1+k)*min(iTime*.3,1.);\n            x = (x-sx0-.5)/sqrt(p.y*p.y+1.)+sx0+.5; //Better thickness\n            \n            if (x>sx0 && x<1.+sx0) {\n                O = (pow(cos((hash(uint(x+100.)*M1)*2.4+vec3(-.1,.6,.7))*pi*.6)*.5+.6,vec3(1,2,3))*(1.-pow((fract(x)-.5)*1.9,2.))).rgbb;\n                \n                //Noodles variant\n                //O = ((vec3(.8,.6,.1)-vec3(0,.3,.06)*hash(uint(x+100.)*M1))*(1.-pow((fract(x)-.5)*1.9,2.))).rgbb;\n            } else\n                O = O*min((abs(x-sx0-.5)-.2)*.65,1.);\n        }\n    }\n    O = pow(O,vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 136, 136, 1389]], "test": "untested"}
{"id": "Nt33zr", "name": "Twizzly Lava Lamp", "author": "jarble", "description": "A simple \"lava lamp\" effect, based on SnoopethDuckDuck's \"Twizzly Mess\" shader.", "tags": ["raymarching", "lavalamp", "template", "artofcode"], "likes": 11, "viewed": 374, "published": 3, "date": "1635566116", "time_retrieved": "2024-07-30T18:51:50.067188", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    //float a = atan(p.x,p.z);\n   // p.y += 0.5 * cos(2. * p.x + iTime);\n    //p.xz += 0.2 * cos(p.zx + iTime);\n    \n    //float b = pow((cos(a + iTime)), 32.);\n    //float b2 = pow((sin(a + iTime)), 32.);\n   // p.y += mix(b, b2, .5 + .5 * cos(iTime));\n   // p.y = sin(0.5 * p.y);\n   // p.x = -2. + 0.5 * sin(0.5 * p.x);\n   //a = cos(a);\n   float r = length(p.xz);\n   float rc = r;\n   //r *= mix(1.,cos(1. * cos(p.y) + iTime), 0.2);\n    \n    //p.x = r + sin(a);\n    //p.z = r + cos(a);\n    \n    //p.y += cos(max(abs(p.x), abs(p.z)) + iTime);\n    \n    //p.y += cos(length(p.xz) + iTime);\n    \n    float r1 = .5;\n    float r2 = .75;\n    //p.x += 0.1 * cos(4. * p.y);\n    float d1 = length(p.xz) - r1;\n    d1 += (cos(p.y));\n    \n    p.y = sin(p.y - iTime+p.x);\n    float d = length(vec2(d1, p.y)) - r2;\n    \n   \n    return 0.2 * d  * (1. + cos(0.55 * rc));//0.25 * d * (1. + 0.75 *  cos(30. * a));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(5. * cos(0.5 * iTime),  cos(0.3 * iTime) * 3., 5. * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.9);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.6 * texture(iChannel0,r / (0.5 + n)).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        col.r += 0.2 * 0.7 + .3 * cos(3. * rf.y + 0. * iTime - 3.1415 / 2.);\n        col.g += 0.2 * 0.7 + .3 * cos(3. * rf.y + 0. * iTime);\n        col.b += 0.2 * 0.7 + .3 * cos(3. * rf.y + 0. * iTime + 3.1415 / 2.);\n        \n        col = mix(pow(col, vec3(2.)), pow(1.-col, vec3(64.)),pow(cos(4.5 * length(p.xz)),2.));\n       \n    \n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt33zr.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1559, 1588, 1588, 1808], [1811, 1811, 1834, 2172, 2731], [2733, 2733, 2767, 2767, 2978], [2980, 2980, 3004, 3004, 3194], [3196, 3196, 3246, 3246, 3437], [3439, 3439, 3457, 3457, 3555], [3558, 3558, 3615, 3615, 4989]], "test": "untested"}
{"id": "ftcGzr", "name": "Sperm", "author": "SnoopethDuckDuck", "description": "i shouldn't have made this (looks quite cool if you increase \"num\")", "tags": ["e"], "likes": 10, "viewed": 335, "published": 3, "date": "1635561768", "time_retrieved": "2024-07-30T18:51:51.111396", "image_code": "#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv.y += 0.02 * cos(12. * uv.x + 8. * iTime);\n    const float num = 30.;\n    \n    float s = 0.;\n    for (float i=0.;i<num;i++) {\n        vec2 p = (0.2 + 0.6 * tanh(3. * cos(0.8 * iTime))) * vec2(tanh(1. *cos(0.5 * pi * tanh(1.5 * cos(iTime + 23. * i/num * pi)) + 1. - 0.5 * i/num * pi)), \n                            0.3 * cos(iTime + 11. * i/num * pi));\n        float d = length(uv - p);\n        s = max(s, step(d, 0.015 + 0.008 * sin(iTime + i/num * pi)));\n        \n        float y = uv.y + 0.01 * cos(50. * uv.x + iTime);\n        //float x = uv.x + .1 * cos(100. * uv.y + iTime);\n        s += smoothstep(-0.05, 0.1, uv.x - (p.x - 0.15 * (i+5.)/num)) * step(uv.x, p.x) * step(abs(y-p.y),0.001);\n    }\n   vec3 col = vec3(s);\n    \n    \n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 127, 1050]], "test": "untested"}
{"id": "Nlc3Rr", "name": "Hex Beat", "author": "Parcle", "description": "Hex 2", "tags": ["hex"], "likes": 0, "viewed": 47, "published": 3, "date": "1635561215", "time_retrieved": "2024-07-30T18:51:51.990046", "image_code": "// Special thanks to The Art of Code\n//     - https://www.youtube.com/c/TheArtofCodeIsCool/videos\n//     - https://www.shadertoy.com/user/BigWIngs\n\nfloat sqrt3 = 1.732;\nfloat scale = 10.0;\n\nvec3 colors[4] = vec3[4](\n                vec3(255.0, 218.0, 169.0) * (1.0 / 255.0), // yellow\n                vec3(111.0, 163.0, 169.0) * (1.0 / 255.0), // turqoise (greenish)\n                vec3(95.0, 114.0, 178.0) * (1.0 / 255.0), // blue\n                vec3(96.0, 54.0, 111.0) * (1.0 / 255.0) // purple\n                );\n\nfloat HexDist(vec2 p){\n    p = abs(p);\n    \n    float rightEdge = p.x;\n    float upperRightEdge = dot(p, normalize(vec2(1.0, sqrt3)));\n    return max(rightEdge, upperRightEdge);\n}\n\nvec2 complexMul(vec2 v, vec2 c) {\n    float real = (v.x * c.x) - (v.y * c.y);\n    float imaginary = (v.x * c.y) + (v.y * c.x);\n    return vec2(real, imaginary);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resXYRatio = iResolution.x / iResolution.y;\n    vec2 uv = ((fragCoord/iResolution.y) - 0.5*vec2(resXYRatio, 1)) * 2.0;\n    vec2 cRotateZoom = vec2(cos(iTime * 0.2), sin(iTime));\n    uv = complexMul(uv, cRotateZoom);\n    uv.x += iTime + 5.0;\n    \n    vec2 uvScaled = uv * scale;\n    vec2 gridScale = vec2(1.0, sqrt3);\n    vec2 a = (mod(uvScaled, gridScale) - 0.5 * gridScale);\n    vec2 b = (mod(uvScaled + 0.5*gridScale, gridScale) - 0.5 * gridScale);\n    \n    vec2 hexUV = dot(a,a) < dot(b,b) ? a : b;\n    vec2 hexIndex = round(uvScaled - hexUV);\n    float breath = (-cos(iTime * 3.0 + ((hexIndex.x + 17.0) * (hexIndex.y - 19.0))) + 1.0) * 0.5;\n    \n    vec3 col;\n    float hexOn = step(0.45 * breath, HexDist(hexUV));\n    uint hexColorIndex = uint((hexIndex.x * 17.0) * (hexIndex.y * 43.0)) % 3u;\n    \n    col.rgb = (1.0 - hexOn) * colors[hexColorIndex];\n    col.rgb += hexOn * colors[3];\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 519, 541, 541, 698], [700, 700, 733, 733, 862], [864, 864, 921, 921, 1879]], "test": "untested"}
{"id": "fl33Rr", "name": "Mira Zeus", "author": "jorge2017a2", "description": "Mira Zeus", "tags": ["font", "mira", "zeus"], "likes": 4, "viewed": 289, "published": 3, "date": "1635558760", "time_retrieved": "2024-07-30T18:51:52.841769", "image_code": "//por jogre2017a2\n//Mira Zeus\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define SM(d,b) smoothstep(antialiasing(1.0),b,d)\n#define SM2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{   vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,SM2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,SM2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,SM2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,SM2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,SM2( distObj,0.0));\n    return colOut;\n}\n\n\nvec3 colorplaneta( vec2 fragCoord )\n{\n    vec2 uv;\n    uv=fragCoord;\n    uv *= 5.0;\n    //Add distortion\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    \tuv.x += sin(iTime + uv.y * i);\n    \tuv.y += cos(iTime + uv.x * i);\n    }\n\n    //Time varying pixel colour\n    //vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx + vec3(0,2,4));\n    \n    vec3 col = 0.5 + 0.5*cos(4.0*iTime + uv.xyx );\n//Fragment colour\n    return col;\n}\n\nfloat GetTexZeus(vec2 uv)\n{\n\tfloat t = iTime;\n\tuv*=3.;\n\t\n\tuv.x += 0.18;\n\tuv.y -= 3.5;\n\tuv.y *= 0.8;\n\tuv *=1.5;\n\tfloat d=1.5;\n\td = Z(uv,1.5);uv.x -= 1.2;\n\td = E(uv,d);uv.x -= 1.2;\n\td = U(uv,d);uv.x -= 1.2;\n\td = S(uv,d);uv.x -= 1.2;\n\treturn d-0.55*CHS;\n}\n\nfloat GetTextMira(vec2 uv)\n{\tfloat t = iTime;\n\tuv*=3.;\n\t\n\tuv.x += 0.18;\n\tuv.y -= 3.5;\n\tuv.y *= 0.8;\n\tuv *=1.5;\n\tfloat d=1.5;\n\td = M(uv,1.5);uv.x -= 1.2;\n\td = I(uv,d);uv.x -= 1.2;\n\td = R(uv,d);uv.x -= 1.2;\n\td = A(uv,d);uv.x -= 1.2;\n\treturn d-0.55*CHS;\n}\n\nfloat cuadro(vec2 uv)\n{\n    float d1= sdBox( uv, vec2(2.0,2.0) );\n    float d2= sdBox( uv, vec2(0.45,0.45) );\n    float dif= differenceSDF(d1, d2);\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tuv-=0.5;\n    vec2 uv0=uv;\t\n\tfloat e1 = sin(uv.y*5.0+iTime)*0.1;\n\tfloat e2 = sin(uv.x*14.0+iTime*0.7)*0.1;\n\te1 = 2.0+e1+e2;\n\tuv*= e1;\n\tuv+=0.5;\n\tuv.x += sin(uv.y*0.32+iTime*0.67)*0.2;\n    vec3 col;\n    \n    \n    vec3 colBg0= colorplaneta(uv);\n    vec3 colBg1= colorplaneta(uv-vec2(0.5,-0.5));\n    col=colBg0;\n    \n    uv.x-=0.5;\n    uv.y+=0.1;\n    float xd1 = GetTexZeus(uv*1.0);\n    float xd2 = GetTexZeus(uv*2.0);\n    float xd3 = GetTexZeus(uv*3.0-vec2(0.0,-1.0));\n    float xd4 = GetTextMira(uv*3.0-vec2(-1.5,2.0));\n    \n    vec3 colletras=vec3(1.6+sin(iTime+uv.x*22.5)*0.2,0.9+sin(uv.x*5.0+uv.y*10.0+iTime*3.1)*0.3,0.5+sin(iTime*10.0+uv.x*32.0)*0.3);\n    col= DrawFigBorde(colletras, col, xd1 );\n    col= DrawFigBorde(colletras, col, xd2 );\n    col= DrawFigBorde(colletras, col, xd3 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col, xd4 );\n  \n    float c1= cuadro(uv0);\n    col= DrawFig(colBg1*vec3(0.3,0.5,0.6), col, c1 );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//letras ==fuente\n//referencia de letras\n//https://www.glslsandbox.com/e#76408.0\n#define CHS 0.21\n\nfloat sdBox2(in vec2 p,in vec2 b) {vec2 d=abs(p)-b;return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);}\nfloat line2(float d,vec2 p,vec4 l){vec2 pa=p-l.xy;vec2 ba=l.zw-l.xy;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return min(d,length(pa-ba*h));}\n\nfloat LR(vec2 p, float d){p.x=abs(p.x);return line2(d,p,vec4(2,-3.25,2,3.25)*CHS);}\nfloat TB(vec2 p, float d){p.y=abs(p.y);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat TBLR(vec2 p, float d){return min(d,abs(sdBox2(p,vec2(2,3.25)*CHS)));}\nfloat A(vec2 p,float d){d=LR(p,d);p.y=abs(p.y-1.5*CHS);return line2(d,p,vec4(2,1.75,-2,1.75)*CHS);}\nfloat B(vec2 p,float d){p.y+=1.75*CHS;d=min(d,abs(sdBox2(p,vec2(2.0,1.5)*CHS)));p+=vec2(0.5,-3.25)*CHS;return min(d,abs(sdBox2(p,vec2(1.5,1.75)*CHS)));}\nfloat C(vec2 p,float d){d=TB(p,d);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat D(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,-1,2,1)*CHS);p.y=abs(p.y);d=line2(d,p,vec4(2,1,1.5,2.75)*CHS);d=line2(d,p,vec4(1.5,2.75,1,3.25)*CHS);return line2(d,p,vec4(1,3.25,-2,3.25)*CHS);} // SUCK MY ARSEHOLE\nfloat E(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);return line2(d,p,vec4(0,-0.25,-2,-0.25)*CHS);}\nfloat F(vec2 p,float d){d=line2(d,p,vec4(2,3.25,-2,3.25)*CHS);d=line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);return line2(d,p,vec4(0,-0.25,-2,-0.25)*CHS);}\nfloat G(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,2.25,2,3.25)*CHS);d=line2(d,p,vec4(2,-3.25,2,-0.25)*CHS);return line2(d,p,vec4(2,-0.25,0.5,-0.25)*CHS);}\nfloat H(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(-2,-0.25,2,-0.25)*CHS);}\nfloat I(vec2 p,float d){d=line2(d,p,vec4(0,-3.25,0,3.25)*CHS);p.y=abs(p.y);return line2(d,p,vec4(1.5,3.25,-1.5,3.25)*CHS);}\nfloat J(vec2 p,float d){d=line2(d,p,vec4(-1.5,-3.25,0,-3.25)*CHS);d=line2(d,p,vec4(0,-3.25,1,-2.25)*CHS);d=line2(d,p,vec4(1,-2.25,1,3.25)*CHS);return line2(d,p,vec4(1,3.25,-1.5,3.25)*CHS);}\nfloat K(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(-2,-0.25,-0.5,-0.25)*CHS);d=line2(d,p,vec4(2,3.25,-0.5,-0.25)*CHS);return line2(d,p,vec4(-0.5,-0.25,2,-3.25)*CHS);}\nfloat L(vec2 p,float d){d=line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat M(vec2 p,float d){p.x=abs(p.x);d=line2(d,p,vec4(2,-3.25,2,3.25)*CHS);return line2(d,p,vec4(0,0.75,2,3.25)*CHS);}\nfloat N(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(-2,3.25,2,-3.25)*CHS);}\nfloat O(vec2 p,float d){return TBLR(p,d);}\nfloat P(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d,abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat Q(vec2 p,float d){d=TBLR(p,d);return line2(d,p,vec4(2,-3.25,0.5,-1.75)*CHS);}\nfloat R(vec2 p,float d){d=line2(d,p,vec4(0.5,-0.25,2.,-3.25)*CHS);d=line2(d,p,vec4(-2.0,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d, abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat S(vec2 p,float d) { d=TB(p,d);d=line2(d,p,vec4(-2.,3.25,-2.,-0.25)*CHS);d=line2(d,p,vec4(-2.,-0.25,2,-0.25)*CHS); return line2(d,p,vec4(2.0,-0.25,2.0,-3.25)*CHS);}\nfloat T(vec2 p,float d){d=line2(d,p,vec4(0,-3.25,0,3.25)*CHS);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat U(vec2 p,float d){d=LR(p,d);return line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);}\nfloat V(vec2 p,float d){p.x=abs(p.x);return line2(d,p,vec4(0,-3.25,2,3.25)*CHS);}\nfloat W(vec2 p,float d){p.x=abs(p.x);d=line2(d,p,vec4(2,-3.25,2,3.25)*CHS);return line2(d,p,vec4(0,-1.25,2,-3.25)*CHS);}\nfloat X(vec2 p,float d){d = line2(d,p,vec4(-2,3.25,2,-3.25)*CHS);return line2(d,p,vec4(-2,-3.25,2,3.25)*CHS);}\nfloat Y(vec2 p,float d){d=line2(d,p,vec4(0,-0.25,0,-3.25)*CHS);p.x=abs(p.x);return line2(d,p,vec4(0,-0.25,2,3.25)*CHS);}\nfloat Z(vec2 p,float d){d=TB(p,d);return line2(d,p,vec4(-2,-3.25,2,3.25)*CHS);}\nfloat i_(vec2 p,float d){d=line2(d,p,vec4(0.,-0.0,0.,3.25)*CHS);p.y=abs(p.y);return line2(d,p,vec4(.0,3.25,-0.0,3.25)*CHS);}\n\n", "sound_code": "///modificado por jorge2017a1\n//fork gaziya5\n///https://qiita.com/gaziya5/items/e58f8c1fce3f3f227ca7\n#define A 0.125\n#define PI 3.141592654\n\nfloat noise(float time)\n{\n    return  (fract(sin(time*99.)*50000.0)*2.0-1.0);\n}\n\nfloat kick(float time) \n{\n    return sin(6.283 * 50.0 * time - 10.0 * exp( -70.0 * time ))*exp(-time*1.6); \n}\n\n///modificado por jorge fp\nfloat bass(float time) \n{\n    return sin(6.283 * 60.0 * time - 10.0 * exp( -70.0 * time ))*exp(-time*0.56); \n}\n\n\n\nfloat snare(float time) {\n  return noise(time)*max(0.0,1.0-min(0.85,time*4.25)-(time-0.25)*0.3);\n}\n\nfloat hihat(float time) {\n  return noise(time)*exp(-time*150.0);\n}\n\nfloat saw(float phase) \n{\n    float s = 0.0;\n    for (int k = 1; k <= 8; k++) {\n    s += (sin(2.0*PI*float(k)*phase) / float(k));\n    }\n    return (1.0/2.0) - (1.0/PI)*s - 0.5;\n}\n\nfloat sawNota(float time,  float freq )\n{\n    /// Fm\n    return  saw(time*freq) *exp(-3.*time);\n}   \n\n\nfloat sequence(int s,float time)\n{\n  float n =mod(time,A);\n  for(int i=0;i<16;i++){\n    if((s>>(int(time/A)-i)%16&1)==1)break;\n    n+=A;\n  }\n  return n;\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    \n    float t1=mod(time,3.0);\n    float t2=mod(time,6.0);\n    \n    float t1a=mod(time,6.0);\n    float t2a=mod(time,12.0);\n    \n    float s3=0.0;\n    float s1,s2;\n    \n    \n    if (time<3.0)\n    {\n        s3=sawNota(sequence(0x7815,time),200.0 )*0.2;\n        s3+=sawNota(sequence(0x7812,time),150.0 )*0.2;\n        s3+=sawNota(sequence(0x7615,time),550.0 )*0.2;\n    }\n    else    \n    {    \n    \n    if(t1a<t2a)\n    {\n        s1=0.2 * sawNota(sequence(0x1505,time+t1a),440.0);\n        s1+=0.2 * sawNota(sequence(0x8505,time),600.0);\n        s1+=0.2 * sawNota(sequence(0x0225,time),750.0);\n        s1/=2.0;\n    }\n    else\n    {   s1+=0.2 * sawNota(sequence(0x3895,time),40.0 );\n        s1+=0.2 * sawNota(sequence(0x5465,time),140.0 );\n        s1/=2.0;\n    }\n    \n    if(t1<t2)\n        s2=0.2 * bass(sequence(0x1505,time));\n    else\n        s2=0.2 * bass(sequence(0x4895,time));   \n    }\n    \n    return vec2(\n                 s1 + s2+s3+\n                 0.2 * snare(sequence(0x1010,time))+\n                 0.4 * kick(sequence(0x4082,time))+\n                 0.2 * hihat(sequence(0x5555,time))\n                 );\n                 \n    \n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl33Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 230, 230, 308], [310, 310, 344, 344, 439], [440, 471, 507, 507, 552], [557, 601, 648, 648, 675], [676, 676, 719, 719, 746], [747, 747, 795, 795, 823], [829, 829, 891, 891, 1089], [1091, 1091, 1172, 1172, 1301], [1303, 1303, 1360, 1360, 1431], [1434, 1434, 1471, 1471, 1849], [1851, 1851, 1878, 1878, 2103], [2105, 2105, 2133, 2133, 2357], [2359, 2359, 2382, 2382, 2524], [2526, 2526, 2583, 2583, 3593]], "test": "untested"}
{"id": "NtcGRr", "name": "Rotating ASCII donut", "author": "dkaraush", "description": "Inspired by ASCII donut.c", "tags": ["raymarching", "torus", "donut"], "likes": 32, "viewed": 1120, "published": 3, "date": "1635558037", "time_retrieved": "2024-07-30T18:51:53.600740", "image_code": "                  precision highp\n              int;/**/float G(vec3 p){\n           float s=sin(iTime),c=cos(iTime\n         ),n=1.-c,o=.7,k=o*o;vec4 D=mat4(n\n       *k+c,n*k,o*s,0,n*k,n*k+c,-o*s,0,-o*s,\n     o*s,c,0,0,0,0,0)*vec4(p+vec3(0,0,-4),1);\n    return length(vec2(length(D.xz)-1.,D.y))-.4\n   ;}void mainImage(out vec4 O,in vec2 I){vec2 R\n   =iResolution.xy,u=(I.xy-vec2((R.x-R.y)*.5,0))\n  /R.y*45.;/**/vec3 d=       normalize(vec3(floor\n  (u)/45.-.5,1)),C =           vec3(0);for(int i=\n  0;i<15;++i){C+=d*G           (C);}float D= max(\n  dot(normalize((vec3          (G(C+vec3(.1,0,0))\n  ,G(C+vec3(0,.1,0))           ,G(C+vec3(0,0,.1))\n  )-G(C))/.1),normalize     (-C)),.0); ivec2 b =\n   ivec2(floor(fract(u)*7.8))-(1,0);O=vec4(vec3(\n   length(C)<9.&&b.x>=0&&b.x<=4&&b.y>=0&&b.y<=6\n    &&/*#*/(int[13](0,0x40000,0xc0000,0x810200,\n    0x41038104, 0x28000, 0x3428000, 0x1428500,\n      0x5c000,0x141c500,0xb9cee73a,0xc2afea86\n         ,0xf55b305f)[int(D*13.)]&1<<int(b\n           .x*7+(6-b.y)-1))>0?D:0.),1);}\n             /*# made by @dkaraush #*/\n                 /*# dima.bio #*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 72, 72, 302]], "test": "untested"}
{"id": "Nlc3zn", "name": "Fractal weirdness 2", "author": "jarble", "description": "A simple fractal pattern.", "tags": ["fractal"], "likes": 2, "viewed": 197, "published": 3, "date": "1635553319", "time_retrieved": "2024-07-30T18:51:54.361705", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv1 = ((fragCoord)*10.0-iResolution.xy)/iResolution.y/40.;\n    uv1.y -= 2.3;\n    uv1 += iTime/160.;\n    for(int c=0;c<3;c++){\n        vec2 uv = uv1;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract((uv.y+uv.x+uv)*(1.-col.y));\n            uv *= (uv.x-uv.y);\n            //col += col.yzx/16./16.;\n            col[c] += (uv.y-uv.x);\n        }\n\n\t}\n    \n    fragColor = vec4(fract(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlc3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 515]], "test": "untested"}
{"id": "flc3zn", "name": "More black and white stuff", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 1, "viewed": 240, "published": 3, "date": "1635553269", "time_retrieved": "2024-07-30T18:51:55.110703", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv *= tanh(10. * cos(length(uv) + 0.5 * iTime));\n    uv.x += 0.1 * cos(10. * uv.y + iTime);\n    float a = atan(uv.y, uv.x);\n    float d = length(uv) + 0.5\n    + 0.5 * tanh( (0. + 1. * tanh(4. * cos(length(uv) + 96. * a + 2. * iTime))) \n                   * cos(80. * length(uv) +  10. * iTime) );\n    d = d * (1.5 + tanh(2. * cos(0. * d + 2.* length(uv) * \n    (0. + tanh(1. * cos(192. * a + iTime))) + 3. * a+  1. * iTime)));\n   // d *= 0.22;\n    float s = step(d,0.4);\n    \n    vec3 col = vec3(s);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 713]], "test": "untested"}
{"id": "flc3Rn", "name": "[ConcoursJFIG2021] Alpine Flyby", "author": "loicvdb", "description": "My entry for the jFIG2021 Shadertoy contest.\nUncomment #define FLY_MODE_QWERTY in Common to fly around the scene.", "tags": ["concoursjfig2021"], "likes": 69, "viewed": 1460, "published": 3, "date": "1635549934", "time_retrieved": "2024-07-30T18:51:56.377316", "image_code": "void mainImage(out vec4 o, in vec2 u){\n    \n    // == motion blur ============================================\n    mat3 cam = getMat3(0);\n    vec3 rd = cam * normalize(vec3((u-iResolution.xy*.5)/iResolution.y, FocalLength));\n    vec3 ro = getVec3(3);\n    float depth = texture(iChannel1, u/iResolution.xy).a;\n    \n    mat3 pCam = getMat3(5);\n    vec3 pRo = getVec3(8);\n    vec3 pxyz = transpose(pCam) * (ro+depth*rd-pRo);\n    vec2 puv = FocalLength * pxyz.xy * iResolution.y / pxyz.z + iResolution.xy*.5;\n    \n    vec3 x = vec3(0);\n    const int samples = 16;\n    vec2 d = (puv-u) / float(samples);\n    for(int i = 0; i < samples; i++) {\n        ivec2 iu = clamp(ivec2(u+float(i-samples/2)*d), ivec2(0), ivec2(iResolution.xy)-1);\n        x += texelFetch(iChannel1, iu, 0).rgb;\n    }\n    \n    x /= float(samples);\n    \n    \n    // == fast bloom ============================================\n    float r = floor(log2(iResolution.y) - 4.5) + .5;\n    for(int i = 0; i < 2; i++)\n        x += texture(iChannel1, u/iResolution.xy, r+float(i*2)).rgb*.1;\n    \n    \n    // == transitions ===========================================\n    #ifndef FLY_MODE\n    float f = iTime*.1;\n    x *= smoothstep(-.2, .2, .5-abs(.5-fract(f)))*2.-1.;\n    #endif\n    \n    \n    // == exposure =============================================\n    x *= 2.;\n    \n    \n    // == vignette =============================================\n    vec2 cuv = u/iResolution.xy-.5;\n    x *= 1. - dot(cuv, cuv)*1.4;\n    \n        \n    // == ACES fit =============================================\n    x = (x*(2.51*x+.03))/(x*(2.43*x+.59)+.14);\n    \n    o = vec4(x, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Uncomment for keyboard control\n// wasd/zqsd + crtl + maj to move arround\n//#define FLY_MODE_QWERTY\n//#define FLY_MODE_AZERTY\n\n\nuniform sampler2D iChannel0Fake;\n\nvec3 getVec3(int add) {\n    return vec3(\n        texelFetch(iChannel0Fake, ivec2(add, 0), 0).w,\n        texelFetch(iChannel0Fake, ivec2(add, 1), 0).w,\n        texelFetch(iChannel0Fake, ivec2(add, 3), 0).w\n    );\n}\n\n\nvoid setVec3(vec3 v, int add, inout vec4 o) {\n    ivec2 u = ivec2(gl_FragCoord.xy);\n    if(u == ivec2(add, 0)) o.w = v.x;\n    if(u == ivec2(add, 1)) o.w = v.y;\n    if(u == ivec2(add, 3)) o.w = v.z;\n}\n\n\nvoid setMat3(mat3 m, int add, inout vec4 o) {\n    for(int i = 0; i < 4; i++) {\n        setVec3(m[i], add+i, o);\n    }\n}\n\n\nmat3 getMat3(int address) {\n    return mat3(getVec3(address), getVec3(address+1), getVec3(address+2));\n}\n\n\nint hash(int i) {\n    // 2024-03-03 : fixed integer rollback by switching hashing to uint\n    uint j = uint(i);\n\tj *= 0xB5297A4Du;\n\tj ^= j >> 8;\n\tj += 0x68E31DA4u;\n\tj ^= j << 8;\n\tj *= 0x1B56C4E9u;\n\tj ^= j >> 8;\n\treturn int(j & 0x7FFFFFFFu);\n}\n\n\nfloat fhash(int i) {\n\treturn float(hash(i))/2147483648.;\n}\n\n\nfloat fhash2(ivec2 i) {\n    return fhash(i.x - 0x8CB * i.y);\n}\n\n\n#define INIT_NOISE Seed = hash(int(floor(gl_FragCoord.x)+floor(gl_FragCoord.y)*12345.)) ^ hash(iFrame)\n\n\nint Seed;\n\n\nfloat random() {\n    return fhash(Seed++);\n}\n\n\nfloat smoothnoise(vec2 x) {\n    ivec2 ix = ivec2(floor(x));\n    vec2 f = smoothstep(0., 1., fract(x));\n    return mix(\n        mix(fhash2(ix+ivec2(0,0)), fhash2(ix+ivec2(1,0)), f.x),\n        mix(fhash2(ix+ivec2(0,1)), fhash2(ix+ivec2(1,1)), f.x),\n        f.y\n    )-.5;\n}\n\n\nfloat fbm(vec2 x) {\n    const float weight = .5;\n    const float scale = 2.;\n    const int iterations = 6;\n    float o = 0., a = 1.;\n    for(int i = 0; i < iterations; i++) {\n        o += smoothnoise(x) * a;\n        a *= weight;\n        x *= scale;\n    }\n    return o;\n}\n\n#ifdef FLY_MODE_AZERTY\n#define FLY_MODE\n#endif\n\n#ifdef FLY_MODE_QWERTY\n#define FLY_MODE\n#endif\n\nconst float FocalLength = 1.5;", "buffer_a_code": "const int Scenes = 6;\n\nconst float Anim[Scenes*10] = float[Scenes*10](\n    0.63, .10, .93, 3.5, -.10,\n    0.63, .13, .93, 3.5, -.30,\n    0.63, .20, .65, 3.8, -.80,\n    0.65, .20, .60, 4.0, -.80,\n    0.83, .18, .13, 5.2, -.50,\n    0.72, .16, .02, 5.7, -.45,\n    0.63, .05, .24, 5.1, -.30,\n    0.55, .06, .30, 4.8, -.30,\n    0.10, .12, .70, 2.0, -.40,\n    0.40, .06, .55, 2.1, -.25,\n    1.05, .16, .90, 4.1, -.45,\n    1.05, .16, .97, 4.1, -.45\n);\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#ifdef FLY_MODE_AZERTY\nconst int FORWARD = 90;\nconst int BACKWARD = 83;\nconst int UP = 16;\nconst int DOWN = 17;\nconst int RIGHT = 68;\nconst int LEFT = 81;\n#endif\n\n#ifdef FLY_MODE_QWERTY\nconst int FORWARD = 87;\nconst int BACKWARD = 83;\nconst int UP = 16;\nconst int DOWN = 17;\nconst int RIGHT = 68;\nconst int LEFT = 65;\n#endif\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n\n    o = texelFetch(iChannel0, ivec2(u), 0);\n    \n    setMat3(getMat3(0), 5, o);\n    vec3 p = getVec3(3);\n    setVec3(p, 8, o);\n    \n    #ifdef FLY_MODE\n    \n    // == mouse control ====================================\n    \n    vec3 v = iFrame == 0 ? vec3(Anim[8], Anim[9], -1.) : getVec3(4);\n    const float sensitivity = 2.;\n    if(sign(iMouse.z) == -1. && sign(iMouse.w) == -1.) {\n        if(v.z > 0.) {\n            v.z = -1.;\n            v.xy += (iMouse.xy+iMouse.zw) * sensitivity/iResolution.y;\n        }\n    } else {\n        v.z = 1.;\n    }\n    setVec3(v, 4, o);\n    \n    vec2 rot = v.xy;\n    if(iMouse.z > 0.) {\n        rot += (iMouse.xy-abs(iMouse.zw)) * sensitivity/iResolution.y;\n    }\n    \n    #else\n    \n    // == animation =====================================\n    \n    float f = iTime*.1;\n    int a = int(f)%Scenes*10;\n    \n    #ifdef NOT_INTEL_IGPU_PEASANT\n    vec3 p1 = vec3(Anim[a+0], Anim[a+1], Anim[a+2]);\n    vec2 a1 = vec2(Anim[a+3], Anim[a+4]);\n    vec3 p2 = vec3(Anim[a+5], Anim[a+6], Anim[a+7]);\n    vec2 a2 = vec2(Anim[a+8], Anim[a+9]);\n    #else\n    vec3 p1, p2;\n    vec2 a1, a2;\n    for(int b = 0; b < 60; b += 10) {\n        if(a == b) {\n            p1 = vec3(Anim[b+0], Anim[b+1], Anim[b+2]);\n            a1 = vec2(Anim[b+3], Anim[b+4]);\n            p2 = vec3(Anim[b+5], Anim[b+6], Anim[b+7]);\n            a2 = vec2(Anim[b+8], Anim[b+9]);\n        }\n    }\n    #endif\n    \n    p = mix(p1, p2, fract(f));\n    vec2 rot = mix(a1, a2, fract(f));\n    \n    #endif\n    \n    \n    // == rotation matrix =====================================\n    \n    vec2 c = cos(rot);\n    vec2 s = sin(rot);\n    mat3 rx = mat3(1, 0, 0, 0, c.y, -s.y, 0, s.y, c.y);\n    mat3 ry = mat3(c.x, 0, -s.x, 0, 1, 0, s.x, 0, c.x);\n    mat3 cam = ry * rx;\n    \n    \n    #ifdef FLY_MODE\n    \n    // == keyboard control ====================================\n    \n    p = iFrame==0 ? vec3(Anim[5], Anim[6], Anim[7]) : p;\n    vec3 m = vec3(0);\n    if(keyClick(FORWARD )) m += cam * vec3(0, 0, 1);\n    if(keyClick(BACKWARD)) m -= cam * vec3(0, 0, 1);\n    if(keyClick(UP      )) m += vec3(0, 1, 0);\n    if(keyClick(DOWN    )) m -= vec3(0, 1, 0);\n    if(keyClick(RIGHT   )) m += cam * vec3(1, 0, 0);\n    if(keyClick(LEFT    )) m -= cam * vec3(1, 0, 0);\n    if(dot(m, m) > 0.) {\n        p += normalize(m)*iTimeDelta*.05;\n    }\n    p.y = max(p.y, .001);\n    \n    #endif\n    \n    \n    setMat3(cam, 0, o);\n    setVec3(p, 3, o);\n    \n    vec3 res = getVec3(10);\n    \n    if(res == iResolution) {\n        return;\n    }\n    \n    // == tree density map ====================================\n    \n    if(res == -iResolution) {\n        vec2 p = u/iResolution.xy;\n        vec3 k = vec3(1./iChannelResolution[0].xy, 0);\n        vec3 n = normalize(vec3((o.x - vec2(texture(iChannel0, p+k.xz).x, texture(iChannel0, p+k.zy).x))/k.xy, 1.).xzy);\n        o.y = clamp(n.y*n.y*n.y*(o.x-.0002)*100., 0., 1.);\n        setVec3(iResolution, 10, o);\n        return;\n    }\n    \n    setVec3(-iResolution, 10, o);\n    \n    \n    // == SIREN heightmap ====================================\n    \n    vec2 uv = 2.*u/iResolution.xy-1.;\n    float ft_0 = -uv.y;\n    float ft_1 = uv.x;\n    vec4 f1_0, f0_0=sin(ft_0*vec4(2.86,-1.82,.66,-3.70)+ft_1*vec4(-1.01,-3.17,2.94,3.29)+vec4(3.39,5.41,.98,2.27));\n    vec4 f1_1, f0_1=sin(ft_0*vec4(-1.41,3.34,-1.86,.04)+ft_1*vec4(-.32,.55,.73,-3.23)+vec4(2.94,1.95,2.89,3.07));\n    vec4 f1_2, f0_2=sin(ft_0*vec4(1.55,-3.52,1.27,.99)+ft_1*vec4(-1.64,-3.75,-2.17,1.77)+vec4(-2.37,.42,-3.52,-4.43));\n    vec4 f1_3, f0_3=sin(ft_0*vec4(-3.17,-1.78,-1.69,-1.72)+ft_1*vec4(-2.29,-.04,-1.78,-1.04)+vec4(2.10,-.24,-1.65,.13));\n    f1_0=sin(mat4(.13,.60,-.12,.09,.02,-.24,-.82,.01,.19,-.68,.18,.03,.45,.36,.39,-.14)*f0_0+\n        mat4(-.12,.38,-.18,.39,.45,-.49,.12,.50,-.16,.33,-.14,-.32,-.86,-.19,.04,.38)*f0_1+\n        mat4(-.10,-.20,.29,.20,.46,-.34,.63,.03,.52,-.93,.05,.45,-.26,-.09,.03,.43)*f0_2+\n        mat4(.08,.47,1.18,-.45,.12,-.39,.14,-.21,.36,-.15,.11,.15,.02,-.40,-.27,-.05)*f0_3+\n        vec4(-1.59,-2.03,-.75,1.50))/1.0+f0_0;\n    f1_1=sin(mat4(.08,-.04,.13,.11,.03,-.22,.73,-.20,.64,-.42,-.07,.65,-.15,.30,-.77,-.72)*f0_0+\n        mat4(.09,.96,.34,.40,-.01,-.07,.27,-.06,.42,-.08,-.16,-.29,.88,-.19,-.04,.66)*f0_1+\n        mat4(.18,-.45,.19,.48,.56,-.50,-.57,-.75,.25,.01,.44,.62,.05,.29,-.35,.25)*f0_2+\n        mat4(-.04,.15,-.23,-.52,.06,-.62,-.33,.07,.38,.15,.52,.02,-.21,.17,-.45,-.25)*f0_3+\n        vec4(.19,.36,-.72,-1.78))/1.0+f0_1;\n    f1_2=sin(mat4(.07,.36,-.25,-.62,-.09,-.31,.21,.43,-.16,.04,-.37,-.23,-.15,-.34,-.25,-.05)*f0_0+\n        mat4(.10,-.31,.38,.45,.27,-.37,.53,-.41,.17,-.10,.33,.34,-.23,-.26,-.10,.33)*f0_1+\n        mat4(.29,.06,.01,-.28,.45,.25,.33,-.54,.64,-.44,.10,-.26,.37,-.25,-.18,-.24)*f0_2+\n        mat4(-.00,-.25,-.59,1.09,-.34,.18,-.64,-.10,-.25,.14,.29,-.25,.05,-.05,-.05,-.38)*f0_3+\n        vec4(1.69,-2.04,1.47,1.73))/1.0+f0_2;\n    f1_3=sin(mat4(-.08,.59,.31,.72,-.60,.25,.40,.60,.20,.15,-.18,-.01,.12,1.61,-.60,.95)*f0_0+\n        mat4(-.49,-.50,-.15,-.30,.42,-.09,.01,.17,-.67,-.34,-.18,-.30,-.07,-.09,-.72,.15)*f0_1+\n        mat4(.25,-.11,-.51,.51,.18,.37,.38,.27,-.02,.26,-.16,-.10,-.17,.17,-.02,.50)*f0_2+\n        mat4(.54,.23,-.04,-.02,.18,.06,.01,.31,-.07,.31,-.22,-.49,.30,.29,.04,.17)*f0_3+\n        vec4(.65,-1.26,1.75,1.02))/1.0+f0_3;\n    f0_0=sin(mat4(1.08,.15,.32,-.37,-.06,.35,-.20,-.36,.55,-.27,.47,-.36,.33,-.42,.59,.88)*f1_0+\n        mat4(-.12,-.35,.03,.03,-.29,.27,-.42,-.25,-.47,-.02,-.17,-.10,-.59,.20,.35,.21)*f1_1+\n        mat4(.13,-.11,-.11,-.51,-.40,-.10,.00,-.07,-.10,.08,-.32,.08,.03,.26,-.08,-.11)*f1_2+\n        mat4(.00,.26,.24,.00,.04,.15,.30,.67,-.76,-.16,.81,.63,.16,-.21,.06,-.05)*f1_3+\n        vec4(-.24,.54,-1.54,-.20))/1.4+f1_0;\n    f0_1=sin(mat4(-.10,.39,.18,-.65,-.04,-.91,-.36,-.06,-.23,.38,-.01,.00,1.10,.43,-.02,.21)*f1_0+\n        mat4(-.24,.79,-.37,.22,.17,.23,.31,-.17,-.22,.55,.23,-.21,-.80,.31,.15,-.26)*f1_1+\n        mat4(.20,.06,.81,.49,-.93,-.37,-.14,-.00,.65,.13,.04,.21,.16,.30,.25,.64)*f1_2+\n        mat4(.60,.33,.18,.08,-.04,.26,-.62,-.59,.17,-.35,.74,.46,1.40,.45,-.49,.15)*f1_3+\n        vec4(.74,-1.08,-1.04,1.92))/1.4+f1_1;\n    f0_2=sin(mat4(-.11,-.49,-.28,.19,-.33,.27,-.34,-.74,.02,-.39,-.42,-.11,.21,-.05,-.05,.18)*f1_0+\n        mat4(.22,-.14,-.48,.45,.64,-.30,.49,.43,-.21,-.19,-.06,-.02,-.80,-.04,.98,-.28)*f1_1+\n        mat4(-.19,.11,.40,-.65,-.40,-.35,-.10,-.41,.10,-.07,.30,-1.14,.17,.35,.29,.25)*f1_2+\n        mat4(.53,-.44,-.36,-.19,-.68,.07,-.18,.62,-.10,-.13,-.06,-.25,.30,.40,.70,-.47)*f1_3+\n        vec4(.88,.96,.46,-.17))/1.4+f1_2;\n    f0_3=sin(mat4(.57,.97,.36,.50,.69,-.63,-.38,-.43,-.35,-.56,.50,.69,-.41,-.79,.04,-.20)*f1_0+\n        mat4(-.34,-.37,.10,.65,-.58,-.13,-.23,-.56,.11,-.06,-.33,-.26,.22,.31,.87,.46)*f1_1+\n        mat4(.27,-.38,.01,.02,-.00,-.06,-.68,-.01,.19,-.28,.00,.19,-.27,-.24,.14,-.27)*f1_2+\n        mat4(.09,.11,-.03,.08,.29,.45,.23,-.41,.11,.16,.70,-.23,-.00,-.20,-.47,.02)*f1_3+\n        vec4(-.84,.26,.39,-1.20))/1.4+f1_3;\n    f1_0=sin(mat4(-.89,-.63,.44,.96,.52,.23,-.09,-.30,-.20,-.57,-.48,.40,.82,-.26,-.68,-.12)*f0_0+\n        mat4(-.40,-.46,.75,.42,-.26,-.13,-.24,-.76,-.35,.03,.18,-.05,-.33,.14,.01,.27)*f0_1+\n        mat4(.21,-.58,.18,-.09,-.36,-.12,.17,.13,-.14,.06,-.10,.01,.12,.27,.41,-.27)*f0_2+\n        mat4(-.26,.46,-.42,.06,.18,.04,-.28,.77,.34,.12,-.18,.01,.52,.41,.47,-.62)*f0_3+\n        vec4(.40,.38,1.15,-.21))/1.7+f0_0;\n    f1_1=sin(mat4(.63,-.09,-.13,-.02,-.11,-.17,.48,-.19,.33,.03,-.17,-.08,.62,-.01,-.64,-.33)*f0_0+\n        mat4(-.13,-.06,-.13,-.19,.10,.41,-.67,.21,-.36,-.07,-.01,-.21,.69,-.35,.12,.37)*f0_1+\n        mat4(-.38,.32,.27,-.26,-.11,-.56,-.03,-.49,.14,.60,-.39,-.49,-.18,.07,.19,.47)*f0_2+\n        mat4(-.65,-.03,-.15,-.47,.18,-.13,.26,-.16,.59,-.08,-.09,-.13,.18,-.90,-.23,-.14)*f0_3+\n        vec4(-.44,-.47,-.54,-.16))/1.7+f0_1;\n    f1_2=sin(mat4(.35,-.38,-.64,.03,-.04,.68,.44,-.41,-.08,-.41,.16,.30,.24,-.33,-.17,.11)*f0_0+\n        mat4(-.45,-.58,.24,.50,-.22,.17,.12,.69,.05,.47,.81,-.55,.23,.43,.14,.15)*f0_1+\n        mat4(-.15,-.38,-.24,-.10,-.94,-.37,.03,-.20,-.09,-.14,-.95,.23,-.48,-.13,-.77,.40)*f0_2+\n        mat4(.16,.10,-.36,-.11,.40,.04,.53,-.84,-.34,.31,-.39,-.45,.17,-.58,-.20,-.48)*f0_3+\n        vec4(.01,-.87,-1.03,1.22))/1.7+f0_2;\n    f1_3=sin(mat4(-.27,.50,-.53,-.13,.25,.31,-.73,.30,-.19,-.08,.17,-.46,-.57,-.56,-.06,.74)*f0_0+\n        mat4(.40,-.09,.12,.23,.46,-.09,-.24,-.27,.27,.40,.31,-.23,.65,.34,.36,.01)*f0_1+\n        mat4(.22,.16,-.10,.25,.17,-.89,-.44,-.33,-.09,-.06,.40,-.21,.23,-.26,.23,.27)*f0_2+\n        mat4(.02,-.12,-.12,.60,-.38,-.04,.09,1.00,.20,-.67,.78,.77,-.77,.18,-.37,.20)*f0_3+\n        vec4(.88,-.73,-.24,-.63))/1.7+f0_3;\n    f0_0=sin(mat4(-.16,-.41,-.02,-.02,.20,-.01,.45,-.47,-.02,-.24,-.22,.38,-.49,-.74,.52,.70)*f1_0+\n        mat4(.05,.34,.23,-.33,.28,.23,.13,-.23,-.35,.65,-.45,.24,-.40,.15,-.09,.69)*f1_1+\n        mat4(.63,-.07,.15,-.30,-.45,.10,.24,.07,.39,.22,-.07,.27,-.15,-.41,-.81,.03)*f1_2+\n        mat4(-.07,.10,.21,.15,.08,-.20,.03,-.65,-.44,-.44,.27,-.03,.42,-.32,-.86,.00)*f1_3+\n        vec4(.52,-.30,-.71,.28))/2.0+f1_0;\n    f0_1=sin(mat4(-.18,.85,.12,.56,.40,-.44,.90,-.26,-.22,.55,.09,-.39,-.29,-.37,-.60,.51)*f1_0+\n        mat4(-.51,-.22,-.18,.05,.35,.33,.61,-.29,.64,.32,.09,-.24,-.91,-.18,.08,.61)*f1_1+\n        mat4(-.83,.55,.13,.10,.42,.32,-.02,-.33,-.41,-.49,-.18,.36,.01,.59,.32,.04)*f1_2+\n        mat4(-.51,-.23,.77,.17,.50,.20,.06,-.57,-.74,-.07,.16,.27,-.18,.29,-.23,-.04)*f1_3+\n        vec4(-.80,-.60,-.24,1.10))/2.0+f1_1;\n    f0_2=sin(mat4(.70,-.06,.47,-.50,.39,-.51,.26,.08,-.63,-.34,-.31,-.45,.18,.32,-.39,.26)*f1_0+\n        mat4(-.44,-.21,.07,.21,.21,.35,.24,-.28,-.02,-.06,-.65,-.66,-.46,.17,-.02,-1.23)*f1_1+\n        mat4(-.05,-.06,-.40,.07,-.60,-.22,.49,-.77,-.25,.26,.37,.01,-.30,.34,.20,.40)*f1_2+\n        mat4(.24,-.03,.24,-.30,.26,-.14,.37,-.02,-.25,.30,-.23,-.44,.14,.73,-.27,-.01)*f1_3+\n        vec4(.28,1.22,.57,.02))/2.0+f1_2;\n    f0_3=sin(mat4(.78,.41,-.17,.13,-.19,-.07,-.05,.31,.03,.31,-.29,-.60,-.49,.27,-.11,-.01)*f1_0+\n        mat4(.19,-.19,.25,.48,.34,-.78,-.85,.04,-.34,-.06,.15,-.27,.25,-.22,.16,.07)*f1_1+\n        mat4(.21,-1.26,.52,-.42,.03,.66,-.33,.47,.27,.03,-.35,-.20,-.06,-.04,.01,-.46)*f1_2+\n        mat4(.91,.45,-.36,-.15,.14,.12,.20,.72,.96,.45,.33,.02,.28,-.12,.18,-.79)*f1_3+\n        vec4(-.86,-1.17,-.51,-.01))/2.0+f1_3;\n    f1_0=sin(mat4(-.11,-.72,.36,-.20,.10,-.07,-.27,.01,.62,-.45,.34,-.41,.14,.51,-.55,-.46)*f0_0+\n        mat4(.40,-.10,.29,-.21,.53,-.41,.06,-.01,-.02,.07,.69,-1.05,.56,.40,-.28,.10)*f0_1+\n        mat4(-.25,-.10,.21,.01,1.09,.55,-.37,-.46,-.06,-.11,-.15,.44,.57,.38,.25,.45)*f0_2+\n        mat4(.53,-.22,-.18,.20,-.91,-.79,.59,-.45,-.13,.11,.62,-.14,-.50,-.09,.59,-.13)*f0_3+\n        vec4(.17,.14,-.03,1.07))/2.2+f0_0;\n    f1_1=sin(mat4(.51,.01,.41,-.65,.11,.05,-.70,-.56,.49,-.33,.62,.19,.31,.15,-.44,.14)*f0_0+\n        mat4(.67,.27,.69,.29,.17,.72,-.42,.46,.10,.22,-.26,-.56,.27,.21,.19,-.28)*f0_1+\n        mat4(-.14,.21,.38,-.48,.70,.46,-.62,-.14,.62,-.15,-.03,.45,-.04,.81,.62,.36)*f0_2+\n        mat4(.22,-.03,.81,-.38,-.27,-.66,-.33,-.74,-.31,-.48,.62,.04,-.33,.01,-.26,-.92)*f0_3+\n        vec4(-.40,.46,1.15,.67))/2.2+f0_1;\n    f1_2=sin(mat4(-.06,.26,-.04,-.46,-.00,-.72,.07,-.08,.19,-.03,.04,.41,.11,-.20,-.32,.17)*f0_0+\n        mat4(.13,.31,.53,.17,.19,.35,.01,-1.04,-.23,.61,-.17,-.20,-.33,.83,.11,.46)*f0_1+\n        mat4(.63,.32,.19,-.05,-.84,.00,.30,.40,.03,.56,-.56,.09,.06,-.01,.14,.20)*f0_2+\n        mat4(.14,.27,.38,-.26,.10,.12,-.76,.39,.42,-.32,-.47,.47,.39,.30,.28,-.33)*f0_3+\n        vec4(.47,.23,1.14,-.52))/2.2+f0_2;\n    f1_3=sin(mat4(-.40,-.39,-.81,.22,-.09,-.16,-.25,-.47,-.08,.15,.88,-.05,.20,-1.04,.41,-.13)*f0_0+\n        mat4(.29,.39,.37,-.10,.65,-.25,.20,.06,-.06,.07,.64,-.02,-.53,-.05,.69,-.52)*f0_1+\n        mat4(-.51,.16,.04,-.37,.66,.08,.50,-.80,-.55,.10,.08,-.11,.02,-.36,.66,.45)*f0_2+\n        mat4(-.10,.02,-.29,-.08,-.51,.86,-.51,.15,.01,-.27,-.26,-.01,.21,-.19,-.16,.30)*f0_3+\n        vec4(-.02,-.37,-.08,.76))/2.2+f0_3;\n    f0_0=sin(mat4(.76,.56,.22,-.20,.02,-.23,.66,-.10,.25,-.19,-.11,.72,.59,.41,.52,.44)*f1_0+\n        mat4(.55,.07,.26,.56,-.20,.51,-.56,-.60,.22,-.16,-.18,.77,-.05,.31,.26,-.23)*f1_1+\n        mat4(.24,.03,.23,-.07,.33,-.45,.27,-.73,.18,-.71,.16,-.55,.20,.16,.44,-.04)*f1_2+\n        mat4(-.75,-.56,-.17,-.14,.10,.16,-.20,-.62,-.25,-1.05,.43,.46,.02,-.44,-.23,.55)*f1_3+\n        vec4(-.01,-.46,1.00,.64))/2.4+f1_0;\n    f0_1=sin(mat4(-1.04,-.16,-.18,-.87,-.60,-.66,.39,.03,-.10,.53,.74,-.38,.84,.23,.21,-.28)*f1_0+\n        mat4(-.29,.17,-.46,.38,-.32,.21,-.30,-.07,.42,-.18,-.32,-.22,.75,-.28,-.05,-.14)*f1_1+\n        mat4(-.47,-.28,.29,.51,.40,.47,-.46,.08,-.12,-.31,.02,.48,-.01,-.29,-.06,.36)*f1_2+\n        mat4(.03,-.37,.23,.17,-.21,.10,-.46,-.44,.16,-.16,.35,.59,.33,.00,-.20,-.52)*f1_3+\n        vec4(.37,-.41,-.38,1.09))/2.4+f1_1;\n    f0_2=sin(mat4(.10,.31,.02,-.27,.32,.02,-.29,.01,.74,-.45,.17,.06,-.03,.37,.06,-.70)*f1_0+\n        mat4(-.20,.14,-.46,-.15,.57,-.47,.30,.34,.01,.12,-.64,-.03,-.01,.04,.71,.52)*f1_1+\n        mat4(-.38,.55,-.37,.63,-.14,-.60,-.44,-.21,-.83,-.23,-.05,.19,-.57,-.21,-.07,-.60)*f1_2+\n        mat4(.27,-.41,-.10,.41,-.52,.26,-1.01,-.24,-.38,.20,-.18,.29,-.12,-.29,.11,.11)*f1_3+\n        vec4(.44,.24,1.03,.16))/2.4+f1_2;\n    f0_3=sin(mat4(.20,.38,-.14,-.38,.29,-.69,.36,-.99,.27,.01,-.35,-.20,.36,-.28,-.64,.02)*f1_0+\n        mat4(.49,.01,-.32,.06,.05,-.07,.45,-.95,.53,.67,-.83,-.76,.09,.06,-.18,-.03)*f1_1+\n        mat4(.33,.12,.65,.08,-.37,-.48,.34,-.66,-.33,-.11,1.41,.81,.57,.59,.77,.42)*f1_2+\n        mat4(1.44,-.18,-.77,-.22,.70,.82,-.61,.34,-.45,-.03,.36,.12,.38,-.04,-.40,-.28)*f1_3+\n        vec4(.83,.20,.63,.38))/2.4+f1_3;\n    f1_0=sin(mat4(-.51,.77,.37,-1.16,-.15,-.73,-.93,-.16,.06,-.20,.84,-.05,-.43,.63,-.39,-.02)*f0_0+\n        mat4(-.58,-.79,-.25,.16,.12,.36,.07,.03,-.35,-.65,-.34,-.41,-.03,-.21,-.29,-.30)*f0_1+\n        mat4(.08,.27,-1.17,.42,-.24,.78,.49,.18,.21,-.54,-.07,.69,.06,-.03,-.45,.96)*f0_2+\n        mat4(.05,-.77,-.23,-.72,-.38,.41,-.66,-.38,.55,-.95,-1.04,-.12,-.13,.65,-.64,.47)*f0_3+\n        vec4(.37,-1.07,.27,.39))/2.6+f0_0;\n    f1_1=sin(mat4(.16,-.23,-.20,-.71,-.16,-.83,-.77,-.40,-.56,.32,.43,.02,.17,.25,-.53,-.09)*f0_0+\n        mat4(.86,.29,.13,.34,-.56,.11,.06,.62,-.36,.09,-.47,-.08,.26,-.06,.09,-.33)*f0_1+\n        mat4(.31,.29,.21,.10,-.54,-.16,.80,.23,.12,.14,.77,.28,.21,.15,.61,.96)*f0_2+\n        mat4(-.19,-.62,.40,.36,-.26,.28,-.18,-.26,.57,.23,.14,.15,.30,-.24,.19,-.01)*f0_3+\n        vec4(-.71,-1.22,.60,.34))/2.6+f0_1;\n    f1_2=sin(mat4(-.71,.17,1.20,-.23,.10,.15,-.29,.54,.24,-.03,.48,-.20,.08,-.11,.14,-.24)*f0_0+\n        mat4(.26,-.01,.28,-.57,.54,-.00,-.08,-.41,.22,-.09,-.74,.44,.47,-.02,.22,.40)*f0_1+\n        mat4(-.45,.26,-.10,-.18,-.22,.02,.16,.29,-.82,.31,-.03,-.37,-.50,-.18,-.23,.42)*f0_2+\n        mat4(.03,-.46,.64,-.03,-.52,.71,-.10,.44,-.83,-.17,-.15,-.31,-.23,.12,-.40,-.39)*f0_3+\n        vec4(-.08,-.35,-.63,-.78))/2.6+f0_2;\n    f1_3=sin(mat4(-.07,-.87,-.52,.86,.03,.06,.13,.78,.25,-.04,-.02,-.17,-.38,.14,.40,.97)*f0_0+\n        mat4(.15,-.17,.55,-.34,.20,.79,-.36,.51,-.72,-.70,.22,.56,.31,.14,.03,.09)*f0_1+\n        mat4(.60,.03,.34,.19,.85,.90,-.67,.12,.36,.41,.04,-.47,-.03,-.13,.63,-.05)*f0_2+\n        mat4(.17,-.17,.28,.46,-.72,-.78,-.59,.11,-.12,-.03,.91,-.12,.65,-.76,-.24,.77)*f0_3+\n        vec4(.11,1.29,-.08,-.69))/2.6+f0_3;\n    f0_0=sin(mat4(-.22,.19,.01,-.45,-.78,.23,.19,-.25,.31,-.12,-.57,-.06,.35,.13,.75,-.67)*f1_0+\n        mat4(.69,.26,-.13,.55,-.63,.33,.14,.40,-.11,.53,-.22,-1.16,-.87,.15,-.11,-.02)*f1_1+\n        mat4(-.67,.13,-.02,1.22,-.09,.51,.06,.22,-.26,-.04,.12,.30,-.56,.06,.29,.28)*f1_2+\n        mat4(-.54,.45,.55,.69,-.00,-.45,.13,-.57,.50,.38,.87,.44,-.65,.53,.14,-.10)*f1_3+\n        vec4(.06,.57,-.20,.16))/2.8+f1_0;\n    f0_1=sin(mat4(.70,-.42,-.29,.88,.63,-.16,.93,.23,-.48,-.31,.55,.84,.42,.52,-.00,.70)*f1_0+\n        mat4(.40,-.39,.07,-.55,.26,.10,-.33,-.06,-.34,.18,.34,-.17,-.57,-.13,.63,-.56)*f1_1+\n        mat4(-.38,-.08,-.11,.08,1.11,-.37,-.39,-.40,.11,-.26,.13,.08,-.61,-.07,.08,-.58)*f1_2+\n        mat4(.44,.44,.48,.30,-.20,-.36,.50,-.10,.68,.33,-.37,.54,.43,.23,.01,.30)*f1_3+\n        vec4(.57,.60,-.29,-.62))/2.8+f1_1;\n    f0_2=sin(mat4(-.41,-.35,-.77,.46,.05,.33,-.91,1.12,-.37,-.33,.15,.36,1.07,-1.50,-.58,-.48)*f1_0+\n        mat4(-.43,-.30,.03,-.06,.08,-.14,.51,-.15,-.37,-.12,-.72,.50,.30,-.76,.52,-.57)*f1_1+\n        mat4(.32,-.45,.12,-.76,.59,-.19,.41,.06,-.56,.15,.56,-.02,.31,.12,-.18,-.37)*f1_2+\n        mat4(.07,-.50,.33,-.33,.14,.04,-.45,.04,.01,.40,-.16,-.99,-.12,-.58,.09,-.79)*f1_3+\n        vec4(.04,-.18,.46,.37))/2.8+f1_2;\n    f0_3=sin(mat4(1.33,.62,-.65,.89,-.19,-.42,.31,.51,.62,.27,-.44,-.06,.14,-.02,-.15,-.23)*f1_0+\n        mat4(-.15,.38,.19,-.24,.08,.30,-.04,.69,-.93,.13,-.13,-.64,.38,-.11,-.26,-.57)*f1_1+\n        mat4(-.85,.56,-.10,-.16,.27,.50,-.64,.66,-.16,.18,.70,-.13,.96,-.28,.41,-.12)*f1_2+\n        mat4(.31,-.42,-.57,-.46,-.25,.60,.14,-.50,-.05,-.46,.61,-.10,-.26,-.04,-.48,.32)*f1_3+\n        vec4(.76,.21,.40,.70))/2.8+f1_3;\n    f1_0=sin(mat4(.23,.33,-.55,1.40,.24,-.72,-.37,-.15,-.20,.01,.13,-.58,-.15,.13,-.47,.37)*f0_0+\n        mat4(.30,-.80,.53,.03,.79,-.25,-.39,.24,-.06,.44,-.47,.17,.30,-.00,-.28,.19)*f0_1+\n        mat4(-.01,-.08,.20,-.36,.31,.40,-.49,-.38,.12,.68,.05,-.15,.53,.33,-.40,-.75)*f0_2+\n        mat4(.43,.27,-.09,.73,-.15,.15,.06,-.68,-.61,-.98,.98,.03,.04,.97,-1.37,.00)*f0_3+\n        vec4(-.21,.83,-.61,.80))/3.0+f0_0;\n    f1_1=sin(mat4(.38,.43,-.28,.32,.70,-.75,.54,-.59,-.36,.87,.55,-.21,.06,-.27,-1.03,-.36)*f0_0+\n        mat4(.49,-.76,-.36,-.26,-.27,-.39,.44,.20,.02,.62,-.05,-.52,.22,-.13,.16,.44)*f0_1+\n        mat4(-.38,-.72,-.10,.33,-.22,.04,.10,.03,.42,.20,.10,-.52,-.24,-.19,.97,.28)*f0_2+\n        mat4(.67,-.42,-.33,.56,-.44,.26,.63,.72,.12,-.77,-.19,.21,.43,.33,-.14,.38)*f0_3+\n        vec4(.17,-.92,.07,-.02))/3.0+f0_1;\n    f1_2=sin(mat4(.12,-.08,-.38,-.85,-.63,-.11,.22,.58,-.53,-.38,.64,-.71,.15,-.61,-.21,.80)*f0_0+\n        mat4(-.25,-.60,.36,-.57,.30,-.48,.43,.12,.26,-.52,-.08,.01,.34,-.48,.54,.30)*f0_1+\n        mat4(.22,-.31,.05,-.37,-.83,.19,.78,-.55,-.12,.12,.03,.08,-.32,.26,-.24,-.44)*f0_2+\n        mat4(.48,-.56,.59,-.06,.30,.69,-.37,.24,-1.16,.09,.04,.43,-.02,-.61,.79,.28)*f0_3+\n        vec4(-.17,.14,.53,-.00))/3.0+f0_2;\n    f1_3=sin(mat4(-.54,-.62,.16,.54,.49,-.25,.22,.78,.97,-.58,-.03,.14,.14,-.23,.02,-.25)*f0_0+\n        mat4(.08,-.48,-.05,-.16,.57,.75,-.93,.12,-.27,-.70,.28,-.08,-.72,-.69,.18,-1.09)*f0_1+\n        mat4(.61,-.13,-.43,.03,-.13,.17,-1.19,.06,-.05,-.18,.08,.28,.94,-.40,.24,.03)*f0_2+\n        mat4(.06,.21,.03,-.29,-.71,.79,.15,.32,.03,.07,.65,-.32,-.14,.36,-.35,.33)*f0_3+\n        vec4(-.46,.67,.19,.78))/3.0+f0_3;\n    f0_0=sin(mat4(.27,.27,-.62,1.70,-.42,-1.11,-.43,-.72,.42,.58,-.82,-.42,-1.72,-.77,-.32,.39)*f1_0+\n        mat4(-.42,-.83,.58,-.20,.19,-.93,-.69,.90,-.56,.94,.13,-.35,.14,.39,-.01,-.45)*f1_1+\n        mat4(-.49,-.23,.49,-.09,.48,-.47,.30,-.65,-.03,-.49,-.75,-.19,-.14,-.49,.36,-1.53)*f1_2+\n        mat4(-.48,-.24,-.11,-.09,-.21,.17,.11,-1.19,-.50,-1.03,.15,.23,.50,-.43,-1.04,.32)*f1_3+\n        vec4(.07,-1.32,.36,.89))/3.2+f1_0;\n    f0_1=sin(mat4(-.14,.30,-1.12,.13,.15,.59,-.21,.60,.85,.07,-.39,.06,-.37,-.57,-.03,.02)*f1_0+\n        mat4(.29,.21,.23,-.73,-.24,-.07,-.46,.07,.65,.51,.19,.01,.18,.04,.53,-.34)*f1_1+\n        mat4(-.69,-.03,.40,.77,.58,.67,-.13,-.06,.21,.18,-.01,.74,-.29,.58,.85,-.08)*f1_2+\n        mat4(-.40,-.67,.52,-.10,-.19,.23,.21,-.07,.83,.99,-.21,.32,.08,-.46,.21,1.04)*f1_3+\n        vec4(-.47,-.10,-.19,.55))/3.2+f1_1;\n    f0_2=sin(mat4(.17,.89,-.48,-.01,-.85,.22,-.83,.05,-.72,-1.06,.21,.59,.75,-.07,-.98,-.28)*f1_0+\n        mat4(-.34,-.05,-.57,-.40,-.06,-.24,.51,-.02,.34,.97,-.05,-.36,.72,.03,-.01,.15)*f1_1+\n        mat4(-.38,1.11,.62,.14,-.39,-.69,-.19,-.19,-.03,.23,.55,-.27,-.75,.13,-.56,-.16)*f1_2+\n        mat4(-.01,-.33,.33,-.21,.60,.67,.35,-.03,-.88,-.92,.09,-.10,-.55,.58,.44,-.08)*f1_3+\n        vec4(.55,-.71,-.27,-.44))/3.2+f1_2;\n    f0_3=sin(mat4(.61,-.50,-.65,.59,-.31,-.85,-.21,-.25,.19,-.03,-.13,.96,-.22,.43,-.50,-.17)*f1_0+\n        mat4(.33,1.07,.39,-.46,.80,-.34,-.32,.33,-.11,-.36,.97,-.48,-.53,.69,.61,.01)*f1_1+\n        mat4(-.39,-.14,-.00,-.06,.00,-.35,.22,.02,.29,-.06,-.15,.17,-.56,-.20,-.39,-.74)*f1_2+\n        mat4(.04,.49,.50,.09,.22,.06,.11,-.13,.23,.43,.01,.89,.09,-.14,-.16,.53)*f1_3+\n        vec4(.76,.36,.01,-.78))/3.2+f1_3;\n    f1_0=sin(mat4(.37,1.12,-.17,.05,.41,.79,-.52,-1.27,.81,-.99,.04,-.49,-.27,.34,-.08,-.11)*f0_0+\n        mat4(.01,.32,.47,-.13,.33,.50,.42,.15,.38,.03,.15,.18,-.98,-.11,-.30,-.47)*f0_1+\n        mat4(.26,.12,-.07,.56,-1.54,.77,.01,.57,.69,.24,.04,-.17,-.53,.44,.54,.01)*f0_2+\n        mat4(-.16,-.36,.69,-.51,-.50,-.52,.22,-.39,-.45,.14,.02,-.38,.96,.25,.13,.16)*f0_3+\n        vec4(.20,.95,1.38,.52))/3.3+f0_0;\n    f1_1=sin(mat4(.94,.43,.50,.30,.55,-.86,-.45,.48,-.00,.32,.00,-.40,-.10,1.38,.07,-.46)*f0_0+\n        mat4(.50,1.28,.09,-.35,-1.10,-.51,-.35,-.14,.21,-.17,-.01,.21,.42,.28,.30,-.14)*f0_1+\n        mat4(-.55,.98,.90,-.43,.27,.03,.45,-.34,.16,.26,.73,.81,.18,-.52,.27,.12)*f0_2+\n        mat4(.37,1.25,.25,.29,-.46,-1.42,-.58,.18,.54,1.37,.49,.42,.09,.77,-.01,.10)*f0_3+\n        vec4(-.50,.21,.05,.90))/3.3+f0_1;\n    f1_2=sin(mat4(-.36,-.57,.71,-.21,-.86,-.12,.71,.27,-.13,-1.03,-.49,-1.10,-.16,.48,-.83,.66)*f0_0+\n        mat4(-.21,-.27,.86,.15,.01,-.32,.08,.41,-.72,.32,-.29,-.34,-.03,-.75,.19,-.11)*f0_1+\n        mat4(.47,.34,-.08,.79,.24,.81,.48,.90,-.35,.05,.21,-.18,.05,-.13,-.51,.79)*f0_2+\n        mat4(.39,-.06,-.67,.11,.63,-.41,-.16,-.26,-.88,-.23,-.38,.16,.18,.02,-.40,.81)*f0_3+\n        vec4(.67,.65,.33,.83))/3.3+f0_2;\n    f1_3=sin(mat4(-.07,.82,-.41,-1.00,.45,-.15,-1.14,-.95,.58,-.10,.34,-.76,.01,.18,-.52,-.12)*f0_0+\n        mat4(.66,-.28,.90,.04,.31,.45,-.13,.43,-.66,-.24,-.22,-.36,-.86,-.24,-.59,-.39)*f0_1+\n        mat4(.50,.13,.16,.61,-1.10,-.99,-.11,.06,-.14,-.32,-.19,-.12,.64,.14,-.21,-.74)*f0_2+\n        mat4(-.22,.30,.52,.62,-.95,.48,.47,.26,1.10,-.64,.08,-.70,-.23,-.41,.12,.07)*f0_3+\n        vec4(.25,-.15,.55,.18))/3.3+f0_3;\n    f0_0=sin(mat4(.06,.92,.24,-1.49,-.63,.23,-.27,-.31,-.47,-.24,.25,-.02,-.08,-.26,-.11,.03)*f1_0+\n        mat4(.79,-.09,-.29,.45,.08,.73,.04,-.08,-.49,-.25,-.41,.31,.08,.33,-.52,-1.23)*f1_1+\n        mat4(.76,.03,.43,.02,.12,.49,.42,.07,.63,-.15,-.14,-.39,-.32,.26,.33,.75)*f1_2+\n        mat4(-.48,.16,-.39,-.05,.20,.54,-.36,-.60,.13,-.14,.27,.03,.78,.59,.56,.46)*f1_3+\n        vec4(.42,.65,-.29,1.02))/3.5+f1_0;\n    f0_1=sin(mat4(.73,-.20,-.70,.10,.84,-.30,-.40,.66,.62,-.05,.35,.23,-.47,-.09,-.40,.20)*f1_0+\n        mat4(.74,.95,.70,-.25,-.80,.36,.10,.83,-.39,-.26,-.05,.66,-.16,.39,-.77,-.56)*f1_1+\n        mat4(-.56,-.80,-.38,-.21,1.21,-.26,-.74,.05,.53,-.13,.63,-.38,.50,-.22,-.15,-.81)*f1_2+\n        mat4(.23,.14,.05,.12,.41,-.59,.43,.06,-.11,.29,.52,-.44,.40,-.29,-.56,.09)*f1_3+\n        vec4(.29,-.61,-.22,.39))/3.5+f1_1;\n    f0_2=sin(mat4(.07,.19,-.24,.32,.02,-.15,-.35,-.77,.70,.03,-.07,-.13,.11,.22,1.01,.01)*f1_0+\n        mat4(-1.08,-.02,.07,-.04,.87,.77,-.14,-.21,-.33,-.00,-.09,-.30,-.71,-.02,-.70,1.30)*f1_1+\n        mat4(.59,-1.19,.55,-1.35,-.01,.85,-.24,-.83,.76,-.47,.18,-.33,-1.57,-.40,-.18,.34)*f1_2+\n        mat4(-.25,-.29,-.23,-.02,.86,-.38,-.42,.07,-.78,.25,-1.08,-.28,-.29,-.33,.11,-.94)*f1_3+\n        vec4(.04,-.17,-.58,-.47))/3.5+f1_2;\n    f0_3=sin(mat4(-.00,.99,-.43,-.28,-1.20,-.48,-1.14,-1.64,.59,.14,.88,-.47,-.85,-.05,-.52,.15)*f1_0+\n        mat4(-.10,-.16,-1.02,-.27,-.62,.80,.03,-.37,.42,-.45,-.47,.18,.24,.63,-.61,-1.22)*f1_1+\n        mat4(.50,.06,-.18,1.23,.37,-.31,-.41,.54,.07,-.14,-.18,1.22,-.03,-.05,-.68,.25)*f1_2+\n        mat4(.38,-.06,.88,-.66,.34,.31,.17,.69,.21,.75,-.24,-.72,-.58,.21,-.48,.07)*f1_3+\n        vec4(.26,.08,-.48,-.27))/3.5+f1_3;\n    f1_0=sin(mat4(.32,-.56,-.39,1.13,-.92,-1.84,.99,.00,.05,1.48,.50,-.78,-.04,.10,-.43,.30)*f0_0+\n        mat4(.02,.85,-.52,.31,-.22,-.61,.02,-.15,.37,-.39,-.49,-.03,-.31,.77,-.23,-.23)*f0_1+\n        mat4(.41,-.67,-.19,-.22,.02,-.24,.37,-.49,.60,.88,.08,-.54,-.13,.66,-1.61,-.29)*f0_2+\n        mat4(-.18,.75,.08,-.35,-.19,-1.06,.36,.22,-.77,.98,.83,-.74,.93,-.75,-.12,.67)*f0_3+\n        vec4(1.61,1.14,-.20,.41))/3.6+f0_0;\n    f1_1=sin(mat4(-1.00,1.90,-.45,-.23,1.43,1.31,-.28,.31,-.98,.04,1.14,.41,-1.19,-.39,.19,-.05)*f0_0+\n        mat4(.20,.34,-.29,.81,1.13,-.73,-.41,-.71,-.78,-.16,-.02,.25,-.00,.74,.26,-.66)*f0_1+\n        mat4(-.73,-.96,.30,.47,1.72,-.93,-.10,-.01,.17,-.58,.40,.61,.75,.31,-.36,.32)*f0_2+\n        mat4(-.17,.17,-.00,.44,.46,.43,-.50,-.21,-.64,-.13,.48,-.01,-.05,-.91,.27,.22)*f0_3+\n        vec4(.28,-.27,.09,.23))/3.6+f0_1;\n    f1_2=sin(mat4(1.15,.61,.11,.22,-.47,.52,-.04,-.12,-.60,-.56,.22,-.06,.25,-.14,-.04,-.06)*f0_0+\n        mat4(-1.15,.38,.22,-.94,-.01,.24,-.78,.21,.16,.52,-.41,.47,1.10,-.10,-.67,1.12)*f0_1+\n        mat4(-.08,-1.20,.07,.56,.61,1.14,-.60,-.75,-.16,-.10,-.33,.01,-.73,.88,-.99,-.57)*f0_2+\n        mat4(-.13,-.91,-.30,.44,.43,-.06,.59,.58,.43,-.75,-.07,-.03,.75,.22,.42,.06)*f0_3+\n        vec4(.17,.38,-.04,-.50))/3.6+f0_2;\n    f1_3=sin(mat4(.04,.44,-.52,-.19,-1.30,-.12,-.99,-1.73,-.14,-.49,1.06,-.30,.05,.16,.26,-.50)*f0_0+\n        mat4(-.33,-.59,-.48,.19,.16,.69,.21,.08,-.35,-.08,.73,-.22,-.13,.28,-.28,-.90)*f0_1+\n        mat4(-.33,-.82,.42,.88,.52,-.43,-2.31,.03,.17,-.24,-.50,.66,-.71,-.65,-1.88,-.52)*f0_2+\n        mat4(-.52,-.47,.27,.12,-.12,-.63,-.38,.12,-.16,.23,.40,.33,.33,-.03,1.03,.93)*f0_3+\n        vec4(-.08,-.73,-.58,.23))/3.6+f0_3;\n    f0_0=sin(mat4(-1.44,.51,.48,-.01,-.86,.60,-1.15,1.52,-1.25,-.96,.10,-.22,.49,1.07,-.50,-.05)*f1_0+\n        mat4(-.99,.82,-1.12,-.78,.13,.55,-.61,.47,-.51,-.50,.21,-.22,.86,.35,-.74,.06)*f1_1+\n        mat4(.28,.22,.07,-1.19,-1.54,-.37,-.27,-.23,-.86,-.69,.22,-.20,-1.48,.60,-.40,.51)*f1_2+\n        mat4(.60,.15,-.20,-.12,-.22,.04,-.73,.16,1.82,-.52,-.46,.50,.50,-.73,-.52,-1.02)*f1_3+\n        vec4(-.59,.59,.87,.11))/3.7+f1_0;\n    f0_1=sin(mat4(-.65,.25,.07,-.07,-1.18,-.50,.55,-.83,-.50,-.59,-.63,-1.13,-.56,-.37,-.63,.84)*f1_0+\n        mat4(-.29,.03,.73,-.89,-.45,-.16,.76,.34,.78,.27,-.30,-.29,.45,.60,-.70,.28)*f1_1+\n        mat4(.27,.43,-.09,1.35,.52,.01,-.32,-.50,.89,-.08,-.11,.99,1.27,.89,.43,.40)*f1_2+\n        mat4(-.33,.27,.05,-.46,-.75,.55,.33,-.04,-.93,.36,.97,-.31,-.06,.12,-1.09,.98)*f1_3+\n        vec4(.40,-.56,-.85,.74))/3.7+f1_1;\n    f0_2=sin(mat4(.36,-.73,.61,-.03,-.26,.12,.22,.50,-.48,-.59,-.08,.70,-.26,-.27,-.46,-.77)*f1_0+\n        mat4(.62,.66,.86,-.53,-.74,1.34,.09,1.02,.11,-.18,-.15,.33,-.86,.46,-.77,.35)*f1_1+\n        mat4(.94,-.35,-.53,.37,-.22,-.59,.78,.24,-.06,-.34,.17,.39,.29,.50,-.29,-.08)*f1_2+\n        mat4(-.57,.38,-.48,.10,-.42,.16,.67,.52,.32,.36,-.52,-.33,-.39,.05,.08,.36)*f1_3+\n        vec4(-.38,-.49,.35,-.15))/3.7+f1_2;\n    f0_3=sin(mat4(1.21,.10,.94,.52,.33,1.11,-2.47,-1.55,-.13,-.26,-.02,-.32,-.16,-.04,.80,-.36)*f1_0+\n        mat4(.06,-.01,.34,-.14,-.40,-.02,-2.14,-1.23,.54,-.15,.69,.53,-.04,-.52,.68,.51)*f1_1+\n        mat4(-.83,.68,1.19,-1.47,-.90,.26,-.67,.20,-.64,-.14,.15,-.89,.33,.31,.43,.49)*f1_2+\n        mat4(.69,.57,.10,.10,.03,-.68,-.44,-.54,.09,-.11,-.02,.13,-.09,-.22,.60,.72)*f1_3+\n        vec4(.46,.29,-.13,.29))/3.7+f1_3;\n    f1_0=sin(mat4(1.08,-.19,-1.36,.31,.00,.53,-.20,1.24,.08,.27,-.36,.51,.03,-.32,.00,1.04)*f0_0+\n        mat4(-.29,-.43,-.08,.08,.09,-.55,-1.06,-1.17,.05,.80,-.85,1.53,.28,.69,.44,.08)*f0_1+\n        mat4(.36,-.53,-.35,.94,-.62,-.22,-.30,-.28,.01,-.44,.40,-.28,-.30,.03,-.32,.27)*f0_2+\n        mat4(.54,.48,-.31,.27,.19,-.46,.08,-.65,.08,.33,.13,-.52,.41,-.96,-.18,.90)*f0_3+\n        vec4(-.25,.58,-1.90,-.79))/3.9+f0_0;\n    f1_1=sin(mat4(-1.04,-.87,1.01,-.16,-.70,-1.53,.23,.53,.12,.35,.53,-.44,-.01,-1.28,-.08,.18)*f0_0+\n        mat4(-.50,1.43,.61,-.28,-1.91,-.07,.38,-.78,.77,-.10,.45,.59,.07,.32,-.09,-.35)*f0_1+\n        mat4(-1.21,.91,-.72,-.06,.68,-.07,-.40,-.24,1.32,.49,.60,.32,.21,-.30,.11,-.20)*f0_2+\n        mat4(-1.63,-.20,-.53,.12,-.47,-.72,-.11,.21,1.45,.27,-.43,-.60,.95,-.28,-.03,-.25)*f0_3+\n        vec4(-.61,.12,.47,-.19))/3.9+f0_1;\n    f1_2=sin(mat4(-1.03,.88,.15,1.64,-.27,-.22,-.10,-.38,-1.17,-.41,-.40,-.49,-.80,-.06,.24,-.13)*f0_0+\n        mat4(1.01,.40,-.48,.89,.13,-.35,-.94,-.38,.60,.18,.25,.64,1.10,-1.40,.27,-.70)*f0_1+\n        mat4(.94,-.78,.20,.85,1.11,.59,-.58,-.99,-.41,-.38,-.46,.07,.59,.23,-.90,.35)*f0_2+\n        mat4(.33,.81,.07,.06,-.48,-.37,-.37,-.14,.20,.05,-.41,-.58,-.22,.01,-.20,.26)*f0_3+\n        vec4(.15,1.23,-.23,.24))/3.9+f0_2;\n    f1_3=sin(mat4(-1.23,-.12,-.69,-2.60,.05,-1.03,-.10,.86,-.25,.47,.63,.80,-.70,.07,-.79,.50)*f0_0+\n        mat4(.20,-.33,.70,-.60,-.31,-.80,.04,.43,-.21,-.29,.21,.62,-.08,-.23,-.74,.65)*f0_1+\n        mat4(-.55,.72,.79,.38,.90,.70,-.97,-.03,.19,-.21,-.36,-.13,.30,.24,-.31,-.07)*f0_2+\n        mat4(-.76,.37,-.34,-.71,.17,-.13,.03,-.80,-.67,.55,.24,.87,.35,.71,2.50,-.66)*f0_3+\n        vec4(-.60,-.34,-.10,-1.24))/3.9+f0_3;\n    f0_0=sin(mat4(.77,1.30,-1.10,1.94,.02,1.02,.20,.60,.67,.34,-.37,-.03,.83,1.69,.56,-1.15)*f1_0+\n        mat4(.29,-1.11,-.93,1.35,.33,-.50,-1.42,-1.56,.35,-.17,-.52,1.01,-.05,-.44,-.06,-.72)*f1_1+\n        mat4(-.37,-.76,-.62,.82,-.78,.21,-.26,-1.06,.35,-.72,-.63,-2.98,-.51,-.97,-.99,2.10)*f1_2+\n        mat4(-.20,-.26,.40,.98,.16,.06,.37,.08,-.59,.12,.80,.39,-.17,.49,-.02,.39)*f1_3+\n        vec4(-.09,-.11,.58,3.17))/4.0+f1_0;\n    f0_1=sin(mat4(.01,.33,.45,-.89,-1.83,-.30,.69,.48,-.95,.61,-.55,.54,.43,-.20,.32,.08)*f1_0+\n        mat4(-.96,.05,.07,-.82,-1.55,.73,.36,-.20,1.99,.06,-.16,.01,.37,.16,-.76,-.44)*f1_1+\n        mat4(-1.23,-.20,-1.51,.38,-.41,-.41,-.29,-.00,.95,-.05,-.54,.83,-.10,.28,.34,-.18)*f1_2+\n        mat4(-2.41,-.21,.33,.53,.87,-.18,.09,1.08,-1.39,.80,-.38,.30,.42,-.21,-.47,-.67)*f1_3+\n        vec4(.24,.62,.59,-.76))/4.0+f1_1;\n    f0_2=sin(mat4(.21,-.88,.15,.06,.48,-.72,-.11,-.56,-.53,-.02,-.11,-1.23,.96,-.07,-.57,.58)*f1_0+\n        mat4(-.39,-.15,-.54,-.58,-.97,1.13,-.65,1.18,.08,-.56,.58,-.40,.60,.05,.73,.15)*f1_1+\n        mat4(.07,.02,-.54,-.38,1.26,.69,.33,.17,-.92,.29,-.21,.65,.97,-.11,.99,1.18)*f1_2+\n        mat4(-.66,.39,.47,-1.03,-1.00,-.18,-1.00,-.56,1.06,.11,.98,-.69,.79,-.30,.51,-1.39)*f1_3+\n        vec4(-.99,.08,-.13,-1.61))/4.0+f1_2;\n    f0_3=sin(mat4(-.69,-.68,.81,-.98,-.55,.41,-.31,-.83,-.59,.21,-.05,-.86,-.21,-.01,-.90,-.56)*f1_0+\n        mat4(-.25,.39,1.21,.28,-.53,-.71,.24,-1.41,-.37,-.27,-2.10,.44,-.13,.57,1.03,-.70)*f1_1+\n        mat4(.35,-.10,-2.62,-.11,.84,-.49,-.88,-.35,.24,-.26,.59,.53,1.21,-1.15,-.78,1.54)*f1_2+\n        mat4(-.85,-.08,.49,-.87,-.59,.46,.88,.01,.84,.62,.21,.04,.01,.52,-1.40,-.54)*f1_3+\n        vec4(-.63,-.41,3.10,1.54))/4.0+f1_3;\n    float f_0=dot(f0_0,vec4(-.05,.05,.01,.01))+\n        dot(f0_1,vec4(.01,-.05,-.03,.04))+\n        dot(f0_2,vec4(.01,-.02,.02,-.01))+\n        dot(f0_3,vec4(.02,.02,.01,.01))+\n        0.470;\n    \n    f_0 += (.3+.7*smoothstep(.25, .3, f_0)) * (fbm(uv*100.)+.3)*.01 - .25;\n    \n    o.x = f_0 * .15;\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const vec3 lDir = normalize(vec3(-1, .3, -1));\nconst vec3 lCol = vec3(5, 4.7, 4);\nconst vec3 fCol = vec3(.7, .8, 1.);\nconst float fExt = 30.;\nconst float fDensity = 1.5;\nconst float fStep = .7;\nconst float fAnis = .3;\nconst float tScale = 2000.;\nconst float tHeight = 4. / tScale;\nconst float vDensity = 2.5 * tScale;\nconst float vStep = .6 / tScale;\n\n\nstruct Intersection {\n    float t;\n    vec3 albedo;\n    bool volumetric;\n};\n\n\nvec2 heightDensityMap(vec2 p) {\n\n    return texture(iChannel0, p).xy;\n    \n}\n\n\nfloat terrainSdf(vec3 p) {\n\n    return p.y - heightDensityMap(p.xz).x;\n    \n}\n\n\nvec4 terrainNormal(vec2 p) {\n\n    float e = heightDensityMap(p).x;\n    vec3 k = vec3(1./iChannelResolution[0].xy, 0);\n    return vec4(normalize(vec3((e - vec2(heightDensityMap(p + k.xz).x, heightDensityMap(p + k.zy).x))/k.xy, 1.).xzy), e);\n    \n}\n\n\nvec3 sky(vec3 rd) {\n\n    return mix(vec3(1., 1.4, 2.), vec3(.7, 1.2, 2.5), smoothstep(-.2, 2., dot(rd, vec2(.1, 3.).xyx)));\n    \n}\n\n\nvec3 skyAmbient() {\n\n    return vec3(.8, 1.3, 2.3);\n    \n}\n\n\nvec4 treeVolume(vec3 p) {\n\n    p *= tScale;\n    \n    float cHash = 0., d = 1000.;\n    \n    for(int j = 0; j < 2; j++) {\n        for(int i = 0; i < 2; i++) {\n        \n            ivec2 c = ivec2(floor(p.xz - .5)) + ivec2(i, j);\n            float hash = fhash2(c);\n            \n            vec2 u = vec2(c) + vec2(fract(hash * 12345.), fract(hash * 54321.));\n            vec2 e = heightDensityMap(u / tScale);\n            vec3 t = vec3(u.x, e.x * tScale, u.y);\n            \n            float h = 2. + 1.5 * fract(hash * 23154.);\n            t.y += h / 2.;\n            t   -= p;\n            t.y /= h;\n            float m = dot(t, t);\n            \n            // using mix to avoid branching\n            float f = step(1. - fract(hash * 35142.), e.y) * step(m, d);\n            cHash = mix(cHash, hash, f);\n            d = mix(d, m, f);\n        }\n    }\n    \n    d = sqrt(d) - .6 + .7 * (texture(iChannel2, .15 * p).r - .5);\n    \n    return vec4(vec3(.08, .08, .03) + vec3(.03, .07, .03) * cHash, step(d, 0.));\n    \n}\n\n\nfloat shadow(vec3 p) {\n    \n    // == tree shadows =========================================\n\n    p += lDir * vStep * random();\n    \n    float o = 0., m = -log(random()) / (vDensity * vStep);\n    \n    for(int i = 0; i < 8 && o < m; i++) {\n        o += treeVolume(p).a;\n        p += lDir * vStep;\n    }\n    \n    if(o > m) return 0.;\n\n    // == terrain soft shadows ==================================\n    \n    const float lRad = .07;\n    float sTheta = lRad;\n    \n    float t = .0001, d = .002;\n    \n    for(int i = 0; i < 64 && d > 0. && d < .2; i++) {\n    \n        d = terrainSdf(p + t*lDir) + .002;\n        sTheta = min(d / t, sTheta);\n        \n        t += fStep * d;\n        \n    }\n    \n    return clamp(sTheta / lRad, 0., 1.);\n}\n\n\nIntersection trace(vec3 ro, vec3 rd) {\n\n    const Intersection noInt = Intersection(-1., vec3(0), false);\n    const vec3 center = vec3(.5, 0.45, .5);\n    \n    \n    // == bounding box intersection ===========================\n    \n    rd += (1. - abs(sign(rd))) * .0000001;   // avoids div/0\n    \n    vec3 cv = (center - ro - sign(rd) * .5) / rd;\n    vec3 fv = (center - ro + sign(rd) * .5) / rd;\n    \n    float cPlane = max(max(max(cv.x, cv.y), cv.z), 0.);\n    float fPlane = min(min(fv.x, fv.y), fv.z);\n    \n    if(fPlane < cPlane) return noInt;\n    \n    \n    // == terrain intersection =================================\n    \n    float t = cPlane;\n    float ld = terrainSdf(ro + t * rd);\n    \n    if(ld < 0.) return noInt;\n    \n    float td = ld < tHeight ? t : -1., ls = ld * fStep;\n    \n    for(int i = 0; i < 256; i++) {\n    \n        t += ls;\n        \n        float d = terrainSdf(ro + rd * t);\n        \n        if(d < tHeight && td < 0.) {\n            // interpolated tree height intersection\n            td = t - ls * (tHeight - d) / (ld - d);\n        }\n        \n        if(abs(d) < .0001 || t >  fPlane) break;\n        \n        ls = d * fStep;\n        ld = d;\n        \n    }\n    \n    if(t > fPlane) t = -1.;\n    \n    if(td < 0.) return noInt;\n    \n\n    // == trees intersection =================================\n    \n    td += vStep * random();\n    \n    vec4 vol = vec4(0.);\n    float oDepth = 0.;\n    float thresh = -log(random()) / vDensity;\n    float wt = -ro.y / rd.y;\n    float far = t < 0. ? fPlane : (wt < t && wt > 0.) ? min(wt, fPlane) : t;\n    \n    for(int i = 0; i < 256 && oDepth < thresh && td < far; i++) {\n    \n        vec3 p = ro + rd * td;\n        \n        vol = treeVolume(p);\n        \n        float ss = max(vStep, (terrainSdf(p) - tHeight) * fStep);\n        oDepth += vol.a * ss;\n        \n        td += ss;\n        \n    }\n    \n    if(oDepth >= thresh && td < far) return Intersection(td, vol.rgb, true);\n    \n    if(t < 0.) return noInt;\n    \n    \n    // == terrain texturing =================================\n    \n    vec3 p = ro + rd * t;\n    vec4 n = terrainNormal(p.xz);\n    vec3 tex = texture(iChannel3, p.xz * 50.).rgb;\n    \n    vec3 sCol = mix(vec3(.15, .10, .05), vec3(.30, .25, .15), tex.x);\n    vec3 gCol = mix(vec3(.10, .20, .00), vec3(.40, .30, .10), tex.x) * tex.y;\n    vec3 rCol = vec3(.50, .45, .40) * tex * tex;\n    \n    float fbm = fbm(p.xz * 200.);\n    \n    vec3 albedo = sCol;\n    albedo = mix(albedo, gCol, smoothstep(.2, .5, .5 * fbm + 1000. * n.w));\n    albedo = mix(albedo, rCol, smoothstep(.2, .3, .2 * fbm + 1.-n.y));\n    \n    return Intersection(t, albedo, false);\n    \n}\n\n\nvoid fog(vec3 ro, vec3 rd, float depth, inout vec3 col, inout float att) {\n    \n    // == bounding sphere intersection ================================\n    \n    vec3 p = ro - vec3(.5, 0., .5);\n    float b = -dot(p, rd);\n    float d = b * b - dot(p, p) + .5;\n    \n    if(d < .0) return;\n    \n    float s = sqrt(d);\n    vec2 cp = vec2(max(b - s, 0.), b + s);\n    \n    if(cp.x >= cp.y) return;\n    \n    ro += rd * cp.x;\n    depth = clamp(depth, cp.x, cp.y) - cp.x;\n    \n    // == volume integration =======================================\n    \n    float hS = fExt * (ro.y + depth * rd.y);\n    float hE = fExt * (ro.y);\n    \n    // analytical volume integration for density = fDensity*exp(-fExt*height)\n    float denom = fExt * rd.y;\n    float oDepth = (denom == 0.) ? exp(ro.y) * depth : (exp(-hE) - exp(-hS)) / denom;\n    \n    float e = exp(-fDensity * oDepth);\n    float hg = .25 * (1. - fAnis * fAnis) / pow(1. + fAnis * (fAnis - 2. * dot(rd, lDir)), 1.5);\n    col = col * e + att * (1. - e) * fCol * (skyAmbient() * .25 + lCol * hg);\n    att *= e;\n    \n}\n\n\nfloat waterDisplacement(vec2 p) {\n\n    float e = heightDensityMap(p).x;\n    \n    float swell = sin(pow(.03 - min(e * 25., 0.), .1) * 200. - p.y * 500. + iTime * 1.5) * .000005;\n    float chop = fbm(p * 1000.+iTime*.1) * .00001;\n    \n    return chop + swell;\n    \n}\n\n\n// This function is messy, but necessary to be able to skip reflections tracing on DX11 (ifs don't work, you need a return)\n\nbool reflection(inout vec3 ro, inout vec3 rd, inout Intersection t, inout float depth, inout vec3 col, inout float att) {\n\n    float wt = rd.y < 0. ? -ro.y/rd.y : -1.;\n    \n    if(!(wt > 0. && (t.t < 0. || wt < t.t))) return false;\n    \n    depth += wt;\n    \n    // == fog before reflections =================================\n    \n    fog(ro, rd, wt, col, att);\n    \n    \n    // == water normal ===========================================\n    \n    ro += rd * wt;\n    \n    vec2 k = vec2(.00001, 0);\n    float wd = waterDisplacement(ro.xz);\n    vec3 wn = normalize(vec3(wd - vec2(waterDisplacement(ro.xz + k.xy), waterDisplacement(ro.xz + k.yx)), k.x).xzy);\n    \n    \n    // == foam ===================================================\n    \n    float e = heightDensityMap(ro.xz).x;\n    \n    if(all(lessThan(abs(ro.xz - .5), vec2(.5))) && e < 0.) {\n    \n        float foam = clamp(.8 + 20000. * wd + 800. * e, 0., 1.);\n        \n        vec3 dLight = lCol * max(0., dot(lDir, wn));\n        vec3 aLight = skyAmbient();\n        \n        col += att * foam * vec3(.25) * (aLight + dLight);\n        att *= 1.-foam;\n        \n    }\n    \n    \n    // == fresnel ================================================\n    \n    const float r0 = .02;\n    \n    float nol = 1. + dot(wn, rd);\n    float fresnel = r0 + (1.-r0) * nol*nol*nol*nol*nol;\n    \n    \n    // == underwater =============================================\n    \n    const vec3 wCol = vec3(0.027,0.051,0.051);\n    const float wExt = 200.;\n    \n    vec3 uCol = vec3(0);\n    \n    if(t.t > 0.) {\n    \n        // underwater terrain\n        vec4 n = terrainNormal(ro.xz+rd.xz*(t.t-wt));\n        float fLight = r0 + (1.-r0) * lDir.y*lDir.y*lDir.y*lDir.y*lDir.y;\n        vec3  dLight = exp(wExt*n.w / lDir.y) * lCol * max(0., dot(lDir, n.xyz)) * fLight;\n        vec3  aLight = exp(wExt*n.w) * skyAmbient();\n        \n        float wScattering = exp(wExt * (wt - t.t));\n        \n        uCol = (1. - wScattering) * wCol * skyAmbient() + wScattering * t.albedo * (dLight + aLight);\n        \n    } else {\n    \n        // no underwater terrain\n        uCol =  wCol * skyAmbient();\n        \n    }\n    \n    col += att * (1. - fresnel) * uCol;\n    \n    \n    // == reflection of the ray ==================================\n    \n    att *= fresnel;\n    rd = reflect(rd, wn);\n    \n    t = trace(ro + vec3(0.0, 0.0001, 0.0), rd);\n    \n    return true;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n\n    INIT_NOISE;\n    \n    vec2 aa = (vec2(random(), random()) - .5) * .15;\n    vec2 uv = (u - iResolution.xy * .5 + aa) / iResolution.y;\n    \n    vec3 rd = getMat3(0) * normalize(vec3(uv, FocalLength));\n    vec3 ro = getVec3(3);\n    vec3 pro = ro;\n    vec3 prd = rd;\n    \n    vec3 col = vec3(0);\n    float att = 1.;\n    \n    \n    // == raytracing =============================================\n    \n    float depth = 0.;\n    Intersection t = trace(ro, rd);\n    bool reflection = reflection(ro, rd, t, depth, col, att);\n    \n    \n    // == shading ================================================\n    \n    if(t.t >= 0.) {\n    \n        vec3 p = ro + t.t * rd;\n        \n        vec2 e = heightDensityMap(p.xz);\n        vec3 aLight = skyAmbient() * exp(min(p.y - e.x - tHeight, 0.) * vDensity * e.y * .15);\n        vec3 dLight = shadow(p) * lCol;\n        \n        if(t.volumetric) {\n            // shade the trees\n            col += att * t.albedo * (aLight + dLight) * .25;\n        } else {\n            // shade the terrain\n            vec4 n = terrainNormal(p.xz);\n            col += att * t.albedo * (aLight + dLight*max(dot(n.xyz, lDir), 0.));\n        }\n        \n    } else {\n    \n        col += att * sky(rd);\n        \n    }\n    \n    depth += att * (t.t < 0. ? 10. : t.t);\n    \n    \n    // == fog ====================================================\n    \n    fog(ro, rd, t.t < 0. ? 10. : t.t, col, att);\n    \n    \n    // == reprojection ===========================================\n    \n    o = vec4(col, depth > 0. ? depth : 1.);\n    \n    mat3 pCam = getMat3(5);\n    vec3 pRo = getVec3(8);\n    vec3 p = transpose(pCam) * (pro+o.a*prd-pRo);\n    vec2 pUv = FocalLength * p.xy * iResolution.y / p.z + iResolution.xy*.5;\n    \n    if(clamp(pUv, vec2(0), iResolution.xy) != pUv) return;\n    \n    vec4 po = texture(iChannel1, pUv/iResolution.xy);\n    \n    float weight = min(.05 + abs(o.a-po.a)*10., .2);\n    \n    // stronger weight on sky and reflections to avoid ghosting\n    if(reflection || t.t < 0.) weight *= 2.;\n    \n    o = mix(po, o, weight);\n}", "buffer_b_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flc3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 110, 1619]], "test": "untested"}
{"id": "Ntc3Rn", "name": "Hex Cross", "author": "Parcle", "description": "first hex grid shader", "tags": ["hex"], "likes": 0, "viewed": 43, "published": 3, "date": "1635549645", "time_retrieved": "2024-07-30T18:51:57.129306", "image_code": "// Special thanks to The Art of Code\n//     - https://www.youtube.com/c/TheArtofCodeIsCool/videos\n//     - https://www.shadertoy.com/user/BigWIngs\n\nfloat sqrt3 = 1.732;\n\nfloat HexDist(vec2 p){\n    p = abs(p);\n    \n    float rightEdge = p.x;\n    float upperRightEdge = dot(p, normalize(vec2(1.0, sqrt3)));\n    return max(rightEdge, upperRightEdge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resXYRatio = iResolution.x / iResolution.y;\n    vec2 uv = ((fragCoord/iResolution.y) - 0.5*vec2(resXYRatio, 1)) * 2.0;\n    \n    \n    vec2 uvScaled = uv * 3.0;\n    vec2 gridScale = vec2(1.0, sqrt3);\n    vec2 a = (mod(uvScaled, gridScale) - 0.5 * gridScale) * 2.0;\n    vec2 b = (mod(uvScaled + 0.5*gridScale, gridScale) - 0.5 * gridScale) * 2.0;\n    \n    vec2 hexUV = dot(a,a) < dot(b,b) ? a : b;\n    vec2 hexOffset = uv - hexUV; // uv rather then scaled UV for aesthetic reasons only\n    float breath = (-cos(iTime * 0.3) + 1.0) * 0.5 * 40.0; // \"breath\" that goes from 0 to 40 using -cos\n    \n    float colorVal = 1.0 - step(cos(breath * hexOffset.x * hexOffset.y), HexDist(hexUV));\n\n    // Output to screen\n    fragColor = vec4(colorVal, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntc3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 192, 192, 349], [351, 351, 408, 408, 1175]], "test": "untested"}
{"id": "ftc3Rn", "name": "Very nice function!", "author": "SnoopethDuckDuck", "description": "tanh(cos(x)) is very nice, please use it", "tags": ["e"], "likes": 6, "viewed": 216, "published": 3, "date": "1635549336", "time_retrieved": "2024-07-30T18:51:57.900244", "image_code": "\n// 1. / tanh(a*cos(0)) ensures it hits +-1.\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float t = thc(3.5, 0.8 * iTime);\n    \n    float r = 16. + 8. * t;\n    float ix = floor(r * uv.x) + 0.5;\n    uv.x = fract(r * uv.x) - 0.5;\n  \n    vec2 p = 0.2 * r * vec2(0., thc(2., 2. * iTime + 2. * ix));\n\n    float d = length(vec2(uv.x, r * uv.y) - p);\n    float s = step(d, (0.015 - 0.005 * t) * r);\n    \n    fragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftc3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 45, 74, 74, 115], [117, 117, 174, 174, 581]], "test": "untested"}
{"id": "flcGRn", "name": "pixelated rotating donut", "author": "dkaraush", "description": "Inspired by ASCII donut.c", "tags": ["raymarching", "torus", "donut"], "likes": 16, "viewed": 480, "published": 3, "date": "1635547416", "time_retrieved": "2024-07-30T18:51:58.647247", "image_code": "              /*###*/void\n          mainImage(out vec4\n       Q,in vec2 W){float s=sin(\n     iTime),c=cos(iTime),n=1.-c,o=\n    .7,k=o*o;vec3 R=iResolution, d=\n   normalize(vec3(floor((W.xy-vec2((\n  R.x-R.y)*.5,0)       )/R.y*80.)/80.  \n  -.5, 1)), C=           vec3(0);for(  \n  int i=0;i<15           ;++i){vec4 D  \n  =mat4(n*k+c,           n*k,o*s,0,n*  \n  k,n*k+c,-o*s           ,0,-o*s,o*s,  \n  c,0,0,0,0,0)*        vec4(C+vec3(0,\n   0,-4),1);C+=d*(length(vec2(length\n    (D.xz)-1.,D.y))-.4);}/**/Q=vec4(\n     floor(vec3(2.-length(C)/2.5)\n       *12.)/12.,1);}/*#########\n         # made by @dkaraush #\n             # dima.bio #*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcGRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 75, 75, 563]], "test": "untested"}
{"id": "7sySDd", "name": "Sound of storm ", "author": "guil", "description": "Storm, lightnings and thunderbolts.", "tags": ["sound", "lightning", "storm"], "likes": 17, "viewed": 836, "published": 3, "date": "1635546128", "time_retrieved": "2024-07-30T18:51:59.407215", "image_code": "mat2 rot(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\n\nvec2 noise2(in vec2 p){\n\n    vec2 res=vec2(0.);\n    float f=2.;\n\tfor( int i=0; i< 5; i++ ) \n\t{\t\t\n        p*=rot(f);     \n        f*=1.4;\n        res+=sin(p+sin(2.*p.yx));\n\t}        \t\n\treturn res/3.;\n}\n\nfloat dseg( vec2 ba, vec2 pa )\n{\n\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba),0., 2. );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 15; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r += s;      \n    }\n    return d*3.;\n    \n}\n\n\n\nfloat lightning(vec2 x,vec2 tgt,float dt)\n{\n    vec2 r = tgt+5.*sin(tgt+.3*iTime);\n    float d=1000.;\n    float dist=length(tgt-x);\n     \n    for (int i = 0; i < 9; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= (noise2(r)+vec2(0.,.7))*4.;\n        dist = dseg(s,x-r);\n        d=min(d,dist);\n        \n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    float a = (fract(iTime)>.4)?1.:0.3;\n    return a*max(fract(dt-.2*iTime+x.y/100.)-.3,0.)*exp(-8.*d)+a*max(fract(dt+.1-.2*iTime)-.3,0.)*exp(-.2*length(x-tgt));\n   \n}\n\n\n\n\nvoid mainImage( out vec4 C, in vec2 FC )\n{\n    float o,c,i,e,f,s,g,k=1.;\n    vec2 r = iResolution.xy;\n    float t = iTime;\n    \n    \n    for(c++;i++<1e2;g+=min(f,max(.09,e))*.06*k,k*=1.002)\n        {s=2.;vec3 p=vec3((FC.xy-r/s)/r.y*g,g-s);\n        p.y = 1.-p.y;\n        p.yz*=rot(-.8);\n        p.z+=.1*t;\n        for(e=f=p.y;s<2e2;s*=1.4)\n            p.xz*=rot(s),\n            e+=abs(dot(sin(p*s-.2*t)/s,p-p+.3)),\n            f+=abs(dot(sin(p*s*.6+2.9+.2*t)/s,p-p+.4));\n        \n        \n        }\n    \n    \n    \n    o = 1.+ e;\n    o*=.5;\n    C = vec4(o*o*o, o*o, o,1.);\n    vec2 uv =(FC.xy-r/2.)/r.y;\n    uv=(1.-uv)*25.;\n    \n    vec2 n = noise2(uv+.3*noise2(4.*uv))*.7;\n    c = lightning(uv+n,vec2(15.,10.),.4);\n    C.rgb += vec3(c, c*c, c+c*c)*4.;\n    \n}", "image_inputs": [], "sound_code": "#define tau 6.2832\n\nfloat fbm(float t){\n    float s=0.;\n    float a = 16.*exp(-3.*t)*t;\n    for (float f = 20.;f<1500.;f *=1.35){\n        s+=sin(tau*f*(t+2.2))/f;\n    }\n    return a*s;\n}\n\nfloat fbm2(float t){\n    float s=0.;\n    float a = 16.*exp(-2.*t)*t;\n    for (float f = 1.,d=0.;f<2.;f *=1.05, d+=.2){\n        s+=fbm(fbm(t)*f+d)/f;\n    }\n    return s/15.;\n}\n\n\nvec2 mainSound(int samp, float time) {\n    \n    float t = mod(time, 5.0);\n    return vec2(fbm2(t));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sySDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 70], [74, 74, 97, 97, 274], [276, 276, 308, 308, 392], [394, 394, 430, 430, 621], [625, 625, 668, 668, 1268], [1273, 1273, 1315, 1315, 2030]], "test": "untested"}
{"id": "ssKXDd", "name": "kissmarkandras bead1", "author": "kissmarkandras1", "description": "Look around with mouse drag and move with WASD.", "tags": ["sdf", "camera", "spheretracing"], "likes": 1, "viewed": 185, "published": 3, "date": "1635545021", "time_retrieved": "2024-07-30T18:52:00.755610", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const int k = 4;\n    fragColor = vec4(0);\n    /*ivec2 pixel = ivec2(fragCoord);\n    for(int i=-k; i<=k; i++)\n    for(int j=-k; j<=k; j++)\n    {\n        fragColor += texelFetch(iChannel0,pixel+ivec2(i,j),0);\n    }\n    \n    fragColor /= float((2*k+1)*(2*k+1));*/\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0).wwww/15.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nstruct Material { \n\n    vec3  color;        // [0,1/pi] \n\n    float roughness;    // [0,~7] \n\n    vec3  emission;\t    // [0, inf] \n\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals \n\n}; \n\nMaterial matarray[6] = Material[6](Material(vec3(0.1,0.2,0.3),0.0,vec3(1,1,1),0.8),\nMaterial(vec3(0.1,0,0),2.0,vec3(3,3,3),0.6),\nMaterial(vec3(0,0.2,0),5.0,vec3(0,0,0),0.02),\nMaterial(vec3(0.1,0,0.3),6.0,vec3(1,2,1),0.6),\nMaterial(vec3(0,0.2,0.3),0.0,vec3(1,1,8),0.03),\nMaterial(vec3(0.1,0.2,0),1.0,vec3(4,1,1),0.7));\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///SDF\n\nfloat sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    float f = sdSphere(p-vec3(-4,1.5,0), 1.0);\n    float g = sdBox(p-vec3(2,0,0),vec3(1,1,1));\n    float h = sdBoxFrame(p-vec3(2,0,0),vec3(1.5,1,1.5),0.1);\n    float i = sdTorus(p-vec3(-4,0,0),vec2(2,0.5));\n    float j = sdBoxFrame(p-vec3(1,2,1),vec3(0.3,1,0.3),0.05);\n    float k = sdBoxFrame(p-vec3(1,2,-1),vec3(0.3,1,0.3),0.05);\n    float l = sdBoxFrame(p-vec3(3,2,1),vec3(0.3,1,0.3),0.05);\n    float m = sdBoxFrame(p-vec3(3,2,-1),vec3(0.3,1,0.3),0.05);\n    float o = sdHexPrism(p-vec3(2,3,0),vec2(2,0.6));\n    \n    \n    return min(min(min(min(min(f,g),min(h,i)),min(min(j,k),min(l,m))),o),p.y+1.);\n}", "buffer_a_code": "// This file contains the \n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,0.5);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    \n    vec3 lightPos=vec3(20.,10.,10.);\n    \n    vec3 v = -ray.V;\n    vec3 l = normalize(lightPos-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = vec3(1./pi);\n    \n    //specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.V;\n    vec3 k_s = vec3(0.4);\n    \n    vec3 h = normalize(toLight+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta;\n    \n    return vec4(col,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,0.1,1.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.006, 102);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n    vec3 prevcol = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    float lambda = 0.3;\n    fragColor.rgb = (1.-lambda)*fragColor.rgb + lambda*prevcol;\n\n    fragColor.w = result.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 390]], "test": "untested"}
{"id": "7sKSDd", "name": "Fractal weirdness", "author": "jarble", "description": "A simple fractal pattern.", "tags": ["fractal"], "likes": 3, "viewed": 219, "published": 3, "date": "1635541042", "time_retrieved": "2024-07-30T18:52:01.730005", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv1 = ((fragCoord)*10.0-iResolution.xy)/iResolution.y/10.;\n    uv1 += iTime/10.;\n    for(int c=0;c<3;c++){\n        vec2 uv = uv1;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract((uv.y+uv.x+uv)/1.5)*1.5;\n            uv *= (uv.x-uv.y);\n            col += col.yzx*(uv.x+uv.y)/8.;\n            col[c] += (uv.y-uv.x);\n        }\n\n\t}\n    \n    fragColor = vec4(fract(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 498]], "test": "untested"}
{"id": "sdKSWd", "name": "Listen To Raymarching [LOUUUD]", "author": "Yusef28", "description": "Using sinewaves with pitch based on the distance to hit a map object for every step along the ray. 30 steps.\n//pitch = 220.*pow(1.06,clamp(dist,0.,1.));\nand the volume adjusted per ear based on the position of each step relative to the ray origin.", "tags": ["2d", "audio", "visual"], "likes": 29, "viewed": 797, "published": 3, "date": "1635540131", "time_retrieved": "2024-07-30T18:52:02.493962", "image_code": "/*\nThis is definitely one of the coolest\nshaders I've ever wrote imo. I did'nt expect\nit to sound at all melodic but I guess it makes\nsense because I have a set repeating animation. \n\nThe circles from: https://www.shadertoy.com/view/wtSSRG\n\n*/\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define FAR 10.\n#define circlePos vec2(cos(iTime)*0.6,-0.5)\n#define squarePos vec2(.9,sin(iTime)*0.4)\n#define S(d) 1.-smoothstep(-eps,+eps, abs(d)-0.01)\n#define thinS(d) 1.-smoothstep(-eps,+eps, abs(d)-0.005)\n#define MAX_LOOP 30.\n#define purp vec3(159,174,216)/255.\n#define blu vec3(160,132,179)/255.\n#define pink vec3(0.9,0.6,0.6)\n\n#define gold vec3(215., 154., 15.)/255.\n\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C(c) U.x-=.5; text+= char(U,64+c).rgb\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \nfloat circle(vec2 p, float r, float sf)\n{    \n    return 1.0-smoothstep(r-eps*sf, r+eps*sf, length(p));\n}\n\n//for gold rim texture\nfloat SIN(vec2 p, float r)\n{\n    float c = length(p);\n    return abs(sin(c*150./r))*(1.0-smoothstep(r-eps, r+eps,c));\n}\n\nvec3 drawFancyCircle(vec3 col, \n                     vec2 uv,\n                     float i,\n                     vec2 screen,\n                     vec2 light, \n                     vec2 pos, \n                     float r){\n                \n    float scale = 0.5/r;\n    vec3 tx1 = vec3(texture(iChannel1, \n    (uv-pos)/r/2.)).rgb+0.;\n    \n    //super hacky texture call to lighting that allows\n    //me to shift the texture by the circle\n    //position, scale it by the texture radius,\n    //adjust aspect ratio, and ajust the center again\n    vec3 tx0 = vec3(texture(iChannel0, \n    ((uv-pos)*scale*rot(iTime+i*8.))*vec2(iResolution.y/iResolution.x,1.)+0.5\n    )).rgb;\n    \n    vec2 lightDir = normalize(light - max(pos,eps));\n    //shadow circle\n    col = mix(col, vec3(0.0), circle(uv-pos-lightDir*0.1*r,r,20.));\n    //rim lighting circle\n    col = mix(col, gold+tx1.x+dot(uv-pos,-lightDir), circle(uv-pos, r,5.));\n    //gold outer circle\n    col = mix(col, gold-tx1.x+0.2, circle(uv-pos, r*0.97, 1.));\n    //sin gradient on outer circle\n    col-=SIN(uv-pos,r)/4.;\n    //black inner circle\n    col = mix(col, vec3(0.1), circle(uv-pos, r*0.78, 5.));\n    //grey center circle\n    col = mix(col, tx0*0.5+0.2*(0.5+0.5*cos(vec3(1.,2.,4.).xyx*4. + i*80.)), circle(uv-pos,r*0.75, 1.)); \n    return col;\n}\n\nfloat drawPoint(vec2 uv, vec2 p, float r){\n     return 1.-smoothstep(r-eps, r+eps, length(uv - p));\n}\n\nfloat distLine(vec2 p, vec2 A, vec2 B){\n  vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    return smoothstep(r+eps, r-eps, distLine(uv,A,B));\n}\n\nfloat map(vec2 p){\n    float c = length(p - circlePos)-0.3;\n    vec2 sp = abs(p-squarePos);\n    float s = max(sp.x,sp.y)-0.2;\n    return min(s,c);\n}\n\nvec2 normal(vec2 p){\n\n    vec2 e = vec2(eps,0.);\n    \n    return normalize(vec2(\n           map(p-e) - map(p+e),\n           map(p-e.yx) - map(p+e.yx) \n           ));\n           \n           \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    vec2 screen = fragCoord.xy/iResolution.xy;\n    vec2 ro = vec2(-0.8,0.);\n    vec2 rd = normalize(vec2(1.,-.2));\n    float a = iTime/3.;\n    //rd *= rot(a);\n    \n  //  if(iMouse.z > 0.5) \n //       rd = normalize((iMouse.xy*2.-iResolution.xy)/iResolution.y - ro);\n    \n   // col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n      \n    //raymarcher\n    float t = 0., d; vec2 last, next; //last and next pos for drawing lines\n    next = ro + rd*t;\n    float mapDistances = map(uv);\n    float gradient = mapDistances;\n    \n    col = vec3(0.9, 0.9, 0.8);\n    float tx2 = vec3(texture(iChannel2, uv)).x+0.3;\n    col-=tx2/9.;  \n    float tx3 = abs(sin(abs(gradient)*100.))/5.;\n    //based on iq's coloring style\n    //col = sign(gradient)*purp;\n    col = mix(col, vec3(1.)-tx3, clamp(1.-sign(gradient),0.,1.));\n\t//col *= clamp(pow(gradient,0.6),0.,1.);\n\t//col += cos(130.0*gradient)/0.01;\n    //draw the map objects as smooth outlines\n    col = mix(col, vec3(.0), S(mapDistances));                     \n    col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n    vec3 lineColorSum = vec3(0.0);\n\n    vec2 pos = ro;\n    float ior = 1./1.45;\n    float side = 1.;\n    //basic ray marcher                   \n    for(float i = 0.; i < MAX_LOOP; i ++){\n        \n        d = map(next);\n        if(t > FAR) break;\n        //t += d*0.75; \n        last = next;\n        //next = ro + rd*t;\n        next += rd*(d*0.75);\n        //draw line from last to next\n        col = mix(col, vec3(0.,0.7,0.99), drawLine(uv,last,next,0.01));\n        //draw point at next\n        col = mix(col, vec3(0.,0.7,0.99)*0.5,drawPoint(uv,next,0.02));\n        //draw circle based on d, distance to hit the map\n        //col = mix(col, 0.5+0.5*cos(vec3(1.,2.,4.).xyx + i*80.)/(1.+i/5.), S(length(uv - last)-abs(d))+0.01);\n        \n        col = drawFancyCircle(col, uv, i, screen, ro, last, min(abs(d),1.) );\n        \n        //check for hit and reflect\n        \n        if(abs(d) < 0.001){\n        \n            //col = mix(col, vec3(0.9,0.0,0.), drawPoint(uv,vec2(-1.5,i/MAX_LOOP-0.1),0.02));\n            vec2 n = normal(next);\n           // col = mix(col, vec3(0.,0.7,0.), drawLine(uv,next,next+n*.3,0.01));\n            vec2 altRd = rd;\n            rd = refract(rd, n, ior);\n            next += n*0.01*side;\n            \n            //This line here is what took all the time.\n            //Setting side to -1., telling myself I'd change it back\n            //to 1, and then believing I had, but I hadn't...I hadn't..I HADN'T!! ROOAR!!\n           \n            col = mix(col, vec3(1.,0.,0.), drawPoint(uv,next,0.02));\n            side *= -1.;\n            ior = 1./ior;\n            \n        }\n        \n    }\n    \n    // Output to screen\n    \n    col = pow(col, vec3(0.7));\n    //vignette\n    vec2 st = fragCoord/iResolution.xy;\n    st *=  1.0 - st.yx;\n    float vig = st.x*st.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \n    \n    vec2 position = vec2(-0.5,.7);\n    float FontSize = 12.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n    \n    vec3 text = vec3(0.);\n    fragColor = vec4(col*vig,1.0);\n\n    C(12);C(15);C(21);C(4);C(-32);C(9);C(14);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.), text.xxx);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.);\n    float y = sin(uv.x*4.+iTime*4.)/2.;\n    \n    float f = pow(1.0-smoothstep(0.2,0.3,pow(abs(y-uv.y), 0.4)),4.);\n    col = mix(col, vec3(0.), f);\n    \n    f = pow(1.0-smoothstep(0.2,0.3,pow(abs(0.-uv.y), 0.34)),4.);\n    col = mix(col, vec3(0.), f);   \n    \n    f = pow(1.0-smoothstep(0.2,0.3,pow(abs(0.-uv.x), 0.34)),4.);\n    col = mix(col, vec3(0.), f);\n    \n    vec2 st = (fragCoord*2.)/iResolution.y;\n    col *= abs(sin(st.y*100.))/1.5;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "#define pi acos(-1.)\n#define FAR 10.\n#define S(d) 1.-smoothstep(-eps,+eps, abs(d)-0.01)\n#define thinS(d) 1.-smoothstep(-eps,+eps, abs(d)-0.005)\n#define MAX_LOOP 30.\n\nfloat map(vec2 p, float time){\n    vec2 circlePos = vec2(cos(time)*0.6,-0.5);\n    vec2 squarePos = vec2(.9,sin(time)*0.4);\n    float c = length(p - circlePos)-0.3;\n    vec2 sp = abs(p-squarePos);\n    float s = max(sp.x,sp.y)-0.2;\n    return min(s,c);\n}\n\nvec2 normal(vec2 p, float time){\n\n    vec2 e = vec2(0.001,0.);\n    \n    return normalize(vec2(\n           map(p-e, time) - map(p+e, time),\n           map(p-e.yx, time) - map(p+e.yx, time) \n           ));\n           \n           \n}\n\nvec2 sineSound(vec2 ro, vec2 pos, float dist, float time, float i){\n    i++;\n    \n    float pitch = 220.*pow(1.06,clamp(dist,0.,1.));\n    pos = pos-ro;\n    dist = clamp(dist,1.,0.1);\n    pos = clamp(pos,0.,1.);\n    vec2 sound = vec2(0.);\n    \n    return vec2(sin(6.2831*pitch*+time*0.5))-pos;\n    //vec2(sin(6.2831*800.0*time/(dist*40.)))/(dist*1.);\n    \n}\nvec2 mainSound( int samp, float time )\n{\n\n    vec2 soundToReturn = vec2(0.);\n    \n    vec2 ro = vec2(-0.8,0.);\n    vec2 rd = normalize(vec2(1.,-.2));\n    float a = time/3.;\n    float t = 0., d;\n    vec2 last, next; //last and next pos for drawing lines\n    next = ro + rd*t;\n    \n    \n    vec2 pos = ro;\n    float ior = 1./1.45;\n    float side = 1.;\n    \n    //basic ray marcher with refraction                 \n    for(float i = 0.; i < MAX_LOOP; i ++){\n        \n        d = map(next, time);\n        if(t > FAR) break;\n        last = next;\n        next += rd*(d*0.75);\n        soundToReturn += sineSound(ro, next, d, time, i)*0.4;\n        if(abs(d) < 0.001){\n        \n            //col = mix(col, vec3(0.9,0.0,0.), drawPoint(uv,vec2(-1.5,i/MAX_LOOP-0.1),0.02));\n            vec2 n = normal(next, time);\n           // col = mix(col, vec3(0.,0.7,0.), drawLine(uv,next,next+n*.3,0.01));\n            vec2 altRd = rd;\n            rd = refract(rd, n, ior);\n            next += n*0.01*side;\n\n            side *= -1.;\n            ior = 1./ior;\n            \n        }\n        \n    }\n    \n    \n    \n    return  soundToReturn/MAX_LOOP;//vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[838, 838, 865, 865, 1035], [1037, 1037, 1055, 1055, 1113], [1119, 1119, 1160, 1160, 1224], [1226, 1249, 1277, 1277, 1368], [1370, 1370, 1592, 1592, 2669], [2671, 2671, 2713, 2713, 2772], [2774, 2774, 2813, 2813, 2930], [2932, 2932, 2981, 2981, 3038], [3040, 3040, 3058, 3058, 3188], [3190, 3190, 3210, 3210, 3381], [3382, 3382, 3439, 3489, 6816]], "test": "untested"}
{"id": "sdVSWt", "name": "Fab30 #inktober2021 \"slither\"", "author": "FabriceNeyret2", "description": ".[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nhey, today's word  fit a game shader I reproduced in 2018 :-) \nSo, just golfing it  [url]https://shadertoy.com/view/4sVfRc[/url]\n", "tags": ["game", "reproduction", "inktober2021"], "likes": 19, "viewed": 432, "published": 3, "date": "1635539574", "time_retrieved": "2024-07-30T18:52:03.292826", "image_code": "//  golfing 2408 chars https://shadertoy.com/view/4sVfRc ( see comments there ).\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2  F,H,D,P;\n    float d,i,h;\n    U = U * e/R + T(0,0).xy - e*.5;\n    \n    P = U * mat2(1,.2,-.2,1);                             // draw background\n    P.x -= .5* ( P.y/= .866 ); // hexa coords from https://www.shadertoy.com/view/lsVBWw\n    F = fract(P);\n    bool u = F.x+F.y > 1.;       \n    vec3 q = vec3(F, fract(-F-F.y)), r = q - q.zxy;\n    u ? r=-r : r;\n    P = floor(P) +                            // P = hexagonal center, d = dist to border\n       (   r.x>0. && r.y<0. ? d = min(r.x,-r.y), vec2(!u,u)\n         : r.y>0. && r.z<0. ? d = min(r.y,-r.z), vec2(u,!u)\n         :                  ( d = min(r.z,-r.x), vec2(u) )\n       );\n    O = ( smoothstep(.0,.01,d-.33)*.4 + sqrt(clamp(5.*(.23-d),0.,1.))*.2 )\n         * vec4(.4,.4,.6,0);\n    \n    for (float i=0.; i<20.; i++)                          // draw energy balls\n        if ( T(i,1).z != -1.)\n            d = length( mod( U - T(i,1).xy+.5*e , e)-.5*e ),\n            H = H(i+.5),\n            O +=  .01*(1.+H.x+.3*sin(6.3*H.y+13.*iTime)) /d/d\n            *( .6 + .6 * cos( .63*i  + vec4(0,23,21,0) ) );\n    \n#define b(c,d)     O = mix(O, vec4(c), smoothstep(.02,0.,d))\n#define B(d,h)     length( U-P -d*D -(h)*H )\n\n    D = length(S)*D(T(0,0).z); H = vec2(-D.y,D);          // draw body\n    for ( i=T(1,0).w-1.; i>=0.; i-- )\n        P = T(i*k,0).xy,\n        d = length( U - P ),\n        b(d, d-.37);\n\n    h = T(0,0).w;                                         // draw eyes\n    b(1., min(B( 1. , .7   ), B( 1. ,-.7   )) -.15);\n    b(0., min(B( 1.4, .7+h ), B( 1.4,-.7+h )) -.08);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;\n    vec2 p,D,H,M;         \n    float i = U.x, j = U.y, a;\n    if (j>1.) return; \n    \n    if (iFrame<1) { O-=O;             // --- initial position\n        j==0.  \n        ?   i==0. ? O.z = atan(S.y,S.x) : \n            i==1. ? O.w = 15. : i,\n            p = vec2(330,150)/N, D = S, H = vec2(-D.y,D),\n            i = 14.-i/k,\n            O.xy = mod( p + i*D + .3*H*sin(i/2.), e+.277 )\n        : O.zw = H(i)*e;\n        return;\n    }\n    O = T(i,j);                      // --- simulation\n    p = T(0,0).xy;\n    \n    if (j==0.) {\n        if(i==0.) // ()?: bugs on ATI      // head motion\n            M = normalize( iMouse.xy * e/R + p-e*.5 - O.xy ),\n            D = D(O.z),\n            iMouse.z>0.\n            ?   a = 14./k * sign(  M.y*D - M*D.y ).x,\n                O.z += a/60.\n            :   a = 0.,\n            O.w = mix( O.w, .15*a, 3./60. ),\n            i = T(1,0).w - 1., // i/k-1.,\n            O.z += sin(i/k/2.+5.*iTime) / 50.,\n            O.xy += length(S)/k * D(O.z); \n        else   O.xy = T(i-1.,0).xy;                  // segments (and inter-step) follows\n        if (i==1.)                                   // if eat ball, length ++\n            for (H = T(0,0).xy, i=0.; i < 20.; i++)\n                length(H - T(i,1).xy) < .3 ? O.w++ : i;\n    }\n    else                                             // energy balls\n        O.z==-1. && 1.-H(i+iTime).x<.0035 ?  O.zw = H(i-iTime)*e : e, // new balls\n        O.xy = O.zw - .06* cos(i+4.*iTime+vec2(33,0)),                // energy balls\n        length( mod(p,e) - O.xy )< .3 ? O = vec4(-1) : O;             // eaten\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 64., k = 4.; \n#define R       iResolution.xy\n#define e       4e2*R/R.y / N\n#define S     ( vec2(10,5)/ N )\n#define D(a)    vec2(cos(a),sin(a))\n#define T(i,j)  texelFetch(iChannel0,ivec2(i,j),0)\n#define H(p)    fract(sin( (p) * vec2(27.1,311.7) )*4e5)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVSWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 121, 121, 1667]], "test": "untested"}
{"id": "ssGXD3", "name": "Tesla's Raymarcher [Refraction]", "author": "Yusef28", "description": "[Mouse enabled]", "tags": ["2d", "visual"], "likes": 15, "viewed": 322, "published": 3, "date": "1635536106", "time_retrieved": "2024-07-30T18:52:04.485637", "image_code": "/*\nThis is really just a raymarching refraction demo\nbut I wanted to stretch the concept a bit so I added\n\nThe circles from: https://www.shadertoy.com/view/wtSSRG\nThe lighting from: https://www.shadertoy.com/view/sdySWG\n\n*/\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define FAR 10.\n#define circlePos vec2(cos(iTime)*0.6,-0.5)\n#define squarePos vec2(.9,sin(iTime)*0.4)\n#define S(d) 1.-smoothstep(-eps,+eps, abs(d)-0.01)\n#define thinS(d) 1.-smoothstep(-eps,+eps, abs(d)-0.005)\n#define MAX_LOOP 30.\n#define purp vec3(159,174,216)/255.\n#define blu vec3(160,132,179)/255.\n#define pink vec3(0.9,0.6,0.6)\n\n#define gold vec3(215., 154., 15.)/255.\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \nfloat circle(vec2 p, float r, float sf)\n{    \n    return 1.0-smoothstep(r-eps*sf, r+eps*sf, length(p));\n}\n\n//for gold rim texture\nfloat SIN(vec2 p, float r)\n{\n    float c = length(p);\n    return abs(sin(c*150./r))*(1.0-smoothstep(r-eps, r+eps,c));\n}\n\nvec3 drawFancyCircle(vec3 col, \n                     vec2 uv,\n                     float i,\n                     vec2 screen,\n                     vec2 light, \n                     vec2 pos, \n                     float r){\n                \n    float scale = 1./r;\n    vec3 tx1 = vec3(texture(iChannel1, \n    (uv-pos)/r/2.)).rgb+0.;\n    \n    //super hacky texture call to lighting that allows\n    //me to shift the texture by the circle\n    //position, scale it by the texture radius,\n    //adjust aspect ratio, and ajust the center again\n    vec3 tx0 = vec3(texture(iChannel0, \n    ((uv-pos)*scale*rot(iTime+i*8.))*vec2(iResolution.y/iResolution.x,1.)+0.5\n    )).rgb;\n    \n    vec2 lightDir = normalize(light - max(pos,eps));\n    //shadow circle\n    col = mix(col, vec3(0.0), circle(uv-pos-lightDir*0.1*r,r,20.));\n    //rim lighting circle\n    col = mix(col, tx1+dot(uv-pos,-lightDir), circle(uv-pos, r,5.));\n    //gold outer circle\n    col = mix(col, tx1, circle(uv-pos, r*0.97, 1.));\n    //sin gradient on outer circle\n    col-=SIN(uv-pos,r)/4.;\n    //black inner circle\n    col = mix(col, vec3(0.1), circle(uv-pos, r*0.78, 5.));\n    //grey center circle\n    col = mix(col, tx0+0.2*(0.5+0.5*cos(vec3(1.,2.,4.).xyx*4. + i*80.)), circle(uv-pos,r*0.75, 1.)); \n    return col;\n}\n\nfloat drawPoint(vec2 uv, vec2 p, float r){\n     return 1.-smoothstep(r-eps, r+eps, length(uv - p));\n}\n\nfloat distLine(vec2 p, vec2 A, vec2 B){\n  vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    return smoothstep(r+eps, r-eps, distLine(uv,A,B));\n}\n\nfloat map(vec2 p){\n    float c = length(p - circlePos)-0.3;\n    vec2 sp = abs(p-squarePos);\n    float s = max(sp.x,sp.y)-0.2;\n    return min(s,c);\n}\n\nvec2 normal(vec2 p){\n\n    vec2 e = vec2(eps,0.);\n    \n    return normalize(vec2(\n           map(p-e) - map(p+e),\n           map(p-e.yx) - map(p+e.yx) \n           ));\n           \n           \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    vec2 screen = fragCoord.xy/iResolution.xy;\n    vec2 ro = vec2(-0.8,0.);\n    vec2 rd = normalize(vec2(1.,-.2));\n    float a = iTime/3.;\n    //rd *= rot(a);\n    \n    if(iMouse.z > 0.5) \n        rd = normalize((iMouse.xy*2.-iResolution.xy)/iResolution.y - ro);\n    \n   // col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n      \n    //raymarcher\n    float t = 0., d; vec2 last, next; //last and next pos for drawing lines\n    next = ro + rd*t;\n    float mapDistances = map(uv);\n    float gradient = mapDistances;\n    \n    col = vec3(0.9, 0.9, 0.8);\n    float tx2 = vec3(texture(iChannel2, uv)).x+0.3;\n    col-=tx2/9.;  \n    float tx3 = abs(sin(abs(gradient)*100.))/5.;\n    //based on iq's coloring style\n    //col = sign(gradient)*purp;\n    col = mix(col, vec3(1.)-tx3, clamp(1.-sign(gradient),0.,1.));\n\t//col *= clamp(pow(gradient,0.6),0.,1.);\n\t//col += cos(130.0*gradient)/0.01;\n    //draw the map objects as smooth outlines\n    col = mix(col, vec3(.0), S(mapDistances));                     \n    col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n    vec3 lineColorSum = vec3(0.0);\n\n    vec2 pos = ro;\n    float ior = 1./1.45;\n    float side = 1.;\n    //basic ray marcher                   \n    for(float i = 0.; i < MAX_LOOP; i ++){\n        \n        d = map(next);\n        if(t > FAR) break;\n        //t += d*0.75; \n        last = next;\n        //next = ro + rd*t;\n        next += rd*(d*0.75);\n        //draw line from last to next\n        col = mix(col, vec3(0.,0.7,0.99), drawLine(uv,last,next,0.01));\n        //draw point at next\n        col = mix(col, vec3(0.,0.7,0.99)*0.5,drawPoint(uv,next,0.02));\n        //draw circle based on d, distance to hit the map\n        //col = mix(col, 0.5+0.5*cos(vec3(1.,2.,4.).xyx + i*80.)/(1.+i/5.), S(length(uv - last)-abs(d))+0.01);\n        \n        col = drawFancyCircle(col, uv, i, screen, ro, last, min(abs(d),1.) );\n        \n        //check for hit and reflect\n        \n        if(abs(d) < 0.001){\n        \n            //col = mix(col, vec3(0.9,0.0,0.), drawPoint(uv,vec2(-1.5,i/MAX_LOOP-0.1),0.02));\n            vec2 n = normal(next);\n           // col = mix(col, vec3(0.,0.7,0.), drawLine(uv,next,next+n*.3,0.01));\n            vec2 altRd = rd;\n            rd = refract(rd, n, ior);\n            next += n*0.01*side;\n            \n            //This line here is what took all the time.\n            //Setting side to -1., telling myself I'd change it back\n            //to 1, and then believing I had, but I hadn't...I hadn't..I HADN'T!! ROOAR!!\n           \n            col = mix(col, vec3(1.,0.,0.), drawPoint(uv,next,0.02));\n            side *= -1.;\n            ior = 1./ior;\n            \n        }\n        \n    }\n    \n    // Output to screen\n    \n    col = pow(col, vec3(0.7));\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \n    \n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define boltNum 8.\n\nfloat hash(float x){\n    return fract(sin(x*12.)*42119.);\n}\n\nfloat noise(float x){\n    float a = hash(floor(x));\n    float b = hash(floor(x) + 1.);\n    float f = fract(x);\n  \n    return mix(a,b,f);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(61,59,77)/325.;//mix(vec3(0.3,0.4,0.2),vec3(0.4,0.,0.9),(1.-length(uv))/1.);\n    //col = mix(col,vec3(1.),(1.-length(uv))/9.);\n    col += vec3(2.-length(uv)-0.6)/9.;\n    float t = iTime/1.+5.;\n    float bend,y,f;\n    for(float i = 0.; i < boltNum; i++){\n        \n        //line \n        //y = 0.;\n        \n        //bend line in middle every second\n        bend = fract(t*(1.+(boltNum-i)/4.)+i/7.+i/8.)*0.13-0.13/2.;\n        bend *= 1.5;\n        y = bend*2. + (1.-uv.x*uv.x)*bend;\n        \n        //add sinewave\n        float randomOff = hash(floor(t*3. + i));\n        y += sin(uv.x*1.6+t*(3.) + randomOff*3.5 + i*80.)/3.;\n        \n        randomOff = hash(floor(t*2.));\n        y += noise(uv.x*6.+t*1. + randomOff*(10.5+i*8.))/5.;\n        //(fract(iTime*2.+uv.x*2.)/5.); \n        \n        //bring everything to 0 at edges\n        y = mix(y, .0, abs(uv.x/2.)/1.2);\n        //draw\n        float f = pow(1.0-smoothstep(0.02,0.5,pow(abs(y-uv.y), 0.5)),4.+i*1.9);\n        //1.0-smoothstep(0.0,0.02,pow(abs(y-uv.y)/fwidth(y-uv.y)/(25.-i*2.),2.));\n        col = mix(col, vec3(1.), f);\n    }\n\n    // Output to screen\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[649, 649, 667, 667, 725], [731, 731, 772, 772, 836], [838, 861, 889, 889, 980], [982, 982, 1204, 1204, 2258], [2260, 2260, 2302, 2302, 2361], [2363, 2363, 2402, 2402, 2519], [2521, 2521, 2570, 2570, 2627], [2629, 2629, 2647, 2647, 2777], [2779, 2779, 2799, 2799, 2970], [2971, 2971, 3028, 3078, 6152]], "test": "untested"}
{"id": "sdKSDt", "name": "Another Spiral Test", "author": "SnoopethDuckDuck", "description": "kept adding equations and got to this somehow", "tags": ["e"], "likes": 8, "viewed": 277, "published": 3, "date": "1635532983", "time_retrieved": "2024-07-30T18:52:05.496934", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sqLength(vec2 a) {\n    return max(abs(a.x), abs(a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float sc = 192. / (1. + tanh(-length(uv) + iTime)) / (1. + 8. * length(uv) * (1. + 0.5 * cos(8. * sqLength(uv) + 0.5 * iTime)));\n    vec2 ipos = ceil(sc * uv) - 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    float id = length(ipos);\n    float fd = length(fpos);\n    \n    float a = atan(ipos.y, ipos.x);\n    \n    float box = sqLength(fpos);\n    box = mix(0.5 - box * box, 0.5 - fd * fd, .5 + .5 * cos(id + iTime));\n    //box = 0.55 - box * box;\n    \n    float k = (1. + sin(id - a - iTime)) * (1. + cos(0.5 * id + iTime)) / (1. + cos(id - a - iTime));\n    float c = 0.8 * box + 0.08 * id + .5 * cos(id - iTime);\n    c *= 0.5 + 0.5 * cos(c);   \n    c *= step(0.2 + k,box) - step(0.3 + k, box);\n\n    vec3 col = pal(0.05 * length(ipos) / c, vec3(0.5), vec3(0.5), vec3(1.5), vec3(0.,0.333,0.666));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [113, 113, 137, 137, 175], [177, 177, 234, 234, 1134]], "test": "untested"}
{"id": "ssKXWt", "name": "Raymarching_Trainning", "author": "AYAYA2", "description": "This is a learnning of raymarching support by:\nhttps://www.youtube.com/watch?v=Vmb7VGBVZJA\nhttps://www.shadertoy.com/view/Xds3zN", "tags": ["raymarch"], "likes": 1, "viewed": 239, "published": 3, "date": "1635530597", "time_retrieved": "2024-07-30T18:52:06.427445", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat dot2( in vec2 v ) { return dot(v,v); }// 自点乘\nfloat dot2( in vec3 v ) { return dot(v,v); }// 三维\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane(vec3 p){\n    return p.y;\n}\n\nfloat dSphere(vec3 p,vec3 o,float radius){\n    return length(p-o.xyz)-radius;\n}\n\nfloat dBox(vec3 p,vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float radius){\n    vec3 ap=p-a;\n    vec3 ab=b-a;\n    \n    float t=dot(ap,ab)/dot(ab,ab);\n    t=clamp(t,0.,1.);\n    \n    vec3 c=a+t*ab;\n    return length(p-c)-radius;\n}\n\n// 方框盒子 b-方框三维、e-方框粗细\nfloat sdBoundingBox(vec3 p,vec3 b,float e){\n    p=abs(p)-b;\n    vec3 q = abs(p+e)-e;\n    \n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// 椭球体\nfloat sdEllipsoid(vec3 p,vec3 radius){\n    float k0=length(p/radius);\n    float k1=length(p/(radius*radius));\n    return k0*(k0-1.)/k1;\n}\n\n\n// 圆柱体，只能渲染竖着的，弃用\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 圆柱体\nfloat sdCylinder(vec3 p,vec3 a,vec3 b,float radius){\n    vec3 ap=p-a;\n    vec3 ab=b-a;\n    \n    float t=dot(ap,ab)/dot(ab,ab);\n    \n    vec3 c=a+t*ab;\n    \n    float x= length(p-c)-radius;\n    float y=(abs(t-.5)-.5)*length(ab);\n    float e=length(max(vec2(x,y),0.));\n    float i=min(max(x,y),0.);// 消除步进过多光线进入柱体内的错误\n    \n    return e+i;\n}\n\n// 甜甜圈\nfloat sdTours(vec3 p,vec2 radius){\n    float x=length(p.xz)-radius.x;\n    return length(vec2(x,p.y))-radius.y;\n}\n\n// 缺口甜甜圈 sc-缺口弧度,缺口半径 ra-外圈半径 rb-体半径（粗细）\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// 六边形？ h-半径,厚度\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 八边形 r-半径 h-厚度\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// 三角椭锥体 r1-下盘半径 r2-上盘半径 h-高度,弃用\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// 椭锥体 a,b-分别为上下球心坐标（可以控制偏斜和高度h） r1-下盘半径 r2-上盘半径\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// 三角柱体 h-大小，高度\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// 三角锥 c-半径？ h-高度\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\n// 圆柱锥体 无控制点版本，弃用\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// 圆柱锥体 a,b-控制点\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// 球底圆锥体 ra-底部曲面半径\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// 八面体 s-边长\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\n// 四棱锥金字塔\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// \n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// 距离长遍历\nfloat GetDist(vec3 p)\n{\n    vec4 s=vec4(0,1,6,1);// A sphere's pos.xyzr\n    \n    float planeDist=sdPlane(p);// ground\n    \n    // 遍历形式所有物体 物体摆放 从远至近-行\n    float bd=dBox(p-vec3(-6,.75,6),vec3(.6));\n    float td=sdTours(p-vec3(-3,.75,6),vec2(.75,0.3));\n    float cd=sdCapsule(p,vec3(0,.75,6),vec3(1,2,6),.4);\n    float sd=dSphere(p,vec3(3,.75,6),.75);\n    float bbd=sdBoundingBox(p-vec3(6,.75,6),vec3(0.6,0.6,0.6),0.05);  \n    \n    float cyld=sdCylinder(p-vec3(-1,.75,0),vec3(0,.3,4),vec3(2,.3,5),.2);\n    float ed=sdEllipsoid(p-vec3(-5.5,.75,4),vec3(0.2,0.15,0.25));\n    float ctd=sdCappedTorus(p-vec3(-3,.75,4),vec2(0.866025,-0.5),0.5, 0.1);\n    float hpd=sdHexPrism(p-vec3(3,0.75,4.4),vec2(0.6,0.1));\n    float opd=sdOctogonPrism(p-vec3(6,0.75,4.3),0.6,0.1);\n    \n    //float rcd0=sdRoundCone(p-vec3(-6,0.75,3.5),0.2,0.1,0.5);\n    float rcd=sdRoundCone(p-vec3(-6,0.75,3.5), vec3(0.1,0.0,0.0), vec3(-0.3,0.4,0.1), 0.15, 0.05);\n    float tpd=sdTriPrism(p-vec3(-3.3,0.75,3.4),vec2(0.5,0.05));\n    float coned=sdCone(p-vec3(5.3,1.1,3.4),vec2(0.3,0.8),0.85);\n    float ccd=sdCappedCone(p-vec3(0.0,0.75,3.5),vec3(0.1,0.0,0.0),vec3(-0.3,0.40,0.1),0.3,0.15);\n    float sad=sdSolidAngle(p-vec3(3,0.05,3.5), vec2(1.5,2)/2.5, 1.);\n    \n    float odd=sdOctahedron(p-vec3(-3.0,0.5,2),0.45);// 四棱锥因为正交投影的问题很难看\n    float pd=sdPyramid(p-vec3(2,0.5,2.0), 0.9);\n    float rbd= sdRhombus(p-vec3(-0.2,0.34,2.0),0.15,0.25,0.04,0.08);\n    \n    float d=min(cd,planeDist);\n    d=min(d,sd);\n    d=min(d,td);\n    d=min(d,bd);\n    d=min(d,cyld);\n    d=min(d,bbd);\n    d=min(d,ed);\n    d=min(d,ctd);\n    d=min(d,hpd);\n    d=min(d,opd);\n    d=min(d,rcd);\n    d=min(d,tpd);\n    d=min(d,coned);\n    d=min(d,ccd);\n    d=min(d,sad);\n    d=min(d,odd);\n    d=min(d,pd);\n    d=min(d,rbd);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro,vec3 rd)\n{\n    float dO=0.;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*dO;\n        float dS=GetDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST||dS<SURF_DIST)break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d=GetDist(p);\n    vec2 e=vec2(.01,0);\n    \n    vec3 n=d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos=vec3(0,5,6);// a light's pos.xyz\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l =normalize(lightPos-p);\n    vec3 n=GetNormal(p);\n    \n    float dif=clamp(dot(n,l),0.,1.);\n    float d=RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif*=.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 ro=vec3(0,3,0);// cameraPos\n    vec3 rd=normalize(vec3(uv.x,uv.y-.3,.35));// cameraDir\n    \n    float d=RayMarch(ro,rd);\n    \n    vec3 p=ro+rd*d;\n    float dif=GetLight(p);\n    col=vec3(dif);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 92, 92, 111], [111, 124, 149, 149, 168], [168, 178, 214, 214, 242], [244, 244, 266, 266, 284], [286, 286, 328, 328, 365], [367, 367, 393, 393, 432], [434, 434, 485, 485, 638], [640, 688, 731, 731, 1026], [1028, 1041, 1079, 1079, 1178], [1181, 1227, 1263, 1263, 1366], [1368, 1381, 1433, 1433, 1751], [1753, 1766, 1800, 1800, 1878], [1880, 1969, 2039, 2039, 2179], [2181, 2213, 2249, 2249, 2560], [2562, 2593, 2649, 2649, 3151], [3153, 3220, 3284, 3284, 3562], [3564, 3675, 3738, 3802, 4389], [4391, 4425, 4461, 4461, 4811], [4813, 4847, 4894, 4894, 5239], [5241, 5285, 5356, 5356, 5694], [5696, 5726, 5790, 5790, 6350], [6352, 6439, 6487, 6487, 6656], [6658, 6680, 6717, 6717, 7311], [7313, 7335, 7377, 7377, 7977], [7979, 8023, 8087, 8087, 8345], [8347, 8366, 8389, 8389, 10204], [10206, 10206, 10239, 10239, 10432], [10434, 10434, 10458, 10458, 10636], [10638, 10638, 10662, 10662, 10967], [10969, 10969, 11026, 11076, 11460]], "test": "untested"}
{"id": "NsVXWd", "name": "conetests", "author": "Del", "description": "cone tests", "tags": ["cone"], "likes": 3, "viewed": 209, "published": 3, "date": "1635524071", "time_retrieved": "2024-07-30T18:52:07.316069", "image_code": "// capped cone / capped pyramid testing\n\n\n//https://iquilezles.org/articles/distfunctions#\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n//float sdCappedConeTest( vec3 p, float h, float r1, float r2 )\n//{\n//  vec2 q = abs(p).xz-vec2(0.125);\n//  q = vec2(length(max(q,0.0)) + min(max(q.x,q.y),0.0),p.y);\n//  vec2 k1 = vec2(r2,h);\n//  vec2 k2 = vec2(r2-r1,2.0*h);\n//  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n//  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n//  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n//  return s*sqrt( min(dot2(ca),dot2(cb)) );\n//}\n\n\n\n\n\n// truncated pyramid - https://www.shadertoy.com/view/NsKSDc\nfloat sdCappedPyramid(vec3 position, float h, float r1, float r2 )\n{\n    float s1 = abs(position.y) - h;\n    // bottom\n    vec3 position1 = position;\n    position1.y -= -h;\n    position1 = abs(position1) - vec3(r1, 0.0, r1);\n    vec3 intersection1 = max(position1, 0.0);\n    float d1 = dot(intersection1, intersection1);\n    // top\n    vec3 position2 = position;\n    position2.y -= h;\n    position2 = abs(position2) - vec3(r2, 0.0, r2);\n    vec3 intersection2 = max(position2, 0.0);\n    float d2 = dot(intersection2, intersection2);\n    \n    position.x = abs(position.x);\n    position.z = abs(position.z);\n\n    vec3 p1 = vec3(r1, -h, 0.0);\n    vec3 p2 = vec3(r1, -h, r1);\n    vec3 p3 = vec3(0.0, -h, r1);\n    vec3 p4 = vec3(r2, h, 0.0);\n    vec3 p5 = vec3(r2, h, r2);\n    vec3 p6 = vec3(0.0, h, r2);\n    vec3 end = p5 - p2;\n    vec3 position3 = position - p2;\n  \n    // side\n    vec3 normal1 = cross(p1 - p2, end);\n    float s2 = dot(position3, normal1);\n    float d3;\n    if (dot(cross(normal1, p2 - p1), position - p2) < 0.0 && \n        dot(cross(normal1, p2 - p1), position - p5) > 0.0 &&\n        dot(cross(normal1, p5 - p2), position - p2) < 0.0) { \n        d3 = s2 * s2 / dot(normal1, normal1);\n    } else {\n        vec3 intersection = position3 - end * clamp(dot(position3, end) / dot(end, end), 0.0, 1.0);\n        d3 = dot(intersection, intersection);\n    }\n \n    // front/back\n    vec3 normal2 = cross(end, p3 - p2);\n    float s3 = dot(position3, normal2);\n    float d4;\n    if (dot(cross(normal2, p6 - p5), position - p2) < 0.0 &&\n        dot(cross(normal2, p6 - p5), position - p5) > 0.0 && \n        dot(cross(normal2, p2 - p5), position - p5) < 0.0) { \n        d4 = s3 * s3 / dot(normal2, normal2);\n    } else {\n        vec3 intersection = position3 - end * clamp(dot(position3, end) / dot(end, end), 0.0, 1.0);\n        d4 = dot(intersection, intersection);\n    }\n    return sqrt(min(min(min(d1, d2), d3), d4)) * sign(max(max(s1, s2), s3));\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\nfloat sdf(in vec3 position)\n{ \n\n    position.xz*=rot(fract(iTime*0.1)*6.28);\n\n    float m = sin(iTime*2.2)*0.3;\n\n    \n    float r1 = 0.7-m;\n    float r2 = 0.7+m;\n    float halfHeight = 0.75;\n    float d1 = sdCappedPyramid(position-vec3(1.5,0.0,0.0), halfHeight, r1, r2);\n    float d2 = sdCappedCone(position+vec3(1.5,0.0,0.0), halfHeight, r1, r2);\n    \n    return min(d1,d2);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\n\n//https://www.shadertoy.com/view/ttGfz1\nfloat lighting(vec3 normal)\n{\n    //fake image based lighting (\"outdoor lighting\")\n    return length(sin(normal*2.)*.5+.5)/sqrt(3.)*smoothstep(-1.,1.,normal.z);\n}\n\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 15.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t//float angle = 0.5 * (iTime - 10.0);\n    float angle = 0.0;\n\tvec3 rayOrigin = 1.2 * vec3(3.0 * cos(angle), 1.5, 3.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(1.0, 1.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 n = normal(position);\n                float ll = lighting(n);\n                color = vec3(0.9,0.9,0.5)*ll;\n\n                \n                if (iMouse.z>0.5)\n                {\n                    fragColor = vec4(n, 1.0);\n                    return;\n                }\n                \n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 91, 116, 116, 135], [136, 136, 195, 195, 508], [970, 1031, 1099, 1099, 2984], [2986, 2986, 3025, 3025, 3207], [3209, 3209, 3230, 3230, 3298], [3299, 3299, 3328, 3328, 3676], [3678, 3678, 3706, 3706, 4051], [4054, 4094, 4123, 4176, 4256], [4259, 4259, 4309, 4309, 4692], [4694, 4694, 4749, 4788, 6178]], "test": "untested"}
{"id": "sdGSDd", "name": "Fab29 #inktober2021 \"patch\"", "author": "FabriceNeyret2", "description": ".[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nMouse to move the patchwork\nreference: see below", "tags": ["2d", "short", "reproduction", "inktober2021", "patchwork"], "likes": 14, "viewed": 260, "published": 3, "date": "1635523856", "time_retrieved": "2024-07-30T18:52:08.256554", "image_code": "// --- utils from http://www.shadertoy.com/view/llySRh\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define H(p)     fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define S(v)     smoothstep( 60./R.y, 0., v ) \n\nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2   R =  iResolution.xy, \n           U = 10.* ( u - iMouse.xy ) / R.y - 3.,\n           I = floor(U), F = fract(U),                     // small tiles ( cut as 2 triangles )\n           I2 = floor(I/4.), F2 = I-I2*4.-1.5,             // super tiles 4x4\n           H, G;\n     float b = F.x + ((int(I.x+I.y)&1)>0 ? F.y : 1.-F.y ),l;// triangle halves: b < or > 1\n     H = H(I2);                                            // color seeds\n    \n#define t(U)  1.5* texture(iChannel0,U).r                  // weaving pattern\n//#define t(V)  1.5* textureGrad(iChannel0,V,dFdx(U),dFdy(U)).r  // to fix some motion aliasing ( thanks mla ! )\n#define T(U)  max( t(U) , max(t(U+.3) , t(U+.6) ) )        \n\n    l = H.y; G = fract(F*4.)-.5;                           // cloth patterns\n    l =  l < .25 ? length(G) - .2                                                 // #1\n       : l < .50 ? max(abs(fract(F.x*4.+floor(F.y*4.)/2.)-.5),abs(G.y*2.)) - .3   // #2\n       : l < .75 ? abs( fract(.1*sin(24.*F.y)+4.*F.x)-.5) -.15                    // #3\n       :           abs( fract(4.*(F.x-F.y))-.5 ) -.15;                            // #4\n                 \n    vec4 C0 = mix( hue(H.y*3.) * T(F),  hue(H.x) * T(F.yx) , S(l) ), // color pattern for each triangle halve\n           // variant: H.x+.5 for complementary colors\n         C1 = hue(H.x) * T(F.yx);\n\n    l = max(abs(F2.x),abs(F2.y));                          // crown rank in super tile\n    O = (    b>1. == F2.y > 0.          && l < 1.          // patches arrangement in super tile\n          || b>1. == F2.x+1.-F2.y <= 0. && fract(atan(F2.y,F2.x)/1.57) < .4  \n                  ? C0                                     // color patch 1\n         : l < 1. ? C1                                     // color patch 2\n         : vec4(1.2,1.1,1.1,1) * T(F)                      // background patch\n        ) * ( 1. -.1* S( min(min(F.x,F.y),abs(1.-b))) );   // patches border\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NdKXWd", "name": "simple fbm with noise tex", "author": "drschizzo", "description": ".", "tags": ["fbm"], "likes": 1, "viewed": 231, "published": 3, "date": "1635522820", "time_retrieved": "2024-07-30T18:52:09.052427", "image_code": "float fbm(vec2 uv){\n    float f=0.;\n    float s=15.;\n    float o=8.;\n    for(float i=o;i>=0.;i--){\n        uv+=sin(iTime*(1./o)+(i*(1.57/o)))*.2;\n        f+=texture(iChannel0,uv/((-s/o)*i+s)).r*(1./(o-1.));\n    }\n    return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float a=iTime/5.;\n    mat2 m=mat2(cos(a),-sin(a),sin(a),cos(a));\n    uv=m*uv*2.*(.8+.2*sin(iTime/2.));\n    vec3 col = vec3(fbm(uv));\n    col*=.6+.4*sin(vec3(.3,.5,.7)*(iTime+length(uv)*3.14));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 228], [231, 231, 288, 288, 577]], "test": "untested"}
{"id": "ssGXDd", "name": "Random Number Generator Library", "author": "paniq", "description": "Implementation of a stateful random number generator designed to make working with random numbers in a shader fast and easy, with demo.", "tags": ["noise", "random", "number", "normal", "gaussian", "generator", "rng"], "likes": 66, "viewed": 2458, "published": 3, "date": "1635520011", "time_retrieved": "2024-07-30T18:52:10.311061", "image_code": "// see Common tab for implementation\n\n//////////////////////////////////////////////////////////\n\nfloat qh(ivec2 fc, int a) {\n    if (fc.x / 8 == a)\n        return 1.0;\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    ivec2 fc = ivec2(fragCoord);\n\n    vec3 col = vec3(0.0);\n    \n    if (fc.y > 0) {\n        col += texelFetch(iChannel0, fc, 0).rgb;\n    }\n\n    // demonstrate gaussian\n    vec4 dist = texelFetch(iChannel0, ivec2(fc.x, 0), 0);\n    if ((dist.x / dist.w)*0.75 > uv.y) {\n        col += vec3(1.0);\n    }\n    \n    // demonstrate sampling 4 unique values from N elements\n    int N = 16;\n    int a = iFrame % N;\n    Random rng = seed(seed(iFrame), fc.y/4);\n    if ((fc.y > 100) && (fc.y < 120)) {\n        ivec3 k = sample_k_3(rng, N, a);\n        col += vec3(0.5) * qh(fc, a);\n        col += vec3(1.0,0.0,0.0) * qh(fc, k.x);\n        col += vec3(0.0,1.0,0.0) * qh(fc, k.y);\n        col += vec3(0.0,0.0,1.0) * qh(fc, k.z);\n    }\n    \n    // put some noise on our noise so we can randomize while we randomize\n    rng = seed(seed(fragCoord), iTime);\n    fragColor = vec4(clamp(col,vec3(0.0),vec3(1.0)) * range(rng, vec3(0.6), vec3(1.0)),1.0);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// random number generator library (https://www.shadertoy.com/view/ssGXDd)\n// by Leonard Ritter (@leonard_ritter)\n\n// based on https://www.shadertoy.com/view/MdcfDj\n// license: https://unlicense.org/\n\n// 2022/11/27: added support for hexagon sampling\n\n// comment out for faster but lower quality hashing\n#define RNGL_HIGH_QUALITY\n\nstruct Random { uint s0; uint s1; };\n\n// constructors; note that constructors are wilfully unique,\n// i.e. calling a different constructor with the same arguments will not\n// necessarily produce the same state.\nuint uhash(uint a, uint b);\nRandom seed(uint s) { return Random(s, uhash(0x1ef7c663u, s)); }\nRandom seed(uvec2 s) { return Random(s.y, uhash(s.x, s.y)); }\nRandom seed(Random a, uint b) { return Random(b, uhash(a.s1, b)); }\nRandom seed(Random a, uvec2 b) { return seed(a, uhash(b.x, b.y)); }\nRandom seed(Random a, uvec3 b) { return seed(a, uhash(uhash(b.x, b.y), b.z)); }\nRandom seed(Random a, uvec4 b) { return seed(a, uhash(uhash(b.x, b.y), uhash(b.z, b.w))); }\nRandom seed(uvec3 s) { return seed(seed(s.xy), s.z); }\nRandom seed(uvec4 s) { return seed(seed(s.xy), s.zw); }\nRandom seed(int s) { return seed(uint(s)); }\nRandom seed(ivec2 s) { return seed(uvec2(s)); }\nRandom seed(ivec3 s) { return seed(uvec3(s)); }\nRandom seed(ivec4 s) { return seed(uvec4(s)); }\nRandom seed(Random a, int b) { return seed(a, uint(b)); }\nRandom seed(Random a, ivec2 b) { return seed(a, uvec2(b)); }\nRandom seed(Random a, ivec3 b) { return seed(a, uvec3(b)); }\nRandom seed(Random a, ivec4 b) { return seed(a, uvec4(b)); }\nRandom seed(float s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec2 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec3 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec4 s) { return seed(floatBitsToUint(s)); }\nRandom seed(Random a, float b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec2 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec3 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec4 b) { return seed(a, floatBitsToUint(b)); }\n\n// fundamental functions to fetch a new random number\n// the last static call to the rng will be optimized out\nuint urandom(inout Random rng) {\n    uint last = rng.s1;\n    uint next = uhash(rng.s0, rng.s1);\n    rng.s0 = rng.s1; rng.s1 = next;\n    return last;\n}\nuvec2 urandom2(inout Random rng) { return uvec2(urandom(rng),urandom(rng)); }\nuvec3 urandom3(inout Random rng) { return uvec3(urandom2(rng),urandom(rng)); }\nuvec4 urandom4(inout Random rng) { return uvec4(urandom2(rng),urandom2(rng)); }\nint irandom(inout Random rng) { return int(urandom(rng)); }\nivec2 irandom2(inout Random rng) { return ivec2(urandom2(rng)); }\nivec3 irandom3(inout Random rng) { return ivec3(urandom3(rng)); }\nivec4 irandom4(inout Random rng) { return ivec4(urandom4(rng)); }\n\nfloat unorm(uint n);\nfloat random(inout Random rng) { return unorm(urandom(rng)); }\nvec2 random2(inout Random rng) { return vec2(random(rng),random(rng)); }\nvec3 random3(inout Random rng) { return vec3(random2(rng),random(rng)); }\nvec4 random4(inout Random rng) { return vec4(random2(rng),random2(rng)); }\n\n// ranged random value < maximum value\nint range(inout Random rng, int mn, int mx) { return mn + (irandom(rng) % (mx - mn)); }\nivec2 range(inout Random rng, ivec2 mn, ivec2 mx) { return mn + (irandom2(rng) % (mx - mn)); }\nivec3 range(inout Random rng, ivec3 mn, ivec3 mx) { return mn + (irandom3(rng) % (mx - mn)); }\nivec4 range(inout Random rng, ivec4 mn, ivec4 mx) { return mn + (irandom4(rng) % (mx - mn)); }\nuint range(inout Random rng, uint mn, uint mx) { return mn + (urandom(rng) % (mx - mn)); }\nuvec2 range(inout Random rng, uvec2 mn, uvec2 mx) { return mn + (urandom2(rng) % (mx - mn)); }\nuvec3 range(inout Random rng, uvec3 mn, uvec3 mx) { return mn + (urandom3(rng) % (mx - mn)); }\nuvec4 range(inout Random rng, uvec4 mn, uvec4 mx) { return mn + (urandom4(rng) % (mx - mn)); }\nfloat range(inout Random rng, float mn, float mx) { float x=random(rng); return mn*(1.0-x) + mx*x; }\nvec2 range(inout Random rng, vec2 mn, vec2 mx) { vec2 x=random2(rng); return mn*(1.0-x) + mx*x; }\nvec3 range(inout Random rng, vec3 mn, vec3 mx) { vec3 x=random3(rng); return mn*(1.0-x) + mx*x; }\nvec4 range(inout Random rng, vec4 mn, vec4 mx) { vec4 x=random4(rng); return mn*(1.0-x) + mx*x; }\n\n// marshalling functions for storage in image buffer and rng replay\nvec2 marshal(Random a) { return uintBitsToFloat(uvec2(a.s0,a.s1)); }\nRandom unmarshal(vec2 a) { uvec2 u = floatBitsToUint(a); return Random(u.x, u.y); }\n\n//// specific distributions\n\n// normal/gaussian distribution\n// see https://en.wikipedia.org/wiki/Normal_distribution\nfloat gaussian(inout Random rng, float mu, float sigma) {\n    vec2 q = random2(rng);\n    float g2rad = sqrt(-2.0 * (log(1.0 - q.y)));\n    float z = cos(q.x*6.28318530718) * g2rad;\n    return mu + z * sigma;\n}\n\n// triangular distribution\n// see https://en.wikipedia.org/wiki/Triangular_distribution\n// mode is a mixing argument in the range 0..1\nfloat triangular(inout Random rng, float low, float high, float mode) {\n    float u = random(rng);\n    if (u > mode) {\n        return high + (low - high) * (sqrt ((1.0 - u) * (1.0 - mode)));\n    } else {\n        return low + (high - low) * (sqrt (u * mode));\n    }\n}\nfloat triangular(inout Random rng, float low, float high) { return triangular(rng, low, high, 0.5); }\n\n// after https://www.shadertoy.com/view/4t2SDh\n// triangle distribution in the range -0.5 .. 1.5\nfloat triangle(inout Random rng) {\n    float u = random(rng);\n    float o = u * 2.0 - 1.0;\n    return max(-1.0, o / sqrt(abs(o))) - sign(o) + 0.5;\n}\n\n//// geometric & euclidean distributions\n\n// uniformly random point on the edge of a unit circle\n// produces 2d normal vector as well\nvec2 uniform_circle_edge (inout Random rng) {\n    float u = random(rng);\n    float phi = 6.28318530718*u;\n    return vec2(cos(phi),sin(phi));\n}\n\n// uniformly random point in unit circle\nvec2 uniform_circle_area (inout Random rng) {\n    return uniform_circle_edge(rng)*sqrt(random(rng));\n}\n\n// gaussian random point in unit circle\nvec2 gaussian_circle_area (inout Random rng, float k) {\n    return uniform_circle_edge(rng)*sqrt(-k*log(random(rng)));\n}\nvec2 gaussian_circle_area (inout Random rng) { return gaussian_circle_area(rng, 0.5); }\n\n// cartesian coordinates of a uniformly random point within a hexagon\nvec2 uniform_hexagon_area (inout Random rng, float phase) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    \n    const float sqrt3div4 = sqrt(3.0 / 4.0);\n    const float pidiv6 = 0.5235987755982988;\n    float r = sqrt3div4 / cos(mod(phi + phase, 2.0 * pidiv6) - pidiv6);\n\n    return vec2(cos(phi), sin(phi)) * r * sqrt(u.y);\n}\n\nvec2 uniform_hexagon_area (inout Random rng) {\n    return uniform_hexagon_area(rng, 1.5707963267948966);\n}\n\n// barycentric coordinates of a uniformly random point within a triangle\nvec3 uniform_triangle_area (inout Random rng) {\n    vec2 u = random2(rng);\n    if (u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    return vec3(u.x, u.y, 1.0-u.x-u.y);\n}\n\n// uniformly random on the surface of a sphere\n// produces normal vectors as well\nvec3 uniform_sphere_area (inout Random rng) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}\n\n// uniformly random within the volume of a sphere\nvec3 uniform_sphere_volume (inout Random rng) {\n    return uniform_sphere_area(rng) * pow(random(rng), 1.0/3.0);\n}\n\n// barycentric coordinates of a uniformly random point within a 3-simplex\n// based on \"Generating Random Points in a Tetrahedron\" by Rocchini et al\nvec4 uniform_simplex_volume (inout Random rng) {\n    vec3 u = random3(rng);\n    if(u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    if(u.y + u.z > 1.0) {\n        u.yz = vec2(1.0 - u.z, 1.0 - u.x - u.y);\n    } else if(u.x + u.y + u.z > 1.0) {\n        u.xz = vec2(1.0 - u.y - u.z, u.x + u.y + u.z - 1.0);\n    }\n    return vec4(1.0 - u.x - u.y - u.z, u); \n}\n\n// for differential evolution, in addition to index K, we need to draw three more\n// indices a,b,c for a list of N items, without any collisions between k,a,b,c.\n// this is the O(1) hardcoded fisher-yates shuffle for this situation.\nivec3 sample_k_3(inout Random rng, int N, int K) {\n    ivec3 t = range(rng, ivec3(1,2,3), ivec3(N));\n    int db = (t.y == t.x)?1:t.y;\n    int dc = (t.z == t.y)?((t.x != 2)?2:1):((t.z == t.x)?1:t.z);\n    return (K + ivec3(t.x, db, dc)) % N;\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// auxiliary functions from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// The Unreasonable Effectiveness of Quasirandom Sequences, by Martin Roberts\nfloat r1(float o, int i) {\n    return fract(o + float(i * 10368889)/exp2(24.0));\n}\nvec2 r2(vec2 o, int i) {\n    return fract(o + vec2(i * ivec2(12664745, 9560333))/exp2(24.0));\n}\nvec3 r3(vec3 o, int i) {\n    return fract(o + vec3(i * ivec3(13743434, 11258243, 9222443))/exp2(24.0));\n}\nvec4 r4(vec4 o, int i) {\n    return fract(o + vec4(i * ivec4(14372619, 12312662, 10547948, 9036162))/exp2(24.0));\n}\n\nfloat r1(int i) { return r1(0.5, i); }\nvec2 r2(int i) { return r2(vec2(0.5), i); }\nvec3 r3(int i) { return r3(vec3(0.5), i); }\nvec4 r4(int i) { return r4(vec4(0.5), i); }\n\n/////////////////////////////////////////////////////////////////////////\n\n// if it turns out that you are unhappy with the distribution or performance\n// it is possible to exchange this function without changing the interface\nuint uhash(uint a, uint b) { \n    uint x = ((a * 1597334673U) ^ (b * 3812015801U));\n#ifdef RNGL_HIGH_QUALITY\n    // from https://nullprogram.com/blog/2018/07/31/\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n#else\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n#endif\n    return x;\n}\nfloat unorm(uint n) { return float(n) * (1.0 / float(0xffffffffU)); }", "buffer_a_code": "ivec2 topixel(vec2 uv) {\n    uv.x /= (iResolution.x/iResolution.y);\n    uv = (uv*0.5+0.5);\n    return ivec2(uv * iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec4 src = vec4(0.0); \n    if (iFrame > 0) {\n        src = texelFetch(iChannel0, fc, 0);\n    } else {\n        src.x = 0.0;\n    }\n    Random rng_base = seed(seed(fragCoord), iFrame);\n    if (fc.y == 0) {\n        Random rng = rng_base;// make a copy\n        // bin a gaussian distribution\n        float q = 1.0/iResolution.y;\n        for (int i = 0; i < 256; ++i) {\n            float n = gaussian(rng, 0.5, 0.2);\n            //float n = triangular(rng, 0.0, 1.0, 0.25);\n            int x = int(n * iResolution.x + 0.5);\n            if (x == fc.x) {\n                src.x += 1.0;\n            }       \n        }\n        src.w += 1.0;\n    } else {\n        Random rng = rng_base;// make a copy\n        src.rgb *= 0.983333;\n        for (int i = 0; i < 64; ++i) {\n            ivec2 p;\n            p = topixel(uniform_circle_area(rng)*0.25 + vec2(-1.5,1.0-0.3));\n            if (p == fc) { src.rgb += vec3(1.0,0.25,0.5); }\n            p = topixel(uniform_hexagon_area(rng)*0.25 + vec2(-0.75,1.0-0.3));\n            if (p == fc) { src.rgb += vec3(1.0,0.75,0.25); }\n            vec3 w = uniform_triangle_area(rng);\n            p = topixel(w.x*vec2(0.0,0.0)+w.y*vec2(0.57735*0.5,0.5)+w.z*vec2(0.57735,0.0) + vec2(-0.57735*0.5,0.45));\n            if (p == fc) { src.rgb += vec3(0.25,0.75,1.0); }\n            p = topixel(uniform_sphere_area(rng).xy*0.25 + vec2(0.75,1.0-0.3));\n            //p = topixel(uniform_sphere_volume(rng).xy*0.25 + vec2(0.75,1.0-0.3));\n            if (p == fc) { src.rgb += vec3(0.25,1.0,0.5); }            \n            vec4 u = uniform_simplex_volume(rng);\n            vec2 uc = u.x*vec2(-1.0,-1.0)+u.y*vec2(0.8,-0.8)+u.z*vec2(-0.8,0.8)+u.w*vec2(1.0,1.0);\n            p = topixel(uc*0.25 + vec2(1.5,0.7));\n            if (p == fc) { src.rgb += vec3(0.5,0.25,1.0); }\n        }\n    }\n    fragColor = src;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 125, 125, 186], [188, 188, 245, 245, 1220]], "test": "untested"}
{"id": "7dySRc", "name": "MFSDF Multi-Field SDF", "author": "PauloFalcao", "description": "MFSDF Multi-Field Signed Distance Function( x,y,z,FieldType ) -> (r,g,b,sdf)\nA single function defines the entire scene objects and all materials\nEvery object SDF and every object material parameter\nNo material ids are used", "tags": ["pathtracing", "mfsdf"], "likes": 14, "viewed": 711, "published": 3, "date": "1635514490", "time_retrieved": "2024-07-30T18:52:11.553739", "image_code": "// MFSDF Multi-Field Signed Distance Function\n// (x,y,z,FieldType) -> (r,g,b,sdf)\n//\n// By @PauloFalcao\n// https://www.shadertoy.com/view/7dySRc\n//\n// MFSDF is a scene description technique\n// \n// A single function defines the entire scene objects and all materials\n// Every object SDF and every object material parameter\n// No material ids are used\n//\n// It's a function were the 4º input parameter (.w) identifies the field type to obtain\n// x,y,z identifies 3d position in space of the field\n// The output x,y,z is the field value, w is the sdf (used for blending materials)\n// \n// Field 0, just returns the SDF (at .w), this way we can avoid procedural material calculations\n// on the raymarching loop\n//\n// This kind of approach is very usefull for node based programs like Material Maker\n// No material IDs are used, it's possible to combine many objects and all the material\n// parameters in a single function vec4 -> vec4\n// When transforming a object (translation, rotation, etc) the materials are also transformed\n// And it's possible com combine different object materials for smooth transitions between objects\n// using the sdf information\n//\n// You can use this system using Material Maker with version 0.3 of my Ray Marching lib\n// https://github.com/paulofalcao/MaterialMakerRayMarching\n// A 2 hours seminar about MFSDF and Ray Marching in Material maker\n// https://www.youtube.com/watch?v=PvmIohbf93Q\n//\n// It also defines a standart way to describe the object material (based on Disney PBR plus a combination of\n// other renders parameters out there, mainly Blender, Godot, three.js, Unity, Unreal, Sketchfab,\n// Vray, Corona etc\n// This renders and more renders like Arnold, Redshift, Octane have many more parameters but I think\n// the main ones are here and a mapping can be done between them.\n// This way is also possible to decouple the render code / render nodes from the object / material definition\n// \n// I propose this table for field types but a different table with more, less or different parameters can be used\n// I suggest using field type 999 to output the table definition id\n// This is table (0,0,0,0)\n// where x=table id ,y=table id version ,z=table id sub version, w (not used)\n// A different table could use (1234,0,0,0) as ID for example\n// \n// TABLE (0,0,0,0) - MFSDF Standart 0\n//\n// FieldType=0 is just the SDF,  1 is BaseColor / Albedo, etc\n//\n// FIELD TYPE                 OUTPUT\n//\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 3 - Subsurface             (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n// 6 - SpecularTint           (v,0,0,sdf)\n// 7 - Anisotropic            (v,0,0,sdf)\n// 8 - Sheen                  (v,0,0,sdf)\n// 9 - SheenTint              (v,0,0,sdf)\n//10 - Clearcoat              (v,0,0,sdf)\n//11 - Clearcoat Gloss        (v,0,0,sdf)\n//12 - Clearcoat Normal       (x,y,z,sdf)\n//13 - Emission               (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//16 - IOR                    (v,0,0,sdf)\n//17 - Transmission           (v,0,0,sdf)\n//18 - Transmission Roughness (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf)\n//999 - Table ID - Identifies this table (0,0,0,0)\n//\n// Bibliography at the end\n//\n// One year ago, I briefly talked about this concept at\n// https://github.com/RodZill4/material-maker/commit/de29bddb45505ffbcb02348ff3169f60cde5cd39\n//\n//\n// ==== The path tracing render ===\n//\n// This a very basic / naive / beta path tracing render, many thing are not supported yet, and\n// many things are not correct, the idea of this code is just show the MFSDF ideia\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(pow(color.xyz/color.w,vec3(1.0/1.7)), 1.0f);\n     \n}\n\n// \n// Bibliography\n//\n// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf\n// https://www.realtimerendering.com/\n// https://www.pbr-book.org/\n// https://raytracing.github.io/books/RayTracingInOneWeekend.html\n// https://raytracing.github.io/books/RayTracingTheNextWeek.html\n// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html\n// https://seblagarde.wordpress.com/2015/07/14/siggraph-2014-moving-frostbite-to-physically-based-rendering/\n// https://www.scratchapixel.com/index.php\n// https://www.youtube.com/playlist?list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi\n// https://google.github.io/filament/Materials.html\n// https://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n// https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/\n// https://blog.demofox.org/2020/06/14/casual-shadertoy-path-tracing-3-fresnel-rough-refraction-absorption-orbit-camera/\n// https://autodesk.github.io/standard-surface/\n// https://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf\n// https://learnopengl.com/PBR/Theory\n// https://jcgt.org/published/0007/04/01/\n// \n// Shaders\n//\n// https://github.com/knightcrawler25/GLSL-PathTracer (not a shader, but good GLSL code)\n// https://www.shadertoy.com/view/XdyyDd by markusm\n// https://www.shadertoy.com/view/llGyRd by markusm\n// https://www.shadertoy.com/view/tsBBWW by demofox\n// https://www.shadertoy.com/view/WsBBR3 by demofox\n// https://www.shadertoy.com/view/ttfyzN by demofox\n// https://www.shadertoy.com/view/MlyyzW by reinder\n// https://www.shadertoy.com/view/3lB3DR by sschmidtix\n// https://www.shadertoy.com/view/XlXfDs by koiava\n// https://www.shadertoy.com/view/4ddcRn by otaviogood\n//\n// Renders PBRs Reference\n//\n// Disney    https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Godot     https://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html\n// Unreal    https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n// Unity       https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html\n// Blender   https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/principled.html\n// Filament  https://google.github.io/filament\n// Sketchfab https://help.sketchfab.com/hc/en-us/articles/204429595-Materials-PBR-\n// Substance https://substance3d.adobe.com/tutorials/courses/the-pbr-guide-part-1\n// Cryengine https://www.youtube.com/watch?v=hGFP_4TYL2o\n// 3DSMax    https://help.autodesk.com/view/3DSMAX/2021/ENU/?guid=GUID-A16234A5-6500-4662-8B20-A5EC9FE1B255\n// Redshift  https://docs.redshift3d.com/display/RSDOCS/Material\n// Arnold    https://docs.arnoldrenderer.com/display/A5AF3DSUG/Standard+Surface\n// Octane    http://www.aoktar.com/octane/OCTANE%20HELP%20MANUAL.html?UniversalMaterial.html\n// VRay      https://docs.chaosgroup.com/display/VMAX/VRayMtl\n// Mitsuba2  https://mitsuba2.readthedocs.io/en/latest/generated/plugins.html#bsdfs\n//\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//RENDER SETTINGS\nconst float maxDist=20.0;\nconst int maxIte=8;\nconst int samples=16; //change this number according to your GPU power\n\n//MATH\nconst float PI=3.14159265359;\nconst float TAU=6.28318530718;\n\nvoid Onb(in vec3 N, inout vec3 T, inout vec3 B){\n    vec3 UpVector=abs(N.z)<0.999?vec3(0,0,1):vec3(1,0,0);\n    T=normalize(cross(UpVector,N));\n    B=cross(N,T);\n}\n\n// RANDOM START\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint rand_pcg(inout uint seed){\n    uint state = seed;\n    seed = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfloat RandomFloat01(inout uint state){\n    uint r=rand_pcg(state);\n    r &= 0x007FFFFFu;\n    r |= 0x3F800000u;\n    return uintBitsToFloat(r) - 1.0f;\n}\n\n// RANDOM END\n\n\n// SAMPLING START\n\nvec3 uniformSampleSphere(float r1,float r2){\n    float z=1.0-2.0*r1;\n    float r=sqrt(max(0.0,1.0-z*z));\n    float phi=TAU*r2;\n    return vec3(r*cos(phi),r*sin(phi),z);\n}\n\nvec3 cosineSampleHemissphere(inout uint state,vec3 n){\n    float u1=RandomFloat01(state);\n    float u2=RandomFloat01(state);\n    return normalize(n+uniformSampleSphere(u1,u2)); \n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 SampleGGXVNDF(inout uint state,vec3 Ve,float alpha_x,float alpha_y){\n    float U1=RandomFloat01(state);\n    float U2=RandomFloat01(state);\n    \n    //transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\n    //orthonormal basis\n    vec3 T1;vec3 T2;\n    Onb(Vh,T1,T2);\n\n    //parameterization of the projected area\n    float r = sqrt(U1); \n    float phi = 2.0 * PI * U2;    \n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\n    //reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n\n    //transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z))); \n\n    return Ne;\n}\n\nfloat schlickWeight(float cosTheta) {\n    float m=clamp(1.-cosTheta,0.,1.);\n    float m2=m*m;\n    return m2*m2*m;\n}\n\n// SAMPLING END\n\n\n//---------------------------------------------------------\n// MFSDF FUNCTION START\n//---------------------------------------------------------\n\n//MFSDF Combine functions \n\nvec4 mf_smooth_union(vec4 a, vec4 b, float k) {\n  float h = max( k-abs(a.w-b.w), 0.0 )/k;\n  h=h*h*k*0.25;\n  return vec4(mix(a.xyz,b.xyz,clamp(a.w*1.0/k,0.0,1.0)),min( a.w, b.w ) - h);\n}\n\nvec4 mf_min(vec4 a,vec4 b){\n  if (a.w<b.w) return a; else return b;\n}\n\nvec4 lights(vec4 p){\n  p.y-=6.0;\n  //p.xz=mod(p.xz,2.0)-1.0;\n  p.xz=mod(p.xz,8.0)-4.0;\n  float sdf=length(p.xyz)-0.9;\n  \n  //13-Emission (r,g,b,sdf) linear (0-infinite)\n  if ((p.w>12.5)&&(p.w<13.5)){\n   return vec4(vec3(40.0),sdf);\n  } else {\n   return vec4(vec3(0),sdf);\n  }\n}\n\nvec4 obj_a(vec4 p){\n  float sphereSize=0.9;\n\n  vec3 color=vec3(0.78,0.19,0.26);\n  p.y+=(sin(p.x*32.0)*sin(p.y*32.0)*sin(p.z*32.0))*0.1;\n  float sdf=length(p.xyz)-sphereSize;\n  \n  float v=sin(atan(p.x,p.z)*8.0)>0.0?1.0:0.0;\n\n  // 5 - Roughness (v,0,0,sdf)\n  if ((p.w>4.5)&&(p.w<5.5)){\n   return vec4(0.1,0.0,0.0,sdf);\n  } else\n  // 4 - Specular (v,0,0,sdf)\n  if ((p.w>3.5)&&(p.w<4.5)){\n   return vec4(0.6,0.0,0.0,sdf);\n  } else\n  // 2 - Metallic (v,0,0,sdf)\n  if ((p.w>1.5)&&(p.w<2.5)){\n   return vec4(v,0.0,0.0,sdf);\n  } else\n  // 1 - BaseColor (r,g,b,sdf) linear (0-1)\n  if ((p.w>0.5)&&(p.w<1.5)){\n   return vec4(color,sdf);\n  }\n  // 0 - SDF (0,0,0,sdf)\n  else {\n   return vec4(vec3(0.0),sdf*0.5);\n  }\n}\n\nvec4 floor_a(in vec4 p){\n  float sdf=p.y+1.0;\n  float v=sin(p.x*PI)*sin(p.z*PI)<0.0?1.0:0.0;\n\n  // 5 - Roughness (v,0,0,sdf)\n  if ((p.w>4.5)&&(p.w<5.5)){\n   return vec4(0.05,0.0,0.0,sdf);\n  } else\n  // 4 - Specular (v,0,0,sdf)\n  if ((p.w>3.5)&&(p.w<4.5)){\n   return vec4((1.0-v)*0.8+0.1,0.0,0.0,sdf);\n  } else\n  // 2 - Metallic (v,0,0,sdf)\n  if ((p.w>1.5)&&(p.w<2.5)){\n   return vec4(0.0,0.0,0.0,sdf);\n  } else\n  // 1 - BaseColor (r,g,b,sdf) linear (0-1)\n  if ((p.w>0.5)&&(p.w<1.5)){\n   //Because of an extremely odd reason this code does not work on some D3D11 backend\n   //It Renders ok on OpenGL backend\n   //So... I had to use sin to do a checkboard :(\n   //https://bugs.chromium.org/p/angleproject/issues/detail?id=6260\n   //\n   //return vec4(vec3(mod(floor(p.x)+floor(p.z),2.0))*0.8+0.1,sdf);\n   //\n   return vec4(vec3(v*0.8+0.1),sdf);\n  }\n  //0-SDF (0,0,0,sdf)\n  else {\n   return vec4(vec3(0),sdf);\n  }\n}\n\n//This is the main MFSDF (Multi-Field Signed Distance Function)\n//(x,y,z,FieldType) -> (r,g,b,sdf)\nvec4 mfsdf(vec4 p){\n  return mf_min(lights(p),\n     mf_smooth_union(floor_a(p),\n     obj_a(p),0.9));\n}\n\n//---------------------------------------------------------\n// MFSDF FUNCTION END\n//---------------------------------------------------------\n\n\n\nvec3 HDRI360(vec3 p){\n    p=p.xyz;\n    return pow(texture(iChannel1,p).xyz,vec3(2.2))+\n           pow(texture(iChannel2,p).xxx,vec3(2.2));\n}\n\n\n\n//tetrahedron normal by PauloFalcao\nvec3 normal(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=mfsdf(vec4(p+e.xyy,0.0)).w;\n  float v2=mfsdf(vec4(p+e.yyx,0.0)).w;\n  float v3=mfsdf(vec4(p+e.yxy,0.0)).w;\n  float v4=mfsdf(vec4(p+e.xxx,0.0)).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid raymarch(in vec3 o,in vec3 v,out vec3 p,inout float d){\n  float s;\n  for(int i=0;i<1024;i++){\n    p=o+v*d;\n    s=mfsdf(vec4(p,0.0)).w;\n    if (abs(s)<0.0001) break;\n    d+=s;\n    if (d>maxDist) break;\n  } \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // From https://www.shadertoy.com/view/tsBBWW by demofox\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n  \n    //Camera - Trackball style\n    float mx=(iMouse.x/iResolution.x)*PI*2.0;\n    float my=(iMouse.y/iResolution.y)*PI/2.01;\n    vec3 o=vec3(cos(my)*sin(mx),sin(my),cos(my)*cos(mx))*4.0; \n    \n    vec3 t=vec3(0.0,0.0,0.0);\n    vec3 u=vec3(0.0,1.0,0.0);\n    vec3 c=normalize(t-o);\n    vec3 cx=normalize(cross(u,c));\n    vec3 cy=normalize(cross(c,cx));\n    \n    vec3 sumrgb=vec3(0.0);\n    for(int aa=0;aa<samples;aa++){\n    \n        vec2 xy=((fragCoord.xy+vec2(RandomFloat01(rngState),RandomFloat01(rngState)))/iResolution.xy)-0.5;\n        xy.x*=(iResolution.x/iResolution.y);\n        vec3 v=normalize(c*1.5+cx*xy.x+cy*xy.y);\n\n        vec3 p;\n        float d=0.01;\n        vec3 rgb=vec3(1.0);\n        vec3 io=o;\n        int i;\n        for(i=0;i<maxIte;i++){\n        \n          raymarch(io/*in*/,v/*in*/,p/*out*/,d/*inout*/);\n          \n          vec3 n=normal(p);\n          \n          //View direction to tangent space\n          vec3 t;vec3 b;Onb(n,t,b);\n          vec3 vt=vec3(dot(-v,t),dot(-v,b),dot(-v,n));\n\n          if (d<maxDist){\n            vec3 obj_Emission=mfsdf(vec4(p,13.0)).rgb;\n            \n            if ((obj_Emission.x+obj_Emission.y+obj_Emission.z)>0.001){\n                rgb=max(obj_Emission*(1.0-d/(maxDist-1.0)),0.0)*rgb;\n                break;\n            } else {\n                float s=RandomFloat01(rngState);\n\n                vec3 obj_BaseColor=mfsdf(vec4(p,1.0)).rgb; // 1 - BaseColor  (r,g,b,sdf)\n                float obj_Metallic=mfsdf(vec4(p,2.0)).x;   // 2 - Metallic   (v,0,0,sdf)\n                float obj_Specular=mfsdf(vec4(p,4.0)).x;   // 4 - Specular   (v,0,0,sdf)\n                float obj_Roughness=mfsdf(vec4(p,5.0)).x;  // 5 - Roughness  (v,0,0,sdf)\n\n                if (s>obj_Specular*obj_Specular){\n                    rgb=max(obj_BaseColor-(obj_BaseColor*obj_Metallic)*(1.0-d/(maxDist-1.0)),0.0)*rgb;\n                    v=cosineSampleHemissphere(rngState,n);\n                } else {\n  \n                    float r2=obj_Roughness*obj_Roughness;\n                    vec3 vndf=SampleGGXVNDF(rngState,vt,r2,r2);\n                    vec3 nv=reflect(-vt,vndf);\n\n                    //Sample direction back to camera space\n                    nv=nv.x*t+nv.y*b+nv.z*n;\n \n                    float FH=schlickWeight(dot(n,nv));\n                    vec3 Cspec0=mix(vec3(obj_Specular*.08),obj_BaseColor,obj_Metallic);\n                    vec3 Fs=mix(Cspec0,vec3(1),FH);\n                    rgb=max(Fs*(1.0-d/(maxDist-1.0)),0.0)*rgb;\n                    \n                    v=nv;\n                }\n                io=p;\n                d=0.001;\n            }\n          } else {\n           rgb*=HDRI360(v);\n           break;\n          }\n        }//for(int i\n        if (i==maxIte) rgb=vec3(0.0);//did not hit any light source\n        sumrgb+=rgb;\n    }//for(int aa\n    \n    // average the frames together\n    sumrgb=sumrgb/float(samples);\n\n    if (iMouse.z<0.1){\n        vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n        fragColor = vec4(lastFrameColor+vec4(sumrgb,1.0));\n    } else {\n        fragColor = vec4(sumrgb,1.0);\n    }   \n\n}\n\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dySRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3764, 3764, 3820, 3820, 3959]], "test": "untested"}
{"id": "NdyXDd", "name": "Erdős–Rényi Random Graphs", "author": "gauravity", "description": "Generates random graphs and runs a physics simulation! Use mouse to drag vertices around\nGo to Common for some params to change!", "tags": ["simulation", "physics", "graphs"], "likes": 14, "viewed": 376, "published": 3, "date": "1635499943", "time_retrieved": "2024-07-30T18:52:12.556059", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(209.,205., 219., 255.)/255.;\n    vec2 uv = fragCoord / iResolution.x;\n    vec4 blu =  vec4(.3, .8, 1, 1);\n\n    #ifdef drawLines\n    for(int i =0; i < n; i++){\n        vec3 c = hsv2rgb(vec3(rand(vec2(i, i)),0.5, 1.));\n        \n        for(int j=0; j < n; j++){\n            if(j <= i){\n                continue;\n            }\n            if (getEdge(i, j)) {\n                line(fragColor, uv, getVertex(i).xy, getVertex(j).xy, lineThickness, vec4(1));\n            }\n        }\n    }\n    #endif\n    for(int i =0; i < n; i++){\n        vec3 c = hsv2rgb(vec3(rand(vec2(i, i)),0.5, 1.));\n        circle(fragColor, uv, getVertex(i).xy, radius, vec4(c, 1));\n     }\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Comment out the following line to disable drawing the lines between vertices\n// Drawing lines is the most expensive operation, without it you can simulate\n// Hundreds of vertices (even while simulating the springs)\n#define drawLines \n//change seed for different random graph\n#define seed vec2(420., 69.)\n//number of vertices (up to min(iResolution.x, iResolution.y)\n#define n 30\n//probability that any two vertices have a edge between them. \n// p*n is the average degree of a vertex (best results around p*n = 3)\n#define p  0.1\n// radius of each vertex\n#define radius 0.015\n// attracting force between vertices with spring (hooks law)\n#define k 15.\n// repellant force between vertices/wall (q/r^2)\n#define q .005\n// velocity wil *= drag once per second, lower = more drag\n#define drag 0.01\n// amount each particle repels the wall (as a fraction of q)\n#define wallRatio 3.\n// thickness of line\n#define lineThickness 0.0015\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n// Official HSV to RGB conversion \n//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid circle(inout vec4 fragColor, in vec2 x, vec2 c, float r, vec4 color) {\n    if (length(c-x) < r) {\n        fragColor = color;\n    }\n}\nfloat rand(vec2 co){ return fract(sin(dot(co.xy + seed,vec2(12.9898,78.233))) * 43758.5453); }\n\n\nvoid line(inout vec4 fragColor, in vec2 x, vec2 p1, vec2 p2, float thicc, vec4 color) {\n    vec2 relx = x - p1;\n    vec2 dir = p2 - p1;\n    float projFactor = dot(relx, dir)/dot(dir, dir);\n    vec2 proj = projFactor*dir;\n    vec2 diff = proj - relx;\n    if (dot(diff, diff) < thicc*thicc && projFactor > 0. && projFactor < 1.) {\n        fragColor = color;\n    }\n}\n// https://www.shadertoy.com/view/tdGBDG\n// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\n\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n\n#define fetchData(addr) texelFetch(iChannel0, addr, 0)\n#define getVertex(i) fetchData(ivec2(i, i))\n#define getEdge(i, j) (fetchData(ivec2(i, j)).x>0.5)\n\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n", "buffer_a_code": "#define PI 3.14159265\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 index = ivec2(fragCoord);\n    if(index.x >= n || index.y >= n || index.x > index.y) {\n        \n        return;\n    }\n    vec2 dims = iResolution.xy / iResolution.x;\n\n    \n    // edge, initialize once\n    if (index.x != index.y) {\n        fragColor = vec4(0., 0., 0., 0.);\n        if(rand(fragCoord) < p) {\n            fragColor += 1.;\n        }\n        return;\n    }\n    \n    float theta = 2.*PI*float(index.x)/float(n);\n    fragColor.xy = dims/2. + vec2(cos(theta),sin(theta))*.1; \n    fragColor.zw = vec2(0,0);\n    if (iFrame < 1) {\n        return;\n    }\n    fragColor = fetchData(index);\n    for(int i =0; i < n; i++) {\n        if (i == index.x) {\n            continue;\n        }\n        if (length(fragColor.xy-getVertex(i).xy) == 0.) {\n            fragColor.xy += fragCoord.xy*.00001;\n        }\n        float chargeForce = q/pow(length(fragColor.xy - getVertex(i).xy), 2.);\n        vec2 direction = normalize(fragColor.xy - getVertex(i).xy);\n        fragColor.zw += direction*chargeForce*iTimeDelta;\n        if (getEdge(i, index.x) || getEdge(index.x, i)) {\n            fragColor.zw += k*(getVertex(i).xy - fragColor.xy)*iTimeDelta;\n        }\n        \n    }\n    vec2 c = fragColor.xy*fragColor.xy;\n    vec2 d = (dims-fragColor.xy)*(dims-fragColor.xy);\n    fragColor.zw += iTimeDelta * (wallRatio*q/c - wallRatio*q/d);\n    fragColor.zw *= pow(drag, iTimeDelta);\n    fragColor.zw = clamp(fragColor.zw, -1., 1.);\n    vec2 mouseProj = iMouse.xy/iResolution.x;\n    if (length(mouseProj-fragColor.xy) < radius) {\n        fragColor = vec4(mouseProj, 0, 0);\n    }\n    fragColor.xy += fragColor.zw * iTimeDelta;\n    fragColor.xy = clamp(fragColor.xy, vec2(0,0), dims);\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 737]], "test": "untested"}
{"id": "tddyDr", "name": "PerlinNoiseEffect", "author": "celns", "description": "PerlinNoise", "tags": ["perlinnoise"], "likes": 2, "viewed": 169, "published": 3, "date": "1635473525", "time_retrieved": "2024-07-30T18:52:13.403792", "image_code": "//Hash2D based on: http://www.shadertoy.com/view/4djSRW\n\nvec2 Hash2D(vec2 p)\n{\n \tp = vec2( dot(p, vec2(127.1, 311.7)),\n              dot(p, vec2(269.5, 183.3)));\n    return  -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat PerlinNoise2D(vec2 seed)\n{\n    vec2 intFloorValue = floor(seed);\n    vec2 intCeilValue = ceil(seed);\n    vec2 fractValue = fract(seed);\n    \n    //vec2 interValue = smoothstep(0.0, 1.0, fractValue);\n    vec2 interValue = fractValue*fractValue*fractValue*(fractValue*(fractValue*6.0-15.0)+10.0);\n    \n    return mix(mix(dot(Hash2D(intFloorValue), fractValue),\n                   dot(Hash2D(intFloorValue + vec2(1.0, 0.0)), fractValue - vec2(1.0, 0.0)),\n                   interValue.x),\n               mix(dot(Hash2D(intFloorValue + vec2(0.0, 1.0)), fractValue - vec2(0.0, 1.0)),\n                   dot(Hash2D(intCeilValue), fractValue - vec2(1.0, 1.0)),\n                   interValue.x),\n               interValue.y);\n}\n\nvec3 Pattern(vec2 uv)\n{\n    vec3 col = vec3(0);\n    uv+=0.5;\n    float scaler = 10.;\n\tuv *= 2. * scaler;\n    \n    float amp = 50.;\n    uv.x+=sin(iTime);\n    uv.y+=cos(iTime);\n    \n\n    float value = PerlinNoise2D(uv);\n    if(uv.y < scaler*1.5)\n    {\n        col = vec3(1.0/value);\n    }\n    else if(uv.y < scaler* 2.0)\n    {\n        col = vec3(uv.x +uv.y+1.0/value);\n    }   \n    else if(uv.y < scaler* 2.5)\n    {\n        \n        col = vec3(tan(1.0/value));\n    }\n    else\n    {\n        col = vec3(value * 0.5 + 0.5);\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Output to screen\n    fragColor = vec4(Pattern(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 78, 78, 217], [219, 219, 251, 251, 944], [946, 946, 969, 969, 1489], [1492, 1492, 1549, 1599, 1750]], "test": "untested"}
{"id": "fsySDd", "name": "Grid Spiral Test", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 18, "viewed": 323, "published": 3, "date": "1635470296", "time_retrieved": "2024-07-30T18:52:14.275462", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// idea:\n// change brightness depending on difference in radius from last frame to this one,\n// for each cell / circle\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float xr = 40.; float yr = 40.;\n    \n    vec2 ipos = vec2(floor(xr * uv.x) + 0.5, floor(yr * uv.y) + 0.5);\n    vec2 fpos = vec2(fract(xr * uv.x) - 0.5, fract(yr * uv.y) - 0.5);\n    \n    float id = length(ipos);//max(abs(ipos.x), abs(ipos.y));\n    float d = 1.- length(fpos);//max(abs(fpos.x), abs(fpos.y));\n   // d *= .5;\n    // 3.5 30. 3.5 // 30. / 37.\n   // float m = 30./37.;\n    float a = atan(ipos.y, ipos.x);\n    float b = .5 + .5 * cos(iTime + 0.1 * length(ipos));\n    //b = b * (1.-b) * 4.;\n    float e = 1.8 + 0.5 * cos(-0.8 * iTime + 1. * a + 0.5 * id);\n    float e2 = e + cos(0.8 * iTime + 3. * a - 0.5 * id);\n\n    //float e2= cos(0.1 * id + 0.8 * iTime);//\n    float c = step(max(0.5, pow(0.5 + 0.5 * (1.-b) * e,12.)), d);//(1.-b) * e);\n    \n    float c2 =  step(max(0.5, pow(0.5 + 0.5 * b * e2, 4.)), d);//(1.-b) * e);//step(0.5 + 0.5 * b * e2, d);\n    c = smoothstep(-0.1,0.1,c2-c) * c;\n    //c *= .5 + .5 * cos(c + iTime);\n    //c = clamp(c, 0., 1.);\n    \n    vec3 col = pal(e/c + 0.4 * h21(ipos), vec3(0.5), vec3(0.5), vec3(1.5), vec3(0.,0.333,0.666));\n    \n    // Time varying pixel color\n   // vec3 col = vec3(c * e);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [113, 113, 133, 133, 208], [210, 329, 386, 436, 1703]], "test": "untested"}
{"id": "NdyXDt", "name": "Taste of Noise 14c", "author": "leon", "description": "mouse interactive neon city life", "tags": ["weird"], "likes": 49, "viewed": 6639, "published": 3, "date": "1635466128", "time_retrieved": "2024-07-30T18:52:15.167078", "image_code": "// taste of noise 14c by leon denise 2021/10/29\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret, Blackle and many others\n// licensed under hippie love conspiracy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // result of Buffer A\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "// taste of noise 14c by leon denise 2021/10/29\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret, Blackle and many others\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nvec3 rng;\nvec2 mouse;\n\n// geometry\nfloat map (vec3 p)\n{\n    // hold space coordinates\n    vec3 pp = p;\n    \n    // distances\n    float scene = 1000.;\n    float shape = 1000.;\n    \n    // parameters\n    vec3 angle = vec3(1.+mouse.x,2.+mouse.y,3);\n    float range = .2;\n    \n    // shiny material\n    material = -1.;\n    \n    // amplitude of kifs\n    float a = 1.;\n    float falloff = 1.55+.05*mouse.y;\n    \n    // kifs (kaleidoscopic iterated function)\n    const float count = 12.;\n    for (float index = 0.; index < count; ++index)\n    {\n        // rotate more and more\n        p.xz *= rot(angle.y/a);\n        \n        // fold and translate\n        p = abs(p)-range*a;\n        \n        // combine to scene\n        scene = min(scene, max(p.x, max(p.y, p.z)));\n        \n        // falloff\n        a /= falloff;\n    }\n    \n    // invert volume\n    scene = -scene;\n    \n    // lines\n    p = pp;\n    p.xz *= rot(mouse.x);\n    p.yz *= rot(mouse.y);\n    p = repeat(p, .1);\n    shape = min(scene, length(p.xz)-.001*rng.x);\n    \n    // lines material and combine to scene\n    material = shape < scene ? 1. : material;\n    scene = min(shape, scene);\n    \n    return scene;\n}\n\nvec3 color (vec3 pos, vec3 ray, vec3 normal)\n{    \n    vec3 color = vec3(0.);\n    \n    // lines\n    if (material > 0.)\n    {\n        // color palette by Inigo Quilez (https://iquilezles.org/articles/palettes)\n        color = .5+.5*cos(vec3(0, .3, .6)*6.+length(pos)*20.+mouse.x);\n    }\n\n    return color;\n}\n\n// sdf estimator\nfloat raymarch (inout vec3 pos, vec3 ray, float dither, float count)\n{\n    // shoot rays\n    for (float index = count; index > 0.; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        \n        // hit volume\n        if (dist < 0.001)\n        {\n            // return steps ratio\n            return index / count;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * dither;\n        \n        // ray march\n        pos += ray * dist;\n    }\n    \n    // no volume\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // reset color\n    fragColor = vec4(0,0,0,1);\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash33(seed);\n    \n    // mouse interaction\n    mouse = 8.*iMouse.xy/iResolution.xy;\n    \n    vec3 rng3 = hash33(seed+78.);\n    \n    // camera coordinates\n    vec3 eye = vec3(0,-0.1,0.1);\n    vec3 at = vec3(0,0,.3);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = cross(x, z);\n    vec3 ray = normalize(z + uv.x * x + uv.y * y);\n    vec3 pos = eye + ray * .1;\n    \n    // raymarching\n    float shade = raymarch(pos, ray, rng.z, 30.);\n\n    // hit volume\n    if (shade > 0.)\n    {\n        // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n        vec2 off=vec2(0.001,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n        // coloring\n        fragColor.rgb += color(pos, ray, normal) * shade; \n        \n        // reflection bounce\n        ray = reflect(ray, normal);\n        \n        // Blackle (https://suricrasia.online/demoscene/functions/)\n        rng3 = normalize(tan(rng3*2.-1.));\n        \n        // jitter blur\n        ray = normalize(ray + rng3);\n        \n        // avoid self collision\n        pos += ray * .01;\n        \n        // shot rays\n        shade = raymarch(pos, ray, rng.z, 20.);\n        \n        // hit neon grid\n        if (material > 0. && shade > 0.)\n        {\n            // coloring\n            normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n            fragColor.rgb += color(pos, ray, normal) * shade;\n        }\n    }\n    \n    // temporal buffer\n    float fade = 0.001;\n    fade += step(0.5, iMouse.z);\n    vec4 frame = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = max(fragColor.rgb, frame.rgb - fade);\n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXDt.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[179, 179, 236, 262, 331]], "test": "untested"}
{"id": "fsySWd", "name": "triquetra", "author": "ufffd", "description": "simple drawing, definitely not efficient", "tags": ["poi", "triquetra", "thirdordermotion"], "likes": 0, "viewed": 107, "published": 3, "date": "1635465833", "time_retrieved": "2024-07-30T18:52:16.067670", "image_code": "const float zoom = .8;\nconst vec2 shift = vec2(0.0,0.088);\nconst vec2 flower = vec2(\n    1.0, // arm spins\n    -2.0 // hand spins\n);\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= (iResolution.x - iResolution.y) / iResolution.x * 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv -= 0.5;\n    \n    uv *= zoom;\n    \n    uv += shift;\n    \n    float bw = 1.0;\n    \n    for (int i=0;i<1000;i++){\n    \n        vec2 center = vec2(0.,0.2);\n\n        center = rotate(center, iTime + float(i) * 0.0407) * flower.x;\n        center += rotate(vec2(0.,0.2), (iTime + float(i) * 0.0407) * flower.y);\n\n        bw *= smoothstep(.03,.031, distance(uv,center));\n\n    }\n    \n    // Output to screen\n    fragColor = vec4(vec3(bw),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 164, 164, 248], [250, 250, 307, 357, 951]], "test": "untested"}
{"id": "fsGXWt", "name": "Taste of Noise 13c", "author": "leon", "description": "mouse interactive tardigrade neon party", "tags": ["weird"], "likes": 19, "viewed": 606, "published": 3, "date": "1635461246", "time_retrieved": "2024-07-30T18:52:17.199644", "image_code": "// taste of noise 13c by leon denise 2021/10/29\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret, Blackle and many others\n// licensed under hippie love conspiracy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // result of Buffer A\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "// taste of noise 13c by leon denise 2021/10/29\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret, Blackle and many others\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nvec2 mouse;\n\n// geometry\nfloat map (vec3 p)\n{\n    // hold space coordinates\n    vec3 pp = p;\n    \n    // distances\n    float scene = 1000.;\n    float shape = 1000.;\n    \n    // parameters\n    vec3 angle = vec3(1.+mouse.x,2.+mouse.y,3);\n    float range = .5;\n    float size = .3;\n    \n    // shiny material\n    material = -1.;\n    \n    // amplitude of kifs\n    float a = 1.;\n    \n    // kifs (kaleidoscopic iterated function)\n    const float count = 8.;\n    for (float index = 0.; index < count; ++index)\n    {\n        // rotate more and more\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.xy *= rot(angle.z/a);\n        \n        // fold and translate\n        p.x = abs(p.x)-range*a;\n        \n        // combine to scene\n        scene = smin(scene, length(p)-size*a, 0.1*a);\n        \n        // falloff\n        a /= 1.4;\n    }\n    \n    // reset space\n    p = pp;\n    \n    // domain repeat\n    float grid = 6.;\n    p.xz = repeat(p.xz+.5/grid, 1./grid);\n    \n    // lines\n    shape = min(length(p.xy), length(p.yz))-.001;\n    \n    // crop lines\n    shape = max(shape, sdBox(pp, vec3(1)));\n    \n    // lines material and combine to scene\n    material = shape < scene ? 1. : material;\n    scene = min(shape, scene);\n    \n    return scene;\n}\n\nvec3 color (vec3 pos, vec3 ray, vec3 normal)\n{    \n    vec3 color = vec3(0.);\n    \n    // spheres\n    if (material == -1.)\n    {\n        // lighting\n        vec3 rf = reflect(ray, normal);\n        vec3 backlight = vec3(0.1) * sqrt(dot(rf, vec3(0,0,1))*0.5+0.5);\n        vec3 specular = vec3(1) * pow(dot(rf, normalize(vec3(0,1,0)))*0.5+0.5,10.);\n        color = backlight + specular*.2;\n    }\n    // lines\n    else\n    {\n        // color palette by Inigo Quilez (https://iquilezles.org/articles/palettes)\n        color = .5+.5*cos(vec3(0, .3, .6)*6.+length(pos)*5.+mouse.x);\n    }\n\n    return color;\n}\n\n// sdf estimator\nfloat raymarch (inout vec3 pos, vec3 ray, vec3 rng, float dither, float count)\n{\n    // shoot rays\n    for (float index = count; index > 0.; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        \n        // hit volume\n        if (dist < 0.001)\n        {\n            // return steps ratio\n            return index / count;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * dither;\n        \n        // ray march\n        pos += ray * dist;\n    }\n    \n    // no volume\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // reset color\n    fragColor = vec4(0,0,0,1);\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    vec3 rng = hash33(seed);\n    \n    // mouse interaction\n    mouse = 8.*iMouse.xy/iResolution.xy;\n    \n    // blur\n    vec3 rng3 = hash33(seed+78.);\n    vec2 dof = vec2(cos(rng3.x*6.28),sin(rng3.x*6.28))*rng3.y;\n    uv += dof*pow(length(uv), 5.0)*rng3.z;\n    \n    // camera coordinates\n    vec3 eye = vec3(.5,1,-3.);\n    vec3 at = vec3(0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = cross(x, z);\n    vec3 ray = normalize(z * 2. + uv.x * x + uv.y * y);\n    vec3 pos = eye + ray * (rng3.z*.5);\n    \n    // raymarching\n    float shade = raymarch(pos, ray, rng3, rng.z, 20.);\n\n    // hit volume\n    if (shade > 0.)\n    {\n        // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n        vec2 off=vec2(0.001,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n        // coloring\n        fragColor.rgb += color(pos, ray, normal) * shade; \n        \n        // reflection bounce\n        ray = reflect(ray, normal);\n        \n        // Blackle (https://suricrasia.online/demoscene/functions/)\n        rng3 = normalize(tan(rng3*2.-1.));\n        \n        // jitter blur\n        ray = normalize(ray + rng3);\n        \n        // avoid self collision\n        pos += ray * .01;\n        \n        // shot rays\n        shade = raymarch(pos, ray, rng3, rng.z, 20.);\n        \n        // hit neon grid\n        if (material > 0. && shade > 0.)\n        {\n            // coloring\n            normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n            fragColor.rgb += color(pos, ray, normal) * shade;\n        }\n    }\n    \n    // temporal buffer\n    float fade = 0.001;\n    fade += step(0.5, iMouse.z);\n    vec4 frame = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = max(fragColor.rgb, frame.rgb - fade);\n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXWt.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[179, 179, 236, 262, 331]], "test": "untested"}
{"id": "NsySzz", "name": "Height Map with RayMarching", "author": "Remming_Senegal", "description": "creates a height map with a given image, and then displays the height map on a plane\n\nWhile I'm not the first to make something like this, it was a good learning experience.\n\nI'm curious what else I can do with height maps and SDFs now.", "tags": ["2d", "3d", "postprocess", "height", "image", "sample"], "likes": 16, "viewed": 1492, "published": 3, "date": "1635455003", "time_retrieved": "2024-07-30T18:52:18.163067", "image_code": "#define FOV 90.0\n#define PI 3.1415926535\n\n// Max steps for ray marcher\n#define MAX_STEPS 600\n#define MAX_DISTANCE 15.0\n// Max threshold for error\n#define EPSILON 0.001\n#define NORMAL_EPSILON 0.001\n\n//height factor for heightmap \n#define HEIGHT_FACTOR 0.5\n\n// Uncomment the line below to see just the heightmap\n//#define DEBUG\n\n// Uncomment the line below for free camera control\n//#define FREE_CAMERA\n\nfloat luminance(vec3 col) {\n    return (0.2126*col.r + 0.7152*col.g + 0.0722*col.b);\n}\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir;\n};\n\nmat3 RotationX(float rotation) {\n    mat3 rotateX = mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 RotationY(float rotation) {\n    mat3 rotateY = mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 RotationZ(float rotation) {\n    mat3 rotateZ = mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n/*\n    Applies transformations as we see fit\n    It's in a function like this because we call this twice\n        -Transform the ray that the scene uses\n        -Transform the UV that the tetxure shader uses\n    THIS IS A VERY IMPORTANT FUNCTION! DO NOT LOOSE IT!\n*/\nvoid Transform(inout vec3 p) {\n    p *= RotationY(iTime);\n}\n\n/*\n    Distance estimator for heightmap\n    Took me some time, but I was able to figure out how to get a distance function\n    \n    MATH ON HOW IT WORKS:\n    (there's some notation errors in the image, where I swapped out p.z or b.y with p.x and b.x respectively)\n    (Too lazy to fix it and upload it again, maybe in the future)\n    https://i.imgur.com/0Shiq0g.jpg\n    \n    \n    DESCRIPTION ON HOW IT WORKS:\n    takes distance as if it were a box.\n    The Y distance however, also subtracts the distance of the heightmap\n    Calculating the rest like a box does the trick\n    \n    So many thanks to IQ and specifically this video that he made:\n    https://youtu.be/62-pRVZuS5c\n\n*/\n\nconst float upperBound = 2.0;\nconst float g = sin(atan(1.,upperBound));\n\nfloat sdHeightMap(vec3 p, vec3 b) {\n\n  vec3 q = abs(p) - b;\n  \n  vec2 uv = vec2(min(p.x,b.x),min(p.z,b.z));\n  \n  // iChannel0 can technically be replaced with any black-white image\n  float h = luminance(texture(iChannel0,uv).rgb);\n  h *= HEIGHT_FACTOR;\n  \n  q.y -= h;\n  q.y *= g;\n  \n  q.x = max(0.0,q.x);\n  q.y = max(0.0,q.y);\n  q.z = max(0.0,q.z);\n  \n  float dist = length(q);\n  \n  return dist;\n}\n\nfloat Scene(vec3 ray) {\n    // Transform around the origin\n    Transform(ray);\n    \n    float sd = 1.0;\n    float heightmap = sdHeightMap(ray,vec3(1.0,0.1,1.0));\n   \n    sd = min(sd,heightmap);\n    return sd;\n}\n\n//RayMarching scene\nfloat rayMarch(Ray o, inout int dist) {\n    vec3 ray;\n    float sd,d;\n  \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n        ray = o.ori + (o.dir * d);\n        sd = Scene(ray);\n        \n        if(sd < EPSILON) {\n            dist = i;\n            return d;\n        }\n        d += sd;\n        \n        if(d > MAX_DISTANCE) break;\n    }\n}\n\n// Various shaders for beautifying the scene\nvec3 Normal(vec3 p) {\n    float d0 = Scene(p);\n    \n    float dX = Scene(p - vec3(NORMAL_EPSILON,0.0,0.0));\n    float dY = Scene(p - vec3(0.0,NORMAL_EPSILON,0.0));\n    float dZ = Scene(p - vec3(0.0,0.0,NORMAL_EPSILON));\n    \n    vec3 r = vec3(d0 - dX, d0 - dY, d0 - dZ);\n    \n    return normalize(r);\n}\n\n// This was again, an artifact of old horrible code.\nvec3 AmbientOcclusion(vec3 p, int complexity) {\n\n    return vec3(0.0);\n}\n\nvec3 Sky(Ray light,vec3 skycolor,vec3 basecol) {    \n    float ray = dot(light.ori,light.dir);\n    return (skycolor * ray) + basecol;\n}\n\n#ifndef DEBUG\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Set (0,0) to the center of the screen\n    uv = (uv * 2.0 - 1.0)/2.0;\n    \n    // Apply aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    // Setting up 3D space\n    vec3 xyz = normalize(vec3(uv,1.0));\n    float fovrange = tan(radians(FOV*.5));\n    xyz *= fovrange;\n\n    // Setting up camera\n    Ray camera;\n    \n    camera.ori = vec3(1.5,1.5,0.0);\n    #ifndef FREE_CAMERA\n    camera.dir = vec3(0.9,-1.57,0.0);\n    #else\n    camera.dir = vec3(-radians(iMouse.y)+PI/2.0,-radians(iMouse.x),0.0);\n    #endif\n    \n    // Transforming 3D space to camera space\n    xyz *= RotationX(camera.dir.x) * RotationY(camera.dir.y) * RotationZ(camera.dir.z);\n    \n    // Setting up the raymarch\n    Ray rendered;\n    rendered.ori = camera.ori;\n    rendered.dir = xyz;\n    \n    // Applying raymarch\n    int dist;\n    float ray = rayMarch(rendered,dist);\n    rendered.dir *= ray;\n    rendered.ori += rendered.dir;\n    \n    //Correct UV coords to transform with the image\n    vec3 textuv = rendered.ori;\n    Transform(textuv);\n    \n    // Applying appropriate colors\n    vec3 flatcol = vec3(texture(iChannel0,textuv.xz).r);\n    flatcol *= vec3(1.0,1.0,0.6);\n    \n    // Fog applied to image\n    float fogFactor = clamp(0.0,1.0,ray * 0.1);\n    vec3 fogcol = vec3(0.2);\n    flatcol = mix(flatcol,fogcol,fogFactor);\n    \n    // Set up lights\n    Ray skylight;\n    skylight.ori = xyz;\n    skylight.dir = vec3(-0.5,-1.0,0.0);\n    skylight.dir = normalize(skylight.dir);\n    vec3 lightcol = vec3(0.5,0.6,0.9);\n    vec3 baselight = vec3(0.3,0.3,0.6);\n    \n    // Creating normals of scene for some nice lighting\n    vec3 normal = Normal(rendered.ori);\n    \n    // Apply diffuse lighting\n    float diffuse = dot(-skylight.dir,normal);\n    \n    flatcol *= diffuse;\n    \n    // Apply specular ligting\n    vec3 reflected = reflect(skylight.dir,normal);\n    float specular = dot(-skylight.dir,reflected);\n    float specularpower = 50.0; //the higher the number the less spread out the light is\n    float specularstrength = 0.2;\n    specular = pow(specular,specularpower);\n    specular *= specularstrength;\n    \n    // For some reason if the specular value goes up too high, it turns black.\n    // Could be floating point overflow, but for now this is the work around\n    specular = (specular < 50.0) ? specular : 0.0;\n    \n    flatcol += specular;\n    //flatcol = vec3(specular);\n    \n    // Sky lighting applied\n    if(ray < 1.0) {\n        flatcol = Sky(skylight,lightcol,baselight);\n    }\n    \n    // Output to screen\n    fragColor = vec4(flatcol,1.0);\n}\n#else \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    float h = luminance(col);\n    h *= -1.0;\n    h += 0.5;\n    \n    fragColor = vec4(vec3(h),1.0);\n    \n}\n#endif", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 429, 429, 488], [535, 535, 567, 567, 719], [721, 721, 753, 753, 906], [908, 908, 940, 940, 1092], [1094, 1360, 1390, 1390, 1419], [2177, 2177, 2212, 2212, 2574], [2576, 2576, 2599, 2634, 2786], [2788, 2808, 2847, 2847, 3142], [3144, 3189, 3210, 3210, 3491], [3493, 3546, 3593, 3593, 3618], [3620, 3620, 3668, 3668, 3755]], "test": "untested"}
{"id": "fdGSWt", "name": "Abstract Planes Fragmented", "author": "aiekick", "description": "Abstract Planes Fragmented", "tags": ["abstract", "planes", "fragmented"], "likes": 14, "viewed": 334, "published": 3, "date": "1635454426", "time_retrieved": "2024-07-30T18:52:19.256145", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via Noodlesplate (https://github.com/aiekick/NoodlesPlate)\n\nconst vec3 uColor0 = vec3(0.2,0.8,0.3);\nconst vec3 uColor1 = vec3(0.8,0.2,0.37);\n\nmat3 rotx(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 roty(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 rotz(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nmat3 m1;\nmat3 m2;\n\nvec3 path(vec3 p)\n{\n\tp.xy += cos(iTime * 0.1);\n\tp *= rotz(p.z * 0.2);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= rotz(p.z * 0.2);\n    p = sin(p.zxy * 0.1) * 2.;\n    return p;\n}\n\nfloat pattern(vec3 p)\n{\n\tp = abs(fract(p*.3) - 0.5);\n\treturn length(max(abs(p.x), abs(p.y)) - p.z);\n}\n\nfloat sdf(vec3 p)\n{\n\tp += path(p);\n\tp *= rotz(p.z * 0.045);\n\tvec2 q = mod(p.xz, 3.0) - 1.5;\n\tvec3 qm1 = p*m1, qm2 = p*m2;\n\tfloat d0 = min(pattern(qm1), pattern(qm2));\n    float d1 = min(pattern(qm1*3.), pattern(qm2*2.));\n   \tfloat dist0 = (1.-clamp(d0,0.,1.));\n\tfloat dist1 = (1.-clamp(d1,0.,1.))*d0;\n\tfloat sp = 1. - cos(p.z * 1.5) * 0.1 - abs(p.y) + dist0*0.75 + dist1*2.25;\n\tp.xz = mod(p.xz, 1.5) - 0.75;\n\tfloat ct = (cos(iTime * 0.5) * 0.5 + 0.5) * 2.0;\n\tfloat st = (sin(iTime * 0.5) * 0.5 + 0.5) * 2.0;\n\tfloat bo = length(max(abs(p) - vec3(ct,1000.0,st), 0.0)) - 0.1;\n\t\n\treturn max(bo,sp);\n}\n\nfloat mat(vec3 p)\n{\n\tp += path(p);\n\tp *= rotz(p.z * 0.045);\n\tvec2 q = mod(p.xz, 3.0) - 1.5;\n\tvec3 qm1 = p*m1, qm2 = p*m2;\n\tfloat d0 = min(pattern(qm1), pattern(qm2));\n    float d1 = min(pattern(qm1*3.), pattern(qm2*2.));\n   \tfloat dist0 = (1.-clamp(d0,0.,1.));\n\tfloat dist1 = (1.-clamp(d1,0.,1.))*d0;\n\tfloat sp = 1. - cos(p.z * 1.5) * 0.1 - abs(p.y) + dist0*0.75 + dist1*2.25;\n\tp.xz = mod(p.xz, 1.5) - 0.75;\n\tfloat ct = (cos(iTime * 0.5) * 0.5 + 0.5) * 2.0;\n\tfloat st = (sin(iTime * 0.5) * 0.5 + 0.5) * 2.0;\n\tfloat bo = length(max(abs(p) - vec3(ct,1000.0,st), 0.0)) - 0.1;\n\t\n\tif (bo > sp)\n\t{\n\t\treturn 1.0;\n\t}\n\treturn 0.0;\n}\n\nvec3 nor(vec3 p, float epsilon)\n{\n\tvec3 eps = vec3(epsilon, 0., 0.);\n\tvec3 nor = vec3(\n\t\tsdf(p + eps.xyy) - sdf(p - eps.xyy),\n\t\tsdf(p + eps.yxy) - sdf(p - eps.yxy),\n\t\tsdf(p + eps.yyx) - sdf(p - eps.yyx));\n\treturn normalize(nor);\n}\n\nfloat getSha( in vec3 ro, in vec3 rd, in float hn) // iq code\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = sdf(ro + rd*t);\n        res = min( res, hn*h/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nfloat getAO( in vec3 p, in vec3 nor ) // iq code\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float(i)/4.0;\n        vec3 aopos =  nor * hr + p;\n        float dd = sdf( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ) // from shane\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf) // from shane\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m;\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(0);\n\t\n\tvec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\t\n\tfloat ca = 3.0;\n    float ce = 8.0;\n    float cd = 20.0;\n\tfloat maxd = 1000.0;\n\t\n\tca = iMouse.x / iResolution.x * 6.28318;\n\tce = iMouse.y / iResolution.y * 30.0;\n\t\n    vec3 ro = vec3(0,0, iTime * 6.); \n\tro -= path(ro);\n\tvec3 cv = ro + vec3(0,0,4); \n\tcv -= path(cv);\n\tvec3 lp = ro + vec3(0,0,3);\n    lp -= path(lp);\n\t\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(uv.x * x + uv.y * y + z);\n\t\n\tmat3 mx = rotx(-7.);\n\tmat3 my = roty(-5.);\n\tmat3 mz = rotz(-3.);\n\t\n    m1 = mx * my * mz;\n    m2 = m1 * m1;\n\t\n\tfloat d = 0.0, s = 1.0;\n\tfor (float i = 0.0; i < 500.0; i++)\n\t{\n\t\tif (log(d/1e7) > 0.0 || d > maxd) break;\n\t\ts = sdf(ro + rd * d);\n\t\td += s * 1.0;\n\t}\n\t\n\tfloat fog = 1.0-exp( -0.001*d*d );\n\t\t\n\tif (d < maxd)\n\t{\n\t\tvec3 p = ro + rd * d;\n\t\tvec3 n = nor(p, 0.01);\n\t\t\n\t\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t\n\t\t\n\t\tfloat mt = mat(p);\n\t\t\n\t\tvec4 col = vec4(0);\t\t\t\t\t\t\t\t\t\n\t\t\t\n\t\tif (mt < 0.5) // top\n\t\t{\n\t\t\tn = doBumpMap(iChannel1, -p*0.5, n, 0.018);\n\t\t\tvec3 refl = reflect(rd,n);\n\t\t\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\t\t\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. );\n\t\t\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\n\t\t\tfloat sha = 0.5 + 0.5 * getSha(p, n, 2.0);\n\t\t\tfloat ao = getAO(p, n);\n\t\t\tfragColor = vec4(\n\t\t\t\t(diff + fre) * 0.8 + diff * ao,\n\t\t\t\t(diff + fre) * uColor1 + spe * sha\n\t\t\t) * 1.0;\n\t\t}\n\t\telse // wall\n\t\t{\n\t\t\tn = doBumpMap(iChannel0, -p*0.5, n, 0.1);\n\t\t\tvec3 refl = reflect(rd,n);\n\t\t\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\t\t\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\n\t\t\tfloat sha = 0.5 + 0.5 * getSha(p, n, 2.0);\n\t\t\tfloat ao = getAO(p, n);\n    \n\t\t\tfragColor = vec4(uColor0 * ao + spe * sha, 1);\n\t\t}\n\n\t\tfragColor = fragColor.zyww + fragColor.x*0.1;\n\t}\n\t\n\tfragColor = mix( fragColor, vec4(0), fog);\n       \n\tfragColor = mix(fragColor, fragColor.grba, sin(fog*3.));\n   \tfragColor = sqrt(fragColor*fragColor*fragColor*1.5);\n\t\n\t// vigneting from iq\n    vec2 q = fragCoord/iResolution.xy;\n    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 1.0 );\n\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGSWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[289, 289, 308, 308, 366], [367, 367, 386, 386, 444], [445, 445, 464, 464, 522], [543, 543, 562, 562, 715], [717, 717, 740, 740, 818], [820, 820, 839, 839, 1416], [1418, 1418, 1437, 1437, 2041], [2043, 2043, 2076, 2076, 2273], [2275, 2275, 2338, 2338, 2564], [2567, 2567, 2617, 2617, 2914], [2916, 2916, 2981, 2981, 3155], [3158, 3158, 3235, 3235, 3531], [3533, 3533, 3589, 3589, 5802]], "test": "untested"}
{"id": "7dVXDc", "name": "Aliasing on moving edge", "author": "ap", "description": "Aliasing on moving edge", "tags": ["aliasing"], "likes": 1, "viewed": 183, "published": 3, "date": "1635452291", "time_retrieved": "2024-07-30T18:52:20.099889", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    float pi = 3.14159;\n    float angle = pi * 0.02;\n    float slope = tan(angle);\n    \n    float yoffset = iResolution.y * 0.5 + 30.0 * sin(iTime * 0.25);\n    \n    float scale = 8.0;\n    vec2 coord = floor(fragCoord / scale) * scale;\n    \n    if(((coord.y - yoffset)/(coord.x - 0.0)) < slope)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 718]], "test": "untested"}
{"id": "ssVXWc", "name": "color-stuff red-blue mash", "author": "bigbadbob234", "description": "still trying to make pixel-outputs (blue, a fixed wavelength, can't rly change physics) feel more-blue-than blue.", "tags": ["colors", "colorshift", "newcolors", "exploringcolor"], "likes": 3, "viewed": 131, "published": 3, "date": "1635446503", "time_retrieved": "2024-07-30T18:52:20.861852", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co*iTime, vec2(12.9898, 78.233))) * 43758.5453);\n}\n    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 uv = fragCoord;\n    \n    float t = iTime * 3.;\n    float k = 2.;\n    float doodle = t; //(t*3.+sin(t*.75)*.5+sin(t*.33)*.25+sin(t*.25)*.125);\n    //float a = .5 + .5*cos(doodle + uv.x - (uv.x*floor(uv.x/k)) + uv.y - (uv.y*floor(uv.y/k)));\n    float a = cos(uv.x*.55)*(doodle)*.2 + sin(uv.y*3.14)*1.+cos(uv.y*.01); \n    a = a-floor(a);\n    float b1 = (t-floor(t));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = (exp(h)/2.718*2.-1.);\n    \n       \n    //vec3 midcol = vec3(1.,1.,1.);\n    //vec3 cola = mix(vec3(1.,.0,1.), vec3(1.,0.,0.), h2);\n    //vec3 colb = mix(vec3(0.,1.,1.), vec3(0.,.5,1.), h2);\n\n    //vec3 cola = mix(vec3(2.,.0,.0), vec3(0.,1.,2.), h);\n    //vec3 colb = mix(vec3(1.,1.,1.), vec3(0.,.0,2.), h2);\n    //vec3 col = mix(cola, colb, h);\n    \n    float rval = rand(fragCoord);\n    vec3 cola = mix(vec3(1.-h2,0,1.-rval), vec3(0,0,1), h);\n    vec3 colb = mix(vec3(1.-h2,0.-2.,0), vec3(.5-rval,rval*h2,2.*h2+rval), h);\n    vec3 col = mix(cola, colb, h);\n\n    //vec3 cola = mix(vec3(.3,0,1), vec3(1,1,0), h);\n    //vec3 colb = mix(vec3(1,.3,0), vec3(0,.5,2), h);\n    //vec3 col = mix(cola, colb, (h2));\n    \n    \n    //vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 97], [108, 108, 165, 257, 1640]], "test": "untested"}
{"id": "ssKSWc", "name": "color experience - iridescent", "author": "bigbadbob234", "description": "iridescence", "tags": ["colors", "colorshift", "shepardtone", "russellbeat", "inventing", "newcolors"], "likes": 2, "viewed": 157, "published": 3, "date": "1635442697", "time_retrieved": "2024-07-30T18:52:21.651740", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 uv = fragCoord;\n    \n    float t = iTime * 15.;\n    float k = 2.;\n    float doodle = t; //(t*3.+sin(t*.75)*.5+sin(t*.33)*.25+sin(t*.25)*.125);\n    //float a = .5 + .5*cos(doodle + uv.x - (uv.x*floor(uv.x/k)) + uv.y - (uv.y*floor(uv.y/k)));\n    float a = cos(uv.x*.1)*(doodle)*.2 + sin(uv.y*3.1415)*.1+cos(uv.y*.01); \n    a = a-floor(a);\n    float b1 = (t-floor(t));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = exp(h)/2.718;\n    \n       \n    //vec3 midcol = vec3(1.,1.,1.);\n    //vec3 cola = mix(vec3(1.,.0,1.), vec3(1.,0.,0.), h2);\n    //vec3 colb = mix(vec3(0.,1.,1.), vec3(0.,.5,1.), h2);\n\n    //vec3 cola = mix(vec3(2.,.0,.0), vec3(0.,1.,2.), h);\n    //vec3 colb = mix(vec3(1.,1.,1.), vec3(0.,.0,2.), h2);\n    //vec3 col = mix(cola, colb, h);\n    \n    vec3 cola = mix(vec3(2,1,1), vec3(-2,0,1), h);\n    vec3 colb = mix(vec3(1,-.5,0), vec3(0,1,5), h);\n    vec3 col = mix(cola, colb, h2);\n\n    //vec3 cola = mix(vec3(.3,0,1), vec3(1,1,0), h);\n    //vec3 colb = mix(vec3(1,.3,0), vec3(0,.5,2), h);\n    //vec3 col = mix(cola, colb, (h2));\n    \n    \n    //vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 150, 1458]], "test": "untested"}
{"id": "7sVXD3", "name": "testing CubeMaps indexing", "author": "FabriceNeyret2", "description": "I was worrying about precise access to CubeMaps pixels center, but it does work.", "tags": ["cubemaps"], "likes": 3, "viewed": 302, "published": 3, "date": "1635438529", "time_retrieved": "2024-07-30T18:52:22.408716", "image_code": "\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = vec2(1024);\n    \n    O = C(U,0);      // access to pixels center of  cubemap face 1, LOD 0\n    \n    if ( length(U-.5*iResolution.xy)<30.) O = C(511.5,0); // check central pixel\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 d )\n{\n    if ( max(d.x, max(d.y,d.z)) != d.z ) return; // we want only face 1 \n    \n    O.xy = mod(U-.5,2.);             // strips every 2 lines/columns\n    \n    if (U==vec2(511.5)) O = vec4(1); // set central pixel\n\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// access to cubemap face 1 , LOD n\n#define C(U,n) texture(iChannel0, vec3(2.*(U)/R-1.,1)*vec3(1,-1,1), float(n) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 231]], "test": "untested"}
{"id": "7sKXW3", "name": "caustics but boring", "author": "Arrangemonk", "description": "pebble texture based caustics may be less taxing than voroni but to know that i actually had to use benchmarks\n", "tags": ["caustics"], "likes": 9, "viewed": 352, "published": 3, "date": "1635434354", "time_retrieved": "2024-07-30T18:52:23.213564", "image_code": "#define tau 6.28318530718\n#define pi 3.141592653589\n\n//i was too lazy to wobble on my own\n//https://www.shadertoy.com/view/WsKXzz\n\nfloat wobble(float p, float amplitude, float frequence, float speed,float time)\n{\n    return amplitude * sin(p * frequence + time * speed);\n}\n\nvec2 wobble2d(vec2 uv, float a, float f, float s,float time)\n{\n    return vec2(wobble(uv.y, a, f, s,time), wobble(uv.x, a, f, s,time + pi*.5));\n}\n\nfloat caustics(vec2 uv,float time,sampler2D tex)\n{\n    vec2 uv1 = uv + wobble2d(uv, .1, 2., 2.,time);\n    float c1 =1.-texture(tex,uv1).r;\n    vec2 uv2 = .5 *uv + .5*wobble2d(uv, .1, 2., 2.,time*.5);\n    float c2 =1.-texture(iChannel0,uv2).r;\n    return pow((c1 +c2) *.5,8.)*2.;\n}\n\nfloat causticsRec(vec2 uv,float time,sampler2D tex)\n{\n    float mid1 = caustics(1.-uv*.5 +time * .01,time *.5,tex);\n    float mid2 = caustics(1.+uv*.5 +time * .01,time *.5,tex);\n    vec2 mid  = mix(uv,vec2(mid1,mid2),.28);\n    return caustics(mid+time * .01 ,time + mid1,tex);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = fragCoord.xy / iResolution.xx ;\n    uv = uv *2.;\n\n    \n    float c = causticsRec(uv,iTime,iChannel0);\n    \n    c = (sqrt(c) + c)/ 2.;\n    \n    vec3 col = vec3(.1,.4,.8);\n    col +=.25;\n    col *= texture(iChannel1, uv*.5 + wobble2d(uv, .004, 8., 2., iTime)).xyz;\n    \n    vec3 foam = mix(vec3(0),texture(iChannel2,uv *.5  + wobble2d(-uv, .05, 8., 2., iTime)).xxx,c);\n\t\n    fragColor = vec4(col + foam,1);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 212, 212, 272], [274, 274, 336, 336, 419], [421, 421, 471, 471, 701], [703, 703, 756, 756, 981], [984, 984, 1041, 1041, 1464]], "test": "untested"}
{"id": "NsKXWc", "name": "multigrid diffusion booster", "author": "FabriceNeyret2", "description": "solving Laplacian(V) = 0 ( e.g. for heat diffusion ) takes foreever.\nMultigrid approach solves this at corse, then thinner and thinner resolution.\nAs usual, hierarchical requires power-of-2 textures, thus the cubeMap.\nPaint dot, rewind to see multigrid ac", "tags": ["diffusion", "solver", "multigrid"], "likes": 9, "viewed": 418, "published": 3, "date": "1635428844", "time_retrieved": "2024-07-30T18:52:24.048332", "image_code": "// Must paint in cubeMap face for power of 2 hierarchy\n// I still map the result on screen, thus the mouse distortion.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O = C(U,0);        // access to cubemap face 1, LOD 0\n // O = sin(100.*O);   // debug: display isovalues\n // float f = sin(100.*O.r); O = mix(O,vec4(1,0,0,0),smoothstep(1.5,0.,abs(f)/fwidth(f)));// debug variant\n\n    O = sqrt(O);       // to sRGB\n   \n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "#define T(U,x,y,n)   C( U + vec2(x,y), n )\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 d )\n{\n    if ( max(d.x, max(d.y,d.z)) != d.z ) return; // we want only face 1 \n    \n    //U -= .5;\n    if (iFrame==0) { O = vec4(0); return; }\n    vec2 R = iResolution.xy, I;\n                                                // --- set multigrid LOD\n  //int n = max(0, int( log2(R.y) -4. - log2(float(1+iFrame/60/2)) ));\n    int n = max(0, int( log2(R.y) -2. - float(iFrame/60) )); // what is optimum duration per level ?\n  //n = 3;\n    U =       U / float(1<<n); I = floor(U);\n    R = floor(R / float(1<<n));\n    \n    O = T(U,0,0, n);                            \n                                                // --- Laplacian solver. \n // vec4 D = (   T(U,1,0,n) + T(U,-1,0,n) + T(U,0, 1,n) + T(U, 0,-1,n) - 4.*O ) / 4.;\n // vec4 D = (   T(U,1,0,n) + T(U,-1,0,n) + T(U,0, 1,n) + T(U, 0,-1,n) // higher orders: https://en.wikipedia.org/wiki/Discrete_Laplace_operator\n //            + T(U,1,1,n) + T(U,-1,1,n) + T(U,1,-1,n) + T(U,-1,-1,n)\n //             - 8.*O ) / 8.;\n    vec4 D = ( 2.*( T(U,1,0,n) + T(U,-1,0,n) + T(U,0, 1,n) + T(U, 0,-1,n) )\n               +    T(U,1,1,n) + T(U,-1,1,n) + T(U,1,-1,n) + T(U,-1,-1,n)\n               - 12.*O ) / 12.;\n    O += D;  // apparently stable even with coef 1\n    \n                                                // --- set border constraints\n#if 0\n    O =  I.y==0. || I.y==R.y-1. ? vec4(I.x/(R.x-1.)) \n       : I.x==0. ? vec4(0) : I.x==R.x-1. ? vec4(1)\n       : O;\n#else\n    O =  I.x==0. ? vec4(1,0,0,1) : I.x==R.x-1. ? vec4(0,1,0,1)\n       : I.y==0. ? vec4(0,0,1,1) : I.y==R.y-1. ? vec4(1,1,1,1)\n       : O;\n#endif\n                                                // --- mouse paint\n    vec2 M = texelFetch(iChannel1,ivec2(0),0).xy;   // get normalized mouse position\n    if ( length(M)>.1 && length(I/R-M)<.1) O = vec4(I.x/R.x > M.x);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// access to cubemap face 1 , LOD n\n#define C(U,n) texture(iChannel0, vec3(clamp(2.*(U)/R-1.,-1.+1./R,1.-1./R),1)*vec3(1,-1,1), float(n) )\n//#define C(U,n) texture(iChannel0, vec3(2.*(U)/R-1.,1)*vec3(1,-1,1), float(n) )", "buffer_a_code": "// can't normalize iMouse in cubeMap, so this Buffer provides it\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = iMouse;\n    O.xy /= iResolution.xy;\n    O.zw /= iResolution.xy;\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 158, 158, 444]], "test": "untested"}
{"id": "fsVXD3", "name": "HypnoThing '79", "author": "hjd3481", "description": "Creates a photon-sieve-like pattern, and then I animated it... and then messed with a old' school VFX shown on a CRT kinda effect. \nFullscreen reccomended. \nMess with the pixel-size via \"pixelZoom\" or set ABS_RESOLUTION 0 and define a fixed numLines", "tags": ["circles", "retro", "tv", "crt", "trig"], "likes": 19, "viewed": 503, "published": 3, "date": "1635425078", "time_retrieved": "2024-07-30T18:52:25.019735", "image_code": "#define ABS_RESOLUTION 0\n///////////////////////////////////////////////////\n\n//ABS_RESOLUTION\nconst float numLines = 480.0;\nconst float numHoriz = numLines*1.66;\n\n// fixed pixel-size\nconst float pixelZoom = 0.1;\n\n///////////////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n#if ABS_RESOLUTION\n    //fixed number of pixels\n    vec2 pixels = vec2( numHoriz, numLines );\n#else\n    //resolution-independant pixel-size\n    vec2 pixels = vec2(iResolution) * vec2(pixelZoom);\n#endif //ABS_RESOLUTION\n    \n    //unit UVs   \n    vec2 uv= fragCoord/iResolution.xy;\n\n    //get background 'tv signal' texture.\n    vec2 tvuv = uv;\n    \n    //quantize vertical lines for 'pixellated' image\n    tvuv.y = floor(tvuv.y * pixels.y) / pixels.y;\n\n    vec3 signal = texture(iChannel0,tvuv).rgb;\n\n    //the 'TV' picture\n    vec3 col = signal; \n\n    //noise\n    col =  mix( col + 0.5, col * 0.8, hash12(fragCoord + iTime));\n        \n    //two lines is one wavelength ( -1 +1 )\n    float lineUpDown = sin(PI*pixels.y*uv.y);  \n        \n    //abs to get 'arches' +1 +1\n    float scanlines = abs(lineUpDown);         \n    \n    //brick pattern ( offset based on alternating line )\n    float bricker = fract(uv.x*pixels.x + sign(lineUpDown)*0.25); \n    \n    //the horizontal pixel border\n    float pixelMaskX = abs( sin(PI*bricker) );\n    \n    vec3 preMask = col;\n    \n    //darken by pixel-border mask\n    col *= pixelMaskX * scanlines; \n           \n    //create the 3 red, green and blue phosphor masks. \n    vec3 shiftRGB = vec3(0.0,1.0,2.0); \n    vec3 barsRGB = abs(sin( PI * clamp( bricker * 3.0 - shiftRGB, 0.0, 1.0) ));\n    vec3 rgbMask = barsRGB * vec3(1.1, 0.6, 1.2); //balance channels / colours\n    \n    //add non-rgb-filtered back in for better white-values and a bit of a 'glow'\n    col *= rgbMask + (preMask * 0.5); \n    \n    col *= 1.33; //overall brighten  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n///////////////////////////////////////////////////", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 Rotate( in vec2 v, in float t )\n{\n     return  v.x * vec2( sin(t), cos(t) ) + v.y * vec2( -cos(t), sin(t) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n       \n    vec2 uv = (fragCoord)/ iResolution.xy; \n\n    //save off the passthough uvs for previous-frame lookup per frag\n    vec2 uvPass = uv;\n    \n    //get (0,0) in centre\n    uv.xy -= 0.5f;\n    \n    //make -1 : +1\n    uv.xy *= 2.0f;\n    \n    //get a square aspect\n    uv.x *= (iResolution.x/iResolution.y);\n   \n    //Make some holes\n    float i =  0.0f;\n   \n    const float radA = 0.06;\n    const float radB = 0.01;\n   \n    const int numRings = 16;\n    const float recipRing = 1.0f / float(numRings-1);\n    for(int iRing=0; iRing < numRings; ++iRing)\n    {\n        float unitRing = float(iRing) * recipRing;\n           \n        int numHoles = int( mix(1.0, 45.0, unitRing ));\n        float recipHole = 1.0f/float(numHoles);\n\n        for( int iHole=0; iHole < numHoles; ++iHole)\n        {\n            float unitHole = float(iHole)*recipHole;\n    \n            float holeRad = mix( radB, radA, 1.0f-unitRing ); //per hole for per hole randomniess inside the ring\n\n            vec2 p = vec2(0);\n\n            float ringRadius = ((1.0f-((1.0f-unitRing)*(1.0f-unitRing)))) * 0.95;\n                        \n            //shift the angle based on time and ring index\n            unitHole += (float(iRing)-float(numRings/3)) * 0.97131212 * iTime * 0.01;\n\n            p = vec2( sin(unitHole*TWOPI), cos(unitHole*TWOPI)) * ringRadius;\n\n            float d = distance( p, uv );        \n\n            i += smoothstep( holeRad+0.005, holeRad-0.005, d );\n\n        }\n    }\n    \n    vec3 col = vec3(i);\n  \n        \n    //get some coloured dots around the main holes ( easily modified to do chromatic blur etc. )        \n    vec3 bl = vec3(0.0);\n        \n    float rT = iTime * 0.91;\n    const float sz = 0.013;\n    bl += texture( iChannel0, uvPass + Rotate(vec2(-sz,0.0f),rT)).rgb * vec3(1.0,0.01,0.0);    \n    bl += texture( iChannel0, uvPass + Rotate(vec2(sz,0.0f),rT)).rgb * vec3(0.8,0.7,0.0);    \n    bl += texture( iChannel0, uvPass + Rotate(vec2(0.0f,-sz),rT)).rgb * vec3(0.02,1.0,0.0);    \n    bl += texture( iChannel0, uvPass + Rotate(vec2(0.0f,sz),rT)).rgb * vec3(0.0,0.05,1.2);\n       \n    col += (bl*0.095) ;\n  \n    \n    //scale&fade\n    vec3 prev = texture( iChannel0, ((uvPass-0.5)*1.01)+0.5 ).rgb;    \n    col += prev*0.62;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926535897932384626433832795\n#define TWOPI 6.283185307179586476925286766559", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 411, 433, 433, 550], [605, 605, 662, 662, 2300]], "test": "untested"}
{"id": "fdVXWc", "name": "Knot Curves 3", "author": "dr2", "description": "Visualize series of parametric knot curves (updated - see source)", "tags": ["knot"], "likes": 9, "viewed": 274, "published": 3, "date": "1635424793", "time_retrieved": "2024-07-30T18:52:25.806631", "image_code": "// \"Knot Curves 3\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Cycle through 11 simple parametric knot curves (as in \"Knot Curves 2\").\n  Alternating tube and moving ball visualization.\n  Moving helical colors for tube.\n  Mouse near left/right edges overrides auto cycle.\n  Mouse near right edge, or in bottom window half, shows tube instead of balls.\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, knc[7], kns[7], qnHit;\nfloat dstFar, tCur, nSeg, sclFac, qCol;\nint knType;\nbool showBalls;\nconst float nKnot = 11.;\nconst float pi = 3.1415927;\n\nvec3 KtPoint (float a)\n{\n  vec3 r;\n  vec2 cs;\n  if (showBalls) a += mod (-0.2 * tCur, 2. * pi);\n  r = vec3 (0.);\n  for (int k = 0; k < 7; k ++) {\n    cs = sin (float (k + 1) * a + vec2 (0.5 * pi, 0.));\n    r += knc[k] * cs.x + kns[k] * cs.y;\n  }\n  return sclFac * r;\n}\n\nfloat SphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      qnHit = (ro + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, sMin;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      sMin = s;\n      qnHit = vec3 (s.xy, 0.);\n    } else {\n      drz = - len * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          s = ro + d * rd;\n          dMin = d;\n          sMin = s;\n          sMin.z -= drz;\n          qnHit = s;\n        }\n      }        \n    }\n  }\n  return vec4 (sMin, dMin);\n}\n\nmat3 EvalRMat (vec3 r, vec3 rp, vec3 rm)\n{\n  vec3 ddr, vt, vn;\n  vt = normalize (rp - rm);\n  ddr = rp + rm - 2. * r;\n  vn = normalize (ddr - vt * dot (vt, ddr));\n  return mat3 (vt, vn, cross (vt, vn));\n}\n\n#define NSEG_MAX  512.  // for tube: larger values, better but slower\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatS;\n  vec4 ds4Min, ds4;\n  vec3 r, rp, qnHitS, qTube;\n  float dMin, d, dAng, eAng, len, jHit;\n  dAng = 2. * pi / nSeg;\n  dMin = dstFar;\n  if (! showBalls) {\n    ds4Min = vec4 (0., 0., 0., dMin);\n    eAng = 0.5 * dAng;\n  }\n  r = KtPoint (2. * pi - dAng);\n  for (float j = float (VAR_ZERO); j < NSEG_MAX; j ++) {\n    if (j == nSeg) break;\n    rp = r;\n    r = KtPoint (j * dAng);\n    if (showBalls) {\n      d = SphHit (ro - r, rd, 0.1);\n      if (d < dMin) {\n        dMin = d;\n        qnHitS = qnHit;\n        jHit = j;\n      }\n    } else {\n      rMat = EvalRMat (r, KtPoint (j * dAng + eAng), KtPoint (j * dAng - eAng));\n      len = 0.5 * length (r - rp);\n      ds4 = CapsHit (((ro - r) * rMat).yzx, (rd * rMat).yzx, 0.1, len);\n      if (ds4.w < ds4Min.w) {\n        ds4Min = ds4;\n        ds4Min.z /= len;\n        qnHitS = qnHit;\n        rMatS = rMat;\n        jHit = j;\n      }\n    }\n  }\n  if (showBalls) {\n    if (dMin < dstFar) {\n      qCol = 4. * jHit / nSeg;\n      qnHit = qnHitS;\n    }\n  } else {\n    if (ds4Min.w < dstFar) {\n      dMin = ds4Min.w;\n      qnHit = rMatS * normalize (qnHitS.zxy);\n      qTube = ds4Min.xyz;\n      qCol = 4. * (jHit + qTube.z + 0.5) / nSeg + atan (qTube.y, - qTube.x) / (2. * pi) +\n         0.2 * tCur;\n    }\n  }\n  return dMin;\n}\n\n// Knot parametrizations from A.K. Trautwein thesis (University of Iowa, 1995) (many more)\n\nvoid KtSetup ()\n{\n  for (int k = 0; k < 7; k ++) {\n    knc[k] = vec3 (0);  kns[k] = vec3 (0);\n  }\n  if (knType == 1) {  // 3.1 trefoil knot\n     knc[0] = vec3 ( 41,   36,   0);   kns[0] = vec3 (-18,   27,   45);\n     knc[1] = vec3 (-83, -113,  -30);  kns[1] = vec3 (-83,   30,  113);\n     knc[2] = vec3 (-11,   11,  -11);  kns[2] = vec3 ( 27,  -27,   27);\n     sclFac = 0.015;\n  } else if (knType == 2) {  // 4.1 figure 8 knot\n     knc[0] = vec3 (  32,   94,   16);  kns[0] = vec3 (-51,   41,   73);\n     knc[1] = vec3 (-104,  113, -211);  kns[1] = vec3 (-34,    0,  -39);\n     knc[2] = vec3 ( 104,  -68,  -99);  kns[2] = vec3 (-91, -124,  -21);\n     sclFac = 0.008;\n  } else if (knType == 3) {  // 5.1 knot\n     knc[0] = vec3 (  88,   89,   44);  kns[0] = vec3 ( 115,  -32,  -69);\n     knc[1] = vec3 (-475, -172,   34);  kns[1] = vec3 (-127,  294,  223);\n     knc[2] = vec3 ( -87,   76,   16);  kns[2] = vec3 (  36,  102,  120);\n     knc[3] = vec3 (  11,  -61,   42);  kns[3] = vec3 ( -19,  113, -125);\n     sclFac = 0.0045;\n  } else if (knType == 4) {  // 5.2 knot\n     knc[0] = vec3 ( -33,  -57,   34);  kns[0] = vec3 ( 43,   99, -21);\n     knc[1] = vec3 (   0,  -54, -100);  kns[1] = vec3 (214, -159, -93);\n     knc[2] = vec3 (-101, -117,  -27);  kns[2] = vec3 (-47,   -5, -16);\n     knc[3] = vec3 (   0,  -31,   52);  kns[3] = vec3 ( 11,  -45,  84);\n     sclFac = 0.008;\n  } else if (knType == 5) {  // granny knot\n     knc[0] = vec3 (-22,   0,  0);  kns[0] = vec3 (-128,   0,   0);\n     knc[1] = vec3 (  0, -10,  0);  kns[1] = vec3 (   0, -27,   0);\n     knc[2] = vec3 (-44,   0, 70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[3] = vec3 (  0,  38,  0);  kns[3] = vec3 (   0,  38,   0);\n     sclFac = 0.016;\n  } else if (knType == 6) {  // square knot\n     knc[0] = vec3 ( -22,  11,   0);  kns[0] = vec3 (-128,   0,   0);\n     knc[2] = vec3 ( -44, -43,  70);  kns[2] = vec3 ( -78,   0, -40);\n     knc[4] = vec3 (   0,  34,   8);  kns[4] = vec3 (   0, -39,  -9);\n     sclFac = 0.016;\n  } else if (knType == 7) {  // 6.1 knot\n     knc[0] = vec3 (  12,   29,  -30);  kns[0] = vec3 ( 20,  78, -78);\n     knc[1] = vec3 (-163, -180, -111);  kns[1] = vec3 ( 76,  58,  37);\n     knc[2] = vec3 ( -87,   88,  -67);  kns[2] = vec3 (-15,  72, -51);\n     knc[3] = vec3 ( -21,    0,   31);  kns[3] = vec3 ( 14, -14,   8);\n     knc[4] = vec3 (  24,    0,  -11);  kns[4] = vec3 (-50,   0,  65);\n     sclFac = 0.008;\n  } else if (knType == 8) {  // 6.2 knot\n     knc[0] = vec3 (  -6,  -21,  -18);  kns[0] = vec3 (-21,  -24,  -13);\n     knc[1] = vec3 (-195, -207,  113);  kns[1] = vec3 ( 92,  -72, -107);\n     knc[2] = vec3 ( -64,  112,   86);  kns[2] = vec3 (-23,   -7,   -9);\n     knc[3] = vec3 (  -6,  -13,  -26);  kns[3] = vec3 ( 13,  -40,   -7);\n     knc[4] = vec3 (  24,  -27,   24);  kns[4] = vec3 ( 15,   -3,   33);\n     knc[5] = vec3 (   0,  -17,   21);  kns[5] = vec3 ( 41,    0,   31);\n     sclFac = 0.008;\n  } else if (knType == 9) {  // 6.3 knot\n     knc[0] = vec3 (-40,   90,  52);  kns[0] = vec3 ( 32,  89,  64);\n     knc[1] = vec3 ( 69, -142,  53);  kns[1] = vec3 (-12, 147,  35);\n     knc[2] = vec3 (120,   74,  77);  kns[2] = vec3 (-52,  85, -87);\n     knc[3] = vec3 (-56,    0, 101);  kns[3] = vec3 ( 46, -56, -19);\n     knc[4] = vec3 (  0,   23,  -5);  kns[4] = vec3 (-17,   0,   2);\n     knc[5] = vec3 ( 14,   16,   3);  kns[5] = vec3 ( 19,   7,   9);\n     sclFac = 0.008;\n  } else if (knType == 10) {  // 7.2 Knot\n     knc[0] = vec3 (  10, 42, 0);  kns[0] = vec3 (115, -104, 30);\n     knc[1] = vec3 (-184, -252,  20);  kns[1] = vec3 ( 10,  47,  19);\n     knc[2] = vec3 (   0,  -21,   6);  kns[2] = vec3 (101, -65, -31);\n     knc[3] = vec3 (  23,  -23,  -4);  kns[3] = vec3 ( 55, -23, -24);\n     knc[4] = vec3 ( -38,   36, -44);  kns[4] = vec3 ( -6, -10, -50);\n     knc[5] = vec3 ( -14,  -13,  31);  kns[5] = vec3 ( 8,    2,  39);\n     knc[6] = vec3 (  16,  -18, -16);  kns[6] = vec3 ( 14,  -9,  23);\n     sclFac = 0.007;\n  } else if (knType == 11) {  // 7.7 Knot\n     knc[0] = vec3 ( -5,   17, -28);  kns[0] = vec3 (  0,   21,   9);\n     knc[1] = vec3 (  8, -174, 110);  kns[1] = vec3 ( 83,   13,   4);\n     knc[2] = vec3 ( 87,  -15,  11);  kns[2] = vec3 (100,    3,  -6);\n     knc[3] = vec3 ( -5,   -9, -46);  kns[3] = vec3 ( 22,   46, -17);\n     knc[4] = vec3 (-10,   16,  32);  kns[4] = vec3 ( 10,  -25,  -9);\n     knc[5] = vec3 ( -2,  -21, -12);  kns[5] = vec3 (-10,    7,  -9);\n     knc[6] = vec3 (  5,   -9,  -9);  kns[6] = vec3 (  6,   -3,  18);\n     sclFac = 0.01;\n  }\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.3, 0.3, 0.35) * (0.5 + 0.2 * rd.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = qnHit;\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (showBalls) nDotL *= nDotL;\n    else vn = VaryNf (32. * ro, qnHit, 0.2);\n    col = HsvToRgb (vec3 (mod (qCol, 1.), 0.6 , 1.)) * (0.3 + 0.7 * nDotL);\n  } else col = BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 rd, ro, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, sr, asp, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  knType = 1 + int (mod (floor (0.1 * tCur), nKnot));\n  showBalls = false;\n  az = 0.;\n  el = 0.;\n  zmFac = 6.;\n  if (mPtr.z > 0.) {\n    if (abs (mPtr.x) > 0.47) {\n      knType = 1 + int (mod ((mPtr.y + 0.5) * nKnot, nKnot));\n      showBalls = (mPtr.x < 0.);\n    } else {\n      az += 2. * pi * mPtr.x;\n      el += pi * mPtr.y;\n      showBalls = (mPtr.y > 0.);\n      zmFac += abs (az);\n    }\n  } else {\n    t = floor (0.6 * tCur) + smoothstep (0., 0.3, mod (0.6 * tCur, 1.));\n    az = 0.2 * t;\n    el = 0.23 * t;\n    showBalls = (mod (0.1 * tCur, 1.) < 0.5);\n  }\n  vuMat = StdVuMat (el, az);\n  nSeg = showBalls ? 128. : NSEG_MAX;\n  KtSetup ();\n  ro = vuMat * vec3 (0., 0., -20.);\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  if (abs (uv.x) < ((zmFac == 6.) ? 1. : asp)) {\n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    };\n  } else {\n    col = BgCol (vuMat * normalize (vec3 (uv, zmFac)));\n  }\n  if (mPtr.z > 0. && abs (uv.x) > 0.94 * asp) col = vec3 (0.3, 0.3, 0.);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[827, 827, 851, 851, 1095], [1097, 1097, 1141, 1141, 1377], [1379, 1379, 1434, 1434, 2168], [2170, 2170, 2212, 2212, 2373], [2446, 2446, 2479, 2479, 3754], [3848, 3848, 3865, 3865, 8335], [8337, 8337, 8359, 8359, 8414], [8416, 8416, 8451, 8451, 8836], [8838, 8838, 8894, 8894, 10592], [10594, 10594, 10624, 10624, 10737], [10739, 10739, 10775, 10775, 10981], [10983, 10983, 11007, 11007, 11129], [11163, 11163, 11187, 11187, 11299], [11301, 11301, 11326, 11326, 11512], [11514, 11514, 11543, 11543, 11755], [11757, 11757, 11796, 11796, 12048]], "test": "untested"}
{"id": "NdVSWc", "name": "test: round", "author": "FabriceNeyret2", "description": "in https://www.shadertoy.com/view/NdcXR8 , Xor use round on a way I didn't know and don't see mentioned in spec:\napparently the rounding for .5 depends if odd vs even ( NB: screen coords are int+.5 ;-) ).\nDoes every one see vertical strips here ? ( GPU/OS", "tags": ["glsl"], "likes": 3, "viewed": 438, "published": 3, "date": "1635421487", "time_retrieved": "2024-07-30T18:52:26.563607", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = vec4( U.x+.5 - round(U.x) );      // same below\n // O = vec4( U.x+.5 - roundEven(U.x) ); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 138]], "test": "untested"}
{"id": "NsySRc", "name": "Nucleation", "author": "davidar", "description": "Simulates particles nucleating into a hexagonal lattice. Hue indicates detected orientation. Mouse to move", "tags": ["simulation", "particle", "lattice"], "likes": 14, "viewed": 392, "published": 3, "date": "1635413954", "time_retrieved": "2024-07-30T18:52:27.330556", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    \n    float scale = 1. + 9. * smoothstep(0., 10., iTime);\n    vec2 m = iResolution.xy/2.;\n    if (iMouse.xy != vec2(0)) m = iMouse.xy;\n    vec2 p = (fragCoord - m)/scale + m;\n    //if (floor(mod(fragCoord.x, 10.)) == 0. || floor(mod(fragCoord.y, 10.)) == 0.) fragColor += 0.1;\n\n    for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n            vec4 data = texelFetch(iChannel0, ivec2(p) + ivec2(i,j), 0);\n            if (data != vec4(0)) {\n                vec4 col = mix(vec4(1), hue(data.w), smoothstep(1., 2., data.z));\n                fragColor += smoothstep(1., 0.67, distance(data.xy, p)) * clamp(data.z, 0., 1.) * col;\n                fragColor = clamp(fragColor, vec4(0), vec4(1));\n            }\n        }\n    }\n    fragColor = sqrt(1. - fragColor);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "#define PI 3.1415926536\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    if (iFrame < 10) {\n        if (hash12(fragCoord) < 1e-2)\n            fragColor = vec4(fragCoord.xy + hash12(1. + fragCoord) - 0.5, 0, 0);\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec2 pos = data.xy;\n    vec2 force = vec2(0);\n    \n    float minDist = 1e3;\n    \n    vec2 orientation = vec2(0);\n    int count = 0;\n\n    for (int i = -10; i <= 10; i++) {\n        for (int j = -10; j <= 10; j++) {\n            vec2 ij = vec2(i,j);\n            if (ij == vec2(0) || length(ij) > 10.) continue;\n\n            vec4 data2 = texture(iChannel0, (fragCoord + ij) / iResolution.xy);\n            if (data2 != vec4(0)) {\n                vec2 pos2 = data2.xy;\n                vec2 vel2 = data2.zw;\n                vec2 delta = pos - pos2;\n                if (data == vec4(0)) delta = fragCoord - pos2;\n                float dist = length(delta) / 2.;\n\n                // something like an interatomic potential\n                force += mix(10. * delta / pow(dist, 4.), -delta / pow(dist, 2.), smoothstep(0.9, 1., dist));\n\n                if (dist < minDist && data2.z >= 1.)\n                    minDist = dist;\n\n                if (dist < 1.) {\n                    float angle = atan(delta.y, delta.x);\n                    angle = mod(angle, PI/3.);\n                    orientation += vec2(cos(angle), sin(angle));\n                    count++;\n                }\n            }\n        }\n    }\n\n    if (data == vec4(0) && 1. < minDist && minDist < 2. && hash13(vec3(fragCoord, iFrame)) < 1e-3)\n        pos = fragCoord; // new particle\n\n    pos = mod(pos + force/1e3, iResolution.xy);\n    float z = data.z + 0.01;\n    if (z > 1.) z = mix(z, (count < 6) ? 1. : 2., 0.05);\n    fragColor = vec4(pos, z, mix(data.w, atan(orientation.y, orientation.x), 0.01));\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec4 data = texture(iChannel0, fract((fragCoord + vec2(i,j)) / iResolution.xy));\n            if(floor(data.x) == floor(fragCoord.x) && floor(data.y) == floor(fragCoord.y)) {\n                fragColor = data;\n                return;\n            }\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 123, 123, 938]], "test": "untested"}
{"id": "fsySD3", "name": "Fab28 #inktober2021 \"crispy\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]", "tags": ["raymarching", "sdf", "short", "chips", "inktober2021", "pringle", "crisp", "fried", "fries"], "likes": 17, "viewed": 398, "published": 3, "date": "1635407395", "time_retrieved": "2024-07-30T18:52:28.827554", "image_code": "// reuse https://shadertoy.com/view/NdySD3\n\n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))         // rotation\n   \nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., r,x,y,z,a=.4; \n    vec3  R = iResolution, d,\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),   // ray direction\n          p = vec3(0,0,3), q,                         // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )\n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x),\n        r = 1. + .004*sin( 25.*atan(q.z,q.y) ),       // unfair border\n        x=q.x, y=q.y, z=q.z,\n        d = vec3(  sqrt(y/a +z*z) , a*(x*x -z*z), sqrt(x*x -y/a) ), // X and Z just re-express Y(X,Z)\n        d = abs( d - q ),                             // distance in each separated axes\n        t = max( min(d.x, min(d.y,d.z) ),             // SDF\n                 length(q.xz)-r ),                    // clamp to disk\n        t = min(t,100.),                              // avoid visiting the infinity and its black hole :-) [ thanks mla ]\n        p += .25*t*D;                                 // step forward = dist to obj\n        \n    if (O.a<0.) O  = texture(iChannel1, q );          // background\n    else        O *= 1.2*vec4(1,.9,.6,1) * ( 1.-.5* texture(iChannel0, q.xz).r ), // material\n                O += .5* max(0., dot( 2.*texture(iChannel2, q.xz ).rgb-1., D ) ); // glints\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 150, 150, 1533]], "test": "untested"}
{"id": "NsKSW3", "name": "The Lodge", "author": "decripter37", "description": "What year is it?", "tags": ["twinpeaks", "liminal"], "likes": 4, "viewed": 259, "published": 3, "date": "1635406642", "time_retrieved": "2024-07-30T18:52:29.598493", "image_code": "float trn(float x){\n  float ret=0.;\n  ret = abs(x - floor(x+.5))*2.;\n  return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 xy = fragCoord.xy;\n  vec2 uv = xy/iResolution.xy;  \n  vec3 col = vec3(1., 1., 1.);\n  float band = 50.;\n  float bandrp = 30.;\n  float pro = (1.+uv.y);\n  vec4 w = vec4(-.006*pow((1.+uv.y),5.), .2, band*2., 0.);\n  bool flr =\n  mod(xy.x +\n      w.z*trn(w.y*iTime + w.x*xy.y + w.a),\n      band*2.)\n   >= band;\n  vec4 v = vec4(0.01*(.5-uv.x), 1., bandrp*sin(iTime)*(1.-uv.y), 0.);\n  bool drp =\n  mod(xy.x +\n    v.z*sin(v.y*iTime + v.x*xy.y + v.a),\n    bandrp*2.)\n  >= bandrp;\n  if(uv.y<.5){\n    if(flr){\n      col*=0.2;\n    }else{\n      col=vec3(1.);\n    }\n    col*=(.5-uv.y)*2.;\n    col.gb*=1.-uv.y;\n  }else{\n    if(drp){\n      col*=0.7;\n    }else{\n      col=vec3(1.);\n    }\n    col.gb*=pow(1.-uv.y, 2.);\n   col*=uv.y-.45;\n  }\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 84], [86, 86, 142, 142, 903]], "test": "untested"}
{"id": "ssGXWc", "name": "stuck pixel filter thing", "author": "somebody", "description": "shader implementation of https://chfour.github.io/waydsp/\nrand() taken from https://www.shadertoy.com/view/Xt23Ry", "tags": ["noise", "random"], "likes": 1, "viewed": 231, "published": 3, "date": "1635396619", "time_retrieved": "2024-07-30T18:52:30.413314", "image_code": "const vec3[] COLORS = vec3[](\n    vec3(255,   0,   0),\n    vec3(  0, 255,   0),\n    vec3(  0,   0, 255),\n    vec3(  0,   0,   0),\n    vec3(255, 255, 255)\n);\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = COLORS[int(rand(uv*(iTime+1.)) * 5.)];\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 180, 180, 228], [229, 229, 249, 249, 317], [318, 318, 338, 338, 371], [373, 373, 430, 430, 559]], "test": "untested"}
{"id": "ssySD3", "name": "Raymarcher Visual [Reflection]", "author": "Yusef28", "description": "just a simple visualizer with coloring based on iq's 2d sdf shaders\n[Mouse enabled]", "tags": ["2d", "visual"], "likes": 5, "viewed": 272, "published": 3, "date": "1635390295", "time_retrieved": "2024-07-30T18:52:31.331858", "image_code": "#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define FAR 10.\n#define circlePos vec2(cos(iTime)*0.6,-0.9)\n#define squarePos vec2(.9,sin(iTime)*0.4)\n#define S(d) 1.-smoothstep(-eps,+eps, abs(d)-0.01)\n\n#define purp vec3(159,174,216)/255.\n#define blu vec3(160,132,179)/255.\n#define pink vec3(0.9,0.6,0.6)\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n    \nfloat drawPoint(vec2 uv, vec2 p, float r){\n     return 1.-smoothstep(r-eps, r+eps, length(uv - p));\n}\n\nfloat distLine(vec2 p, vec2 A, vec2 B){\n  vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    return smoothstep(r+eps, r-eps, distLine(uv,A,B));\n}\n\nfloat map(vec2 p){\n    float c = length(p - circlePos)-0.2;\n    vec2 sp = abs(p-squarePos);\n    float s = max(sp.x,sp.y)-0.2;\n    return min(s,c);\n}\n\nvec2 normal(vec2 p){\n    vec2 e = vec2(eps,0.);\n    \n    return normalize(vec2(\n           map(p-e) - map(p+e),\n           map(p-e.yx) - map(p+e.yx) \n           ));\n           \n           \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    \n    vec2 ro = vec2(-0.8,0.);\n    vec2 rd = normalize(vec2(1.,-.2));\n    float a = iTime/3.;\n    //rd *= rot(a);\n    \n    if(iMouse.z > 0.5) \n        rd = normalize((iMouse.xy*2.-iResolution.xy)/iResolution.y - ro);\n    \n   // col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n      \n    //raymarcher\n    float t = 0., d; vec2 last, next; //last and next pos for drawing lines\n    next = ro + rd*t;\n    float mapDistances = map(uv);\n    float gradient = mapDistances;\n    \n\n    //based on iq's coloring style\n    col = sign(gradient)*purp;\n    col = mix(col, blu, clamp(1.-sign(gradient),0.,1.));\n\tcol *= clamp(pow(gradient,0.6),0.,1.);\n\tcol *= 0.7 + 0.3*cos(130.0*gradient);\n    //draw the map objects as smooth outlines\n    col = mix(col, vec3(1.), S(mapDistances));                     \n    col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n    \n\n    vec2 pos = ro;\n    \n    //basic ray marcher                   \n    for(float i = 0.; i < 15.; i ++){\n        \n        d = map(next);\n        if(t > FAR) break;\n        //t += d*0.75; \n        last = next;\n        //next = ro + rd*t;\n        next += rd*(d*0.75);\n        //draw line from last to next\n        col = mix(col, vec3(0.,0.7,0.99), drawLine(uv,last,next,0.01));\n        //draw point at next\n        col = mix(col, vec3(0.,0.7,0.99)*0.5,drawPoint(uv,next,0.02));\n        //draw circle based on d, distance to hit the map\n        col = mix(col, 0.5+0.5*cos(vec3(1.,2.,4.).xyx + i*80.)/(1.+i/5.), S(length(uv - last)-d)+0.01);\n        \n        //check for hit and reflect\n        if(d < 0.001){\n            vec2 n = normal(next);\n            rd = reflect(rd, n);\n            next -= n*0.01;\n            //t *= 0.9;\n        }\n        \n    }\n    \n    // Output to screen\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \n    \n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 325, 325, 383], [394, 394, 436, 436, 495], [497, 497, 536, 536, 653], [655, 655, 704, 704, 761], [763, 763, 781, 781, 911], [913, 913, 933, 933, 1103], [1104, 1104, 1161, 1211, 3291]], "test": "untested"}
{"id": "7dGXD3", "name": "Transition Effect ", "author": "nguyenkim495", "description": "Sum up some of transition effect, what people public in this site. I added licences for each transition effect. Thanks ", "tags": ["transition"], "likes": 5, "viewed": 374, "published": 3, "date": "1635389685", "time_retrieved": "2024-07-30T18:52:32.686237", "image_code": "#define currentTime = iTime; \n\n//swap https://www.shadertoy.com/view/fd2GDD\nvec4 Swap()\n{\n    vec4 outColor;\n    return outColor;\n}\n\n//Crosswarp https://www.shadertoy.com/view/ssj3Dh\n//iChannel1 is main draw, iChannel0 is transition effect\nvec4 Crosswarp(vec2 fragCoord, float time )\n{\n    vec4 outColor;\n  vec2 p = fragCoord/iResolution.xy;\n   float x = time;//mod(iTime,2.); // change this to alter the speed\n   \n  x=smoothstep(.0,1.0,(x*2.0+p.x-1.0));\n  outColor= mix(texture(iChannel1,(p-.5)*(1.-x)+.5), texture(iChannel0,(p-.5)*x+.5), x); \n  return outColor;\n}\n\n//Ripple Texture Transition https://www.shadertoy.com/view/3ljfzV\nvec4 Ripple(in vec2 fragCoord, float time )\n{\n    float freq = 8.0;\n    float period = 8.0;\n    float speed = 2.0;\n    float fade = 4.0;\n    float displacement = 0.2;\n    \n    vec4 outColor;\n    \n    vec2 R = iResolution.xy,\n         U = ((2. * fragCoord.xy) - R) / min(R.x, R.y),\n         T = fragCoord / R.y;\n    float D = length(U);\n\n    float frame_time = mod(iTime * speed, period);\n    float pixel_time = max(0.0, frame_time - D);\n\n    float wave_height = (cos(pixel_time * freq) + 1.0) / 2.0;\n    float wave_scale = (1.0 - min(1.0, pixel_time / fade));\n    float frac = wave_height * wave_scale;\n    if (mod(iTime * speed, period * 2.0) > period)\n    {\n        frac = 1. - frac;\n    }\n\n    vec2 tc = T + ((U / D) * -((sin(pixel_time * freq) / fade) * wave_scale) * displacement);\n    \n    vec2 p = fragCoord/iResolution.xy;\n    \n    outColor = mix(\n        texture(iChannel0, p),\n        texture(iChannel1, p),\n        frac);\n    return outColor;\n}\n\n\n//Noise https://www.shadertoy.com/view/3lB3Dm\nvec4 Noise(vec2 fragCoord, float time)\n{\n    vec4 outColor;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // get image of iChannel1\n    vec2 offset = uv.xy * 0.5;\n    vec4 channel1 = texture(iChannel0, uv);//, offset); \n    \n    float opacity = 0.5 + cos(iTime * 0.5) * 0.5;\n    \n    float amount = opacity;\n    uv.x += channel1.r * amount;\n    uv.y += channel1.g * amount;\n    uv.x -= channel1.b * amount;\n    uv.y -= channel1.a * amount;\n    \n    // get image of iChannel0\n    vec4 channel0 = texture(iChannel1, uv.xy);\n    \n    // Output to screen\n   \toutColor = channel1;\n    outColor = mix(channel1, vec4(0.5), opacity);\n    \n    return outColor;\n}\n\n//Slices https://www.shadertoy.com/view/ltVSzd\nvec4 Slices()\n{\n    vec4 outColor;\n    return outColor;\n}\n\n// luminance https://www.shadertoy.com/view/tdXfDS\nvec4 Luminance(vec2 fragCoord, float time)\n{\n    vec4 outColor;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfloat t = mod(iTime, 5.)/3.;\n    float lum = 0.2126*col.r + 0.7152*col.g + 0.0722*col.b;\n    float a = step(1.-lum, t);\n    // Output to screen\n    outColor = vec4(col, 1.) * a;\n    return outColor;\n}\n\n//random https://www.shadertoy.com/view/wdcSzl\nvec4 Random()\n{\n    vec4 outColor;\n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = mod(iTime, 3.);\n    \n    // Output to screen\n    //fragColor = Crosswarp(fragCoord, time);\n    fragColor = Ripple(fragCoord, time);\n    //fragColor = Noise(fragCoord, time);\n    //fragColor = Luminance(fragCoord, time);\n    \n    \n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Flame\n//base on this shader https://www.shadertoy.com/view/MdX3zr\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//wave\n//base on this shader https://www.shadertoy.com/view/fstGDN\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(tan(z)+1.)*abs(tan(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define SS(a, b, t) smoothstep(a, b, t)\n#define gridFrequency 0.55\n#define timeForward 900.\n#define colorShiftSpeed 15. * vec3(.234, .123, .345)\n\nfloat DistToLine(vec2 point, vec2 startPoint, vec2 endPoint)\n{\n    vec2 startToPoint = point - startPoint;\n    vec2 startToEnd = endPoint - startPoint;\n    \n    float t = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0., 1.);\n    \n    return length(startToPoint - startToEnd * t);\n}\n\n//Random with 2 input and 1 output\nfloat Random21 (vec2 p) \n{\n    return fract(sin(dot(p.xy,\n                         vec2(12.9898,78.233)))\n                            *43758.5453123);\n}\n\n//Random with 2 input and 2 output\nvec2 Random22 (vec2 p)\n{\n    float n = Random21(p);\n    return vec2(n, Random21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    vec2 n = Random22(id + offset) * (iTime + timeForward);\n    return offset + sin(n) *.4;\n}\n\nfloat DrawLine(vec2 p, vec2 a, vec2 b)\n{\n    float d = DistToLine(p, a, b);\n    float m = SS(.025, .01, d);\n    float len = length(a-b);\n    m *= SS(1., .8, len)*.5 + SS(.075, .025, abs(len-.75)) * .15;\n    return m;\n}\n\nfloat Layer(vec2 uv)\n{\n    float m = 0.;\n    vec2 gridUV = fract(uv)-.5; //Move to middle of screen\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[i++] = GetPos(id, vec2(x,y));\n        }\n    }\n    \n    float t = iTime * 5.;\n    for (int i = 0; i < 9; i++)\n    {\n        m += DrawLine(gridUV, p[4], p[i]);\n        \n        //Draw sparkle at the point\n        vec2 j = (p[i] - gridUV) * 35.; \n        float sparkle = 1./dot(j,j);\n        m += sparkle * (sin(t + fract(p[i].x) * 10.) * .5 + 0.5);\n    }\n    \n    //Draw the cut line between grids\n    m += DrawLine(gridUV, p[1], p[3]);\n    m += DrawLine(gridUV, p[1], p[5]);\n    m += DrawLine(gridUV, p[3], p[7]);\n    m += DrawLine(gridUV, p[5], p[7]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) - .5;\n    \n    float m = 0.;\n    float t = iTime * .1;\n    \n    float gradient = -uv.y - 0.15;\n    float fft = texelFetch (iChannel0, ivec2(.7,0), 0).x;\n    \n    //Rotate the layer\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n    mouse *= rot;\n    \n    for (float i = 0.; i <= 1.; i += 0.33f)\n    {\n        float z = fract(i+t); //Move pass 1, snap back to 0 -> reuse Layer\n        float size = mix(10., .5, z);\n        float fade = SS(0., .5, z) * SS(1., .8, z);\n        m += Layer(uv * gridFrequency * size + i * 25. - mouse) * fade;\n    }\n\n    //Debug Point\n    //vec2 point = GetPos(id);\n    //float d = length(gridUV - point);\n    //m = SS(.1, .05, d);\n\n    //Debug grid:\n    //if (gridUV.x > .48 || gridUV.y > .48) col = vec3(1,0,0);\n    \n    //Shift color base on varying channel speed as well as UV\n    vec3 base = sin(t * colorShiftSpeed + uv.x * 2. + uv.y * 2.) * .4 + .6;\n    vec3 col = vec3(m) * base;\n    \n    //Post processing effect    \n    gradient *= fft;\n    gradient = clamp(gradient, 0., 1.);\n    col += gradient * base;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_c_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec3 glow(vec2 p, vec2 lpos)\n{\n    vec2 q = p - lpos;\n    float atten = 1./dot(q,q);\n    //atten *= (1. + atten*1e-4); // Make the inside slightly sharper\n    return vec3(1.0) * atten;\n}\n\n\nfloat rand(vec2 co){\n    // https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/*\nfloat rand(float v){\n    return fract(sin(12.9898*v)*43758.5453);\n}\n*/\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvec3 lastExplosion(float time)\n{\n    // vec3(time since last explosion,\n    //      index of last explosion,\n    //      time until next explosion)\n    float t = mod(time, 10.);\n    float interval = floor(time/10.);\n    float t0max = 0., imax=-1.;\n    float t0next = 10.;\n    for(float i=0.; i<10.; i++)\n    {\n        float t0 = rand(vec2(interval, i)) * 10.;\n        if(t > t0 && t0 > t0max)\n        {\n            t0max = t0;\n            imax = i;\n        }\n        if(t < t0 && t0 < t0next)\n        {\n            t0next = t0;\n        }\n    }\n    return vec3(t-t0max, 10.*interval+imax, t0next-t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 lastExpl = lastExplosion(iTime);\n    float t = lastExpl.x, explNum = lastExpl.y, tFadeout = lastExpl.z;\n    \n    // Fireworks base color\n    vec3 baseCol = vec3(0.5,0.5,0.5) + 0.4*sin(vec3(1.)*explNum+vec3(0.,2.1,-2.1));\n    \n    // Number of particles\n    float N_LIGHTS = 100.;\n    for(float i=0.; i<N_LIGHTS; i++)\n    {\n        \n        // Generate points uniformly on hemisphere\n        // (see Total Compendium eq. (34))\n        float f = i/N_LIGHTS;\n        float r = sqrt(1. - f*f);\n        float th = 2.*0.618033*3.14159*i; // Use Golden Ratio for a quasirandom sequence\n        float hash = sin(explNum+i*85412.243);\n        float weight = (1.-0.2*hash);\n        th += hash *3.* 6.28/N_LIGHTS;\n        // Only take x and y coordinates\n        vec2 lpos = vec2(cos(th), sin(th)) * r;\n        // Add some physics\n        lpos.xy *= (1.-exp(-3.*t/weight)) * weight; // explosion, easing out\n        //lpos.y += t*0.3*weight - t*(1.-exp(-t*weight)) * 0.6 * weight; // vertical free-fall motion\n        float intensity = 2e-4;\n        intensity *= exp(-2.*t); // Fade out with time\n        intensity *= (1.-0.5*hash); // Randomize per particle\n        intensity *= (1.+10.*exp(-20.*t)); // Intensity burst at explosion\n        intensity *= clamp(3.*tFadeout, 0., 1.); // Fade out before next explosion\n        col += glow(p, lpos) * intensity * baseCol;\n    }\n    \n    \n    col = max(col, 0.);\n    //col = 1.-exp(-col); // Tone mapping\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14); // Tone mapping\n    //col = col/(1.+col);\n    col = sqrt(col); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 76, 89, 89, 131], [133, 240, 285, 285, 565], [567, 633, 678, 678, 1588], [1591, 1637, 1677, 1677, 2344], [2346, 2393, 2408, 2408, 2450], [2452, 2503, 2547, 2547, 2935], [2937, 2984, 2999, 2999, 3041], [3043, 3043, 3100, 3150, 3444]], "test": "untested"}
{"id": "7sGSW3", "name": "Taste of Noise 12", "author": "leon", "description": "trippin", "tags": ["weird"], "likes": 13, "viewed": 531, "published": 3, "date": "1635384338", "time_retrieved": "2024-07-30T18:52:33.541949", "image_code": "// taste of noise 12 by leon denise 2021/10/28\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret, Blackle and many others\n// licensed under hippie love conspiracy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nfloat jump(float time, float curve)\n{\n    return pow(fract(time), curve) + floor(time);\n}\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "// taste of noise 12 by leon denise 2021/10/28\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret, Blackle and many others\n// licensed under hippie love conspiracy\n\n// global variable\nfloat delay = 6.;\nfloat material, bounces;\nvec3 rng;\n\n// geometry\nfloat map (vec3 p)\n{\n    float scene = 1000.;\n    float shape = 1000.;\n    \n    // times\n    float t = floor(iTime/delay)*78.;\n    float j = jump(iTime/delay, .001)+t;\n    vec3 rngt = hash31(t);\n    \n    // parameters\n    vec3 angle = vec3(1,2,3)+j;\n    float range = .5;\n    float size = .3;\n    \n    // random falloffs\n    float var = mix(1.2, 1.9, rngt.x);\n    float vaa = mix(1.1, 1.8, rngt.y);\n    float vas = mix(1.3, 1.5, rngt.z);\n    \n    // kaleidoscopic iterated function\n    const float count = 8.;\n    material = -1.;\n    float ar = 1., aa = 1., as = 1.0;\n    for (float index = 0.; index < count; ++index)\n    {\n        // fold\n        p.x = abs(p.x)-range*ar;\n        \n        // rotate\n        p.xz *= rot(angle.y/aa);\n        p.yz *= rot(angle.x/aa);\n        p.xy *= rot(angle.z/aa);\n        \n        // combine\n        scene = min(scene, length(p)-size*as);\n        \n        // falloff\n        ar /= var;\n        aa /= vaa;\n        as /= vas;\n    }\n    \n    // lines\n    shape = min(length(p.xy), length(p.xz));\n    material = shape < scene ? 1. : material;\n    scene = min(shape, scene);\n    return scene;\n}\n\nvec3 color (vec3 pos, vec3 ray, vec3 normal)\n{    \n    vec3 color = vec3(0.);\n    \n    if (material == -1.)\n    {\n        // lighting\n        vec3 rf = reflect(ray, normal);\n        vec3 backlight = vec3(0.1) * sqrt(dot(rf, vec3(0,0,1))*0.5+0.5);\n        vec3 specular = vec3(1) * pow(dot(rf, normalize(vec3(0,1,0)))*0.5+0.5,10.);\n        color = backlight + specular*.5;\n    }\n    else\n    {\n        // color palette by Inigo Quilez (https://iquilezles.org/articles/palettes)\n        color = .5+.5*cos(vec3(0, .3, .6)*6.+length(pos)*4.+1.);\n        \n        // brighten up reflections\n        color *= 1.+bounces*1.;\n    }\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // reset color\n    fragColor = vec4(0,0,0,1);\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash33(seed);\n    \n    // blur edges\n    vec3 rng3 = hash33(seed+78.);\n    vec2 dof = vec2(cos(rng3.x*6.28),sin(rng3.x*6.28))*rng3.y;\n    uv += dof*pow(length(uv), 8.0)*rng3.z*.5;\n    \n    // camera coordinates\n    vec3 eye = vec3(.5,1,-3.);\n    vec3 at = vec3(0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = cross(x, z);\n    vec3 ray = normalize(z * 2. + uv.x * x + uv.y * y);\n    vec3 pos = eye + ray * (rng3.z*.5);\n    \n    // normalized random direction by Blackle (https://suricrasia.online/demoscene/functions/)\n    rng3 = normalize(tan(rng3*2.-1.));\n    \n    // raymarching\n    const float count = 30.;\n    float total = 0.;\n    bounces = 0.;\n    for (float index = 0.; index < count; ++index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.001)\n        {\n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(0.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n            // coloring\n            float shade = 1.-index/count;\n            fragColor.rgb += color(pos, ray, normal) * shade / (1.+bounces);\n            \n            // reflection\n            if (++bounces > 1.) break;\n            ray = reflect(ray, normal);\n            ray = normalize(ray + rng3);\n            dist = 0.01;\n            total = 0.;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * rng.z;\n        \n        // depth of field\n        total += dist;\n        ray += 0.03*smoothstep(2.,6.,total) * rng3;\n        \n        // ray march\n        pos += ray * dist;\n    }\n    \n    // vignette\n    fragColor.rgb *= 1.-pow(length(uv), 8.);\n    \n    // temporal fade\n    vec4 frame = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = max(fragColor.rgb, frame.rgb - 0.001);\n    \n    // animation fade\n    fragColor.rgb *= smoothstep(1., .95, fract(iTime/delay));\n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGSW3.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[178, 178, 235, 235, 304]], "test": "untested"}
{"id": "ssK3DR", "name": "Postcard of a Mirage ", "author": "byt3_m3chanic", "description": "A shader I've kicked around for a while - parts of the noise from various @iq's examples / and add in some anisotropic glitter and floating shapes. ", "tags": ["raymarching", "fbm", "water", "anisotropic", "sand", "glitter"], "likes": 24, "viewed": 491, "published": 3, "date": "1635381703", "time_retrieved": "2024-07-30T18:52:34.298925", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Postcard of a Mirage \n    10/27/21 @byt3_m3chanic\n\n    A shader I've kicked around for a while. \n    Parts of the noise from various @iq's examples.\n    Add in some anisotropic glitter and floating \n    shapes, and you have a abstract isometric shader! \n*/\n\n\n#define S\tsmoothstep\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265\n#define PI2 6.28318530\n#define ZRO 0\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nvec2 hash2( vec2 p ){ return fract(sin(vec2(dot(p,vec2(127.1,211.7)),dot(p,vec2(219.5,183.3))))*43758.5453); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// @gaz\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat box(vec2 p,vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// @iq\nvec3 noised( in vec2 x ){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    // texel fetch version\n    vec2 p = vec2(floor(x));\n    float a = hash21( p+vec2(0,0) );\n\tfloat b = hash21( p+vec2(1,0) );\n\tfloat c = hash21( p+vec2(0,1) );\n\tfloat d = hash21( p+vec2(1,1) );\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t   6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n// @iq\nfloat fbm ( in vec2 _st, float oct) {\n    oct = min(oct,5.);\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(.5), sin(.5),-sin(.5), cos(.5));\n    for (float i = 0.; i < 8.25-oct; ++i) {\n        v += a * noised(_st).x;\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n//generate terrain using above noise algorithm\nfloat terrain( vec2 p, float freq ) {\t\n\tfloat h = -1.;\n\tfloat w = 2.6;\n\tfloat m = 0.35;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noised((p * m)).x;\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\n//globals\nvec3 hitPoint,hit;\nvec2 vuv;\nmat2 r45,turn,tilt;\nfloat mvt = 0.,ghs,shs;\nfloat midpt;\n\n//constants\nconst float sz = .5;\nconst float hf = sz*.5;\nconst float db = sz *2.;\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(1e5,0.);\n    p.y+=4.;\n    vec3 pp = p;\n\n    if(vuv.x<midpt) p.z-=T*.3;\n    \n    float ter = terrain(p.xz*sz,2.)*.85;\n    float d2 = p.y - ter;\n    \n    if(d2<res.x && vuv.x<midpt) {\n       res = vec2(d2,2.);\n       hit=p;\n    }\n    \n    float d3 = pp.y-1.-(ter*.75);\n    if(d3<res.x && vuv.x>midpt) {\n        res=vec2(d3,1.);\n        hit=p;\n    }\n\n    vec2 id = floor(p.xz*sz) + .5; \n    vec2 r = p.xz - id/sz;\n    vec3 qx = vec3(r.x,p.y,r.y);\n    float hs = hash21(id);\n    float xtr = terrain(id,2.)*.85;\n    vec3 qqx=qx-vec3(0,xtr+.1,0);\n    \n    float bf = length(qqx)-(.3*hs);\n    if(bf<res.x && vuv.x<midpt && hs>.4 && xtr>1.15) {\n        res=vec2(bf,4.);\n        hit=qqx;\n        shs=hs;\n    }\n\n    float cells = 8.;\n    vec3 q = pp-vec3(0,4.5,0);\n    q.xz*=turn;\n\n    // @Shane Polar Repetion \n    float a = atan(q.z, q.x);\n    // Partitioning the angle into \"aNum\" cells.\n    float ia = floor(a/6.2831853*cells);\n    ia = (ia + .5)/cells*6.2831853;\n\n    // find object via mod and cells and wave\n    float ws = -mod(ia,.0);\n    float cy = sin( ws*4. + (T * .25) * PI) * 1.5;\n    q.y +=cy;\n\n    // Converting the radial centers to their positions.\n    q.xz *= rot(ia);\n    q.x -= 5.75;\n \n    q.zy*=rot(ws+T);\n    q.xz*=rot(ws);\n\n    float df = zag(q,.295);\n    if(df<res.x) {\n        res=vec2(df,3.);\n        hit=q;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\n// water ripples - using bmp map to add extra\n// depth to water effects\nvec3 fxBumpMap( vec3 p, vec3 n, float bf, float per) {\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        vec3(fbm(p.xz - e.xy, 3.)), \n        vec3(fbm(p.xz - e.yx, 2.)), \n        vec3(fbm(p.xz - e.yy, 3.))\n    );\n    vec3 g = vec3(.3, .59, .12) * m; \n    g = (g - dot(vec3(fbm(p.xz , 3.)), vec3(.3, .59, .12)) )/e.x; g -= n*dot(n, g);  \n    return normalize( n + g*bf );\n}\n\n// reduced voronoi based off @iq\n// https://www.shadertoy.com/view/ldl3W8\n// used for the glitter pattern\nvec3 voronoi( in vec2 x) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 mg, mr;\n    float md = 8.,ox = 0.;\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md ){\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    md = 8.;\n    //reduced to 1\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = mg + vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        ox = o.x;\n    }\n    return vec3(md,ox,mr.x);\n}\n\n// lame based off the tex3D and used\n// to add texture for glintz\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = voronoi(p.yz).xyz;\n    vec3 ty = voronoi(p.zx).xyz;\n    vec3 tz = voronoi(p.xy).xyz;\n    //return mat3(tx*tx, ty*ty, tz*tz)*n;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 glintz( vec3 lcol, vec3 hitPoint, vec3 n, vec3 rd, vec3 lpos) {\n    vec3 mate = vec3(0);\n    vec3 pos = hitPoint;\n    \n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    float pw,q,anisotropy;\n    vec3 tcoord;\n \n    //build layers\n    for(int i = 0; i < 2;i++) {\n\n        if( i==0 ) {\n            anisotropy=.55;\n            pw=R.x*.20;\n            tcoord=coord;\n        } else {\n            anisotropy=.62;\n            pw=R.x*.10;\n            tcoord=coord2;\n        }\n        \n        vec3 aniso = vec3(vor3D(tcoord.zyx*pw,n).yy, vor3D(tcoord.xyz*vec3(pw,-pw,-pw),n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n\n        float ah = abs(dot(h,aniso));\n \n        if( i==0 ) {\n            q = exp2((1.15-anisotropy)*2.5);\n            nh = pow( nh, q*4.);\n            nh *= pow( 1.-ah*anisotropy, 10.);\n        } else {\n            q = exp2((.1-anisotropy)*3.5);\n            nh = pow( nh, q*.4);\n            nh *= pow( 1.-ah*anisotropy, 150.);\n        }     \n\n        glints += \n        (lcol*nh*exp2(((i==0?1.25:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n\n    return \n        mix(light*vec3(0.3), vec3(.05), .1) +\n        glints +\n        lcol * .3;\n}\n\nvec3 sky = vec3(0);\n// modified slim sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, float ison) { \n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n    // rayleigh / mie\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1), betaM = vec3(4e-2); \n    float zAng = max(2e-6, rd.y);\n    // scatter - Klassen's model.\n    vec3 extinction = exp(-(betaR*1. + betaM*1.)/zAng);\t\n    vec3 col = 2.*(1. - extinction);\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 vuv = (ro + t*rd).xz;\n\tif(t>0.&&ison>0.) {\n        col = mix(col, vec3(3), smoothstep(.45, 1., fbm(3.*vuv/1e5,1.))*\n                                smoothstep(.25, .65, rd.y*.5 + .5)*.4);  \n    }\n    return clamp(ACESFilm(col), 0., 1.);\n} \n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n\n    float  m = 0.;\n    vec3 p = ro;\n    for (int i = 0; i<128;i++) {\n     \tp = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<d*MIN_DIST || d>MAX_DIST)break;\n        d += i<32? ray.x*.45 : ray.x*.85; \n        m = ray.y;\n    }\n    \n    hitPoint=hit;\n    ghs=shs;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST){\n        alpha = d;\n      \tvec3 n = normal(p, d);\n         \n        vec3 lpos = vec3(-14.,9,-4.);\n        vec3 l = normalize(lpos-p);   \n        vec3 h = vec3(.5);\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.0, 1., fresnel);\n        ref=vec3(.01); \n        // materials and bump\n        if(m==1.) {    \n            n = fxBumpMap(.05*T+hitPoint*.025, n, .15 ,d);\n            h = glintz(vec3(0.114,0.361,0.447), .01*T+hitPoint*.015, n, normalize(p-lpos), l);\n            ref = (h+.2)-fresnel;\n        }\n        if(m==2.) {   \n            h = glintz(vec3(0.945,0.753,0.533), hitPoint.zyx*.055, n, rd, l);\n            ref = (h*.5)-fresnel;\n        }\n        if(m==3.) {\n            ref = vec3(.7)-fresnel;\n        }\n        if(m==4.) {\n            h = mix(vec3(0.624,0.169,0.016),vec3(0.737,0.588,0.043),clamp(ghs*.85,0.,1.));\n            ref = (h*.5)-fresnel;\n        }\n        // diff and shadows\n        float diff = clamp(dot(n,l),.03,1.);\n        float shdw = 1., t = .3;\n        for(int i=0; i<18; i++){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) {shdw = .03; break;}\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = .5 * pow(max(dot(view, ret), 0.), 24.);\n\n        C += h * diff+spec;\n        C = mix(sky,C,  exp(-.000025*d*d*d));\n\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n       \n    } else {\n        C = sky;\n    }\n    return vec4(C,alpha);\n}\n\nvoid topLayer(inout vec3 C, vec2 uv) {\n    float px = fwidth(uv.x);\n    //uv*=tilt;\n    float bx = box(uv-vec2(.0,.02),vec2(.9,.475))-.0025;\n    float dx = abs(bx)-.001;\n    dx=smoothstep(px,-px,dx);\n    bx=smoothstep(-px,px,bx);\n\n    float bd = box(uv-vec2(.001,-.015),vec2(.86,.435))-.0025;\n    float sd =smoothstep(.085-px,px,bd);\n\n    vec3 ln = mix(vec3(0.647,0.545,0.435),vec3(0.208,0.588,0.753),.5+uv.y*.75);\n    C=mix(C,ln,bx);\n    if(hash21(uv)>.7)C=mix(C,C*.8,bx);\n    C=mix(C,C*.15,min(sd,bx));\n    \n    float en = noised(vec2(uv.y*20.,.1)).x*.05;\n    float tp = box(uv-vec2(en*.5,.5),vec2(.2,.025));\n    float ts = smoothstep(px,-px,tp);\n    tp = abs(tp)-.001;\n    tp=smoothstep(px,-px,tp);\n    C=mix(C,C*.2,ts);\n    C=mix(C,C*.6,tp);\n\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    mvt+= T*.5;\n    turn=rot(T*.2);\n\n    // uv + ro + rd\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vuv=uv;\n    float vv = uv.y;\n    midpt = .45*sin(vv*5.+T*1.15);\n\n    float zoom = 10.;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0.,0.,1.);\n\n    float x = M.xy==vec2(0)?0.:(M.x/R.x * 1. - .5) * PI;\n    mat2 rx = rot(-.38531); mat2 ry = rot(-.38531+x);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fil=vec3(1.);\n    \n    // ref loop @BigWIngs\n    float d =0.;\n    // if slow reduce to 2\n    for(float i=0.; i<3.; i++) {\n        vec4 pass = render(ro, rd, ref, i==3.-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n\n    \n    \n    C=clamp(C,vec3(0),vec3(1));\n    topLayer(C,uv);\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3DR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[549, 549, 570, 570, 659], [660, 660, 682, 682, 738], [739, 739, 758, 758, 803], [805, 813, 841, 841, 1003], [1005, 1005, 1031, 1031, 1111], [1113, 1120, 1145, 1145, 1501], [1502, 1509, 1546, 1546, 1884], [1885, 1932, 1969, 1969, 2126], [2308, 2308, 2326, 2326, 3696], [3698, 3708, 3738, 3738, 3974], [3976, 4048, 4102, 4102, 4437], [4439, 4545, 4571, 4571, 5164], [5166, 5232, 5266, 5266, 5511], [5513, 5513, 5581, 5581, 6917], [6939, 7018, 7044, 7044, 7109], [7110, 7110, 7162, 7162, 7772], [7775, 7775, 7860, 7860, 9898], [9900, 9900, 9938, 9938, 10648], [10650, 10650, 10691, 10705, 11529]], "test": "untested"}
{"id": "NsySD3", "name": "Fractal Cloud", "author": "xjorma", "description": "Inspired by https://twitter.com/josefluispelz/status/1453019124699906058 By Josef Luis Pelz\nTrying to do a realtime version of it.\nUse the mouse to move around.", "tags": ["fractal", "raymarch", "cloud", "cineshader"], "likes": 35, "viewed": 5768, "published": 3, "date": "1635367577", "time_retrieved": "2024-07-30T18:52:35.055901", "image_code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define AA 0\n\nmat2 rot(float a)\n{\n  float s = sin(a), c = cos(a);\n  return mat2(c,-s,s,c);\n}\n\nfloat cube(vec3 p)\n{\n  vec3 a = abs(p) - 1.;\n  return max(a.x, max(a.y, a.z));\n}\n\n\nmat2 mx, my, mz;\nfloat fold(vec3 p)\n{\n  float scale = 50.0;\n  p *= scale;\n  int iter = 13;\n  for (int i=0; i < iter; i++)\n  {\n    p.xy *= mz;\n    p.yz *= mx;\n    p.xz *= my;\n    p = abs(p) - float(iter - i);    \n  }\n  return cube(p) / scale;\n}\n\nfloat map(vec3 p)\n{\n   return fold(p);\n}\n\n\n\nfloat rayCastShadow(in vec3 ro, in vec3 rd)\n{\n   vec3 p = ro;\n   float acc = 0.0;\n   float dist = 0.0;\n\n   for (int i = 0; i < 32; i++)\n   {\n\t  if((dist > 6.) || (acc > .75))\n\t\t   break;\n\n      float sdf = map(p);\n      \n      const float h = .05;\n      float ld = max(h - sdf, 0.0);\n      float w = (1. - acc) * ld;   \n     \n      acc += w;\n             \n      sdf = max(sdf, 0.05);\n      p += sdf * rd;\n      dist += sdf;\n   }  \n   return max((0.75 - acc), 0.0) / 0.75 + 0.02;\n}\n\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n   vec3 p = ro;\n   float acc = 0.;\n   \n   vec3 accColor = vec3(0);\n   \n   float dist = 0.0;\n\n   for (int i = 0; i < 64; i++)\n   {\n\t  if((dist > 10.) || (acc > .95))\n        break;\n\n      float sdf = map(p) * 0.80;\n      \n      const float h = .05;\n      float ld = max(h - sdf, 0.0);\n      float w = (1. - acc) * ld;   \n     \n      accColor += w * rayCastShadow(p, normalize(vec3(0.75,1,-0.10))); \n      acc += w;\n       \n      sdf = max(sdf, 0.03);\n      \n      p += sdf * rd;\n      dist += sdf;\n   }  \n    \n   return accColor;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mz = rot(iTime * 0.19);\n    mx = rot(iTime * 0.13);\n    my = rot(iTime * 0.11);\n\n\tvec3 tot = vec3(0.0);\n        \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera       \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 6. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd);\n        \n        tot += col;         \n#if AA\n    }\n    tot /= 4.;\n#endif\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySD3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[127, 127, 146, 146, 205], [207, 207, 227, 227, 287], [307, 307, 327, 327, 533], [535, 535, 554, 554, 575], [579, 579, 624, 624, 1059], [1063, 1063, 1100, 1100, 1631], [1633, 1633, 1675, 1675, 1839]], "test": "untested"}
{"id": "NdGSW3", "name": "DFT Convolution", "author": "paniq", "description": "realtime fullscreen DFT convolution using linear light, with color support; we need to cramp everything into 4 buffers, so it takes 12 frames to update the picture fully. comes with 9 kernel presets.", "tags": ["convolution", "dft"], "likes": 5, "viewed": 473, "published": 3, "date": "1635365229", "time_retrieved": "2024-07-30T18:52:36.286610", "image_code": "\nconst float tau = 6.283185;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_KERNEL\n    // shift kernel back to center\n    fragCoord = mod(fragCoord + vec2(ivec2(iResolution.xy)/2), iResolution.xy);\n#endif\n#if 0\n    vec4 f = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(vec3(f.x*0.5+0.5),0.0);\n#elif defined(SHOW_DFT)\n    vec4 f = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    float w = length(f);\n    w = w / (w + 1.0); // limit magnitudes to 0..1\n    float a = atan(f.y,f.x);\n    fragColor = vec4(pow(vec3(w)*hue(a), vec3(1.0/2.2)), 1.0);\n#else\n    vec4 f = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    #ifdef SHOW_KERNEL\n    fragColor = vec4(pow(f.rgb,vec3(1.0/2.2)),0.0);\n    #elif defined(LINEAR_LIGHT)\n    fragColor = vec4(pow(ACESFitted(f.rgb*0.8),vec3(1.0/2.2)),0.0);\n    #else\n    fragColor = vec4(pow(f.rgb,vec3(1.0/2.2)),0.0);\n    #endif\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    //// IMAGE\n\n    vec4 image = vec4(0.0);\n#ifdef LONDON\n    image = texture(iChannel2, (uv*0.5*vec2(1.0, 16.0/9.0))*0.5 + 0.5);\n#else\n    image = texture(iChannel1, (uv*0.5*vec2(1.0, 1.0))*0.5 + 0.5);\n#endif\n    image.rgb = pow(image.rgb, vec3(2.2));\n#ifdef LINEAR_LIGHT\n    // fake linear light\n    image.rgb = InvACESFitted(image.rgb);\n#endif\n\n    //// KERNEL\n\n    vec4 kernel = vec4(0.0);\n    ivec2 pixelcoord = ivec2(fragCoord);\n    float identity_pixel = float(pixelcoord == ivec2(0));\n    // shift center to the edge because 0,0 convolves relative to 0,0\n    fragCoord = mod(fragCoord + vec2(ivec2(iResolution.xy)/2), iResolution.xy);\n    uv = fract(fragCoord/iResolution.xy)*2.0-1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float radius = RADIUS;\n    float A = iResolution.x*iResolution.y;\n    #if (KERNEL == 0) // circular gradient\n    float d = length(uv);\n    float w = mix(0.5,1.0,dot(uv,uv) / (radius*radius));\n    kernel = vec4(w*(1.0 - clamp((d - radius)*iResolution.y/2.0, 0.0, 1.0)));\n    #elif (KERNEL == 1) // hexagon\n    float u0 = dot(abs(uv),ang(radians(60.0)));\n    float u1 = dot(abs(uv),ang(radians(0.0)));\n    float d = max(u0,u1);\n    kernel = vec4(1.0 - clamp((d - radius)*iResolution.y/2.0, 0.0, 1.0));\n    #elif (KERNEL == 2) // pentagon\n    uv = vec2(abs(uv.x),uv.y);\n    float u0 = dot(uv,ang(radians(54.0)));\n    float u1 = dot(uv,ang(radians(-18.0)));\n    float u2 = dot(uv,ang(radians(-90.0)));\n    float d = max(max(u0,u1),u2);\n    kernel = vec4(1.0 - clamp((d - radius)*iResolution.y/2.0, 0.0, 1.0));\n    #elif (KERNEL == 3) // bloom\n    float R = 4.0;\n    float d = gauss(length(uv)*R)*R*R/A;\n    d += identity_pixel;\n    kernel = vec4(d*0.5);\n    #elif (KERNEL == 4) // motion blur\n    float R = radius*6.0;\n    float d = udBezier(uv, vec2(-0.5,0.0)*R, vec2(0.0, 0.1)*R, vec2(0.5,0.0)*R);\n    A = sqrt(A);\n    kernel = vec4(1.0 - clamp((d - 0.5/A)*iResolution.y/2.0, 0.0, 1.0));\n    #elif (KERNEL == 5) // star\n    radius *= 0.125;\n    uv = vec2(abs(uv.x),uv.y);\n    float u0 = dot(uv,ang(radians(18.0)));\n    float u1 = dot(uv,ang(radians(90.0)));\n    float u2 = dot(uv,ang(radians(-54.0)));\n    float u3 = dot(uv,ang(radians(-126.0)));\n    float d = min(max(u0,u3),max(u1,u2));\n    kernel = vec4(1.0 - clamp((d - radius)*iResolution.y/2.0, 0.0, 1.0));\n    #elif (KERNEL == 6) // polychrome flare\n    uv = cmul(uv, radians(25.0));\n    vec3 m = vec3(0.2, 0.3, 0.4);\n    uv = abs(uv);\n    vec2 uv_r = pow(uv, vec2(m.x));\n    vec2 uv_g = pow(uv, vec2(m.y));\n    vec2 uv_b = pow(uv, vec2(m.z));\n    vec3 L;\n    L.r = pow(uv_r.x+uv_r.y,1.0/m.x);\n    L.g = pow(uv_g.x+uv_g.y,1.0/m.y);\n    L.b = pow(uv_b.x+uv_b.y,1.0/m.z);    \n    vec3 c = 1.0 - clamp((L - radius)*iResolution.y/256.0, vec3(0.0), vec3(1.0));\n    c = pow(c, vec3(32.0))*radius*40.0/sqrt(A);\n    kernel = vec4(c + identity_pixel*vec3(1.5,0.6,0.0)*0.5, 0.0);\n    #elif (KERNEL == 7)\n    float l = length(uv);\n    float m = (1.0 - clamp((l - radius*1.5)*iResolution.y/2.0, 0.0, 1.0));\n    vec3 d = min(abs((l-radius*(1.0+vec3(0.0,1.0,2.0)*0.5))*16.0),vec3(1.0));\n    d = cos(d*radians(180.0))*0.5+0.5;\n    kernel = vec4(d*m,0.0);\n    #elif (KERNEL == 8)\n    #if 1\n    mat3 M = mat3(\n         0, -1,  0,\n        -1,  5, -1,\n         0, -1,  0\n    );\n    #else\n    // write your own\n    // will not be normalized\n    mat3 M = mat3(\n         0,  0,  0,\n         0,  1,  0,\n         0,  0,  0\n    );\n    #endif\n    ivec2 p = pixelcoord;\n    if ((min(p.x,p.y) >= 0) && (max(p.x,p.y) < 3))\n        kernel = vec4(M[p.x][p.y]);\n    #endif\n    \n    int ch = (iFrame / 4) % 3;\n    fragColor = vec4(image[ch], 0, kernel[ch], 0);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// built the thing from scratch but used https://www.shadertoy.com/view/4s3GDs\n// extensively for reference and to fix implementation details\n\n#define RADIUS 0.1\n\n#define LINEAR_LIGHT\n// 0 = circular gradient bokeh\n// 1 = hexagon bokeh\n// 2 = pentagon bokeh\n// 3 = bloom\n// 4 = bezier motion blur\n// 5 = star bokeh\n// 6 = polychrome flare\n// 7 = hue ring\n// 8 = 3x3 sharpen matrix\n#define KERNEL 5\n//uncomment for regent street test picture\n//#define LONDON\n\n#if (KERNEL == 5)\n#undef RADIUS\n#define RADIUS 0.2\n#endif\n\n#if (KERNEL == 8)\n#undef LINEAR_LIGHT\n#endif\n\n//#define SHOW_KERNEL\n//#define SHOW_DFT\n\n//// utility functions\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \nvec2 ang(float a) { return vec2(cos(a), sin(a)); }\nfloat gauss(float x) { return exp(-.5*x*x); }\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat expstep(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return 1.0/(1.0 + exp(1.0/x - 1.0/(1.0-x)));\n}\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\n// from https://www.shadertoy.com/view/MlKcDD\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n///////////////////////////////////////////////\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvec3 InvRRTAndODTFit(vec3 x)\n{\n    return -1.0/100.0*(21647550.0*x + sqrt(-1873455419487500.0*x*x + 2326712714032270.0*x + 2415638944900.0) - 1228930.0)/(983729.0*x - 1000000.0);\n}\n\nvec3 InvACESFitted(vec3 color)\n{    \n    color = color * inverse(ACESOutputMat);\n    \n    // Apply RRT and ODT\n    color = InvRRTAndODTFit(color);\n\n    color = color * inverse(ACESInputMat);\n\n    return color;\n}\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame % 4;\n    if (frame == 0) {\n        int M = int(iResolution.x);\n        int U = int(fragCoord.x);\n        float u = fragCoord.x - 0.5 - float(int(iResolution.x)/2);\n        float iM = 1.0 / float(M);\n        vec4 result = vec4(0.0);\n        for (float i = 0.0; i < iResolution.x; ++i) {\n            float k = -6.28318530718*(float(u)*float(i)*iM);\n            vec4 d = texelFetch(iChannel0, ivec2(i,fragCoord.y), 0);\n            result.xy += cmul(d.xy, k);\n            result.zw += cmul(d.zw, k);\n           \n        }\n        fragColor = result;\n    } else if (frame == 1) {\n        int M = int(iResolution.y);\n        int U = int(fragCoord.y);\n        float v = fragCoord.y - 0.5 - float(int(iResolution.y)/2);\n        float iM = 1.0 / float(M);\n        vec4 result = vec4(0.0);\n        for (float i = 0.0; i < iResolution.y; ++i) {\n            float k = -6.28318530718*(float(v)*float(i)*iM);\n            vec4 d = texelFetch(iChannel1, ivec2(fragCoord.x,i), 0);\n            result.xy += cmul(d.xy, k);\n            result.zw += cmul(d.zw, k);\n        }\n        fragColor = result;\n    } else if (frame == 2) {\n        vec2 U = fragCoord - 0.5;\n        vec4 s = texelFetch(iChannel1, ivec2(fragCoord), 0).xyzw;\n        vec2 A = s.xy;\n        vec2 B = s.zw;\n        vec2 uv = (fragCoord.xy / iResolution.xy)*2.0 - 1.0;\n        vec2 m = (iMouse.xy / iResolution.xy);\n        \n        float L = length(U);\n        float l = length(uv);\n        \n        #ifdef SHOW_KERNEL\n        A = B;\n        #else\n        // center pixel of kernel, which is the integral of the entire image\n        float B_area = texelFetch(iChannel1, ivec2(iResolution.xy)/2, 0).z;\n        #if ((KERNEL == 3)||(KERNEL == 6)||(KERNEL == 8)) // controls its own intensity\n        B_area  = 1.0;\n        #endif\n        // convolution\n        A = mat2(B,-B.y,B.x) * A / B_area;\n        #endif\n    \n        fragColor = vec4(A,0,0);\n    } else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame % 4;\n    if (frame == 2) {\n        int M = int(iResolution.x);\n        float u = fragCoord.x - 0.5;\n        float iM = 1.0 / float(M);\n        vec2 result = vec2(0.0);\n        for (float i = 0.0; i < iResolution.x; ++i) {\n            float k = 6.28318530718*float(u)*float(i)*iM;\n            float m = mod(float(i) + float(int(iResolution.x)/2), iResolution.x);\n            vec4 d = texelFetch(iChannel0, ivec2(m+0.5,fragCoord.y), 0);\n            result += cmul(d.xy, k);\n        }\n        fragColor = vec4(result * iM, 0, 0);\n    } else if (frame == 3) {\n        int M = int(iResolution.y);\n        float v = fragCoord.y - 0.5;\n        float iM = 1.0 / float(M);\n        vec2 result = vec2(0.0);\n        for (float i = 0.0; i < iResolution.y; ++i) {\n            float k = 6.28318530718*float(v)*float(i)*iM;\n            float m = mod(float(i) + float(int(iResolution.y)/2), iResolution.y);\n            vec4 d = texelFetch(iChannel1, ivec2(fragCoord.x,m+0.5), 0);\n            result += cmul(d.xy, k);\n        }\n        fragColor = vec4(result * iM, 0, 0);\n    } else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame % 4;\n    int ch = (iFrame / 4) % 3;\n#ifdef SHOW_DFT\n    if ((frame == 2) && (ch == 0)) {\n        fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    } else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n#else\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if (frame == 3) {\n        fragColor[ch] = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    }\n#endif\n}\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGSW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 905]], "test": "untested"}
{"id": "NdySD3", "name": "hyperbolic paraboloid SDF∞", "author": "FabriceNeyret2", "description": "Ray marching an hyperbolic paraboloid  y = x² - z²\nWhen Euclidian distance is too hard to compute, ray-marching can simply use L∞ norm as well for the SDF.\n\nblack hole let for demo. Fix: uncomment #22 ( thanks mla ! )", "tags": ["raymarching", "sdf", "short"], "likes": 13, "viewed": 465, "published": 3, "date": "1635362659", "time_retrieved": "2024-07-30T18:52:37.139331", "image_code": "#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation\n//#define sqrt(v)  ( v < 0. ? 1e5 : sqrt(v) )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., x,y,z,a=.4; \n    vec3  R = iResolution, d,\n          D = normalize(vec3((U+U-R.xy)/R.y, -2.)),   // ray direction\n          p = vec3(0,0,3), q,                         // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )  \n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x),\n        x=q.x, y=q.y, z=q.z,\n        d = vec3(  sqrt(y/a +z*z) , a*(x*x -z*z), sqrt(x*x -y/a) ), // X and Z just re-express Y(X,Z)\n        d = abs( d - q ),                             // distance in each separated axes\n     // t = max( abs( a*(x*x -z*z) - y ) -.01,        // indeed, even d.y could be enough in some uses\n        t = max( min(d.x, min(d.y,d.z) ) -.01 ,       // SDF\n                 length(q.xz)-1. ),                   // clamp to disk\n     // t = min(t,100.), // [ uncomment to avoid the black hole :-) ]\n        p += .25*t*D;                                 // step forward = dist to obj\n        \n    if (O.a<0.) O  = texture(iChannel1, q );          // background\n    else        q  = sin(30.*q),\n                O *=  vec4( min( abs(q)/fwidth(q) , 1.), 0); // texture\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdySD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 153, 153, 1434]], "test": "untested"}
{"id": "fdyXW3", "name": "Figure8 logeps in s3", "author": "ollj", "description": "figure 8 uses complex number distance fields in s3.\nThis extreme distortion comes with extreme marching challenge.\na naive approach to that is logeps(), as in this shader.\na a smarter approach is to calculate the matrix of differentials to rescale lipschi", "tags": ["3d", "4d", "knot", "projective", "s3", "seifert"], "likes": 6, "viewed": 421, "published": 3, "date": "1635356908", "time_retrieved": "2024-07-30T18:52:38.077821", "image_code": "#define doLogEps\n// logeps break condition of https://www.shadertoy.com/view/tdXXzl\n\n//Daniel Piker 2021\n/* \nChanged to get the Seifert surface using (1/4πi) log (Q/Q∗)\n(added complex log line 85 and new field expression line 163)\n\nTrying here to show different valued Seifert fibers like in \nhttps://twitter.com/KangarooPhysics/status/1381380025568616459\n\n// Inigo Quilez 2021\n/*\n\nAn (appoximated) SDF that has a Figure-8 knot shape. It's not very\nsymmetric or pretty, but it counts (topologically).\n\nThe idea is described here https://arxiv.org/pdf/1610.02463.pdf and\ngoes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic\nprojection to land in a 4D hyper sphere S3, a subset of R4.\n\nIn R4 we define a function F that returns a R2 field (or\ntwo scalar fields, if you want). We find the zero isosurface\n(the nodal set, or roots) of F by zeroing its two components.\n\nBecause we are only evaluating the subset of R4 that lays on S3,\nwe are really computing the intersection of the isosurfce of F\nwith the surface of the sphere S3. This creates a curve on the surface\nof the sphere, which thanks to the stereographic projection we started\nwith becomes a curve in R3, our 3D space. That's the curve we are\nraymarching.\n\nThe R4 parameter to F can be grouped as two complex numbers u and v.\nAnd in the case of this shader I'm using\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. This curve is a figure 8 shape, as\ndescribed in the paper. You can change the SHAPE define below to\nsee another shape (a torus knot).\n\nLastly, there's more than one way to convert F into a R1 scalar field\nthan taking it's length |F|. For example, you can pass F through any\n2D SDF formula you want, such a square. Change the PROFILE define\nbellow to explore that.\n\n\nSee: https://www.shadertoy.com/view/tsBGzt\nSee: https://www.shadertoy.com/view/7sGSRd\n\n*/\n\n#define AA 1\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: something i made\n#define SHAPE 0\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 clog( vec2 z) {return vec2 (log(sqrt(z.x*z.x+z.y*z.y)),atan(z.y,z.x));}\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/articles/biplanar\nvec3 tex( sampler2D sam, in vec4 p, in vec4 n )\n{\n    n = n*n;\n    n = n*n;\n    vec3 col = vec3(0.0);\n    col += n.x*texture(iChannel0,p.yz).xyz;\n    col += n.y*texture(iChannel0,p.zw).xyz;\n    col += n.z*texture(iChannel0,p.wx).xyz;\n    col += n.w*texture(iChannel0,p.xy).xyz;\n    return col / (n.x+n.y+n.z+n.w);\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/24.0;\n    //float a = 0.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    // figure-8\n    vec2 a = vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v));\n    vec2 q = 64.0*cmul(u,csqr(u)) \n           - 12.0*cmul(u,a) \n           + 14.0*cmul(v,v) \n           + 14.0*csqr(conj(v)) \n           -      csqr(csqr(v)) \n           +      csqr(csqr(conj(v)));\n    return q;\n    #endif\n    \n    #if SHAPE==1\n    // torus\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n\n    #if SHAPE==2\n    // something I made\n    return    64.0*cmul(v,csqr(csqr(u)))\n           + 32.0*cmul(u,csqr(v))\n           + 32.0*csqr(v) \n           + 8.0;\n    #endif    \n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if PROFILE==0\n    //return length(phi) - 10.0;  \n    \n    //(1/4πi) log (Q/Q∗)  \n  //  return (length(cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))));    \n    return abs(mod(((cmul(vec2(0,0.785398163),clog(cdiv(phi,conj(phi))))).x + iTime/3.14159265359),6.28318530718) - 0.5);\n    \n    \n    #else\n    return sdRoundSquare( phi, 8.0, 0.5 );\n    #endif\n}\n\n// only used for texturing, not for distance-estimation\nvec4 field_grad( in vec4 q )\n{\n    float f = field(q);\n    const vec2 e = vec2(0.001,0.0);\n    return normalize(vec4(\n        field(q+e.xyyy),\n        field(q+e.yxyy),\n        field(q+e.yyxy),\n        field(q+e.yyyx))-f );\n}\n\nfloat map( in vec3 p )\n{\n\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        sh = min( sh, clamp(k*h/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        t += clamp(h,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\n\n//logEps() put into subroutine\n//, to toggle between various LOD-scales (distance field zoom levels)\n//, to make it toggleAble (sometimes a simpler end condition is better)\nbool logEps(float d,float s//t=distanceToCamera s=numberOfmarchingIterations\n){if(1./exp(d)<.01)return s<.001;//better for short distance reflections\n  //above line fails within a tensor-distorted gradient...\n  return log(d*d/s/1e5)>0. //long distance logeps for spinor /tdXXzl\n ;}\n\n\nfloat marchLog(inout vec3 pos, inout vec3 dir  ,float tmax     \n){\n ;float s=0.\n ;float d=0.;\n ;vec3 p=pos//+1.*dir\n //pos//+1.*dir is optional zNear, logeps is a bit bad when camera is close to a wall\n //, this is easily avoided\n //logeps() shines in LONG distances, not as much in short distances (within large lipschitz)\n //i have plans for a [logNeps], which should be better ingeneral average fractals\n ;for(float i=0.;i<2000.;i++ //logeps is fine with 4x as many iterations, it unlikely needs half of them.\n //r3_to_s3():  could need more than 40000 iterations, but will have much lower framerates on it.\n ){if(logEps(d,s))return d\n  ;s=map(p)\n  ;d+=s*.02\n  //smaller value for r3_to_s3(): https://www.shadertoy.com/view/7sVXWK\n  //than for 2 spinors: https://www.shadertoy.com/view/tdXXzl\n  ;p=pos+dir*d\n ;}return 0.;}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE>0\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n\n        // raymarch\n        const float tmax = 15.0;\n        #ifdef doLogEps\n        float t=marchLog(ro,rd,tmax);//child march loop function.\n        #else\n        float t = 0.0;\n        for( int i=0; i<8192; i++ ){ //parent march loop;\n            vec3 pos = ro + rd*t;\n            float d = map(pos);\n            if( d<0.001 ) break;\n            d = min(d*0.8,0.1);\n            t += d;\n            if( t>tmax ) break;} \n        #endif\n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        #ifdef doLogEps\n        if(map(ro+rd*t)<0.001 && t<tmax)//because logeps may end up in empty space on this much distortion\n       //t<tmax seems to NEVER be true for logeps, which is kinda sad.\n        #else\n        if( t<tmax)\n        #endif\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(  pos );\n            vec4 nor4 = field_grad( pos4 );\n            vec3 mate = tex(iChannel0,pos4,nor4);\n            mate = mate*mate;\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        \n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2227, 2227, 2248, 2248, 2260], [2261, 2261, 2279, 2279, 2336], [2337, 2337, 2356, 2356, 2388], [2389, 2582, 2601, 2601, 2677], [2679, 2834, 2864, 2864, 2919], [2920, 2920, 2950, 2950, 3020], [3021, 3021, 3042, 3042, 3088], [3089, 3089, 3111, 3111, 3198], [3199, 3199, 3220, 3220, 3245], [3246, 3246, 3276, 3276, 3376], [3377, 3377, 3397, 3397, 3453], [3454, 3575, 3610, 3610, 3675], [3676, 3790, 3849, 3849, 3935], [3936, 4043, 4092, 4092, 4358], [4458, 4458, 4486, 4486, 4674], [4676, 4676, 4705, 4705, 5304], [5306, 5306, 5332, 5332, 5733], [5735, 5791, 5821, 5821, 6015], [6017, 6017, 6041, 6041, 6392], [6394, 6440, 6486, 6486, 6683], [6685, 6730, 6779, 6779, 7103], [7105, 7105, 7147, 7147, 7431], [7434, 7607, 7686, 7686, 7888], [7891, 7891, 7957, 7957, 8716]], "test": "untested"}
{"id": "7sKSDV", "name": "Gaussian Filtered Checkerboard", "author": "oneshade", "description": "Applying a gaussion filter to a checkerboard.", "tags": ["2d", "blur", "filter", "checkerboard", "gaussian"], "likes": 6, "viewed": 167, "published": 3, "date": "1635348037", "time_retrieved": "2024-07-30T18:52:38.836793", "image_code": "// https://www.desmos.com/calculator/l3buctrt3l\n\n// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered checkerboard\n// Works for filter widths between 0 and 3\n// Increase k to allow for larger filter widths\nconst float k = 4.0; // k → ∞\nfloat gchecker(in vec2 p, in vec2 w) {\n    p = mod(p, 2.0);\n    float s = 1.0 - 2.0 * mod(k, 2.0);\n    float u = 0.0, v = 0.0;\n    for (float n=-k; n <= k; n++) {\n        u += s * erf((p.x - n) / w.x);\n        v += s * erf((p.y - n) / w.y);\n        s = -s;\n    }\n\n    return (1.0 - u * v) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 w = mix(vec2(0.001), vec2(0.5), 0.5 - 0.5 * vec2(cos(0.5 * iTime), sin(iTime)));\n    fragColor = vec4(gchecker(uv, w));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 81, 104, 104, 164], [166, 325, 363, 363, 622], [624, 624, 679, 679, 882]], "test": "untested"}
{"id": "7llXDj", "name": "Mandelbrot Sounds", "author": "incription", "description": "Sounds from the mandelbrot set!", "tags": ["fractal", "sound", "mandelbrot"], "likes": 3, "viewed": 387, "published": 3, "date": "1635338007", "time_retrieved": "2024-07-30T18:52:39.788248", "image_code": "\nfloat fractal(vec2 uv) {\n    vec2 c = uv;\n    vec2 z = vec2(0);\n    float i;\n    \n    float x2, y2 = 0.;\n    for(i = 0.; i < MAX_ITER; i++) {\n        if( x2 + y2 > 16. ) break;\n        \n        x2 = z.x * z.x;\n        y2 = z.y * z.y;\n        \n        z = vec2(x2 - y2, 2. * z.x * z.y) + c;\n    }\n    \n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = T(uv, iTime);\n    float i = fractal(uv);\n    \n    vec3 col = vec3(i/MAX_ITER);\n    \n    float d = length(uv - point(iTime));\n    if(d<0.01)col=vec3(1,0,0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "\n\nfloat fractal(vec2 c, float t) {\n    vec2 z = vec2(c);\n    float i;\n    \n    float x2, y2 = 0.;\n    float f = 0.;\n    for(i = 0.; i < MAX_ITER; i++) {\n        if( x2 + y2 > 16. ) break;\n        \n        f += sin(6.28*pow(2., length(z))*440.0*t);\n        \n        x2 = z.x * z.x;\n        y2 = z.y * z.y;\n        \n        z = vec2(x2 - y2, 2. * z.x * z.y) + c;\n    }\n    \n    return f / i;\n}\n\nfloat ao(vec2 c, float t, vec2 dt) {\n    float f = fractal(c, t);\n    \n    f += fractal(c-dt.x, t);\n    f += fractal(c+dt.x, t);\n    f += fractal(c-dt.y, t);\n    f += fractal(c+dt.y, t);\n    \n    f += fractal(c-dt.xx, t) * .5;\n    f += fractal(c+dt.xx, t) * .5;\n    f += fractal(c-dt.yy, t) * .5;\n    f += fractal(c+dt.yy, t) * .5;\n    \n    return f / 7.;\n}\n\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 p = point(time);\n    \n    float f = ao(p, time, vec2(1)/100000.);\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( f ) * 0.5;\n}", "sound_inputs": [], "common_code": "#define pcenter vec2(0.3, 0.5)\n#define MAX_ITER 150.\n\nvec2 T(vec2 uv, float t) {\n    return uv * vec2(3, 2) - vec2(2, 1);\n}\n\nvec2 point(float time) {\n    time *= 2.;\n    return vec2(sin(time)*0.2, cos(time)*0.2) - vec2(1,0);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 317], [319, 319, 376, 376, 639]], "test": "untested"}
{"id": "sdVXWK", "name": "hash density", "author": "FabriceNeyret2", "description": "top: hash density = 1 - length\nbottom right: average 8 values\nbottom left: analytic average", "tags": ["noise", "hash"], "likes": 7, "viewed": 277, "published": 3, "date": "1635334018", "time_retrieved": "2024-07-30T18:52:40.651939", "image_code": "#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y;\n\n#define H(s) vec4( hash( s+ U+iTime ) > length(U) )\n    O =   U.y > 0. ?   H()\n        : U.x > 0. ? ( H(.1)+H(.2)+H(.3)+H(.4)+H(.5)+H(.6)+H(.7)+H(.8) ) / 8.\n                   :   vec4(1. - length(U));\n    O = sqrt(O); // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 111, 111, 405]], "test": "untested"}
{"id": "NsVXDV", "name": "Fab27 #inktober2021 \"spark\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\ninspiration: see below", "tags": ["procedural", "2d", "noise", "perlin", "gradient", "lightning", "short", "inktober2021"], "likes": 49, "viewed": 2058, "published": 3, "date": "1635331868", "time_retrieved": "2024-07-30T18:52:41.654259", "image_code": "//reusing https://shadertoy.com/view/WdGXWG\n\nvoid mainImage( out vec4 O, vec2 U ) { O = T(U); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//reusing https://shadertoy.com/view/WdGXWG\n\n#define hash(p) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n\nfloat noise( vec2 p )                                // Perlin base noise ( grandient noise )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 p )                               // Perlin noise ( fractal noise )\n{\t\n    float v  = 0.,s = 1.;\n    for( int i=0; i++ < 7; s /= 2., p*=2. )\n        v += s* noise( p );\n    return v;\n}\n\n// -----------------------------------------------\n#define rot(a) mat2(cos(a + vec4(0,11,33,0) ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.* ( u+u -R ) / R.y;\n         \n    O = T(u) * vec4(.87,.8,.9,1);                    // reprint violet-fading prev frame.\n\n    U *= rot( 6.28*hash(vec2(floor(iTime*4.))).x );  // change direction every 1/4th second\n    \n    //      glow             noise changing more often with distance to center.\n    O += .01 / (abs( U.y - perlin(vec2(U.x, iFrame*int(1.+abs(U.x))/4)) * (.5+.3*U.x) ))\n             * smoothstep(-.1,0.,U.x);               // draw only one side\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "vec2 mainSound( int samp, float time )\n{\n    return vec2( min(.0,tan(6.28 *30.*time)) );\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 83, 83, 95]], "test": "untested"}
{"id": "NdVSDV", "name": "Snoopy and the Red Baron 2", "author": "dr2", "description": "Two famous characters locked in eternal conflict - updated", "tags": ["aircraft", "flight", "immersive", "peanuts"], "likes": 25, "viewed": 343, "published": 3, "date": "1635326128", "time_retrieved": "2024-07-30T18:52:42.608213", "image_code": "// \"Snoopy and the Red Baron 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Alternating flight paths; mouse in small window to switch views; mouse in right\n// top/bottom corners for closeups.\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat Maxv2 (vec2 p);\nfloat Minv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2e (vec2 p);\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define N_SEG 12\n\n#define N_FLYER  2\n\nmat3 flyerMat[N_FLYER];\nvec3 flyerPos[N_FLYER], qHit, sunDir, cPt[N_SEG], cPtOrg, cUpCirc, cDnCirc, oDir, oNorm;\nfloat tCur, dstFar, flyVel, tLen[N_SEG], rLoop, sHzRamp, rCirc, pathDir, vfLoop,\n   ptFac, grndScl, flSzFac;\nint idObj, idObjGrp, tpTrk, vuMode;\nbool isSh;\nconst int idFus = 1, idPipe = 2, idWngM = 3, idStrut = 4, idWngT = 5, idTail = 6, idLeg = 7,\n   idWhl = 8, idNose = 9, idGun = 10, idPlt = 11;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 ws;\n  float d, wr, h, qy;\n  int ig;\n  ig = idObjGrp / 256;\n  dMin /= flSzFac;\n  p /= flSzFac;\n  if (! isSh) d = PrRoundBoxDf (p, vec3 (1.2, 0.5, 1.1), 0.02);\n  if (isSh || d < dMin) {\n    q = p;\n    wr = -0.2 + q.z;\n    d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n       0.11 * (1. - 0.6 * wr * wr), 1.), 0.05);\n    d = max (d, - PrRoundBoxDf (q - vec3 (0., 0.16, 0.), vec3 (0.04, 0.03, 0.07), 0.04)); \n    DMINQ (idObjGrp + idFus);\n    q = p;  \n    q.yz -= vec2 (0.17, 0.5);\n    d = PrCylDf (q, 0.015, 0.15);\n    DMINQ (idObjGrp + idGun);\n    q = p;  \n    q.y -= 0.17;\n    d = PrSphDf (q, 0.04); \n    DMINQ (idObjGrp + idPlt);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.1, 0.03, 0.8);\n    d = PrCapsDf (q, 0.02, 0.15);\n    DMINQ (idObjGrp + idPipe);\n    q = p;\n    q.yz -= vec2 (0.03, 1.1);\n    d = PrConeDf (q, vec3 (0.8, 0.6, 0.06));\n    DMINQ (idObjGrp + idNose);\n    q = p;\n    q.yz -= vec2 (((ig == 1) ? 0.12 : 0.09), 0.4);\n    qy = q.y;\n    if (ig == 1) q.y += 0.12;\n    h = (ig == 1) ? 0.24 : 0.42;\n    q.y = mod (q.y, h) - 0.5 * h;\n    d = min (1.2 - abs (q.x), abs (PrBox2Df (vec2 (abs (q.x) - 1., q.z + 0.2), vec2 (0.25, 0.05))));\n    wr = 0.47;\n    h = (q.z - 0.1) / wr;\n    d = max (SmoothMax (PrCaps2Df (vec2 (q.y, q.z + 0.25), 0.03 * (wr - h * h), wr), - d, 0.01),\n       - q.z - 0.22);\n    d = max (d, abs (qy) - 0.26);\n    q.y = qy;\n    DMINQ (idObjGrp + idWngM);\n    q = p;\n    q.yz -= vec2 (((ig == 1) ? 0.12 : 0.09), 0.42);\n    q.xz = abs (q.xz) - vec2 (0.5, 0.1);\n    d = PrCylDf (q.xzy, 0.01, ((ig == 1) ? 0.24 : 0.21));\n    DMINQ (idObjGrp + idStrut);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.1, ((ig == 1) ? 0.24 : 0.15), 0.42);\n    d = PrCylDf (q.xzy, 0.01, ((ig == 1) ? 0.12 : 0.15));\n    DMINQ (idObjGrp + idStrut);\n    q = p;\n    q.z -= -0.9;\n    wr = 0.33;\n    h = (q.z - 0.05) / wr;\n    q.x = abs (q.x);\n    d = min (0.42 - q.x, abs (q.z + 0.06));\n    d = max (SmoothMax (PrCaps2Df (vec2 (q.y, q.z + 0.18), 0.03 * (wr - h * h), wr), - d, 0.01),\n       - q.z - 0.14);\n    d = max (d, 0.02 - 1.5 * q.x - q.z);\n    DMINQ (idObjGrp + idWngT);\n    q = p;\n    wr = 0.28;\n    q.yz -= vec2 (-0.1, -0.98);\n    h = (q.z - 0.1) / wr;\n    d = min (0.24 - abs (q.y - 0.3), abs (PrBox2Df (vec2 (q.y - 0.35, q.z + 0.02), vec2 (0.16, 0.04))));\n    d = SmoothMax (PrCaps2Df (vec2 (q.x, dot (q.zy, sin (0.1 * pi + vec2 (0.5 * pi, 0.)))),\n       0.03 * (wr - h * h), wr), - d, 0.01);\n    d = max (d, - q.z - 0.04);\n    DMINQ (idObjGrp + idTail);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.135, -0.24, 0.7);\n    q.xy = Rot2D (q.xy, -0.55);\n    q.yz = Rot2D (q.yz, 0.15);\n    d = PrCylDf (q.xzy, 0.012, 0.12);\n    DMINQ (idObjGrp + idLeg);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.22, -0.34, 0.715);\n    d = PrCylDf (q.yzx, 0.01, 0.035);\n    DMINQ (idObjGrp + idLeg);\n    q.x -= 0.01;\n    d = PrCylDf (q.yzx, 0.1, 0.015);\n    DMINQ (idObjGrp + idWhl);\n  } else dMin = min (dMin, d);\n  return flSzFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    if (vuMode == 0 || vuMode == k + 1) {\n      idObjGrp = (k + 1) * 256;\n      dMin = FlyerDf (flyerMat[k] * (p - flyerPos[k]), dMin);\n    }\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  isSh = true;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  isSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / flSzFac;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    if (vuMode == 0 || vuMode == k + 1) {\n      idObjGrp = (k + 1) * 256;\n      q = flyerMat[k] * (p - flyerPos[k]) / flSzFac - vec3 (0., 0.02, 1.07);\n      d = PrCylDf (q, 0.3, 0.007);\n      DMINQ (0);\n    }\n  }\n  return flSzFac * dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GrndDf (vec3 p)\n{\n  vec3 q;\n  float d, hb, hn, hf, a, r, vs;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    hb = sqrt (r) / (2. * pi);\n    vs = 40.;\n    hf = (r > 1.4) ? 2.5 * hb * mix (Fbm2e (vs * vec2 (hb, a + 1.)), Fbm2e (vs * vec2 (hb, a)), a) : 0.;\n    hn = (r > 1.8) ? 0. : 0.03 * Fbm2e (8. * q.xz) * (1. - smoothstep (1.4, 1.8, r));\n    d = q.y - hn - mix (hb, hf, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r);\n    d = max (r - 20., d);\n  }\n  return grndScl * d;\n}\n\nfloat GrndDfN (vec3 p)\n{\n  return GrndDf (p) - 0.8 * Fbm2 (0.5 * p.xz);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDfN (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat Insig (vec2 p, int ig)\n{\n  float s;\n  if (ig == 2) s = (1. - SmoothBump (0.08, 0.12, 0.005, length (p))) *\n     (1. - SmoothBump (-0.01, 0.03, 0.005, length (p)));\n  else s = 1. - SmoothBump (0.03, 0.06, 0.005, length (abs (p) - 0.07));\n  return s;\n}\n\nvec4 FlyerCol (int ig, int id, vec3 vn)\n{\n  vec4 col4;\n  vec2 w;\n  float s;\n  col4 = (ig == 2) ? vec4 (0.9, 0.9, 0.2, 0.2) : vec4 (0.9, 0.2, 0.2, 0.2);\n  if (id == idFus) {\n    if (qHit.z > 1.01) {\n      col4 = vec4 (0.9, 0.9, 0.9, 0.3);\n      if (length (abs (qHit.xy + vec2 (0., 0.05)) * vec2 (0.6, 1.)) < 0.03) col4.rgb *= 1. -\n         0.7 * SmoothBump (0.2, 0.8, 0.05, mod (64. * ((ig == 1) ? qHit.y : qHit.x), 1.));\n    }\n    w = abs (qHit.xz) - vec2 (0.09, 0.12);\n    if (abs (qHit.y - 0.1) < 0.04 && Maxv2 (w) < 0.) col4.rgb = vec3 (0.2, 0.15, 0.05);\n    col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (1.5 * qHit.yz + vec2 (0., 0.4), ig));\n  } else if (id == idWngM) {\n    col4.rgb = mix (col4.rgb, 1. - col4.rgb, step (0., qHit.z - 0.14 - 0.07 *\n       abs (sin ((8./1.2) * pi * qHit.x))));\n    s = 1.2 / 8.;\n    s = mod (qHit.x + 0.5 * s, s) - 0.5 * s;\n    col4.rgb *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, s);\n    if (abs (qHit.y) > 0.1 && qHit.y * vn.y > 0.) {\n      col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (vec2 (abs (qHit.x) - 0.9, qHit.z), ig));\n    }\n  } else if (id == idWngT) {\n    col4.rgb = mix (col4.rgb, 1. - col4.rgb, step (0., qHit.z - 0.11 - 0.03 *\n       abs (sin (17. * pi * qHit.x))));\n    s = 1. / 17.;\n    s = mod (qHit.x + 0.5 * s, s) - 0.5 * s;\n    col4.rgb *= 1. + 0.1 * SmoothBump (-0.005, 0.005, 0.001, s);\n  } else if (id == idTail) {\n    col4.rgb = mix (1. - col4.rgb, col4.rgb, Insig (2.5 * qHit.yz + vec2 (-0.9, -0.25), ig));\n  } else if (id == idNose) {\n    col4 = (qHit.z > -0.04) ? mix (col4, vec4 (1., 1., 1., 0.5), 0.5) : vec4 (0.1);\n  } else if (id == idPipe) {\n    col4 = vec4 (0.8, 0.8, 0.85, 0.3) * (0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.05,\n       mod (16. * qHit.z, 1.)));\n  } else if (id == idStrut || id == idLeg) {\n    col4.rgb = 0.6 * col4.rgb + vec3 (0.4);\n  } else if (id == idGun) {\n    col4.rgb = vec3 (0.6, 0.6, 0.7);\n  } else if (id == idPlt) {\n    col4 = vec4 (0.4, 0.2, 0.1, 0.);\n    if (qHit.z > 0.02 && qHit.y < 0.03) col4.rgb = (ig == 2) ? vec3 (0.9) : vec3 (0.6, 0.4, 0.4);\n    if (qHit.z > 0. && length (vec2 (abs (qHit.x) - 0.011, qHit.y - 0.015)) < 0.01)\n       col4 = vec4 (0., 0.2, 0., 0.2);\n    if (qHit.z > 0. && ig == 2 && length (qHit.xy - vec2 (0., -0.02)) < 0.012)\n       col4.rgb = vec3 (0.1);\n  } else if (id == idWhl) {\n    if (length (qHit.yz) > 0.07) col4 = vec4 (0.05);\n  }\n  return col4;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  rd.y = abs (rd.y);\n  q = 0.01 * (ro.xz + 0.5 * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.2, 0.8, ff);\n  fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  sd = max (dot (rd, sunDir), 0.);\n  skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) * min (0.3 * pow (sd, 64.) +\n     0.5 * pow (sd, 2048.), 1.);\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.7), skCol, 0.3 + 0.7 * fd), clCol, 0.1 + 0.9 * f * fd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, roo;\n  float dstObj, dstGrnd, sh;\n  int ig, id;\n  roo = ro;\n  isSh = false;\n  dstGrnd = (vuMode == 0) ? GrndRay (ro, rd) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      ig = idObj / 256;\n      id = idObj - 256 * ig;\n      col4 = FlyerCol (ig, id, ((ig == 1) ? flyerMat[0] : flyerMat[1]) * vn);\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn =  GrndNf (ro);\n      col = mix (vec3 (0.2, 0.4, 0.1), vec3 (0., 0.5, 0.), clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.));\n      col = mix (vec3 (0.6, 0.6, 0.7) * (0.7 + 0.3 * Noisefv2 (4. * vec2 (length (ro.xz), ro.y))),\n         col, smoothstep (0.5, 0.8, vn.y));\n      col *= 0.1 + 0.9 * max (0., max (dot (vn, sunDir), 0.));\n    }\n  } else {\n    col = (vuMode == 0) ? SkyCol (ro, rd) : vec3 (0.2);\n  }\n  if (TrObjRay (roo, rd) < min (min (dstGrnd, dstObj), dstFar)) col = mix (col,\n     mix (vec3 (1.), vec3 (0.8), step (0.02, abs (length (qHit.xy) - 0.26))), 0.2);\n  return clamp (col, 0., 1.);\n}\n\nvoid PathSetup ()\n{\n  float hTop, sHzStr, sDnRamp, sUpRamp;\n  ptFac = 20.;\n  cPtOrg = vec3 (2. * pathDir, 0., -3.);\n  hTop = 1.5;\n  rLoop = 2.2;\n  sHzRamp = 1.;\n  rCirc = 2.;\n  sDnRamp = 1.5;\n  sUpRamp = 1.3 * sDnRamp;\n  sHzStr = sDnRamp - sUpRamp + 3. * sHzRamp;\n  vfLoop = 0.3;\n  cDnCirc = cPtOrg + vec3 (- rCirc * pathDir, 0., -2. * sHzRamp);\n  cUpCirc = cPtOrg + vec3 (- rCirc * pathDir, 2. * hTop, 2. * sDnRamp + 6. * sHzRamp);\n  cPt[0] = cDnCirc;   cPt[0].xz += vec2 (- rCirc * pathDir, sHzStr);\n  cPt[1] = cPt[0];    cPt[1].z += sHzStr;\n  cPt[3] = cUpCirc;   cPt[3].x -= rCirc * pathDir;\n  cPt[4] = cUpCirc;   cPt[4].x += rCirc * pathDir;\n  cPt[2] = cPt[3];    cPt[2].z -= 2. * sHzRamp;\n  cPt[5] = cPt[4];    cPt[5].z -= 2. * sHzRamp;\n  cPt[7] = cPtOrg;\n  cPt[8] = cPtOrg;\n  cPt[6] = cPt[7];    cPt[6].z += 4. * sHzRamp;\n  cPt[9] = cDnCirc;   cPt[9].x += rCirc * pathDir;\n  cPt[10] = cDnCirc;  cPt[10].x -= rCirc * pathDir;\n  cPt[11] = cPt[0];\n  tLen[0] = 0.;\n  for (int k = 1; k < N_SEG; k ++) tLen[k] = length (cPt[k] - cPt[k - 1]);\n  tLen[4] = pi * rCirc;\n  tLen[8] = 2. * pi * rLoop * (1. + vfLoop);\n  tLen[10] = pi * rCirc;\n  for (int k = 1; k < N_SEG; k ++) tLen[k] += tLen[k - 1];\n}\n\nvec3 TrkPos (float t)\n{\n  vec3 r;\n  vec2 cs;\n  t *= 0.05 / (2. * pi);\n  t = mod (t, 1.);\n  cs = sin (2. * pi * t + vec2 (0.5 * pi, 0.));\n  r.xz = vec2 (1., cs.y);\n  r.xz = 40. * cs.x * r.xz / dot (r.xz, r.xz) + vec2 (1., - 5.);\n  r.y = 10. + 2. * sin (2. * pi * t);\n  return r;\n}\n\nvoid FlyerPM1 (float t, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, acc, va, flVd, fpF, fpB;\n  vec2 cs;\n  float oRl, dt;\n  if (vuMode == 0) {\n    dt = 0.2;\n    flPos = TrkPos (t);\n    fpF = TrkPos (t + dt);\n    fpB = TrkPos (t - dt);\n    vel = (fpF - fpB) / (2. * dt);\n    acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n    va = cross (acc, vel) / length (vel);\n    flVd = normalize (vel);\n    oRl = 2. * length (va) * sign (va.y);\n    oRl = smoothstep (0.01, 0.03, abs (oRl)) * oRl;\n    cs = sin (oRl + vec2 (0.5 * pi, 0.));\n    flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n       mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n  } else {\n    flPos = vec3 (0.);\n    flMat = mat3 (1., 0., 0., 0., 1., 0., 0., 0., 1.);\n  }\n}\n\nvoid FlyerPM2 (float t, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 p, p1, p2, u;\n  vec2 cs;\n  float w, ft, ftt, s, h, oRl;\n  int ik;\n  h = 2. * sin (0.43 * pi * t) + sin (0.79 * pi * t);\n  oRl = 0.01 * pi * h;\n  t = mod (t, tLen[N_SEG - 1]);\n  for (int k = 1; k < N_SEG; k ++) {\n    if (t < tLen[k]) {\n      t -= tLen[k - 1];\n      p1 = cPt[k - 1];\n      p2 = cPt[k];\n      w = tLen[k] - tLen[k - 1];\n      ik = k;\n      break;\n    }\n  }\n  oNorm = vec3 (0., 1., 0.);\n  ftt = t / w;\n  ft = ftt;\n  if (ik == 4 || ik == 10) oRl += -0.25 * pi * SmoothBump (0.05, 0.95, 0.05, ft);\n  if (ik == 4) oRl += 2. * pi * smoothstep (0.4, 0.6, ft);\n  if (ik == 2 || ik == 6) {\n    oDir = p2 - p1;\n    p.xz = p1.xz + oDir.xz * ft * vec2 (pathDir, 1.);\n    p.y = p1.y + oDir.y * smoothstep (0., 1., ft);\n    oDir.y *= 6. * ft * (1. - ft);\n    oDir = normalize (oDir);\n  } else if (ik == 4) {\n    ft *= pi;\n    p = cUpCirc;\n    u = vec3 (- cos (ft) * pathDir, 0., sin (ft));\n    p.xz += rCirc * u.xz;\n    oDir = cross (oNorm, u);\n    oDir.xz *= pathDir;\n  } else if (ik == 8) {\n    ft = (ft < 0.5) ? ft * (1. + vfLoop * (1. - 2. * ft)) :\n       ft * (1. + 2. * vfLoop * (ft - 1.5)) + vfLoop;\n    p = 0.5 * (cPt[7] + cPt[8]);\n    ft *= 2. * pi;\n    u = vec3 (0., cos (ft), sin (ft));\n    p.yz += rLoop * (vec2 (1., 0.) - u.yz);\n    oNorm = u;\n    oDir = normalize (vec3 (0., 2. * pi * rLoop * vec2 (sin (ft), - cos (ft))));\n  } else if (ik == 10) {\n    ft *= pi;\n    p = cDnCirc;\n    u = vec3 (cos (ft) * pathDir, 0., - sin (ft));\n    p.xz += rCirc * u.xz;\n    oDir = cross (oNorm, u);\n    oDir.xz *= pathDir;\n  } else {\n    oDir = p2 - p1;\n    p = p1 + oDir * ft;\n    oDir = normalize (oDir);\n  }\n  p *= ptFac;\n  p.y += 2. + 0.1 * h;\n  p.y += 8.;\n  flPos = p;\n  if (vu > 0.) {\n    oDir *= -1.;\n    oRl *= -1.;\n  }\n  oRl += 0.2 * (Fbm1 (t) - 0.5) * SmoothBump (0.1, 0.9, 0.1, ftt);\n  cs = sin (oRl * pathDir + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) * AxToRMat (oDir, oNorm);\n}\n\nvec3 VuPos (float t)\n{\n  vec3 p, df;\n  float b, r, a, tb;\n  df = flyerPos[1] - flyerPos[0];\n  b = 3.;\n  r = 4.;\n  p = vec3 (0., 1. + 1.5 * sin (0.1 * pi * t), 0.);\n  t = 8. * mod (t / (2. * (b + pi * r)), 1.);\n  t = floor (t) + smoothstep (0.9, 1., fract (t));\n  t = 2. * (b + pi * r) * t / 8.;\n  tb = 0.5 * pi * r;\n  a = -1.;\n  if (t < tb) {\n    a = t / r;\n    p.x = 0.5 * b;\n  } else if (t < tb + b) {\n    p.xz = vec2 (tb + 0.5 * b - t, r);\n  } else if (t < 3. * tb + b) {\n    a = 0.5 * pi + (t - (tb + b)) / r;\n    p.x = -0.5 * b;\n  } else if (t < 3. * tb + 2. * b) {\n    p.xz = vec2 (t - (3. * tb + 1.5 * b), - r);\n  } else {\n    a = 1.5 * pi + (t - (3. * tb + 2. * b)) / r;\n    p.x = 0.5 * b;\n  }\n  if (a >= 0.) p.xz += r * sin (a + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2D (p.xz, - atan (- df.z, df.x));\n  p += 0.5 * (flyerPos[1] + flyerPos[0]);\n  return p;\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 e;\n  e = vec2 (1., 0.);\n  uv *= 2.;\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 4.) *\n     (4. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr;\n  vec3 flPos, ro, rd, vd, col;\n  vec2 canvas, uv, mMid, ut, mSize, msw;\n  float az, el, zmFac, asp, sr, tCyc;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  vuMode = 0;\n  if (mPtr.z > 0. && Minv2 (vec2 (mPtr.x, abs (mPtr.y)) + 0.04 * vec2 (1. / asp, 1.) - 0.5) > 0.)\n     vuMode = (mPtr.y > 0.) ? 1 : 2;\n  if (vuMode == 0) {\n    mSize = (1./5.) * vec2 (asp, 1.);\n    mMid = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (-1., -1.);\n    ut = abs (uv - mMid) - mSize;\n    regId = -1;\n    if (mPtr.z > 0.) {\n      regId = 0;\n      msw = 2. * mPtr.xy - mMid / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1;\n        msw /= 2. * mSize.y;\n      }\n      if (regId == 0) msw = mPtr.xy;\n      msw *= smoothstep (0.01, 0.1, abs (msw));\n    }\n    vuId = 0;\n    if (Maxv2 (ut) < 0.) {\n      uv = (uv - mMid) / mSize.y;\n      vuId = 1;\n    }\n    if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n    tCyc = 60.;\n    tpTrk = (length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01,\n       mod (tCur / tCyc, 1.))) ? 2 : 1;\n    if (tpTrk == 1) {\n      flyVel = 2.;\n      for (int k = 0; k < N_FLYER; k ++) FlyerPM1 (tCur * flyVel + ((k == 0) ? 0. : 2.),\n        flyerPos[k], flyerMat[k]);\n    } else {\n      flyVel = 1.;\n      pathDir = (mod (tCur / tCyc, 2.) > 1.) ? 1. : -1.;\n      PathSetup ();\n      for (int k = 0; k < N_FLYER; k ++) FlyerPM2 (tCyc * mod (tCur / tCyc, 1.) * flyVel + \n         ((k == 0) ? 0.15 : 0.4), 0., flyerPos[k], flyerMat[k]);\n      FlyerPM2 (tCyc * mod (tCur / tCyc, 1.) * flyVel, 0., flPos, flMat);\n    }\n    ro = vec3 (1., 10., 1.);\n    vd = 0.5 * (flyerPos[0] + flyerPos[1]) - ro;\n    az = 0.;\n    el = 0.;\n    zmFac = 3.;\n    if (tpTrk == 1) {\n      if (vuId == 1) {\n        ro = VuPos (0.1 * tCur);\n        vd = 0.5 * (flyerPos[0] + flyerPos[1]) - ro;\n      } else {\n        zmFac = 6. + 0.2 * length (vd);\n      }\n    } else {\n      if (vuId == 1) {\n        ro = flPos + 0.3 * oNorm + 0.2 * cross (oNorm, oDir) * sin (0.1 * pi * tCur);\n      } else {\n        zmFac = 6. + 0.2 * length (vd);\n      }\n    }\n    if (tpTrk == 1 || vuId != 1) {\n      az = 0.5 * pi + atan (- vd.z, vd.x);\n      el = asin (vd.y / length (vd));\n    }\n    if (vuId == regId) {\n      msw *= smoothstep (0., 0.03, length (msw));\n      az += 0.5 * pi * msw.x;\n      el += 0.25 * pi * msw.y;\n    }\n    vuMat = StdVuMat (el, az);\n    grndScl = 100.;\n    dstFar = 10. * grndScl;\n    sunDir = normalize (vec3 (cos (0.01 * tCur), 2., - sin (0.01 * tCur)));\n    flSzFac = 0.5;\n  } else {\n    for (int k = 0; k < N_FLYER; k ++) FlyerPM1 (0., flyerPos[k], flyerMat[k]);\n    az = 0.6 * pi + 2. * pi * mod (0.02 * tCur, 1.);\n    el = 0.15 * pi * sin (0.1 * pi * tCur);\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * vec3 (0., 0., -8.);\n    zmFac = 7.;\n    dstFar = 120.;\n    sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n    flSzFac = 1.;\n  }\n  col = vec3 (0.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    if (vuMode == 0 && tpTrk == 2 && vuId == 1) rd = rd * flMat;\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (vuMode == 0) {\n    col += GlareCol (rd, flMat * sunDir * vuMat, uv);\n    if (mPtr.z > 0. && Maxv2 (abs (uv)) < 0.05 && Minv2 (abs (uv)) < 0.005)\n       col = mix (col, vec3 (1., 1., 0.1), 0.3);\n    if (Maxv2 (ut) < 0. && Minv2 (abs (ut)) * canvas.y < 2.) col = vec3 (0.5, 0.1, 0.1);\n  }\n  if (mPtr.z > 0. && vuId == 0 && regId == 0 && min (uv.x - asp, abs (uv.y) - 1.) > -0.08)\n     col = mix (col, vec3 (1., 1., 0.1), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y), vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2e (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.96875);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSDV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1564, 1564, 1600, 1600, 4576], [4578, 4578, 4600, 4600, 4846], [4848, 4848, 4881, 4881, 5064], [5066, 5066, 5087, 5087, 5342], [5344, 5344, 5381, 5381, 5641], [5643, 5643, 5667, 5667, 6007], [6009, 6009, 6044, 6044, 6228], [6230, 6230, 6253, 6253, 6784], [6786, 6786, 6810, 6810, 6859], [6861, 6861, 6895, 6895, 7383], [7385, 7385, 7407, 7407, 7662], [7664, 7664, 7694, 7694, 7920], [7922, 7922, 7963, 7963, 10306], [10308, 10308, 10340, 10340, 11035], [11037, 11037, 11072, 11072, 12437], [12439, 12439, 12458, 12458, 13635], [13637, 13637, 13660, 13660, 13916], [13918, 13918, 13975, 13975, 14671], [14673, 14673, 14740, 14740, 16684], [16686, 16686, 16708, 16708, 17547], [17549, 17549, 17592, 17592, 18038], [18082, 18082, 18138, 18138, 22178], [22180, 22180, 22212, 22212, 22312], [22314, 22314, 22347, 22347, 22436], [22438, 22438, 22484, 22484, 22531], [22533, 22533, 22566, 22566, 22593], [22595, 22595, 22637, 22637, 22688], [22690, 22690, 22733, 22733, 22797], [22799, 22799, 22843, 22843, 22903], [22905, 22905, 22938, 22938, 23011], [23013, 23013, 23035, 23035, 23062], [23064, 23064, 23086, 23086, 23113], [23115, 23115, 23160, 23160, 23252], [23254, 23254, 23299, 23299, 23337], [23339, 23339, 23396, 23396, 23479], [23481, 23481, 23517, 23517, 23723], [23725, 23725, 23759, 23759, 23921], [23923, 23923, 23953, 23953, 24066], [24100, 24100, 24124, 24124, 24177], [24179, 24179, 24203, 24203, 24315], [24317, 24317, 24342, 24342, 24488], [24490, 24490, 24515, 24515, 24701], [24703, 24703, 24725, 24725, 24879], [24881, 24881, 24902, 24902, 25056], [25058, 25058, 25080, 25080, 25236]], "test": "untested"}
{"id": "fsVSWV", "name": "rainbow pseudo voronoi thingy", "author": "_samuelcho_", "description": "The minimum distant to points give voronoi. Coloring the distance fields. ", "tags": ["voronoi", "colorful"], "likes": 7, "viewed": 310, "published": 3, "date": "1635320107", "time_retrieved": "2024-07-30T18:52:43.610533", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 5.0;\n\n    vec2 p1 = vec2(sin(iTime*0.6942),cos(iTime*0.4269));\n    vec2 p2 = vec2(cos(iTime*0.888+0.8989),sin(iTime*0.666+69.69));\n    vec2 p3 = vec2(cos(iTime*1.069428+69.8989),sin(iTime*0.96942+55.88));\n    \n    \n    float d1 = length(uv-p1);\n    float d2 = length(uv-p2);\n    float d3 = length(uv-p3);\n    \n    d1 = sin(d1+iTime*0.9);\n    d2 = sin(d2+iTime*0.8);\n    d3 = sin(d3 + iTime*0.87);\n    \n    float d = min(d1,d2);\n    d = min(d,d3);\n    \n    \n    \n    vec3 col = vec3(0);\n   \n    col = palette(\n    d*0.5,\n    vec3(0.5),\n    vec3(.5),\n    vec3(1.),\n    vec3(.0,.1,.2));\n    col = mix(col, palette(d*0.5,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)), d2 *0.5+0.5);\n    col = mix(col, palette(d*0.5,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.0,.0)), d1*0.5+0.5);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 115], [117, 117, 174, 174, 1058]], "test": "untested"}
{"id": "fdVSWV", "name": "terrain colorramp simplification", "author": "Arrangemonk", "description": "working on simplifying a colorramp", "tags": ["colorramp"], "likes": 3, "viewed": 204, "published": 3, "date": "1635318570", "time_retrieved": "2024-07-30T18:52:44.512123", "image_code": "    #define pi 3.141592653589\n    #define tau 6.28318530718\n    vec3 bot = vec3(15., 110., 161.)/255.;\n    vec3 mid1 =vec3(150., 252., 227.) /255.;\n    vec3 mid2 = vec3(250., 252., 227.) /255.;\n    vec3 top = vec3(28., 150.,  74.)/255.;\n    \nconst vec3 biome[] = vec3[](    \nvec3( 15., 110., 161.) /255.,\nvec3( 77., 178., 179.) /255.,\nvec3(150., 252., 227.) /255.,\nvec3(250., 252., 227.) /255.,\nvec3( 28., 150.,  74.) /255.\n);\n\n//https://www.shadertoy.com/view/Xt23zV\nfloat linearstep(float edge0, float edge1, float x)\n{\n    return  clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n    \n    \n    vec3 rampBiome(float x){\n    vec3 col = biome[0];\n    float step_size = 1./(float(biome.length())-1.);\n    for(int i = 0; i < biome.length()-1; i++){\n        col =mix(col, biome[i+1], linearstep(float(i)*step_size, (float(i)+1.)*step_size, x));\n    }\n    return col;\n}\n\nfloat Mask(float x){\n    x= x -.5;\n    return .5+sign(.5*(.25 -x*x))*.5;\n}\n\nvec3 colorramp(float x)\n{\n     x = mix(x,x*x,.5);\n\n     vec3 col =   mix( bot,mid1,x * 3.)     * Mask(x*3.);\n     col +=       mix(mid1,mid2,x * 3. -1.) * Mask(x*3. -1.);\n     return col + mix(mid2, top,x * 3. -2.) * Mask(x*3. -2.);\n}\n\nvec3 colorramp2(float inx)\n{   \n    inx = clamp(inx,.0001,.9999);\n    float x = 2.* inx * inx;\n     vec3 col = (.4 + .4*cos((1.-x)*vec3(4,2,1)))*Mask(x) \n     + (.4 + .4*cos((x-1.)*vec3(2,1.25,2)))*Mask(x-1.);\n     col = mix(vec3(.4,.7,.6),mix(col, col*col,.5)*2.,.5);\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n     vec3 col = colorramp2(uv.x);\n     if(uv.y > .33)\n     col = colorramp(uv.x);\n      if(uv.y > .66)\n     col = rampBiome(uv.x);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 468, 521, 521, 583], [868, 868, 888, 888, 942], [944, 944, 969, 969, 1178], [1180, 1180, 1208, 1208, 1467], [1469, 1469, 1526, 1526, 1732]], "test": "untested"}
{"id": "NdKSWV", "name": "Gaussian Filtered Segments", "author": "oneshade", "description": "Applying a gaussian filter to a piecewise linear function.", "tags": ["filter", "1d", "linear", "gaussian", "segments", "weierstrass", "piecwise"], "likes": 11, "viewed": 209, "published": 3, "date": "1635314793", "time_retrieved": "2024-07-30T18:52:45.310987", "image_code": "// https://www.desmos.com/calculator/mfzpsbbyqn\n// Similar to the Weierstrass transform (https://en.wikipedia.org/wiki/Weierstrass_transform)\n// Piecewise linear functions can be filtered by adding up gseg() for each segment\n// Demoing a recreation of the example on the wikipedia page\n\n// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered segment\n// 1/sqrt(pi) ≈ 0.5641895\nfloat gseg(in float x, in vec2 a, in vec2 b, in float w) {\n    float p = (x - a.x) / w, q = (x - b.x) / w;\n    float m = (b.y - a.y) / (b.x - a.x) * w;\n    float y = (erf(p) - erf(q)) * (m * p + a.y);\n    y += (exp(-p * p) - exp(-q * q)) * 0.5641895 * m;\n    return y / 2.0;\n}\n\nfloat f(in float x, in float w) {\n    float y = gseg(x, vec2(0.0, 4.5), vec2(5.0, 4.5), w); // Segment from (0, 4.5) to (5, 4.5)\n    y += gseg(x, vec2(5.0, 4.5), vec2(10.0, -4.5), w); // Segment from (5, 4.5) to (10, -4.5)\n    return y;\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 12.0 + vec2(5.0, 0.25);\n    float unit = 20.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Filter width\n    float w = mix(0.001, 5.0, 0.5 - 0.5 * cos(0.5 * iTime));\n\n    // Plot\n    float y = f(uv.x, w);\n    float dydx = (f(uv.x + 0.001, w) - y) / 0.001;\n    drawSDF(abs(uv.y - y) / sqrt(1.0 + dydx * dydx), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 319, 342, 342, 402], [404, 461, 519, 519, 737], [739, 739, 772, 772, 977], [1059, 1059, 1114, 1114, 1546]], "test": "untested"}
{"id": "fdyXWK", "name": "Figure-8 Knot (Implicit in R4)", "author": "iq", "description": "A figure-8 knot, as described here: [url]https://arxiv.org/pdf/1610.02463.pdf[/url].", "tags": ["3d", "4d", "knot", "projective"], "likes": 31, "viewed": 916, "published": 3, "date": "1635314093", "time_retrieved": "2024-07-30T18:52:46.283387", "image_code": "/* Inigo Quilez 2021\n\nAn appoximated SDF for a Figure-8 knot. The idea is described here\nhttps://arxiv.org/pdf/1610.02463.pdf and goes like this:\n\nFrom R3, our regular 3D space, we do an inverse stereographic projection\nto land in a 4D hyper sphere S3, a subset of R4. Here in R4 we define a\nfunction F that returns a R2 field (or two scalar fields, if you want).\nThen we find its zero isosurface (nodal set). Because we are only\nevaluating the subset of R4 that lays on S3, we are really computing the\nintersection of the isosurface of F with the sphere S3. This creates a\ncurve on the sphere, which thanks to the stereographic projection becomes\na curve in R3, our 3D space. That's the curve we are raymarching. Now,\nthe R4 domain of F can be grouped as two complex numbers u and v. In the\ncase of the figure 8 knot,\n\nF(u,v) = 64v³ − 12v(3+2u²−2u*²) − (14u²+14u*²+u⁴-u*⁴)\n\nwhere u* is the conjugate of u. Finally, texturing happens in spherical\ncoordinates on S3 itself, with becomes a regular 3D texturing problem.\n\nYou can change the SHAPE define below to see other shapes. Also, there\nare more than one way to convert F into a R1 scalar field than taking\nits length |F|. For example, you can pass F through any 2D SDF formula\nyou want, such a square. Change the PROFILE define bellow to explore that.\n\nSee also: https://www.shadertoy.com/view/tsBGzt\nSee also: https://www.shadertoy.com/view/7sGSRd                        */\n\n// antialiasing. Can set to 2 if you have a fast machine\n#define AA 1\n\n// 0: figure 8\n// 1: torus 5-2\n// 2: clifford torus\n// 3: something I made\n// 4: some other shape I made\n#define SHAPE 0\n\n// 0: circular\n// 1: square\n#define PROFILE 0\n\n// 0: distance estimation in R3 (pos)\n// 1: distance estimation in R1 (t), equivalent to Newtwon-Raphson\n#define METHOD 1\n\n//------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n//------------------------------------------------------------\n// complex number operations\n//------------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n//------------------------------------------------------------\n// https://en.wikipedia.org/wiki/Stereographic_projection\nvec4 inversestereographic(vec3 p)\n{\n    float r2 = 1.0+dot(p,p);\n    return vec4(2.0*p,r2-2.0)/r2;\n}\n//------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n//------------------------------------------------------------\n// texture a 4D sphere, |p|=1\nvec3 tex( sampler2D sam, in vec4 p )\n{\n    // https://en.wikipedia.org/wiki/N-sphere#Spherical_coordinates\n    vec3 q = acos(p.xyz/vec3(length(p.xyzw),\n                             length(p.yzw),\n                             length(p.zw) ));\n                             \n    // here we could do actual 3D texturing, but instead,\n    // i hacked three 2D texture projections\n    vec3 col = vec3(0.0);\n    col  = texture(sam,q.xy).xyz;\n    col += texture(sam,q.yz).xyz;\n    col += texture(sam,q.zx).xyz;\n    col = col/3.0;\n    \n    // adjust contrast a bit to match source texture\n    col *= 0.5+col*(1.5-col);\n\n    // srgb to linear\n    return col*col;\n}\n//===============================================================================================\n\nvec4 r3_to_s3( in vec3 p )\n{\n    vec4 q = inversestereographic(p);\n    \n    // rotate in yw\n    float a = iTime*6.283185/6.0;\n    q.yw *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    \n    return q;\n}\n\nvec2 F( in vec2 u, vec2 v )\n{\n    #if SHAPE==0\n    return  64.0*cmul(u,csqr(u)) \n          - 12.0*cmul(u,vec2(3.0,0.0) - 2.0*csqr(v) + 2.0*csqr(conj(v))) \n          + 14.0*cmul(v,v) \n          + 14.0*csqr(conj(v)) \n          -      csqr(csqr(v)) \n          +      csqr(csqr(conj(v)));\n    #endif\n    \n    #if SHAPE==1\n    return 20.0*(cmul(u,csqr(csqr(u))) + csqr(v));\n    #endif    \n    \n    #if SHAPE==2\n    return 32.0*(cmul(u,conj(u))-cmul(v,conj(v)));\n    #endif    \n\n    #if SHAPE==3\n    return  64.0*cmul(v,csqr(csqr(u)))\n          + 32.0*cmul(u,csqr(v))\n          + 32.0*csqr(v) \n          + 8.0;\n    #endif    \n\n    #if SHAPE==4\n    float h = u.x*u.x - u.y*u.y + v.x*v.x - v.y*v.y;\n    return vec2(u.y*u.y*u.y + v.y*v.y*h,  u.x*u.x*v.x + u.y*v.x*h)*32.0;\n    #endif\n\n}\n\nfloat field( in vec4 q )\n{\n    vec2 phi = F(q.xy,q.zw);\n    \n    #if SHAPE==4\n    const float th = 1.0;\n    #else\n    const float th = 10.0;\n    #endif\n    \n    #if PROFILE==0\n    return length(phi) - th;\n    #else\n    return sdRoundSquare( phi, 0.8*th, 0.05*th );\n    #endif\n}\n\nfloat map( in vec3 p )\n{\n    return field(r3_to_s3(p));\n}\n\nfloat distance_map( in vec3 p )\n{\n    float d = field(r3_to_s3(p));\n\n    // could do some automatic differentiation here...\n    float eps = 0.0001;\n    vec3 g = (vec3(field(r3_to_s3(p+vec3(eps,0.0,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,eps,0.0))),\n                   field(r3_to_s3(p+vec3(0.0,0.0,eps))))-d)/eps;\n    \n    // distance estimator\n    return d/length(g);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    const float tmax = 5.0;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        #if METHOD==0\n        float f = distance_map(pos);\n        sh = min( sh, clamp(k*f/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        #else\n        float f = map(pos);\n        sh = min( sh, clamp(0.02*k*f/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        const float eps = 0.001;\n        float df = (map(ro+rd*(t+eps))-f)/eps;\n        f = f/abs(df);\n        #endif\n        \n\n        t += clamp(f,0.001,0.1);\n        if( t>tmax ) break;\n    }\n    return sh;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( distance_map(pos+nor*0.001+kv*h*2.0)*1.0, 0.0, 1.0 );\n\t}\n\tao /= 32.0;\n\t\n\treturn clamp( ao*1.5-0.1, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    // camera movement\t\n    float an = -0.0*iTime/20.0;\n    vec3 ro = vec3( 5.0*sin(6.283185*an), 4.0, 5.0*cos(6.283185*an) );\n    #if SHAPE==1\n    ro.xz *= 1.5;\n    ro.y = 0.0;\n    #endif\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n        \n        vec3 col = vec3(0.0);\n        col = vec3(0.05 + 0.05*rd.y);\n        \n        // raymarch\n        if( map(ro)>0.0 )\n        {\n        const float tmax = 15.0;\n        float t = 0.0;\n        for( int i=0; i<8192; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            \n            #if METHOD==0\n            float f = distance_map(pos);\n            if( abs(f)<0.001 ) break;\n            float dt = f;\n            #else\n            float f = map(pos);\n            if( abs(f)<0.001 ) break;\n            const float eps = 0.001;\n            float df = (map(ro+rd*(t+eps))-f)/eps;\n            float dt = f/abs(df);\n            #endif\n            \n            t += clamp(dt,-0.1,0.1);\n            if( t>tmax ) break;\n        }\n            \n\n        if( t<tmax )\n        {\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            // we do texturing in R4\n            vec4 pos4 = r3_to_s3(pos);\n            vec3 mate = tex(iChannel0,pos4);\n            mate *= 0.3;\n\n            // sun\n            {\n            vec3 lig = normalize(vec3(1.0,1.0,0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            if( dif>0.001 ) dif *= shadow(pos+nor*0.001, lig, 48.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = pow(clamp(dot(nor,hal),00.,1.0),32.0);\n            spe *= 0.04 + 0.96*pow( clamp(1.0-dot(lig,hal), 0.0, 1.0), 5.0 );\n            spe *= 10.0;\n\n            col  = 0.6*mate*vec3(9.0,8.0,7.0)*dif;\n            col += spe*dif*mate.x*10.0;\n            \n            float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n            col += mate*fre*1.0*(0.25+0.75*dif)*vec3(1.0,0.7,0.4);\n            }\n            \n            // sky\n            {\n            vec3 ref = reflect(rd,nor);\n            float dif = 0.5+0.5*nor.y;\n            float spe = smoothstep(0.3,0.5,ref.y);\n            spe *= dif;\n            spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n            if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref, 8.0);\n            col += 3.0*occ*mate*dif*vec3(0.5,0.6,1.0)*1.5;\n            #if METHOD==1\n            spe *= 2.0;\n            #endif\n            col += 1.0*spe;\n            }\n\n            // sun bounce\n            col += mate*(1.0-occ)*vec3(1.2,0.5,0.2)*0.2;\n        }\n        }\n\n        // gain\n        col = col*1.5/(1.0+col);\n        \n        // to gamma space\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1989, 1989, 2010, 2010, 2022], [2023, 2023, 2041, 2041, 2098], [2099, 2099, 2118, 2118, 2150], [2151, 2344, 2363, 2363, 2439], [2440, 2595, 2625, 2625, 2680], [2681, 2681, 2711, 2711, 2781], [2782, 2782, 2803, 2803, 2849], [2850, 2850, 2872, 2872, 2959], [2960, 2960, 2981, 2981, 3006], [3007, 3007, 3037, 3037, 3137], [3138, 3259, 3294, 3294, 3359], [3360, 3474, 3533, 3533, 3619], [3620, 3713, 3751, 3819, 4367], [4467, 4467, 4495, 4495, 4661], [4663, 4663, 4692, 4692, 5440], [5442, 5442, 5468, 5468, 5719], [5721, 5721, 5745, 5745, 5778], [5780, 5780, 5813, 5813, 6163], [6165, 6211, 6257, 6257, 6454], [6456, 6501, 6550, 6550, 7156], [7158, 7158, 7200, 7200, 7493]], "test": "untested"}
{"id": "NsKXWK", "name": "Gaussian Filtered Triangle Wave", "author": "oneshade", "description": "Testing a gaussian filtered triangle wave.", "tags": ["filter", "approximation", "waveform", "gaussian", "trianglewave"], "likes": 5, "viewed": 156, "published": 3, "date": "1635311812", "time_retrieved": "2024-07-30T18:52:47.135110", "image_code": "// https://www.desmos.com/calculator/q94xrjnumr\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color, 1.0);\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    uv = (uv - 0.5) * 1.5 + 0.5; // Scale 1.5x\n\n    float unit = 3.0 / iResolution.y; // 2x pixel size\n\n    float w = 0.501 - 0.5 * cos(0.25 * iTime); // Filter width\n    float x = uv.x + iTime;\n\n    // Graph\n    float y = gtri(x, w);\n    float dydx = (gtri(x + 0.001, w) - y) / 0.001;\n    float dist = abs(uv.y - y) / sqrt(1.0 + dydx * dydx);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(unit, 0.0, dist));\n\n    // Undo scale\n    uv = (uv - 0.5) / 1.5 + 0.5;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(int samp, float time) {\n    return vec2(makeNoise(time));\n}", "sound_inputs": [], "common_code": "// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered triangle wave\n// Works for filter widths between 0 and 1\n// Increase k to allow for larger filter widths\nconst float k = 4.0; // k → ∞\nfloat gtri(in float x, in float w) {\n    x = mod(x, 2.0);\n\n    float v = 0.5641895 * w; // w/sqrt(pi)\n    float s = 1.0 - 2.0 * mod(k, 2.0);\n    float y = (2.0 * k + 1.0) * mod(k, 2.0) - k;\n    for (float n=-k; n <= k; n++) {\n        float p = x - n, u = p / w;\n        y += (p * erf(u) + v * exp(-u * u)) * s;\n        s = -s;\n    }\n\n    return y;\n}\n\nfloat makeNoise(in float time) {\n    return gtri(time * 200.0, 0.501 - 0.5 * cos(0.25 * time));\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 127, 230, 230, 495], [497, 497, 552, 574, 1865]], "test": "untested"}
{"id": "NdKXWK", "name": "入门之路-9", "author": "jialouluo", "description": "纹理", "tags": [], "likes": 4, "viewed": 210, "published": 3, "date": "1635308295", "time_retrieved": "2024-07-30T18:52:47.900064", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    float time = iTime*0.1;\n\n    st = st - 0.5;\n\n    float r = length(st);\n    float a = atan(st.y, st.x);\n\n    float sides = 30.;\n    float ma = mod(a, 6.28/sides);\n    ma = abs(ma - 3.14/sides);\n\n    st = r * vec2(cos(ma), sin(ma));\n    st = fract(st+time);\n\n    vec4 color = vec4(st.x,st.y,0.0,1.0);\n    color = smoothstep(0.0,1.0,texture(iChannel0,st)) *(1.-smoothstep(0.0,1.0,texture(iChannel1,st)));\n    fragColor = color;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 596]], "test": "untested"}
{"id": "7syXDV", "name": "入门之路-8", "author": "jialouluo", "description": "分型布朗运动 +  noise \nps:我说这是云 谁赞成谁反对 QAQ", "tags": [], "likes": 6, "viewed": 266, "published": 3, "date": "1635304387", "time_retrieved": "2024-07-30T18:52:48.816614", "image_code": "\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nvec2 random2(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat snoise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random2(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random2(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random2(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random2(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\n#define FBM_COUNT  5\nfloat fbm(vec2 st){\n\n    float result =0.0;//输出值\n    float A = 0.5;//振幅\n    mat2 rotate = mat2(cos(0.5),sin(0.5),//旋转矩阵\n                        -sin(0.5),cos(0.5));\n    for(int i= 0;i<FBM_COUNT;i++){//分型布朗运动核心\n        result += A * noise(st);\n        st *=2.;//频率2倍\n        st *= rotate;\n        A *=0.5;//振幅1/2倍\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=3.;\n    vec2 st = vec2(0.0);\n    st.x = fbm(uv +  iTime *0.112);\n    st.y = fbm(uv);\n    vec2 st2 =vec2(0.0);\n    st2.x = fbm(st + uv + iTime *0.15);\n    st2.y = fbm(st + uv + iTime *0.26);\n    float f = fbm(st + st2);\n    vec3 color = vec3(clamp(f*f,0.0,1.0),clamp(mix(0.6784,0.6345,f*f*(f-2.0)),0.0,1.0),clamp(f*f*4.0,0.0,1.0));\n    color = mix(color,vec3(0.1543,0.4345,0.7533),f*f*0.76);\n    color = mix(color,vec3(0.68777,0.0,0.7),clamp(length(st2.x),0.0,1.0));\n    color = mix(color,vec3(0.1543,1.,1.),clamp(length(st),0.0,1.0));\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.0);\n    \n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 137], [138, 138, 165, 165, 510], [511, 511, 538, 538, 719], [720, 720, 742, 759, 1325], [1347, 1347, 1366, 1366, 1732], [1733, 1733, 1790, 1790, 2433]], "test": "untested"}
{"id": "7sGXDV", "name": "triangle_atan ", "author": "yyf1994", "description": "triangle", "tags": ["triangle"], "likes": 2, "viewed": 239, "published": 3, "date": "1635301155", "time_retrieved": "2024-07-30T18:52:49.627446", "image_code": "#define PI  3.14\n\nvec3 drawTriangle( vec2 uv , vec2 origin  ,float height , float radius  ){\n  vec2 point = uv - origin ;\n  float h = point.y ;\n  float r = abs( atan(point.x , point.y) ) ;\n  if(  h < height && r < radius ){\n        return  vec3(1.0);\n  }\n  return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 result = drawTriangle(uv , vec2(0.5 , 0.5) , 0.2 , PI/4.0  );\n    fragColor =  vec4(result , 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 92, 92, 276], [279, 279, 336, 336, 526]], "test": "untested"}
{"id": "ssySDV", "name": "truchet 3d -basic v2", "author": "jorge2017a2", "description": "truchet 3d -basic v2", "tags": ["truchet3dbasicv2"], "likes": 41, "viewed": 467, "published": 3, "date": "1635298704", "time_retrieved": "2024-07-30T18:52:50.436283", "image_code": "//por jorge2017a1=jorge2017a2 :)\n#define MAX_STEPS 110\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat Hash21(vec2 p)\n{   p=fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.26);\n    return fract(p.x*p.y);\n}\n\nvec4 truchet( in vec2 uv )\n{   uv= rotatev2(uv, radians(45.0));\n    vec3 col=vec3(0.0);\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n    float n=Hash21(id); //rango 0.0 a 1.0\n    float width=0.1;\n\n    if(n<0.5) gv.x*=-1.0;\n\n    //----------\n    /// Tip Shane....9/jun/2021\n    float d=abs(gv.x + gv.y)*.7071; // Diagonal line.\n    gv = abs(gv) - .5; // Corners.\n    d = min(d, abs(gv.x + gv.y)*.7071); \n    //----------\n    float  mask= d-width;\n    float r = pow(1.0-sqrt( d),1.5 );\n    float g = pow(1.0-sqrt( d),1.5 );\n    float b = 1.0*(r+g);\n    col+=vec3(r,g-0.8,b-0.8)*mask;\n    return vec4(col,mask);\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    vec3 pp=p;\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n    p.y= opRep1D(p.y,40.0) ;\n   vec4 t1= truchet(p.xy*0.65);\n    float  d1=sdBox( p, vec3(20.0,20.0,1.0) ); \n    float d2= sdBox( p-vec3(0.0,0.0,3.0), vec3(20.0,20.0,2.0)  );\n    float inter1= intersectSDF( d1,t1.w);\n    float uni=unionSDF(d2, inter1);\n    res =opU3(res, vec3(uni,1.0,-1.0));\n   return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    \n   \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n         vec3 r = reflect(rd, norm);\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh+=occlusion(hit,r);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}    \n    \n        \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*3.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 20.0, -5.0 ); light_color1=vec3( 0.5 );\n \tlight_pos2= vec3( -20.0, 10.0, 30.0 ); light_color2 =vec3(1.0,0.0,0.0); \n \n   vec3 ro=vec3(0.0,5.0+t,-7.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(-30.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};   \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 526, 526, 610], [612, 656, 703, 703, 730], [731, 731, 774, 774, 801], [802, 802, 850, 850, 878], [879, 917, 953, 953, 998], [1000, 1065, 1099, 1099, 1195], [1196, 1196, 1230, 1230, 1321], [1322, 1322, 1356, 1356, 1447], [1448, 1448, 1482, 1482, 1577], [1579, 1579, 1601, 1601, 1688], [1690, 1690, 1718, 1718, 2305], [2308, 2308, 2333, 2333, 2789], [2791, 2791, 2815, 2815, 2977], [2979, 2979, 3028, 3028, 3695], [3698, 3698, 3734, 3734, 3979], [3981, 3981, 4008, 4008, 4025], [4027, 4027, 4063, 4063, 4155], [4156, 4156, 4202, 4202, 4327], [4329, 4329, 4366, 4366, 4642], [4644, 4644, 4711, 4711, 4988], [4990, 4990, 5073, 5073, 6081], [6084, 6084, 6177, 6177, 6307], [6309, 6309, 6341, 6341, 6538], [6541, 6541, 6634, 6634, 6805], [6807, 6807, 6838, 6838, 7463], [7465, 7465, 7491, 7491, 7601], [7603, 7603, 7661, 7661, 7713], [7715, 7715, 7772, 7772, 8350]], "test": "untested"}
{"id": "ssGSDK", "name": "Raymarching Basic Visualizer", "author": "Yusef28", "description": "just a simple visualizer with coloring based on iq's 2d sdf shaders\n[Mouse enabled]", "tags": ["2d", "visual"], "likes": 11, "viewed": 298, "published": 3, "date": "1635288642", "time_retrieved": "2024-07-30T18:52:51.269057", "image_code": "#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define FAR 10.\n#define circlePos vec2(cos(iTime)*0.6,-0.9)\n#define squarePos vec2(.9,sin(iTime)*0.4)\n#define S(d) 1.-smoothstep(-eps,+eps, abs(d)-0.01)\n\n#define purp vec3(159,174,216)/255.\n#define blu vec3(160,132,179)/255.\n#define pink vec3(0.9,0.6,0.6)\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n    \nfloat drawPoint(vec2 uv, vec2 p, float r){\n     return 1.-smoothstep(r-eps, r+eps, length(uv - p));\n}\n\nfloat distLine(vec2 p, vec2 A, vec2 B){\n  vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    return smoothstep(r+eps, r-eps, distLine(uv,A,B));\n}\n\nfloat map(vec2 p){\n    float c = length(p - circlePos)-0.2;\n    vec2 sp = abs(p-squarePos);\n    float s = max(sp.x,sp.y)-0.2;\n    return min(s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    \n    vec2 ro = vec2(-0.8,0.);\n    vec2 rd = normalize(vec2(1.,0.2));\n    float a = iTime/3.;\n    //rd *= rot(a);\n    \n    if(iMouse.z > 0.5) \n        rd = normalize((iMouse.xy*2.-iResolution.xy)/iResolution.y);\n    \n   // col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n      \n    //raymarcher\n    float t = 0., d; vec2 last, next; //last and next pos for drawing lines\n    next = ro + rd*t;\n    float mapDistances = map(uv);\n    float gradient = mapDistances;\n    /*\n    //call map once to get the distances\n    \n    col = vec3(.7) - sign(mapDistances)*vec3(0.1,0.6,0.7);\n    float gradient = mapDistances;//smoothstep(0.1,0.4,abs(fract(mapDistances*15.)-0.5));\n    //draw the map distance as a repeating gradient\n    col = mix(col, vec3(0.1),//cos(vec3(1.,2.,5.)),\n    //-mapDistances*0.1, \n    gradient);\n    */\n    \n    //based on iq's coloring style\n    col = sign(gradient)*purp;\n    col = mix(col, blu, clamp(1.-sign(gradient),0.,1.));\n\tcol *= clamp(pow(gradient,0.6),0.,1.);\n\tcol *= 0.7 + 0.3*cos(130.0*gradient);\n    //draw the map objects as smooth outlines\n    col = mix(col, vec3(1.), S(mapDistances));                     \n    col = mix(col, vec3(0.8,0.,0.3),drawPoint(uv,ro,0.02));\n    \n\n    \n    \n    //basic ray marcher                   \n    for(float i = 0.; i < 10.; i ++){\n        \n        d = map(next);\n        if(d < 0.001 || t > FAR) break;\n        \n        t += d*0.75;\n        \n        last = next;\n        next = ro + rd*t;\n        \n        //draw line from last to next\n        col = mix(col, vec3(1.,0.,0.), drawLine(uv,last,next,0.01));\n        //draw point at next\n        col = mix(col, vec3(1.,0.,0.),drawPoint(uv,next,0.02));\n        //draw circle based on d, distance to hit the map\n        col = mix(col, vec3(0.,0.2,0.7)*2., S(length(uv - last)-d));\n    }\n    \n    // Output to screen\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \n    \n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGSDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 325, 325, 383], [394, 394, 436, 436, 495], [497, 497, 536, 536, 653], [655, 655, 704, 704, 761], [763, 763, 781, 781, 911], [913, 913, 970, 1020, 3188]], "test": "untested"}
{"id": "sdyXRV", "name": "Contour Detector", "author": "Remming_Senegal", "description": "detects the main colors of an image by first looking for the edges then blurring everything inside each of the edges.\n\nKind of laggy though, with only 35.6 as opposed to the holy 60.0 fps, so any ideas to speed this up are appreciated", "tags": ["pixel", "camera", "camera", "sampling", "contour", "passes", "detail", "channels", "vec2", "orientation"], "likes": 7, "viewed": 354, "published": 3, "date": "1635282396", "time_retrieved": "2024-07-30T18:52:52.042988", "image_code": "#define BLUR_RADIUS 0.2\n#define PRECISION 0.01\n#define SKIP 5.0\n\n// Uncomment the line below just to view the edge detection buffer\n//#define JUST_BLUR\n\n/*\n    Detects contours in an image\n    \n    HOW IT WORKS:\n        -detect for edges, which is done in buffer A\n        -Start blurring in a radial pattern.\n        -When we hit a pixel that's white, it's an edge.\n        -Stop blurring once we hit an edge\n        -Move on to next pixel\n        \n        -Makes nice solid colors that cut off at edges\n*/\n\n#ifndef JUST_BLUR\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 blurred;\n    float i;\n    for(i = 0.0; i < BLUR_RADIUS / PRECISION; i += PRECISION) {\n        vec2 point = vec2(i*cos(i*SKIP),i*sin(i*SKIP));\n        point *= PRECISION;\n        point += uv;\n        \n        vec4 sampled;\n        if(texture(iChannel1,point).rgb == vec3(1.0)) {\n            break;\n        }\n        sampled = texture(iChannel0,point);\n        blurred += sampled;\n    }\n   \n    blurred *= PRECISION;\n    blurred /= i;\n \n    fragColor = blurred;\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel1,uv);\n}\n#endif", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    Edge Detector\n    Looks for contrast difference in surrounding pixels\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = 1.0/iResolution.x;\n    float y = 1.0/iResolution.y;\n\n    // Edge map\n    vec4 m = texture(iChannel0,uv);\n    \n    vec4 N = texture(iChannel0,uv+vec2(0.0,y));\n    vec4 S = texture(iChannel0,uv+vec2(0.0,-y));\n    vec4 W = texture(iChannel0,uv+vec2(x,0.0));\n    vec4 E = texture(iChannel0,uv+vec2(-x,0.0));\n    \n    vec4 mN = abs(m - N);\n    vec4 mS = abs(m - S);\n    vec4 mW = abs(m - W);\n    vec4 mE = abs(m - E);\n    \n    vec4 contrast = mN + mS + mW + mE;\n    contrast /= 4.0;\n    \n    float col = (contrast.r + contrast.g + contrast.b)/3.0;\n    \n    // Filter out the Contrast values we don't need\n    // TODO: find minimum contrast to cut out using existing image\n    if(col < 0.03) \n        col = 0.0;\n    else col = 1.0;\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdVSWy", "name": "sea of balls: shader LOD", "author": "FabriceNeyret2", "description": "mid: analytical scene average\ncf \"Fake fur rendering\" [url]https://www.researchgate.net/publication/220721859_Fake_fur_rendering[/url]\n& \"Real-time Realistic Rendering and Lighting of Forests\" [url]https://hal.inria.fr/hal-00650120[/url]\nmouse: camera", "tags": ["raymarching", "voronoi", "worley", "short"], "likes": 7, "viewed": 346, "published": 3, "date": "1635266058", "time_retrieved": "2024-07-30T18:52:52.903686", "image_code": "#define rot(a) mat2(cos(a+vec4(0,11,33,0))) // --- utils from https://www.shadertoy.com/view/llySRh\n#define H(p)   fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvec4   lum = vec4(0,1,0,0),           // balls color on lit side\n      shad = vec4(0,0,1,0),           // balls color on shadow side\n        bg = vec4(1,0,0,0);           // background color\nfloat r = .3;                         // spheres radius\n      \nfloat map(vec3 q) {                   // --- scene  SDF ----------------\n    q *= 2.;\n    vec2 I = floor(q.yx), F = fract(q.yx), D;\n    float d, l=9.;\n    for( int k=0; k < 9; k++ )        // find closest seed within neihbors\n        D = vec2(k%3,k/3) -1.,\n        d = length( D + H(I+D) - F ), // offset to seed\n        l = min(l,d);                 // keep closest dist\n    return length(vec2(l,q.z)) - r;   // sphere SDF\n}\n\nvoid mainImage(out vec4 O, vec2 U)    // --- renderer ----------------\n{\n    vec3 R = iResolution;\n    U = (U+U-R.xy)/R.y;\n    float t=9., i; \n    vec3  N, e = vec3(1,-1,0)/1e2, \n          D = normalize(vec3(U, -2.)),                 // ray direction\n          p = vec3(0,-2,22),                           // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.2,0);\n    p.yz *= rot(.5-6.3*M.y),                           // rotations\n    p.xz *= rot(-6.3*M.x);\n    D.yz *= rot(.5-6.3*M.y),\n    D.xz *= rot(-6.3*M.x);\n    if (D.z*p.z>0.) { O=vec4(1); return; }             // sky\n\n    if ( abs(U.x) < .5 ) {                        // --- analytical average\n         t = -p.z/D.z;\n         if ( t < 0. ) { O = bg; return; }\n         p += t*D;                                     // ray-trace to plane\n         N = vec3(0,0,1);                              // plane normale\n         float d = 3.14*r*r,                           // sphere density\n               a = 1.- pow( 1.-d, 1./ abs(dot(N,D)) ), // apparent density\n               s = ( 1.+ D.x ) / 2. ; // D.x: dot(D,L) // sphere apparent shadowing proportion\n         O = mix( bg, mix( lum, shad, s ), a );        // compose contributions\n      }\n    else {     \n        for ( i=0.; i<200. && t>.01; i++ )        // --- explicit rendering\n            t = min(9., map(p)),                       // SDF\n            p += .25*t*D;                              // step forward = dist to obj\n\n        if (i<200.)                                    // hit\n             N = normalize(   map(p+e.xyy)/e.xyy +  map(p+e.yxy)/e.yxy // https://iquilezles.org/articles/normalsSDF\n                            + map(p+e.yyx)/e.yyx +  map(p+e.xxx)/e.xxx ),\n             O = N.x > 0. ? lum : shad;                // toon shading\n          // O = vec4( .3 + .7*max(0.,N.x) );          // ambient + diffuse\n        else O = bg;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 451, 504, 857], [859, 859, 931, 931, 2805]], "test": "untested"}
{"id": "7sKXDG", "name": "sea of balls", "author": "FabriceNeyret2", "description": "using the Worley/Voronoi seed-per-cell trick\n\nMouse controls camera.", "tags": ["raymarching", "voronoi", "worley", "short"], "likes": 21, "viewed": 551, "published": 3, "date": "1635253149", "time_retrieved": "2024-07-30T18:52:53.667644", "image_code": "// utils from https://www.shadertoy.com/view/llySRh\n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))                          // rotation\n#define H(p)     fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat map(vec3 q, out vec2 _I) {      // --- scene. return SDF, out = ID.\n    vec2 I = floor(q.yx), F = fract(q.yx), D,H;\n    float d, l=9.;\n    for( int k=0; k < 9; k++ )        // find closest seed within neihbors\n        D = vec2(k%3,k/3) -1.,\n        H = H(I+D+.5),                // motion parameters\n        d = length( D + H(I+D) - F    // offset to seed\n                      + .8*cos( 15.*iTime*(H.y-.5) + 6.3*H.x + vec2(0,11) ) // seed rotation\n                  ),\n        d < l ? l = d, _I = I+D : I;  // keep closest dist + its id.\n    return length(vec2(l,q.z)) - .3;\n}\n\nvoid mainImage(out vec4 O, vec2 U)    // --- renderer\n{\n    float t=9.; \n    vec3  R = iResolution, N, e = vec3(1,-1,0)/1e2, \n          D = normalize(vec3((U+U-R.xy)/R.y, -2.)),   // ray direction\n          p = vec3(0,-2,22), q,                       // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.12,0); \n    vec2 C;\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )  \n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                      // rotations\n        q.xz *= rot(-6.3*M.x),\n        t = map(q,C),                                 // SDF\n        p += .25*t*D;                                 // step forward = dist to obj\n\n    O *= hue(H(C).x);                 // coloring from ID\n                                      // optional: true shading\n    if (O.a>0.) N = normalize(   map(q+e.xyy,C)/e.xyy +  map(q+e.yxy,C)/e.yxy\n                               + map(q+e.yyx,C)/e.yyx +  map(q+e.xxx,C)/e.xxx ),\n                O *= vec4( .3 + .7*max(0.,N.z) )*1.3;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 312, 353, 863], [865, 865, 920, 920, 1916]], "test": "untested"}
{"id": "fsySWG", "name": "truchet 3d", "author": "drschizzo", "description": "truchet test", "tags": ["raymarching", "truchet"], "likes": 2, "viewed": 273, "published": 3, "date": "1635251321", "time_retrieved": "2024-07-30T18:52:54.436587", "image_code": "float N21(vec2 p){\n    p+=12.245;\n    p=fract(p*vec2(1.432342,515.5621));\n    p+=dot(p,p+341.3535);\n    return fract(p.x*p.y*.12);\n    \n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float r=length(q)-t.y;\n  return min(r,length(vec3(abs(p.x),p.y,abs(p.z))-vec3(.17,0,.18))-.06);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat crossTorus(vec3 p,vec3 id){\n    float w=.035;\n    \n    float t1=sdTorus(vec3(abs(p.x)-.5,p.z,abs(p.y)-.5),vec2(.25,w));\n    //t1=min(t1,length(p-vec3(.25,-.25,-.25))-.2);\n       \n\n\n    float t2=sdTorus(vec3(abs(p.x)-.5,p.z,p.y),vec2(.25,w));\n    t2=min(t2,sdTorus(vec3(p.x,p.z,abs(p.y)-.5),vec2(.25,w)));\n   \n\n\n    float r=N21(id.xy+id.z+floor(iTime/3.));\n    float rn=N21(id.xy+id.z+floor(iTime/3.)+1.);\n    float t=r>.5?t1:t2;\n    float tn=rn>.5?t1:t2;\n    \n    return mix(t,tn,smoothstep(.8,.9,fract(iTime/3.)));\n\n    \n}\n\nfloat cube(vec3 p, vec3 id){\n    \n    float c=cos(1.57);\n    float s=sin(1.57);\n    mat2 m=mat2(c,s,-s,c);\n    vec2 a=p.yz*m;\n    vec2 b=p.xz*m;\n    float t=min(crossTorus(p,id),crossTorus(vec3(p.x,a.x,a.y),id));\n    t=min(crossTorus(vec3(a.x,p.y,b.y),id),t);\n    return max(sdBox(p,vec3(.52)),t);\n}\n\nvec3 transform(inout vec3 p){\n    float c=cos(sin(iTime/10.));\n    float s=sin(sin(iTime/10.));\n    \n    mat2 m=mat2(c,s,-s,c);\n    p.xy*=m;\n    vec3 op=p;\n    vec3 r=vec3(1.);\n    p=fract(p)-.5;\n    return floor(op-p); \n}\n\nfloat dist(vec3 p){\n    \n    vec3 id=transform(p);   \n    float cu=cube(p,id);\n       \n    return cu;\n}\n\nvec3 normal(vec3 p){\n    vec2 e=vec2(.001,0.0);\n    float d=dist(p);\n    vec3 n=vec3(\n        d-dist(p-e.xyy),\n        d-dist(p-e.yxy),\n        d-dist(p-e.yyx));\n    return normalize(n);\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float d=0.;\n    float td=0.;\n    float i=0.;;\n    for(;i<50.;i++){\n        d=dist(ro+td*rd);\n        td+=d;\n        if(td>50. || d<.001)\n            break;\n    }\n    if(i>50.)\n        return 50.;\n    return float(td);    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    for( float t=.001; t<100.; )\n    {\n        float h = dist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 shade(vec3 p,vec3 rd){\n    vec3 n=normal(p);\n    \n    \n    vec3 id=transform(p); \n    \n    vec3 col=vec3(.15,.55,.80);\n    //WIP color mix\n    vec3 col1=normalize(.5+.5*sin(iTime/2.+col*(id.x+id.y*10.)));\n    vec3 col2=normalize(.5+.5*sin(iTime/2.+col*((id.x+1.)+id.y*10.)));\n    vec3 col3=normalize(.5+.5*sin(iTime/2.+col*((id.x-1.)+id.y*10.)));\n    vec3 col4=normalize(.5+.5*sin(iTime/2.+col*((id.x)+(id.y-1.)*10.)));\n    vec3 col5=normalize(.5+.5*sin(iTime/2.+col*((id.x)+(id.y+1.)*10.)));\n    col1+=col3*smoothstep(.75,1.,length(p.x-vec2(.25)));\n    col1+=col2*smoothstep(.75,1.,length(p.x+vec2(.25)));\n    col1+=col4*smoothstep(.75,1.,length(p.y-vec2(.25)));\n    col1+=col5*smoothstep(.75,1.,length(p.y+vec2(.25)));\n    \n    vec3 a=col1/1.5*vec3(abs(dot(n,normalize(vec3(3.,2.,13.)-p))));\n    return a;//*softshadow(p+n*.1,normalize(-p+vec3(0,0.,0.-iTime/10.)),2.);\n}\n\n\n\n\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t=iTime/10.;\n    vec3 camera=vec3(0.,0.,6.-t);\n    vec3 lookAt=vec3(sin(iTime/3.),cos(iTime/3.),-t);\n    float zoom=.8;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    float d=rayMarch(c,ray);\n    \n    \n    vec3 p=c+ray*d;\n    vec3 n=normal(p);\n    vec3 col=shade(p,ray);\n    /*vec3 rf=reflect(n,ray);\n    float df=rayMarch(p+n*.01,rf);\n    float fresnel=clamp(pow(1.-dot(ray,n),5.),.2,.8);\n    col+=shade(p+rf*df,rf)*.3*fresnel;\n      */  \n    fragColor = vec4(col*max((1.-d*.15),.05),1.);\n}\n\n//from https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/ \nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .05 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 137], [140, 140, 173, 173, 312], [315, 315, 346, 346, 436], [438, 438, 471, 471, 967], [969, 969, 997, 997, 1268], [1270, 1270, 1299, 1299, 1492], [1494, 1494, 1513, 1513, 1597], [1599, 1599, 1619, 1619, 1787], [1791, 1791, 1824, 1824, 2052], [2054, 2054, 2107, 2107, 2322], [2324, 2324, 2351, 2351, 3201], [3208, 3208, 3266, 3266, 3972], [3974, 4052, 4088, 4088, 4428]], "test": "untested"}
{"id": "7sVSDG", "name": "draw_triangle", "author": "yyf1994", "description": "triangle", "tags": ["triangle"], "likes": 1, "viewed": 250, "published": 3, "date": "1635248806", "time_retrieved": "2024-07-30T18:52:55.368097", "image_code": "\nvec3 drawTriangle( vec3 P , vec3 A, vec3 B, vec3 C ){\n    //       A\n    //     |    \\\n    //    |      \\\n    //   |   . p  \\\n    //  |          \\\n    // B ----------  C \n\n    vec3 AB = A - B;\n    vec3 BC = B - C;\n    vec3 CA = C - A;\n\n    vec3 AP = A - P;\n    vec3 BP = B - P;\n    vec3 CP = C - P;\n\n    bool b1 = cross(AB, AP) .z >= 0.0;\n    bool b2 = cross(BC, BP).z   >= 0.0;\n    bool b3 = cross(CA, CP).z   >= 0.0;\n\n    if(b1 && b2 && b3  ){\n      return vec3(1.0);\n    }else{\n      return vec3(0.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    //points\n    vec3 v0 = vec3(0.0, 0.1, 0.0);\n    vec3 v1 = vec3( -0.2, -0.2, 0.0);\n    vec3 v2 = vec3( 0.2,  -0.2, 0.0);\n\n    vec3 result = drawTriangle(  vec3(uv   , 0.0)   , v0 , v1 , v2 );\n    fragColor =  vec4(result , 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 54, 171, 513], [516, 516, 573, 573, 888]], "test": "untested"}
{"id": "ssVXWG", "name": "入门之路-7", "author": "jialouluo", "description": "网格噪声 + Voronoi算法", "tags": [], "likes": 0, "viewed": 235, "published": 3, "date": "1635246403", "time_retrieved": "2024-07-30T18:52:56.259713", "image_code": "vec2 random( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=3.;\n    vec2 f = fract(uv);//取小数部分 -单元网格坐标\n    vec2 k = floor(uv);//取整\n    vec3 color =vec3(0.0);\n    float m = 2.0;\n    vec2 dir = vec2(0.0);\n    for(int i=-1;i<=1;i++){\n        for(int j =-1;j<=1;j++){\n            vec2 rand = vec2(float(i),float(j));\n            vec2 result = random(rand+ k );\n            result = 0.5 + 0.5*sin(iTime + result*6.28 ) + rand ;\n            float dis = length(result - f);\n            if(dis<m){\n                m = dis;\n                dir = result;\n            }\n        }\n    }\n    //简单的理解为 找到每个像素与多个（这里是9个--上下左右四个斜角还有像素自身存在的网格的特殊点(伪随机点)）单元网格特殊点(伪随机点)的最短距离特殊点，然后将其距离的值存储下来\n    color+=m;\n    color-=abs(sin(35.43 * m))*0.3;\n    color.rg =dir; \n    \n    color = step(0.05,color)*color;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 116], [118, 118, 175, 225, 1250]], "test": "untested"}
{"id": "ssVSWG", "name": "3am", "author": "lambmeow", "description": "I am an idiot and drank coffee at 8pm so here i am coding something to pass time and help me fall asleep", "tags": ["sdf", "code", "nosleep", "3am"], "likes": 2, "viewed": 235, "published": 3, "date": "1635241723", "time_retrieved": "2024-07-30T18:52:57.056582", "image_code": "#define time iTime\n#define resolution iResolution\nfloat ss(vec3 p)\n{\n\tvec2 xz = vec2(p.x, p.y + p.z * .05);\n\n\tp.xz = mod(p.xz + 1.,2.) - 1.; \n\treturn length(p + sin(time + xz.y *2. - xz.x *0.2)* vec3(0,1,0)) - 1.;\n}\n\nvec3 rt(vec3 ro, vec3 rd)\n{\n\tfloat dist = 0.0;\n\tfor(int i = 0; i < 255; i++)\n\t{\n\t\tfloat ll = ss(ro+rd*dist);\n\t\t\n\t\tif(ll < 0.01)\n\t\t\treturn (ro+rd*dist);\n\t\t\t\n\t\tdist += ll;\n\t\tif(dist > 130.)\n\t\t\tbreak;\n\t\t\n\t\t\n\t}\n\t\n\treturn vec3(200);\n}\n\n\nvec3 nn(vec3 p)\n{\n\tvec2 xx = vec2(0.001, 0);\n\treturn normalize(vec3(\n\t\tss(p + xx.xyy) - ss(p -  xx.xyy),\n\t\tss(p + xx.yxy) - ss(p - xx.yxy),\n\t\tss(p + xx.yyx) - ss(p - xx.yyx)));\n}\n\nvec4 cc(vec3 p, vec2 u)\n{\n\t\n\tvec4 amb =  mix(vec4(0.1,0,0,1), vec4(1,.2,.5,1), (u.y  + 1.) );\n\tif(p.z == 200.)\n\t\treturn amb;\n\tvec3 n = nn(p);\n\tvec4 col =  dot(n, normalize(vec3(0,1,-1)))* vec4(1,0.4,.5,1) * p.z /100. + abs(p.y) * vec4(1, 0,.4,1)  + amb * 0.1;\n\treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 r = resolution.xy, u = (2.* (uv) - r)/r.y;\n\t\n\tvec3 rd = normalize(vec3(u, 2.0)),\n\tro = vec3(0,4. + cos(time * 0.05) * 0.5,-10.);\t\n \t\n\tfragColor = cc(rt(ro,rd), u);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 68, 68, 215], [217, 217, 244, 244, 446], [449, 449, 466, 466, 627], [629, 629, 654, 654, 903], [907, 907, 957, 1007, 1182]], "test": "untested"}
{"id": "sdKSWG", "name": "Fish Lens + Chromatic Aberration", "author": "ms_frogrammer", "description": "eh ah mm fish sees weird things", "tags": ["postprocessing", "fisheye", "easy"], "likes": 6, "viewed": 423, "published": 3, "date": "1635236494", "time_retrieved": "2024-07-30T18:52:57.933239", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv (0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // uv (-1 to 1, 0 - center)\n    uv.x = 2. * uv.x - 1.;\n    uv.y = 2. * uv.y - 1.;\n    \n    float barrel_power = 1.15; // increase for BIGGER EYE!\n    float theta = atan(uv.y, uv.x);\n\tfloat radius = length(uv);\n\tradius = pow(radius, barrel_power);\n\tuv.x = radius * cos(theta);\n\tuv.y = radius * sin(theta);\n    \n    // uv (0 to 1)\n    uv.x = 0.5 * (uv.x + 1.);\n    uv.y = 0.5 * (uv.y + 1.);\n\n    float chromo_x = 0.2;\n    float chromo_y = 0.2;\n    \n    // output\n    fragColor = vec4(texture(iChannel0, vec2(uv.x - chromo_x*0.016, uv.y - chromo_y*0.009)).r, texture(iChannel0, vec2(uv.x + chromo_x*0.0125, uv.y - chromo_y*0.004)).g, texture(iChannel0, vec2(uv.x - chromo_x*0.0045, uv.y + chromo_y*0.0085)).b, 1.0);;\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 76, 841]], "test": "untested"}
{"id": "fsKXDG", "name": "Raytrace make it faster", "author": "rockhard", "description": "Simple traditional raytrace scene.times faster than \"ray step search\" method \n pathtrace i will post later. ", "tags": ["raytrace", "pbr"], "likes": 3, "viewed": 315, "published": 3, "date": "1635234272", "time_retrieved": "2024-07-30T18:52:58.787953", "image_code": "mat3 rotXY(float rX, float rY){\n float cx = cos(rX),sx = sin(rX),cy = cos(rY),sy=sin(rY);\n return mat3(-sy, 0, -cy, -sx * cy, cx, sx * sy,cx * cy, sx, -cx * sy);\n}\n//to much cross add reduce ect still get the same!just a simple math.\nvec3 getdir(vec2 p,mat3 m){\n  return normalize(vec3(p.x * m[0].x + p.y * m[1].x - m[2].x, \n       p.x * m[0].y + p.y * m[1].y - m[2].y, \n       p.x * m[0].z + p.y * m[1].z - m[2].z));\n}\n\nfloat move(float sto){\n    float n = mod(floor(iTime), 8.); // 8 keyframe.\n    float t = mod(iTime, 8.); // Fractional time.\n    return  smoothstep(.0, .9, fract(t+sto)); // Smoothing. \n }\n\nstruct box{vec3 p,s,c;};\nbox boxes(int i){\n  if(i==0)return box(vec3(0.0,-0.2,0.0),vec3(3.0,0.5,3.0),vec3(0.6,0.58,0.57));\n  else  return box(vec3(0.0,0.5,0.0),vec3(0.65,0.5,0.65),vec3(0,1.0,0));\n} \n\nstruct sphere{vec3 p,c;float r;};\nsphere sphs(int i){\n  if(i==0) return sphere(vec3(1.0,move(1.0)*0.3+0.3,0.6),vec3(1.0,1.0,0.0),0.3);\n  else if(i==1) return sphere(vec3(-1.0,move(2.0)*0.5+0.5,0.8),vec3(0.0,1.0,1.0),\n           0.15*move(sin(iTime))+0.5);\n  else return sphere(vec3(1.0,move(2.0)*0.5+0.5,-0.6),vec3(1.0,0.0,1.0),0.5);\n}\n \n#define MAX_STEPS 6\n#define MAX_DIST 1.0\nfloat sdPlane(vec3 p) { return p.y;}\nfloat sdSphere(vec3 p, float r) { return length(p)-r;}\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h); }\n\nfloat sdShapes(vec3 p){\n   float d = sdSphere(vec3(p.x,p.y+0.5*sin(iTime)-0.225,p.z),0.25);\n   d = smin(d, sdPlane(p),0.5);\n   return d;\n}\n\nvec3 mapcol=vec3(0.0);\n\nfloat map(vec3 p,int id){\n  if(id==0){\n    mapcol=texture(iChannel0,p.xz*0.1).xyz;\n       return p.y - mapcol.x*0.06;}\n   else if(id==1) return sdShapes(p);   \n   else return 0.0;\n}\n//this displacement looks better than normalmap\nfloat raymatch(inout vec3 p, vec3 d,float tmax,int id){\n\tfloat dist = 0.0; \n    for(int i=0; i<10; i++){\n   \t    float stepdist = map(p,id);\n        dist+=stepdist;\n        if(dist>tmax) return 0.0;\n        else  if(dist<0.001) return dist;\n        p+=stepdist*d; \n    }\n    return dist;\n}\nvec3 normal(vec3 p,int id){ vec2 e = vec2(-DELTA,DELTA);   \n  return normalize(e.yxx*map(p + e.yxx,id) + e.xxy*map(p + e.xxy,id) + \n\t\t e.xyx*map(p + e.xyx,id) + e.yyy*map(p + e.yyy,id));   \n}\nvec3 hitpos,hitnor,hitcol;\nvec2 hitmm;\n//The id is main entry index to materials list if you wanna use.\nint hitid;\n//main trace throughout all objects to find nearest.\nvoid rayhit(vec3 ro,vec3 rd){\n    vec3 bp=vec3(0.0);\n    float near=1000.0;\n    hitid=-1; \n    float tmax=0.0;\n    for(int i=0;i<2;i++){\n       box b=boxes(i);\n       vec4 d=raybox(ro,rd,b.p,b.s,bp,tmax);\n       if(d.w>0.0){ \n         if(i==0||i==1){\n            float ndist= raymatch(bp,rd,tmax-d.w,i); \n            if(ndist==0.0)continue;\n            d.w+=ndist; \n            d.xyz=normal(bp,i);\n         }\n         if(near>d.w){ \n         near=d.w;\n         hitid=i;\n         hitpos=bp;hitnor=d.xyz;\n         if(i==0) hitcol=mapcol;\n         else hitcol=b.c;\n         hitmm=vec2(near,tmax);}\n    }}   \n    for(int j=0;j<3;j++){\n       sphere s=sphs(j);\n       float ds=raysphere(ro,rd,s.p,s.r);\n       if(ds>0.0&&near>ds){       \n        near=ds; hitid=j+2;\n        hitpos=ro+rd*ds;hitnor=normalize(hitpos-s.p);\n        hitcol=s.c;\n        hitmm=vec2(ds,ds);\n      }\n    } \n}\n\nvec3 diffuse(vec3 p,vec3 rd, vec3 n,vec3 li,vec3 c){\n   float d2l;  \n   vec3 col=PBR(li,n,-rd,c,0.05,.02,d2l); //c*(max(0.0,d2l)*0.7+0.3); \n   if(d2l>0.0){\n      //  col+=pow(max(0.0, dot(n,normalize(li-rd))),60.0)*vec3(0.25,0.21,0.12);\n      //shadow trace\n      rayhit(p+n*DELTA,li);\n      if(hitid!=-1)col*=0.5;\n   }   \n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y; \n\n    //the yaw roll pitch matrix without roll.\n    mat3 camrot=rotXY(0.35,iTime*0.2+iMouse.x/iResolution.x*0.1);\n    vec3 ro=camrot[2]*3.85;\n    vec3 rd=getdir(uv,camrot);\n    vec3 light=normalize(vec3(0.6,0.8,0.6));\n  \n    vec3 col=vec3(0.0);\n    \n    rayhit(ro,rd);\n    //store the first result is importent\n    //to avoid hit id changes.\n    int bid=hitid;\n    vec3 nor=hitnor;\n    vec3 pos=hitpos;\n    vec3 c=hitcol;\n    if(bid!=-1){      \n        col=diffuse(pos,rd,nor,light,c); \n       //the floor box is reflective..\n        if(bid==0||bid==4){\n          vec3 rn=reflect(rd,nor);\n          rayhit(pos+0.001*nor,rn);\n          if(hitid!=-1){\n            vec3 cr=diffuse(hitpos,rd,hitnor,light,hitcol);\n            //energy based reflection as the world always be...\n            float d2e=0.6-0.5*clamp(dot(nor,-rd),0.0,1.0);\n            col=mix(col,cr,d2e*min(1.0,max(cr.z,max(cr.x,cr.y))));\n        }}\n    }\n    fragColor = vec4(pow(col,vec3(0.5)),1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DELTA 1e-4\nfloat raysphere(vec3 p,vec3 d,vec3 sp,float sr) {\n    vec3 m = p - sp;\n    float b = dot(m,d);\n    float c = dot(m, m) - sr * sr;\n    if (c > 0.0 && b > 0.0) return 0.0;\n    float discr = b * b - c; \n    if (discr < 0.0) return 0.0; \n    return -b - sqrt(discr);//-b+sqrt(discr);\n}\nvec4 raybox(vec3 p,vec3 d,vec3 boxp,vec3 boxs,inout vec3 hp,inout float hmax) {\n    vec4 hit=vec4(0.0);     \n    vec3 bmin=boxp-boxs;\n    vec3 bmax=boxp+boxs;\n    float tymin, tzmin, tymax, tzmax; \n    float tmin,tmax; \n\n    if (d.x >= 0.0){ tmin = (bmin.x - p.x) / d.x; tmax = (bmax.x - p.x) / d.x; }\n    else { tmin = (bmax.x - p.x) / d.x; tmax = (bmin.x - p.x) / d.x;  }\n    if (d.y >= 0.0) { tymin = (bmin.y - p.y) / d.y; tymax = (bmax.y - p.y) / d.y; }\n    else { tymin = (bmax.y - p.y) / d.y;  tymax = (bmin.y - p.y) / d.y; }\n\n    if ((tmin > tymax) || (tymin > tmax)) return hit;\n    if (tymin > tmin) tmin = tymin;\n    if (tymax < tmax) tmax = tymax;\n\n    if (d.z >= 0.0){ tzmin = (bmin.z - p.z) / d.z; tzmax = (bmax.z - p.z) / d.z; }\n    else { tzmin = (bmax.z - p.z) / d.z; tzmax = (bmin.z - p.z) / d.z; }\n    if ((tmin > tzmax) || (tzmin > tmax)) return hit;\n    if (tzmin > tmin) tmin = tzmin;\n    if (tzmax < tmax) tmax = tzmax;\n    if(tmin<0.0) return hit;//inside box \n    hit.w = tmin;hmax=tmax;\n    vec3 center = boxp;\n\tvec3 size = boxs;\n    hp=p+tmin*d;\n\tvec3 pc =hp-center;\n\tvec3 normal = vec3(sign(pc.x)* step(abs(abs(pc.x) - size.x),DELTA),\n\tsign(pc.y) * step(abs(abs(pc.y) - size.y), DELTA),\n\tsign(pc.z) * step(abs(abs(pc.z) - size.z), DELTA));\n\thit.xyz= normalize(normal);\n    return hit;\n} \n\nfloat G1V (float dotNV, float k ) { return 1.0 / (dotNV*(1.0 - k) + k); }\n\nvec3 PBR (vec3 L,vec3 N, vec3 V, vec3 albedo, float roughness,\n    float F0,inout float d2l) {\n \n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n    d2l=dotNL;\n    float ambient=mix(0.5,0.0,acos(N.y)*0.31831);\n    dotNL+=ambient;\n    \n\tfloat D, vi ,vis, F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = roughness*roughness;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = roughness / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n    // Fresnel (Schlick)\n\tfloat Fresnel = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*Fresnel;\n    \n\tfloat specular = /*dotNL */ D * F * vis;\n\t \n\tvec3 diffuse = (albedo * 0.31831);\n\n\treturn (diffuse+specular)*(dotNL);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 163], [164, 234, 261, 261, 419], [421, 421, 443, 443, 609], [636, 636, 653, 653, 808], [845, 845, 864, 864, 1146], [1190, 1190, 1213, 1213, 1226], [1227, 1227, 1260, 1260, 1281], [1282, 1282, 1323, 1323, 1418], [1420, 1420, 1443, 1443, 1558], [1584, 1584, 1609, 1609, 1765], [1766, 1814, 1869, 1869, 2103], [2104, 2104, 2131, 2131, 2295], [2411, 2464, 2493, 2493, 3342], [3344, 3344, 3396, 3396, 3683], [3685, 3685, 3742, 3742, 4792]], "test": "untested"}
{"id": "NsVSWy", "name": "Gaussian Filtered Rectangle", "author": "oneshade", "description": "Gaussian blurred rectangle.", "tags": ["blur", "filter", "rectangle", "gaussian"], "likes": 19, "viewed": 247, "published": 3, "date": "1635224506", "time_retrieved": "2024-07-30T18:52:59.730433", "image_code": "// https://www.desmos.com/calculator/rnlcawwmf8\n\n// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered rectangle\nfloat grect(in vec2 p, in vec2 b, in float w) {\n    float u = erf((p.x + b.x) / w) - erf((p.x - b.x) / w);\n    float v = erf((p.y + b.y) / w) - erf((p.y - b.y) / w);\n    return u * v / 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float w = mix(0.25, 0.5, 0.5 - 0.5 * cos(0.5 * iTime));\n    float h = mix(0.25, 0.4, 0.5 - 0.5 * sin(iTime));\n    float s = mix(0.001, 0.125, 0.5 - 0.5 * cos(iTime));\n\n    fragColor = vec4(grect(uv, vec2(w, h), s));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 81, 104, 104, 164], [166, 197, 244, 244, 388], [390, 390, 445, 445, 734]], "test": "untested"}
{"id": "fdVSDG", "name": "1_6_hsv2rgb", "author": "tomoe", "description": "sample code", "tags": ["ch1"], "likes": 1, "viewed": 241, "published": 3, "date": "1635217468", "time_retrieved": "2024-07-30T18:53:00.634018", "image_code": "const float PI = 3.1415926;\nfloat atan2(float y, float x){\n    if (x == 0.0){\n        return sign(y) * PI / 2.0;\n    } else {\n        return atan(y, x);\n    }\n}\nvec2 xy2pol(vec2 xy){\n    return vec2(atan2(xy.y, xy.x), length(xy));\n}\nvec2 pol2xy(vec2 pol){\n    return pol.y * vec2(cos(pol.x), sin(pol.x));\n}\nvec3 hsv2rgb(vec3 c){ // fork from https://www.shadertoy.com/view/MsS3Wc\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    pos = 2.0 * pos.xy - vec2(1.0);\n    pos = xy2pol(pos);\n    pos.x = mod(0.5 * pos.x / PI, 1.0);\n    fragColor.rgb = hsv2rgb(vec3(pos, 1.0));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 58, 58, 160], [161, 161, 182, 182, 232], [233, 233, 255, 255, 306], [307, 307, 328, 379, 516], [517, 517, 571, 571, 786]], "test": "untested"}
{"id": "NdKSDG", "name": "1_5_polarRot", "author": "tomoe", "description": "sample code\npolar coordinate with rotational RGB color", "tags": ["ch1"], "likes": 1, "viewed": 251, "published": 3, "date": "1635217459", "time_retrieved": "2024-07-30T18:53:01.436871", "image_code": "const float PI = 3.14159265;\nfloat atan2(float y, float x){\n    if (x == 0.0){\n        return sign(y) * PI / 2.0;\n    } else {\n        return atan(y, x);\n    }\n}\nvec2 xy2pol(vec2 xy){\n    return vec2(atan2(xy.y, xy.x), length(xy));\n}\nvec2 pol2xy(vec2 pol){\n    return pol.y * vec2(cos(pol.x), sin(pol.x));\n}\nvec3 tex(vec2 st){\n    float time = 0.5 * iTime;\n    vec3 circ = vec3(0.5 * pol2xy(vec2(time, 0.5)) + 0.5, 1.0);\n    vec3[3] col3;\n    col3[0] = circ.xyz;\n    col3[1] = circ.yzx;\n    col3[2] = circ.zxy;\n    st.s = st.s / PI + 1.0;\n    st.s += time;\n    int ind = int(st.s);\n    vec3 col = mix(col3[ind % 2], col3[(ind + 1) % 2], fract(st.s));\n    return mix(col3[2], col, st.t);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    pos = 2.0 * pos - vec2(1.0);\n    pos = xy2pol(pos);    \n    fragColor = vec4(tex(pos), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 59, 59, 161], [162, 162, 183, 183, 233], [234, 234, 256, 256, 307], [689, 689, 743, 743, 888]], "test": "untested"}
{"id": "fdKSDG", "name": "1_4_polar", "author": "tomoe", "description": "sample code\nlerp colors using polar coordinate", "tags": ["ch1"], "likes": 1, "viewed": 256, "published": 3, "date": "1635217451", "time_retrieved": "2024-07-30T18:53:02.186866", "image_code": "const float PI = 3.1415926;\nfloat atan2(float y, float x){\n    if (x == 0.0){\n        return sign(y) * PI / 2.0;\n    } else {\n        return atan(y, x);\n    }\n    // or use \"?:\" as follows:\n    // return x == 0.0 ? sign(y) * PI / 2.0 : atan(y, x);\n}\nvec2 xy2pol(vec2 xy){\n    return vec2(atan2(xy.y, xy.x), length(xy));\n}\nvec2 pol2xy(vec2 pol){\n    return pol.y * vec2(cos(pol.x), sin(pol.x));\n}\nvec3 tex(vec2 st){\n    vec3[3] col3 = vec3[](\n        vec3(0.0, 0.0, 1.0),\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0)\n    );\n    st.s = st.s / PI + 1.0;\n    int ind = int(st.s);\n    vec3 col = mix(col3[ind % 2], col3[(ind + 1) % 2], fract(st.s));\n    return mix(col3[2], col, st.t);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    pos = 2.0 * pos.xy - vec2(1.0);\n    pos = xy2pol(pos);    \n    fragColor = vec4(tex(pos), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 58, 58, 249], [250, 250, 271, 271, 321], [322, 322, 344, 344, 395], [685, 685, 739, 739, 887]], "test": "untested"}
{"id": "fsVXWG", "name": "1_3_posterization", "author": "tomoe", "description": "sample code\nposterization using\n(left) step  (right) smoothstep", "tags": ["ch1"], "likes": 1, "viewed": 250, "published": 3, "date": "1635217437", "time_retrieved": "2024-07-30T18:53:03.035596", "image_code": "int channel;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec3[4] col4 = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0, 1.0, 0.0),\n        vec3(1.0, 0.0, 1.0),\n        vec3(1.0, 1.0, 1.0)\n    );\n    float n = 4.0;\n    pos *= n;\n    channel = int(2.0 * fragCoord.x / iResolution.x);\n    if (channel == 0){  //left: step\n        pos = floor(pos) + step(0.5, fract(pos));\n    } else {  //right: smoothstep\n        float thr = 0.25 * sin(iTime);\n        pos = floor(pos) + smoothstep(0.25 + thr, 0.75 - thr, fract(pos));\n    }\n    pos /= n;\n    vec3 col = mix(mix(col4[0], col4[1], pos.x), mix(col4[2], col4[3], pos.x), pos.y);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NsKSDG", "name": "1_2_bilerp", "author": "tomoe", "description": "sample code", "tags": ["ch1"], "likes": 1, "viewed": 190, "published": 3, "date": "1635217421", "time_retrieved": "2024-07-30T18:53:03.899287", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec3[4] col4 = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 1.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(1.0, 1.0, 0.0)\n    );\n    \n    vec3 col = mix(mix(col4[0], col4[1], pos.x), mix(col4[2], col4[3], pos.x), pos.y);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NdKSzd", "name": "Gaussian Filtered Square Wave", "author": "oneshade", "description": "Testing a gaussian filtered square wave.", "tags": ["filter", "approximation", "waveform", "gaussian", "squarewave"], "likes": 10, "viewed": 247, "published": 3, "date": "1635215159", "time_retrieved": "2024-07-30T18:53:04.814839", "image_code": "// https://www.desmos.com/calculator/xdlx1yoiyt\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color, 1.0);\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    uv = (uv - 0.5) * 1.5 + 0.5; // Scale 1.5x\n\n    float unit = 3.0 / iResolution.y; // 2x pixel size\n\n    float w = 0.501 - 0.5 * cos(0.25 * iTime); // Filter width\n    float x = uv.x + iTime;\n\n    // Graph\n    float y = gsquare(x, w);\n    float dydx = (gsquare(x + 0.001, w) - y) / 0.001;\n    float dist = abs(uv.y - y) / sqrt(1.0 + dydx * dydx);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(unit, 0.0, dist));\n\n    // Undo scale\n    uv = (uv - 0.5) / 1.5 + 0.5;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(int samp, float time) {\n    return vec2(makeNoise(time));\n}", "sound_inputs": [], "common_code": "// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered square wave\n// Works for filter widths between 0 and 1.5\n// Increase k to allow for larger filter widths\nconst float k = 5.0; // k → ∞\nfloat gsquare(in float x, in float w) {\n    x = mod(x, 2.0);\n    float y = 0.0;\n    float s = 1.0 - 2.0 * mod(k, 2.0);\n    for (float n=-k; n <= k; n++) {\n        y += s * erf((x - n) / w);\n        s = -s;\n    }\n\n    return (1.0 - y) / 2.0;\n}\n\nfloat makeNoise(in float time) {\n    return 0.25 * gsquare(time * 200.0, 0.501 - 0.5 * cos(0.25 * time));\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 127, 230, 230, 495], [497, 497, 552, 574, 1871]], "test": "untested"}
{"id": "NdKXWG", "name": "value noise 2D smooth", "author": "yyf1994", "description": "value noise 2D smooth", "tags": ["noise"], "likes": 0, "viewed": 242, "published": 3, "date": "1635211286", "time_retrieved": "2024-07-30T18:53:05.627666", "image_code": " \n \nfloat random(vec2 x) { \n    return fract( sin( dot(x ,vec2(12.12357, 20.789) ) + 0.001 ) * 223.123  );\n}\n\n\nfloat smooth_line(float x) {\n    float f = 6.0 * pow( x , 5.0 ) -  15.0 * pow( x , 4.0 ) +  10.0 * pow( x , 3.0);\n    return f;\n}\n\n/** @brief value noise */\nfloat valueNoise(vec2 pos){\n    \n    vec2 fr= fract(pos);\n    vec2 AA= floor(pos);\n    vec2 AB= floor(pos)  + vec2(1,0);\n    vec2 BA= floor(pos)  + vec2(0,1);\n    vec2 BB= floor(pos)  + vec2(1,1);\n    \n    // we sample random number on a regular grid\n    //\n    //  AA-----------AB\n    //   |           |\n    //   |           |\n    //   |    pos    |\n    //   |           |\n    //   |           |\n    //  BA-----------BB\n    float rAA = random(AA);\n    float rAB = random(AB);\n    float rBA = random(BA);\n    float rBB = random(BB);\n    \n    // bilinear interpolation of the value\n    float nAA_AB = mix(rAA , rAB,          (   fr.x));\n    float nBA_BB = mix(rBA , rBB,      smooth_line   (  fr.x));\n    return mix(nAA_AB , nBA_BB,      smooth_line (  fr.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n     vec2 uv = fragCoord/iResolution.xy  * 30.0 ;\n     float value = valueNoise(uv );\n    \n    fragColor = vec4(  value , value,value , value );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 26, 26, 108], [111, 111, 139, 139, 240], [242, 268, 295, 295, 1029], [1031, 1031, 1088, 1088, 1241]], "test": "untested"}
{"id": "ssySDy", "name": "Blob chain", "author": "op", "description": "Raymarching in sliced  blob chain of balls and  point lights", "tags": ["3d", "raymarching", "distancefield", "blob", "ball", "kerning"], "likes": 5, "viewed": 335, "published": 3, "date": "1635210272", "time_retrieved": "2024-07-30T18:53:06.382647", "image_code": "\nconst vec3 g_lightDir = normalize(vec3(-1.0, 0.6, -1.0));\nconst vec3 g_bakLightDir = normalize(vec3(1.0, -0.7, 1.5));\n\nconst float g_tg = 0.98; // point light trigger\n\n// ------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n#define saturate(_a) clamp(_a, 0.0,1.0)\n\n\nfloat hash13(ivec3 p)\n{\n    vec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// from IQ\nvec3 hash33( uvec3 x )\n{\n    const uint k = 1103515245U;\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash33( ivec3 x )\n{\n    return hash33( uvec3(x) );\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n\n// smin for 2 components, driven by first one(distance)\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    h = h*h*0.25/k;\n    \n    \n    float g = (b.y-a.y)*h;\n    \n    \n    return a.x<b.x ? vec2(a.x-h, a.y+g) : vec2(b.x-h, b.y-g);    \n}\n\n\n#define RING_RADIUS 1.0\n#define RING_AMPLITUDE 1.0\n\nconst float distErr = max(0.0, sqrt(pow(RING_RADIUS+RING_AMPLITUDE,2.0)*2.0) - 1.5);\n\nvec2 map( in bool highOnly, in vec3 p )\n{\n\n    vec2 res = vec2(1000000.0, 1.0);\n\n    float s = 1.0;\n    p *= s;\n    \n\n    // animate smin\n    float sm = 0.01 + 0.99*max(0.0,sin(iTime*0.2));\n\n    // scan 3 rings of ball (left, center, right)\n    for(int i=-1; i<=1; i++)\n    {                                \n        vec3 f = fract(p);\n        f.y = p.y;\n        f.z = p.z;\n\n\n        vec3 cc = vec3(i,0,0);\n        vec3 cw = p-f + cc;\n        ivec3 bid = ivec3(cw);\n        cc += 0.5;// center\n\n        cc.y += RING_AMPLITUDE * sin( cw.x +  iTime*1.33);\n        cc.z += RING_AMPLITUDE * cos( cw.x +  iTime*1.23);\n\n\n        const int nb = 8;\n        float a = iTime*(1.17 + sin(cw.x*7.27) ); // twist !\n        for(int j=0; j<nb; j++, a+=2.0*3.14159/float(nb))\n        {\n            ivec3 id = bid; id.y += j;\n            vec3 hs = hash33( id );\n\n            float e = fract(hs.x+hs.z);  // random color scale                    \n            if(highOnly && e<g_tg) continue;\n\n            vec3 c=cc;\n            c.z += RING_RADIUS * cos(a) * (0.4 + 0.6*hs.y);\n            c.y += RING_RADIUS * sin(a) * (0.4 + 0.6*hs.z);\n\n            // Random radius\n            float r = 0.1 + 0.3*hs.x*(0.7 + 0.3*sin( (0.1 +hs.z*7.31) *  iTime));\n\n            // Random offset\n            float o = fract(hs.x+hs.y)*(1.0-2.0*r) - (0.5-r);                   \n            o *= 0.5 + 0.5*sin( (0.1 + hs.x*5.51)*iTime)*sin(iTime*(0.2 + 11.1*hs.y));\n            c.x += o;\n\n            // sdf\n            float d = length(f-c) - r;\n\n            res = smin(res, vec2(d, e), sm );\n\n            res.y = min(1.0, res.y);                                        \n        }\n\n        if(res.x<=0.0) break;\n    }\n    \n    res.x /= s;\n    \n    return res;\n}\n\n\n\nvec3 calcNormal(in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy,outside, MAP_DETAIL_STD ).x + \n       e.yyx*map( pos + e.yyx).x ) + \n       e.yxy*map( pos + e.yxy).x ) + \n       e.xxx*map( pos + e.xxx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(false, pos+0.001*e).x;\n    }\n    return normalize(n);\n\n#endif    \n}\n\n\nvec2 intersect(in float maxdist, in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0, 0);\n\n\n    float t = 0.0;\n\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( false, p );\n        \n        if( h.x<(0.0001*t) ||  t>maxdist ) return vec2(t, h.y);\n\n        // we should have perfect distance:\n        // but since we offset in a vertical slice, and only scan left&right neigboor,\n        // then we need to detect potentially over evaluated distances\n      \n        t+= h.x<=distErr ? h.x : max(distErr, h.x-distErr);\n\n    }\n\n    return vec2(maxdist, 0.0); //res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n\n    float tmax = 120.0;\n    \n    float t = 0.02;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(false, ro + rd*t ).x;\n          \n#if 1\n        res = min( res, 4.0*h/t );// soft\n#else        \n        if(t>0.1 && h<=0.0) return 0.0;// hard\n#endif        \n\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return max(.0, res );\n}\n\n\n\nfloat specular(vec3 ld, vec3 n, vec3 rd, float s)\n{\n    return pow( max(0.0, dot(reflect(ld,n), rd )), s);\n}\n\nfloat diffuse(vec3 ld, vec3 n)\n{\n    return saturate( dot(n , ld) );\n}\n\n\nvec3 background(vec3 p, vec3 n)\n{\n    return vec3(0.3,0.4,0.5)*0.3 * (0.5 + 0.5*dot(n,g_lightDir)  );\n}\n\nvec3 calcPointColor(float id)\n{\n    id = saturate( (id-g_tg)/(1.0-g_tg) );\n    float tm = iTime * ( 0.7 + 0.3*id);\n    \n    float tc = pow(sin(0.1*tm),2.0);\n    vec3 c1 = mix( 1.5*vec3(1.0,0.5 + tc ,0.0), 1.5*vec3(0.0, tc+0.5,tc*tc), tc );\n    \n    vec3 c2 = mix( 1.5*vec3(1.0,tc*2.0, 0.0), 1.5*vec3(1.0,0.0, tc), tc );\n        \n    tc = saturate( sin(tm*0.23)*4.0 );\n    \n    return mix(c1, c2, tc );       \n}\n\n\nvec3 render(in vec2 fragCoord, in vec3 ro, in vec3 rd, out float tt )\n{\n    float maxDist = 50.0;\n    vec2 t = intersect(maxDist, ro,rd);\n    \n    tt = t.x;\n    \n    vec3 col, colBackground = background(ro,rd);\n    \n    if(t.x>=maxDist)\n        col = colBackground; // background\n    else\n    {\n\n        vec3 p = ro + rd*t.x;\n        vec3 n  = calcNormal(p , 0.0001);\n\n\n        if(t.y>g_tg)\n        { // point light/self illum\n            col  = calcPointColor(t.y);\n\n            // small halo..\n            float r= 0.5; // max radius of a sphere\n            float e = map(true, p+rd*r).x;\n            col *= smoothstep(0.8, 0.0, e/r);\n\n        }\n        else\n        {\n            // ambient\n            vec3 amb = 0.2*textureLod( iChannel3, n.xy, 0.0 ).xyz;\n            amb += 0.5*background(ro,n);\n\n            // Ball color\n            float ty = t.y / g_tg;            \n            vec3 colBall = 0.5*mix(vec3(0.3, 0.1, 0.5), vec3(0.9, 0.3, 0.5), ty);\n\n\n            // directional lighting\n            float atten = 0.5 + 0.5*calcSoftshadow(p, g_lightDir);\n            col = colBall * ( amb + atten*diffuse(g_lightDir, n) );\n            col+= atten*specular(g_lightDir, n, rd, 16.0);\n\n\n            // animation: show shadowed only\n            {\n                float u = saturate( sin(iTime*0.2 + fragCoord.x*0.001)*4.0 );\n                col = mix(vec3(atten), col, u );\n            }\n    \n    \n            // back light\n            float d = 1.0 - min(1.0, 0.1*length(p-vec3(0)) );\n            col += /*atten**/0.6*vec3(0.0, 0.7, 1.0)* diffuse(g_bakLightDir, n) * d;\n\n\n            // lighting with closest point light, by calculating the distance variation along normal, in the light field !\n            {\n                const float rl = 3.0; // point light radius\n                vec2 pl = map( true, p ); // closest point light\n                if(pl.x < rl)\n                {\n                    float dl = (rl-pl.x) * max(0.0, pl.r-map(true, p+n).x) / rl;\n                    // lighting + some 'reflectivity'\n                    vec3  cl = calcPointColor(pl.y);\n                    col += cl*(colBall + 0.2) * dl * 4.0;\n                }\n            }\n        }\n        \n        // fog\n        col = mix(colBackground, col \n                        , smoothstep(maxDist, -3.0, t.x) );\n                        //,min(1.0,exp(-.05*t.x + 1.0)) );\n    }\n\n    \n    return col;\n}\n\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n    vec3 cw = normalize(rt-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    \n    return mat3( cu, cv, cw );\n}\n\nvec3 pathCamera(out vec3 ta)\n{\n    float cTime = iTime*0.3;\n\n    // camera\n    float an = 0.025*sin(0.5*cTime) - 1.25;\n    vec3 ro = vec3(5.7,1.6, 5.7);\n    \n    ro.x = 0.0+ cos(0.5*cTime)*10.0;  \n    ro.z = 0.0+ sin(0.5*cTime)*12.0;\n\n    ro.y += sin(0.351*cTime)*16.0;\n\n    ta = vec3(0.0,0.0 + 0.0*sin(0.1*cTime),0);    \n\n    return ro;\n}\n\n\nvec3 ACESFilm(vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n\n    // camera\n    vec3 ta, ro=pathCamera(ta);\n\n\n    // ray\n    const float fl = 3.5;\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,fl) );\n\n    vec3 col = vec3(0.0);\n\n\n    // render\n    float t;    col += render(fragCoord, ro, rd, t);\n\n\n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    \n    // Output to screen    \n    fragColor = vec4( ACESFilm(col), 1.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 316, 316, 432], [435, 446, 470, 470, 636], [638, 638, 662, 662, 695], [698, 738, 779, 779, 851], [853, 893, 934, 934, 1006], [1009, 1058, 1110, 1110, 1140], [1143, 1199, 1237, 1237, 1411], [1552, 1552, 1593, 1593, 3275], [3893, 3893, 3952, 3952, 4494], [4496, 4541, 4589, 4589, 4991], [4995, 4995, 5046, 5046, 5103], [5105, 5105, 5137, 5137, 5175], [5178, 5178, 5211, 5211, 5281], [5283, 5283, 5314, 5314, 5693], [5696, 5696, 5767, 5767, 8081], [8086, 8086, 8141, 8141, 8335], [8337, 8337, 8367, 8367, 8676], [8679, 8679, 8702, 8758, 8944], [8947, 8947, 9004, 9004, 9539]], "test": "untested"}
{"id": "7syXDy", "name": "Taste of Noise 11", "author": "leon", "description": "trippin", "tags": ["weird"], "likes": 51, "viewed": 1217, "published": 3, "date": "1635209768", "time_retrieved": "2024-07-30T18:53:07.148599", "image_code": "// taste of noise 11 by leon denise 2021/10/26\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret and many others\n// licensed under hippie love conspiracy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n", "buffer_a_code": "// taste of noise 11 by leon denise 2021/10/26\n// thanks to Inigo Quilez, David Hoskins, NuSan, Fabrice Neyret and many others\n// licensed under hippie love conspiracy\n\n// global variable\nvec3 rng;\n\n// geometry\nfloat map (vec3 p)\n{\n    float t = iTime * 0.05;\n    \n    // parameters\n    vec3 angle = vec3(1,2,3)+rng.x*.1+sin(length(p))+p*.1-t;\n    float size = 0.01*sin(rng.x*3.14)*rng.y;\n    float range = .6;\n    \n    // geometric iteration\n    const float count = 12.0;\n    float a = 1.0;\n    float scene = 1000.;\n    for (float index = 0.0; index < count; ++index)\n    {        \n        // rotate\n        p.yx *= rot(angle.z/a);\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        \n        // fold\n        vec3 ppp = p;\n        p.x = abs(p.x)-range*a;\n        \n        // add sdf object\n        scene = smin(scene, length(p)-size, 0.5*a);\n        \n        // falloff\n        a /= 1.4;\n    }\n        \n    return scene;\n}\n\n// Inigo Quilez (https://www.shadertoy.com/view/Xds3zN)\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.1*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );// * (0.5+0.5*nor.y);\n}\n\nvec3 color (vec3 pos, vec3 ray, vec3 normal)\n{    \n    // lighting\n    vec3 rf = reflect(ray, normal);\n    float ld = dot(rf, vec3(0,0,1))*0.5+0.5;\n    vec3 ld2 = vec3(0.875,0.722,1.000) * sqrt(ld);\n    ld = dot(rf, normalize(vec3(0,1,0)))*0.5+0.5;\n    vec3 light = vec3(0.580,0.918,1.000) * pow(ld,10.);\n\n    // color palette by Inigo Quilez (https://iquilezles.org/articles/palettes)\n    vec3 tint = .5+.5*cos(vec3(0, .3, .6)*4.+length(pos)*3.-1.);\n    \n    // ambient occlusion by Inigo Quilez (https://www.shadertoy.com/view/Xds3zN)\n    float ao = mix(1., getAO(pos, normal), .9);\n\n    // compositing\n    return (tint + ld2 + light) * ao * .5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash33(seed);\n    \n    // pixel coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // blur edges\n    vec3 rng3 = hash33(seed+78.);\n    vec2 dof = vec2(cos(rng3.x*6.28),sin(rng3.x*6.28))*rng3.y;\n    uv += dof*pow(length(uv), 8.0)*.5;\n    \n    // camera coordinates\n    vec3 eye = vec3(0,0,-3);\n    vec3 ray = normalize(vec3(uv, 2));\n    vec3 pos = eye + ray * 1.;\n    \n    // raymarching\n    const float count = 25.;\n    bool hit = false;\n    float index;\n    for (index = 0.; index < count; ++index)\n    {\n        float dist = map(pos);\n        if (dist < 0.001)\n        {\n            hit = true;\n            break;\n        }\n        dist *= 0.9 + 0.1 * rng.z;\n        pos += ray * dist;\n    }\n    \n    if (hit)\n    {\n        // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n        vec2 off=vec2(0.001,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n        // coloring\n        float shade = 1.-index/count;\n        fragColor.rgb = color(pos, ray, normal) * shade;\n    }\n    \n    // feedback with fade out\n    vec4 frame = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = max(fragColor.rgb, frame.rgb - 0.002);\n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXDy.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[169, 169, 226, 226, 296]], "test": "untested"}
{"id": "7dyXDy", "name": "elastic collision 2D", "author": "remaindeer", "description": "Simulate elastic collisions between circles with velocity and mass mapped to color intensity and size. Red indicates a collision. It is not fully optimized. Relearning a lot of math... Seems to expand and cool down... Now with walls. Less buggy...", "tags": ["collision", "simulation", "velocity", "mass", "elastic"], "likes": 9, "viewed": 482, "published": 3, "date": "1635206585", "time_retrieved": "2024-07-30T18:53:07.928514", "image_code": "// Image\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - 1.0) / 2.0;\n\n    vec3 col = vec3(0);\n    for (int j = 0; j < N; j++) {\n        vec4 motion = texelFetch(iChannel0, ivec2(j, IPOS), 0);\n        vec4 prop = texelFetch(iChannel0, ivec2(j, IPRP), 0);\n        float dist = distance(uv, motion.xy);\n        if (dist < prop.y) {\n            col = vec3(0, 1, 1);\n            if (dist < prop.y - prop.y * 0.075) {\n                float speed = clamp(length(motion.zw) / length(vec2(MPVELO, MPVELO)), 0.25, 1.0);\n                col = prop.z == 1.0 ? vec3(speed, 0, 0) : vec3(0, speed, 0);\n            }\n        }\n    }\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2  uv = fragCoord;\n    ivec2 iv = ivec2(uv);\n\n    vec4 fcol = vec4(0);\n    if (iv.x < N && iv.y < IEND) {\n        if (iFrame == 0) {\n            // initialize\n            /****/ if (iv.y == IPOS) {\n                fcol = vec4(random3(uv.xy + iDate.xy + iTime).xy, 0, 0);\n                vec2 vel = random3(uv.yx + iDate.xy + iTime).xy;\n                vel.x *= random(uv.xy + iDate.xy + iTime) < 0.5 ? -1.0 : +1.0;\n                vel.y *= random(uv.yx + iDate.xy + iTime) < 0.5 ? -1.0 : +1.0;\n                fcol.zw = vel * MPVELO;\n            } else if (iv.y == IPRP) {\n                fcol.x = MPMASS * random(uv.xy + iDate.xy + iTime); // mass\n                fcol.y = fcol.x / MPMASS * MPRADI;                  // radius\n            }\n        } else {\n            vec4 motion1 = texelFetch(iChannel0, ivec2(iv.x, IPOS), 0);\n            vec2 pos1 = motion1.xy;\n            vec2 vel1 = motion1.zw;\n            vec4 prop1 = texelFetch(iChannel0, ivec2(iv.x, IPRP), 0);\n            float mass1 = prop1.x;\n            float radius1 = prop1.y;\n\n            bool cll = false;\n            for (int j = 0; j < N; j++) {\n                if (iv.x != j) {\n                    vec4 motion2 = texelFetch(iChannel0, ivec2(j, IPOS), 0);\n                    vec2 pos2 = motion2.xy;\n                    vec2 vel2 = motion2.zw;\n                    vec4 prop2 = texelFetch(iChannel0, ivec2(j, IPRP), 0);\n                    float mass2 = prop2.x;\n                    float radius2 = prop2.y;\n                    float d = distance(pos1, pos2);\n                    if (d < radius1 + radius2) {\n                        vec2 n = normalize(pos1 - pos2);\n                        pos1 += n * (radius1 + radius2 - d);\n                        if (dot(pos2 - pos1, vel1) > 0.0) { \n                            // https://en.wikipedia.org/wiki/Elastic_collision#Two-dimensional_collision_with_two_moving_objects\n                            vel1 -= (2.0 * mass2 / (mass1 + mass2)) * (dot(vel1 - vel2, pos1 - pos2) / length(pos1 - pos2)) * (pos1 - pos2);\n                            // https://en.wikipedia.org/wiki/Specular_reflection#Vector_formulation\n                            vel1 -= 2.0 * dot(vel1, n) * n;\n                        }\n                        cll = true;\n                        break;\n                    }\n                }\n            }\n            \n            /****/ if (pos1.x - radius1 < 0.0) {\n                pos1.x = radius1;\n                vel1.x *= -1.0;\n            } else if (pos1.x + radius1 > 1.0) {\n                pos1.x = 1.0 - radius1;\n                vel1.x *= -1.0;\n            } else if (pos1.y - radius1 < 0.0) {\n                pos1.y = radius1;\n                vel1.y *= -1.0;\n            } else if (pos1.y + radius1 > 1.0) {\n                pos1.y = 1.0 - radius1;\n                vel1.y *= -1.0;\n            }\n\n            pos1 += vel1 * iTimeDelta;\n\n            /****/ if (iv.y == IPOS) {\n                fcol = vec4(pos1, vel1);\n            } else if (iv.y == IPRP) {\n                fcol = vec4(prop1.x, prop1.y, int(cll), 0);\n            }\n        }\n    }\n\n    fragColor = fcol;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Common\n\n/////// buffer data channel row index: position & velocity\n#define IPOS 0\n/////// buffer data channel row index: properties (mass, radius, & collision)\n#define IPRP 1\n/////// buffer data channel row index: end of data\n#define IEND 2\n/////// number of particles\n#define N 1280 / 4\n/////// maximum particle mass\n#define MPMASS 1.0\n/////// maximum particle radius\n#define MPRADI 0.015\n/////// maximum particle velocity\n#define MPVELO 0.25\n\nfloat random(vec2 seed) {\n    // https://thebookofshaders.com/10/\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 random3(vec2 seed) {\n    return vec3(random(seed.xy), random(seed.yx), random(seed.xx));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 65, 65, 744]], "test": "untested"}
{"id": "fdyXDG", "name": "Mandeltrip", "author": "RubberDuck55", "description": "Mandelbrot set coded in GLSL, but trippy.", "tags": ["fractal"], "likes": 2, "viewed": 304, "published": 3, "date": "1635200053", "time_retrieved": "2024-07-30T18:53:08.730370", "image_code": "void rotate(inout vec2 p,float angle,vec2 rotationOrigin)\n{\n    p -= rotationOrigin;\n    p *= mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    p += rotationOrigin;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float modtime = sin(iTime/10.+4.71238)*15.+15.;\n    float tcubed = modtime*modtime*modtime;\n    \n    vec2 zv = vec2(0.729, 0.14);\n    vec2 uv = (fragCoord)/iResolution.xy / vec2(iResolution.y / iResolution.x, 1.) - vec2(0.5, 0);\n    rotate(uv, length(uv)*(modtime/15.), vec2(0., 0.));\n    rotate(uv, modtime, vec2(0.5,0.5));\n    uv = vec2((uv.x-zv.x)/(tcubed+1.)+zv.x, (uv.y-zv.y)/(tcubed+1.)+zv.y);\n\n    vec2 mbv = vec2((uv.x*2.47-2.), (uv.y*2.24-1.12));\n    vec2 v = vec2(0);\n    int iter = 0;\n    int maxiter = int(modtime*10.+100.);\n    \n    while(v.x*v.x + v.y*v.y <= 4. && iter < maxiter){\n        float xtemp = v.x*v.x - v.y*v.y + mbv.x;\n        v = vec2(xtemp, 2.*v.x*v.y + mbv.y);\n        iter++;\n    }\n    \n    vec3 col = vec3(hsv2rgb(vec3(float(iter)/200.+modtime+0.66, 1., 1.)));\n    //if(iter == maxiter) col = vec3(0);\n\n    //col = vec3(fract(uv.xy*17.), col.b);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 172], [174, 174, 196, 196, 365], [367, 367, 424, 424, 1343]], "test": "untested"}
{"id": "7sySDG", "name": "Fab26 #inktober2021 \"connect\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n", "tags": ["2d", "short", "inktober2021"], "likes": 21, "viewed": 305, "published": 3, "date": "1635196878", "time_retrieved": "2024-07-30T18:53:09.480365", "image_code": "#define S(v)     smoothstep( 15./R.y, 0., v )\n#define C(C)     S( length(F-C) -.1 )\n\nfloat L(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );                                  // dist to segment\n}\n\nvoid mainImage(out vec4 O, vec2 u ) \n{\n    vec2  R = iResolution.xy,\n          U = 10.* u / R.y, I,F,D;     \n    if ( mod(U.x,2.) >= 1. ) U.y += .5; \n    I = floor(U), F = fract(U);\n    D = I + d*floor(iTime);  \n\n    O =  ( C(vec2(0,.5)) + C(vec2(1,0)) + C(1.) )              // dots\n        * vec4(.8,.8,0,1);\n        \n    float v = sign(H(D).x-.5),                                 // current and previous step\n         _v = sign(H(D-d).x-.5);\n    v = mix( _v, v, min(1.,2.*fract(iTime)) );                 // transition\n    v = L( F, vec2(0,.5), vec2(1,.5+.5*v ));\n    O +=  (1.-O.a) *  S(v);                                    // draw connectors\n    if ( T(I)>0. ) O.r += (1.-O.a) * S(v/5.); // (.06/v-.2);   // red glow along flux\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 O, vec2 I ) \n{\n    if (I.x>18. || I.y > 11. ) return;\n    if ( iFrame==0 || fract(iTime)<.1 ) { O-=O; return; }\n    \n    I-=.5;\n    bool i = mod(I.x,2.)>0.;\n    vec2 D = I + d*floor(iTime);\n            \n    if ( I==vec2(0,5) ) O.z = 1.;                        // flux source\n    else { \n        O.z = T(I);                                      // previous state\n#define C(Y,i) if( H( D - vec2(1,Y) ).x < .5 == i ) O.z += T( I - vec2(1,Y) )\n        C( 0, i );                                       // test the 2 upstream connectors. \n        C( i?1:-1, !i );                                 // if connected, propagate flux.\n    }  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define H(p)   fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(I)   texelFetch(iChannel0, ivec2(I), 0).z\n\nvec2  d = 1./vec2(1024,2048); // random seed offset along time. pow2 for robustness", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sySDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 117, 117, 258], [260, 260, 298, 298, 996]], "test": "untested"}
{"id": "sdySWG", "name": "Lightning Effect [Reproduction]", "author": "Yusef28", "description": "From Soerbgames Twitter: https://twitter.com/SoerbGames/status/1233059213716402176\nGaussian Blur from FabriceNeyret2: https://www.shadertoy.com/view/ltScRG\nAnisopropic effect from ulianlumia: https://www.shadertoy.com/view/wtlfz8", "tags": ["lightning", "reproduction"], "likes": 35, "viewed": 1563, "published": 3, "date": "1635192693", "time_retrieved": "2024-07-30T18:53:10.342061", "image_code": "/*\n\nThe idea is a direct reproduction of Soerbgames Twitter:\nhttps://twitter.com/SoerbGames/status/1233059213716402176\nIt's a tutorial, but not a glsl tutorial so that's what\nI added.\n\n1. Start with a line\n2. Move it up and down (parabolically from the center\n3. Add a sine wave component\n4. Add a noise component\n5. Add more of these\n6.Post process (Bloom and Anisotropic filtering I guess)\n\n\n3d could be cool.\n\n*/\n\n//Single pass Gaussian blur by FabriceNeyret2\n//https://www.shadertoy.com/view/ltScRG\n\n//anisotrpic effect by ulianlumia \n//https://www.shadertoy.com/view/wtlfz8\n\n//fragColor initialized \n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    float f = length((uv+0.5)  - 0.6);\n    fragColor.x += T(uv + f*0.006).x;\n    fragColor.y += T(uv).y;\n    fragColor.z += T(uv - f*0.006).z;\n\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define boltNum 8.\n\nfloat hash(float x){\n    return fract(sin(x*12.)*42119.);\n}\n\nfloat noise(float x){\n    float a = hash(floor(x));\n    float b = hash(floor(x) + 1.);\n    float f = fract(x);\n  \n    return mix(a,b,f);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(61,59,77)/325.;//mix(vec3(0.3,0.4,0.2),vec3(0.4,0.,0.9),(1.-length(uv))/1.);\n    //col = mix(col,vec3(1.),(1.-length(uv))/9.);\n    col += vec3(2.-length(uv)-0.6)/9.;\n    float t = iTime/1.+5.;\n    float bend,y,f;\n    for(float i = 0.; i < boltNum; i++){\n        \n        //line \n        //y = 0.;\n        \n        //bend line in middle every second\n        bend = fract(t*(1.+(boltNum-i)/4.)+i/7.+i/8.)*0.13-0.13/2.;\n        bend *= 1.5;\n        y = bend*2. + (1.-uv.x*uv.x)*bend;\n        \n        //add sinewave\n        float randomOff = hash(floor(t*3. + i));\n        y += sin(uv.x*1.6+t*(3.) + randomOff*3.5 + i*80.)/3.;\n        \n        randomOff = hash(floor(t*2.));\n        y += noise(uv.x*6.+t*1. + randomOff*(10.5+i*8.))/5.;\n        //(fract(iTime*2.+uv.x*2.)/5.); \n        \n        //bring everything to 0 at edges\n        y = mix(y, .0, abs(uv.x/2.)/1.2);\n        //draw\n        float f = pow(1.0-smoothstep(0.02,0.5,pow(abs(y-uv.y), 0.5)),4.+i*1.9);\n        //1.0-smoothstep(0.0,0.02,pow(abs(y-uv.y)/fwidth(y-uv.y)/(25.-i*2.),2.));\n        col = mix(col, vec3(1.), f);\n    }\n\n    // Output to screen\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.25); \n    \n    fragColor = vec4(col*vig,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "//Single pass Gaussian blur by FabriceNeyret2\n//https://www.shadertoy.com/view/ltScRG\n\n//another that might work ok is: https://www.shadertoy.com/view/Xltfzj\n\n\n\n// 16x acceleration of https://www.shadertoy.com/view/4tSyzy\n// by applying gaussian at intermediate MIPmap level.\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = blur( iChannel0, U/iResolution.xy, 1./iChannelResolution[0].xy );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Just adding Buffer A and Buffer B\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    fragColor =  texture(iChannel0,uv) + texture(iChannel1,uv)/2.;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdySWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[644, 644, 701, 751, 963]], "test": "untested"}
{"id": "fdGXDy", "name": "3-Simplex Fog", "author": "paniq", "description": "demonstrating closed form integral for color interpolated fog on an animated 3-simplex", "tags": ["raytracing", "ray", "intersection", "tetrahedron"], "likes": 59, "viewed": 1254, "published": 3, "date": "1635189611", "time_retrieved": "2024-07-30T18:53:11.202760", "image_code": "#define DEBUG_LIGHT 0\n#define DEBUG_NORMAL 0\n\n// calculates the definite line integral of alphablending two colors through a fog volume\n// T is the logarithmic transmittance (0 .. -inf)\n// d is the distance of the ray\n// x is the end of the integral (0..1); pass 1 here if not sure\n// returns color mixing factors and alpha\nvec3 color_fog_mix_coeffs(float T, float d, float x) {\n    float Td = T*d; // scale transmittance by ray length\n    float acc_alpha = exp(Td*x); // occlusion accumulated along integral    \n    // integrated alpha\n    float w = 1.0 - acc_alpha;\n    // integrated color\n    float v = x * acc_alpha / (acc_alpha - 1.0) - 1.0 / Td;\n    float u = 1.0 - v;\n    return vec3(u, v, w);\n}\n\n// compute the barycentric transform matrix\nmat3 compute_bary_transform(vec3 p[4]) {\n    vec3 e[6];\n    e[0] = p[2] - p[1];\n    e[1] = p[0] - p[2];\n    e[2] = p[1] - p[0];\n    e[3] = p[1] - p[3];\n    e[4] = p[2] - p[3];\n    e[5] = p[0] - p[3];\n    mat3 m = mat3(\n    \tcross(e[0], e[3]),\n    \tcross(e[1], e[4]),\n    \tcross(e[2], e[5]));\n    float invdet = 1.0/dot(m[0], e[1]);\n    // premultiply the plane orthogonals by the inverse determinant\n    return m * invdet;\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec4 to_bary(vec3 p3, mat3 m, vec3 t) {\n    // weights are scaled distance of point to individual planes\n    vec3 w = (t - p3) * m;\n    float ww = 1.0 - w.x - w.y - w.z;\n    return vec4(w, ww);    \n}\n\nvec3 from_bary(vec3 p[4], vec4 w) {\n\treturn p[0] * w.x + p[1] * w.y + p[2] * w.z + p[3] * w.w;\n}\n\nvec3 normal_from_bary(mat3 m, vec4 w) {\n    return normalize(m * (w.w - w.xyz));\n}\n\nstruct Hit {\n    // ray scalar\n    float t;\n    // barycenter\n    vec4 b;\n    // normal\n    vec3 n;\n};\n\n// return normal of nearest plane in barycentric coordinates\nvec4 select_plane_normal(vec4 b) {\n    float lc = min(min(b.x, b.y), min(b.z, b.w));\n    return step(b, vec4(lc));\n}\n\n// return the intersection of ray and tetrahedron\n// as well as the barycentric coordinates and normals of the hit points\nbool iSimplex3(vec3 p[4], vec3 ro, vec3 rd, \n\tout Hit near, out Hit far) {\n    \n    mat3 m = compute_bary_transform(p);\n    \n    // convert ray endpoints to barycentric basis\n    vec4 r0 = to_bary(p[3], m, ro);\n    vec4 r1 = to_bary(p[3], m, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    \n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    // valid since GL 4.1\n    near.t = -1.0 / 0.0;\n    far.t = 1.0 / 0.0;\n    \n#if 0\n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far.t = min(far.t, t[i]);\n        } else {\n            near.t = max(near.t, t[i]);\n        }\n    }\n#else\n    // loopless, branchless alternative\n    // equivalent to checking dot product of ray dir and plane normal    \n    bvec4 comp = lessThan(brd, vec4(0.0));\n    vec4 far4 = mix(vec4(far.t), t, comp);\n    vec4 near4 = mix(t, vec4(near.t), comp);\n    far.t = min(min(far4.x,far4.y),min(far4.z,far4.w));\n    near.t = max(max(near4.x,near4.y),max(near4.z,near4.w));\n#endif\n    \n    if ((far.t <= 0.0) || (far.t <= near.t))\n        return false;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n\n    vec4 n0 = select_plane_normal(near.b);\n    vec4 n1 = select_plane_normal(far.b);\n    near.n = normal_from_bary(m, n0);\n    far.n = normal_from_bary(m, n1);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = iTime * 0.1;\n    float d = 2.5;\n\tcamPos = vec3(d*sin(an),1.0,d*cos(an));\n    camTar = vec3(0.0,-0.3,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 feet_curve(float t) {\n    float subt = mod(t, 3.0);\n    float x = sin(radians(min(subt*180.0,180.0)));\n    float a0 = radians((t - subt)/3.0 * 30.0);\n    float a1 = a0 + radians(30.0);\n    float a = mix(a0, a1, min(subt,1.0));\n\treturn vec3(cos(a),sin(a),mix(-1.0,-0.8,x));\n}\n\nfloat fog_light(vec3 n, vec3 l) {\n    return mix(0.1, 1.0, 0.5+0.5*-dot(n, l));\n}\n\nvec3 calc_intersection( in vec3 ro, in vec3 rd ) {\n    ro = ro.zxy;\n    rd = rd.zxy;\n    vec3 p[4];\n    float ti = iTime * 8.0;\n    p[0] = feet_curve(ti);\n    p[1] = feet_curve(ti + 12.0 + 1.0);\n    p[2] = feet_curve(ti + 24.0 + 2.0);\n    // do a little spring animation\n    ti = iTime * 4.0;\n    vec2 cuv = hash21(float(int(ti / 5.0))) * 2.0 - 1.0;\n    ti = mod(ti, 5.0) * 2.0;\n    float rk = (10.0 - ti) / (1.0 + (10.0 - ti));\n    float spr = clamp(rk * ((8.0 - sin(ti * 8.0) / (ti * ti))/8.0), 0.0, 2.0);\n    p[3] = vec3(0.0,0.0,0.5);//vec3(mix(vec2(0.0), cuv, spr), mix(-0.7, 0.5, spr));\n    \n    vec3 l = normalize(vec3(1.0, -1.0, -1.0));\n    \n    float plane_t = -(ro.z + 1.0) / rd.z;\n    \n    float alpha = 0.8;\n    \n    Hit h0, h1;\n    vec3 col = vec3(0.0);\n    if (plane_t > 0.0) {\n\t    vec3 plane_p = ro + rd * plane_t;\n        col = vec3(abs(rd.z));\n        float sh = 0.5;\n        if (iSimplex3(p, plane_p, -l, h0, h1)) {\n            vec3 fog = color_fog_mix_coeffs(1.0 - 1.0/(1.0 - alpha), h1.t - h0.t, 1.0);\n            sh = mix(sh, 0.25, fog.z);\n        }\n        col *= sh;\n    } else {        \n        col = vec3(0.0);\n    }\n    \n    // smooth normals for the fog\n    vec3 n0 = normalize(p[0] - (p[1] + p[2] + p[3])/3.0);\n    vec3 n1 = normalize(p[1] - (p[2] + p[3] + p[0])/3.0);\n    vec3 n2 = normalize(p[2] - (p[3] + p[0] + p[1])/3.0);\n    vec3 n3 = normalize(p[3] - (p[0] + p[1] + p[2])/3.0);\n    \n    if (iSimplex3(p, ro, rd, h0, h1)) {\n        Hit w0, w1;\n        \n#if 1\n        vec3 C[4] = vec3[](\n            vec3(0.0, 1.0, 0.5)*fog_light(n0, l),\n            vec3(1.0, 0.5, 0.0)*fog_light(n1, l),\n            vec3(1.0, 0.0, 0.5)*fog_light(n2, l),\n            vec3(0.5, 0.0, 1.0)*fog_light(n3, l)\n        );\n#else\n        vec3 C[4] = vec3[](\n            vec3(0.1, 1.0, 0.1),\n            vec3(1.0, 0.1, 0.1),\n            vec3(0.1, 0.1, 1.0),\n            vec3(0.0)\n        );\n#endif\n        \n        vec3 c0 = h0.b.x * C[0] + h0.b.y * C[1] + h0.b.z * C[2] + h0.b.w * C[3];\n        vec3 c1 = h1.b.x * C[0] + h1.b.y * C[1] + h1.b.z * C[2] + h1.b.w * C[3];\n        \n        vec3 fog = color_fog_mix_coeffs(1.0 - 1.0/(1.0 - alpha), h1.t - h0.t, 1.0);\n        \n        col = mix(col, c0*fog.x + c1*fog.y, fog.z);\n    }\n    \n    return col;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    col = calc_intersection( ro, rd );\n\t   \n    fragColor = vec4( linear_srgb(ACESFitted(col*1.5)), 1.0 );\n}", "image_inputs": [], "common_code": "// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 324, 378, 378, 702], [704, 748, 788, 788, 1172], [1174, 1306, 1345, 1410, 1505], [1507, 1507, 1542, 1542, 1603], [1605, 1605, 1644, 1644, 1687], [1793, 1854, 1888, 1888, 1970], [1972, 2094, 2168, 2168, 3519], [3596, 3596, 3679, 3679, 3802], [3805, 3805, 3832, 3832, 3867], [3960, 3960, 3982, 3982, 4095], [4097, 4097, 4123, 4123, 4376], [4378, 4378, 4411, 4411, 4459], [6720, 6720, 6784, 6784, 6962], [6964, 6964, 7021, 7021, 7611]], "test": "untested"}
{"id": "fsyXWy", "name": "sunrise, sunset", "author": "droidkid", "description": "Trying out some exercises from the book of shaders.", "tags": ["bookofshaders"], "likes": 1, "viewed": 261, "published": 3, "date": "1635182732", "time_retrieved": "2024-07-30T18:53:12.153218", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 background = vec3(0.2, 0.2, 0.2);\n    vec3 sunColor = vec3(0.996, 0.364, 0.160);\n    vec3 innerSun = vec3(1.00,0.65,0.00);\n    vec3 ground1 = vec3(0.301, 0.286, 0.274);\n    vec3 ground2 = vec3(0.552, 0.447, 0.270);\n\n    vec3 col;\n    if (uv.y > 0.3) {\n        vec2 sun_pos = vec2(0.5, sin(iTime) * 0.5 - 0.18);\n        float dist = distance(sun_pos, uv.xy);\n        vec3 rayCol = mix(sunColor, background, dist);\n        \n        vec3 innerSunCol = mix(innerSun, rayCol, smoothstep(0.0, 0.02, dist));\n        col = innerSunCol;\n\n    } else {\n        col = mix(ground1, ground2, uv.y / 0.2);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 741]], "test": "untested"}
{"id": "7dGXRt", "name": "Plotting Functions", "author": "droidkid", "description": "fun with trig functions in shadertoy", "tags": ["maths"], "likes": 1, "viewed": 226, "published": 3, "date": "1635182524", "time_retrieved": "2024-07-30T18:53:12.906205", "image_code": "vec3 plot(float dist, vec3 color, float thickness) {\n    return color * (smoothstep(-thickness, 0.0, dist) - smoothstep(0.0, thickness, dist));\n} \n\nvec3 y_axis(vec2 uv) {\n    float dist = (uv.x - 0.5);\n    return plot(dist, vec3(1.0, 1.0, 0.0), 0.002);\n}\n\nvec3 x_axis(vec2 uv) {\n    float dist = (uv.y - 0.5);\n    return plot(dist, vec3(1.0, 1.0, 0.0), 0.003);\n}\n\nvec3 yx_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float dist = abs(point.x - point.y);\n    return plot(dist, vec3(0.0, 1.0, 0.0), 0.003);\n}\n\nvec3 sin_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float val = 0.4 * sin(iTime) * sin(point.x * 3.14 * 5. + iTime*2.);\n    float dist = abs(val - point.y);\n    return plot(dist, vec3(1.0, 0.0, 0.0), 0.02);\n}\n\nvec3 cos_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float val = 0.3 * cos(iTime) * cos(point.x * 3.14 * 5. + iTime*5.);\n    float dist = abs(val - point.y);\n    return plot(dist, vec3(1.0, 0.0, 1.0), 0.02);\n}\n\nvec3 tan_line(vec2 uv) {\n    vec2 point = uv - 0.5;\n    float val = 0.3 * cos(iTime) * tan(point.x * 3.14 * 5. + iTime*4.);\n    float dist = abs(val - point.y);\n    return plot(dist, vec3(1.0, 1.0, 0.0), 0.02);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //vec4 yaxis_color = vec4(y_axis(uv), 1.0);\n    //vec4 xaxis_color = vec4(x_axis(uv), 1.0);\n    //vec4 yx_color = vec4(yx_line(uv), 1.0);\n    vec4 sin_color = vec4(sin_line(uv), 1.0);\n    vec4 cos_color = vec4(cos_line(uv), 1.0);\n    vec4 tan_color = vec4(tan_line(uv), 1.0);\n\n\n    //fragColor = vec4(max(yaxis_color, xaxis_color));\n    //fragColor = vec4(max(fragColor, yx_color));\n    fragColor = vec4(max(fragColor, sin_color));\n    fragColor = vec4(max(fragColor, cos_color));\n    fragColor = vec4(max(fragColor, tan_color));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 145], [148, 148, 170, 170, 254], [256, 256, 278, 278, 362], [364, 364, 387, 387, 508], [510, 510, 534, 534, 722], [724, 724, 748, 748, 936], [938, 938, 962, 962, 1150], [1153, 1153, 1210, 1260, 1846]], "test": "untested"}
{"id": "7sVSRd", "name": "TheTunnel", "author": "z0rg", "description": "TheTunnel", "tags": ["tunnel"], "likes": 19, "viewed": 393, "published": 3, "date": "1635178138", "time_retrieved": "2024-07-30T18:53:13.755933", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).xyz,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nfloat _rsqr(vec2 uv, vec2 s, float r)\n{\n    vec2 l = abs(uv)-s;\n    return min(length(max(l, 0.)+min(max(l.x, l.y), 0.))-r, max(l.x, l.y));\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    l = abs(l)-s*.3;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat _sqr(vec2 uv, vec2 s)\n{\n    vec2 l = abs(uv)-s;\n    return max(l.x, l.y);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(1000.,-1.);\n    \n    float tunnel = -_rsqr(p.xy, vec2(3., 1.), .4);\n    tunnel = max(tunnel, abs(p.z)-10.);\n    acc = _min(acc, vec2(tunnel, 0.));\n    \n    vec3 pc1 = p-vec3(sin(iTime*.5),.4*sin(iTime),8.+2.*sin(iTime*1.5));\n    pc1.xy *= r2d(iTime+sin(iTime*.2));\n    pc1.xz *= r2d(-iTime*.5);\n    float cubes = _cube(pc1, vec3(.4));\n    \n    acc = _min(acc, vec2(cubes, 1.));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i< steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getEnv(vec3 rd)\n{\n    return 2.*texture(iChannel0, rd*vec3(1.,-1.,1.)*vec3(15.,15.,1.)+vec3(0.,.5,0.)).xyz*vec3(0.357,0.745,0.565);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 off = (vec3(rand(),rand(),rand())-.5)*2.;\n    vec3 ro = vec3(sin(iTime*.2),1.3,-5.)+off*.005;\n    vec3 ta = vec3(0.,1.1,6.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    rd = normalize(rd-off*.001);\n    vec3 res = trace(ro,rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro +rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        if (res.z  == 0.)\n        {\n            vec2 uvt = vec2(atan(p.y, p.x)*7., p.z);\n        \n            vec2 rep = vec2(.5);\n            uvt = mod(uvt+rep*.5,rep)-rep*.5;\n            float carrelage = _sqr(uvt, vec2(.2));\n            vec3 tng = normalize(cross(rd, n));\n            n = normalize(n+tng*sat(carrelage*10.)*.5+texture(iChannel1, 3.*p.xy*vec2(1.,10.)).xxx*.05);\n            n = normalize(n+(vec3(rand(),rand(), rand())-.5)*.05);\n            vec3 rdrefl = normalize(reflect(rd, n));\n            vec3 resrefl = trace(p-n*0.01, rdrefl, 128);\n            if (resrefl.y > 0.)\n            {\n                col = vec3(0.075,0.427,0.427)*(1.-sat(carrelage))*.5\n                *(1.-sat(length(uv*1.)));\n            }\n            else\n                col = getEnv(rdrefl);\n        } \n    }\n    else\n        col = getEnv(rd);\n    \n    col = mix(col, vec3(0.894,0.969,0.631), pow(sat(length(col)), 25.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel1,uv).x;\n    seed+=fract(iTime);\n    vec3 col = rdr(uv);\n    col = mix(col, texture(iChannel2, fragCoord/iResolution.xy).xyz, .75);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVSRd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 550]], "test": "untested"}
{"id": "7sGSRd", "name": "Figure-8 Knot", "author": "iq", "description": "A figure-8 knot, as described by François Guéritaud, Saul Schleimer, and Henry Segerman here: [url]http://gallery.bridgesmathart.org/exhibitions/2019-icerm-illustrating-mathematics/henrys[/url].", "tags": ["3d", "knot", "projective"], "likes": 100, "viewed": 2698, "published": 3, "date": "1635174616", "time_retrieved": "2024-07-30T18:53:14.848014", "image_code": "// Copyright Inigo Quilez, 2021 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// This is a figure-8 knot, as described by François Guéritaud, Saul\n// Schleimer, and Henry Segerman here:\n//\n// http://gallery.bridgesmathart.org/exhibitions/2019-icerm-illustrating-mathematics/henrys\n// \n// It's defined in S3 (ie, the surface of a 4-dimensional hypersphere),\n// and then projected to R3 (regular 3D space) through a stereographic\n// projection. The extrussion of the path into a tube is done in R3.\n// I Tried adaptive subdivision, and worked well, but not completely.\n\n#define AA 1              // make 2 on fast machines\n\nconst int   kNum = 256;   // subdivisions. make 1024 on fast machines\nconst float kRad = 0.06;  // thickness\n\n\n// knot\nvec3 knot( in float t )\n{\n    t *= 6.283185;\n\n    // knot in S3\n    const float e = 0.16;\n    const float h = 0.25;\n    float a = e*sin(4.0*t);\n    float b = 1.0-a*a;\n    vec4 q = vec4 ( \n      b*(h*cos(t)+(1.0-h)*cos(3.0*t)),\n      b*(2.0*sqrt(h-h*h)*sin(2.0*t)),\n      a*(2.0),\n      b*(h*sin(t)-(1.0-h)*sin(3.0*t))\n      )\n      / (1.0+a*a);\n    \n    // rotate in the xw plane (in S3)\n    float a1 = iTime*6.283185/10.0;\n    q.xw *= mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n    \n    // stereographic projection from S3 to R3\n    vec3 p = q.xyz/(1.0-q.w);\n  \n    // scale\n    return p * 0.25;\n}\n\n//-------------------------------------------------------\n\n// intersects a capsule (single cap)\n// https://iquilezles.org/articles/intersectors\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra, \n                out float v )\n{\n    vec4 res = vec4(-1.0);\n\n    v = 0.0;\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float ocrd = dot(oc,rd);\n    float ococ = dot(oc,oc);\n      \n    float a = baba - bard*bard;\n    float b = baba*ocrd - baoc*bard;\n    float c = baba*ococ - baoc*baoc - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        // body\n        float y = baoc + t*bard;\n        if( y>0.0 && y<baba )\n        {\n            v = y/baba;\n            res = vec4(t,(oc+t*rd-ba*v)/ra);\n        }\n        // sphere cap\n        else \n        {\n            h = ocrd*ocrd - ococ + ra*ra;\n            if( h>0.0 )\n            {\n                t = -ocrd - sqrt(h);\n                res = vec4(t,(oc+t*rd)/ra);\n            }\n        }\n    }\n    \n    return res;\n}\n\n// intersects a capsule\n// https://iquilezles.org/articles/intersectors\nbool sCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ba = pb-pa;\n    vec3 oc = ro-pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    float ocrd = dot(oc,rd);\n    float ococ = dot(oc,oc);\n    \n    float a = baba - bard*bard;\n    float b = baba*ocrd - baoc*bard;\n    float c = baba*ococ - baoc*baoc - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        // body\n        float y = baoc + t*bard;\n        if( t>0.0 && y>0.0 && y<baba ) return true;\n        // sphere cap\n        h = ocrd*ocrd - ococ + ra*ra;\n        if( h>0.0 )\n        {\n            //if( h*h<-ocrd*abs(ocrd) ) return true;\n            t = -ocrd - sqrt(h);\n            if( t>0.0 ) return true;\n        }\n    }\n    \n    return false;\n}\n\n// intersects the knot\nvec4 intersect( in vec3 ro, in vec3 rd, out float resV )\n{\n    // subdivide the knot, and find intersections\n    float   v = 0.0;\n    vec4 tnor = vec4(1e20);\n    vec3   op = knot(0.0);\n    for( int i=1; i<=kNum; i++ )\n    {\n        // parameter\n        float t = float(i)/float(kNum);\n\n        // evaluate knot\n        vec3 p = knot(t);\n\n        // segments\n        float tmpv;\n        vec4 tmp = iCylinder( ro, rd, op, p, kRad, tmpv );\n        if( tmp.x>0.0 && tmp.x<tnor.x ) { tnor = tmp; v=t+(tmpv-1.0)/float(kNum); }\n\n        op = p;\n    }\n    \n    resV = v;\n\n    return tnor;\n}\n\n// intersects the knot\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    // subdivide the knot, and find intersections\n    vec3 op = knot(0.0);\n    for( int i=1; i<=kNum; i++ )\n    {\n        // parameter\n        float t = float(i)/float(kNum);\n        \n        // evaluate knot\n        vec3 p = knot(t);\n        \n        // segments\n        if( sCylinder( ro, rd, op, p, kRad ) ) return 0.0;\n\n        op = p;\n    }\n    \n    return 1.0;\n}\n\n// do coloring and lighting\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, in float hm )\n{\n    // material - base color\n    vec3 mate = 0.5 + 0.5*cos(hm*6.283185+vec3(0.0,2.0,4.0));\n\n    // material - white stripes\n    vec3 cen = knot(hm); \n    vec3 w = normalize(knot(hm+0.001)-cen);\n    vec3 v = vec3(w.y,-w.x,0.0)/length(w.xy);\n    vec3 u = normalize(cross(v,w));\n    float an = atan( dot(pos-cen,u), dot(pos-cen,v) );\n    float ar = an - 30.0*hm + iTime;\n    mate += 1.5*smoothstep(-0.3,0.8,sin(6.283185*ar));\n\n    // sky lighting\n    vec3 ref = reflect(rd,nor);\n    float dif = 0.5+0.5*nor.y;\n    float spe = smoothstep(0.1,0.2,ref.y);\n    spe *= dif;\n    spe *= 0.04 + 0.96*pow( clamp(1.0+dot(rd,nor), 0.0, 1.0), 5.0 );\n    if( spe>0.001 ) spe *= shadow(pos+nor*0.001, ref);\n    vec3 col = 0.6*mate*vec3(1.0)*dif + spe*6.0;\n\n    // sss\n    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n    col += fre*fre*(0.5+0.5*mate)*(0.2+0.8*dif);\n\n    // self occlusion\n    float occ = 0.0;\n    for( int i=1; i<=kNum/4; i++ )\n    {\n        float h = float(i)/float(kNum/4);\n        vec3  d = knot(h) - pos;\n        float l2 = dot(d,d);\n        float l = sqrt(l2);\n        float f = dot(d/l,nor);\n        occ = max(occ, f*exp2(-l2*8.0) );\n        occ = max(occ, f*1.5*kRad*kRad/l2 );\n    }\n    col *= 1.0-occ;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.0*iTime;\n\tvec3 ro = vec3( 1.0*sin(6.283185*an), 0.0, 1.0*cos(6.283185*an) );\n    vec3 ta = vec3( 0.0, 0.02, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // background\n        vec3 col = vec3(0.17*(1.0-0.15*dot(p,p))*smoothstep(-1.0,1.0,rd.y));\n\n        // raytrace knot\n        float hm;\n        vec4 tnor = intersect( ro, rd, hm );\n        if( tnor.x<1e19 )\n        {\n            col = shade( ro+tnor.x*rd, tnor.yzw, rd, hm );\n        }\n        \n        // gain\n        col *= 1.4/(1.0+col);\n        // tint\n        col = pow( col, vec3(0.8,0.95,1.0) );\n        \n        // color to perceptual space\t\n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n \n    // remove color banding through dithering\n    tot += (1.0/255.0)*fract(sin(fragCoord.x*7.0+17.0*fragCoord.y)*1.317);\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGSRd.jpg", "access": "api", "license": "proprietary-license", "functions": [[1422, 1430, 1455, 1455, 2025], [2086, 2171, 2294, 2294, 3159], [3161, 3233, 3326, 3326, 4075], [4077, 4100, 4158, 4208, 4682], [4684, 4707, 4747, 4797, 5116], [5118, 5146, 5211, 5240, 6440]], "test": "untested"}
{"id": "fsGXWG", "name": "galaxyyy", "author": "rifke", "description": "optimized from https://www.shadertoy.com/view/MdXSzS", "tags": ["galaxy", "universes"], "likes": 19, "viewed": 1052, "published": 3, "date": "1635172364", "time_retrieved": "2024-07-30T18:53:15.606985", "image_code": "// optimized from https://www.shadertoy.com/view/MdXSzS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy/iResolution.xy)-.5;\n\tfloat len = length(uv.xy);\n\t\n    float t = .01*iTime;\n\tfloat time = t  +  (5.+sin(t))*.11 / (len+.07); // spiraling\n\tfloat si = sin(time), co = cos(time);\n\tuv *= mat2(co, si, -si, co);                    // rotation\n\n\tfloat c=0., v1=0., v2=0., v3;  vec3 p;\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tp = .035*float(i) *  vec3(uv, 1.);\n\t\tp += vec3(.22,  .3,  -1.5 -sin(t*1.3)*.1);\n\t\t\n\t\tfor (int i = 0; i < 8; i++)                // IFS\n\t\t\tp = abs(p) / dot(p,p) - 0.659;\n\n\t\tfloat p2 = dot(p,p)*.0015;\n\t\tv1 += p2 * ( 1.8 + sin(len*13.0  +.5 -t*2.) );\n\t\tv2 += p2 * ( 1.5 + sin(len*13.5 +2.2 -t*3.) );\n\t}\n\t\n\tc = length(p.xy) * .175;\n\tv1 *= smoothstep(.7 , .0, len);\n\tv2 *= smoothstep(.6 , .0, len);\n\tv3  = smoothstep(.15, .0, len);\n\n\tvec3 col = vec3(c,  (v1+c)*.25,  v2);\n\tcol = col  +  v3*.9;                      // useless: clamp(col, 0.,1.)\n\tfragColor=vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 113, 113, 1021]], "test": "untested"}
{"id": "sdKXzd", "name": "shield field", "author": "mdb", "description": "test of a futuristic force shield", "tags": ["bloom", "shield"], "likes": 30, "viewed": 1262, "published": 3, "date": "1635170671", "time_retrieved": "2024-07-30T18:53:16.362963", "image_code": "//apply bloom effect\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 bloom(vec2 uv){\n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j){\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j){\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i){\n        vec3 c = texture(iChannel0, uv + vec2(0, i) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c;\n  \n    }\n    return final_colour/(Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).rgb;\n    col += 0.5*bloom(uv);\n    col = clamp(col, 0.0, 1.0);\n    col = col*col*(3.0 - 2.0*col);\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 iSphere(vec3 ro, vec3 rd){\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - 1.0;\n\tfloat delta = b*b - c;\n\tif(delta < 0.0) return vec2(-1.0);\n    return -b + vec2(-1.0, 1.0)*sqrt(delta);\n}\n\nvec4 hexagon( vec2 p ) //from https://www.shadertoy.com/view/Xd2GR3\n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nvec3 trace(vec3 ro, vec3 rd){\n       vec2 sphere = iSphere(ro, rd);\n       float plane = -(ro.y - 0.2)/rd.y;\n       if(plane < 0.0 && sphere.x < 0.0) return vec3(0.1);\n       if((plane > 0.0 && plane < sphere.x)|| sphere.x < 0.0){\n           float d = 0.02/(abs(length(ro + plane*rd) - 1.0)+0.01);\n           return vec3(0.1 + 0.05/(plane+1.0)) + vec3(0.690, 0.494, 0.905)*d;\n       }else{\n           vec3 col = vec3(0.0);\n           vec3 p = ro + sphere.x*rd;\n           vec3 normal = p;\n           vec2 uv = mod(vec2(atan(p.x, p.z)/3.14195+0.5 + iTime*0.05, p.y*0.5+0.5), vec2(1.0));\n           vec4 hexa = hexagon(uv*29.4);\n           \n           float frs = 1.0 + dot(normal, rd);\n           frs = max(frs, 1.0 - abs((p.y - 0.2)*7.0));\n           frs = pow(frs, 3.0)*3.0;\n           col += vec3(0.690, 0.494, 0.905)*frs;\n           col += 7.0*vec3(0.376, 0.333, 0.847)*smoothstep(0.05, 0., hexa.z)*max(0.01, frs);\n           col += vec3(0.121, 0.741, 0.615)*smoothstep(0.3, 0., hexa.z)*max(0.1, frs);\n           col += vec3(0.121, 0.741, 0.615)*0.1;\n           if(sphere.y < plane){\n               p = ro + sphere.y*rd;\n               col += vec3(0.666, 0.996, 0.839)*vec3(0.376, 0.333, 0.847)*pow(max(0.0, 1.0 - abs((p.y - 0.2)*5.0)), 3.0);\n           }\n           \n           if(plane > 0.0){\n               float d = 0.2/(abs(length(ro + plane*rd) - 1.0)+0.1);\n               col += vec3(0.666, 0.996, 0.839)*vec3(0.690, 0.494, 0.905)*d;\n           }\n         \n           return vec3(col);\n       }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0.0, 0.0, 1.0)*1.7;\n    vec3 dir0 = normalize(-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(dir0, up));\n    up = cross(dir0, right);\n    \n    vec3 ro = camPos;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < AA; i++){\n        for(int j = 0; j < AA; j++){\n           vec3 rd = normalize(dir0 \n                       + up*(uv.y+float(j)/iResolution.y/float(AA))\n                       + right*(uv.x+float(i)/iResolution.x/float(AA)));\n            col += trace(ro, rd); \n        }\n    }\n    col /= float(AA*AA);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "//apply bloom effect\nfloat normpdf(in float x, in float sigma){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    \n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        vec3 c = texture(iChannel0, (fragCoord.xy+vec2(i, 0)) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c;\n  \n    }\n\n\n    fragColor = vec4(final_colour/(Z), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sigma = 7.0;\nconst int mSize = 30;\n\n#define AA 2", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 64, 64, 117], [119, 119, 139, 159, 780], [782, 782, 839, 839, 1124]], "test": "untested"}
{"id": "NdySWG", "name": "Constant Alpha Trilinear Fog", "author": "paniq", "description": "Closed form fog integral of eight trilinearly interpolated colors. The solution actually integrates a linear interpolation, so can also easily be adapted for barycentric interpolation as well i.e. any tetrahedron.", "tags": ["blending", "trilinear", "interpolation", "alpha"], "likes": 28, "viewed": 774, "published": 3, "date": "1635170614", "time_retrieved": "2024-07-30T18:53:17.121934", "image_code": "\n// calculates the definite line integral of alphablending two colors through a fog volume\n// T is the logarithmic transmittance (0 .. -inf)\n// d is the distance of the ray\n// x is the end of the integral (0..1); pass 1 here if not sure\n// returns color mixing factors and alpha\nvec3 color_fog_mix_coeffs(float T, float d, float x) {\n    float Td = T*d; // scale transmittance by ray length\n    float acc_alpha = exp(Td*x); // occlusion accumulated along integral    \n    // integrated alpha\n    float w = 1.0 - acc_alpha;\n    // integrated color\n    float v = x * acc_alpha / (acc_alpha - 1.0) - 1.0 / Td;\n    float u = 1.0 - v;\n    return vec3(u, v, w);\n}\n\n/////////\n\nbool cube(vec3 org, vec3 dir, out float near, out float far) {\n    vec3 p = -org/dir;\n    vec3 q = 0.5/abs(dir);\n\tvec3 tmin = p - q;\n\tvec3 tmax = p + q;\n    near = max(tmin.x,max(tmin.y,tmin.z));\n\tfar = min(tmax.x,min(tmax.y,tmax.z));\n\treturn near < far && far > 0.0;\n}\n\n\nvoid transformray (vec3 ro, vec3 rd, mat2 rotationY, vec3 offset, out vec3 outro, out vec3 outrd)\n{\n\toutro = ro + offset;\n\toutro = vec3(rotationY * outro.xz, outro.y).xzy;\n\toutrd = vec3(rotationY * rd.xz, rd.y).xzy;\n}\n\n// alpha channel is unused\nconst float A = 0.0;\nconst float B = 0.0;\nvec4 C[8] = vec4[](\n#if 1\n    vec4(0,0,0,B),\n    vec4(1,0,0,A),\n    vec4(0,1,0,A),\n    vec4(1,1,0,B),\n    vec4(0,0,1,A),\n    vec4(1,0,1,B),\n    vec4(0,1,1,B),\n    vec4(1,1,1,A)\n#elif 0\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,A),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B),\n    vec4(1,1,1,B)\n#elif 1\n    vec4(0,0,0,B),\n    vec4(1,0,0,B),\n    vec4(0,1,0,B),\n    vec4(1,1,0,B),\n    vec4(0,0,1,A),\n    vec4(1,0,1,A),\n    vec4(0,1,1,A),\n    vec4(1,1,1,A)\n#else\n    vec4(0,0,0,B),\n    vec4(1,0,0,A),\n    vec4(0,1,0,A),\n    vec4(1,1,0,A),\n    vec4(0,0,1,A),\n    vec4(1,0,1,A),\n    vec4(0,1,1,A),\n    vec4(1,1,1,B)\n#endif\n);\n\n// smallest non-inf number: exp(-103.9) or exp2(-149.99999)\n\nvec4 tf(vec4 s) {\n    return s;\n}\n\nvec4 tfinv(vec4 s) {\n    return s;\n}\n\nvec4 map(vec3 p) {\n    vec4 c00 = mix(tf(C[0]), tf(C[1]), p.x);\n    vec4 c01 = mix(tf(C[2]), tf(C[3]), p.x);\n    vec4 c10 = mix(tf(C[4]), tf(C[5]), p.x);\n    vec4 c11 = mix(tf(C[6]), tf(C[7]), p.x);\n    vec4 c0 = mix(c00, c01, p.y);\n    vec4 c1 = mix(c10, c11, p.y);\n    vec4 c = mix(c0, c1, p.z);    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// camera\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 0.55; // move camera closer\n\tvec3 camro = normalize(vec3(1.0, -0.1 + sin(iTime)*0.5+0.5, 0.0));\n\tvec3 w = -camro;\n\tcamro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0, 1.0, 0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n\tvec3 camrd = normalize(p.x * u + p.y * v + 1.5 * w);\n\tfragColor = vec4(0.0);\n\t\n\t// rotation\n\tfloat angle = 5.0 * iMouse.x / iResolution.x;\n\tif( iMouse.z < 0.5 )\n\t\tangle = iTime + 4.7;\n\tfloat ca = cos(angle);\n\tfloat sa = sin(angle);\n\tmat2  m = mat2(ca, -sa, sa, ca);\n\t\n\tfloat far, near;\n\tvec3 ro, rd;\n\t\n    vec3 c = vec3(0.0);\n    float k = 0.0;\n\t// cube\n\ttransformray(camro, camrd, m, vec3(0.0), ro, rd );\n    if (cube (ro, rd, near, far)) {\n        float d = (far - near);\n        vec3 p0 = (ro + rd * near)+0.5;\n        vec3 p1 = (ro + rd * far)+0.5;       \n        \n        vec4 c0 = map(p0);\n        vec4 c1 = map(p1);\n        \n        float alpha = mix(0.25,1.0,cos(iTime*0.25)*0.5+0.5);\n        vec3 a = tfinv(map(p0)).rgb; // source color\n        vec3 b = tfinv(map(p1)).rgb; // target color\n        float T = 1.0 - 1.0 / (1.0 - alpha); // convert to logarithmic transmittance\n        vec3 fog = color_fog_mix_coeffs(T*sqrt(2.0), d, 1.0);\n        k = fog.z;\n        c = fog.s * a + fog.t * b;\n    }\n    \n    // alpha blend\n    c = c*k + (texture(iChannel0, p*2.0).rrr * 0.2 + 0.2)*(1.0 - k);\n    \n    fragColor = vec4(pow(c, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdySWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 279, 333, 333, 657], [670, 670, 732, 732, 939], [942, 942, 1041, 1041, 1159], [1954, 1954, 1971, 1971, 1987], [1989, 1989, 2009, 2009, 2025], [2027, 2027, 2045, 2045, 2344], [2346, 2346, 2403, 2414, 3898]], "test": "untested"}
{"id": "NsySWG", "name": "1D perlin waves", "author": "rifke", "description": "simple demos of 1d perlin noise.\nupper left:   1d perlin noise curve\nupper right:  simple 2D terrain\nlower left:   hand drawn effect\nlower right:  2D water surface", "tags": ["terrain", "perlinnoise", "water", "1d", "curve", "handdrawn"], "likes": 8, "viewed": 710, "published": 3, "date": "1635169950", "time_retrieved": "2024-07-30T18:53:17.965678", "image_code": "//---------------------------------------------------------------------------\n//Rendering: four simple demos\n//upper left:   1d perlin noise curve\n//upper right:  simple 2D terrain\n//lower left:   hand drawn effect\n//lower right:  2D water surface\n//---------------------------------------------------------------------------\n#define FADE_SCALE 30.0\n\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color, bool isSolid) \n{\n\tfloat d = (length(uv - center) - radius) * FADE_SCALE;\n    d = isSolid ? d : abs(d);\n\treturn vec4(color, 1. - clamp(d, 0., 1.));\n}\n\nvec4 rect(vec2 uv, vec2 minV, vec2 maxV, vec3 color, bool isSolid)\n{\n\tfloat d = max(max(uv.x-maxV.x, minV.x-uv.x), max(uv.y-maxV.y, minV.y-uv.y)) * FADE_SCALE;\n    d = isSolid ? d : abs(d);\n\treturn vec4(color, 1. - clamp(d, 0., 1.));\n}\n\nvec4 renderLR(in vec2 uv)\n{\n    float noise = .06 * (fbm(uv.x, 4, .1) + fbm(uv.x + iTime, 4, .1));\n    float d = (uv.y + noise - 1.) * FADE_SCALE;\n\tfloat t = clamp(d, 0., 1.);\n    \n    vec3 skyColor = vec3(0., 0., 0.);\n    vec3 waterColor = vec3(.0, .3, .5) + .3 * uv.y;\n    return vec4(mix(waterColor, skyColor, t), 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    float noise = .02 * fbm(uv.x + uv.y, 6, 1.);\n    \n    fragColor = renderLR(2.*uv+vec2(-aspect, 1.));  \n}", "image_inputs": [], "common_code": "//---------------------------------------------------------------------------\n//1D Perlin noise implementation \n//---------------------------------------------------------------------------\n#define HASHSCALE 0.1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat fbm(float pos, int octaves, float persistence) \n{\n    float total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n    for(int i = 0; i < 4; ++i) \n    {\n        total += perlinNoise1D(pos * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total / maxValue;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 427, 427, 559], [561, 561, 629, 629, 796], [798, 798, 825, 825, 1121], [1123, 1123, 1178, 1178, 1398]], "test": "untested"}
{"id": "7dVXzd", "name": "Rainbow Loader Bar", "author": "Krischan", "description": "A simple floating and colorful customizable loader bar.", "tags": ["rainbow", "neon", "bar", "loader"], "likes": 12, "viewed": 480, "published": 3, "date": "1635166765", "time_retrieved": "2024-07-30T18:53:18.956030", "image_code": "#define HEIGHT      0.05   // Height of the Bar\n#define BACKLIGHT   0.6    // Backlight\n#define BRIGHTNESS  0.33   // overall Brightness\n#define GLOW        1.25   // Glow intensity of the Bar\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    \n\tfloat c = BACKLIGHT;\n\tfloat a = abs(uv.y);\n\tfloat s = 1.0 - smoothstep(0.0, HEIGHT, a);\n\tc *= 1.33 - smoothstep(0.0, 0.5, a);\n    c*=c*c;\n\t\n    if(abs(uv.y) < HEIGHT) { c += s; }\n\t\n\tfragColor = vec4(cos(6.283 * (uv.x + iTime + vec3(0.0,.33,0.66))) + GLOW, 1.0) * c * BRIGHTNESS;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 251, 251, 586]], "test": "untested"}
{"id": "7sKSzd", "name": "golfing  android 2d", "author": "FabriceNeyret2", "description": "golfing 2533 chars \"android 2d\" by letsparty1793. [url]https://shadertoy.com/view/4lSBRD[/url]\n+ anti-aliasing.", "tags": ["golf", "android2d"], "likes": 8, "viewed": 264, "published": 3, "date": "1635165128", "time_retrieved": "2024-07-30T18:53:19.729960", "image_code": "// golfing 2533 chars \"android 2d\" by letsparty1793. https://shadertoy.com/view/4lSBRD\n\n\n// ---  464 chars: -24 by Fab\n\n#define S(d)       smoothstep( -2., 2., (d)*R.y )\n#define l          length\n#define L(d,U,a,r) min( d, S( l( U - (a) * clamp( dot(U, a)/dot(a,a), -1., 1. ) ) - r ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy, \n         U = ( u+u -R ) / R.y, V, \n         o = vec2(0,.1), e = o + vec2(o.y,-o);                              // ear-antenna frame\n    U.x = abs(U.x);                                                         // mirror symmetry \n    V = U - o*4.7;\n\tO = vec4(.58,.76,.28,1); \n    O += (1.-O)* L( L( max( min( L( S( l( max( abs(U) - vec2(.45,.4), 0.)) )// body box   \n                                  , U - vec2(.61,.06), o+o,  .1 )           // arm line\n                              , S( max( l(V+o) - .45, -V.y ) ) )            // head hemi-circle\n                          , 1.- S( l( V - vec2(.2,.18) ) - .054 ) )         // sub eye cicle\n                     , U - vec2(.18,-.4), o*2.3, .1 )                       // feet line\n                  , V - e*3.14, sign(e)*.07, .02 );                         // ear line\n}\n\n\n\n\n\n\n/** // ---  488 chars: -19 by Fab\n\n#define S(d)      smoothstep( -2./R.y, 2./R.y, d )\n#define L(U,a,r)  S( length( U - a * clamp( dot(U, a)/dot(a,a), -1., 1. ) ) - r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy, \n         U = ( u+u -R ) / R.y, V, \n         o = vec2(0,.1), e = o + vec2(o.y,-o);\n    U.x = abs(U.x);                                                         // mirror symmetry \n    V = U - o*4.68;\n\tO = vec4(.58,.76,.28,1); \n    O += (1.-O)* min( min( max( min( min( S( length(max( abs(U) - vec2(.45,.4), 0.)) ) // body box   \n                                        , L( U - vec2(.61,.056), vec2(0,.2),  .1) )    // arm\n                                  , S( max( length(V+o) - .45, -V.y ) ) )   // head hemi-circle\n                              , 1.- S( length(V - vec2( .2,.18)) - .054) )  // sub eye cicle\n                         , L( U - vec2(.18,-.4), vec2(0,.23), .1) )         // feet \n                    , L( V - e*3.14, sign(e)*.07, .02 ) );                  // ear\n}\n\n\n\n\n\n\n/** // ---  507 chars: -62 by Fab\n\n#define S(d)      smoothstep( -2./R.y, 2./R.y, d )\n#define L(U,a,r)  S( length( U - a * clamp( dot(U, a)/dot(a,a), -1., 1. ) ) - r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy, \n         U = ( u+u -R ) / R.y, V, e = vec2(0,.1);\n    U.x = abs(U.x);                                             // mirror symmetry \n    V = U - e*4.68;\n    float d = min(max( min( min( S( length(max( abs(U) - vec2(.45,.4), 0.)) )     // body box   \n                               , L( U - vec2(.61, .056), vec2(0, .2),  .1) ), // arm\n                            S( max( length(V+e) - .45, -V.y ) ) )     // head hemi-circle\n                     , 1.-S( length(V - vec2( .196, .178)) - .054) ), // sub eye cicle\n                  L( U- vec2( .18, -.404), vec2(0, .228), .1) );      // feet \n    e += vec2(e.y,-e);\n    d = min(d, L( V - e*3.14, sign(e)*.07, .02 ) );             // ear\n\tO = vec4(.58,.76,.28,1); O += (1.-O)*d;                     // coloring\n}\n\n\n\n\n\n\n/** // --- 559 chars:  -49 by dean_the_coder\n\n#define S(d)      smoothstep( -2./R.y, 2./R.y, d )\n#define L(U,a,r)  S( length(U - a * clamp(dot(U, a)/dot(a,a), -1., 1. ) ) - r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy, h,\n         U = ( u+u -R ) / R.y,\n         b = vec2(.448, .402);                                     // body size\n    U.x = abs(U.x);                                                // mirror symmetry \n\n    float d = S( length(max( abs(U) - b, 0.)) );                   // body box                                                  // circle offset\n    h = vec2(0, .468);\n    d = min(max(\n        min(min(d, L( U - vec2(b.x+.158, .056), vec2(0, .196),  0.104) ), // arm\n        S( max( length(U-h+vec2(0,.1)) - b.x, -(U-h).y ) ) ),// head hemi-circle\n        1.-S( length(U- h - vec2( .196, .178)) - .054) ),   // sub eye cicle\n        L(U- vec2( .18, -.404), vec2(0, .228), .1) );       // feet\n    vec2 e = vec2(0, b.x - 0.01);\n         e = ( e + vec2(e.y,-e.x) ) / 1.4;\n    d = min(d, L(U-h - e, sign(e)*.07, .02) );                // ear\n\tO = mix(vec4(.58,.76,.28,1), vec4(1), d );                     // coloring\n}\n\n\n\n\n\n\n/** // --- 608 chars by Fab\n\n#define S(d)      smoothstep( -2./R.y, 2./R.y, d )\n#define L(U,a,r)  S( length(U - a * clamp(dot(U, a)/dot(a,a), -1., 1. ) ) - r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy, h,\n         U = ( u+u -R ) / R.y,\n         b = vec2(.448, .402);                                     // body size\n    U.x = abs(U.x);                                                // mirror symmetry \n\n    float d = S( length(max( abs(U) - b, 0.)) ),                   // body box\n          o = .1;                                                  // circle offset\n    d = min(d, L( U - vec2(b.x+.158, .056), vec2(0, .196),  0.104) ); // arm\n    h =  vec2(0, .468);\n    d = min(d, S( max( length(U-h+vec2(0,o)) - b.x, -(U-h).y ) ) ),// head hemi-circle\n    d = max(d, 1.-S( length(U- h - vec2( .196, .178)) - .054) );   // sub eye cicle\n    d = min(d, L(U- vec2( .18, -.404), vec2(0, .228), .1) );       // feet\n    vec2 s = vec2(.02, .1),\n         e = vec2(0, b.x - o + s.y - .01);\n         e = ( e + vec2(e.y,-e.x) ) / 1.4;\n    d = min(d, L(U-h - e, sign(e)*.7 * s.y, s.x) );                // ear\n\tO = mix(vec4(.58,.76,.28,1), vec4(1), d );                     // coloring\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 325, 325, 1173]], "test": "untested"}
{"id": "fsGXzG", "name": "Extruded Pixelated Spiral", "author": "Shane", "description": "Extruded pixelated spiral", "tags": ["grid", "pixel", "spiral", "design", "extrude"], "likes": 53, "viewed": 845, "published": 3, "date": "1635163502", "time_retrieved": "2024-07-30T18:53:20.748238", "image_code": "/*\n\n    Extruded Pixelated Spiral\n    -------------------------\n\n\tOn Shadertoy I often come across very simple 2D examples that I like.\n    Sometimes, if I think the base pattern is interesting enough, I might\n    extrude it just to see what it looks like. Extruded imagery is a bit\n    of a computer graphics cliche, but I like it.\n    \n    This particular image is loosely based on a minimal spiral image by\n    Foxic -- The link is below, for anyone interested. To adhere to the \n    spirit of the original, I've extruded it in a pixelized manner and kept \n    roughly the same palette. However, it looks pretty interesting in other \n    colors too.\n    \n    Technically, there's not a lot to this. Hopefully, it'll run fine on\n    most systems. It'd be a lot more efficient to render the 2D spiral on\n    a backbuffer first, but I wanted to keep things simple.\n    \n\n\n\tInspired by:\n    \n\t// I like the minimal design.\n    Pixelized IceCreamSwirl - foxic\n\thttps://www.shadertoy.com/view/NdVXWz\n    \n    // Tater's been putting up some pretty nice shaders lately.\n    Spiraled Layers - Tater\n    https://www.shadertoy.com/view/Ns3XWf\n\n\n*/\n\n\n// Global tile scale.\nvec2 scale = vec2(1./8., 1./8.);\n\n// Off the rows by half a cell to produce a brickwork feel. The staggered \n// effect can also make a quantized image look smoother.\n#define ROW_OFFSET\n\n// Use hexagon pylons instead of squares.\n//#define HEXAGON\n\n// Boring out holes on alternate blocks to give it more of a tech feel and\n// to provide a little extra visual stimuli. Without the holes, the image\n// looks cleaner, but less interesting, I feel.\n#define HOLES\n\n// Raising the faces of the pylon tops. I find it can help bounce the light \n// off the surface in a more reflective way.\n//#define RAISED\n\n// Putting a ridge decoraction on the pylon tops.        \n//#define RIDGES\n\n\n// The hexagons must use offset rows.\n#ifdef HEXAGON\n#ifndef ROW_OFFSET\n#define ROW_OFFSET\n#endif\n#endif\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Height map value.\nfloat hm(in vec2 p){ \n\n    \n    // Render the swirl by adding polar coordinates. You can apply the logarithm to\n    // the length for a different kind of feel, but I'll leave it in its current form.\n    float swirl = fract(atan(p.y, p.x)/6.2831 + length(p)*1.25 - iTime/4.);\n    \n    /*\n    // Alternative square or octagon swirl -- Other metrics are also possible.\n    vec2 ap = abs(p);\n    float shp = max(ap.x, ap.y);\n    //float shp = max(max(ap.x, ap.y), (ap.x + ap.y)*.7071);\n    float swirl = fract(atan(p.y, p.x)/6.2831 + shp*1.5 - iTime/4.);\n    */\n\n    //swirl = abs(swirl - .5)*2.; swirl = smoothstep(.15, .85, swirl);\n    swirl = sin(swirl*6.2831)*.5 + .5;\n    \n    \n    // In the form above, the height transitions between zero and one.\n    // The following simply manipulates the way in which that happens.\n    \n    // Number of quantization levels.\n    #define lNum 4.\n    float iswirl = floor(swirl*lNum*.9999)/lNum;\n\n    // Arrange for the pylons to smoothly transition between quantization\n    // levels whilst honoring the pixelated look... I could have described\n    // that better, but hopefully, you know what I mean. :D\n    return mix(iswirl, iswirl + 1./lNum, smoothstep(0., 1., swirl));\n    // Popping unnaturally from one state to the next.\n    //return iswirl*lNum/(lNum - 1.); \n    // Continuous, smooth motion.\n    //return swirl; \n    \n    \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n#ifdef HEXAGON\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n    \n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n#endif\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n    vec2 l = scale;\n\tvec2 s = scale*2.;\n    #ifdef HEXAGON\n    vec2 hSc = vec2(1, scale.y/scale.x*2./1.732);\n    #endif\n    \n    float minSc = min(scale.x, scale.y);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0); \n    \n    // Four block corner postions.\n    #ifdef ROW_OFFSET\n    // Offset rows.\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.5, -.25), vec2(0, -.25)); \n    #else\n    vec2[4] ps4 = vec2[4](vec2(-.25, .25), vec2(.25), vec2(.25, -.25), vec2(-.25)); \n    #endif\n    \n    float data = 0.; // Extra data.\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - ps4[i]) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + ps4[i])*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        float h = hm(idi);\n        \n        h *= .1;\n            \n         \n        #ifdef HEXAGON\n        // Hexagon option: Multiply scale by \"vec2(1, 1.732/2.),\"\n        // and have the ROW_OFFSET define turned on.\n        float di2D = sHexS(p.yx, minSc/1.732 - .008, .02);\n        #else\n        float di2D = sBoxS(p, l/2. - .008, .02);        \n        //float di2D = length(p) - l.x/2. + .004;\n        #endif\n        \n        \n        #ifdef HOLES\n        // Boring out some of the boxes.\n        if((i&1)==0) di2D = max(di2D, -(di2D + minSc/4.));\n        #endif\n        \n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h - .5), h + .5);\n        \n        \n        #ifdef RAISED\n        // Raised tops.\n        di += di2D*.25;\n        #endif\n        \n        #ifdef RIDGES\n        // Putting ridges on the faces.\n        di += sin(di2D/minSc*6.2831*3.)*.005;\n        #endif\n        \n        /*\n        // Lego.\n        float cap = length(p) - scale.x/4.;\n        cap = opExtrusion(cap, (q3.z + h - .5 + .035), h + .5);\n        di = min(di, cap); //di = max(di, -cap)\n        */\n        \n        \n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Extra data. In this case, the 2D distance field.\n            data = di2D;\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, data);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded object.\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef HEXAGON\n    scale *= vec2(2./1.732, 1);\n\t#endif\n    \n\t// Camera Setup.\n    // Tilted camera, just to prove it's 3D. :)\n\t//vec3 ro = vec3(0, -1.3, -2.2); // Camera position, doubling as the ray origin.\n\t//vec3 lk = ro + vec3(0, .12, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n\t// Front on camera.\n    vec3 ro = vec3(0, 0, -2.2); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.25, .5, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block field value, block ID and 2D data field value.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6);   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            float h = hm(svGID.yz);\n            \n            //texCol = mix(vec3(.05), vec3(1), h); // White.\n            texCol = mix(vec3(.05), vec3(1.4, .2, .6), h); // Pink.\n            //texCol = mix(vec3(.05), vec3(.5, 1, .25), h); // Green.\n            //texCol = mix(vec3(.05), vec3(.25, .7, 1.5), h); // Blue.\n            //texCol = mix(vec3(.05), mix(vec3(1.4, .2, .6), vec3(2, .3, .3), diff*diff*1.5), h);\n            \n            // Extra blending options.\n            //texCol = mix(texCol, texCol.xzy, h);\n            //texCol = mix(texCol, texCol.zyx, clamp((ld.y - ld.x) - .5, 0., 1.));\n            //texCol = mix(texCol.zyx, texCol, diff*diff*1.5);\n             \n            \n            /*\n            // Dark edges.\n            //vec2 lCoord = sp.xy - svGID.yz;\n            vec2 sc = scale;\n            float lw = .006;\n            float dS = abs(svGID.w) - lw; // 2D face field value.\n            //texCol = mix(texCol, min(texCol.xzy*1.35 + .1, 1.), (1. - smoothstep(0., .005, dS + lw)));\n            dS = max(dS, abs(sp.z + h*.1*2.) - lw/2.); // Just the rim.\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, dS))*.8);\n            */\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n\n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .92)*spec*freS*2.*sh);\n      \n        // Shading.\n        col *= ao*atten;\n        \n          \n\t\n\t}\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2067, 2100, 2122, 2122, 2180], [2183, 2211, 2232, 2232, 2295], [2298, 2319, 2339, 2517, 3691], [3694, 3721, 3778, 3778, 4084], [4740, 4768, 4815, 4815, 4905], [7891, 7914, 7932, 7951, 8221], [8225, 8246, 8282, 8331, 8769], [8772, 8872, 8908, 9288, 9560], [9563, 9754, 9806, 9887, 11155], [11158, 11310, 11345, 11345, 11590], [11593, 11593, 11649, 11682, 16807]], "test": "untested"}
{"id": "NsKSRz", "name": "Abstract Geometric Art Pattern", "author": "Shane", "description": "Applying a very simple procedure involving multiple colored square-shaped overlays and basic lighting to produce a greeble-like surface in the style of abstract art.", "tags": ["procedural", "voronoi", "texture", "abstract", "art", "greeble"], "likes": 71, "viewed": 1024, "published": 3, "date": "1635163347", "time_retrieved": "2024-07-30T18:53:21.502222", "image_code": "/*\n\n    Abstract Geometric Pattern\n    --------------------------\n\n    Applying a very simple procedure involving multiple colored square overlays \n    and basic lighting to produce a greeble-like surface in the style of abstract \n    art... or something to that effect. :)\n    \n    I'd been experimenting with procedural greebled surfaces a while ago, and this \n    was just a byproduct of that. I wouldn't call it a greebled surface per se, but \n    if you mapped it onto a 3D surface, it'd have that feel. Thanks to the basic \n    lighting, it also has a painted feel. On a side note, a lot of wrapped \n    procedural textures you see have usually been highlighted in a similar wrappable \n    unidirectional way.\n    \n    The technique is about as simple as it gets: Combine some offset squares to \n    form a polygon with squared sides. Construct a square grid and render these\n    in each cell. After that, combine a few resultant layers at various frequencies.\n    The method is different, but similar to stacking Voronoi layers.\n    \n    I didn't put a lot of effort into rendering speed, as this is the kind of thing\n    that you should probably prerender into one of the buffers prior to use. By the\n    way, I have a couple of 3D greeble examples that I'll post later.\n    \n    \n    Other examples:\n    // Similar principals, and a nice result. By the way Piyushslayer has\n    // some other really nice examples.\n    Abstract Squircles - piyushslayer \n    https://www.shadertoy.com/view/Wtc3D8\n    \n\n*/\n\n\n// Just the two palattes - Vibrant: 0, Earth: 1.\n#define PALETTE 0\n\n// Base shape -  Square: 0, Diamond: 1., Hexagon: 2, Octagon: 3, Circle: 4.\n#define SHAPE 0\n\n\n// Random rotation, which gives it more of a \"tech\" look.\n//#define RAND_ROT\n\n\n//Thanks to Dave_Hoskins for the fantastic hash functions!\n//https://www.shadertoy.com/view/4djSRW\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    //f = mod(f, GRID_SIZE);\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- Accumulated noise layers of modulated amplitudes and frequencies.\nfloat fBm(vec2 p){ \n\n    // Layer the noise.\n    float ns = 0., sum = 0., a = 1.;\n    for(int i = 0; i<5; i++){\n    \n        ns += n2D(p)*a;\n        p *= 2.5;\n        sum += a;\n        a /= 1.5;\n    }\n    \n    return ns/sum; // Range: [0, 1].\n}\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n*/\n\n// Shape distance metrics. You could put whatever you feel like here.\nfloat dist(vec2 p, vec2 b){\n \n      \n      #if SHAPE == 0\n      // Square.\n      p = abs(p) - b;\n      return max(p.x, p.y);\n      #elif SHAPE == 1\n      // Diamond.\n      p = abs(p);\n      return (p.x + p.y)*.7071 - mix(b.x, b.y, .5);\n      #elif SHAPE == 2\n      // Hexagon.\n      p = abs(p);\n      return max(p.x*.8660254 + p.y*.5, p.y) - mix(b.x, b.y, .5);\n      #elif SHAPE == 3\n      // Octagon.\n      p = abs(p);\n      return max((p.x + p.y)*.7071, max(p.x, p.y)) - mix(b.x, b.y, .5);\n      #else\n      // Circle.\n      return length(p) - (b.x + b.y)/2.;\n      #endif\n      \n      //p = abs(p) - b;\n      //p = p*.8660254 + p.yx*.5;\n      //return max(p.x, p.y);\n      \n      //p = abs(p)-b;\n      //p = (p + p.yx)*.7071;\n      //return max(p.x, p.y);\n}\n\n\n// The cell shape: This is just a union of four offset shapes, but it could\n// be anything you can dream up. This particular random shape exceeds the\n// boundaries of the cell, so surrounding cells need to be accounted for.\n\nfloat cellShape(vec2 p, vec2 ip){\n    \n    float d = 1e5;\n    \n    for(int i = 0; i<4; i++){\n    \n        // Four random values.\n        float fi = 1./(1. + float(i));\n        vec4 rnd = vec4(hash21(ip + .15*fi), hash21(ip + .23*fi), \n                        hash21(ip + .32*fi), hash21(ip + .41*fi));\n        \n        // Offset position.\n        vec2 q = \n        #ifdef RAND_ROT\n        // Optional random rotation.\n        r2(floor(hash21(ip + .07*fi)*4.)*3.14159265/4.)*\n        #endif\n        p - (rnd.xy - .5)*1.5;\n    \n        // Render a square, diamond, or whatever.\n        //float shape = sBoxS(q, .1 + rnd.zw*.3, min(rnd.z, rnd.w)*.07);\n        float shape = dist(q, .1 + rnd.zw*.3); // Rectangular dimensions.\n        //float shape = dist(q, vec2(.1 + length(rnd.zw)*.2)); // Square.\n        \n        // Take the minimum (union) of all combined shapes.\n        d = min(d, shape);\n    \n    }\n    \n    // Holes... Didn't work. :)\n    //d = abs(d  + .135) - .135;\n    \n    return d; // Return the random distance, or bound.\n    \n}\n\n\n\n// Constructing the grid pattern: Render a random shape in each cell.\nvec4 gridPattern(vec2 p, float sf){\n    \n    const vec2 sc = vec2(1);\n    \n    vec3 col = vec3(1);\n    \n    float alpha = .9;\n    float d = 1e5;\n    \n    // The cell shapes exceed the cell boundaries, which means covering all \n    // surrounding cells that the shape covers. In this case, there are 9.\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n          \n            // Local cell coordinates and cell ID.\n            vec2 cntr = vec2(i, j) - .5;\n            vec2 q = p;\n            vec2 ip = floor(q/sc - cntr) + .5; \n            q -= ip*sc;\n        \n            // Cell shape.\n            float c = cellShape(q, ip);\n            \n            // Using the cell ID to produce some random number.\n            vec2 rnd = vec2(hash21(ip/23.), hash21(ip/113.)) - .5;\n            rnd.y = smoothstep(.985, .997, sin(rnd.y*6.2831 + iTime/2.)*.5 + .5);\n            \n            // Feeding the random cell-ID-based value into IQ's cool palette formula\n            // to produce the shape color.\n            #if PALETTE == 1\n            // Earth tones.\n            vec3 cellCol = (.5 + .46*cos(rnd.x*6.2831/2. + vec3(0, 1, 2)))/3.5;\n            // Blinking highlights.\n            cellCol = mix(cellCol, mix(cellCol, cellCol*vec3(1.8, .9, .3), 1.), rnd.y); \n            #else\n            // Vibrant palette.\n            vec3 cellCol = (.5 + .46*cos(rnd.x*6.2831/2.75 + vec3(0, 1, 2) + 2.2));\n            // Blinking highlights.\n            cellCol = mix(cellCol, mix(cellCol, cellCol.xzy, .6), rnd.y); \n            #endif\n            \n            // Greyscale.\n            //cellCol = vec3(dot(cellCol, vec3(.299, .587, .114)))/1.5;\n            \n            // Using the shape distance to produce a bit of shading.\n            float sh = max(.5 - c/.1, 0.)*max(1. - dot(q, q)*.5, 0.)*2.5;\n            \n            // Rendering to the canvas. This is the way I like to do it, but you can\n            // use whatever system you're comfortable with. The following are just some\n            // Photoshop type laters: Shadow, outer edge, shaded color and an inner\n            // edge for decoration.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(c) - .01))*.5*alpha);\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(c) - .01)));\n            col = mix(col, cellCol*sh, (1. - smoothstep(0., sf, c))*alpha);//\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(c + .06) - .005)));\n            \n            // Keeping a copy of the minimum overall distance for the layering routine.\n            d = min(d, c);\n\n        }\n    } \n    \n    // Return the shaded shape color and associated distance.\n    return vec4(col, d);\n    \n}\n\n// Layering the grid pattern above.\nvec3 layeredPattern(vec2 p, vec3 col, float sf){\n    \n\n    // Frequency (associated with scale) and alpha (transparency) values.\n    float freq = 1., alpha = 1.;\n    \n    for(int i=0; i<4; i++){\n    \n        // Random values based on layer count.\n        float fi = 1./(1. + float(i));\n        vec2 rnd = vec2(hash21(vec2(0) + .1*fi), hash21(vec2(0) + .2*fi))*2.;\n        \n        // Render this particular grid layer.\n        \n        // Color and distance value.\n        vec4 gCol = gridPattern((p - rnd)*freq, sf*freq);\n        // Mix a drop shadow, edge and layer color onto the previous layer.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8.*freq, abs(gCol.w) - .01))*.5*alpha);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*freq, abs(gCol.w) - .01))*alpha);\n        col = mix(col, gCol.xyz, (1. - smoothstep(0., sf*freq, gCol.w))/freq*alpha);\n        \n        // Increace the frequency\n        freq *= 1.4;\n        alpha *= .92;\n    }\n    \n    /*\n    // Overlayed diagonal stripe pattern.\n    float pat = (abs(fract((p.x - p.y)*64.) - .5)*2. - .125)/64./2.;\n    pat = smoothstep(0., sf, pat)*.5 + .65;\n    col *= pat;\n    */\n    \n    return col; // Overall texture value.\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen coordinates: They're already in aspect correct form,\n    // so tranlation and scalar resizing is all that is necessary.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Scale and translation.\n    const float sc = 1.5;\n    vec2 p = uv*sc + vec2(1, .25)*iTime/5.;\n    \n    // Coordinate perturbation.\n    p += vec2(n2D(p*24.), n2D(p*24. + 5.))*.004;\n    \n    // Smoothing factor.\n    float sf = sc/iResolution.y;\n    \n    // Background color -- Most of this will be covered with colored shapes.\n    vec3 bg = vec3(.05);\n    \n    // Two layered pattern samples. The second will be used for \n    // highlighting.\n    float sDist = 3./450.;\n    vec3 col = layeredPattern(p, bg, sf);\n    vec3 col2 = layeredPattern(p - normalize(vec2(1, 1))*sDist, bg, sf);\n    \n    // Two bump values. One from each direction.\n    float b = max(dot(col2 - col, vec3(.299, .587, .114)), 0.)/sDist;\n    float b2 = max(dot(col - col2, vec3(.299, .587, .114)), 0.)/sDist;\n    \n    \n    // Applying some subtle fBm noise.\n    float ns = fBm(p*40.)*.8 + .5;\n    col *= ns;\n\n    \n    // Adding the bump highlights.\n    col = col*(vec3(.2, .4, 1)*b*b*.005 + vec3(1, .15, .05)*b2*.04 + .6);\n\n    \n\n    /*\n    // Subtle diagonal pattern overlay. Not used.\n    float pat = (abs(fract((p.x - p.y)*64.) - .5)*2. - .125)/64./2.;\n    pat = .25 + smoothstep(0., sf, pat);\n    col *= pat;\n    */\n \n    /*\n    // Cell borders.\n    vec2 q = abs(fract(p) - .5);\n    float bord = max(q.x, q.y) - .5;\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf*4., abs(bord) - .0025))*.75);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(bord) - .0025)));\n    */\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col*vec3(1, .05, .15), col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n    // Rought gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1756, 1938, 1959, 2153, 2286], [2289, 2322, 2342, 2342, 2400], [2403, 2471, 2489, 2596, 3084], [3086, 3162, 3180, 3206, 3406], [3560, 3630, 3657, 3657, 4390], [5662, 5732, 5767, 5767, 8414], [8416, 8452, 8500, 8580, 9657], [9659, 9659, 9713, 9849, 11717]], "test": "untested"}
{"id": "ssyXDw", "name": "Extruded Circle Animation", "author": "Shane", "description": "A quarter circle animation in extruded form.", "tags": ["circle", "design", "extrude", "propeller"], "likes": 45, "viewed": 571, "published": 3, "date": "1635163329", "time_retrieved": "2024-07-30T18:53:22.496564", "image_code": "/*\n\n    Extruded Circle Animation\n    -------------------------\n\n\tAs previously mentioned, I on occasion like to take a simple flat 2D \n    example, then extrapolate it to a quasi 3D setting to see if it looks\n    interesting. In this case, I've extruded a 2D animation I've seen in \n    various forms. I think this particular one was originally written by \n    FLRN (Florian).\n    \n    I got the idea to do it after looking at a version on Shadertoy written\n    by Vamoss -- The links to it and the original it was based on are below,\n    for anyone interested.\n    \n    The extruded version is interesting, but it's really hard to beat the \n    simplicity of the original. Anyway, there's nothing technically\n    challenging here, but I've provided a heap of options below, for anyone\n    who wishes to play around with various rendering styles.\n\t\n    \n\n\tBased on the following:\n    \n\tSquare Circle Dance - vamoss\n    https://www.shadertoy.com/view/ldK3Dc\n    \n    Which in turn was based  on:\n    FLORIAN (FLRN)\n    https://flrn-gif.tumblr.com/post/116319247625\n\n\n\n*/\n\n// Textured, metallic and environmental lighting options. Turning them\n// all off looks a little cleaner, which is sometimes preferred, but I've\n// defaulted to a weathered appearance.\n#define TEXTURE\n#define METALLIC\n#define ENVIRONMENT\n\n// Palette - Spectrum: 0, Golden brown: 1, Green and blue: 2, Blinking: 3, \n// Mondrian: 4, White: 5.\n#define PALETTE 0\n\n// Paint the sides a lighter color.\n#define SIDES\n\n// Bump map the background cells.\n#define BUMP_BG\n\n// Giving the camera a subltle tilt.\n#define CAM_TILT\n// Lens warp.\n#define LENS_WARP\n\n\n\n\n// Grayscale (and slightly sepia), for that pretentious artistic look. :)\n//#define GRAYSCALE\n\n// Max ray distance.\n#define FAR 20.\n\n// Scale.\nconst vec2 gScale = vec2(.5);\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, fract(p)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// Two different angles. One for each alternate checkered set.\nvec2 gAng;\n\n// Moving the extruded tiles: There are two sets split into\n// alternate checkers. There are 8 key frames.\nvoid move(){\n\n    \n    float n = mod(floor(iTime), 8.); // 8 keyframe.\n    float t = mod(iTime, 8.); // Fractional time.\n    float st = smoothstep(.3, .7, fract(t)); // Smoothing.\n\n    // Each checkered set moves differently: Rotating back and forth,\n    // or rotating by a quarter whilst stopping and resting on alternate\n    // frames. It's mostly common sense.\n    \n    // Angle one.\n    float ndiv2 = floor(n/2.);\n    if(mod(n, 2.) == 0.) gAng.x = mix(ndiv2*3.14159/2., (ndiv2 + 1.)*3.14159/2., st);\n    else gAng.x = (ndiv2 + 1.)*3.14159/2.;\n\n\n    // Angle two.\n    if(mod(floor(t), 2.)<.5){\n        gAng.y = mix(3.14159/2., 0., st);\n    }\n    else {\n        gAng.y = mix(0., 3.14159/2., st);\n    }\n       \n\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n#define SHAPE 2\n\n// Shape distance metrics. You could put whatever you feel like here.\nfloat dist(vec2 p, vec2 b){\n \n      \n      #if SHAPE == 0\n      // Square.\n      p = abs(p) - b;\n      return max(p.x, p.y);\n      #elif SHAPE == 1\n      // Diamond.\n      p = abs(p);\n      return (p.x + p.y)*.7071 - mix(b.x, b.y, .5);\n      #elif SHAPE == 2\n      // Octagon.\n      //p *= rot2(3.14159/8.);\n      p = abs(p);\n     \n      return max((p.x + p.y)*.7071, max(p.x, p.y)) - mix(b.x, b.y, .5);\n      \n      // Dodecahedron.\n      // vec2 p2 = p*.8660254 + p.yx*.5;\n      // p = vec2(max(p2.x, p2.y), max(p.y, p.x));\n      // p = abs(p) - mix(b.x, b.y, .5);\n      return max(p.x, p.y);\n      \n      \n      #else\n      // Circle.\n      return length(p) - (b.x + b.y)/2.;\n      #endif\n      \n      //p = abs(p) - b;\n      //p = p*.8660254 + p.yx*.5;\n      //return max(p.x, p.y);\n      \n      //p = abs(p)-b;\n      //p = (p + p.yx)*.7071;\n      //return max(p.x, p.y);\n}\n\n\nfloat faceDist;\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = gScale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // For block corner postions.\n    //vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l, vec2(l.x, -l.y));\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        float h = 1.;//hm(idi);\n        \n        //h = floor(h*15.999)/15.*.1; // Or just, \"h *= .15,\" for nondiscreet heights.\n        h *= .025;\n        \n        \n            \n        // One larger extruded block.\n        //float di2D = sBoxS(p, l/2. - .0*scale, .02);\n        \n        \n        vec2 q = p;\n        \n        float t = mod(iTime, 4.);\n;\n        \n        if((i&1)==0){\n            q *= rot2(-gAng.x);\n        }\n        else {\n            q *= rot2(-gAng.y);\n        }\n        \n        //float pin = dist(q, vec2(.09*gScale.x));\n        float pin = length(q) - .08*gScale.x;\n        \n        float di2D = length(q) - (l.x/2. - .01);\n        //float di2D = dist(q, l/2. - .01);\n        di2D = max(di2D, -(max(abs(q.x - .5), abs(q.y - .5)) - .5-.01));\n        di2D = max(di2D, -(max(abs(q.x + .5), abs(q.y + .5)) - .5-.01));\n        \n        di2D = max(di2D, -pin);\n        \n        //pin = abs(pin + .02*gScale.x) - .02*gScale.x;\n        \n\n        \n           \n    \n\n        // Boring out some of the lower boxes. I like it, but thought it\n        // confused matters.\n        //if(h<1./15.*.15 + .001) di2D = max(di2D, -(di2D + .3*scale));\n\n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h), h);\n        \n        //di -= min(-di2D*.7, .02);\n        di += di2D*.35;\n        \n        //float pat = (abs(fract(di2D*32.) - .5)*2. - .125)/32.;\n        //di -= (pat)*.1;\n        \n        \n        pin = opExtrusion(pin, (q3.z + h - .5), h + .5 + .01);\n        \n //       di = min(di,  opExtrusion(abs(di2D + .01+.002) -.01, (q3.z + h + .005), h + .005));\n        \n        // Cell object ID -- Hacked in at the last minute.\n        float cOID = di<pin? 0. : 1.;\n        di = min(di, pin);\n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Not used in this example, so we're saving the calulation.\n            boxID = cOID;\n            \n            faceDist = di2D;  \n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .05;\n/*    \n    vec2 sc = gScale/2.*vec2(1, 1);\n    vec2 q = p.xy;// + vec2(sc.x/2.*1., sc.y/2.);\n            //if(mod(floor(q.y/sc.y), 2.)==0.) q.x += sc.x/2.;\n    vec2 iq = floor(q/sc) + .5;\n    q -= iq*(sc);\n    q = abs(q);\n    float block = max(max(q.x, q.y) - sc.x/2. + .025, abs(p.z - sc.x/8.) - sc.x/8.);\n    fl = min(fl + .04, block + (max(q.x, q.y) - sc.x/2.)/8.);\n*/\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Distance, block ID, and cell object ID.\n    \n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow \n    // test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 4.;\n    p.y += iTime/4.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c, c*c, c); // Blueish tinge.\n    \n    return mix(p.zxy, p, n3D2); // Mixing in a bit of red.\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    #ifdef CAM_TILT\n    vec3 ro = vec3(-.125, -.125, -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.005, .01, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    #else\n    vec3 ro = vec3(0, 0, -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    #endif\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .5, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    //vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV));\n    #ifdef LENS_WARP\n    // Ray warping, lens warping, etc -- One of many variations.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z + (.5 - dot(rd.xy, rd.xy))*.5, 0.))));\n    #endif\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.yz *= rot2( sin(-3.14159/3.)/3. );\n\t//rd.xz *= rot2( sin(iTime/1.)/64. );\n\t//rd.xy *= rot2( cos(iTime/2.)/64. );\n\n    \n    // Retrieve the two angular postions of the alternating\n    // grid cell objects.\n    move();\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block distance, ID and cell object ID.\n    vec4 svGID = gID;\n    \n    float svfaceDist = faceDist;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(0);   \n\n        \n        // Object: Forground or background.\n        if(svObjID<.5){\n            \n            \n            // The extruded propeller grid.\n            \n            // Coloring.\n            \n            vec2 sc = gScale;\n            vec3 q = sp;\n            vec2 iq = floor(q.xy/sc) + .5;\n            q.xy -= iq*sc;\n            int check = mod(iq.x + iq.y, 2.)<.5? 1 : 0;\n            \n            if(check==1) q.xy *= rot2(-gAng.x);\n            else q.xy *= rot2(-gAng.y);\n\n            \n            // Random value based on cell ID.\n            float rnd = (svGID.y + svGID.z)/4.;\n            \n            //rnd = floor(rnd*16.)/16.;\n            \n            #if PALETTE == 0\n            // Spectrum.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831 + vec3(0, 1, 2)*2. - 2.15);\n            #elif PALETTE == 1\n            // Golden brown.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/4.5 + vec3(0, 1, 2) + .35);\n            #elif PALETTE == 2\n            // Green and blue.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/4.5 + vec3(0, 1, 2) + .35);\n            if(check == 1) texCol1 = texCol1.zyx;\n            else texCol1 = texCol1.yxz;//vec3(dot(texCol1, vec3(.299, .587, .114)));\n            //if(check == 1 && q.x>q.y) texCol1 = texCol1.yxz;\n            //if(check == 0 && q.x>q.y) texCol1 = texCol1.yxz;\n            #elif PALETTE == 3\n            // Blinking earthtone quarter colors.\n            vec2 iq2 = iq;\n            if(q.x>0.) iq2 += 1./2.;\n            if(q.y<0.) iq2 += 1./4.;\n            rnd = hash21(iq2);\n            float rnd2 = hash21(iq2 + .13);\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/3. + vec3(0, 1, 2) + 1.65);\n            texCol1 = mix(texCol1, mix(texCol1.xzy, texCol1, .25), \n                          smoothstep(.8, .9, sin(rnd2*6.2831 + iTime*2.)*.5 + .5));\n            #elif PALETTE == 4\n            // Mondrian.\n            vec3 texCol1 = vec3(.7);\n            if(check == 1 && q.x<q.y) texCol1 = vec3(1, .07, .06);\n            if(check == 1 && q.x>q.y) texCol1 = vec3(0, .5, 1);\n            if(check == 0 && q.x>q.y) texCol1 = vec3(1, .9, .1);\n            /*\n            // Alternative.\n            vec3 texCol1 = vec3(.7);\n            vec2 qID = mod(floor(svGID.yz*2.), 2.);\n            if(qID.x == 1. && qID.y == 0.) texCol1 = vec3(1, .07, .06);\n            if(qID.x == 0. && qID.y == 1.) texCol1 = vec3(0, .5, 1);\n            if(qID.x == 1. && qID.y == 1.) texCol1 = vec3(1, .9, .1);\n            */\n            #else\n            // White.\n            vec3 texCol1 = vec3(.65);\n            #endif\n             \n            // The outer propellor rim color.\n            vec3 texCol2 = mix(vec3(1.5), texCol1, dot(texCol1, vec3(.299, .587, .114)));//tx/1.5;//\n            #if PALETTE == 4\n            texCol2 = vec3(.85);\n            #endif\n     \n            // Applying the texture, if defined.\n            #ifdef TEXTURE\n            vec3 tx = tex3D(iChannel0, vec3(q.xy + iq/2. - .125, q.z)/2., sn);\n            tx = smoothstep(-.1, .5, tx);\n            texCol1 = mix(texCol1, texCol1*tx*1.75, .65);\n            texCol2 = tx;\n            #endif\n            \n            // Setting the outer and inner propellor colors.\n            if(svGID.w == 1.) texCol = texCol2;\n            else texCol = texCol1;\n\n            \n            \n           \n        \n            // Constructing the dark propeller edge markings.          \n            float ht = 1.;//hm(svGID.yz);\n            vec2 lCoord = sp.xy - svGID.yz;\n            sc = gScale;\n            float lw = gScale.x*.06;//.05;\n            float dS = abs(svfaceDist) - lw;\n\n            // Tapering the sides, or not.\n            #ifndef SIDES\n            dS = max(dS, abs(sp.z + ht*.025*2.) - lw); // Just the rim.\n            #endif\n            \n\n            \n            if(svGID.w == 0.){\n                // Rendering the propeller colors and dark edge markings. \n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, dS))*.95);\n                texCol = mix(texCol, texCol2*.7, (1. - smoothstep(0., .005, dS + .015)));\n            }\n            else {\n                // Inner markings.\n                float cir = length(lCoord) - lw/2.  -.005;\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .007, cir)));\n                texCol = mix(texCol, texCol2, (1. - smoothstep(0., .007, cir + .015)));\n            }\n              \n           \n \n        }\n        else {\n            \n            // The dark floor in the background.\n            //\n            // Scaling, ID and local square cell coordinates.\n            vec2 sc = gScale/2.*vec2(1, 1);\n            vec2 q = sp.xy;// + vec2(sc.x/2.*1., sc.y/2.);\n            //if(mod(floor(q.y/sc.y), 2.)==0.) q.x += sc.x/2.; // Brickwork.\n            vec2 iq = floor(q/sc) + .5;\n            q -= iq*(sc);\n            \n            // Two square samples for bump mapping purposes. In case it isn't obvious,\n            // this is a very cheap and hacky procedure, but it's good enough.\n            float sq = max(abs(q.x) - sc.x/2., abs(q.y) - sc.y/2.);\n            vec2 ld2 = normalize(ld.xy);\n            float sq2 = max(abs(q.x + ld2.x*.01) - sc.x/2., abs(q.y + ld2.y*.01) - sc.y/2.);\n            float bord = abs(sq) - .005;\n            bord = abs(bord - .015) - .005;\n            \n            float b = max((sq2 - sq)/.01, 0.); // Bump value.\n            texCol = vec3(.05);\n            #ifdef BUMP_BG\n            texCol += b*b*.05; // Adding the bump value.\n            #endif\n            // Extra bordering.\n            texCol = mix(texCol, texCol*2., (1. - smoothstep(0., .005*4., bord)));\n            texCol = mix(texCol, texCol/8., (1. - smoothstep(0., .005, bord)));\n            \n            // If the texture is set, apply it.\n            #ifdef TEXTURE\n            vec3 tx = getTex(sp.xy/3.);\n            tx = smoothstep(-.1, .55, tx);\n            texCol *= tx*2.;\n            #endif\n            \n        }\n        \n        // Greyscale values.\n        #ifdef GRAYSCALE\n        texCol = vec3(1.1, .95, .8)*dot(texCol, vec3(.299, .587, .114));\n        #endif\n        \n        \n        // Ramping up the diffuse values, depending on what part of the scene we've hit.\n        vec2 sc = gScale;\n        float lw = gScale.x*.06;\n        float dS = abs(svfaceDist) - lw;\n        \n        #ifdef METALLIC\n        \n        if(svObjID == 0.){\n           // Outer and inner propeller diffuse values.\n           diff = mix(diff, pow(diff, 4.)*1.5, 1. - smoothstep(0., .005, dS));\n           if(svGID.w == 1.) diff = pow(diff, 4.)*1.5;\n           //diff = pow(diff, 4.)*1.5;\n        }\n        else {\n           // Making the dark background more metallic.\n           diff = pow(diff, 6.)*2.35;\n        }\n        #endif\n        \n        \n        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .9)*spec*freS*2.*sh);\n\n        \n        #ifdef ENVIRONMENT\n        // Fake environment mapping.\n        vec3 cTex = envMap(reflect(rd, sn));\n        \n        if(svObjID == 0.){\n            // Adding more environment lighting to the out propeller.\n            col = mix(col + (col)*cTex*2., col + (col)*cTex*6., 1. - smoothstep(0., .005, dS));\n        }\n        else col = col + (col)*cTex*2.; // Just a bit of environment lighting to the background.\n        #endif\n        \n        // Shading.\n        col *= ao*atten;\n        \n        // Debug AO, shadows, etc.\n        //col = vec3(ao);\n\t\n\t}\n    \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1880, 1913, 1935, 1935, 1993], [1996, 2024, 2045, 2045, 2108], [2110, 2190, 2236, 2236, 2800], [2804, 3051, 3071, 3448, 3552], [3554, 3618, 3638, 3638, 3687], [3765, 3872, 3884, 3884, 4587], [4589, 4616, 4673, 4673, 4979], [4982, 5012, 5059, 5059, 5110], [5306, 5376, 5403, 5403, 6253], [9871, 9894, 9912, 9931, 10595], [10599, 10620, 10656, 10705, 11176], [11179, 11279, 11315, 11315, 11499], [11502, 11693, 11745, 11870, 13190], [13193, 13345, 13381, 13381, 13635], [13639, 13782, 13803, 13803, 14149], [14151, 14450, 14470, 14470, 14802], [14805, 14805, 14861, 14894, 26182]], "test": "untested"}
{"id": "sdVXRd", "name": "place texture in center ", "author": "zyc", "description": "place texture in center of screen", "tags": ["center"], "likes": 0, "viewed": 258, "published": 3, "date": "1635162976", "time_retrieved": "2024-07-30T18:53:23.269497", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Center our coordinate system    \n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec2 uv2 = clamp(uv + vec2(0.5, 0.5),vec2(0.0), vec2(1.0));\n    \n    vec4 bgColor = texture(iChannel0, ouv);\n    vec4 fgColor = texture(iChannel1, uv2);\n    fragColor = mix(bgColor,fgColor, fgColor.a);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 98, 434]], "test": "untested"}
{"id": "ssVSRd", "name": "value noise 2D", "author": "yyf1994", "description": "value noise 2D", "tags": ["noise"], "likes": 1, "viewed": 193, "published": 3, "date": "1635161243", "time_retrieved": "2024-07-30T18:53:24.119225", "image_code": "\n \n#define scale 0.1\n\n \nfloat random(vec2 x) { \n    return fract( sin( dot(x ,vec2(12.12357, 20.789) ) + 0.001 ) * 223.123  );\n}\n\n\nfloat smooth_line(float x) {\n    float f = 6.0 * pow( x , 5.0 ) -  15.0 * pow( x , 4.0 ) +  10.0 * pow( x , 3.0);\n    return f;\n}\n\n/** @brief value noise */\nfloat valueNoise(vec2 pos){\n    \n    vec2 fr= fract(pos);\n    vec2 AA= floor(pos);\n    vec2 AB= floor(pos)  + vec2(1,0);\n    vec2 BA= floor(pos)  + vec2(0,1);\n    vec2 BB= floor(pos)  + vec2(1,1);\n    \n    // we sample random number on a regular grid\n    //\n    //  AA-----------AB\n    //   |           |\n    //   |           |\n    //   |    pos    |\n    //   |           |\n    //   |           |\n    //  BA-----------BB\n    float rAA = random(AA);\n    float rAB = random(AB);\n    float rBA = random(BA);\n    float rBB = random(BB);\n    \n    // bilinear interpolation of the value\n    float nAA_AB = mix(rAA , rAB,      (   fr.x));\n    float nBA_BB = mix(rBA , rBB,      (  fr.x));\n    return mix(nAA_AB , nBA_BB,      (  fr.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // float value = valueNoise(fragCoord * scale );\n    \n     vec2 uv = fragCoord/iResolution.xy  * 30.0 ;\n     float value = valueNoise(uv );\n    \n    fragColor = vec4(  value , value,value , value );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 128], [131, 131, 159, 159, 260], [262, 288, 315, 315, 1019], [1021, 1021, 1078, 1129, 1281]], "test": "untested"}
{"id": "ssVSzt", "name": "hex tiling test 2", "author": "FabriceNeyret2", "description": "hex truchet  ( adapted from [url]drschizzo. https://shadertoy.com/view/NsVSWw[/url] ).\n\nplay with the profile function P(h) !", "tags": ["truchet", "tiling", "hex"], "likes": 10, "viewed": 293, "published": 3, "date": "1635160504", "time_retrieved": "2024-07-30T18:53:24.924073", "image_code": "// Fork of golfed version of \"hex tiling test\" by drschizzo. https://shadertoy.com/view/NsVSWw\n\n  #define H(a)   fract(1e4*sin(dot(ceil(a),vec2(17,71))))\n  #define S(v)   smoothstep(20./R.y, 0., v ) \n//#define F3(h)  length(h)*cos(mod(atan(h.y,h.x),2.1)-1.05 - vec2(0,1.57) ) // --- 3-fold rotational symmetry\n  #define F3(h)  length(h)*cos(mod(atan(h.y,h.x)+1.05*.5,2.1)-1.05*.5 - vec2(0,1.57) )\n\n//#define P(h) S( abs(h.xyxy)-.1 )                   // --- play with the profile function !\n//#define P(h) S( abs(length(vec2(abs(h.x)-.9,h.y))-.78) ) \n//#define P(h) S( abs(length(h)-.5) ) \n//#define P(h) .5+.5*cos(30.*length(F3(h)-vec2(.5,0)))\n//#define P(h) .5+.5*cos(60.*length(F3(h)-.575*J.yx))\n//#define P(h) S( abs( length(F3(h)-.575*J.yx) -.285 ) -.15 )\n//#define P(h) S( abs( abs( length(F3(h)-.575*J.yx) -.285 ) -.15  ))\n  #define P(h) .5*S( w = abs( length(F3(h)-.575*J.yx) -.285 ) -.15 ) + S( abs(w) )\n//#define P(h) min(1., S( abs(length(vec2(abs(h.x)-.9,h.y))-.78)-w ) + 4.5*dot(h,h)* S(abs(h.y)-w))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R =  iResolution.xy,\n         U = 13.*(u-.5*R)/R.y + iTime*1.3,\n         J = vec2(.5,.87),                                  // hexuv\n         a = mod(U+J,J+J) - J,\n         b = mod(U  ,J+J) - J,\n         G = dot(a,a) < dot(b,b) ? a : b;                   // G: hex coords.  U-G : hex id\n    \n    float s = fract(1e4*sin(dot(ceil(U-G+floor(5.+iTime)),vec2(17,71)))), w=.08;  // tile angle attribute\n  \n    G *= mat2(cos( (s<.33 ? 3.14/3. : s<.66 ? -3.14/3. : 0.) + vec4(0,11,33,0))); // random rot tile\n    O += P(G) -O;                                           // apply profile shape\n // O *= S(.5-length(O)) *s;                                // debug: show tile Id\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1014, 1014, 1052, 1052, 1731]], "test": "untested"}
{"id": "ssKXRt", "name": "Mesh Dome", "author": "dr2", "description": "A varying Voronoi meshed dome", "tags": ["voronoi", "architecture", "dome"], "likes": 18, "viewed": 318, "published": 3, "date": "1635154899", "time_retrieved": "2024-07-30T18:53:25.857577", "image_code": "// \"Mesh Dome\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // = 0/1 optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p, float t);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 LoadTx (vec2 uv);\n\nvec3 sunDir;\nfloat tCur, dstFar, radWat;\nint idObj;\nconst int idRf = 1, idPil = 2, idCent = 3, idPWall = 4, idOWall = 5;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, radRf, r, a, dw, t;\n  dMin = dstFar;\n  radRf = 2.5 * radWat; //  (based on \"Varying Mesh\")\n  t = LoadTx (p.xz / (1.2 * radRf) + 0.5).x;\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) + 0.5 : 0.;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (10. * a + 0.5) / 10.);\n  dw = q.x - 0.55 * radRf;\n  q.y -= -0.625 * radRf;\n  d = abs (PrSphDf (q, radRf)) - 0.003 * radRf * (1. - smoothstep (0., 0.15, dw - 0.65)) *\n     (1. - 1.5 * smoothstep (0.1, 0.6, t));\n  d = 0.5 * max (d, dw - 1.);\n  DMIN (idRf);\n  q.z = abs (q.z);\n  q -= vec3 (0.58 * radRf * vec2 (1., tan (pi / 10.)), 2.45 + 0.625 * radRf).xzy;\n  d = PrRoundCylDf (q.xzy, 0.3, 0.05, 2.5);\n  DMIN (idPil);\n  q = p;\n  d = max (PrRound4BoxDf (vec3 (q.xz, q.y + 1.).xzy, vec3 (3., 0.2, 3.), 2.), - q.y);\n  DMIN (idCent);\n  d = PrRoundBox2Df (vec2 (r - radWat, q.y - 0.5), vec2 (0.05, 0.5), 0.1);\n  DMIN (idPWall);\n  d = SmoothMax (PrRoundBox2Df (vec2 (r - 0.61 * radRf, q.y - 1.5), vec2 (0.1, 1.5), 0.1), 2. -\n     abs (dot (q.zx, sin (2. * pi * floor (20. * a + 0.5) / 20. + vec2 (0.5 * pi, 0.)))), 0.1);\n  DMIN (idOWall);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.005 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  idObj = idObjT;\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, vec3 vn, float sh)\n{\n  vec4 col4;\n  vec3 col;\n  float nDotL;\n  nDotL = max (dot (vn, sunDir), 0.);\n  if (idObj == idRf) col4 = vec4 (0.7, 0.7, 0.8, 0.3);\n  else if (idObj == idPil) col4 = vec4 (0.6, 0.7, 0.3, 0.1) * (0.8 +\n     0.2 * smoothstep (0.1, 0.2, mod (4. * ro.y + 0.5, 1.)));\n  else if (idObj == idCent) col4 = vec4 (0.65, 0.6, 0.6, 0.2);\n  else if (idObj == idPWall) col4 = vec4 (0.75, 0.7, 0.7, 0.1) * (0.7 +\n     0.3 * step (0.05, mod (90. * (atan (ro.z, ro.x) / (2. * pi) + 0.5), 1.)));\n  else if (idObj == idOWall) col4 = vec4 (0.75, 0.7, 0.7, 0.1) * (0.9 +\n     0.1 * smoothstep (0.1, 0.2, mod (2. * ro.y + 0.5, 1.)));\n  if (idObj == idRf) nDotL *= nDotL;\n  col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n     col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  return col;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi) * vec2 (0.5, 1.);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi) * vec2 (0.5, 1.);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return 1.2 * mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, float sh)\n{\n  vec3 col, vn;\n  float f;\n  vn = vec3 (0., 1., 0.);\n  f = 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n  vn = RippleNorm (0.2 * ro.zx, vn, 4. * f);\n  col = 0.6 * mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.2 +\n     0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n  vn = VaryNf (4. * ro, vn, f);\n  col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, colR, vn, vnw, roo, rdo;\n  float dstObj, dstGrnd, dstWat, r, sh;\n  HexVorInit ();\n  roo = ro;\n  rdo = rd;\n  radWat = 12.;\n  dstGrnd = dstFar;\n  sh = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n  } else if (rd.y < 0.) {\n    dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n  }\n  if (dstObj < dstFar || rd.y < 0.) sh = (min (dstObj, dstGrnd) < dstFar) ?\n     ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n  if (dstObj < dstFar) {\n    col = ObjCol (ro, rd, vn, sh);\n  } else if (rd.y < 0.) {\n    r = length (ro.xz);\n    if (r < radWat + 8.) {\n      col = (r < radWat) ? vec3 (0.8, 0.9, 1.) : vec3 (0.8, 0.83, 0.8) * (1. -\n         0.3 * smoothstep (-0.5, 0., r - (radWat + 8.)));\n      vc = HexVor (2. * ro.xz, 1.);\n      vn = mix (vn, normalize (vec3 (- vc.y, 4., - vc.z)), SmoothBump (0.05, 0.13, 0.02, vc.x));\n      col = vec3 (0.62, 0.65, 0.62) * (0.7 + 0.3 * step (0.1 + 0.05 * vc.w, vc.x));\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         0.2 * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    } else {\n      col = GrndCol (ro, rd, dstGrnd, sh);\n      col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    }\n  } else col = SkyBgCol (ro, rd);\n  ro = roo;\n  rd = rdo;\n  if (rd.y < 0.) {\n    dstWat = (0.45 - ro.y) / rd.y;\n    ro += dstWat * rd;\n    if (length (ro.xz) < radWat && dstWat < dstObj) {\n      vnw = VaryNf (0.2 * ro + 0.05 * tCur, vec3 (0., 1., 0.), 0.1);\n      rd = reflect (rd, vnw);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n        colR = ObjCol (ro, rd, vn, sh);\n      } else colR = SkyBgCol (ro, rd);\n      col = mix (0.5 * col, colR, 0.9 - 0.8 * pow (max (- dot (rdo, vnw), 0.), 5.));\n      col += 0.2 * step (0.95, sh) * pow (max (dot (sunDir, reflect (rdo, vnw)), 0.), 2048.);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.17 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.3 * pi * mPtr.y;\n  } else {\n    az -= 0.02 * pi * tCur;\n  }\n  el = clamp (el, -0.3 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 0., -60.);\n  ro = vuMat * ro;\n  ro.y = max (ro.y, 0.1);\n  zmFac = 3.5 / (1. - 0.7 * abs (mod (az + pi, 2. * pi) - pi) / pi);\n  dstFar = 150.;\n  sunDir = normalize (vec3 (0., 1.5, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.07 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / (asp * zmFac))) * asp * zmFac,\n         uvv.y, zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p, float t)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin ((u.y - 0.5) * 2. * pi * t + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.1) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Mesh Dome\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMin (float a, float b, float r);\nvoid HexVorInit ();\nfloat HexVor (vec2 p, float t);\nvec2 Hashv2v2 (vec2 p);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur;\nconst float pi = 3.1415927;\n\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec2 pxIv;\n  tCur = iTime;\n  pxIv = floor (fragCoord);\n  if (max (pxIv.x, pxIv.y) >= txSize.x) discard;\n  HexVorInit ();\n  stDat = vec4 (HexVor (80. * pxIv / txSize, tCur), 0., 0., 0.);\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\nvec2 gVec[7], hVec[7];\nconst float sqrt3 = 1.73205;\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p, float t)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin (2. * pi * (u.y - 0.5) * t + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, 0.1) - sd.x;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXRt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1115, 1115, 1137, 1137, 2276], [2278, 2278, 2311, 2311, 2558], [2560, 2560, 2581, 2581, 2838], [2840, 2840, 2877, 2877, 3171], [3173, 3173, 3224, 3224, 4021], [4023, 4023, 4048, 4048, 4467], [4469, 4469, 4513, 4513, 4702], [4704, 4704, 4762, 4762, 5136], [5138, 5138, 5172, 5172, 5929], [5931, 5931, 5966, 5966, 8042], [8044, 8044, 8100, 8100, 9401], [9403, 9403, 9436, 9436, 9463], [9465, 9465, 9522, 9522, 9598], [9600, 9600, 9647, 9647, 9694], [9696, 9696, 9743, 9743, 9810], [9836, 9836, 9856, 9856, 10076], [10078, 10078, 10109, 10109, 10701], [10703, 10703, 10727, 10727, 10957], [10959, 10959, 10983, 10983, 11043], [11045, 11045, 11090, 11090, 11182], [11184, 11184, 11229, 11229, 11267], [11269, 11269, 11326, 11326, 11409], [11411, 11411, 11447, 11447, 11653], [11655, 11655, 11685, 11685, 11798], [11832, 11832, 11856, 11856, 11916], [11918, 11918, 11942, 11942, 11995], [11997, 11997, 12021, 12021, 12133], [12135, 12135, 12160, 12160, 12306], [12308, 12308, 12333, 12333, 12519], [12521, 12521, 12543, 12543, 12697], [12699, 12699, 12720, 12720, 12875], [12877, 12877, 12906, 12906, 13118], [13120, 13120, 13159, 13159, 13411], [13438, 13438, 13461, 13461, 13493]], "test": "untested"}
{"id": "7sKSRt", "name": "Fab25 #inktober2021 \"splat\" 2", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nNB: does not handle well pilling order of more than 2 splats. (bufferless exercice ;-) )", "tags": ["2d", "splat", "short", "splash", "inktober2021"], "likes": 11, "viewed": 296, "published": 3, "date": "1635147898", "time_retrieved": "2024-07-30T18:53:26.632506", "image_code": "// variant of https://shadertoy.com/view/7dyXzt\n\n#define H(p)     fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hue(v)   ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )\n#define T(t,s)  ( t < 1. ? t-s : fract(t-s) )                       // init vs steady rain\n\nvoid mainImage(out vec4 O, vec2 u ) \n{\n    vec2  R = iResolution.xy;\n    float n = 2., w = n/R.y, t = iTime/10.,\n          l = 9., d,a,m=9.,p;\n    vec2  U = w* ( u+u - R ), D, P,H1,H2,H3,\n          I = floor(U), F = fract(U)-.5;\n    vec4  C; vec3 N;\n    O -=O;\n    for( int k=0 ; k < 9; k++ )                                     // check neighbor cells\n        D = vec2( k%3, k/3 )-1.,\n        d = T( t , H(I+D+.2).x ),                                   // proba of splat / oldness in splat\n        d > 0.                   \n          ? P = F - D - H(I+D),                                     // splat local coords\n            a = atan(P.y,P.x), \n            H1 = H(I+D+.6), H2 = H(I+D+.4)*6.28, H3 = H(I+D+.2),    // splat attributes\n            l = length(P) - .2*(1.+H1.x  +.3* cos(3.*a+H2.x) +.3* (1.+.3*H1.y)*cos(7.*a+H2.y) ),// splat shape\n            p = tanh(l*30.), N = normalize(vec3(-dFdx(p),-dFdy(p),10.*w)),   // height profile & Normal\n            C = vec4(  hue(H3.y) * (.7+.3*max(0.,dot(N,vec3(-1,-1,1)/1.73))) // amb+diffuse color\n                     + pow(max(0.,(.4*N.z-N.x-N.y)/1.47),20.)                // specular\n                     ,1) \n                  * smoothstep(1.5*min(fwidth(l),w*4.),0., l )      // splat mask\n                  * smoothstep(1.,0.,T( t , H3.x ) ),               // fade with age\n            C.a>.1 && d < m ? m = d,\n                    O = C + (1.-C.a)*O                              // blend over or under prevs\n                  : O += (1.-O.a) * C                               //   depending on relative age\n            :O; \n        \n    O += (1.-O.a)*(.93+.07*texelFetch(iChannel0,ivec2(u)%256,0).r); // background\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 322, 322, 1956]], "test": "untested"}
{"id": "fdKXzd", "name": "value  noise 1D smooth2", "author": "yyf1994", "description": "value  noise 1D smooth", "tags": ["noise"], "likes": 1, "viewed": 215, "published": 3, "date": "1635142832", "time_retrieved": "2024-07-30T18:53:27.391476", "image_code": "\n#define MapSize 10\n\nfloat random(float x) {\n     return fract(sin(x * 457.87 + 0.001  ) * 10000.0);\n}\n\nfloat smooth_line(float x) {\n    float f = 6.0 * pow( x , 5.0 ) -  15.0 * pow( x , 4.0 ) +  10.0 * pow( x , 3.0);\n    return f;\n}\n\n \n\nfloat value_noise_1D(float u){\n    // Fractial part.\n    float f = fract(u);\n\n    // Integer part.\n    float i = floor(u);\n\n    float y1 = random(i);\n    float y2 = random(i + 1.0);\n\n    float res = mix(y1, y2, smoothstep(0.0 , 1.0 ,smooth_line(f)) );\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n\n    float _u = uv.x* float(MapSize) ;\n\n    float y = value_noise_1D(_u)  ;\n\n    float lineWidth =  0.01 ;\n    \n    if(uv.y>y && uv.y<y+ lineWidth){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }else{\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    }   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 44, 44, 102], [104, 104, 132, 132, 233], [238, 238, 268, 290, 507], [509, 509, 565, 615, 913]], "test": "untested"}
{"id": "fsVSzd", "name": "value  noise 1D smooth", "author": "yyf1994", "description": "value  noise 1D smooth", "tags": ["noise"], "likes": 1, "viewed": 207, "published": 3, "date": "1635142326", "time_retrieved": "2024-07-30T18:53:28.238212", "image_code": "\n#define MapSize 10\n\n  \n\n\nfloat random(float x) {\n     return fract(sin(x * 457.87 + 0.001  ) * 10000.0);\n}\n\n\n \n\nfloat value_noise_1D(float u)\n\n{\n    // Fractial part.\n    float f = fract(u);\n\n    // Integer part.\n    float i = floor(u);\n    \n    float y1 = random(i);\n    float y2 = random(i + 1.0);\n\n    float res = mix(y1, y2, smoothstep(0.0 , 1.0 , f) );\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    \n    \n    float _u = uv.x* float(MapSize) ;\n\n    float y = value_noise_1D(_u)  ;\n   // float y = value_noise_1D_map(_u)  ;\n\n \n      \n    float lineWidth =  0.01 ;\n    \n    if(uv.y>y && uv.y<y+ lineWidth){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }else{\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    }   \n\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 49, 49, 107], [113, 113, 145, 167, 376], [378, 378, 435, 485, 853]], "test": "untested"}
{"id": "ssKSzc", "name": "value  noise 1D", "author": "yyf1994", "description": "value  noise 1D", "tags": ["noise"], "likes": 1, "viewed": 193, "published": 3, "date": "1635141353", "time_retrieved": "2024-07-30T18:53:28.987210", "image_code": "\n#define MapSize 10\n\nfloat points[MapSize] = float[MapSize] ( 0.36 , 0.68 , 0.11 , 0.22 , 0.45 ,  0.25 , 0.58 , 0.49 , 0.29 , 0.40 )  ;\n \n\n\nfloat random(float x) {\n     return fract(sin(x * 457.87 + 0.001  ) * 10000.0);\n}\n\n\n\n\nfloat value_noise_1D_map(float u)\n\n{\n    // Fractial part.\n    float f = fract(u);\n\n    // Integer part.\n    int i = int( floor(u) );\n    \n    float y1 = points[i];\n    float y2 = points[i + 1 ];\n\n    float res = mix(y1, y2, f);\n    return res;\n}\n\n\n\nfloat value_noise_1D(float u)\n\n{\n    // Fractial part.\n    float f = fract(u);\n\n    // Integer part.\n    float i = floor(u);\n    \n    float y1 = random(i);\n    float y2 = random(i + 1.0);\n\n    float res = mix(y1, y2, f);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    \n    \n    float _u = uv.x* float(MapSize) ;\n\n    float y = value_noise_1D(_u)  ;\n   // float y = value_noise_1D_map(_u)  ;\n\n \n      \n    float lineWidth =  0.01 ;\n    \n    if(uv.y>y && uv.y<y+ lineWidth){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }else{\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    }   \n\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 163, 163, 221], [226, 226, 262, 284, 472], [476, 476, 508, 530, 714], [716, 716, 773, 823, 1191]], "test": "untested"}
{"id": "NdVSzd", "name": "Neutron Star.", "author": "pancakespeople", "description": "Click with the mouse to zoom in or out, left of the screen = in, right = out.", "tags": ["space", "neutronstar"], "likes": 8, "viewed": 299, "published": 3, "date": "1635141012", "time_retrieved": "2024-07-30T18:53:30.065327", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.3897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 mouse = iMouse.xy/iResolution.x * 8.0;\n    \n    if (mouse.x <= 0.0) mouse.x = 4.0;\n    \n    float zoom = mouse.x;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 gv = fract(uv+0.5) - random2(uv);\n    uv *= zoom;\n    float dist = length(uv);\n    float angle = atan(uv.y, uv.x);\n    float c = fbm(vec2(cos(angle+iTime), sin(angle+dist)) / 2.0) * 2.0;\n    float f = (1.0 - sqrt(1.0 - dist)) / dist;\n\n    vec3 col = vec3(0.0);\n\n    vec2 nuv = uv;\n    nuv *= rotate(iTime);\n\n    // Neutron star\n    col += vec3(0.7, 0.9, 1.0) * smoothstep(0.17, 0.15, dist);\n    col += max((fbm(nuv*f*250.0)*2.0+0.5) * smoothstep(0.16, 0.15, dist) * vec3(0.7, 0.9, 1.0), 0.0);\n    \n    // Flaring\n    col += vec3(smoothstep(1.0, c, dist)) * vec3(0.7, 0.9, 1.0) * smoothstep(0.15, 0.16, dist);\n    \n    // Spikes\n    col += vec3(0.1 / abs(uv.y)) * smoothstep(2.0, -5.0, dist) * vec3(0.7, 0.9, 1.0) * smoothstep(1.0, 10.0, zoom);\n    \n    // Glow\n    col += vec3(smoothstep(1.1, 0.0, dist / 4.0) / 3.0) * vec3(0.7, 0.9, 1.0) * smoothstep(0.15, 0.16, dist);\n\n    // Stars\n    col += vec3(0.01 / length(gv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1093, 2267]], "test": "untested"}
{"id": "fdVSRt", "name": "chunk loading area", "author": "ArmandB", "description": "shows where to load chunks \nuse the mouse to rotate the looking direction\nred = 1st priority\ngreen = 2nd priority\nblue = 3rd priority", "tags": ["game"], "likes": 2, "viewed": 278, "published": 3, "date": "1635133645", "time_retrieved": "2024-07-30T18:53:30.883140", "image_code": "float fovDeg = 90.0;\nfloat bufferRadius = 5.0;\nfloat renderDist = 50.0;\nfloat PI = 3.14159265359;\n\nmat2 rotate2d(float angle){\n    return mat2(\n        cos(angle), sin(angle), \n        -sin(angle), cos(angle) \n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy/iResolution.xy*100.0) -50.0;\n    mouse.x *= iResolution.x/iResolution.y;\n    float dir = atan(mouse.y, mouse.x); //the direction the player is looking\n\n    // Normalized pixel coordinates (from 0 to 100)\n    vec2 uv = fragCoord/iResolution.xy*100.0;\n    uv -= 50.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 st = uv;\n    uv = round(uv);\n    uv = uv*rotate2d(dir);\n    \n    vec3 col = vec3(0);\n    \n    float fov = fovDeg/180.0 * PI; //the fov in radians\n    \n    float minAngle = -fov/2.0; //the min angle to draw\n    float maxAngle = fov/2.0; //the max angle to draw\n    float angleTan = atan(uv.y, uv.x); //the angle of the current position\n    vec2 uvMin = uv*rotate2d(minAngle); //the position of the min angle\n    vec2 uvMax = uv*rotate2d(maxAngle); //the position of the max angle\n    if (length(uv) <= bufferRadius){ //center\n        col += vec3(0.4,0,0);\n    } else {\n        if (angleTan >= minAngle && angleTan <= maxAngle){ //angle\n            if (length(uv) <= renderDist) {\n                col += vec3(0,0.4,0);\n            } else if (length(uv) <= renderDist+bufferRadius) {\n                col += vec3(0,0,0.4);\n            }\n        } else if (uvMin.x <= renderDist+bufferRadius && uvMin.x >= 0.0 && uvMin.y >= -bufferRadius && uvMin.y <= 0.0){ //side min\n            col += vec3(0,0,0.4);\n        } else if (uvMax.x <= renderDist+bufferRadius && uvMax.x >= 0.0 && uvMax.y <= bufferRadius && uvMax.y >= 0.0){ //side max\n            col += vec3(0,0,0.4);\n        }\n    }\n    \n    //direction pointer\n    vec2 stRot = st*rotate2d(dir);\n    col += smoothstep(1.0, 0.0, (stRot.x >= 0.0) ? abs(stRot.y*5.0) : 1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 126, 126, 218], [220, 220, 277, 277, 1997]], "test": "untested"}
{"id": "fsVXRc", "name": "Recursive Blur", "author": "Remming_Senegal", "description": "Instead of blurring everything in one frame, it blurs over the span of a given amount of frames:\nPROS:\n+Very efficient\n+High FPS\n+Good looking blur\n\nCONS:\n-No videos\n-Takes time to blur", "tags": ["2d", "filter", "buffer", "repeat", "void"], "likes": 1, "viewed": 340, "published": 3, "date": "1635116335", "time_retrieved": "2024-07-30T18:53:31.745833", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define BLUR 100\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = 3.0/iResolution.x;\n    float y = 3.0/iResolution.y;\n    \n    vec4 average;\n    // Weird glitch where loading the shader for the first time doesn't sample channels\n    // Should be fixed if I add some buffer frames though\n    if(iFrame <= 5) {\n        vec4 m = texture(iChannel0,uv);\n        vec4 N = texture(iChannel0,uv+vec2(0.0,y));\n        vec4 S = texture(iChannel0,uv+vec2(0.0,-y));\n        vec4 W = texture(iChannel0,uv+vec2(x,0.0));\n        vec4 E = texture(iChannel0,uv+vec2(-x,0.0));\n        \n        average = m + N + S + W + E;\n        average /= 5.0;\n\n    \n    } else if(iFrame < BLUR + 5) {\n        vec4 m = texture(iChannel1,uv);\n        vec4 N = texture(iChannel1,uv+vec2(0.0,y));\n        vec4 S = texture(iChannel1,uv+vec2(0.0,-y));\n        vec4 W = texture(iChannel1,uv+vec2(x,0.0));\n        vec4 E = texture(iChannel1,uv+vec2(-x,0.0));\n        \n        average = m + N + S + W + E;\n        average /= 5.0;\n\n    } else {\n        vec4 m = texture(iChannel1,uv);\n        average = m;\n    }\n    \n    \n    fragColor = average;\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 252]], "test": "untested"}
{"id": "ssyXRd", "name": "Fork molten bis atnupacas 965", "author": "atnupacas", "description": "some self-consistency improvements of ([url]https://www.shadertoy.com/view/MsGSRd[/url]).\ncornusammonis' latest fluid stuff reminded me to give that another try - also tried to use mipmaps, but looked better without in the end... use mouse to push fluid", "tags": ["simulation", "fluid", "flow", "cfd"], "likes": 5, "viewed": 334, "published": 3, "date": "1635112973", "time_retrieved": "2024-07-30T18:53:32.516772", "image_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD - with some self consistency fixes\n\n// drawing the liquid\n\n// same fluid as in \"Spilled\" - https://www.shadertoy.com/view/MsGSRd\n// ...but with self-consistent-ish velocity field\n// the previous method was just defined implicitely by the rotations on multiple scales\n// here the calculated velocity field is put back into the stored field\n\n// use mouse to push fluid, press I to init\n\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel1\n\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    return texture(iChannel2,dir.xzy)+.15;\n}\n\nvec4  getCol(vec2 uv) { return texture(iChannel0,scuv(uv)); }\nfloat getVal(vec2 uv) { return length(getCol(uv).xyz); }\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0); return vec2( getVal(uv+d.xy)-getVal(uv-d.xy),\n                                       getVal(uv+d.yx)-getVal(uv-d.yx) )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // calculate normal from gradient (the faster the higher)\n    vec3 n = vec3(-getGrad(uv,1.4/iResolution.x)*.02,1.);\n    n=normalize(n);\n\n    /*vec3 light = normalize(vec3(-1,1,2));\n    float diff=clamp(dot(n,light),0.,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0); spec=exp2(log2(spec)*24.0)*2.5;*/\n    \n    // evironmental reflection\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    vec3 dir=normalize(vec3(sc,-1.));\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(vec3(0),R.xzy,1.).xyz;\n    \n    // slightly add velocityfield to color - gives it a bit of a 'bismuty' look\n    vec4 col=getCol(uv)+.5;\n    col=mix(vec4(1),col,.35);\n    col.xyz*=.95+-.05*n; // slightly add some normals to color\n    \n\t//fragColor.xyz = col.xyz*(.5+.5*diff)+.1*refl;\n\tfragColor.xyz = col.xyz*refl;\n\tfragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD - with some self consistency fixes\n\n// ...the actual fluid simulation\n\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n#define SUPPORT_EVEN_ROTNUM\n\n#define keyTex iChannel2\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n\nconst float ang = PI2/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    float l=log2(dot(b,b))*sqrt(.125)*.0;\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(textureLod(iChannel0,((pos+p)/Res0.xy),l).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    vec2 b = cos(float(iFrame)*.3-vec2(0,1.57));  // vary curl-evaluation-points in time\n    vec2 v=vec2(0);\n    float bbMax=.5*Res0.y; bbMax*=bbMax; // take curls up to half screen size\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n            v+=p.yx*getRot(pos+p,-mh*b);\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    // perform advection\n    fragColor=textureLod(iChannel0,fract((pos-v*vec2(-1,1)*5.*sqrt(Res0.x/600.))/Res0.xy),0.);\n    \n    // feeding some self-consistency into the velocity field\n    // (otherwise velocity would be defined only implicitely by the multi-scale rotation sums)\n    fragColor.xy=mix(fragColor.xy,v*vec2(-1,1)*sqrt(.125)*.9,.025);\n    \n    // add a little \"motor\"\n    vec2 c=fract(scuv(iMouse.xy/iResolution.xy))*iResolution.xy;\n    vec2 dmouse=texelFetch(iChannel3,ivec2(0),0).zw;\n    if (iMouse.x<1.) c=Res0*.5;\n    vec2 scr=fract((fragCoord.xy-c)/Res0.x+.5)-.5;\n    // slowly rotating current in the center (when mouse not moved yet)\n    if (iMouse.x<1.) fragColor.xy += 0.003*cos(iTime*.3-vec2(0,1.57)) / (dot(scr,scr)/0.05+.05);\n    // feed mouse motion into flow\n    fragColor.xy += .0003*dmouse/(dot(scr,scr)/0.05+.05);\n\n    // add some \"crunchy\" drops to surface\n    fragColor.zw += (texture(iChannel1,fragCoord/Res1*.35).zw-.5)*.002;\n    fragColor.zw += (texture(iChannel1,fragCoord/Res1*.7).zw-.5)*.001;\n    \n    // initialization\n    if(iFrame<=4) fragColor=vec4(0);\n    if(KEY_I>.5 ) fragColor=(texture(iChannel1,uvSmooth(fragCoord.xy/Res0.xy*.05,Res1))-.5)*.7;\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// just some mouse motion detection\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 c=texelFetch(iChannel0,ivec2(0),0);\n    vec2 m=iMouse.xy;\n    vec2 d=vec2(0);\n    if(iMouse.xy!=iMouse.zw) { d=iMouse.xy-c.xy; }\n    fragColor.xyzw = vec4(m,d);\n}\n\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// your code here\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=1.-iMouseData.z/1000.;\n    #endif\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    //return uv+.8*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyXRd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[598, 598, 644, 644, 689], [691, 691, 714, 714, 752], [753, 753, 776, 776, 809], [815, 815, 850, 850, 1004], [1006, 1006, 1063, 1063, 1930]], "test": "untested"}
{"id": "7dyXzt", "name": "Fab25 #inktober2021 \"splat\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n", "tags": ["2d", "rain", "splat", "drops", "short", "splash", "inktober2021"], "likes": 3, "viewed": 305, "published": 3, "date": "1635110884", "time_retrieved": "2024-07-30T18:53:33.293695", "image_code": "#define H(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(t,s)  ( t < 1. ? t-s : fract(t-s) )                   // init vs steady rain\n\nvoid mainImage(out vec4 O, vec2 u ) \n{\n    vec2  R = iResolution.xy;\n    float N = 2., w = N/R.y, t = iTime/10.,\n          l = 9., d,a;\n    vec2  U = w* ( u+u - R ), D,P,_P,\n          I = floor(U), F = fract(U)-.5;\n          \n    O = .9*texture(iChannel0, 2.*u/R);                          // background\n    \n    int i=-1,k=0;\n    for( ; k < 9; k++ )                                         // check neighbor cells\n        D = vec2( k%3, k/3 )-1.,\n        T( t , H(I+D+.2).x ) > 0.                               // proba of splat\n          ? P = F - D - H(I+D),\n            d = dot(P,P),\n            d < l ? l = d, _P=P,i=k : k :k;                     // keep closest splat id\n        \n    i >= 0\n      ? a = atan(_P.y,_P.x),                                    // restore closest splat\n        D = vec2( i%3, i/3 )-1.,\n        F = H(I+D+.6)*.1, P = H(I+D+.4)*6.28,\n        l = length(_P) - .1-F.x  -.03* cos(3.*a+P.x) -.03* (1.+3.*F.y)*cos(7.*a+P.y), // splat shape\n        O = mix(O, vec4(.8,.8,1,1), .4* smoothstep(2.*min(fwidth(l),w),0., l )     // draw splat\n                                      * smoothstep(1.,0.,T( t , H(I+D+.2).x ) ) )  // fade over time\n      : O;\n    \n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 206, 206, 1349]], "test": "untested"}
{"id": "sdyXzt", "name": "Neumorphic Power Button", "author": "Zi7ar21", "description": "idk lol\nMaybe I will add pushability later\nThis isn't the best code btw", "tags": ["night", "ui", "power", "button", "dark", "design", "symbol", "icon", "neumorphism", "ux"], "likes": 7, "viewed": 396, "published": 3, "date": "1635107455", "time_retrieved": "2024-07-30T18:53:34.134447", "image_code": "const float pi = 3.141592653589793;\n\nfloat dotp( vec2 vector ) { return dot(vector, vector); }\nfloat dotp( vec3 vector ) { return dot(vector, vector); }\nfloat dotp( vec4 vector ) { return dot(vector, vector); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n\n    // Radius ^ 2 (sqrt() skip)\n    float r2 = dotp(uv);\n\n    float theta0 = 0.5+( atan( uv.x,  uv.y)/(2.0*pi) );\n    float theta1 = 0.5+( atan(-uv.x, -uv.y)/(2.0*pi) );\n\n    if(r2 < 0.5*0.5)\n    {\n        fragColor.rgb = (0.2*vec3( 0.5*(sin(2.0*pi*theta1)+1.0) ) )+0.1;\n\n        if(r2 < 0.45*0.45)\n        {\n            fragColor.rgb = (0.05*vec3( 0.5*(sin(2.0*pi*theta0)+1.0) ) )+0.225;\n\n            if(r2 < 0.4*0.4)\n            {\n                float theta = 0.5+(atan(-uv.x, -uv.y)/(2.0*pi));\n\n                fragColor.rgb = vec3( mix(0.2, (0.2*( 0.5*(sin(2.0*pi*theta1)+1.0) ) )+0.1, max(dotp(2.0*uv)-0.0, 0.0) ) );\n\n                if( (r2 < 0.2*0.2 && r2 > 0.19*0.19 && theta1 > 0.1 && theta1 < 0.9) || (uv.x < 0.005 && uv.y < 0.25 && uv.x > -0.005 && uv.y > 0.0) )\n                {\n                    fragColor.rgb = vec3(0.3, 0.3, 1.0);\n                }\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 64, 64, 94], [95, 95, 122, 122, 152], [153, 153, 180, 180, 210], [212, 212, 269, 269, 1297]], "test": "untested"}
{"id": "7dGXzt", "name": "auroracorev222222", "author": "WaifuFarmer", "description": "a u r123\n\nany tips on how to reduce artifacts without ruining performance ?", "tags": ["222"], "likes": 1, "viewed": 328, "published": 3, "date": "1635104741", "time_retrieved": "2024-07-30T18:53:34.902394", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - mod(fragCoord, SCALE)) / iResolution.xy;\n    //vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(pow(texture(iChannel0, uv).rgb / 10., vec3(0.454545)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 1280\n#define MAX_DIST 1280.\n#define MAX_DIST_CHECK MAX_DIST - 10.\n#define E 0.001\n#define PI 3.141592\n#define MODE 1\n\n#define PI 3.141592\n\n//#define PRECISION (sin(iDate.w)*.1+.11)\n//#define INV_PRECISION (1. / PRECISION)\n#define PRECISION 0.1\n#define INV_PRECISION 10.\n\n#define MIND_RATIO 0.6\n#define COL_LOL_RATIO (sin(iDate.w*0.73)*.5+.5)\n\nvec3 rotX(vec3 v, float a)\n{\n    return vec3(v.x, v.y * cos(a) - v.z * sin(a), v.y * sin(a) + v.z * cos(a));\n}\n\nvec3 rotY(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) + v.z * sin(a), v.y, v.z * cos(a) - v.x * sin(a));\n}\n\nvec3 rotZ(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a), v.z);\n}\n\nvec3 modSDF(vec3 p, vec3 c)\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nvec3 modSDFlim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 elongateSDF(in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return max(q,0.0) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\nvec3 twistSDF(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat scene(vec3 p)\n{\n    //p = modSDF(p, vec3(30., 30., 30.))+ sin(iTime + p.x) * 10.;\n    //p.x /= iResolution.x / iResolution.y - 0.3;\n    float stx = sin(iDate.w);\n    float sty = sin(iDate.w * 1.228);\n    float stz = sin(iDate.w * 0.856);\n    float displacement_mapping = sin(p.y) + 0.3 * sin(p.x * (1.23 + 2. * stx)) * sin(p.y * (1.37 + 2.2 * sty)) * sin(p.z * (1.56 + 2.12 * stz));\n    float dm = 0.2 * sin(p.x * sin(iDate.w / 5.) * 3.) * sin(p.y * sin(iDate.w / 4.) * 3.) * sin(p.z * sin(iDate.w / 6.) * 3.);\n    //float size = abs(mod(p.x * 0.3 + p.y * 0.5+ p.z * 0.4 + iDate.w, delay) - delay * 0.5);\n    //displacement_mapping *= size;\n    vec2 torus_0 = vec2(4.8, 0.6);\n    vec3 p_mod = rotZ(rotY(rotX(p, iDate.w * 1.2), sin(iDate.w) * 1. * displacement_mapping), iDate.w * .9);\n        return PRECISION * sdfTorus(twistSDF(p_mod, (sin(iDate.w * 0.8)-0.7) + 0.3 +  displacement_mapping * 0.1 + sin(iTime)*.5+.9) + displacement_mapping * 0.1, torus_0) + dm * 0.2 * smoothstep(-1., 1., stx) + 0.033 * (sin(iTime));\n}\n\n\nvec2 march(vec3 ro, vec3 rd, float side)\n{\n    float ray_dist = 0.;\n    float mind = 10000.;\n    for (int steps = 0; steps < MAX_STEPS; steps++)\n    {\n        vec3 p = ro + rd * ray_dist;\n        float step_dist = scene(p) * side;\n        if (step_dist * INV_PRECISION < mind)\n            mind = step_dist * INV_PRECISION;\n        ray_dist += step_dist;\n        if (step_dist < E || ray_dist > MAX_DIST)\n            break;\n    }\n    return vec2(ray_dist, mind);\n}\n\nvec3 normal(vec3 p)\n{\n    float d = scene(p);\n    vec2 e = vec2(E, 0.);\n    \n    vec3 n = d - vec3(\n        \t\tscene(p - e.xyy),\n                scene(p - e.yxy),\n                scene(p - e.yyx));\n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 n, float side)\n{\n    vec3 lightPos = vec3(-30. * sin(iTime), 30., -30. * cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    float dif = clamp(dot(l, side * n), 0.1, .7);\n    vec2 d = march(p + n, l, -side);\n    if (d.x < length(lightPos - p))\n       return dif * 0.;\n    return dif;\n\n}\n\nvec3 get_ray_dir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(mod(fragCoord, SCALE)) != ivec2(0))\n        return;\n\tvec3 col = vec3(0);\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y);\n    //vec3 ro = vec3(20. * sin(iTime), 0., -20. * cos(iTime));\n    //vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    //rd = rotY(rd, -iTime);\n\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(10, 0, -10);\n    ro.yz *= rot(-m.y * PI + 1.);\n    ro.xz *= rot(-m.x * TAU);\n    \n    vec3 rd = get_ray_dir(uv, ro, vec3(0,0.,0), 0.9);\n\n    \n    vec2 d = march(ro, rd, 1.);\n    float mind = 1. - pow(1. - min(1., max(d.y, 0.)), 2.2);\n    mind = d.y;\n    vec3 p = ro + rd * d.x;\n    vec3 n = normal(p);\n    vec3 pp = p + n * E * 10.;\n    vec3 refr = rd;\n    int i = 1;\n    vec3 lol = vec3(0);\n    //if (d.x < MAX_DIST_CHECK)\n    //    col += light(pp, n, 1.) * vec3(pp.x - 3., pp.y - 3., pp.z - 3.) / 8.;\n    float st = sin(iTime * 0.93)*.5+.5;\n    //st = 0.;\n    while (1 - MODE == 0 && d.x < MAX_DIST_CHECK && i < 4)\n    {\n        //col += light(pp, n, mod(float(i + 1), 2.)*2.-1.)\n        //    *(vec3(pp.x - 3., pp.y + 100., pp.z - 13.) * st\n        //    + vec3(d.x * 20., d.y * 7., length(p) / 3.) * (1. - st))\n        //    / exp(float(i) + 1.5);\n        col += light(pp, n, mod(float(i + 1), 2.)*2.-1.) * (modSDF(abs(pp), vec3(10.)) + n) * 0.7 * (sin(iTime*0.24562152534)*0.25+0.75);\n        /*refr = refract(refr, n, 1./1.3);\n        d = march(p - n * E * 3., refr, 1.);\n        p = ro + rd * d.x;\n        n = normal(p);\n        pp = p + n * E * 10.;*/\n        i++;\n        mind += abs(d.y);\n    }\n    mind /= float(i);\n    mind = MIND_RATIO / mind;\n    //vec3 mind = vec3(1.) - pow(vec3(1.) - vec3(min(1., max(d.y, 0.))), vec3(2.2));\n    //col += (1. - log(mind + 1.)) * max(0., (0.4 - min(1.4, max(d.y, 0.))));\n    //col = vec3(mind);\n    //col += smoothstep(0.8, 1.1, 3.333 * max(0., (0.3 - min(1., max(mind, 0.)))));\n    //col = col * COL_LOL_RATIO + lol * (1. - COL_LOL_RATIO);\n    //col += 0.00 * vec3(sin(iDate.w / 2.), cos(iDate.w / 3.), sin(iDate.w / 4.)) * 0.3 * (1. - pow(1. - vec3(min(1., max(d.y, 0.))), vec3(2.2)));\n    //col *= smoothstep(0., 0.4, max(0., 0.45 - length(uv)));\n    //col = ((1. - (sin(iDate.w * 0.6)*.5+.5)) + 0.4) * pow(col, vec3(0.454545));\n    col = pow(col, vec3(0.454545));\n    //ADD THIS//col += 0.2*vec3(0.1, 0.4, 0.9) * smoothstep((cos(iDate.w)*.5+.7) * 1., (sin(iDate.w)*.5+.7) * 10., mind);\n    fragColor = vec4(1.*col, 1.);\n    //fragColor = vec4(col /*+ (sin(iTime * 2.8)*.5+.5) * 0.99 * texture(iChannel0, fragCoord / iResolution.xy).brg * vec3(0.8, .5, 1.2)*/, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.283185\n#define STK(x) (sin(iTime * x * TAU)*.5+.5)\n#define FUN (1. + floor(STK(STK(.1) * .11)*8.))\n#define SCALE 1.\n/*\n** Trigonometry functions\n*/\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n/*\n** Bitwise Operators\n*/\n\nint xor(float a, float b)\n{\n    a = float(int(a));\n    b = float(int(b));\n    int c = 0;\n    for (float i = 1.; i < 65536.; i *= 2.)\n    {\n        float m = i * 2.;\n        int d = 0;\n        if (mod(a, m) > i-0.5)\n            d++;\n        if (mod(b, m) > i-0.5)\n            d++;\n        if (d == 1)\n            c += int(i);\n    }\n    return c;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 253]], "test": "untested"}
{"id": "sdGSzt", "name": "The Alien", "author": "dean_the_coder", "description": "Following the theme of 'lets make a shader about a movie I like', may I present 'The Alien'. :D", "tags": ["3d", "raymarching", "animation", "alien", "gyroid", "movie", "cineshader"], "likes": 20, "viewed": 5323, "published": 3, "date": "1635099465", "time_retrieved": "2024-07-30T18:53:35.987495", "image_code": "// 'The Alien' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/sdGSzt (YouTube: https://youtu.be/2QoR8L16Lc0)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I nearly gave up several times on this shader. I knew modelling\n// a human face would be hard, so thought attempting an alien would\n// be easier. No two 'alien' references seem to be the same, so\n// I can use artistic license. Also there's no eyes/node to get wrong.\n// I'm quite happy with the result, but the body could do with some arms.\n// But hey - The framerate is still acceptable (for me), so...\n//\n// I'm also trying to improve my animation skills. I've added some\n// 'anticipations', where before a strike the alien pulls back a bit\n// to build up some 'power'.\n//\n// The skull pattern was simpler than I was expecting - I just threw\n// a simple gyroid at it and it looked good! Surprising! And fast\n// to calculate in real-time.\n//\n// Tricks to get the performance:\n//   - No 'max dist' needed in raymarching loop (all rays hit something).\n//   - Only the skull is reflective, and that reflects just a fake sky.\n//     (I know there's no sky in a corridor, but it looks good!)\n//   - I precalculate two smooth noises variables in the lighting\n//     code and reuse them as much as possible.\n//   - Lots of domain repetition.\n//     E.g. Each jaw only has one tooth!\n//          There's only one SDF for the wall pipe.\n//          The Weyland-Yutani logo is _nearly_ just one line.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, and a bunch\n// of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define U\tnormalize\n#define L\tlength\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b, c)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) { return -smin(-a, -b, k); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn L(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(L(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + L(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn L(p) - r;\n}\n\nfloat arc(vec3 p) {\n\tp.x -= -3.83333;\n\tvec2 v = vec2(-.56464, .82534),\n\t     q = p.xy - 2. * v * max(0., dot(v, p.xy));\n\tv = vec2(-3.83333, 0);\n\tfloat u = -v.x - L(q);\n\treturn sqrt((q.y < 0. ? dot(q + v, q + v) : u * u) + p.z * p.z) - max(.001, .8 - (p.y > 0. ? atan(-p.y, p.x) * v.x : -p.x < 0. ? p.y : 4.6 - p.y) * .06);\n}\n\nfloat backInOut(float x) {\n\tfloat f = x < .5 ? 2. * x : 1. - (2. * x - 1.),\n\t      g = pow(f, 3.) - f * sin(f * 3.141);\n\treturn x < .5 ? .5 * g : .5 * (1. - g) + .5;\n}\n\nfloat bone(vec3 p, float h, float r, float s) {\n\tfloat f = S(.7, 1., abs(p.x / h - .5) * 2.) * .05 * s;\n\tp.y = abs(p.y) - f;\n\treturn cap(p, h, r - f * .6);\n}\n\nfloat sky(vec3 rd) {\n\tfloat d = 10. / rd.y,\n\t      den = 1.;\n\tif (d < 0.) return 0.;\n\tvec3 p = rd * d + vec3(1, .2, 1) * t * .8;\n\tp.xz *= .2;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.12 * fbm(p));\n\n\treturn S(.9, 1., den) * (1. - sat(d / 64.));\n}\n\nfloat th(inout vec3 p) {\n\tfloat f = atan(p.z, p.x) + .25087;\n\tp.xz = L(p.xz) * cos(mod(f, .26174) - .13087 + vec2(0, 1.57));\n\tp = vec3(.04 - p.y, p.x - .36, p.z);\n\tf = .45 + abs(floor(f * 2.) * .01);\n\treturn cap(p, f, .05 * S(0., f * 1.5, cos(abs(p.x / f * 1.86 - 1. + p.x))));\n}\n\nHit map(vec3 p) {\n\tHit h;\n\th.d = 1e7;\n\tfloat d, lip, at, f, nd, s, O, x, o,\n\t      ph = S(0., 5., t);\n\tp.x -= 12. * (1. - ph);\n\tp.xz *= rot(sin(t * .5) * .02);\n\tp.yz *= rot(sin(t) * .01);\n\tvec3 r, np, pp,\n\t     op = p;\n\n\t// Corridor.\n\tp.xz *= mat2(.96891, -.2474, .2474, .96891);\n\tp.y = abs(p.y);\n\tp.z -= 30.;\n\td = -p.z - 2.;\n\tp.yz *= mat2(.87758, -.47943, .47943, .87758);\n\tp.y -= 2.5;\n\tminH(min(d, -p.z), 6, p);\n\tp.x = abs(p.x + 3.) - 15.;\n\tminH(box(p - vec3(0, 8.5, 0), vec3(5, 2.3, .1)), 8, p - vec3(0, 8.5, 0));\n\n\t// Pipework.\n\td = L(p.yz - vec2(14, 0)) - 1.5;\n\tp.y = abs(p.y - 2.5) - 1.1;\n\tminH(min(d, L(p.yz) - .8), 7, p);\n\n\t// Anim.\n\tlip = 0.;\n\tr = vec3(0);\n\n\t// Walk on.\n\top.x += 16. * (1. - ph);\n\tr.xy = sin(ph * 12.566 + vec2(0, 8)) * vec2(.05, .1) * S(1., .5, ph * ph);\n\tr.z = -r.x * .5;\n\top.y += abs(r.x);\n\n\t// Slight turn.\n\tph = S(4., 8., t);\n\tr.xy = mix(r.xy, sin(backInOut(ph) * -.25132 + vec2(0, 8)) * vec2(1, .12), S(0., .2, ph));\n\n\t// Sniff.\n\tph = S(8.2, 12., t);\n\tlip = abs(sin(ph * 6.283));\n\tr.x += sin(ph * -3.142) * .015;\n\n\t// Face forward.\n\tr.xy *= S(14., 11.5, t);\n\n\t// Whip-round anticipation.\n\tph = S(14.5, 15., t);\n\tr += vec3(.1, .05, .1) * ph;\n\top.y += ph * .1;\n\n\t// Whip.\n\tph = S(15., 15.3, t);\n\tr = mix(r, vec3(-.5, .12, 0), ph);\n\n\t// Mouth open.\n\tat = S(15.3, 20., t) * .2;\n\tf = S01(at * 30.);\n\tlip += f;\n\tr.yz = mix(r.yz, vec2(.34, -.1 + sin(t) * .07), at * 5.);\n\n\t// Inner mouth open.\n\tat += S(20., 23., t) * .25;\n\n\t// Strike anticipation.\n\top.z -= S(24., 24.2, t) * .5;\n\n\t// Strike.\n\tph = S(24.2, 24.5, t);\n\top.z += ph * 1.5;\n\tat += ph * .4;\n\n\t// Withdraw.\n\tph = S(29., 32., t);\n\tat += ph;\n\top.z -= ph;\n\tr.y *= S(34., 31., t);\n\n\t// Body position.\n\top += vec3(.9, 1.3, -3.6);\n\top.yz *= rot(r.y + .2);\n\top.xz *= rot(r.x - .2);\n\tr *= 3.;\n\n\t// Spine.\n\tp = op;\n\tp.xy *= mat2(-.73739, -.67546, .67546, -.73739);\n\tp.x++;\n\td = cap(p + vec3(0, .68, 0), 4., .1 + abs(sin(p.x * 26.) * .04));\n\tminH(d, 2, p);\n\n\t// Neck/body.\n\tp.z *= 1. - mix(.4, 1.2, S01(p.x)) * .42;\n\tf = abs(sin(p.x * 15.) * .07);\n\tf *= S(.01, .05, abs(p.z));\n\tf += S(0., .3, p.x) * .6 * S01(p.y);\n\tnd = cap(p, 4., mix(.3, .5, S01(p.x)) * (1. + f));\n\tnp = p;\n\n\t// Rotate head.\n\tp = op - vec3(1, .4, 0);\n\tr *= .5;\n\tp.xz *= rot(r.x);\n\tp.yz *= rot(r.z);\n\tp += vec3(1, .4, 0);\n\top = p;\n\n\t// Skull.\n\tp = op;\n\tp.x -= 1.5;\n\tp.xy *= mat2(.85252, -.52269, .52269, .85252);\n\tp.xy = vec2(p.y - 1., -p.x);\n\td = arc(p);\n\tp = op - vec3(.9, 0, 0);\n\tp.xy *= mat2(.995, -.09983, .09983, .995);\n\tf = .15 - box(p, vec3(2.6, cos((p.x + .3) * .4) * 1.71 - .5, 1));\n\td = smax(d, f, .06);\n\tminH(d, 1, p);\n\n\t// Head bulk.\n\tp = op;\n\tp.y -= .86;\n\td = min(d, L(p.yz) - .3 - .04 * abs(sin(p.x * 7.7)) - .02 * abs(sin(p.x * 23.1)));\n\tminH(max(d, abs(p.x) - 2.4), 2, p);\n\n\t// Frills.\n\tp = op;\n\tp.xy += vec2(1.8, -.88);\n\tp.z = abs(p.z) - .22;\n\tp.xy *= mat2(.99281, .11971, -.11971, .99281);\n\tp.xz *= mat2(.9968, .07991, -.07991, .9968);\n\td = max(cap(p, 3.5, .2 + .05 * abs(sin(p.x * 22.)) + sin(p.x) * .1), -p.y - .14);\n\n\t// Lower organs.\n\tpp = p + vec3(-1.8, .3, 0);\n\tpp.yz /= .8 + .5 * cos(pp.x);\n\tpp.yz *= rot(pp.x * -.3 + .8);\n\tf = sin(pp.x * 35.);\n\tf = max(smin(box(pp, vec3(2, vec2(.1 + .01 * abs(f * f)))), L(abs(pp.yz) - .116) - .02, .08), abs(pp.x) - 2.);\n\tminH(min(d, f), 2, pp);\n\tif (nd < d) minH(smin(d, nd, .5), 9, np);\n\n\t// Skull bone.\n\tp.yz += vec2(.21, -.15) - sin(p.x - .2) * .14;\n\tminH(bone(p, 3.6, .08, 1.), 3, p);\n\n\t// Cheek bone.\n\tp.x -= 3.63;\n\tp.xy *= mat2(.88699, -.46178, .46178, .88699);\n\tp.yz *= mat2(.5403, .84147, -.84147, .5403);\n\td = min(d, bone(p, .65, .06 - .01 * sin(p.x * 10. - 1.), .8));\n\tminH(d, 3, p);\n\n\t// Top gums.\n\tp = op;\n\tp.xy -= vec2(2.3, .76);\n\td = max(cyl(p.xzy, vec2(.4 + S(-.15, .1, p.y) * .17 - S(.2, -.2, p.y + p.x) * .09, .2 - sin(p.y * 77.) * .02 * lip)) - .1, 2.75 * p.y + p.x - .4);\n\tminH(d, 3, p);\n\n\t// Smooth connect organs to top gums.\n\tminH(max(max(smin(f, d, .25) + .01, -f), -d), 2, p);\n\n\t// Top teeth.\n\tp.x -= .08;\n\tminH(max(smax(th(p), p.y - .03, .02), 2.29 - op.x), 4, p);\n\n\t// Strike animation.\n\tf = S(1., .9, at);\n\ts = S(.5, .51, at);\n\tO = (S(0., .15, at) * .6 + s * .4) * f + sin(t) * .03;\n\tx = S(0., .2, at) * .22 + s * .5;\n\to = S(.15, .4, at) * .5 + s * (sin(t * 14.) - .8) * .2;\n\tx *= f * f;\n\to *= f * f;\n\n\t// Inner mouth.\n\tp = op;\n\tp.xy *= mat2(.87758, -.47943, .47943, .87758);\n\tp.xz *= rot(sin(t * 2.) * .014 * s);\n\tp.y -= 1.44;\n\tp.x -= x - .9;\n\tpp = p;\n\td = L(p.yz) - .1 - sin(p.x * 58.) * .01;\n\tp.yz = abs(p.yz) - .08;\n\td = max(smin(max(d, -d - .012), L(p.yz) - .03, .05), abs(p.x - 2.2) - .5);\n\tminH(d, 5, p);\n\tp = pp;\n\tp.y = abs(p.y) - .08;\n\tp.x -= 2.68;\n\tp.xy *= rot(o + .1);\n\tp.x -= .05;\n\tminH(smin(d, box(p, vec3(.035 + abs(sin(abs(p.z) * 81.) * .006), .008, .1)) - .014, .03), 5, p);\n\n\t// Inner teeth.\n\tp.x -= .025;\n\tp.z = abs(abs(p.z) - .034) - .017;\n\tp.y *= -1.;\n\tp.xy = p.yx;\n\td = cap(p, .06, .016 * cos(p.x * 22.));\n\tp.z = abs(pp.z) - .09;\n\tminH(min(d, cap(p, .1, .02 * cos(p.x * 17.))), 4, p);\n\n\t// Jaws.\n\to = O * -.4 - .9;\n\tp = op - vec3(1.6, .95, 0);\n\tp.xy *= rot(o);\n\tf = p.x * -.25;\n\tp.z -= clamp(p.z, -.6 - f, .6 + f);\n\td = bone(p, .9, .1 + f * .2, .8);\n\tp.x -= .9;\n\tp.xy *= mat2(.69671, .71736, -.71736, .69671);\n\td = smin(d, cap(p, .3, p.x * -.03 + .08), .1);\n\n\t// Bottom gums.\n\tp = op - vec3(1.6, .95, 0);\n\tp.xy *= rot(.8 + o);\n\tf = cyl(p.xzy * vec3(1, 1.3, 1) - vec3(.77, 0, -.73), vec2(.38 - .005 * sin(p.y * 126.), .04)) - .05;\n\tminH(smin(d, max(f, .7 - p.x), .1), 3, p);\n\n\t// Cheek skin.\n\tpp = p - vec3(.6, -.2, 0);\n\tf = S(-.32, .32, pp.y);\n\tpp.z = abs(pp.z) - .4 - f * .14;\n\tf = mix(.8, .5, O) * (.04 - .03 * sin(3.14 * f));\n\td = smin(d, min(box(pp + vec3(.2, -.2, -.05), vec3(.1 * pp.y + f, .32, 0)), box(pp, vec3(f, .35, 0))) - .02, .03);\n\tminH(d, 3, pp);\n\n\t// Bottom teeth.\n\tp.x -= .73;\n\tp.y += .9;\n\tp.xy *= mat2(-.98999, .14112, -.14112, -.98999);\n\tminH(max(max(p.x + .1, p.y + .3), th(p)), 4, p);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn U(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = L(p - lp);\n\tvec3 ld = U(lp - p);\n\tfor (float i = Z0; i < 25.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return sat(map(h * n + p).d / h); }\n\nvec3 strobe(vec3 p, vec3 c) {\n\tp.x -= 1.5;\n\tvec2 q = p.xz * rot(t * 2.);\n\treturn mix(c, pow(c, vec3(.7, 1, 1)), S(.8, .6, abs(q.x / q.y)));\n}\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tvec3 ld = U(vec3(6, 3, -10) - p), c;\n\tvec2 spe = vec2(10, 1);\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\t      nh = n31(h.p * 55.),\n\t      nl = n31(h.p * 23.);\n\tif (h.id == 1) {\n        // Gyroid.\n\t\tc = pow(abs((vec3(.005, .01, .01) * dot(sin(h.p * 26.), cos(h.p.zxy * 26.))\n\t\t + nh * .0046) * .5), vec3(1.12, map(ld + p).d * -.07 + 1.46, 1.43));\n\t\tc *= 1. - (.9 * S01(.9 + dot(rd, n)) + .5);\n\t\tspe = vec2(5, 28);\n\t}\n\telse if (h.id == 2 || h.id == 5 || h.id == 9) {\n\t\tc = vec3(ao * .001);\n\t\tc += S(.8, 1., ao) * vec3(1.4, 1.4, 1) * .009;\n\t\tc *= nh;\n\t\tc += 1e-4;\n\t\tspe = vec2(30. * ao, 3);\n\t\tif (h.id == 5) {\n\t\t\tc *= 4.5;\n\t\t\tspe = vec2(3, 13);\n\t\t}\n\t}\n\telse if (h.id == 3) {\n\t\tc = vec3(.56, .5, .6) * .001;\n\t\tc += S(.09, .88, abs(n.y) * nh) * .002 * vec3(1, .62, .65);\n\t\tn += (nl - .5) * .08;\n\t\tspe = vec2(18, 20);\n\t}\n\telse if (h.id == 6) {\n\t\tc = vec3(.01 + nl * .01);\n\t\tspe = vec2(19, 1);\n\t}\n\telse if (h.id == 7) {\n\t\tc = vec3(.03 + nl * .02);\n\t\tspe = vec2(42, 50);\n\t}\n\telse if (h.id == 8) {\n\t\th.p *= .3;\n        if (p.y < 0.0) h.p.y *= -1.;\n\t\tfloat w1 = abs(abs(abs(h.p.x) - .5) - h.p.y - .25);\n\t\tc = 5e-4 + min2(step(abs(h.p.xy), vec2(1.2, .4))) * (vec3(1, 1, 0) * S(.2, .15, w1) + vec3(.5) * S(.2, .15, min(abs(abs(h.p.x) - h.p.y - .15), max(h.p.y, abs(h.p.x) - .05))) * S(.25, .2, S(.4, .3, w1))) * .05 + nh * .001;\n\t}\n\telse {\n\t\tc = vec3(.01 + pow(sat(dot(rd, reflect(ld * vec3(-1, -1, 1), n))), 24.) * .6);\n\t\tspe = vec2(8, 5);\n\t}\n\n\tif (h.id == 9) c *= .4;\n\n\t// Combine into final color.\n\treturn (sat(.1 + .9 * dot(ld, n)) * (.1 + .9 * shadow(p, vec3(6, 3, -10))) * (.3 + .7 * ao) * ao + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y) * strobe(p, abs(c)) * 5.;\n}\n\nvec3 scene(vec3 rd) {\n    vec3 p = vec3(0);\n\tfloat i,\n\t      d = 0.;\n\tHit h;\n\tfor (i = Z0; i < 120.; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tvec3 n = N(p, d),\n\t     col = lights(p, rd, n, h) * exp(d * d * -.002);\n\tif (h.id == 1) {\n\t\t// We hit a reflective surface - Cheat and just reflect sky.\n\t\tn = U(n + (n31(h.p * 44.) - .5) * .05);\n\t\tcol += .015 * sky(reflect(rd, n));\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 36.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy;\n\tvec3 col = scene(U(vec3(uv, 1)));\n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(max(vec3(0), col), vec3(.45)) * sat(t) * S(34., 33., t), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGSzt.jpg", "access": "api", "license": "artistic-2.0", "functions": [[2110, 2171, 2190, 2190, 2531], [2533, 2533, 2552, 2552, 2684], [2686, 2686, 2725, 2725, 2807], [2809, 2809, 2848, 2848, 2875], [2877, 2877, 2897, 2897, 2921], [2923, 2923, 2942, 2942, 3009], [3011, 3011, 3038, 3038, 3120], [3122, 3122, 3150, 3150, 3240], [3242, 3242, 3279, 3279, 3326], [3328, 3328, 3347, 3347, 3652], [3654, 3654, 3680, 3680, 3821], [3823, 3823, 3870, 3870, 3980], [3982, 3982, 4002, 4002, 4230], [4232, 4232, 4256, 4256, 4511], [4513, 4513, 4530, 4530, 10385], [10387, 10387, 10412, 10412, 10623], [10625, 10625, 10656, 10656, 10910], [10912, 10940, 10975, 10975, 11011], [11013, 11013, 11042, 11042, 11154], [11156, 11156, 11201, 11201, 12877], [12879, 12879, 12900, 12900, 13316], [13318, 13318, 13363, 13363, 13634]], "test": "untested"}
{"id": "NdyXRd", "name": "random 1D", "author": "yyf1994", "description": "random 1D", "tags": ["random"], "likes": 0, "viewed": 292, "published": 3, "date": "1635087280", "time_retrieved": "2024-07-30T18:53:36.892074", "image_code": "\nfloat random(float n){\n\treturn fract(sin(n) * 100000.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    float x = uv.x*1009.0 ;\n\n    float y = random(x)  ;\n\n    float lineWidth =  0.004 ;\n    \n    if(uv.y>=y && uv.y<= y+ lineWidth){\n         fragColor = vec4(0.0,0.0,0.0,1.0);\n    }else{\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    \n    }   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 59], [62, 62, 119, 119, 412]], "test": "untested"}
{"id": "NsGSRd", "name": "Footwear Design 001", "author": "yasuo", "description": "slide moc EVA", "tags": ["footwear"], "likes": 11, "viewed": 244, "published": 3, "date": "1635085450", "time_retrieved": "2024-07-30T18:53:37.653040", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL_OUTSOLE 0\n#define MATERIAL_MIDSOLE1 1\n#define MATERIAL_MIDSOLE2 2\n#define MATERIAL_UPPER 3\n\n#define ZERO (min(iFrame,0))\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xy*=Rot(radians(90.0));\n    p.yz*=Rot(radians(15.0));\n    p.y*=1.5;\n    float d = sdCappedCylinder(p-vec3(0.0,0.0,0.25),h,0.3);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.23);\n    d = min(d, d2);\n    \n    p = prevP;\n    d2 = sdBox(p-vec3(0,0.0,0.0),vec3(0.145,h,0.18));\n    d = min(d, d2);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.yz*=Rot(radians(15.0));\n    p.y*=1.3;\n    d2 = sdCappedCylinder(p-vec3(-0.03,0.3,-0.01),0.2,0.125);\n    d = max(-d2,d);\n\n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    vec3 prevP = p;\n    float d = baseOutsole(p,0.02);\n    \n    p.z = mod(p.z,0.04)-0.02;\n    p.y*=0.5;\n    p.xz*=Rot(radians(90.0));\n    p.xy*=Rot(radians(30.0));\n    float d2 = sdTriPrism(p-vec3(0.0,0.01,0.0),vec2(0.03,0.3));\n    \n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.02,0.0),0.01);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec2 midsole(vec3 p){\n    float d = baseOutsole(p-vec3(0.0,0.03,0.0),0.01);\n    float d2 = baseOutsole(p-vec3(0.0,0.06,0.0),0.02);\n    \n    p.yz*=Rot(radians(-3.0));\n    float mask = p.y-0.07;\n    d2 = max(mask,d2);\n    \n    vec2 model = vec2(d,MATERIAL_MIDSOLE1);\n    vec2 model2 = vec2(d2,MATERIAL_MIDSOLE2);\n    \n    return combine(model,model2);\n}\n\nfloat upperBase(vec3 p){\n    vec3 prevP = p;\n    p.xz*=1.03;\n   \n    float d2 = baseOutsole(p-vec3(0,0.19,0),0.15);\n   \n    p.z-=0.06;\n    p.yz*=Rot(radians(40.0));\n    \n    float mask = p.y-0.2;\n    d2 = max(mask,d2);\n   \n    p = prevP;\n    p.yz*=Rot(radians(-10.0));\n    p.xz*=Rot(radians(15.0));\n    float d = sdEllipsoid(p-vec3(0.0,0.095,0.0),vec3(0.23,0.24,0.53));\n   \n    d = max(d,d2);\n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.3;\n    \n    float d2 = upperBase(p-vec3(0.0,-0.02,-0.03));\n    d = max(-d2,d);\n    \n    float prevD = d;\n    \n    p = prevP;\n    p.yz*=Rot(radians(-10.0));\n    p.xz*=Rot(radians(15.0));\n    p.z*=0.6;\n    p = mod(p,0.11)-0.055;\n    d2 = length(p)-0.05;\n    \n    d = max(-d2,d);\n    \n    p = prevP;\n    p.z-=0.1;\n    p.yz*=Rot(radians(40.0));\n    \n    float mask = p.y-0.2;\n    d2 = max(-mask,prevD);    \n\n    return min(d,d2);\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*300.0)*0.001;\n    vec3 prevP = p;\n    \n    p.y+=0.1;\n    p.z+=0.1;\n    float d = outsole(p);\n    \n    vec2 model = vec2(d,MATERIAL_OUTSOLE);\n    vec2 model2 = midsole(p);\n    \n    d = upper(p);\n    \n    vec2 model3 =vec2(d,MATERIAL_UPPER);\n    \n    return combine(model,combine(model2,model3));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    float nn = noise3d(p*80.0)*0.12;\n    if(mat == MATERIAL_OUTSOLE){\n        col = diffuseMaterial(n,rd,p,vec3(1.0,1.0,0.9)+nn);\n    } else if(mat == MATERIAL_MIDSOLE1){\n        col = diffuseMaterial(n,rd,p,vec3(1.0,0.6,0.0)+nn);\n    } else if(mat == MATERIAL_MIDSOLE2){\n        col = diffuseMaterial(n,rd,p,vec3(0.6,0.6,0.6))+nn;\n    } else if(mat == MATERIAL_UPPER){\n        \n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.2, 0.3)+nn+nn);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-15.0+iTime*20.0));\n        \n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = vec3(1.0,1.0,0.2);\n        //col = vec3(0.95);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGSRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 591, 616, 616, 955], [957, 957, 993, 993, 1035], [1037, 1086, 1138, 1138, 1245], [1247, 1247, 1278, 1278, 1365], [1367, 1367, 1403, 1403, 1486], [1488, 1488, 1525, 1525, 1608], [1610, 1610, 1645, 1645, 2258], [2260, 2260, 2282, 2282, 2638], [2640, 2640, 2661, 2661, 2991], [2993, 2993, 3017, 3017, 3401], [3403, 3403, 3423, 3423, 3910], [3912, 3912, 3934, 3934, 4248], [4250, 4250, 4308, 4308, 4575], [4577, 4577, 4601, 4601, 4802], [4804, 4804, 4846, 4846, 5041], [5043, 5084, 5133, 5133, 5424], [5426, 5426, 5483, 5483, 6102], [6104, 6104, 6163, 6163, 6630], [6632, 6632, 6689, 6689, 7721]], "test": "untested"}
{"id": "NdyXRt", "name": "drapes 2", "author": "FabriceNeyret2", "description": "Folds are modeled as circle sections of unit length curved to accommodate the target linear length.\nSee [url]https://www.desmos.com/calculator/umrflmd6dm[/url]\n\nMouse controls camera.", "tags": ["raymarching", "short", "folds", "drapes"], "likes": 14, "viewed": 344, "published": 3, "date": "1635083418", "time_retrieved": "2024-07-30T18:53:38.420986", "image_code": "#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))                          // rotation\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    float t=9.,d, l,A,r,s,u,v;                           \n    vec3  R = iResolution,\n          D = normalize(vec3((U+U-R.xy)/R.y, -2.)),                    // ray direction\n          p = vec3(0,-2,22), q,a,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(10,12,0)/1e2*cos(.3*iTime+vec3(0,11,0))+vec3(0,.12,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )          \n        q = p,\n        q.yz *= rot(.5-6.3*M.y),                                       // rotations\n        q.xz *= rot(-6.3*M.x), \n        a = abs(q), \n        v = .6 +.4*q.y/10.,                                            // normalized height\n        l = mix(1., v, .5+.5*sin(iTime) ) -1e-3,     // drape extension: 1 = no folds,  0.2 = max folds\n        u = floor(q.x/l),\n        A = 1.1*acos(2.*l-1.) +2.*acos(l), r = 1./A, // folds angle & radius, see https://www.desmos.com/calculator/umrflmd6dm\n        q.x = mod( q.x+l*float(q.z<0.) , 2.*l ) -l/2., \n        q.xz -= r * vec2( sin(A/2.),-sign(q.z)*cos(A/2.) ), \n        t = abs(length(q.xz) - r) -.01,\n        t = max(t, max(a.x-10.*l,a.y-10.) ) ,\n\n        p += .25*t*D;                                                  // step forward = dist to obj\n\n    O *= .5+.5*texture(iChannel0,vec2(.5+.05*( u + fract(atan(q.x,abs(q.z))/A) ) , v )); // material\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 186, 186, 1542]], "test": "untested"}
{"id": "sdKXzc", "name": "Fab24 #inktober2021 \"extinction\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nExtinction of light ( from left to right ) by an explicit (top) vs statistical (bottom) distribution of 1-pixel thick occluders.\nMouse.y controls density.", "tags": ["2d", "short", "inktober2021"], "likes": 7, "viewed": 271, "published": 3, "date": "1635079592", "time_retrieved": "2024-07-30T18:53:39.259744", "image_code": "#define H(p)     fract(sin(floor(p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define S        smoothstep(w+w,0., sqrt(l) )\n\nvoid mainImage(out vec4 O, vec2 u ) \n{\n    vec2  R = iResolution.xy;\n    float N = length(iMouse.xy)<10. ? 10.+8.*sin(iTime) : 20.*iMouse.y/R.y, \n          w = N/R.y,\n          l = 9.,v=1., y, d=l, x;\n    vec2  U = w* ( u+u - R ), D,P,\n          I = floor(U), F = fract(U)-.5;\n          \n    O-=O;\n    if (U.y<0.) {                                  // --- extinction by statistical distribution\n        O.r += pow( 1. - 3.14*w, U.x+w*R.x ); \n        O = sqrt(O);                               // to sRGB\n        return; \n    }                                              // ---  extinction by explicit extinction\n    \n    for( int k = 0; k < 9; k++ )                   // draw the random occluders\n        D = vec2( k%3, k/3 )-1.,\n        P = F - D - H(I+D),\n        l = min(l, dot(P,P)),\n        P.x > 0. ? d = min(d, P.y*P.y): y;    \n    O += S;\n    \n    l = 9.;    \n    for( x = -w*R.x; x < floor(U.x); x++ ) {       // compute ray energy decay from left to pos\n        l = 9.;\n        I.x = floor(x);\n        for( int k = -1; k < 2; k++ )\n            D = vec2(0,k),\n            y = ( F - D - H(I+D) ).y,\n            l = min(l, y*y);\n \n         v *= 1.-S;\n    }\n    l = d; v *= 1.-S;                              // contribution of current cell\n    O.r += v;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 169, 169, 1395]], "test": "untested"}
{"id": "sdKSzc", "name": "Fab23 #inktober2021 \"leak\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera.", "tags": ["raymarching", "short", "inktober2021"], "likes": 13, "viewed": 327, "published": 3, "date": "1635074570", "time_retrieved": "2024-07-30T18:53:40.121440", "image_code": "\n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))                          // rotation\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    float t=9.,d, s;                                                   // s: hit object id \n    vec3  R = iResolution,\n          D = normalize(vec3((U+U-R.xy)/R.y, -3.)),                    // ray direction\n          p = 5./R, q,a,                                               // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(.3*iTime+vec3(0,11,0)); \n    vec4 r = O-O;\n    for ( O=vec4(1); O.x > 0. && t > .005; O-=.005 )          \n        q = p,\n        q.yz *= rot(.5-6.3*M.y), \n        q.xz *= rot(-6.3*M.x), \n        a = abs(q),\n        t = max( a.x -1.5, max(a.y-.5,a.z-1.) ),                       // sheets\n        t = s = max( t, abs( mod(q.y,.025) - .012 ) ),\n        t = min( t, max( max( a.x -1.5, max(abs(a.y-.5)-.02,a.z-1.05) ), // cover\n                         -length(vec2(q.z+1.,a.y-.53))+.03 )),         // furrow\n        t = min( t, max( max( length(q.zy+vec2(.2,0))-1., -length( q.zy+vec2(.15,0))+1.), // back\n                          max( a.x -1.5, max(a.y-.5,q.z-1.) ))),\n        t = min(t, d = max(-q.z+1.2, length(q.xy/vec2(5,.5)))+.1 ), \n        r += exp( -40.*d*d ) * hue(q.x*.7+.35),                        // rainbow leak\n     // d < m ? m = d, z = q.x : z,\n        p += .25*t*D;                                                  // step forward = dist to obj\n        \n                                                                       // --- materials\n    if ( t!=s ) O *= vec4(.7,.6,.6,1);                                 // cover\n    O += .4*sqrt(r); // * hue(z*.7+.35);                               // rainbow leak (in sRGB )\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 187, 187, 1807]], "test": "untested"}
{"id": "sdVSRc", "name": "Falling Sand Simulation", "author": "fad", "description": "sand: click + drag: \nwall: left shift + click + drag:\nerase: space + click + drag:\n\nchange scale and brush radius in common tab\n\ntheres a bug where sometimes sand duplicates itself :)", "tags": ["simulation", "falling", "sand"], "likes": 24, "viewed": 1469, "published": 3, "date": "1635070510", "time_retrieved": "2024-07-30T18:53:40.898362", "image_code": "float rand_n(float r, int n)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        r = fract(r * 100.0);\n    }\n    \n    return r;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord / scale);\n    Particle self = particle_at(coord);\n    \n    switch (self.type)\n    {\n        case SAND:\n        {\n            frag_color = vec4(\n                mix(0.9, 1.0, rand_n(self.shade, 1)), \n                mix(0.75, 0.8, rand_n(self.shade, 2)),\n                mix(0.5, 0.6, rand_n(self.shade, 3)), 1.0) * mix(0.7, 1.0, self.shade);\n            return;\n        } break;\n        \n        case WALL:\n        {\n            frag_color = vec4(\n                mix(0.3, 0.4, rand_n(self.shade, 1)), \n                mix(0.3, 0.4, rand_n(self.shade, 2)),\n                mix(0.3, 0.4, rand_n(self.shade, 3)), 1.0) * mix(0.7, 1.0, self.shade);\n            return;\n        } break;\n        \n        case AIR:\n        {\n            frag_color = vec4(0.6, 0.8, 1.0, 1.0);\n            return;\n        }\n    }\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// SETTINGS\nconst float scale        = 5.0;\nconst float brush_radius = 2.0;\n\n// COMMON\n#ifndef HW_PERFORMANCE\nuniform vec3      iResolution;\nuniform sampler2D iChannel0;\nuniform float     iTime;\nuniform int       iFrame;\n#endif\n\nint seed;\n\nfloat rand()\n{\n    int n = (seed++ << 13) ^ seed;\n    return float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483647.0;\n}\n\n#define INIT_SEED() \\\n    seed = int(iTime * frag_coord.x + frag_coord.y * iResolution.x); \\\n    seed = int(rand() * 2147483647.0) + iFrame;\n\nconst int AIR  = 0;\nconst int SAND = 1;\nconst int WALL = 2;\n\nstruct Particle\n{\n    int   type;\n    bool  has_moved_this_frame;\n    float shade;\n};\n\n#define IN_BOUNDS(coord) (0 <= (coord).x && (coord).x < int(iResolution.x / scale) && 0 <= (coord).y && (coord).y < int(iResolution.y / scale))\n#define NOT_IN_BOUNDS(coord) ((coord.x) < 0 || int(iResolution.x / scale) <= (coord.x) || (coord.y) < 0 || int(iResolution.y / scale) <= (coord.y))\n\n\nParticle particle_at(ivec2 coord)\n{\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return Particle(WALL, false, 0.0);\n    }\n    \n    vec4 data = texelFetch(iChannel0, coord, 0);\n    return Particle(\n        int(data.x),\n        bool(data.y),\n        data.z\n    );\n}\n\nvec4 to_vec4(Particle particle)\n{\n    return vec4(\n        float(particle.type),\n        float(particle.has_moved_this_frame),\n        particle.shade,\n        0.0\n    );\n}", "buffer_a_code": "float distance_to_line(vec2 a, vec2 b, vec2 p)\n{\n    // from iq: https://www.youtube.com/watch?v=PMltMdi1Wzg\n    float h = clamp(dot(p - a, b - a) / dot(b - a, b - a), 0.0, 1.0);\n    return length(p - mix(a, b, h));\n}\n\nconst float KEY_SPACE = 32.0;\nconst float KEY_LEFT_SHIFT = 16.0;\n\n\nbool key_pressed(float key_code)\n{\n    return texture(iChannel2, vec2((key_code + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord);\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return;\n    }\n    \n    INIT_SEED();\n    \n    vec4 pMouse = texelFetch(iChannel1, ivec2(0, 0), 0);\n    \n    if (pMouse.z > 0.0)\n    {\n        if (iMouse.z > 0.0 && distance_to_line(pMouse.xy / scale, iMouse.xy / scale, vec2(coord)) < brush_radius)\n        {\n            frag_color = to_vec4(Particle(\n                (key_pressed(KEY_SPACE) ? AIR : key_pressed(KEY_LEFT_SHIFT) ? WALL : SAND), \n                true, mix(0.7, 1.0, rand())\n            ));\n            return;\n        }\n    }\n    else\n    {\n        if (iMouse.z > 0.0 && distance(vec2(coord), iMouse.xy / scale) < brush_radius)\n        {\n            frag_color = to_vec4(Particle(\n                (key_pressed(KEY_SPACE) ? AIR : key_pressed(KEY_LEFT_SHIFT) ? WALL : SAND), \n                true, mix(0.7, 1.0, rand())\n            ));\n            return;\n        }\n    }\n    \n    Particle self = particle_at(coord);\n    \n    switch (self.type)\n    {\n        case SAND:\n        {\n            Particle below = particle_at(coord + ivec2(0, -1));\n            \n            if (below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n        } break;\n        \n        case AIR:\n        {\n            Particle above = particle_at(coord + ivec2(0, 1));\n            \n            if (above.type == SAND)\n            {\n                above.has_moved_this_frame = true;\n                frag_color = to_vec4(above);\n                return;\n            }\n        } break;\n    }\n    \n    frag_color = to_vec4(Particle(self.type, false, self.shade));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord);\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return;\n    }\n    \n    Particle self = particle_at(coord);\n    \n    if (self.has_moved_this_frame)\n    {\n        frag_color = to_vec4(self);\n        return;\n    }\n    \n    INIT_SEED();\n    \n    int dir = int(rand() < 0.5) * 2 - 1;\n    \n    switch (self.type)\n    {\n        case SAND:\n        {\n            Particle below = particle_at(coord + ivec2(dir, -1));\n            \n            if (!below.has_moved_this_frame && below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n        } break;\n        \n        case AIR:\n        {\n            Particle above = particle_at(coord + ivec2(-dir, 1));\n            \n            if (!above.has_moved_this_frame && above.type == SAND)\n            {\n                above.has_moved_this_frame = true;\n                frag_color = to_vec4(above);\n                return;\n            }\n        } break;\n    }\n    \n    frag_color = to_vec4(self);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    ivec2 coord = ivec2(frag_coord);\n    if (NOT_IN_BOUNDS(coord))\n    {\n        return;\n    }\n    \n    Particle self = particle_at(coord);\n    \n    if (self.has_moved_this_frame)\n    {\n        frag_color = to_vec4(self);\n        return;\n    }\n    \n    INIT_SEED();\n    rand();\n    \n    int dir = int(rand() >= 0.5) * 2 - 1;\n    \n    switch (self.type)\n    {\n        case SAND:\n        {\n            Particle below = particle_at(coord + ivec2(dir, -1));\n            \n            if (!below.has_moved_this_frame && below.type == AIR)\n            {\n                frag_color = to_vec4(Particle(AIR, true, 0.0));\n                return;\n            }\n        } break;\n        \n        case AIR:\n        {\n            Particle above = particle_at(coord + ivec2(-dir, 1));\n            \n            if (!above.has_moved_this_frame && above.type == SAND)\n            {\n                above.has_moved_this_frame = true;\n                frag_color = to_vec4(above);\n                return;\n            }\n        } break;\n    }\n    \n    frag_color = to_vec4(self);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    if (frag_coord == vec2(0.5, 0.5))\n    {\n        frag_color = iMouse;\n    }\n    else\n    {\n        frag_color = vec4(0.0);\n    }\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVSRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 125], [127, 127, 184, 184, 1027]], "test": "untested"}
{"id": "NdVSDR", "name": "入门之路-3", "author": "jialouluo", "description": "切换图片小案例", "tags": [], "likes": 4, "viewed": 216, "published": 3, "date": "1635066748", "time_retrieved": "2024-07-30T18:53:41.763050", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       //非常简洁的一个图片切换小案例\n   vec2 uv =  fragCoord/ iResolution.xy;\n\t\t\tfloat x = 0.8;\n            x = abs(cos(iTime));\n\t\t\tx = smoothstep(.0,1.0,(x*2.0+uv.y-1.0));\n\t\t\tvec4 f = mix(\n\t\t\t\ttexture(iChannel0, (uv)*(1.-x)),\n\t\t\t\ttexture(iChannel1, (uv)*x), \n\t\t\t\tx);\n            //vec4 f2 = vec4(0.0,1.0,1.0,1.0) * x;\n\t\t\tfragColor = f;\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 109, 411]], "test": "untested"}
{"id": "7sKXRc", "name": "入门之路-6", "author": "jialouluo", "description": "noise+mix\n", "tags": [], "likes": 3, "viewed": 207, "published": 3, "date": "1635066674", "time_retrieved": "2024-07-30T18:53:42.532992", "image_code": "vec2 random(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat snoise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\nfloat Model(vec2 st,float N){\n    st = st*2.-1.;\n    float a = atan(st.x,st.y)+3.14;\n    float r = 6.28/N;\n    return abs(cos(floor(.5+a/r)*r-a)*length(st));\n}\nfloat getModel(vec2 st,vec2 size){\n    return Model(st*size,4.);\n}\nfloat createModel(in vec2 st,in float num[4]){\n    float exy =4.;\n    float exx =2.;\n    st*=vec2(exx,exy);\n    vec2 fi = fract(st);\n    vec2 df = floor(st);\n    fi.x = mix(fi.x,1.-fi.x,step(1.0,df.x));\n    return mix(getModel(fi,vec2(0.83,1.)),getModel(fi - vec2(0.03,0.),vec2(1.0)),num[int(df.y)]);\n}\nfloat getWork(vec2 st,float t){\n    float exy =4.;\n    float exx =2.;\n    float num[4];\n    float j = floor(mod(t,pow(2.,exy)));\n    for(int i=0;i<4;i++){\n        num[i] =0.0;\n        num[i] = step(1.0,mod(j,2.));\n        j = ceil(j/2.);\n    }\n    return createModel(st,num);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//和五同样的方法 只是将c的值进行筛选\n    vec2 vUv = fragCoord/iResolution.xy;\n    vUv*=3.;\n    vec2 uv = fract(vUv);\n  //  uv.x*=iResolution.x/iResolution.y;\n    float t = iTime*0.3;//速度\n    float c = mix(getWork(uv,t+floor(vUv.x) +floor(vUv.y) ),getWork(uv,t+floor(vUv.x) +floor(vUv.y) + 1.0),fract(t));\n    c += snoise(uv*7.)*0.08;\n    float angle = atan(uv.y,uv.x);\n    vec3 color = (0.5 + 0.5*cos(6.28*(angle/6.28 +vec3(0.6,0.7,0.9)) ))*step(c,0.77);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 207], [208, 208, 230, 247, 809], [810, 810, 839, 839, 969], [970, 970, 1004, 1004, 1036], [1037, 1037, 1083, 1083, 1339], [1340, 1340, 1371, 1371, 1617], [1618, 1618, 1675, 1728, 2209]], "test": "untested"}
{"id": "ssVSRc", "name": "入门之路-5", "author": "jialouluo", "description": "noise + mix", "tags": [], "likes": 1, "viewed": 192, "published": 3, "date": "1635065707", "time_retrieved": "2024-07-30T18:53:43.564235", "image_code": "vec2 random(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat snoise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\nfloat Model(vec2 st,float N){\n    st = st*2.-1.;\n    float a = atan(st.x,st.y)+3.14;\n    float r = 6.28/N;\n    return abs(cos(floor(.5+a/r)*r-a)*length(st));\n}\nfloat getModel(vec2 st,vec2 size){\n    return Model(st*size,4.);\n}\nfloat createModel(in vec2 st,in float num[4]){\n    float exy =4.;\n    float exx =2.;\n    st*=vec2(exx,exy);\n    vec2 fi = fract(st);\n    vec2 df = floor(st);\n    fi.x = mix(fi.x,1.-fi.x,step(1.0,df.x));\n    return mix(getModel(fi,vec2(0.83,1.)),getModel(fi - vec2(0.03,0.),vec2(1.0)),num[int(df.y)]);\n}\nfloat getWork(vec2 st,float t){\n    float exy =4.;\n    float exx =2.;\n    float num[4];\n    float j = floor(mod(t,pow(2.,exy)));\n    for(int i=0;i<4;i++){\n        num[i] =0.0;\n        num[i] = step(1.0,mod(j,2.));\n        j = ceil(j/2.);\n    }\n    return createModel(st,num);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 vUv = fragCoord/iResolution.xy;\n    vec2 uv = fract(vUv);\n  //  uv.x*=iResolution.x/iResolution.y;\n    float t = iTime;\n    float c = mix(getWork(uv,t),getWork(uv,t + 1.0),fract(t));\n    c += snoise(uv*7.)*0.08;\n    float angle = atan(uv.y,uv.x);\n    vec3 color = (0.5 + 0.5*cos(6.28*(angle/6.28 +vec3(0.3,0.6,0.9)) ))*c;\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVSRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 207], [208, 208, 230, 247, 809], [810, 810, 839, 839, 969], [970, 970, 1004, 1004, 1036], [1037, 1037, 1083, 1083, 1339], [1340, 1340, 1371, 1371, 1617], [1618, 1618, 1675, 1675, 2066]], "test": "untested"}
{"id": "fdGXR3", "name": "1_1_lerpTriple", "author": "tomoe", "description": "sample code", "tags": ["ch1"], "likes": 0, "viewed": 237, "published": 3, "date": "1635055814", "time_retrieved": "2024-07-30T18:53:44.623403", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec3[3] col3 = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 1.0),\n        vec3(0.0, 1.0, 0.0)\n        );\n    pos.x *= 2.0;\n    int ind = int(pos.x);\n    vec3 col = mix(col3[ind], col3[(ind + 1) % 3], fract(pos.x));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NdySR3", "name": "1_0_lerp", "author": "tomoe", "description": "A sample code for the book.", "tags": ["ch1"], "likes": 0, "viewed": 188, "published": 3, "date": "1635055743", "time_retrieved": "2024-07-30T18:53:45.518011", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec3 RED = vec3(1.0, 0.0, 0.0);\n    vec3 BLUE = vec3(0.0, 0.0, 1.0);\n    vec3 col = mix(RED, BLUE, pos.x);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdySR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 248]], "test": "untested"}
{"id": "sdKSzV", "name": "Golfed SmoothLifeL (455 chars)", "author": "Flyguy", "description": "Golfed version of SmoothLifeL (https://youtu.be/KJe9H6qS82I).\nUses a simpler threshold based transfer function which produces effectively the same result.", "tags": ["organic", "life", "small", "golf", "smoothlife"], "likes": 12, "viewed": 453, "published": 3, "date": "1635041909", "time_retrieved": "2024-07-30T18:53:47.554566", "image_code": "void mainImage( out vec4 c, vec2 p ){\n\tc = texelFetch(iChannel0, ivec2(p), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Sample pixel y value at location v\n#define S(v) texelFetch(iChannel0, ivec2(v),0)\n\nfloat N = 12.; //Neighborhood size\n\nvoid mainImage( out vec4 c, vec2 p ){\n    vec2 a, //Total kernel area (x = neighborhood, y = cell)\n         k, //Neighborhood/cell kernel mask\n         o, //Sample offset\n         f; //Neighborhood/cell fill\n    \n    //Sample pixels in neighborhood/cell\n    for(o.y = -N; o.y++ <= N;){                        \n        for(o.x = -N; o.x++ <= N;){\n            k = step(length(o), vec2(N, N/3.));        //Kernel bounds\n            k.x -= k.y;                                //Neighborhood excludes cell\n            a += k;                                    //Add up kernel area\n            f += k * S(mod(p + o, iResolution.xy)).x;    //Add up neighborhood/cell fill\n        }\n    }\n    \n    f /= a; // Normalize fill to 0-1.\n    \n    //Life rule & euler integration\n    c = clamp(\n    S(p) + .1 * float(          //Time step .1 x 0.5 i.e. how fast a cell heals/degrades per frame\n        f.y < .5 ?              //Select birth/survival threshold if cell fill > 0.5\n        f.x > .26 && f.x < .34: //Dead cell is \"born\" if neighborhood fill >.26 and <.34\n        f.x > .37 && f.x < .55  //Live cell survives if neighborhood fill >.37 and <.55\n    ) - .05 //0.5 x Time step\n    + step(length(iMouse.xy - p), N)                           //Mouse drawing\n    + (iFrame < 2 ? texture(iChannel1, p/1e3, 0.).x-.5 : 0.)   //Initial conditions\n    , 0., 1.);                                                 //Clamp cell value between 0-1.\n}\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 80]], "test": "untested"}
{"id": "fsKXz3", "name": "Rolling Shutter Effect Animation", "author": "oneshade", "description": "[url=https://en.wikipedia.org/wiki/Rolling_shutter]https://en.wikipedia.org/wiki/Rolling_shutter[/url]", "tags": ["effect", "animation", "rollingshutter"], "likes": 12, "viewed": 145, "published": 3, "date": "1635033585", "time_retrieved": "2024-07-30T18:53:48.448176", "image_code": "// Try uncommenting for a speedy version\n//#define SPEED_ANIM\n\nfloat anim(in vec2 uv, in float time) {\n    float dist = length(uv) - 0.4 * sin(mod(5.0 * atan(uv.y, uv.x) + 500.0 * time, 6.28));\n    return smoothstep(fwidth(dist), 0.0, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float scan = fragCoord.y / iResolution.y;\n    float time = 0.01 * iTime;\n    float frameDur = 0.02; // To exaggerate effect\n\n    #ifdef SPEED_ANIM\n    time = iTime;\n    frameDur = 0.025; // Change to 0.0255 and it appears to go in reverse :D\n    #endif\n\n    float localTime = time / frameDur;\n    float sec = floor(localTime), fracSec = fract(localTime);\n\n    // Capture animation with delay between scanlines\n    vec3 color = vec3(anim(uv, (sec - 1.0 + scan) * frameDur)); // Previous frame\n    if (scan < fracSec) color = vec3(anim(uv, (sec + scan) * frameDur));\n    color.g = max(color.g, 0.5 * anim(uv, time)); // Actual animation in green\n\n    // Scanline\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(2.0 / iResolution.y, 0.0, abs(scan - fracSec)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 102, 102, 243], [245, 245, 300, 300, 1172]], "test": "untested"}
{"id": "fdKSz3", "name": "Twizzly Octopus", "author": "SnoopethDuckDuck", "description": "This ones a bit trippy", "tags": ["raymarching", "template", "artofcode"], "likes": 3, "viewed": 284, "published": 3, "date": "1635028925", "time_retrieved": "2024-07-30T18:53:49.307878", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = length(p) - 2.;\n    vec3 n = vec3(cos(iTime), 1., sin(iTime));\n    //d = max(d, dot(p,n));\n    float a = atan(p.z ,p.x);\n    \n    float sd = length(p) + cos(5. * length(p.x) + cos(2. * length(p.xz) * p.y+iTime))- 2.;\n    \n    p.y += cos(4. * length(p) + 1. * p.y + iTime);\n    \n    float pd = abs(dot(p,n)) - 0.5;\n    \n   \n    \n    return 0.15 *  max(pd, sd); \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    vec3 col = mix(vec3(1.),vec3(0.),0.99 + 0.01 * rd.y);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(5.2 * tanh(0.4 * iTime) * cos(0.25 * iTime),cos(0.9 * iTime),5.2 * tanh(0.4 * iTime) * sin(0.25 * iTime));//vec3(5. * cos(0.5 * iTime), cos(1. * iTime) * 0., 5. * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float d2 = RayMarch(p, rd);\n        vec3 p2 = p + rd * (2. + d2);\n        vec3 n2 = GetNormal(p2);\n        vec3 r2 = reflect(rd, n2);\n        vec3 rf2 = refract(rd, n2, 0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float dif2 = dot(n2, normalize(vec3(1,2,3)))*.5+.5;\n       // col += 0.1 * vec3(dif2);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.5 * texture(iChannel0,r / (0.5 + n)).rgb;\n       // col += 0.5 * texture(iChannel0,r / (0.5 + n2)).rgb;\n        \n        col.r += .15 * cos(3. * rf.x + 2. * iTime - 3.1415 / 2.);\n        col.g += .15 * cos(3. * rf.y + 2.1 * iTime);\n        col.b += .15 * cos(3. * rf.z + 2.2 * iTime + 3.1415 / 2.);\n        \n        float a = atan(p.z, p.x);\n        float f = .5 + .5 * sin(0. * a + 10. * length(p));\n        col *= f;\n       \n    } else {\n        col = Bg(rd);\n       // col *= texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKSz3.jpg", "access": "api", "license": "mit", "functions": [[1474, 1474, 1493, 1493, 1555], [1558, 1558, 1587, 1587, 1807], [1810, 1810, 1833, 1833, 2210], [2212, 2212, 2246, 2246, 2457], [2459, 2459, 2483, 2483, 2673], [2675, 2675, 2725, 2725, 2916], [2918, 2918, 2936, 2936, 3012], [3015, 3015, 3072, 3072, 4847]], "test": "untested"}
{"id": "7syXRc", "name": "HOLHO Twist", "author": "shau", "description": "Another HOLHO 4 animation. https://holhocollection.com", "tags": ["holho"], "likes": 10, "viewed": 454, "published": 3, "date": "1635023594", "time_retrieved": "2024-07-30T18:53:50.186529", "image_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n * Simple animation for a HOLHO viewer \n * Official HOLHO 4 viewer used to test this animation\n * https://holhocollection.com\n * Tested on official iPhone Shadertoy App using High Quality settings\n * Adjust BOXWIDTH to suite your device\n * Make your own HOLHO viewer \n * https://www.youtube.com/watch?v=Xhu-XjXa4p4\n */\n\n//THIS BUFFER TRANSLATES OUTPUT OF BUFFERS TO 4 VIEWS\n//Most examples I have seen use a single scene projected onto 4 faces of viewer\n//Set USE_PROJECTION to 1 in common to use individual (front,right,rear,left) \n//projected views onto each face of viewer\n\nvec3 renderBox(sampler2D tx, vec2 uv, ivec2 u)\n{\n    if (uv.y>0.0 && abs(uv.x)<uv.y)\n    {\n        return texelFetch(tx,u,0).xyz; \n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0);\n    ivec2 iU = ivec2(U),\n          imageBox = imageDimensions(R);\n    vec2 uv = (U - R*.5) / R.y;\n    \n    \n    //TOP BOX\n    ivec4 box = ivec4(int(R.x)/2-imageBox.x/2,\n                      int(R.x)/2+imageBox.x/2, \n                      int(R.y)/2,\n                      int(R.y)/2+imageBox.y);\n    #if USE_PROJECTIONS==1 \n    //projected rear view\n    col += renderBox(iChannel2,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #endif\n    \n    //RIGHT BOX\n    box = ivec4(int(R.x)/2,\n                int(R.x)/2+imageBox.y, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected right view\n    col += renderBox(iChannel1,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #endif\n    \n    //BOTTOM BOX\n    box = ivec4(int(R.x)/2-imageBox.x/2,\n                int(R.x)/2+imageBox.x/2, \n                int(R.y)/2-imageBox.y,\n                int(R.y)/2);\n    //default front view - also default projection\n    col += renderBox(iChannel0,\n                     vec2(uv.x,-uv.y),\n                     ivec2(box.y-iU.x,\n                           box.w-iU.y));\n    \n    //LEFT BOX                        \n    box = ivec4(int(R.x)/2-imageBox.y,\n                int(R.x)/2, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected left view\n    col += renderBox(iChannel3,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #endif\n\n    //debug buffer output\n    //col = texture(iChannel3,U/R).xyz;\n\n    C = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-------\n\n#define PI 3.141592\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 100.0\n#define FL 2.6\n\n#define LA vec3(0,-3,0.0)\n#define RO vec3(0,3,4.5)\n\n//0 PROJECT FRONT ONTO ALL FACES  \n//1 PROJECT FRONT, REAR, LEFT, RIGHT ONTO EACH FACE  \n#define USE_PROJECTIONS 1\n//PREFERED WIDTH OF RENDERING\n#define BOXWIDTH 1300\n\n//RAYMARCHING AND SHADER IN COMMON TO HANDLE CASES THAT NEED\n//MULTIPLE CAMERA ANGLES (ALSO MULTIPLE BUFFERS)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n/* MODEL START */\n\n//SDF functions IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 6.283185/repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nfloat map(vec3 p, float T) \n{\n    vec3 q = p;\n    q.y -= T;\n    q.xz *= rot((q.y*2.0+sin(T*0.7)*2.1)*0.1);\n    pModPolar(q.xz,3.0);\n    q.yz = mod(q.yz,0.4)-0.2;\n    return length(q-vec3(2,0,0));\n}\n\n/* MODEL END */\n\n\nvec3 march(vec3 ro, vec3 rd, float T)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i=0; i<100; i++)\n    {\n        vec3 p = ro+rd*t;\n        float ns = map(p,T);\n        \n        col += rotHue(vec3(1.0,0.5,0.2),p.y*0.3-sin(T*1.3)*2.9)*0.2/(1.0+ns*ns*100.0);\n\n        t += ns;\n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    return col;\n}\n\nivec2 imageDimensions(vec2 r)\n{\n    int a = min(BOXWIDTH,min(int(r.x),int(r.y)));\n    return ivec2(a,a/2);\n}\n\nvec3 camera(vec2 U, vec2 r, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - r*.5) / r.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}", "buffer_a_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER FRONT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    ro.xz *= rot(iTime*-0.2);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER RIGHT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    #if USE_PROJECTIONS==1      \n    ro.xz *= rot(iTime*-0.2+PI*0.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    #endif\n    C = vec4(col,1.0);\n}", "buffer_b_inputs": [], "buffer_c_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER REAR VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    #if USE_PROJECTIONS==1     \n    ro.xz *= rot(iTime*-0.2+PI);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    #endif\n    C = vec4(col,1.0);\n}", "buffer_c_inputs": [], "buffer_d_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER LEFT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    #if USE_PROJECTIONS==1\n    ro.xz *= rot(iTime*-0.2+PI*1.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    #endif\n    C = vec4(col,1.0);\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXRc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[750, 750, 798, 798, 910], [912, 912, 950, 950, 3287]], "test": "untested"}
{"id": "sdVXRV", "name": "Super-Neumorphism", "author": "theschwa", "description": "My attempt to recreate Martin Naumann's \"Super-Neumorphism\" https://www.behance.net/gallery/108751509/Super-Neumorphism", "tags": ["noise", "rgb", "reproduction"], "likes": 17, "viewed": 439, "published": 3, "date": "1635017970", "time_retrieved": "2024-07-30T18:53:51.094102", "image_code": "/*\n\nMy attempt to recreate Martin Naumann's \"Super-Neumorphism\" https://www.behance.net/gallery/108751509/Super-Neumorphism\n\nBy: theschwa\n\n*/\n\n# define PI 3.141592653589\n# define TAU (2. * PI)\n\n// Noise by IQ: https://www.shadertoy.com/view/XdXBRH\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nfloat noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 0\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va  + u.x*(vb-va) \n               + u.y*(vc-va) \n               + u.x*u.y*(va-vb-vc+vd);\n}\n\nvec3 colorNoise ( vec2 uv ) {\n    vec3 col = vec3(0., 0., 0.);\n    col.x = noised( uv );\n    col.y = noised( uv + vec2(10., 13.) );\n    col.z = noised( uv + vec2(-17., -15.) );\n    \n    // Map to [0, 1]\n    col = .5 + .5*col;\n    \n    // Contrast\n    col = (col - .5) * 2. + .5;\n    \n    return col;\n}\n\nfloat radialmap( vec2 P ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = P;\n    \n    //uv *= 2.;\n    float l = length( uv );\n    //float d = cos( l / .2 ) ;\n    \n    float d = pow( cos( 3.141 * l / 2. ), 0.5);\n    \n    // Make it go to 0 outside the circle\n    //d *= step(-1., -l);\n    \n    //d = 1. - pow( abs( l ), 3.5 );\n    \n    d = clamp( d, 0.001, 1.);\n    \n    return d;\n    \n}\n\nvec3 upscale_by_grad( vec2 uv ) {\n    float scale = 2.*abs(iTime/20. - floor(iTime/20. + .5) )*1.;\n    //scale = 1.;\n    float radmap = radialmap( uv );\n    \n    // Invert the radial map\n    uv *= scale * (1. - radmap);\n    \n    vec3 col = colorNoise( uv - vec2( cos( iTime * .23 ), sin( iTime * .15 ) ) );\n    return col;\n}\n\n\nvec3 unpolarize( vec2 uv ) {\n    float r = 1.;\n    \n    vec2 rec;\n    \n    rec.x = uv.y * cos( uv.x * TAU ) * r;\n    rec.y = uv.y * sin( uv.x * TAU ) * r;\n    \n \n    return upscale_by_grad(rec);\n}\n\n\nvec3 mirror_shift( vec2 uv ) {\n    vec3 col = vec3( 0. );\n    \n\n    if( uv.y < .5 ) {\n        uv.y += .5;\n        uv.x = (1. - uv.x);\n        col = unpolarize( uv );\n    } else { \n        uv.y -= .5;\n        uv.y = (1. - uv.y);\n        col = unpolarize( uv );\n    }\n    \n    return col;\n}\n\n\nvec3 polarize( vec2 rec ) {\n    vec2 pol;\n    \n    pol.y = length( rec );\n    pol.x = atan( rec.y, rec.x) / TAU;\n    \n    return mirror_shift( pol );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec2 uv = st;\n    \n    vec3 col = vec3( 0. );\n    \n    \n    st -= vec2( .5 );\n    st *= 2.;\n    st.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    \n    col = upscale_by_grad( st );\n    col = unpolarize( st );\n    col = mirror_shift( st );\n    col = polarize( st );\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 248, 309, 309, 447], [450, 510, 537, 537, 1236], [1238, 1238, 1267, 1267, 1539], [1541, 1541, 1568, 1618, 1945], [1947, 1947, 1980, 1980, 2271], [2274, 2274, 2302, 2302, 2470], [2473, 2473, 2503, 2503, 2761], [2764, 2764, 2791, 2791, 2915], [2920, 2920, 2977, 3027, 3414]], "test": "untested"}
{"id": "7sKSzV", "name": "Soft Rainbows", "author": "theschwa", "description": "Playing with concepts from Martin Naumann's \"Super-Neumorphism\" https://www.behance.net/gallery/108751509/Super-Neumorphism", "tags": ["noise", "rgb"], "likes": 12, "viewed": 328, "published": 3, "date": "1635016175", "time_retrieved": "2024-07-30T18:53:51.953804", "image_code": "/*\n\nBy: theschwa\n\n*/\n\n# define PI 3.141592653589\n# define TAU (2. * PI)\n\n// Noise by IQ: https://www.shadertoy.com/view/XdXBRH\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nfloat noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 0\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va  + u.x*(vb-va) \n               + u.y*(vc-va) \n               + u.x*u.y*(va-vb-vc+vd);\n}\n\nvec3 colorNoise ( vec2 uv ) {\n    vec3 col = vec3(0., 0., 0.);\n    col.x = noised( uv );\n    col.y = noised( uv + vec2(10., 13.) );\n    col.z = noised( uv + vec2(-17., -15.) );\n    \n    // Map to [0, 1]\n    col = .5 + .5*col;\n    \n    // Contrast\n    col = (col - .5) * 2. + .5;\n    \n    return col;\n}\n\nfloat radialmap( vec2 P ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = P;\n    \n    //uv *= 2.;\n    float l = length( uv );\n    //float d = cos( l / .2 ) ;\n    \n    float d = pow( cos( 3.141 * l / 2. ), 0.5);\n    \n    // Make it go to 0 outside the circle\n    //d *= step(-1., -l);\n    \n    //d = 1. - pow( abs( l ), 3.5 );\n    \n    d = clamp( d, 0.001, 1.);\n    \n    return d;\n    \n}\n\nvec3 upscale_by_grad( vec2 uv ) {\n    float scale = 2.*abs(iTime/20. - floor(iTime/20. + .5) )*1.;\n    //scale = 1.;\n    float radmap = radialmap( uv );\n    \n    // Invert the radial map\n    uv *= scale * (1. - radmap);\n    \n    vec3 col = colorNoise( uv - vec2( cos( iTime * .23 ), sin( iTime * .15 ) ) );\n    return col;\n}\n\n\nvec3 unpolarize( vec2 uv ) {\n    float r = 1.;\n    \n    vec2 rec;\n    \n    rec.x = uv.y * cos( uv.x * TAU ) * r;\n    rec.y = uv.y * sin( uv.x * TAU ) * r;\n    \n \n    return upscale_by_grad(rec);\n}\n\n\nvec3 mirror_shift( vec2 uv ) {\n    vec3 col = vec3( 0. );\n    \n\n    if( uv.y < .5 ) {\n        uv.y += .5;\n        uv.x = (1. - uv.x);\n        col = unpolarize( uv );\n    } else { \n        uv.y -= .5;\n        uv.y = (1. - uv.y);\n        col = unpolarize( uv );\n    }\n    \n    return col;\n}\n\n\nvec3 polarize( vec2 rec ) {\n    vec2 pol;\n    \n    pol.y = length( rec );\n    pol.x = atan( rec.y, rec.x) / TAU;\n    \n    return mirror_shift( pol );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec2 uv = st;\n    \n    vec3 col = vec3( 0. );\n    \n    \n    st -= vec2( .5 );\n    st *= 2.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    \n    col = upscale_by_grad( st );\n    //col = unpolarize( st );\n    //col = mirror_shift( st );\n    //col = polarize( st );\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 127, 188, 188, 326], [329, 389, 416, 416, 1115], [1117, 1117, 1146, 1146, 1418], [1420, 1420, 1447, 1497, 1824], [1826, 1826, 1859, 1859, 2150], [2153, 2153, 2181, 2181, 2349], [2352, 2352, 2382, 2382, 2640], [2643, 2643, 2670, 2670, 2794], [2799, 2799, 2856, 2906, 3300]], "test": "untested"}
{"id": "ssGXRc", "name": "Twizzly \"Plane\" Intersection", "author": "SnoopethDuckDuck", "description": "Just messing around so messy code", "tags": ["raymarching", "template", "artofcode"], "likes": 7, "viewed": 303, "published": 3, "date": "1635009619", "time_retrieved": "2024-07-30T18:53:52.803532", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = length(p) - 2.;\n    vec3 n = vec3(cos(2. * iTime), 0.6 * cos(length(p.y) + 2.8 * iTime) / cos(0.7 * iTime), sin(2. * iTime));\n   // d = max(d, dot(p,n) / p.y);\n   float a = atan(p.z, p.x) / atan(p.y, p.x);\n    float d2 = 1.-abs(dot(cos(5. * length(p) - 0. * iTime) * p,n));\n    d =  max(d, d2);\n    \n    return 0.3 * d; // 0.05 looks cool (but laggier)\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    vec3 col = mix(vec3(1.),vec3(0.),0.99 + 0.01 * rd.y);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(5.2 * tanh(0.4 * iTime) * cos(0.25 * iTime),cos(0.9 * iTime),5.2 * tanh(0.4 * iTime) * sin(0.25 * iTime));//vec3(5. * cos(0.5 * iTime), cos(1. * iTime) * 0., 5. * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float d2 = RayMarch(p, rd);\n        vec3 p2 = p + rd * (2. + d2);\n        vec3 n2 = GetNormal(p2);\n        vec3 r2 = reflect(rd, n2);\n        vec3 rf2 = refract(rd, n2, 0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float dif2 = dot(n2, normalize(vec3(1,2,3)))*.5+.5;\n       // col += 0.1 * vec3(dif2);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.5 * texture(iChannel0,r / (0.5 + n)).rgb;\n        col += 0.5 * texture(iChannel0,r / (0.5 + n2)).rgb;\n        \n        col.r += .15 * cos(3. * rf.x + 2. * iTime - 3.1415 / 2.);\n        col.g += .15 * cos(3. * rf.y + 2.1 * iTime);\n        col.b += .15 * cos(3. * rf.z + 2.2 * iTime + 3.1415 / 2.);\n        \n        float a = atan(p.z, p.x);\n        float f = .5 + .5 * sin(0. * a + 10. * length(p));\n        col *= f;\n       \n    } else {\n        col = Bg(rd);\n       // col *= texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXRc.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1559, 1588, 1588, 1808], [1811, 1811, 1834, 1834, 2203], [2205, 2205, 2239, 2239, 2450], [2452, 2452, 2476, 2476, 2666], [2668, 2668, 2718, 2718, 2909], [2911, 2911, 2929, 2929, 3005], [3008, 3008, 3065, 3065, 4838]], "test": "untested"}
{"id": "fsGXzc", "name": "Curvature shader", "author": "iY0Yi", "description": "For SDF Sculptors!\nI've noticed the curvature is useful as a visual debug with complex SDF modelling.\nI've mostly just copied and pasted Evan's postprocess code.\n\"Screen Space Curvature Shader\" by Evan Wallace:\nhttp://madebyevan.com/shaders/curvature/", "tags": ["modeling", "debug", "curvature", "sculpting"], "likes": 47, "viewed": 1839, "published": 3, "date": "1635002927", "time_retrieved": "2024-07-30T18:53:53.575468", "image_code": "// \"Screen Space Curvature Shader\" by Evan Wallace:\n// http://madebyevan.com/shaders/curvature/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Change shading type\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n\n// Shoe Model from my shader.\n// \"A man from 'A LOST MEMORY'\" by iYOYi:\n// https://www.shadertoy.com/view/Ws3yW4\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MIN_DIST 0.001\n#define MAX_DIST 30.0\n#define ITERATION 100\n\n#define SHOW_ANIM 0\nvec3 ro = vec3(0), rd = vec3(0);\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per) {\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdBox(vec3 p,vec3 b) {\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b) {\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b) {\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpSubstraction(in float a,in float b) {\n    return max(-a, b);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r) {\n    vec2 u = max(vec2(r + b,r + -a), vec2(0));\n    return min(-r, max (b, -a)) + length(u);\n}\n\nvoid pElongate(inout float p, in float h ) {\n    p = p-clamp(p,-h,h);\n}\n\nfloat sdFoot(vec3 p) {\n\tfloat d = MAX_DIST;\n\tfloat bsd = length(p), bsr=0.2500;\n\tif (bsd > 2.*bsr) return bsd-bsr;\n    \n\tvec3 cpFoot = p;\n\t{\n\t\tvec3 q = cpFoot;\n#if SHOW_ANIM\n        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;\n#else\n        float patapata = -.3;\n#endif\n        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));\n        cpFoot=q;\n\t}\n\tvec3 cpFoot_Main = cpFoot;\n\tcpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);\n\tpElongate(cpFoot_Main.y, 0.0125);\n\t{\n\t\tvec3 q=cpFoot_Main;\n        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n        float ycl = smoothstep(.002,.2,q.y);\n        float zcl = 1.-smoothstep(-.2,.5,q.z);\n        float zcl2 = smoothstep(-.2,.0,q.z);\n        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.075*ycl*zcl*zcl2;\n        cpFoot_Main=q;\n\t}\n\n    // Shoe\n    float d1,d2;\n\td1 = sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214));\n\td1 = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d1, 0.1438);\n\td1 = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d1, 0.0100);\n    d1 = fOpSubstractionSmooth(dot(cpFoot_Main, vec3(0,1,0)) - .001, d1, 0.0080);\n\td1 = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d1);\n\td1 = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d1, 0.0100);\n\t\n\t// Shoe lace\n\td2 = sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d2);\n\t\n\treturn min(d1,d2);\n}\n\nfloat sdScene(vec3 p) {\n    return sdFoot(p);\n}\n\nfloat intersect() {\n    float d = MIN_DIST;\n\n    for (int i = 0; i < ITERATION; i++) {\n        vec3 p = ro + d * rd;\n        float res = sdScene(p);\n        res*=.5;\n        if (abs(res) < MIN_DIST)break;\n        d += res;\n        if (d >= MAX_DIST) return MAX_DIST;\n    }\n    if(d>MAX_DIST) return MAX_DIST;\n    return d;\n}\n\n// from iq's shader\nvec3 normal(vec3 p) {\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e);\n    }\n    return normalize(n);\n}\n\n// Camera localized normal\nvec3 campos, camup;\nvec3 localNormal(vec3 p) {\n    vec3 n = normal(p), ln;\n    vec3 side = cross(campos, camup);\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -rd));\n}\n\n// \"camera\": create camera vectors.\nvoid camera(vec2 uv) {\n    const float pY = .5;\n    const float cL = 10.;\n    const vec3 forcus = vec3(0,.08,-.137);\n    const float fov = .015;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,0,0);\n    pos.xz = vec2(sin(iTime*.6),cos(iTime*.6))*cL;\n    if(iMouse.z>.5)\n        pos = vec3(sin(iMouse.x/iResolution.x*TAU),sin(iMouse.y/iResolution.y*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcampos = cw, camup = cv;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    float hit = intersect();\n    vec3 p = ro + hit * rd;\n\n    vec3 n = localNormal(p);\n    float depth = distance(ro, p)/MAX_DIST;\n    \n    // I've mostly just copied and pasted Evan's code.\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Compute curvature\n\tvec3 dx = dFdx(n);\n\tvec3 dy = dFdy(n);\n\tvec3 xneg = n - dx;\n\tvec3 xpos = n + dx;\n\tvec3 yneg = n - dy;\n\tvec3 ypos = n + dy;\n\tfloat curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 2.0 / (depth*5.);\n\n\t// Compute surface properties\n    #if CURVATURE\n        vec3 light = vec3(0.0);\n        vec3 ambient = vec3(curvature + 0.5);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        float shininess = 0.0;\n    #elif METAL\n        float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\n        float shine = clamp(curvature * 5.0, 0.0, 1.0);\n        vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n        vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\n        vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\n        vec3(0.5, 0.4, 0.3), shine) - ambient;\n        vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\n        float shininess = 128.0;\n    #elif RED_WAX\n        float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\n        vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n        vec3 ambient = vec3(0.05, 0.015, 0.0);\n        vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\n        vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\n        float shininess = 32.0;\n    #endif\n    \n    // Compute final color\n    float cosAngle = dot(n, light);\n    fragColor.rgb = ambient +\n    diffuse * max(0.0, cosAngle) +\n    specular * pow(max(0.0, cosAngle), shininess);\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    \n    fragColor.rgb = pow(fragColor.rgb*1.5, vec3(.9));\n    if(depth>.9) fragColor.rgb = vec3(.125);\n\tfragColor.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[766, 766, 790, 790, 860], [862, 862, 882, 882, 954], [956, 956, 982, 982, 1318], [1320, 1320, 1347, 1347, 1518], [1520, 1707, 1726, 1726, 1764], [1766, 1766, 1803, 1803, 1883], [1885, 1885, 1926, 1926, 1980], [1982, 1982, 2030, 2030, 2213], [2215, 2215, 2243, 2243, 2324], [2326, 2326, 2365, 2365, 2387], [2389, 2389, 2426, 2426, 2452], [2454, 2454, 2501, 2501, 2592], [2594, 2594, 2640, 2640, 2665], [2667, 2667, 2722, 2722, 2816], [2818, 2818, 2862, 2862, 2889], [2891, 2891, 2913, 2913, 5177], [5179, 5179, 5202, 5202, 5226], [5228, 5228, 5247, 5247, 5552], [5554, 5574, 5595, 5693, 5890], [5939, 5939, 5965, 5965, 6095], [6097, 6133, 6155, 6155, 6877], [6879, 6879, 6934, 6934, 9028]], "test": "untested"}
{"id": "7sySz3", "name": "Chromaverb Spectral Resonance", "author": "xenn", "description": "Praise to all  anonymous code contributors, ancestors, gods etc...and thanks\ntry clicking and dragging around", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 6, "viewed": 338, "published": 3, "date": "1635002755", "time_retrieved": "2024-07-30T18:53:54.536897", "image_code": "// Fork of \"spectracircles\" by xenn. https://shadertoy.com/view/ss3SDf\n// 2021-10-12 20:59:12\n\n// Fork of \"spectracircle\" by xenn. https://shadertoy.com/view/sd3SDf\n// 2021-10-12 17:54:00\n\n// Fork of \"Sun Beam Flower\" by None. https://shadertoy.com/view/-1\n// 2021-10-12 17:24:46\n\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 0.0 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = min(col,color);\n                      color = max(col2,col);\n                      col2 = mix(col,color,col2);\n                     col2 = max(col,color) * color;\n                      \n                       \n      color = max(col,color) * color;\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (mix(col,col2,0.5)))*noise), 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*6.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb2(hsv), 0.1), hsv.y*0.075);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iFeedbackColorShiftZoom 0.05\n//#define iFeedbackColorShiftImpact 0.001\n#define iBlob1ColorPulseSpeed -0.03456\n#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n\n\n\n\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,0.200/iResolution.y),(150.0 +(150.*(sin(iTime / 11.0)))));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*0.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel1,uv)*vec4(diff)+vec4(spec)*vec4(spec)+vec4(spec);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = -.001;\nconst float iFeedbackFadeRate         = .999;\n//const float iFeedbackColorShiftZoom   = .05;\nconst float iFeedbackColorShiftImpact = 0.001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 0.75;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .69;\nconst float iBlob1PowFactor           = 20.;\n//const float iBlob1ColorPulseSpeed     = .04;\nconst float iBlob2Radius              = .56;\nconst float iBlob2PowFactor           = 20.;\n//const float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = .25;\nconst float iFeedbackMouseShiftFactor = .01;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 blend = mix(col,col2,0.975);\n  \n // fragColor=blend*((blend * (col*0.95)) * 0.50)+(blend*0.75),(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n// fragColor=blend*((blend * (blend - col*0.095)) * 0.050)+(blend*0.95),(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n\n fragColor=blend*(blend  * 1.50)+(blend*0.5),(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//   fragColor=blend,texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sySz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 373, 373, 452], [454, 454, 477, 477, 617], [619, 619, 676, 676, 2033]], "test": "untested"}
{"id": "7dGSR3", "name": "1D SAT + scanline bokeh", "author": "paniq", "description": "faster bokehs in O(r), hexagonal-shaped and simple anamorphic bokehs also supported", "tags": ["blur", "bokeh", "kernel", "sat"], "likes": 36, "viewed": 1157, "published": 3, "date": "1635000881", "time_retrieved": "2024-07-30T18:53:55.311825", "image_code": "\nconst float tau = 6.283185;\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec2 pw = 1.0 / iChannelResolution[0].xy;\n    vec2 uv = fragCoord * pw;\n    vec2 rb = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);    \n    vec2 R = vec2(0.5,1.0)*exp(mix(log(3.0), log(64.0),cos(-rb.y*0.15*tau - 0.8 + iTime)*0.5 + 0.5));\n    vec4 c = vec4(0.0);\n    int IRy = int(R.y);\n    vec2 rd = vec2(R.x*R.x, 1.0/(R.y*R.y));\n    float cw = 0.0;\n    for (int i = -IRy; i <= IRy; ++i) {\n        float fi = float(i);\n#if (BOKEH == 1)\n        float w = 0.866025*min(1.0, (1.0 - abs(fi/R.y)) / 0.5)*R.y;\n#elif (BOKEH == 2)\n        float x = -fi/R.y;\n        float f1 = sin(radians(54.0))*(1.0 - x) / cos(radians(54.0));\n        float f2 = sin(radians(162.0))*(-2.618 - x) / cos(radians(162.0));\n        float f3 = step(cos(radians(144.0)),x);\n        float w = min(f1,f2)*R.y*f3;\n#else\n        float w = (1.0 - rd.y*fi*fi) * rd.x;\n        w = sqrt(w);\n#endif\n        float owl = max(0.0, w - fragCoord.x);\n        float owr = max(0.0, fragCoord.x - iChannelResolution[0].x + w);\n        // subtract the missing pixels at the border from the weight\n        cw += 2.0 * w - owl - owr;\n        w *= pw.x;\n        float y = uv.y + pw.y * fi;\n        vec4 p0 = texture(iChannel0, vec2(uv.x - w, y));\n        vec4 p1 = texture(iChannel0, vec2(uv.x + w, y));\n        c += (p1 - p0);\n    }\n#ifdef FAKE_LINEAR_LIGHT\n    float exposure = 1.0;\n#ifdef LONDON\n    exposure = 0.7;\n#endif\n    fragColor = vec4(pow(ACESFitted((c.rgb / cw + 0.5) * exposure), vec3(1.0/2.2)),1.0);\n#else\n    fragColor = c / cw + 0.5;\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame;\n    if (frame < 60) { // input; we give it a second so the viewer has a chance to change to fullscreen ;)\n        vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n#ifdef LONDON\n        fragColor = texture(iChannel2, (uv*0.5*vec2(1.0, 16.0/9.0))*0.5 + 0.5);\n#else\n        fragColor = texture(iChannel1, (uv*0.5*vec2(1.0, 1.0))*0.5 + 0.5);\n#endif\n#ifdef FAKE_LINEAR_LIGHT\n        // fake linear light\n        fragColor.rgb = InvACESFitted(pow(fragColor.rgb, vec3(2.2)));\n#endif\n        // DC offset correction, causing integral to become non-monotonic\n        fragColor = fragColor - 0.5;\n    } else {\n        frame -= 60;\n        ivec2 fc = ivec2(fragCoord);\n        vec4 d = texelFetch(iChannel0, fc + ivec2( 0, 0), 0);\n        fragColor = d; // as-is\n        if (frame < 12) {\n            // sum horizontally via jump flooding\n            int S = 1 << frame;\n            int x = fc.x - S;\n            if (x >= 0) {\n                vec4 b = texelFetch(iChannel0, ivec2(x, fc.y), 0);\n                fragColor += b;\n            }\n        }\n    }    \n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// after changing any of these, you need to restart the shader\n#define FAKE_LINEAR_LIGHT\n// 0 = anamorphic circular\n// 1 = hexagon\n// 2 = pentagon\n#define BOKEH 1\n#define LONDON\n\n///////////////////////////////////////////////\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvec3 InvRRTAndODTFit(vec3 x)\n{\n    return -1.0/100.0*(21647550.0*x + sqrt(-1873455419487500.0*x*x + 2326712714032270.0*x + 2415638944900.0) - 1228930.0)/(983729.0*x - 1000000.0);\n}\n\nvec3 InvACESFitted(vec3 color)\n{    \n    color = color * inverse(ACESOutputMat);\n    \n    // Apply RRT and ODT\n    color = InvRRTAndODTFit(color);\n\n    color = color * inverse(ACESInputMat);\n\n    return color;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 51, 51, 158], [160, 160, 217, 217, 1777]], "test": "untested"}
{"id": "fsGSzV", "name": "Refraction Metaballs", "author": "luckyballa", "description": "some insta-like effect but for webcam", "tags": ["raymarching", "metaballs", "refraction", "webcam"], "likes": 23, "viewed": 1047, "published": 3, "date": "1634990564", "time_retrieved": "2024-07-30T18:53:56.171526", "image_code": "#define MAX_STEPS 40\n#define MAX_DIST 40.\n#define SURF_DIST .005\n#define samples 32\n#define LOD 2\n\nfloat hash(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 184.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(hash(b), hash(b + d.yx), f.x), mix(hash(b + d.xy), hash(b + d.yy), f.x), f.y);\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k; \n}\n\nfloat getDist(vec3 p) {\n    float final = MAX_DIST;\n    float iTime = iTime; \n    p = p - vec3(0.,0.5, 5.);\n    for (int i = 0; i < 10; i++) {\n        float iF = float(i);\n        float fi = iF + floor(iF / 5.);\n        vec3 pos = p;\n        pos.xy += vec2(sin(iTime + fi), cos(iTime + fi * 2.)) * 0.4;\n        pos.z += sin(iTime * cos(float(i * 4))) * 0.2;\n        float r = sin(fi + 1.) * 0.15;\n        float n = min(sin(pos.z * iF * 5.), cos(pos.x * pos.y * iF * 10.)) * 0.1;\n        float bubble = sdSphere(pos + vec3(n) * 0.1 - vec3(0.05), r);\n        \n        final = smin(final, bubble, 0.4);\n    }\n\n    \n    return final;\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float res = getDist(p);\n        float dS = res;\n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normals(vec3 p, float of ) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    return dif;\n}\n\nfloat gaussian(vec2 i) {\nconst float sigma = float(samples) * .25;\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    const int  sLOD = 1 << LOD;\n    vec4 O = vec4(0);\n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * texture(sp, U + scale * d);\n    }\n    \n    return O / O.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 2.;\n\n\tvec3 ro = vec3(.0, 0., 1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y + 0.2 , 2.));\n    vec3 ld =  vec3(0., 0., 1.);\n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = normals(p, 0.03);\n    float dif = diffuse(p, n, ld); \n    float fresnel = smoothstep(0.5, 0.3, dot(-rd, n));\n    vec3 oil = vec3(noise(n.xy * 2.7), noise(n.xy * 3.), noise(n.xy * 3.3)); \n    \n    vec2 camUV = fragCoord / iResolution.xy;\n    vec3 cam1 = texture(iChannel0, camUV).xyz * 0.9;\n    camUV += n.xy * 0.05 * dif;\n    vec3 cam2 = blur(iChannel0, camUV, 1./iResolution.xy).xyz * 0.9;\n    vec3 dispersion = vec3(0.);\n    dispersion.r = texture(iChannel0, vec2(camUV.x - n.x * 0.0075,camUV.y)).r;\n    dispersion.g = texture(iChannel0, camUV).g;\n    dispersion.b = texture(iChannel0, vec2(camUV.x + n.y * 0.0075, camUV.y)).b;\n\n    col = dif * cam2;\n    col += cam2 * 0.15;         \n    col += oil * 0.4;\n    col += fresnel * 0.3;\n    col = mix(col, dispersion, (abs(n.x) + abs(n.y)) * 0.3);\n    \n    if (d > MAX_DIST) { col = vec3(cam1);  }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 119, 119, 186], [188, 188, 209, 209, 415], [417, 417, 452, 452, 474], [477, 477, 518, 518, 592], [594, 594, 617, 617, 1225], [1226, 1226, 1260, 1260, 1528], [1530, 1530, 1563, 1563, 1751], [1753, 1753, 1793, 1793, 1884], [1886, 1886, 1910, 1910, 2019], [2021, 2021, 2066, 2066, 2342], [2345, 2345, 2402, 2402, 3649]], "test": "untested"}
{"id": "NsySzc", "name": "Symmetry linear - Variant", "author": "NoxWings", "description": "Simmetry linear - Variant", "tags": ["simmetrylinearvariant"], "likes": 7, "viewed": 269, "published": 3, "date": "1634990198", "time_retrieved": "2024-07-30T18:53:57.035218", "image_code": "// variant on https://www.shadertoy.com/view/3tKGzV\n\n#define SURF_HIT 0.001\n#define FAR_PLANE 50.\n#define animTime (mod(iTime, 10.))\n#define S(x,y,z) smoothstep(x,y,z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,animTime))\n\nconst float PI = 3.14159;\n\nmat2 r2d(float a) {float sa=sin(a), ca=cos(a);return mat2(ca, -sa, sa, ca);}\n\nfloat fold = 0.0;\nfloat map(vec3 p) {\n    vec3 q = p;\n    \n\n    q = mod(q, fold) - fold*.5;\n    float d = length(q.xy) - 0.4;\n    d = min(d, length(q.xz) - 0.4);\n    d = min(d, length(q.yz) - 0.4);\n    return d;\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(SURF_HIT, 0);\n    float m = map(p);\n    return normalize(vec3(\n    \tm - map(p - e.xyy),\n        m - map(p - e.yxy),\n        m - map(p - e.yyx)\n    ));\n}\n\nfloat mapTrace(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0;i<128;i++) {\n        float h = map(ro + rd * d);\n        if (h < SURF_HIT || d >= FAR_PLANE) break;\n        d += h;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y * 1.0;\n\n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    fold = mix(0.1, 4.0, animTime);\n    fold = A(fold, 0.1, 7.0, 10.0);\n    \n    ro += vec3(0, 0, -1.* animTime * fold);\n    rd.xy *= r2d(PI * mix(animTime * 0.1, animTime * 0.1 - 0.3, sin(animTime * PI * 0.3)));\n\n    float d = mapTrace(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 n = mapNormal(p);\n\n    vec3 fogCol = vec3(1);\n    vec3 col = fogCol;\n    if (d < FAR_PLANE) {\n        vec3 outer = vec3(0.9);\n        vec3 inner = vec3(0.1, 0.1, 0.1);\n        \n        float f = pow(clamp(1.0 - dot(-rd, n), 0.0, 1.0), 1.5);\n        float fog = clamp(pow(d/FAR_PLANE, 1.), 0.0, 1.0);\n        \n        col = f * outer + (1.0 - f) * inner;        \n        col = mix(col, fogCol, vec3(fog));\n    }\n\n    fragColor = vec4(col, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 267, 267, 324], [344, 344, 363, 363, 539], [541, 541, 565, 565, 736], [738, 738, 772, 772, 945], [947, 947, 1004, 1004, 1907]], "test": "untested"}
{"id": "fsySzc", "name": "入门之路-4", "author": "jialouluo", "description": "用noise实现一个小案例", "tags": [], "likes": 2, "viewed": 208, "published": 3, "date": "1634989520", "time_retrieved": "2024-07-30T18:53:57.890930", "image_code": "vec2 random(in vec2 _st ){\n    _st = vec2(\n            dot(_st,vec2(127.326,321.324)),\n            dot(_st,vec2(15.31,45.332))\n                    );\n    return 2.0*fract(sin(_st)*432.23) +1.0; //1.0 ~ 3.0\n}\nfloat noise(vec2 st){ //Gradient Noise\n    vec2 i = fract(st);//取小数\n    vec2 k = floor(st);//向负无穷取整\n    vec2 u = i*i*(3.0-2.0*i);//插值函数\n    return  mix(\n                    mix(dot(random(k + vec2(0.0,0.0)),i - vec2(0.0,0.0)),\n                        dot(random(k + vec2(0.0,1.0)),i - vec2(0.0,1.0)),\n                         u.y),\n                    mix(dot(random(k + vec2(1.0,0.0)),i - vec2(1.0,0.0)),\n                        dot(random(k + vec2(1.0,1.0)),i - vec2(1.0,1.0)),\n                         u.y),\n                       u.x\n                   );//二维noise\n}\n\nvec3 shape(vec2 st ,float r){\n    vec2 uv = st-vec2(0.5);\n    uv*=2.0;\n    float angle = atan(uv.y,uv.x);\n    float m = abs(mod(angle+iTime*2.,3.14*2.)-3.14)/3.6 ;\n    r += sin(angle*50.)*noise(uv+iTime*0.2)*.1 * (1.-step(0.5,iMouse.z));\n    r += (sin(angle*20.)*.1*pow(m,2.))* (1.-step(0.5,iMouse.z));\n    float c = 1.-smoothstep(r,r+0.007,dot(uv,uv));\n    vec3 color = 0.5 + 0.5*cos(6.28*(angle/6.28 +vec3(0.3,0.6,0.9)) );\n    return c*color;\n}\nvec3 createCircle(vec2 st,float radius,float width){\n    return shape(st,radius) - shape(st,radius-width);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//感觉以前似乎太啰嗦了反而效果不是那么美好，所以这次干脆就只留下代码吧。\n//试试点击图像看看会发生什么，这可能会帮助你理解这个效果是如何实现的（28,29行）\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3  color = createCircle(uv,0.5,0.07);\n    //color = vec3(noise(uv));//这里是使用noise算法之后结果的观察\n    \n\tfragColor = vec4(vec3(1.-color), 1.0 );\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 207], [208, 208, 229, 246, 808], [810, 810, 839, 839, 1256], [1257, 1257, 1309, 1309, 1365], [1366, 1366, 1423, 1647, 1862]], "test": "untested"}
{"id": "fdGXRc", "name": "Twizzly Shape", "author": "SnoopethDuckDuck", "description": "A few artifacts on this one, might do background later", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 296, "published": 3, "date": "1634988908", "time_retrieved": "2024-07-30T18:53:58.710737", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n\n    float a = atan(p.z, p.x);\n    float r = length(p.xz);\n    \n    p.y += 0.4 * cos(r + 2.5 * iTime);\n    p.y += 0.025 * cos(8. * r + .5 * iTime);\n    \n    r += 0.5 * cos(5. * a - cos(iTime) * 8. * r);\n    p.x = r * cos(a);\n    p.z = r * sin(a);\n   \n  \n    float d = length(p) - 1.4 + 1.3 * cos(iTime);\n    vec3 n = vec3(cos(4. * a + 4. * p.y + 2. * iTime), 2., 0.);// + 0.5 * vec3(cos(3. * p.x + iTime),0.,sin(3. * p.z + iTime));\n    float k = .5 +.25 * cos(iTime);\n    float s = 1.; // in 0-1\n    //d = 0.;\n    d = max(d, max(dot(p, n) - k + s * (1.-k) * cos(iTime), -dot(p,n) - k - s * (1.-k) * cos(iTime)));\n    return 0.15 * d;//0.22 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(5. * cos(0.4 * iTime), 3. * sin(0.6 * iTime), 5. * sin(0.4 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.6 * texture(iChannel0,r / (0.5 + n)).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        col.r += 0.2 * 0.7 + .3 * cos(10. * rf.y + 4. * iTime - 3.1415 / 2.);\n        col.g += 0.2 * 0.7 + .3 * cos(10. * rf.y + 4. * iTime);\n        col.b += 0.2 * 0.7 + .3 * cos(10. * rf.y + 4. * iTime + 3.1415 / 2.);\n        \n        //float m = .5 + .5 * cos(4. * length(p.xz) + 1. * p.y - 3. * iTime);\n        \n        //col = 1.- mix(1.-col, 10. * (1.- col) * (1.- col) * col * col, m);\n    } else {\n       // col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGXRc.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1559, 1588, 1588, 1808], [1811, 1811, 1834, 1834, 2481], [2483, 2483, 2517, 2517, 2728], [2730, 2730, 2754, 2754, 2944], [2946, 2946, 2996, 2996, 3187], [3189, 3189, 3207, 3207, 3305], [3308, 3308, 3365, 3365, 4798]], "test": "untested"}
{"id": "fsVXzy", "name": "NoxWings Logo", "author": "NoxWings", "description": "NoxWings Logo", "tags": ["noxwingslogo"], "likes": 2, "viewed": 214, "published": 3, "date": "1634987330", "time_retrieved": "2024-07-30T18:53:59.524562", "image_code": "#define USE_POST             1\n\n#define BARREL_DISTORTION    1\n#define SCAN_LINES\t\t\t 1\n#define CHROMATIC_ABERRATION 1\n#define VIGNETTE             1\n\nfloat POST_INTENSITY() {\n    return 0.7;\n}\n\nfloat crtCurve(in vec2 uv)\n{\n    float domeCurvature = 3.0;\n    float domex = 1.0 - pow(abs(uv.x), domeCurvature);\n    float domey = 1.0 - pow(abs(uv.y), domeCurvature);\n    return domex * domey;\n}\n\nvec2 crtDistortedUV(in vec2 uv, in float strength)\n{\n    vec2 s = 1.0/iResolution.xy;\n    vec2 offset = vec2(1, 0);\n\n    float p = crtCurve(uv);\n    float h1 = crtCurve(uv + s * offset.xy);\n    float v1 = crtCurve(uv + s * offset.yx);\n\n   \treturn uv - (p - vec2(h1, v1)) * strength;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec2 texUV = uv;\n    vec3 color = vec3(0);\n\n#if USE_POST == 1\n    #if BARREL_DISTORTION == 1\n    {\n        float distortion = 30.0;\n        distortion = mix(0.0, distortion, POST_INTENSITY());\n        vec2 compression = distortion / vec2(300.0, 200.0);\n\n        // Compression\n        uv2 *= 1.0 + compression;\n        // Distortion\n        uv2 = crtDistortedUV(uv2, distortion);\n\n        if (abs(uv2.x) > 1.0 || abs(uv2.y) > 1.0)\n        {\n            fragColor = vec4(vec3(0), 1.0);\n            return;\n        }\n\n        texUV = uv2 * 0.5 + 0.5;\n    }\n    #endif\n#endif\n\n    vec4 buffer = texture(iChannel0, texUV);\n    color = buffer.rgb;\n\n#if USE_POST == 1\n    #if CHROMATIC_ABERRATION == 1\n    {\n\t\tfloat intensity = 0.00007 * POST_INTENSITY();\n        float lensDistortion = 0.4;\n\n        float radialIntensity = pow(length(uv2), lensDistortion);\n    \tvec2 radialDirection = normalize(uv2);\n\n        //fragColor = vec4(radialIntensity); return;\n\n\t    vec3 waveLengths = vec3(440, 575, 650);\n\t    vec3 offsets = (waveLengths.g - waveLengths) * intensity * radialIntensity;\n\n        float mixed = clamp(length(uv2) + 0.1, 0.0, 1.0);\n\n    \tcolor.r = mix(color.r, texture(iChannel0, texUV + radialDirection * offsets.r).r, mixed);\n    \tcolor.b = mix(color.b, texture(iChannel0, texUV + radialDirection * offsets.b).b, mixed);\n    }\n    #endif\n\n\t#if VIGNETTE == 1\n    {\n    \tfloat radial = 1.0 - clamp(-0.2 + pow(length(uv2 / 1.4), 2.2), 0.0, 1.0);\n        radial = mix(1.0, radial, POST_INTENSITY());\n    \tcolor.rgb *= vec3(radial);\n    }\n    #endif\n\n    #if SCAN_LINES == 1\n    {\n        float lines = iResolution.y / 6.0;\n        float scan = smoothstep(0.03, 0.2, fract(uv.y * lines));\n        scan = mix(1.0, scan, POST_INTENSITY());\n\t    color *= scan;\n    }\n    #endif\n#endif\n\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color.rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//------------------------------------------------------------------------------\n// Math\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float HALF_PI = PI * 0.5;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = TAU/360.;\n\nmat2 rot2D(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\n#define AA .01\n#define S(x, y, z) smoothstep(x, y, z)\n#define animTime (mod(iTime, 10.))\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,animTime))\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circle(vec2 uv, float r) {\n    return S(r+AA, r, length(uv));\n}\n\nfloat arc(vec2 uv, vec2 rs, float offset) {\n    vec3 r = vec3(rs, 0);\n    vec2 o2 = vec2(offset/2., 0);\n\n    float shape = circle(uv + r.xz - o2, rs.x);\n    return clamp(shape - circle(uv + r.yz + o2, rs.y), 0.0, 1.0);\n}\n\nmat3 translation(vec2 m) {\n    return mat3(1, 0, m.x, 0, 1, m.y, 0, 0, 1);\n}\n\nmat3 rotation(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat3(ca, sa, 0, -sa, ca, 0, 0, 0, 1);\n}\n\nmat3 rotateAroundMatrix(vec2 pivot, float angle) {\n    return translation(pivot) * rotation(angle) * translation(-pivot);\n}\n\nvec2 rotateAround(vec2 point, vec2 pivot, float angle) {\n    return vec2(vec3(point, 1) * rotateAroundMatrix(pivot, angle));\n}\n\nfloat logo(vec2 uv, float t) {\n    float invT = 1.0 - t;\n\n    vec2 arcOffset = vec2(.45, .3);\n    vec2 arcBalls = vec2(.6, .65);\n    float arcWidth = .055;\n\n    // the last rot2D(invT) is not exact\n    vec2 topArcPosition = (uv * rot2D(.25) - arcOffset) * rot2D(invT);\n    vec2 botArcPosition = (uv * rot2D(PI + .25) - arcOffset) * rot2D(invT);\n\n    float turns = 5.;\n    topArcPosition = rotateAround(topArcPosition, vec2(arcBalls.x, 0), turns*TAU*invT);\n    botArcPosition = rotateAround(botArcPosition, vec2(arcBalls.x, 0), turns*TAU*invT);\n\n    float topArc = arc(topArcPosition, arcBalls, arcWidth);\n    float bottomArc = arc(botArcPosition, arcBalls, arcWidth);\n\n    float shape = topArc;\n    shape += bottomArc;\n    shape += circle(uv, .15);\n    return shape;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1);\n\n    vec3 col = vec3(0);\n\n   \tfloat logoFadeIn = S(0.0, 1.0, animTime);\n    float shapeFadeIn = S(0.0, 5.0, animTime);\n    float shapeTurn = S(0.0, 5.0, animTime);\n    float logoFadeOut = S(7.5, 10., animTime);\n\n    float shape = logo(uv, shapeTurn) * shapeFadeIn;\n    col = vec3(hash12(uv * 100. * (1. + animTime))) - vec3( shape );\n    col = mix(vec3(0), col, logoFadeIn);\n    col = mix(col, vec3(0), logoFadeOut);\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 174, 174, 192], [194, 194, 222, 222, 391], [393, 393, 445, 445, 677], [679, 679, 734, 734, 2724]], "test": "untested"}
{"id": "NsVSWw", "name": "hex tiling test", "author": "drschizzo", "description": "2d hex truchet\n3d truchet here : https://www.shadertoy.com/view/fsySWG", "tags": ["truchet", "tiling", "hex"], "likes": 15, "viewed": 399, "published": 3, "date": "1634978976", "time_retrieved": "2024-07-30T18:54:00.399223", "image_code": "/*float hex(vec2 p){\n    p=abs(p);\n\n    float d=dot(p,normalize(vec2(1.,1.73)));\n    float c=max(d,p.x);\n    return c;\n}*/\n\nfloat hash21(vec2 a){\n    a+=3.44;\n    a=fract(a*vec2(47.43,1.32));\n    a+=dot(a,a+2.23);\n    return fract(a.x*a.y);\n}\n    \nvec4 hexuv(in vec2 uv,float size){\n    uv*=size;\n    vec2 r=vec2(1,1.73);\n    vec2 a=mod(uv+r*.5,r)-r*.5;\n    vec2 b=mod(uv,r)-r*.5;\n    \n    vec2 gv=dot(a,a)<dot(b,b)?a:b;\n    vec2 id=uv-gv;\n    return vec4(gv.x,gv.y,id.x,id.y);\n}\n\nfloat getLines(vec4 huv){\n    float c=length(vec2(abs(huv.x)-.9,huv.y))-.28;\n    float w=.12;\n    float blur=.02;\n    c=smoothstep(w+blur,w , abs(c-.5) );\n    float l=smoothstep(w+blur,w,abs(huv.y));    \n    return min(c+l*4.5*dot(huv.xy,huv.xy),1.);\n}\n/*\nWIP trying to figure how to maintain continuity\nvec3 getColoredLines(vec4 huv,vec2 uv){\n        float w=.12;///(pow(length(uv*2.),.5));\n\n    float c=length(vec2(huv.x-.9,huv.y))-.28;\n    c=step(abs(c-.5),w);\n    vec3 cl=vec3(1.,0,0)*c;\n    c=length(vec2(-huv.x-.9,huv.y))-.28;\n    c=step(abs(c-.5),w);;\n    vec3 cr=vec3(0,1.,0)*c;\n    \n   vec3 cc=cl+cr;\n    \n    float l=abs(huv.y)-w/2.<w/2.?1.:0.;\n     l=clamp(l*4.5*dot(huv.xy,huv.xy),0.,1.);\n    return vec3(0,0,l)+cc;\n    \n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t=vec2(iTime/10.);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n//      vec2 m=(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n  //  float d=smoothstep(0.,.5,length(m-uv))+.5;\n    vec4 huv=hexuv(uv+t,10.);\n    float shift=hash21(huv.zw+floor(iTime));\n    float angle = shift<.33 ? 3.14/3. : shift<.66 ? -3.14/3. : 0.;\n    \n    mat2 r=mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n    huv.xy=huv.xy*r;\n    \n    vec3 col=vec3(getLines(huv));\n    col*=.5+.5*sin(vec3(.54,.3,.7)*iTime);\n    \n    //vec3 col=vec3(getColoredLines(huv,uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 145, 145, 242], [248, 248, 282, 282, 479], [481, 481, 506, 506, 733], [1219, 1219, 1276, 1276, 1874]], "test": "untested"}
{"id": "NdGXR3", "name": "RGB-Tunnel III", "author": "turboplay", "description": "A variant of https://www.shadertoy.com/view/7dGXzK and https://www.shadertoy.com/view/7syXzV\n", "tags": ["simple", "tunnel", "short", "tweet", "golf"], "likes": 2, "viewed": 257, "published": 3, "date": "1634974953", "time_retrieved": "2024-07-30T18:54:01.230002", "image_code": "\nvoid mainImage(out vec4 o, vec2 u){\n   o += length(u= u/iResolution.x-0.25) - o;\n   o *= 4. / exp(6.*fract(atan(u.xyxx, u.xxyx)/0.393 - .2/o - iTime));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 154]], "test": "untested"}
{"id": "7sVXRV", "name": "Sound Experiment #2", "author": "oneshade", "description": "Semi-spooky experiments with sound tab.", "tags": ["sound", "experiment", "short"], "likes": 10, "viewed": 365, "published": 3, "date": "1634967377", "time_retrieved": "2024-07-30T18:54:02.118626", "image_code": "// Based on the spooky sound in this p5.js sketch:\n// https://editor.p5js.org/allison.parrish/sketches/8aW5OeI8M\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n// Modified hash from https://www.shadertoy.com/view/4djSRW\nfloat noise(in vec3 p) {\n\tp = fract(p * 0.731 - p.x * 253.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0));\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0));\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0));\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0));\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0));\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0));\n    float ruf = noise(cell + 1.0);\n\n    return mix(mix(mix(ldb, rdb, local.x), mix(ldf, rdf, local.x), local.z),\n               mix(mix(lub, rub, local.x), mix(luf, ruf, local.x), local.z), local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = 0.1 * iTime;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + time;\n\n    // iq's domain warping technique\n    float warp = 0.0;\n    for (int i=0; i < 5; i++) warp = fnoise(vec3(uv, 0.25 * time) + warp, 2.0, 5.0);\n\n    float pow2 = warp * warp, pow4 = pow2 * pow2, pow8 = pow4 * pow4;\n    fragColor = vec4(pow4, pow4 + pow8, pow4, 1.0);\n\n    // Aspect correct uncentered and undrifting UVs\n    uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(int samp, float time) {\n    return vec2(makeNoise(time));\n}", "sound_inputs": [], "common_code": "#define TAU 6.28\n\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Approximate gaussian filtered saw wave\nfloat gsaw(in float x, in float w) {\n    x = fract(x);\n    return (erf(2.0 * (1.0 - x) / w) - erf(2.0 * x / w)) / 2.0 + x;\n}\n\nfloat whiteNoise(in float time) {\n    // return fract(495.381 * cos(937.385 * time + 18.387));\n    // https://www.shadertoy.com/view/4djSRW\n    time = fract(time * 0.1031);\n    time *= time + 33.33;\n    time *= time + time;\n    return fract(time);\n}\n\nfloat smoothNoise(in float time) {\n     return mix(whiteNoise(floor(time)), whiteNoise(ceil(time)), smoothstep(0.0, 1.0, fract(time)));\n}\n\nfloat squareWave(in float time) {\n    return mod(floor(2.0 * TAU * time), 2.0);\n}\n\nfloat triWave(in float time) {\n    return (1.0 - 2.0 * abs(1.0 - 2.0 * fract(TAU * time + 0.25)));\n}\n\nfloat sineWave(in float time) {\n     return sin(TAU * time);\n}\n\nfloat bump(in float time, in float width, in float sharpness) {\n    time = max(0.0, abs(time) - width) * sharpness;\n    return exp(-time * time);\n}\n\nfloat expFade(in float time, in float sharpness) {\n    return exp2(-time * sharpness);\n}\n\nfloat makeNoise(in float time) {\n    float sound = 0.0;\n\n    // Kind of spooky, also sounds a bit like a ventilator fan\n    float amp = 1.0 / 50.0;\n    for (float i=0.0; i < 50.0; i++) {\n        float freq = floor(mix(100.0, 1000.0, whiteNoise(i)));\n        sound += amp * sin(mod(TAU * freq * time, TAU));\n    }\n\n    // Okayish bell tolling\n    if (time > 5.0 && time < 26.0) {\n        float time1 = time - 5.0;\n        float time2 = time1 - min(3.0 * floor(time1 / 3.0), 15.0);\n        sound += gsaw(TAU * 55.0 * time2, 0.15) * expFade(time2, 1.0) * expFade(time1, 0.1);\n    }\n\n    // Drum\n    if (time > 28.0) {\n        float time3 = time - 28.0;\n        float time4 = mod(time3, 3.0);\n        sound += 0.5 * sineWave(100.0 * expFade(time4, 1.0) * time4) * expFade(time4, 1.0) * expFade(time3, 0.15);\n    }\n\n    return sound;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 192, 296, 296, 631], [633, 693, 717, 717, 831], [833, 833, 858, 858, 1491], [1493, 1493, 1552, 1552, 1838], [1840, 1840, 1895, 1895, 2994]], "test": "untested"}
{"id": "7sKXRV", "name": "rehab", "author": "sp4ghet", "description": "idk man what even are shaders\n\nFFT Integrated looks like crap since you are only sampling audio at random every frame instead of actually summing all the signal.\n\nAlso soundcloud is ded RIP (soundcloud is back POGGIE WOGGIE)", "tags": ["rehabilitation"], "likes": 11, "viewed": 502, "published": 3, "date": "1634955755", "time_retrieved": "2024-07-30T18:54:03.307448", "image_code": "// Bonzo to Shadertoy\n#define v2Resolution iResolution\n#define texFFT iChannel0\n#define time iTime\n#define texFFTIntegrated iChannel1\n#define texNoise iChannel2\n//\n#define saturate(x) clamp(x, 0., 1.)\n#define lofi(x, n) floor((x)*(n)) / (n)\nconst float PI = acos(-1.);\n\nconst vec3 up = vec3(0.,1.,0.);\n\nmat2 r2d(float t){\n    float c = cos(t), s = sin(t);\n    return mat2(c,s,-s,c);\n}\n\nfloat tr(vec3 p, vec2 rr){\n  p.xz *= r2d(time * .2);\n  float x = length(p.xz) - rr.x;\n  float y = p.y;\n  float th = atan(p.z, p.x);\n  vec2 xy = vec2(x,y);\n  float t = floor(time) + 0.5 + 0.5 * cos(PI * exp(-3. * fract(time)));\n  vec2 uv = vec2(th+.3*t, .5*t+atan(xy.y, xy.x));\n  rr.y -= .1 * texture(texNoise, uv).r;\n  xy *= r2d(th * 4.);\n  float disp = .5 * rr.y * sin(3. * time + th);\n  xy.y = abs(xy.y + disp) - rr.y;\n  return length(xy) - rr.y;\n}\n\nvoid chmin(inout vec4 a, in vec4 b){\n    a = abs(a.x) < abs(b.x) ? a : b;\n}\n\n\nfloat glo = 0.;\nfloat vl = 0.;\nvec4 map(vec3 q){\n  vec3 p = q;\n  vec4 d = vec4(1e5, 0,0,0);\n  \n  p -= vec3(-.5,.5,0);\n  p.xz *= r2d(-PI * .15);\n  p.xy *= r2d(-PI * .35);\n  p.yz *= r2d(-PI * .1);\n  float tr1 = tr(p, vec2(1., .15));\n  \n  p.xz *= r2d(PI * .75);\n  float sp = length(p.xz - .005 * p.y*p.y) - .2;\n  float ns = texture(texNoise, p.xy - vec2(0,vl)).r;\n  sp = max(abs(sp), .01);\n  glo += ns * .3 / (sp*sp + .05);\n  chmin(d, vec4(sp, 2, 0, 0));\n  \n  p = q;\n  p -= vec3(.5, -.5, -.25);\n  p.yz *= r2d(-PI * .4);\n  float tr2 = tr(p, vec2(1., .15));\n  float dst = min(tr1, tr2);\n  chmin(d, vec4(dst, 0,0,0));\n  \n  p.xz *= r2d(PI * .5);\n  sp = length(p.xz + .01 * p.y*p.y) - .2;\n  sp = max(abs(sp), .01);\n  ns = texture(texNoise, p.zy + vec2(0,vl)).r;\n  glo += ns * .3 / (sp*sp + .05);\n  chmin(d, vec4(sp, 2, 0, 0));\n  \n  \n  return d;\n}\n\nvec3 normal(vec3 p, vec2 e){\n  return normalize(vec3(\n    map(p + e.xyy).x - map(p - e.xyy).x,\n    map(p + e.yxy).x - map(p - e.yxy).x,\n    map(p + e.yyx).x - map(p - e.yyx).x\n  ));\n}\n\nvec3 grad(float t){\n  t *= 2. * PI;\n  return vec3(\n    .3 + .3 * cos(t),\n    .5 + .5 * cos(t),\n    .7 + .3 * cos(t)\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 pt = uv - 0.5;\n    vec2 aspect = vec2(v2Resolution.y / v2Resolution.x, 1);\n    pt /= aspect;\n\n    pt *= dot(pt,pt) * .5 + 1.;\n\n    vl = texture(texFFTIntegrated, vec2(.01, .5)).r;\n\n    vec3 c = vec3(0);\n    c.rg = smoothstep(vec2(.05), vec2(.01), mod(pt, .1) / .1);\n    c = vec3(max(c.r, c.g));\n\n\n    vec3 ro = vec3(0,0,-5);\n    vec3 fo = vec3(0);\n    vec3 cz = normalize(fo-ro);\n    vec3 cx = normalize(cross(cz, up));\n    vec3 cy = cross(cx, cz);\n    vec3 rd = mat3(cx,cy,cz) * normalize(vec3(pt, 1));\n\n    float t = 0., precis = 1e-5;\n    vec4 d;\n    vec3 p = ro;\n\n    for(int i=0; i<128; i++){\n        p = ro + rd*t;\n        d = map(p);\n        t += d.x * .7;\n        precis = t * .001;\n        if(t > 50. || d.y != 2. && abs(d.x) < precis){\n          break;\n        }\n    }\n\n    vec3 l = normalize(vec3(-1., 2., -.6));\n    if(d.y != 2. && abs(d.x) < precis){\n        vec3 n = normal(p, vec2(precis, -precis));\n        vec3 h = normalize(l-rd);\n        //vec3 a = vec3(.2, .85, .9);\n        vec3 a = grad(abs(dot(n,-rd)));\n        float r0 = 2.;\n        float fre = r0 * pow(1. - abs(dot(n,-rd)), 5.);\n        c = a * max(dot(n,l), .1);\n        c += a * pow(dot(n,h), 15.);\n        c += (1.-a) * fre;\n\n        float ao = 0., sss=0.;\n        for(float aod=0.05; aod<.3; aod+=.05){\n            ao += map(p + n*aod).x / aod;\n            float ssd = aod * 6.;\n            sss += map(p + h*ssd).x / ssd;\n        }\n        c += (1.-a) * .3 * sss * .05 / .3;\n        c *= ao * .05 / .3;\n    }\n\n    float vol = .15 * texture(texFFT, vec2(.01)).r;\n    c += vec3(.9,.2,.2) * (.1 * vol + .001) * glo;\n\n\n    float vig = max(1. - dot(pt,pt), 0.);\n    c *= vig;\n  \n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28194, "src": "https://soundcloud.com/poniyama_com/telecommunication-from-x", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 c = texture(iChannel0, vec2(uv.x,.25));\n    c = .01 * (exp(c) - 1.);\n    vec4 back = texture(iChannel1, uv);\n    fragColor = c + back;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28195, "src": "https://soundcloud.com/poniyama_com/telecommunication-from-x", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 321, 321, 384], [386, 386, 412, 412, 836], [838, 838, 874, 874, 913], [947, 947, 964, 964, 1754], [1756, 1756, 1784, 1784, 1939], [1941, 1941, 1960, 1960, 2063], [2066, 2066, 2123, 2173, 3934]], "test": "untested"}
{"id": "sdKXzK", "name": "Trippy animation.", "author": "mvaios", "description": "Trippy shader effect", "tags": ["grid", "colors", "effect", "fx", "trippy"], "likes": 1, "viewed": 263, "published": 3, "date": "1634952620", "time_retrieved": "2024-07-30T18:54:04.182109", "image_code": "// Original idea from this video with a great explenation of how this works: https://www.youtube.com/watch?v=cQXAbndD5CQ\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n\t\n    uv *= mat2(.707, -.707, .707, .707);\n    uv *= 8. * (sin(iTime * .1) * .4 + 1.4);\n    \n    vec2 gv = fract(uv)-.5; \n\tvec2 id = floor(uv);\n    \n\tfloat m = 0.;\n    float t;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n            \n            t = -iTime*.32+length(id-offs)*.42;\n            float r = mix(.4, 1.5, sin(t)*.5+.5);\n    \t\tfloat c = smoothstep(r, r*.99, length(gv+offs));\n    \t\tm = m*(1.-c) + c*(1.-m);\n        }\n    }\n    \n    float mult = sin(iTime) * 0.25 + 1.4;\n    float modBase = uv.x * uv.y;\n    fragColor = vec4(m * mod(modBase, mult * 1.3), m * mod(modBase * 2.3, (mult + 1.) / 1.3), m * mod(modBase, mult), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 180, 180, 945]], "test": "untested"}
{"id": "7sySzV", "name": "Twizzly Mess", "author": "SnoopethDuckDuck", "description": "The whole thing is an artifact basically", "tags": ["raymarching", "template", "artofcode"], "likes": 17, "viewed": 457, "published": 3, "date": "1634947624", "time_retrieved": "2024-07-30T18:54:04.956039", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float a = atan(p.x,p.z);\n   // p.y += 0.5 * cos(2. * p.x + iTime);\n    //p.xz += 0.2 * cos(p.zx + iTime);\n    \n    float b = pow(abs(cos(1. * a + iTime)), 32.);\n    float b2 = pow(abs(sin(1. * a + iTime)), 32.);\n   // p.y += mix(b, b2, .5 + .5 * cos(iTime));\n   // p.y = sin(0.5 * p.y);\n   // p.x = -2. + 0.5 * sin(0.5 * p.x);\n     a = cos(5. * a);\n   float r = length(p.xz);\n   float rc = r;\n   r *= mix(1.,.8 + .2 * cos(1. * cos(10. * p.y) + iTime), 0.2);\n    \n    p.x = r * cos(a);\n    p.z = r * sin(a);\n    \n    p.y *= 1.8 + cos(4. * max(abs(p.x), abs(p.z)) + 4. *iTime);\n    \n    p.y *= 0.8 + 0.2 * cos(20. * length(p.xz) + 10.* iTime);\n    \n    float r1 = 1.;\n    float r2 = 0.5;\n    //p.x += 0.1 * cos(4. * p.y);\n    float d1 = length(p.xz) - r1;\n    d1 += 0.8* cos(0.2 * p.y  + cos(p.y) + 0.5 * iTime);\n    \n    p.y = cos(0.5 * p.y + iTime);\n    float d = length(vec2(d1, p.y)) - r2;\n    \n   \n    return 0.2 * d  * (1. + cos(0.55 * rc));//0.25 * d * (1. + 0.75 *  cos(30. * a));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(5. * cos(0.5 * iTime),  cos(0.3 * iTime) * 3., 5. * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.9);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.6 * texture(iChannel0,r / (0.5 + n)).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        col.r += 0.2 * 0.7 + .3 * cos(3. * rf.y + 0. * iTime - 3.1415 / 2.);\n        col.g += 0.2 * 0.7 + .3 * cos(3. * rf.y + 0. * iTime);\n        col.b += 0.2 * 0.7 + .3 * cos(3. * rf.y + 0. * iTime + 3.1415 / 2.);\n        \n        col = mix(pow(col, vec3(2.)), pow(1.-col, vec3(64.)),pow(cos(4.5 * length(p.xz)),2.));\n       \n    \n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sySzV.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1559, 1588, 1588, 1808], [1811, 1811, 1834, 1834, 2827], [2829, 2829, 2863, 2863, 3074], [3076, 3076, 3100, 3100, 3290], [3292, 3292, 3342, 3342, 3533], [3535, 3535, 3553, 3553, 3651], [3654, 3654, 3711, 3711, 5085]], "test": "untested"}
{"id": "ftB3DG", "name": "Refraction Crystals [015]", "author": "byt3_m3chanic", "description": "Refraction Crystals [015] Just playing with some simple fold/mirror formulas / SDF intersections", "tags": ["raymarching", "fractal", "refraction", "crystal"], "likes": 34, "viewed": 640, "published": 3, "date": "1634944770", "time_retrieved": "2024-07-30T18:54:05.799784", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Refraction Crystals [015]\n    10/22/21 @byt3_m3chanic\n    \n    Just playing with some simple fold/mirror formulas / SDF intersection\n    to make some pretty fractal crystal like things.\n\n*/\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MAX_DIST    100.\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), .0, 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq sdf's\nfloat box(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\nfloat octa( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*.5773;\n}\n\n// fold formulas\nvoid bet(inout vec4 p, float s, float f, float m) {\n\tp.xy = abs(p.xy + f) - abs(p.xy - f) - p.xy;\n\tfloat rr = dot(p.xyz, p.xyz);\n\tif (rr < m) {\n\t\tif(m==0.) m=1e-5;\n\t\tp /= m;\n\t}else{\n\t\tif (rr<1.)p /= rr;\n\t}\n\tp *= s;\n}\n\nvoid tet(inout vec4 p, float k1, float k2, float k3, float k4) {\n\tp = abs(p);\n\tfloat k = (k1 - .5)*2.;\n\tp.xyz /= vec3(k2, k3, k4);\n\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n\n\tp.xyz = p.xyz*k1 - k + 1.;\n\tp.xyz *= vec3(k2, k3, k4);\n\tp.w *= abs(k);\n}\n\nvec2 sdform(in vec3 pos, float hs) {\n    vec4 P = vec4(pos.xzy, 1.);\n    float orbits = .0;\n    for(int i = 0; i < 3; i++) {\n        orbits = max(length(P.xz)*.075,orbits);\n        bet(P, 4.25-hs, 3.-hs, .55);\n        \n        if(hs>.5) {\n            tet(P, 1.5+hs, 1.5, 1.5, 1.5);\n        }else{\n            tet(P, 1.5-hs, 1.+hs, 1.5, 1.5);\n        }\n    }\n  \n    float ln = .9*(abs(P.z)-15.)/P.w;\n    \n    return vec2(ln,orbits);\n}\n\nmat2 rx,ry,turn;\nfloat time,ga1,ga2,ga3,ga4,tmod;\n    \nconst float s = 13.;\nconst float hf= s/2.;\n\nvec2 map (in vec3 p) {\n    vec2 res = vec2(MAX_DIST,0.);\n    \n    vec3 dp = p;\n    \n    p.y+= .2;\n    p.z+= M.z>0.?.75:1.75;\n   \n    // movin domain 1 rep but using px to move the ID's\n    // as if the domain is continious helps make the refraction\n    // stay pretty as things get messy with larger time variables \n    // used for distance\n    float px = p.x-(ga2*s);\n    p.x-=ga1*s;\n    float id = floor((px+hf)/s);\n\n    p.x=mod(p.x+hf,s)-hf;\n    p.yz*=rx;\n    p.xz*=ry;\n\n    float hs = hash21(vec2(id,1.));\n    vec2 f = sdform(p,hs);\n    float c = octa(p,3.);\n    \n    f.x= hs>.85?max(f.x,c):max(-f.x,c);\n    if(f.x<res.x) {\n        res = f;\n    }\n\n    float d = box(dp,vec3(9),.00);\n    d=max(d,-box(dp,vec3(5.5,4.,5.5),.001));\n    d=max(d,-box(dp,vec3(9.5,3.,4.5),.25));\n    d=max(d,-box(dp,vec3(4.5,3.,9.5),.25));\n    if(d<res.x) {\n        res = vec2(d,14.);\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(.1,9,7);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 clr = .5 + .4 *sin(m + vec3(2.5,1.5,.5));\n    vec3 h = mix(vec3(0),clr,.45);\n    if(m==14.) h=vec3(.416,.420,.506)*clamp((p.y*.1+.5),0.,1.);\n    return h*diff;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    time = T;\n    float timer = T*.08;\n    \n    tmod = mod(time, 10.);\n    float t1 = lsp(0., 5., tmod);\n    ga1 = eoc(fract(t1));\n    ga1 = ga1*ga1*ga1;\n    ga2 = (t1)+floor(time*.1);\n\n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,4.),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? 0. :  (M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n    //float dt = length(uv-vec2(x,y));\n    rx = rot(x+.28),ry = rot(timer+y);\n\n    vec3  p = ro + rd * .1;\n    float atten = .95,k = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    // lower for slow machines (128)\n    for(int i=0;i<172;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float d = ray.x*.95;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m==4.)break;\n\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            if(m==14.) {\n                atten *=.4;\n                rd=reflect(-rd,n);\n                p+=n*.02;\n            }else{\n                atten *= .75;\n                rd=refract(rd,n,.9);\n            }\n        }  \n        if(distance(p,rd)>18.) { break; }\n    }\n    // Output to screen\n    O = vec4(sqrt(smoothstep(0.,1.,C)),1.);\n}\n\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftB3DG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[461, 461, 483, 483, 541], [542, 542, 561, 561, 606], [607, 607, 651, 651, 704], [705, 705, 725, 725, 761], [763, 775, 811, 811, 899], [900, 900, 930, 930, 978], [980, 997, 1048, 1048, 1213], [1215, 1215, 1279, 1279, 1585], [1587, 1587, 1623, 1623, 2020], [2121, 2121, 2143, 2143, 3010], [3012, 3081, 3126, 3126, 3349], [3352, 3352, 3413, 3413, 3710], [3712, 3712, 3753, 3753, 5152]], "test": "untested"}
{"id": "7sGXzR", "name": "Surfing in the moon", "author": "LongJohnny", "description": "Inverting the texture values and using them as a heightmap to the plane. Finally bending the plane to emulate a circular surface.  All of this combined with a scaled sphere and moving camera create a speedy effect.", "tags": ["moon", "speed"], "likes": 5, "viewed": 257, "published": 3, "date": "1634937022", "time_retrieved": "2024-07-30T18:54:06.642530", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sinDisplacement(vec3 p, float strength) {\n    return sin(strength*-p.y);\n}\n\nfloat smin(float a, float b, float k) {\n    \n    /*float h = max(0., min(1., (b - a)/k + .5));\n    float m = h * (1. - h) * k;\n       \n    return a * k + b * (1. - k) - m * .5;*/\n    \n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    \n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    // Project ap onto ab \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    // Projection cannot exceed the length of ab\n    t = clamp(t, 0., 1.);\n    \n    // Closest point in line segment\n    vec3 c = a + ab * t;\n    \n    // Distance to line segment\n    float d = length(p - c);\n    \n    // Distance to capsule\n    return d - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.)) +min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    float y = p.y;\n    return sqrt(x*x + y*y) - r.y;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    \n    vec2 uv = p.xz;\n    float noise = texture(iChannel1, uv * 0.005).r;\n    \n   \n    return dot(p, normalize(n)) - (h - noise*6.);\n}\n\nfloat opCheapBend(vec3 p )\n{\n    const float k = -0.001; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n   \n    \n    return sdPlane(q - vec3(0., 0., iTime * 100. + cos(iTime)+1. * 200.), vec3(cos(iTime * 1.5) * .15, 1.,0.),-3.);\n}\n\n\nvec4 GetDist(vec3 p) {\n    vec3 c = vec3(7.);\n    //p = mod(p+0.5*c,c)-0.5*c;\n    \n    float k = sin(iTime * 2.); // or some other amount\n    float e = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(e,-s,s,e);\n    //p = vec3(m*p.xy,p.y);\n    \n    // From -1 to 2\n    float pulse = abs(cos(iTime * 4.));\n\n    vec3 sp = p;\n    sp *= vec3(1.,3.,.2);\n    sp -= vec3(cos(iTime*2.)*2., sin(iTime * 2.)*2., (cos(iTime) - 1.) * 3.);\n   \n    //sp. *= Rot(iTime);\n    float d = sdSphere(sp, 1.2);\n    float ds = sdSphere(p + vec3(0., 0.8 + sin(iTime) * 2., 1.2), 0.7);\n    float ds2 = sdSphere(p + vec3(0., 0.8 + sin(iTime) * 2., -1.2), 0.7);\n   \n    float d2 = sdBox(p - vec3(0.,-3., 0. ), vec3(10., .1, 10.));\n    \n    float d3 = sdCapsule(p, vec3(0., 1., 0.), vec3(.0, -1., 0.), 1.2);\n    \n    float d4 = sdTorus(p - vec3(0., pulse, 0.), vec2(1.0, 0.2));\n    \n    //float d5 = sdPlane(p - vec3(0., 0., iTime * 100.), vec3(cos(iTime * 1.5) * .15, 1.,0.),-3.);\n    float d5 = opCheapBend(p);\n    float sk = 1.;\n    \n    float mi = min(d, d5);\n    \n    return mi == d ? vec4(.5,0.01,.01,d) : vec4(vec3(.1),d5);\n}\n\nvec4 RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\n    // Current marching distance\n\tfloat currentDistance=0.;\n    vec4 curr;\n    \n    for(int i=0; i < MAX_STEPS; ++i) {\n    \n        // March in the ray direction\n    \tvec3 p = rayOrigin + rayDirection*currentDistance;\n        \n        // Get direction to solid using the distance function\n        curr = GetDist(p);\n        float dS = curr.w;\n        \n        // Increase marching distance\n        currentDistance += dS;\n        \n        // Stop ray marching when max distance is surpassed \n        // or when the distance is very small\n        if(currentDistance>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec4(curr.xyz, currentDistance);\n}\n\nfloat IsInShadow(vec3 rayOrigin, vec3 rayDirection) {\n    \n    float currentDistance = 0.;\n    float res = 1.;\n    \n    for (int i = 0; i < 200; ++i) {\n\n        // Get direction to solid using the distance function\n        float dS = GetDist(rayOrigin + rayDirection*currentDistance).w;\n        \n        // Stop ray marching when max distance is surpassed \n        // or when the distance is very small\n        if(dS < 0.001) return 0.;\n        \n        res = min(res, 9.*dS/currentDistance );\n        \n        // Increase marching distance\n        currentDistance += dS;\n    }\n    return res;\n\n}\n\nvec3 GetNormal(vec3 p) {\n\tconst float h = 0.1; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*GetDist( p + k.xyy*h ).w + \n                      k.yyx*GetDist( p + k.yyx*h ).w + \n                      k.yxy*GetDist( p + k.yxy*h ).w + \n                      k.xxx*GetDist( p + k.xxx*h ).w );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n\n    // Ray from pixel to the scene origin\n    vec3 f = normalize(l-p);\n       \n    // Finding the ray direction\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n   \n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Moving uv's to the [0,1] range and correcting porportions\n    // using the aspect ratio\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= (iResolution.y/iResolution.x);\n\t//vec2 m = iMouse.xy/iResolution.xy;\n\n    float speed = iTime * 10.;\n    \n    float x = cos(iTime) * 3.;\n    vec3 ro = vec3(x, exp(abs(x) - 4.)*10. + 3.,20.);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 sceneOrigin = vec3(0.);\n    \n    vec3 rd = GetRayDir(uv, ro, sceneOrigin, 1. );\n    vec3 col = vec3(0);\n       \n    vec4 obj = RayMarch(ro, rd);\n    float d = obj.w;\n    \n    vec3 lightDir = normalize(vec3(0., 1., 2.));\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = refract(rd, n, .5);\n        \n        float shadow = IsInShadow(p + n*SURF_DIST*10., lightDir);\n        \n        //vec3 cr = texture(iChannel0, r).rgb;\n\n        float dif = dot(normalize(n), lightDir) * .5 + .5;\n        col = obj.xyz * dif * (shadow*.9 + .1);\n    } else {\n        col = vec3(.0, .0, .0);\n    }\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 187], [189, 189, 236, 236, 269], [271, 271, 310, 449, 540], [542, 542, 592, 592, 977], [979, 979, 1008, 1008, 1090], [1092, 1092, 1125, 1125, 1153], [1155, 1155, 1186, 1186, 1275], [1277, 1277, 1317, 1317, 1455], [1457, 1457, 1485, 1485, 1778], [1781, 1781, 1803, 1803, 2893], [2895, 2895, 2945, 2979, 3605], [3607, 3607, 3660, 3660, 4203], [4205, 4205, 4229, 4229, 4543], [4545, 4545, 4595, 4638, 4879], [4881, 4881, 4938, 5099, 6170]], "test": "untested"}
{"id": "NsKXRK", "name": "Interactive river", "author": "intrakits", "description": "I wanted to make the river i made earlier interactive.", "tags": ["simulation", "interactive", "refraction", "fluid", "river", "navier", "stokes"], "likes": 5, "viewed": 336, "published": 3, "date": "1634924295", "time_retrieved": "2024-07-30T18:54:07.925101", "image_code": "//Navier-Stokes reference:      https://www.shadertoy.com/view/tt3yzn\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    uv=fragCoord/iResolution.xy;\n    vec4 trans = texture(iChannel1,uv);\n    vec3 col = trans.xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURFACE_DIST 0.01\n#define AA 1\n\n\n\nfloat drawSphere(in vec2 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec2(.166));\n    \n}\n\nfloat cellTile(in vec2 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec2(.81, .62)));\n    c = min(c, drawSphere(p - vec2(.39, .2)));\n    \n    c = min(c, drawSphere(p - vec2(.62, .24)));\n    c = min(c, drawSphere(p - vec2(.2, .82)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec2(.48, .29)));\n    c = min(c, drawSphere(p - vec2(.06, .87)));\n\n    c = min(c, drawSphere(p - vec2(.6, .86)));\n    c = min(c, drawSphere(p - vec2(.18, .44)));\n        \n    return (c*4.);\n    \n}\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n   // p*=.00025;\n   //p+=iTime;\n    float f = 0.5000 * cellTile(p.xz);\n    p = m * p;\n    f += 0.2500 * cellTile(p.xz);\n    p = m * p;\n    f += 0.1666 * cellTile(p.xz);\n    p = m * p;\n    f += 0.0834 * cellTile(p.xz);\n    \n    return f;\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec3 lightPos = vec3(0,20,0);\nvec3 camPos = vec3(0,5,5.);\n\nconst float dt = 2.0f;\nconst float dx = 1.00f;\nconst float nu = 0.00001f;\n", "buffer_a_code": "vec2 GetDist(vec3 p, vec2 uv){\n    float box = dBox(p-vec3(0,0,-1), vec3(10,.1,1));\n    float off = fbm(p*.1+iTime*.1);\n    vec4 c = texture(iChannel2, p.xz/10.-vec2(-.5,-.5));\n    /*vec4 cCol;\n    cCol.rgb = .6 + .6 * cos(6.3 * atan(c.y,c.x)/(2.*3.14159) + vec3(0,23,21)); // velocity\n\tcCol.rgb *= c.w/5.; // ink\n\tcCol.rgb += clamp(c.z - 1., 0., 1.)/10.; // local fluid density\n    cCol.a = 1.;\n    cCol.rgb=vec3(smoothstep(.1,.2,length(cCol.rgb)));\n   */// off=smoothstep(.1,.3,off)*.1;\n    //float off2 = fbm(vec3(p.x*.1+iTime*.1,0,0));\n    //vec2 res = vec2(p.y-sin(p.z+iTime*4.)*.4-sin(p.x+iTime*4.)*.4,1);\n    vec2 res = vec2(p.y-off*c.w*5.-off,1);\n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd,vec2 uv){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p,uv);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p, vec2 uv){\n    //distance to point being analyzed\n    float d = GetDist(p, uv).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy, uv).x,\n         GetDist(p-e.yxy, uv).x,\n         GetDist(p-e.yyx, uv).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p, vec2 uv){\n    //position of the light source\n    \n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p, uv);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l, uv).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal, vec2 uv){\n//------------------\n    vec2 d = RayMarch(ro,rd, uv);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p, uv)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p, uv);\n    float angle = dot(n,vec3(0,1,0));\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n      //  uv.x*=.5;\n       // uv+=.5;\n        col=vec3(0,0.3,.5);\n        \n        vec3 op = texture(iChannel1,uv-vec2(noise(uv)*smoothstep(1.,.5,angle))).xyz;\n        col = mix(col,op,.03*smoothstep(.0,.1,length(op)));\n        //col*=refl*.3;\n        col*=vec3(fresnel);\n        col=min(col,vec3(.5));\n        //col+=vec3(0,0.,.6);\n        reflVal = 0.5;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n      //  col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n     float dist = length(p);\n     if(dist>1000.){\n         dist = 1000.;\n     }\n    return vec4(col,dist);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    \n    float time = iTime*.5;\n    float exp1 = cos(time);\n    float exp22 = pow(sin(time)+1.5,exp1);\n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + camPos+vec3(mo*3.,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    vec3 p = vec3(0);\n    uv=fragCoord/iResolution.xy;\n    vec3 n=GetNormal(p, uv);\n    vec3 refr = refract(rd,n,1./1.4);\n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal,uv);\n    float dist = col.a;\n    vec4 bounce = .3*reflVal*Render(ro,refr,reflVal,uv);\n    \n    \n\n \n    col.xyz += bounce.xyz;\n    vec4 bounce2 = reflVal*Render(ro,rd,reflVal,uv);\n    col.xyz += bounce2.xyz;\n    uv=fragCoord/iResolution.xy;\n    vec4 op = texture(iChannel1,uv);\n    float zTest;\n    if(op.a < dist){\n   // col = op;\n    }\n    //col = op;\n   // col.xyz=min(op.,col);\n    fragColor = vec4(col.xyz,1);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 GetDist(vec3 p){\n    p.y+=1.;\n    float box = dBox(p-vec3(0,0,-3), vec3(.5));\n    vec2 res = vec2(box,1);\n    vec2 box2 = vec2(dBox(p-vec3(2,0,-3), vec3(.5)),2);\n    res = colMin(res,box2);\n    vec2 box3 = vec2(dBox(p-vec3(-2,0,-3), vec3(.5)),3);\n    res = colMin(res,box3);\n    \n    vec2 box4 = vec2(dBox(p-vec3(2,0,0), vec3(.5)),2);\n    res = colMin(res,box4);\n    vec2 box5 = vec2(dBox(p-vec3(-2,0,0), vec3(.5)),3);\n    vec2 grnd = vec2(p.y+10.,4);\n    res = colMin(res,grnd);\n    res = colMin(res,box5);\n    \n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n   // vec3 lightPos = vec3(40,100,0);\n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff*10.;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 2.){\n        col *= vec3(0,1,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 3.){\n        col *= vec3(0,0,1);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 4.){\n        col *= vec3(.7,.3,0.);\n        //col*=refl*.4;\n       // col*=vec3(fresnel);\n        reflVal = 0.0;\n    }\n    else{\n      //  col=vec3(0,0.,0.);\n       // col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    float dist = length(p);\n     if(dist>1000.){\n         dist = 1000.;\n     }\n    return vec4(col,dist);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    float time = iTime*.5;\n    \n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + camPos+vec3(mo*3.,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal);\n    vec4 bounce = .3*reflVal*Render(ro,rd,reflVal);\n    col.xyz += bounce.xyz;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    //uv = (fragCoord)/iResolution.y;\n    \n    fragColor = vec4(col.xyz,1.0);\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// advection & boundary & control\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);  \n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // advection\n    vec4 a = texture(iChannel0, (fragCoord-o.xy*dt)/iResolution.xy);\n    fragColor = a;\n\n    \n    // interaction\n    vec2 mPos= vec2(iMouse.x,iResolution.y-iMouse.y);\n    if(sign(iMouse.z)==1.0f)\n    {\n        vec2 d = fragCoord-mPos;\n        float r = length(d);\n        vec2 d2 = mPos-abs(iMouse.zw);\n        float r2 = length(d2);\n        if(r2>0.0f)\n        {\n            fragColor.xy += d2/r2*exp(-r*r*0.01f);\n            fragColor.w += 0.5f*exp(-r*r*0.01f);\n            fragColor.w = min(fragColor.w, .8f);\n        }\n    }\n    \n    // boundary condition\n    if(fragCoord.x == 0.5f)\n    {\n        fragColor.xy = -e.xy;\n        fragColor.z = e.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.y == 0.5f)\n    {\n        fragColor.xy = -n.xy;\n        fragColor.z = n.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.x == iResolution.x-0.5f)\n    {\n        fragColor.xy = -w.xy;\n        fragColor.z = w.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.y == iResolution.y-0.5f)\n    {\n        fragColor.xy = -s.xy;\n        fragColor.z = s.z;\n        fragColor.w = 0.0f;\n    }\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// pressure poisson\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // float divergence of the velocity\n    float div = (e.x - w.x + n.y - s.y) / (2.0f * dx * dx);\n    \n    // one jacobi iteration\n    float a = 1.0f / ( dx * dx);\n    float p = 1.0f / ( -4.0f * a ) * ( div - a * (n.z + e.z + s.z + w.z));\n\n    fragColor = vec4(o.xy, p, o.w);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 128, 210, 405]], "test": "untested"}
{"id": "7syXzV", "name": "RGB-Tunnel II (126 chars)", "author": "hnh", "description": "Finite code - endless joy :) \nA variant of https://www.shadertoy.com/view/7dGXzK", "tags": ["simple", "tunnel", "short", "tweet", "golf"], "likes": 3, "viewed": 338, "published": 3, "date": "1634922014", "time_retrieved": "2024-07-30T18:54:09.223629", "image_code": "\nvoid mainImage(out vec4 o, vec2 u){\n//*\n// FabriceNeyret2: 126 chars\n   o += length(u= u/iResolution.x-.4) - o;\n   o *= 4. / exp(9.*fract(atan(u.xyxx, u.xxyx)/.393 + .6/o + iTime));\n\n// my first attempt: 129 chars\n//    o= 4.*length(u= u/iResolution.x-.4)\n//         *exp(-9.*fract(atan(u.xyxx, u.xxyx)/.393 - .6/length(u) - iTime));\n\n/*/\n// base variant, looks slightly nicer\n    u= (u - vec2(.5,.7)*iResolution.xy)/iResolution.y;\n    float lu= length(u);\n    o= 2.*lu*exp(-9.*fract(atan(u.xyxx, u.xxyx)*8./3.1415 + 1./lu + iTime));\n//*/\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 69, 541]], "test": "untested"}
{"id": "sdGXzV", "name": "River with refraction", "author": "intrakits", "description": "Having some more fun with refraction.", "tags": ["refraction", "water", "river"], "likes": 1, "viewed": 268, "published": 3, "date": "1634919148", "time_retrieved": "2024-07-30T18:54:10.197026", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    uv=fragCoord/iResolution.xy;\n    vec4 trans = texture(iChannel1,uv);\n    vec3 col = trans.xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURFACE_DIST 0.01\n#define AA 1\n\n\n\nfloat drawSphere(in vec2 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec2(.166));\n    \n}\n\nfloat cellTile(in vec2 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec2(.81, .62)));\n    c = min(c, drawSphere(p - vec2(.39, .2)));\n    \n    c = min(c, drawSphere(p - vec2(.62, .24)));\n    c = min(c, drawSphere(p - vec2(.2, .82)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec2(.48, .29)));\n    c = min(c, drawSphere(p - vec2(.06, .87)));\n\n    c = min(c, drawSphere(p - vec2(.6, .86)));\n    c = min(c, drawSphere(p - vec2(.18, .44)));\n        \n    return (c*4.);\n    \n}\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n   // p*=.00025;\n   //p+=iTime;\n    float f = 0.5000 * cellTile(p.xz);\n    p = m * p;\n    f += 0.2500 * cellTile(p.xz);\n    p = m * p;\n    f += 0.1666 * cellTile(p.xz);\n    p = m * p;\n    f += 0.0834 * cellTile(p.xz);\n    \n    return f;\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec3 lightPos = vec3(0,20,0);\nvec3 camPos = vec3(0,5,5);\n\nconst float dt = 2.0f;\nconst float dx = 1.00f;\nconst float nu = 0.00001f;\n", "buffer_a_code": "vec2 GetDist(vec3 p, vec2 uv){\n    float box = dBox(p-vec3(0,0,-1), vec3(10,.1,1));\n    float off = fbm(p*.1+iTime*.1);\n   \n    //float off2 = fbm(vec3(p.x*.1+iTime*.1,0,0));\n    //vec2 res = vec2(p.y-sin(p.z+iTime*4.)*.4-sin(p.x+iTime*4.)*.4,1);\n    vec2 res = vec2(p.y-off,1);\n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd,vec2 uv){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p,uv);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p, vec2 uv){\n    //distance to point being analyzed\n    float d = GetDist(p, uv).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy, uv).x,\n         GetDist(p-e.yxy, uv).x,\n         GetDist(p-e.yyx, uv).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p, vec2 uv){\n    //position of the light source\n    \n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p, uv);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l, uv).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal, vec2 uv){\n//------------------\n    vec2 d = RayMarch(ro,rd, uv);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p, uv)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p, uv);\n    float angle = dot(n,vec3(0,1,0));\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n      //  uv.x*=.5;\n       // uv+=.5;\n        col*=vec3(0,0.3,.5);\n        \n        vec3 op = texture(iChannel1,uv-vec2(noise(uv)*smoothstep(1.,.5,angle))).xyz;\n        col = mix(col,op,.06*smoothstep(.0,.1,length(op)));\n        //col*=refl*.3;\n        col*=vec3(fresnel);\n        //col+=vec3(0,0.,.6);\n        reflVal = 0.9;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n      //  col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n     float dist = length(p);\n     if(dist>1000.){\n         dist = 1000.;\n     }\n    return vec4(col,dist);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    \n    float time = iTime*.5;\n    float exp1 = cos(time);\n    float exp22 = pow(sin(time)+1.5,exp1);\n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + camPos+vec3(mo*3.,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    vec3 p = vec3(0);\n    uv=fragCoord/iResolution.xy;\n    vec3 n=GetNormal(p, uv);\n    vec3 refr = refract(rd,n,1./1.4);\n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal,uv);\n    float dist = col.a;\n    vec4 bounce = .3*reflVal*Render(ro,refr,reflVal,uv);\n    \n    \n\n \n    col.xyz += bounce.xyz;\n    vec4 bounce2 = reflVal*Render(ro,rd,reflVal,uv);\n    col.xyz += bounce2.xyz;\n    uv=fragCoord/iResolution.xy;\n    vec4 op = texture(iChannel1,uv);\n    float zTest;\n    if(op.a < dist){\n   // col = op;\n    }\n    //col = op;\n   // col.xyz=min(op.,col);\n    fragColor = vec4(col.xyz,1);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 GetDist(vec3 p){\n    p.y+=1.;\n    float box = dBox(p-vec3(0,0,-3), vec3(.5));\n    vec2 res = vec2(box,1);\n    vec2 box2 = vec2(dBox(p-vec3(2,0,-3), vec3(.5)),2);\n    res = colMin(res,box2);\n    vec2 box3 = vec2(dBox(p-vec3(-2,0,-3), vec3(.5)),3);\n    res = colMin(res,box3);\n    \n    vec2 box4 = vec2(dBox(p-vec3(2,0,0), vec3(.5)),2);\n    res = colMin(res,box4);\n    vec2 box5 = vec2(dBox(p-vec3(-2,0,0), vec3(.5)),3);\n    vec2 grnd = vec2(p.y+10.,4);\n    res = colMin(res,grnd);\n    res = colMin(res,box5);\n    \n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n   // vec3 lightPos = vec3(40,100,0);\n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff*10.;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 2.){\n        col *= vec3(0,1,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 3.){\n        col *= vec3(0,0,1);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 4.){\n        col *= vec3(.7,.3,0.);\n        //col*=refl*.4;\n       // col*=vec3(fresnel);\n        reflVal = 0.0;\n    }\n    else{\n      //  col=vec3(0,0.,0.);\n       // col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    float dist = length(p);\n     if(dist>1000.){\n         dist = 1000.;\n     }\n    return vec4(col,dist);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    float time = iTime*.5;\n    \n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + camPos+vec3(mo*3.,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal);\n    vec4 bounce = .3*reflVal*Render(ro,rd,reflVal);\n    col.xyz += bounce.xyz;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    //uv = (fragCoord)/iResolution.y;\n    \n    fragColor = vec4(col.xyz,1.0);\n}", "buffer_b_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 139, 334]], "test": "untested"}
{"id": "ssySzV", "name": "Mandelbrot Set GLSL", "author": "RubberDuck55", "description": "Mandelbrot set coded in GLSL", "tags": ["fractal"], "likes": 0, "viewed": 88, "published": 3, "date": "1634917724", "time_retrieved": "2024-07-30T18:54:11.104600", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid rotate(inout vec2 p,float angle,vec2 rotationOrigin)\n{\n    p -= rotationOrigin;\n    p *= mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    p += rotationOrigin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float modtime = sin(iTime/10.+4.71238)*15.+15.;\n    float tcubed = modtime*modtime*modtime;\n    \n    vec2 zv = vec2(0.729, 0.14);\n    vec2 uv = (fragCoord)/iResolution.xy / vec2(iResolution.y / iResolution.x, 1.) - vec2(0.5, 0);\n    rotate(uv, modtime/2., vec2(0.5, 0.5));\n    uv = vec2((uv.x-zv.x)/(tcubed+1.)+zv.x, (uv.y-zv.y)/(tcubed+1.)+zv.y);\n\n    vec2 mbv = vec2((uv.x*2.47-2.), (uv.y*2.24-1.12));\n    vec2 v = vec2(0);\n    int iter = 0;\n    int maxiter = int(modtime*10.+100.);\n    \n    while(v.x*v.x + v.y*v.y <= 4. && iter < maxiter){\n        float xtemp = v.x*v.x - v.y*v.y + mbv.x;\n        v = vec2(xtemp, 2.*v.x*v.y + mbv.y);\n        iter++;\n    }\n    \n    vec3 col = vec3(hsv2rgb(vec3(float(iter)/200.+0.66, 1., 1.)));\n    if(iter == maxiter) col = vec3(0);\n\n    //col = vec3(fract(uv.xy*17.), col.b);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssySzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [192, 192, 251, 251, 364], [366, 366, 423, 423, 1280]], "test": "untested"}
{"id": "7sGXzK", "name": "0_1_helloWorld", "author": "tomoe", "description": "A sample code for the book", "tags": ["ch0"], "likes": 0, "viewed": 243, "published": 3, "date": "1634911461", "time_retrieved": "2024-07-30T18:54:11.928398", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy/iResolution.xy;\n    fragColor = vec4(1.0, pos, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 139]], "test": "untested"}
{"id": "7sGGWd", "name": "Glowering Sun", "author": "z0rg", "description": "The image is inspired by this beautiful cover accompanying such a wonderful song https://www.youtube.com/watch?v=oxoqm05c7yA", "tags": ["zefzef"], "likes": 26, "viewed": 544, "published": 3, "date": "1634908900", "time_retrieved": "2024-07-30T18:54:12.885837", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+1.*pow(col, vec3(GLOW_POW));\n    //rgb += 2.*vec3(0.,.25,.3)*sat(sin(uv.y*355.-iTime*200.)-.5);\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 map(vec3 p)\n{\n    p.z += iTime;\n    vec2 acc = vec2(1000., -1.);\n    //acc = _min(acc, vec2(length(p)-1., 0.));\n    \n    float floor_ = -p.y;\n    float path = sin(p.z)*.5+sin(p.z*.5);\n    floor_ = floor_-acos(cos(clamp(p.x*2.+path, -1.57,1.57)))*.5;\n    acc = _min(acc,vec2(floor_, 1.));\n    \n    float floor2 = -p.y-.3;\n    acc = _min(acc, vec2(floor2, 2.));\n    \n    acc = _min(acc, vec2(-p.z+iTime+15., 3.));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < 200; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nvec3 rdr(vec2 uv)\n{\n    float stp = .001;\n    uv = round(uv/stp)*stp;\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.,-1.5,-10.);\n    vec3 ta = vec3(0.,-1.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 512);\n    if (res.y>0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        if (res.z == 1.)\n        {\n            vec2 gridth = vec2(0.005);\n            vec2 gridrep = vec2(0.5);\n            vec2 uvgrid = p.xz+vec2(0.,iTime);\n            uvgrid = mod(uvgrid+gridrep*.5, gridrep)-gridrep*.5;\n            float gridshp = min(_sqr(uvgrid, vec2(gridth.x, 1.)), _sqr(uvgrid, vec2(1.,gridth.y)));\n            col = mix(vec3(0.), (res.y/10.)*vec3(.5,.2,.3)*7./pow(res.y,.7), 1.-sat(gridshp*5./pow(res.y/10.,5.)));\n        }\n        if (res.z == 2.)\n            col = vec3(0.420,0.459,1.000)*2.;\n        if (res.z == 3.)\n        {\n            vec2 uvs = p.xy-vec2(0.,-1.);\n            col = vec3(0.396,0.251,0.196)+pow(texture(iChannel1, uvs*.1).x, 5.)*.5;\n            vec3 rgbsun = mix(vec3(1.000,0.388,0.369), \n            vec3(1.000,0.376,0.141), texture(iChannel1, uvs*8.).x);\n            col = mix(col, rgbsun, 1.-sat((length(uvs)-5.5)*400.));\n            float mount = -uvs.y-1.5-sin(uvs.x*.5)*.5-asin(sin(uvs.x))*.2-sin(uvs.x*.1)*.7;\n            col = mix(col, vec3(0.), 1.-sat(mount*400.));\n        }\n        float stpt = .05;\n        float tnoise = float(int(iTime/stpt))*stpt;\n        float rawnoise = texture(iChannel1, uv*2.+vec2(tnoise, sin(tnoise*1000.))).x;\n        col += .1*vec3(rawnoise);\n        col = col*.7+.5*pow(col*rawnoise, vec3(1.2));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n\n    vec3 col =  rdr(uv);\n    vec2 off = (vec2(1., -1.)/(iResolution.x*.8));\n    if (true) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34120, "src": "https://soundcloud.com/mayfruit/yu-utsu-sun", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 20\n#define GLOW_DISTANCE 0.1\n#define GLOW_POW 1.3\n\n#define sat(a) clamp(a, 0.,1.)\n#define PI 3.14159265\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n", "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+2.*pow(col, vec3(GLOW_POW));\n    rgb += 4.*vec3(0.,.25,.3)*sat(sin(uv.y*355.-iTime*200.)-.5);\n    fragColor = vec4(rgb,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGGWd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1044]], "test": "untested"}
{"id": "7dGXzK", "name": "RGB-Tunnel I (122 chars)", "author": "hnh", "description": "Finite code - endless joy :) \n", "tags": ["simple", "tunnel", "short", "tweet", "golf"], "likes": 6, "viewed": 295, "published": 3, "date": "1634906213", "time_retrieved": "2024-07-30T18:54:13.780446", "image_code": "\nvoid mainImage(out vec4 o, vec2 u){\n//*\n// FabriceNeyret2: 122 chars\n//  o+= length(u= u/iResolution.x-.4);  // works for me -> -2 (see comments)\n    o+= length(u= u/iResolution.x-.4) - o;\n    o= 1.-3.*o*fract(atan(u.xyxx, u.yxxx)/.785-.8/o-iTime);\n//  o= 1.-o*mod(atan(u.xyxx, u.yxxx)/.262-2.4/o-iTime,3.);  // -> -1 by Xor, slower\n\n// my first attempt: 123 chars\n//    o= 1.-3.*length(u= u/iResolution.x-.4)\n//            *fract(atan(u.xyxx, u.yxxx)/.785-.8/length(u)-iTime);\n            \n/*/\n// base variant, looks slightly nicer\n    u= (u - vec2(.5,.7)*iResolution.xy)/iResolution.y;\n    float lu= length(u);\n    o= 1. - 2.*lu*fract(atan(u.xyxx, u.yxxx)*4./3.1415 - 1.6/lu - iTime);\n//*/\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 146, 694]], "test": "untested"}
{"id": "NdySRV", "name": "0_0_helloWorld", "author": "tomoe", "description": "A sample code for the book", "tags": ["ch0"], "likes": 0, "viewed": 248, "published": 3, "date": "1634884641", "time_retrieved": "2024-07-30T18:54:14.544403", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdySRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 99]], "test": "untested"}
{"id": "NdKGzh", "name": "threshold blurr", "author": "ArmandB", "description": "blends similarly colored pixels", "tags": ["blurr"], "likes": 1, "viewed": 431, "published": 3, "date": "1634864402", "time_retrieved": "2024-07-30T18:54:15.389144", "image_code": "const int sampleRadius = 20; //the radius of the square to sample from (bascially blurriness)\nconst float threshold = 0.05; //the max delta for it to blend\n\nfloat avgCol(vec3 col){\n    return (col.x + col.y + col.z)/3.0;\n}\n\nvec3 fetch(ivec2 coord){\n    return texelFetch(iChannel0, coord, 0).xyz;\n}\n\n//returns color put in if the delta of the current pixel's color and the color to test is below a threshold\nvoid checkCol(in vec3 testingCol, in vec3 col, inout vec3 toAvg, inout vec3 successCount){\n    vec3 delta = vec3(abs(col.x-testingCol.x),abs(col.y-testingCol.y),abs(col.z-testingCol.z));\n    if (delta.x<threshold && delta.y<threshold && delta.z<threshold){\n        toAvg += testingCol;\n        successCount ++;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord*2.0);\n    vec3 col = fetch(iCoord);\n    col = col;\n    vec3 toAvg;\n    vec3 successCount;\n    vec3 testingCol;\n    \n    for (int x = sampleRadius/2; x > -sampleRadius/2; x--){\n        for (int y = sampleRadius/2; y > -sampleRadius/2; y--){\n            if (x == 0 && y == 0){continue;}\n            testingCol = fetch(ivec2(iCoord.x+x, iCoord.y+y));\n            checkCol(testingCol,col,toAvg, successCount);\n        }\n    }\n    \n    if (successCount.x != 0.0 && successCount.y != 0.0 && successCount.z != 0.0){ \n        toAvg /= successCount; \n        col = toAvg;\n    }\n\n    fragColor = vec4(col,0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 180, 180, 222], [224, 224, 248, 248, 298], [300, 408, 498, 498, 726], [728, 728, 785, 785, 1421]], "test": "untested"}
{"id": "7dVSWm", "name": "a very sine wavy scene", "author": "ArmandB", "description": "I no longer wish to see sin ever again", "tags": ["sine"], "likes": 2, "viewed": 225, "published": 3, "date": "1634863454", "time_retrieved": "2024-07-30T18:54:16.190003", "image_code": "float scale = 2.0;\n\nfloat noise(vec2 uv, int waves){\n    float n = 0.0;\n    for (int i = 0; i < waves; i++){\n        n += sin((uv.x+float(i))*pow(2.0,float(i))) + sin((uv.y+float(i))*pow(2.0,float(i)));\n    }\n    return n/float(waves+1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 100.0*scale;\n    uv -= iMouse.xy;\n    \n    float n = noise(uv/100.0, 2)*15.0-2.0;\n    float time = iTime*5.0;\n    \n    float wave = n;\n\n    vec3 col = vec3(0,0.5,0.8);\n    \n    float whitecap = sin(uv.x/8.0 + time/6.0)/2.0+0.5 + sin(uv.y/8.0 + time/6.0)/2.0+0.5;\n    if (whitecap < 0.9){\n        col += vec3(0.1);\n    }\n    \n    if (abs(sin(uv.x*100.0 - time) + sin(uv.y*100.0 - time)) + n > 0.1){\n        col = vec3(1);\n        \n        if (n >= 0.0 + clamp(sin(uv.x/3.0)+sin(uv.y/3.0)/2.0,0.0,1.0)){\n            col = vec3(0,n/15.0+0.3,0);\n            \n            if (n <= 1.0*(sin(uv.x)+sin(uv.y)/2.0 + 0.9)){\n                col = vec3(n/15.0+0.8,n/15.0+0.8,0);\n            }\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 52, 52, 239], [242, 242, 299, 299, 1121]], "test": "untested"}
{"id": "NdKXDm", "name": "Jelly Gateways", "author": "Tater", "description": "sss looks nice", "tags": ["3d", "raymarching", "sss", "bounce"], "likes": 43, "viewed": 788, "published": 3, "date": "1634862763", "time_retrieved": "2024-07-30T18:54:16.957950", "image_code": "#define MDIST 100.0\n#define STEPS 128.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\nvec3 rdg = vec3(0);\nvec3 hsv(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//iq box sdf\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat ebox(vec2 p, vec2 b){\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\n\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    float dc = min(rc.y,rc.z)+0.01;\n    return dc;\n}\nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } \n    else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } \n    else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } \n    else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\nvec3 map(vec3 p){\n    float t = -iTime*0.8;\n    vec3 rd2 = rdg;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    p.xz*=rot(t*0.3*pi/3.);\n    rd2.xz*=rot(t*0.3*pi/3.);\n    //p.xz*=rot(pi/4.);\n    //rd2.xz*=rot(pi/4.); \n    vec3 po = p;\n    float dsz = 0.45;\n    float m = 2.42-dsz;\n    float bs = 1.-dsz*0.5;\n    \n    //VERTIAL TRANSLATION\n    p.y+=t*m;\n    \n    //VERTIAL REP\n    float id1 = floor(p.y/m);\n    p.y = pmod(p.y,m);\n    \n    //ROTATE EACH LAYER\n    p.xz*=rot(id1*pi/2.);\n    rd2.xz*=rot(id1*pi/2.);\n\n    vec3 p2 = p; //dibox p1\n    \n    //Auxillary boxes positions\n    vec3 p3 = p;\n    vec3 rd3 = rd2;\n     \n    p3.xz*=rot(pi/2.);\n    rd3.xz*=rot(pi/2.);\n    vec3 p4 = p3; \n    \n    \n    //HORIZONTAL REP\n    p2.z = pmod(p2.z-m*0.5,m);\n    p4.z = pmod(p4.z-m*0.5,m);\n    \n    float cnt = 100.;\n    float id2 = idlim(p.z,m,-cnt,cnt);\n    float id3 = idlim(p3.z,m,-cnt,cnt);\n    p.z = lim(p.z,m,-cnt,cnt);\n    p3.z = lim(p3.z,m,-cnt,cnt);\n    \n    \n    //CLOSING ANIMATION \n    float close = max((id1-t)*1.,-2.);\n    float close2 = clamp(max((id1-t-0.3)*1.,-2.)*1.4,0.,1.);\n    close+=id2*0.025;\n    close = clamp(close*1.4,0.,1.);\n    close = easeOutBounce(close);\n    //close = 1.0-easeOutBounce(1.-close);\n\n    \n    \n    //CLOSING OFFSET\n    p.x = abs(p.x)-34.5*0.5-0.25*7.;\n    p.x-=close*34.5*0.52-0.055;\n    \n    p3.x = abs(p3.x)-36.5;\n\n    p.x-=((id1-t)*0.55)*close*2.4;\n    p3.x-=((id1-t)*0.55)*close2*2.4;\n    //WAVEY\n    p.x+=(sin(id1+id2-t*6.0)*0.18+4.)*close*2.4;\n    p3.x+=(sin(id1+id3-t*6.0)*0.18+4.)*smoothstep(0.,1.,close2)*2.4;\n    \n    \n    //BOX SDF\n    a = vec2(ebox(p,vec3(7.5*2.5,bs,bs))-0.2,id2);\n    \n    //AUXILLARY BOX\n    b = vec2(ebox(p3,vec3(7.5*2.5,bs,bs))-0.2,id3);\n    \n    a=(a.x<b.x)?a:b;\n    //ARTIFACT REMOVAL\n    float c = dibox(p2,vec3(1,1,1)*m*0.5,rd2)+.1;\n    //ARTIFACT REMOVAL 2\n    c = min(c,dibox(p4,vec3(1,1,1)*m*0.5,rd3)+.1);\n    \n\n    float nsdf = a.x;\n    \n    a.x = min(a.x,c); //Combine artifact removal\n    a.y = id1;\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,13,-5)*1.5;\n    if(iMouse.z>0.){\n    ro.yz*=rot(1.0*(iMouse.y/iResolution.y-0.2));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.5)+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n\n    vec3 d= vec3(0);\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.005){\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n\n    {\n        vec3 ld = normalize(vec3(0,45,0)-p);\n      \n        //sss from nusan\n        float sss=0.01;\n        for(float i=1.; i<20.; ++i){\n            float dist = i*0.09;\n            sss += smoothstep(0.,1.,map(p+ld*dist).z/dist)*0.023;\n        }\n        vec3 al = vec3(0.204,0.267,0.373);\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        float diff = max(0.,dot(n,ld));\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),40.0);\n        float fres = pow(abs(.7+dot(rd,n)),3.0);     \n        //ao from blackle \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n\n        col = al*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3+fres*mix(al,vec3(1),0.7)*0.4;\n        col+=sss*hsv(vec3(fract(d.y*0.5+d.y*0.1+0.001)*0.45+0.5,0.9,1.35));\n        col*=mix(ao,1.,0.85);\n        col = pow(col,vec3(0.75));\n    }\n    col = clamp(col,0.,1.);\n    //col = smoothstep(0.,1.,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 189, 189, 358], [359, 372, 399, 399, 486], [487, 487, 514, 514, 592], [594, 594, 646, 646, 692], [693, 693, 747, 747, 789], [791, 791, 826, 826, 935], [936, 936, 966, 966, 1310], [1311, 1311, 1328, 1328, 3316], [3317, 3317, 3335, 3335, 3463], [3465, 3465, 3522, 3522, 5302]], "test": "untested"}
{"id": "7dtSDf", "name": "Liquid Metalball", "author": "NoxWings", "description": "Just a simple animation of a \"metallish\" metaball to try out some reflections\n\nhttps://twitter.com/NoxWings/status/1451230562564415499", "tags": ["distortion", "metaball", "reflections", "metal", "liquid"], "likes": 49, "viewed": 1258, "published": 3, "date": "1634855572", "time_retrieved": "2024-07-30T18:54:17.913395", "image_code": "// Scene\n\n#define NUM_REFLECTIONS 5\n\nconst float SURF_HIT = 0.01;\nconst float farPlane = 20.0;\nconst int maxSteps = 128;\n\nHit ground(in vec3 p) {\n    return Hit(0, -(length(p-vec3(0, 198.8, 0)) - 200.));\n}\n\nHit metaBall(in vec3 p) {\n    vec3 q = p;\n    q.y += A(cos(animTime * PI) * 1.0 + 1.7, 0.0, 0.0, 4.0);    \n    if (animTime > 10.0) {\n        float t = animTime - 10.0;\n        q.y += -2.5 * t + 0.5 * 10.0 * t*t;\n    }\n    \n    \n    q.xz *= rot2D(q.y);\n    \n    vec3 scale = A(vec3(1), vec3(0.5, 1.0, 0.5), 10., 11.);\n    q *= scale;\n    \n    float r = 1.0;\n    r = A(r, 0.2, 10., 10.5);\n\n    float amp = 0.1;\n    amp = A(amp, sin(animTime * 30.0) * .05 + 0.1, 8.0, 10.);\n    amp = A(amp, 1., 10., 10.5);\n    \n    r += amp * sin(q.x * 8.0 + animTime * 5.0) * sin(q.y * 8.0) * sin(q.z * 8.0);\n    float sphere = sdSphere(q, r);\n    \n    float definition = A(0.7, 0.3, 10., 10.5);\n    sphere *= definition;\n    \n\n    return Hit(1, sphere);\n}\n\nHit ballGround(in vec3 p) {\n    float blend = A(0.5, 0.0, 0.0, 8.0);\n    blend = A(blend, 0.5, 10.0, 11.0);\n\n    return hsmin(metaBall(p), ground(p), blend);\n}\n\nHit map(in vec3 p) {\n    Hit h = ballGround(p);\n    return h;\n}\n\nvec3 mapNormal(in vec3 p, float surfHit) {\n    vec2 e = vec2(0.01, 0.0);\n \tfloat d = map(p).d;\n    return normalize(vec3(\n        d - map(p - e.xyy).d,\n        d - map(p - e.yxy).d,\n        d - map(p - e.yyx).d\n    ));\n}\n\n// -----------------------------------------------------------------------------\n\n// Regular sphere tracing\n// If maxSteps is hit it returns the closest hit found\nTraceResult trace(in vec3 ro, in vec3 rd, in float maxDistance, in int maxSteps) {\n    float d = 0.0;\n    float closestD = maxDistance;\n    Hit closest = Hit(-1, maxDistance);\n    \n    for (int i=0; i < maxSteps && d < maxDistance; i++) {\n    \tvec3 p = ro + rd * d;\n        Hit h = map(p);\n        \n        if (h.d < closest.d) {\n            closest = h;\n            closestD = d;\n        }\n        if (h.d <= SURF_HIT) return TraceResult(closest.id, d, ro, rd);\n        \n        d += h.d;\n    }\n    \n    if (d >= maxDistance) {\n        return TraceResult(-1, maxDistance, ro, rd);\n    }\n\n    return TraceResult(-2, closestD, ro, rd);\n}\n\n// Sphere tracing for reflections\n//\n// If maxSteps is hit it reports the maxDistance\n// It also tries to step away from the surface it is reflecting \n// (mostly eyeballing here to avoid artifacts with bent space around the ball)\nTraceResult traceReflection(Surface s, in float maxDistance, in int maxSteps) {\n    vec3 ro = s.p + s.n * SURF_HIT * 2.0;\n    vec3 rd = reflect(s.rd, s.n);\n    \n    float d = SURF_HIT * 2.0;\n    for (int i=0; i < maxSteps && d < maxDistance; i++) {\n    \n    \tvec3 p = ro + rd * d;\n        Hit h = map(p);\n        \n        if (h.d < SURF_HIT) {\n            return TraceResult(h.id, d, ro, rd);\n        }\n        \n        d += h.d;\n    }\n    \n    return TraceResult(-1, maxDistance, ro, rd);\n}\n\nSurface getSurf(TraceResult tr) { \n    vec3 p = tr.ro + tr.rd * tr.d;\n    vec3 n = mapNormal(p, SURF_HIT);\n    float ao = 0.0;\n    \n    return Surface(\n        tr.id, // material id\n        tr.d,  // distance\n        p,    // position\n        n,    // normal\n        ao,   // ambient occlusion\n        tr.rd    // view ray direction\n    );\n}\n\nstruct LightingResult {\n    Material mat;\n    vec3 color;\n};\n\n// On one iteration I used an environment map for reflections too\n// but currently I'm not using it, I love the simplicity of the real reflections\nvec4 sampleEnv(in samplerCube samp, vec3 dir) {\n    dir.xz = rot2D(270. * DEG2RAD) * dir.xz;\n    return sRGBToLinear(texture(samp, dir));\n}\n\nMaterial matFromSurface(Surface s) {\n    Material m;\n    m.albedo    = vec3(0.0);\n    m.emissive  = vec3(0.0);\n    m.roughness = 1.0;\n    m.metallic  = 0.0;\n    m.ao = s.ao;\n\n    if (s.materialId == -1) {\n        m.albedo    = vec3(0.01);\n        m.roughness = 0.85;\n    } else if (s.materialId == 0) {\n        m.albedo    = vec3(0.01);\n        m.roughness = 0.0;\n    } else if (s.materialId == 1) {\n        m.albedo = vec3(0.1);\n        m.roughness = 0.1;\n        m.metallic = 1.0;\n    } else {\n        m.emissive = vec3(1, 0, 1);\n    }\n    \n    return m;\n}\n\nvec3 calculateLights(Surface s, Material m) {\n    const int lights = 2;\n    Light l[2];\n    l[0].direction = normalize(vec3(1, 1, 0));\n    l[0].ambient = vec3(0.01);\n    l[0].color = vec3(3.0);\n    l[1].direction = normalize(vec3(-1, 1, 0));\n    l[1].ambient = vec3(0.01);\n    l[1].color = vec3(3.0);\n    \n    vec3 color = vec3(0);\n    for (int i=0; i < lights; i++) {\n        vec3 cont = BRDF(l[i], s, m);\n        cont = max(cont, vec3(0));\n        color += cont;\n    }\n    \n    return color;\n}\n\nLightingResult surfaceLighting(inout Surface s) {  \n    if (s.materialId == -1) {\n        // Sky\n        // This one is a bit hacky, \n        // I wanted some kind of dome with somewhat interesting colors so that reflections looked good\n        // I think the dome actually ended up looking somewhat similar to a SH but it was already working this way...\n        s.p.y += 1.1;\n        vec3 n = normalize(vec3(s.p.x, s.p.y, s.p.z));\n\n        Surface floorS = Surface(\n            0,\n            s.dist,\n            s.p,\n            vec3(0,1,0),\n            s.ao,\n            s.rd\n        );\n        Material floorM = matFromSurface(s);\n        vec3 floorColor = calculateLights(floorS, floorM);\n        \n        float floorBlend = S(-.2, 1.2, n.y);\n        \n        Material m = matFromSurface(s);\n        s.n = n;\n        m.roughness = 1.0;\n        \n        vec3 color = mix(floorColor, vec3(0), floorBlend);\n        \n        return LightingResult(m, color);\n    } else if (s.materialId == 0) {\n        // Floor\n        \n        Material m = matFromSurface(s);\n        vec3 floorColor = calculateLights(s, m);\n        \n        return LightingResult(m, floorColor);\n    } else if (s.materialId == 1) {\n        // Ball\n        // The floor part here is for the ball, surface parameter blending\n        // I should probably do something a bit more clear to blend surface parameters\n    \n        Surface floorS = Surface(\n            0,\n            s.dist,\n            s.p,\n            s.n,\n            s.ao,\n            s.rd\n        );\n        Material floorM = matFromSurface(floorS);\n        vec3 floorColor = calculateLights(floorS, floorM);\n        \n        Material m = matFromSurface(s);\n        vec3 ballColor = calculateLights(s, m);\n        \n        float blend = S(-1.1, -0.9, s.p.y); \n        vec3 color = mix(floorColor, ballColor, blend);\n        \n        m.metallic = mix(floorM.metallic, m.metallic, blend);\n        m.roughness = mix(floorM.roughness, m.roughness, blend);\n        \n        return LightingResult(m, color);\n    } else {\n        // error, unset material\n        Material m = matFromSurface(s);\n        vec3 color = calculateLights(s, m);\n        return LightingResult(m, color);\n    }\n}\n\nvec3 lighting(Surface s) {\n    LightingResult current = surfaceLighting(s);\n    vec3 color = current.color;\n    \n    const int reflections = NUM_REFLECTIONS;\n    float extinction = 1.0;\n    \n    for (int i = 0; i < reflections; i++) {\n        TraceResult rh = traceReflection(s, farPlane, maxSteps);\n        \n        s = getSurf(rh);\n        \n        float refAmount = (1.0 - current.mat.roughness);\n        extinction *= refAmount;\n        \n        current = surfaceLighting(s);\n        color += extinction * saturate(current.color) * 0.6;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 screen = uv * 2.0 - 1.0;\n    screen.x *= iResolution.x / iResolution.y;\n    \n    float xCam = A(0.0, -0.2, 0.0, 3.0);\n    xCam = A(xCam, -0.65, 0.0, 9.0);\n    xCam = A(xCam, -0.95, 8.5, 10.0);\n    xCam = A(xCam, -1.0, 10.0, 11.0);\n    \n    float yCam = A(-0.25, -0.08, 0.3, 1.0);\n    yCam = A(yCam, -0.3, 0.5, 2.5);\n    yCam = A(yCam, -0.08, 0.5, 3.0);\n    yCam = A(yCam, -0.06, 4.0, 10.0);\n    yCam = A(yCam, 0.15, 10.0, 10.5);\n    yCam = A(yCam, -0.25, 10.0, 11.0);\n    \n    float camDist = A(1.5, 5.5, 0.0, 2.0);\n    camDist = A(camDist, 3.5, 0.0, 3.0);\n    camDist = A(camDist, 4.0, 3.0, 5.0);\n    camDist = A(camDist, 4.5, 4.0, 7.0);\n    camDist = A(camDist, 3.5, 7.0, 10.0);\n    camDist = A(camDist, 2.0, 9.5, 10.5);\n    camDist = A(camDist, 2.5, 10.0, 11.);\n    \n    Camera cam = createOrbitCamera(\n        screen, \n        vec2(xCam, yCam) *  PI, \n        iResolution.xy, \n        60.0 * DEG2RAD, \n        vec3(0, 0.5, 0), \n        0.0, \n        camDist\n    );\n\n    vec3 ro = cam.position;\n    vec3 rd = cam.direction;\n    \n    TraceResult tr = trace(ro, rd, farPlane, maxSteps);\n    Surface s = getSurf(tr);\n    \n    vec4 col = vec4(lighting(s), 1.0);\n    col = ACESFilm(col);\n    col = linearTosRGB(col);\n    fragColor = col;\n}", "image_inputs": [], "common_code": "// Common / Framework stuff\n\n// -----------------------------------------------------------------------------\n// Basics / Math\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define animTime (mod(iTime, 11.))\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,animTime))\n\nfloat invLerp(float a, float b, float x) {\n    x = clamp(x, a, b);\n    return (x - a) / (b - a);\n}\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float DEG2RAD = PI / 180.;\n\nfloat saturate(in float x) { return clamp(x, 0.0, 1.0); }\nvec2 saturate(in vec2 x) { return clamp(x, vec2(0.0), vec2(1.0)); }\nvec3 saturate(in vec3 x) { return clamp(x, vec3(0.0), vec3(1.0)); }\nvec4 saturate(in vec4 x) { return clamp(x, vec4(0.0), vec4(1.0)); }\n\nmat2 rot2D(float angle) {\n    float ca = cos(angle), sa = sin(angle);\n    return mat2(ca, -sa, sa, ca);\n}\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) {\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\n// -----------------------------------------------------------------------------\n// Colors\n\nvec4 linearTosRGB(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec4 sRGBToLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n   \nvec4 ACESFilm(vec4 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n   \n// -----------------------------------------------------------------------------\n// Hits\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k) {\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\n\nstruct Hit {\n    int id;\n    float d; // means distance to surface\n};\n\nstruct TraceResult {\n    int id;\n    float d; // means distance traveled\n    vec3 ro;\n    vec3 rd; \n};\n\nHit hmin(in Hit a, in Hit b) { if (a.d < b.d) return a; return b; }\nHit hmax(in Hit a, in Hit b) { if (a.d > b.d) return a; return b; }\nHit hsmin(in Hit a, in Hit b, in float k) {\n    Hit h = hmin(a, b);\n    h.d = smin(a.d, b.d, k);\n    return h;\n}\nHit hsmax(in Hit a, in Hit b, in float k) {\n    Hit h = hmax(a, b);\n    h.d = smin(a.d, b.d, k);\n    return h;\n}\n\n// -----------------------------------------------------------------------------\n// Materials\n\nstruct Light {\n    vec3 direction;\n    vec3 ambient;\n    vec3 color;\n};\n\nstruct Surface {\n    int materialId;\n    float dist;\n    vec3 p;\n    vec3 n;\n    float ao;\n    vec3 rd;\n};\n    \nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n    float ao;\n};\n\n// -----------------------------------------------------------------------------\n// SDFs\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// Camera\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget) {\n    vec2 r = mouse;\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n    \n    vec3 position = target + vec3(0, height, 0) + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget ;\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction.yz = rot2D(-r.y) * direction.yz;\n    direction = lookAtMatrix(target - position) * direction;\n    \n    return Camera(position, direction);\n}\n\n// -----------------------------------------------------------------------------\n// PBR Implementation\n// - Lambert or Burley diffuse    \n// - Schlick Fresnel\n// - GGX NDF\n// - Smith-GGX height-correlated visibility function\n\n// Sources\n// \n// https://learnopengl.com/PBR/Lighting\n// https://google.github.io/filament/Filament.html\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation\n    \nvec3 F_Schlick_full(float HoV, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - HoV, 5.0);\n} \n\nvec3 F_Schlick(float HoV, vec3 f0) {\n    return F_Schlick_full(HoV, f0, vec3(1.0));\n} \n    \nfloat Diff_Lambert() {\n    return 1.0 / PI;\n}\n\nvec3 Diff_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    vec3 lightScatter = F_Schlick_full(NoL, vec3(1.0), vec3(f90));\n    vec3 viewScatter = F_Schlick_full(NoV, vec3(1.0), vec3(f90));\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat D_GGX(float NoH, float a) {\n    float a2 = a * a;\n    float f = (NoH * a2 - NoH) * NoH + 1.0;\n    return a2 / (PI * f * f);\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float a) {\n    float a2 = a * a;\n    float NoV2 = NoV*NoV;\n    float NoL2 = NoL*NoL;\n    float GGL = NoL * sqrt(NoV2 * (1.0 - a2) + a2);\n    float GGV = NoV * sqrt(NoL2 * (1.0 - a2) + a2);\n\treturn 0.5 / (GGL + GGV);\n}\n\nfloat GGX_Smith_Approx_Visibility(float NoV, float NoL, float a) {\n    return 1.0 / (2.0 * mix(2.0*NoL*NoV, NoL+NoV, a));\n}\n\nvec3 BRDF(Light l, Surface surf, Material mat) {\n    vec3 V = -surf.rd;\n    vec3 N = surf.n;\n    vec3 L = l.direction;\n    vec3 H = normalize(V + L);\n    \n    float NoV = max(dot(N, V), 0.0);\n    float NoL = max(dot(N, L), 0.0);\n    float NoH = max(dot(N, H), 0.0);\n    float HoV = max(dot(H, V), 0.0);\n    \n    vec3  albedo     = mat.albedo;\n    float roughness  = mat.roughness;\n    float a          = roughness * roughness;\n    float metallic   = mat.metallic;\n    float dielectric = 1.0 - metallic;\n    \n    // Constants\n    vec3 dielectricSpecular = vec3(0.04);\n    vec3 black = vec3(0);\n    \n    // Frenel term\n    vec3 F0 = mix(dielectricSpecular, albedo, metallic);\n    vec3 F  = F_Schlick(HoV, F0);\n    \n    // Normal distribution\n    float D = D_GGX(NoH, a);\n    \n    // Visibility term\n    //     should be equivalent to G / (4.0 * NoL * NoV)\n    //     but it doesn't look the same as https://www.shadertoy.com/view/tdKXR3\n    float Vis = V_SmithGGXCorrelated(NoV, NoL, a);\n    \n    // Specular BRDF Cook Torrance\n    vec3 specular = F * (Vis * D);\n    \n    // Lambert Diffuse\n    //     Should we scale by (1.0 - F) ?? gltf and learnopengl have it but filament doesn't\n    //     Also what about lambert 1/PI ?? https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n    //     PI might not be used in IBL only?\n    vec3 kD = vec3(1.0) - F;\n    vec3 c = mix(albedo * (1.0-dielectricSpecular), black, metallic);\n    vec3 diffuse = kD * (c / PI);\n    // vec3 diffuse = (1.0 - F) * diffuseColor * Diff_Burley(NoV, NoL, NoH, a);\n    \n    // Final Color\n    vec3 fakeGI = l.ambient * mat.albedo;\n    vec3 emissive = mat.emissive;\n    vec3 directLight = l.color * NoL * (diffuse + specular);\n    \n    //return vec3(Vis)*NoL;\n    return fakeGI + emissive + directLight;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 145, 145, 205], [207, 207, 232, 232, 946], [948, 948, 975, 975, 1107], [1109, 1109, 1129, 1129, 1172], [1174, 1174, 1216, 1216, 1394], [1478, 1559, 1641, 1641, 2195], [2197, 2427, 2506, 2506, 2918], [2920, 2920, 2953, 2953, 3261], [3325, 3472, 3519, 3519, 3611], [3613, 3613, 3649, 3649, 4171], [4173, 4173, 4218, 4218, 4668], [4670, 4670, 4719, 4719, 6883], [6885, 6885, 6911, 6911, 7456], [7459, 7459, 7516, 7516, 8808]], "test": "untested"}
{"id": "fsVSzy", "name": "Tundra", "author": "jarble", "description": "A snowy landscape with erosion and domain warping.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "tundra"], "likes": 10, "viewed": 426, "published": 3, "date": "1634852294", "time_retrieved": "2024-07-30T18:54:18.752153", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    \n    float f = 2.15; //change this number to change the spacing of the mountains \n    //Another interesting variation:\n    //float f = 2.15+(sin(uv.x/i1)+cos(uv.x/i1))*value1;\n    \n    float value = value1;\n    float amplitude = i1*value1;\n    float freq = i1/f;\n    float n1 = 0.;\n    vec2 noise2,noise1;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise1.yx-uv/freq);\n        noise1 = noise2-vec2(value)-noise1.yx*freq;\n        freq /= -f;\n        n1 = noise1.x+noise1.y;\n\n        value += n1*(amplitude-freq);\n\n        uv -= noise2.yx*freq;\n    }\n    \n    return value/(4.);\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    //uv /= 2.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result = fbm1(uv,oct,i1,result-result/i1);\n        oct /= 2;\n    }\n    return result;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/8.;\n    vec3 camPos = vec3(8., 2., 5.+sin(iTime/2.)/4.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)/2.-1.6;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 888], [890, 890, 918, 918, 1113], [1115, 1115, 1137, 1137, 1167], [1169, 1169, 1199, 1199, 1249], [1251, 1251, 1271, 1271, 1323], [1325, 1325, 1358, 1358, 1552], [1554, 1554, 1621, 1621, 1839], [2213, 2213, 2265, 2265, 2810], [2812, 2812, 2863, 2863, 3064], [3066, 3066, 3092, 3092, 3168], [3236, 3236, 3293, 3293, 5260]], "test": "untested"}
{"id": "fdKXDm", "name": "Transparency and Refraction", "author": "intrakits", "description": "Wanted to make cool refractions and translucent geometry.", "tags": ["transparency", "transparent", "translucent", "multipass"], "likes": 0, "viewed": 245, "published": 3, "date": "1634844751", "time_retrieved": "2024-07-30T18:54:19.970894", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv;\n    uv= fragCoord/iResolution.xy;\n    vec4 trans = texture(iChannel1,uv);\n    vec3 col = trans.xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 GetDist(vec3 p){\n    //p.z+=sin(iTime*.3+4.)*4.+4.;\n    float sphere = length(p)-.5;\n    vec2 res = vec2(sphere,1);\n    vec2 sphere2 = vec2(length(p-vec3(0,-1,0))-.5,1);\n    res = colMin(res,sphere2);\n    vec2 sphere3 = vec2(length(p-vec3(0,1,0))-.5,1);\n    res = colMin(res,sphere3);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    \n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal, vec2 uv){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n    \n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= texture(iChannel1,uv-vec2(noise(uv))).xyz;\n        //col*=refl;\n        //col*=vec3(fresnel);\n        reflVal = 0.9;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n      //  col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     float dist = length(p);\n     /*if(dist > 1000.){\n         dist = 1000.;\n     }*/\n    return vec4(col,d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv;// = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    \n    float time = iTime*.5;\n    float exp1 = cos(time);\n    float exp22 = pow(sin(time)+1.5,exp1);\n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + vec3(sin(iTime),0., 2.+cos(iTime));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    vec3 p = vec3(0);\n    vec3 n=GetNormal(p);\n    vec3 refr = refract(rd,n,1./1.4);\n    \n    float reflVal = 1.;\n    uv = fragCoord/iResolution.xy;\n    vec4 col = Render(ro,rd,reflVal,uv);\n    float dist = col.a/MAX_DIST;\n    vec4 bounce = .3*reflVal*Render(ro,refr,reflVal,uv);\n    \n    \n\n \n    col += bounce;\n   // vec4 bounce2 = reflVal*Render(ro,rd,reflVal,uv);\n    //col += bounce2;\n    \n    vec4 op = texture(iChannel1,uv);\n    float opD = op.a/MAX_DIST;\n    float zTest;\n    if(opD<=dist){\n        col=op;\n    }\n//    col = mix(col,op,clamp(0.,1.,abs(opD-dist)));\n\n   // col.xyz=min(op.,col);\n    fragColor = vec4(col.xyz,1);\n}", "buffer_a_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 GetDist(vec3 p){\n    float box = dBox(p-vec3(0,0,-3), vec3(.5));\n    vec2 res = vec2(box,1);\n    vec2 box2 = vec2(dBox(p-vec3(2,0,-3), vec3(.5)),2);\n    res = colMin(res,box2);\n    vec2 box3 = vec2(dBox(p-vec3(-2,0,-3), vec3(.5)),3);\n    res = colMin(res,box3);\n    \n    vec2 box4 = vec2(dBox(p-vec3(2,0,0), vec3(.5)),2);\n    res = colMin(res,box4);\n    vec2 box5 = vec2(dBox(p-vec3(-2,0,0), vec3(.5)),3);\n    res = colMin(res,box5);\n    \n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n   // vec3 lightPos = vec3(40,100,0);\n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\n\nvec4 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.1;\n    }\n    else if(d.y == 2.){\n        col *= vec3(0,1,0);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.9;\n    }\n    else if(d.y == 3.){\n        col *= vec3(0,0,1);\n        col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.9;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n      //  col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    float dist = length(p);\n/*     if(dist>1000.){\n         dist = 1000.;\n     }*/\n    return vec4(col,d);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    float time = iTime*.5;\n    float exp1 = cos(time);\n    float exp22 = pow(sin(time)+1.5,exp1);\n   // float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 0, 0, 0);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + vec3(sin(iTime),0., 2.+cos(iTime));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    float reflVal = 1.;\n    vec4 col = Render(ro,rd,reflVal);\n    vec4 bounce = .3*reflVal*Render(ro,rd,reflVal);\n    col.xyz += bounce.xyz;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    //uv = (fragCoord)/iResolution.y;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n#define AA 1\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec3 lightPos = vec3(0,0,30);\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 139, 285]], "test": "untested"}
{"id": "sdGXzy", "name": "Fab22 #inktober2021 \"open\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera.    line #18. try l / D distance of opening.\nSome artifacts remaining.", "tags": ["raymarching", "short", "inktober2021"], "likes": 16, "viewed": 335, "published": 3, "date": "1634842310", "time_retrieved": "2024-07-30T18:54:20.953268", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n#define door    max( a.x-1.,max(a.y-2.,a.z-.05))\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    float t=9.,h=0.,l, T=2.*iTime,d,f,k;                           // d,f,k: hit object id \n    vec3  R = iResolution,\n          D = normalize(vec3((U+U-R.xy)/R.y, -1.5)),               // ray direction\n          p = vec3(0,1,0), q, a,qd,                                // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(2,.1,0)/1e2*cos(1.3*T+vec3(0,11,0))+vec3(0,.05,0); \n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )                // --- draw the sharp cubes\n        q = p,\n        q.yz *= rot(.5-6.3*M.y), \n        q.xz *= rot(-6.3*M.x),\n        q.z -= T, l = floor(q.z/3.+.8)*3.-1.+T,  // ( thanks to spalmer for the debug ! )\n        q.z = mod(q.z+1.8,3.) - 1.8,\n        a = q, a.x++, a.xz *= rot( -2.*smoothstep(-1.,0.,l/3.+.5) ), a.x--, // --- doors\n        qd= a, a = abs(a), t = d = door,\n        t = min(t, k = length(qd - vec3(.8,.1,.1))-.1),            // door knob\n        q.z = abs(q.z)-.02,                                        // --- walls\n        a = abs(q), \n        t = min(t, max( min( q.z, f= q.y+2.),                      // wall+floor\n                       -door ) ),                                  // door hole\n        p += .25*t*D;                                              // step forward = dist to obj\n        \n                                                                   // --- materials\n    O *= t==d ? texture(iChannel2,qd.yx) // vec4(.6,.3,.1,1);      // doors\n       : t==k ? vec4(.7,.6,0,1) + 1e2*pow(.58*(qd.x+qd.y+qd.z),15.)// knob\n       : t==f ? texture(iChannel0,q.xz ) // * vec4(.2,.2,.5,1);    // floor\n       :        texture(iChannel1,q.xy )*.2+.8;                    // walls\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 166, 166, 1840]], "test": "untested"}
{"id": "ssGSzw", "name": "Fork Branchless deus0 598", "author": "deus0", "description": "Typical DDA algorithms used for voxel traversal use if statements to decide which axis to advance the ray along.  I have devised a modification that eliminates most of them, increasing the performance on GPUs, which do not cope well with branching code.", "tags": ["3d", "raymarching", "raycasting", "voxel"], "likes": 2, "viewed": 414, "published": 3, "date": "1634831912", "time_retrieved": "2024-07-30T18:54:21.857849", "image_code": "//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\nconst bool USE_BRANCHLESS_DDA = true;\nconst int MAX_RAY_STEPS = 64;\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c, float iTime) {\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 42.0 + 16.0 * sin(iTime * 0.1)));\n    return d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 0.5), -24.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, 0.1 * iTime);\n\trayDir.xz = rotate2d(rayDir.xz, 0.1 * iTime);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos, iTime)) continue;\n\t\tif (USE_BRANCHLESS_DDA) {\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\t\t/*bvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\t\tmask.x = b1.x && b2.x;\n\t\t\tmask.y = b1.y && b2.y;\n\t\t\tmask.z = b1.z && b2.z;*/\n\t\t\t//Would've done mask = b1 && b2 but the compiler is making me do it component wise.\n\t\t\t\n\t\t\t//All components of mask are false except for the corresponding largest component\n\t\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\t\t\n\t\t\tsideDist += vec3(mask) * deltaDist;\n\t\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\t\t}\n\t\telse {\n\t\t\tif (sideDist.x < sideDist.y) {\n\t\t\t\tif (sideDist.x < sideDist.z) {\n\t\t\t\t\tsideDist.x += deltaDist.x;\n\t\t\t\t\tmapPos.x += rayStep.x;\n\t\t\t\t\tmask = bvec3(true, false, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sideDist.y < sideDist.z) {\n\t\t\t\t\tsideDist.y += deltaDist.y;\n\t\t\t\t\tmapPos.y += rayStep.y;\n\t\t\t\t\tmask = bvec3(false, true, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec3 color;\n\tif (mask.x) {\n\t\tcolor = vec3(0.5);\n\t}\n\tif (mask.y) {\n\t\tcolor = vec3(1.0);\n\t}\n\tif (mask.z) {\n\t\tcolor = vec3(0.75);\n\t}\n\tfragColor.rgb = color;\n\t//fragColor.rgb = vec3(0.1 * noiseDeriv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 232, 232, 256], [259, 259, 290, 290, 386], [389, 389, 426, 426, 592], [594, 594, 626, 626, 737], [739, 739, 796, 796, 3071]], "test": "untested"}
{"id": "sdyXRy", "name": "GLSL Windows bug #75", "author": "FabriceNeyret2", "description": "On windows Angle I see black, white, white   ( black = bug )\nOn OpenGL          I see white, white, white", "tags": ["glsl", "bug", "angle"], "likes": 4, "viewed": 288, "published": 3, "date": "1634825941", "time_retrieved": "2024-07-30T18:54:22.619812", "image_code": "void mainImage(out vec4 O, vec2 u )\n{\n    vec2 U = u / iResolution.xy; \n    O = vec4(1);  \n    float N;\n    \n    if (U.x < .333) {\n        N = 1.,              // \",\" and pow(float): BUG on Windows \n        O *=  pow( N, 2.);\n    }\n    else if (U.x < .666) {\n        N = 1.;              // \";\" and pow(float): no bug\n        O *=  pow( N, 2.); \n    }\n    else { \n        N = 1.,              // ',' and pow(vec4): no bug\n        O *= pow( vec4(N), vec4(2));\n    }\n    \n    if ( (int(u) % (int(iResolution)/3) ) == 0 ) O=vec4(1,0,0,1); // red separators\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dySzG", "name": "Mandelbrot/Julia", "author": "guil", "description": "Use mouse to change the Julia view.", "tags": ["julia", "mandelbrot"], "likes": 13, "viewed": 421, "published": 3, "date": "1634818997", "time_retrieved": "2024-07-30T18:54:23.675988", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 10.5) // '.'\n\t{\n\t\tdata = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(n < 11.5) // '-'\n\t{\n\t\tdata = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\n//-----------------------------------------------------------------\n\nvec2 cinv( vec2 z)  { float d = dot(z,z); return vec2( z.x, -z.y ) / d; }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 1.2*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tvec2 c= p;\n\n\tvec2 z = p;\n\tfloat f = 4.;\n\tfloat g = 4.;\n\tif(p.x>.5){\n\t\tc = 1.2*(-iResolution.xy+2.0*iMouse.xy)/iResolution.y;\n\t\tz.x-= 1.5;\n\t\tz*=1.5;\n\t}\n\t\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\t\n\t\t//z=(cmul(c,cinv(z))+z)*.5;\n        z= csqr(z)+c;\n        vec2 zz = cinv(z);\n\t\tf = min( f, abs(dot(zz-c,zz+c) ));\n\t\tg = min( g, abs(dot(zz-p,zz-p)));\n\t}\n\t\n\tf = 1.0+log(f)/15.0;\n\tg = 1.0+log(g)/5.0;\n\t\n\tvec3 col = 1.-abs(vec3(g,f*g,f*f));\n\t\n\t\n\tcol = mix(col, vec3(1.),PrintValue((p-vec2(0.3,1.))/.07, c.x,5.,3.));\n\tcol = mix(col, vec3(1.),PrintValue((p-vec2(0.9,1.))/.07, c.y,5.,3.));\n\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dySzG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3176, 3176, 3197, 3197, 3249], [3250, 3250, 3280, 3280, 3335], [3336, 3336, 3358, 3358, 3407], [3410, 3410, 3467, 3467, 4137]], "test": "untested"}
{"id": "fsGSzy", "name": "Shredded Art 2", "author": "dr2", "description": "More endlessly self-shredding art (NFT rights reserved)", "tags": ["fractal", "kifs", "destruction", "banksy"], "likes": 19, "viewed": 423, "published": 3, "date": "1634809104", "time_retrieved": "2024-07-30T18:54:24.588548", "image_code": "// \"Shredded Art 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define FIX_LO_PIC  0  // = 1 to freeze image in shredded part of picture\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Hashfv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, pWid, hMax, hFrac, hCur, nCyc, tCyc, tFrac;\nint idObj;\nconst int mxStep = 200;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, sWid, fx;\n  dMin = dstFar;\n  q = p;\n  q.y -= hFrac - hCur;\n  d = PrRoundBoxDf (q, vec3 (pWid, hMax - hCur, 0.), 0.005);\n  q.y += hCur;\n  DMINQ (1);\n  sWid = 0.1;\n  q = p;\n  d = abs (q.x) - pWid;\n  q.y -= - hMax + hFrac - hCur;\n  fx = floor (q.x / sWid);\n  q.x -= sWid * (fx + 0.5);\n  q.xz = Rot2D (q.xz, 0.2 * pi * (Hashff (fx + 17.33 * nCyc) - 0.5) * (q.y - hCur));\n  d = max (d, PrRoundBoxDf (q, vec3 (0.5 * sWid - 0.008, hCur, 0.), 0.005));\n  q.x = p.x;\n  q.y += hCur - hMax;\n  DMINQ (1);\n  q = p;\n  q.y -= hFrac;\n  d = SmoothMax (PrRoundBoxDf (q, vec3 (pWid + 0.15, hMax + 0.15, 0.02), 0.02),\n     - PrBox2Df (q.xy, vec2 (pWid, hMax)), 0.02);\n  DMINQ (2);\n  q.z -= 0.01;\n  d = PrBoxDf (q, vec3 (pWid, hMax, 0.01));\n  DMINQ (3);\n  q = p;\n  d = 10. - q.z;\n  DMINQ (4);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FracDf (vec3 p)\n{  // (KIFS fractal simplified from leon's \"Taste of Noise 7\")\n  vec3 ip, a;\n  float s, gSize, f, w;\n  p.x += 0.02 * tFrac;\n  gSize = 3.;\n  ip = floor (p / gSize);\n  p -= (ip + 0.5) * gSize;\n  a = vec3 (0.1, 0.2, 0.3) + 0.5 * length (p) + 0.1 * p + ip;\n  w = 5. + 3. * sin (2. * pi * Hashfv3 (ip) + 0.7 * tFrac);\n  s = gSize;\n  f = 0.1;\n  for (int j = 0; j < 5; j ++) {\n    p.xz = abs (p.xz) - w * f;\n    p.yz = Rot2D (p.yz, a.x);\n    p.xz = Rot2D (p.xz, a.y);\n    p.yx = Rot2D (p.yx, a.z);\n    s = SmoothMin (s, PrSphDf (p, f), f);\n    f *= 0.5;\n  }\n  return 0.5 * s;\n}\n\nvec2 FracRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  int nStep;\n  dHit = 0.;\n  nStep = 0;\n  for (int j = VAR_ZERO; j < mxStep; j ++) {\n    d = FracDf (ro + dHit * rd);\n    ++ nStep;\n    if (d < 0.01 || dHit > dstFar) break;\n    dHit += d;\n  }\n  if (nStep == mxStep) nStep = 0;\n  return vec2 (dHit, float (nStep));\n}\n\nvec3 FracNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FracDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 FracCol (vec2 p)\n{\n  vec3 ro, rd, col, vn;\n  vec2 ff;\n  float dstFrac;\n  ro = vec3 (0., 0., -10.);\n  rd = normalize (vec3 (p, 5.));\n  ff = FracRay (ro, rd);\n  col = vec3 (0.);\n  if (ff.x < dstFar) {\n    ro += ff.x * rd;\n    if (ff.y > 0.) {\n      vn = FracNf (ro);\n      col = HsvToRgb (vec3 (mod (ff.y / float (mxStep) + 0.03 * tFrac, 1.), 0.9, 1.)) * vn.z * vn.z;\n      col = pow (clamp (col, 0., 1.), vec3 (0.7));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, t;\n  pWid = 1.;\n  hMax = 1.3;\n  hFrac = 0.7 * hMax;\n  t = fract (tCur / tCyc);\n  nCyc = floor (tCur / tCyc);\n  hCur = hMax * (0.1 + 0.85 * (1. - smoothstep (0.75, 0.8, t)) * smoothstep (0.1, 0.4, t)) - 0.15;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (1., 1., 1., 0.);\n      if (qHit.z < 0.) {\n        tFrac = tCur;\n#if FIX_LO_PIC\n        if (ro.y < hFrac - hMax) tFrac = nCyc * tCyc;\n#endif\n        qHit.y += 0.05;\n        if (PrBox2Df (qHit.xy, vec2 (pWid)) < -0.05) col4 = vec4 (FracCol (qHit.xy / pWid +\n           vec2 (1., 1.1)), -1.);\n      }\n    } else if (idObj == 2) {\n      col4 = vec4 (0.5, 0.4, 0.2, 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.6, 0.3, 0.1, 0.) * (0.8 + 0.2 * Fbm2 (64. * ro.xy));\n    } else if (idObj == 4) {\n      col4 = vec4 (0.4, 0., 0., 0.);\n      vn = VaryNf (32. * ro, vn, 1.);\n    }\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n      col *= 1. - smoothstep (0.2, 0.6, dstObj / dstFar);\n    } else col = col4.rgb;\n  } else {\n    col = vec3 (0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCyc = 15.;\n  t = smoothstep (0.15, 0.25, 0.5 - abs (fract (tCur / tCyc) - 0.5));\n  if (abs (uv.x) < 1.1 - 0.4 * t) {\n    az = 0.;\n    el = 0.;\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += pi * mPtr.y;\n    }\n    az = clamp (az, -0.6 * pi, 0.6 * pi);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * mix (vec3 (0., 0.9, -7.), vec3 (0., 0., -12.), t);\n    zmFac = 4.5;\n    dstFar = 100.;\n    ltDir = normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = vec3 (0.82);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGSzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[919, 919, 941, 941, 1762], [1764, 1764, 1797, 1797, 1980], [1982, 1982, 2003, 2003, 2258], [2260, 2260, 2283, 2344, 2852], [2854, 2854, 2887, 2887, 3169], [3171, 3171, 3193, 3193, 3449], [3451, 3451, 3474, 3474, 3898], [3900, 3900, 3935, 3935, 5218], [5262, 5262, 5318, 5318, 6569], [6571, 6571, 6604, 6604, 6631], [6633, 6633, 6665, 6665, 6765], [6767, 6767, 6800, 6800, 6889], [6891, 6891, 6937, 6937, 6984], [6986, 6986, 7031, 7031, 7123], [7125, 7125, 7170, 7170, 7208], [7210, 7210, 7234, 7234, 7351], [7353, 7353, 7389, 7389, 7595], [7597, 7597, 7627, 7627, 7740], [7774, 7774, 7798, 7798, 7835], [7837, 7837, 7861, 7861, 7921], [7923, 7923, 7947, 7947, 8012], [8014, 8014, 8038, 8038, 8150], [8152, 8152, 8177, 8177, 8363], [8365, 8365, 8386, 8386, 8541], [8543, 8543, 8572, 8572, 8784], [8786, 8786, 8825, 8825, 9077]], "test": "untested"}
{"id": "NsySRy", "name": "Fab21 #inktober2021 \"fuzzy\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera", "tags": ["raymarching", "short", "inktober2021"], "likes": 13, "viewed": 409, "published": 3, "date": "1634807100", "time_retrieved": "2024-07-30T18:54:25.353503", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n\n#define r  q.yz *= rot(.5-6.*M.y),                                 \\\n           q.xz *= rot(2.-6.*M.x)                                  \\\n\n#define C(l,w)  (                         /* rotated cube SDF */   \\\n        r,                                                         \\\n        a = abs(q)-(l),                                            \\\n        t = min(t, min(length(max(a.xy,a.xz)),length(max(a.xy,a.zy))) - (w) ) )\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    float t=9.,h=0.,b,c;                                           // b,c: hit object id \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),                  // ray direction\n          p = 9./R, q, a,                                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(.3*iTime+vec3(0,11,0)); \n     \n    for (c=1.; c > 0. && t > .01; c-=.01)                          // --- draw the fuzzy cube\n        q = p, t = 9., \n        r, C( 1.2, -.05 ), h += exp(-t*t), \n        p += .5*t*D;                                               // step forward = dist to obj\n\n    p = 9./R;\n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)                   // --- draw the sharp cubes\n        q = p, \n        c = C( 1.5, .04 ),\n        r,                                                         // ( frame of the fuzzy cube )\n        b = C( .8 , .03 ), \n        p += .2*t*D;                                               // step forward = dist to obj\n\n  O *= 1.5; t==c ? O *= vec4(.8,.9,1,1) : t==b ? O *= vec4(1,.9,.8,1) : O; // color scheme\n  O = max( O, .04*h*vec4(.8,1,.8,1) );                             // combine sharp + fuzzy\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsySRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 507, 544, 544, 1762]], "test": "untested"}
{"id": "7dKSWm", "name": "Twizzly Flower", "author": "SnoopethDuckDuck", "description": "messy code", "tags": ["raymarching", "template", "artofcode"], "likes": 14, "viewed": 502, "published": 3, "date": "1634790523", "time_retrieved": "2024-07-30T18:54:26.245119", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat myLength(vec2 u) {\n    float a = atan(u.x, u.y);\n    float b = .5 + .5 * cos(iTime);\n    float n = 3. - 18. * a * a;\n    u *= vec2(cos(n * a + iTime), sin(n * a + iTime));\n    return length(u * cos(a));\n}\n\nfloat GetDist(vec3 p) {\n   // float d = sdBox(p, vec3(1));\n    //d = mix(length(p) - 0.2, d, .5 );\n    float b = .5 + .5 * cos(iTime);\n    float a = atan(p.x,p.z);\n    float r1 = 0.9;\n    float r2 = 0.9;\n    float d1 = length(p.xz) - r1;\n    float d = p.y * (2. + cos(3. * p.y * b - 18. * a)) * myLength(vec2(d1,p.y)) - r2;   \n    \n    return 0.05 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    //float time\n    vec3 ro = vec3(6. * cos(0.314159 * iTime), 4., 6. * sin(0.2 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,1.,0), 2.2);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col -= .2 *vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 1.5 * texture(iChannel0,r / (0.5 + n)).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        float k = 0.25;\n        col.r += 0.15 + k * cos(10. * rf.y + 4. * iTime - 3.1415 / 2.);\n        col.g += 0.15 + k * cos(10. * rf.y + 4. * iTime);\n        col.b += 0.15 + k * cos(10. * rf.y + 4. * iTime + 3.1415 / 2.);\n        \n        vec3 col2 = col;\n        col.r *= col2.g;\n        col.g *= col2.b;\n        col.b *= col2.r;\n        \n        col /= 1.-pow(abs(sin(0.2 * length(p.xz) + .5 * p.y - 1. * iTime)),10.);\n        col *= (1.- 0.1 * length(p.xz)) * .25 * col;\n        \n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKSWm.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1559, 1588, 1588, 1808], [1811, 1811, 1835, 1835, 2021], [2023, 2023, 2046, 2121, 2377], [2379, 2379, 2413, 2413, 2624], [2626, 2626, 2650, 2650, 2839], [2841, 2841, 2891, 2891, 3082], [3084, 3084, 3102, 3102, 3200], [3203, 3203, 3260, 3260, 4735]], "test": "untested"}
{"id": "ssVXDm", "name": "Quaternion Newton Fractal Try", "author": "oneshade", "description": "It seems like differentiation and newton-raphson approximation is a bit more complicated with quaternions.", "tags": ["fractal", "quaternion", "iteration", "newton", "attempt", "naive"], "likes": 5, "viewed": 220, "published": 3, "date": "1634782298", "time_retrieved": "2024-07-30T18:54:27.171641", "image_code": "// vec4(a, b, c, d) = a + bi + cj + dk\nvec4 qmul(in vec4 p, in vec4 q) {\n    return vec4(p.x * q.x - p.y * q.y - p.z * q.z - p.w * q.w,\n                p.x * q.y + p.y * q.x + p.z * q.w - p.w * q.z,\n                p.x * q.z - p.y * q.w + p.z * q.x + p.w * q.y,\n                p.x * q.w + p.y * q.z - p.z * q.y + p.w * q.x);\n}\n\nvec4 qconj(in vec4 p) {\n    return vec4(p.x, -p.yzw);\n}\n\nvec4 qinv(in vec4 q) {\n    return qconj(q) / dot(q, q);\n}\n\n// https://www.shadertoy.com/view/ld23DV\nvec4 iBox(in vec3 ro, in vec3 rd, in vec3 size) {\n    vec3 n = ro / rd;\n    vec3 k = size / abs(rd);\n\n    vec3 t1 = -k - n;\n    vec3 t2 =  k - n;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) return vec4(-1.0);\n    return vec4(tN, -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz));\n}\n\nvec3 qNewton(in vec4 x) {\n    vec4 a = vec4(1.5, 2.0, 1.0, 0.25);\n    vec4 b = vec4(-1.0, 0.65, 2.0, -0.1);\n    vec4 c = vec4(-1.2, 1.25, 1.5, 1.3);\n\n    for (int i=0; i < 100; i++) {\n        vec4 xa = x - a, xb = x - b, xc = x - c;\n        vec4 f = qmul(xa, qmul(xb, xc));\n        vec4 df = qmul(xa + xb, xc) + qmul(xa, xb);\n        x -= qmul(f, qinv(df));\n    }\n\n    float distA = length(x - a);\n    float distB = length(x - b);\n    float distC = length(x - c);\n\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    if (distB < distA) color = vec3(0.0, 1.0, 0.0);\n    if (distC < min(distA, distB)) color = vec3(0.0, 0.0, 1.0);\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    fragColor = vec4(0.0);\n\n    // Generate camera ray\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    vec4 box = iBox(ro, rd, vec3(1.5));\n    if (box.x > 0.0) {\n        vec3 pos = ro + rd * box.x;\n        fragColor.rgb = qNewton(10.0 * vec4(pos, sin(iTime))) * max(0.0, dot(-rd, box.yzw));\n    }\n\n    // Tonemap\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 72, 72, 327], [329, 329, 352, 352, 384], [386, 386, 408, 408, 443], [445, 486, 535, 535, 847], [849, 849, 874, 874, 1488], [1490, 1490, 1545, 1545, 2430]], "test": "untested"}
{"id": "sdVXDm", "name": "newton fractal gaurav", "author": "gauravity", "description": "yuh", "tags": ["fractal"], "likes": 3, "viewed": 244, "published": 3, "date": "1634781872", "time_retrieved": "2024-07-30T18:54:28.062260", "image_code": "#define PI 3.1415926538\n\nvec2 mult(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x * b.y + a.y * b.x);\n}\n//https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\nfloat atan2(in float y, in float x)\n{\n    float s = (abs(x) > abs(y))?1.:0.;\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec2 powc(vec2 x, float n) {\n     float ang = atan2(x.y, x.x);\n     float modulus = length(x);\n     float newAng = n * ang;\n     float newMod = pow(modulus, n);\n     return newMod*vec2(cos(newAng), sin(newAng));\n     \n}\n\n\nvec2 conj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nfloat mod2(vec2 a)\n{\n    return a.x*a.x + a.y*a.y;\n}\n\nvec2 inv(vec2 x) {\n    return conj(x) / mod2(x);\n}\nvec2 f(vec2 x) {\n    return vec2(-1, 0) + powc(x, 3.);\n}\n\nvec2 fp(vec2 x) {\n  \n     return 3.0*powc(x, 2.); //+ 2.0*x + vec2(1.0, 0);\n}\n\nvec2 newt(vec2 x) {\n     return x - mult(f(x), inv(fp(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.x;\n    vec2 xy = uv*2.0 -vec2(1.0, iResolution.y/iResolution.x);\n    vec2 x = mult(xy*16.0 / pow(iTime, 2.), vec2(cos(iTime), sin(iTime)));\n    \n    vec3 col = vec3(152.,125.,124.)/255.;\n    for (int i =0; i < 100; i++){\n       float qTime = mod(iTime, 10.0);\n       if (qTime > 5.0) {\n       qTime = 10.0-qTime;\n       }\n       if (float(i) >= qTime*24.0) {\n           break;\n        }\n        x =newt(x);\n     \n    }\n    vec2 unity = vec2(cos(2.*PI/3.), sin(2.*PI/3.));\n    vec2 u2 = powc(unity, 2.);\n    vec2 o = vec2(1., 0.);\n    \n    float di = mod2(x - unity);\n    float dni = mod2(x - u2);\n    float dn1 = mod2(x - o);\n    if (dni < di && dni < dn1) {\n       col = vec3(160., 156., 176.)/255.;\n    }\n    else if (di < dn1) {\n       col = vec3(255.,193.,69.)/255.;\n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 52, 52, 113], [114, 222, 259, 259, 350], [352, 352, 380, 380, 571], [574, 574, 593, 593, 623], [625, 625, 645, 645, 677], [679, 679, 697, 697, 729], [730, 730, 746, 746, 786], [788, 788, 805, 805, 865], [867, 867, 886, 886, 928], [930, 930, 987, 1037, 1947]], "test": "untested"}
{"id": "sdVXWw", "name": "interesting colors thing", "author": "bigbadbob234", "description": "Trying to make a shepard-tone-like thing but with colors (consistently moving from red to blue).\nI'm new to playing with shadertoy, sorry about the ugly code.", "tags": ["colors", "colorshift", "shepardtone", "russellbeat", "inventing", "newcolors"], "likes": 1, "viewed": 112, "published": 3, "date": "1634770290", "time_retrieved": "2024-07-30T18:54:28.929940", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 uv = fragCoord;\n    \n    float t = 1.0;\n    float a = .5 + .5*cos(iTime*3. + uv.x - (uv.x*floor(uv.x/3.0)) + uv.y - (uv.y*floor(uv.y/3.0)));\n    float b1 = (iTime-floor(iTime));\n    float b = a; // + b1;\n    //(uv.x*floor(uv.x / 7.0)) \n    float h = b - (b * floor(b/t));\n    float h2 = exp(h)/2.71;\n    \n    vec3 col = vec3(1.-h2*2., (.5-h2)*(.5-h), h2*(abs(.25-h)+1.));\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 241, 743]], "test": "untested"}
{"id": "fsVXDm", "name": "Skyramp", "author": "Arrangemonk", "description": "i recon the skyramp for the shallow water shader was way to expensive", "tags": ["skyramp"], "likes": 1, "viewed": 288, "published": 3, "date": "1634764905", "time_retrieved": "2024-07-30T18:54:29.746756", "image_code": "    vec3 skytop= vec3(0.459,0.749,1.05);\n    vec3 skybottom = vec3(1.1,0.533,0.000);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n     vec3 col = mix(skybottom,skytop,sqrt(uv.y));\n     col *= col * 1.2 + .35;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 143, 143, 299]], "test": "untested"}
{"id": "fsKXDm", "name": "this so needs a chill track", "author": "Arrangemonk", "description": "forked this shader and made it to some sort of lavalamp", "tags": ["raymarch", "circle"], "likes": 22, "viewed": 604, "published": 3, "date": "1634762322", "time_retrieved": "2024-07-30T18:54:30.611445", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.1\nfloat HALF = 0.5;\nfloat PIH = 1.57079632679;\nfloat PI  = 3.14159265359;\nfloat TAU = 6.28318530718;\nfloat E = 2.71828182846;\nfloat RADIUS = 6.;\nvec4 sphere = vec4(0.,1.,0.,1.);\nvec3 lightpos = vec3(10.,10.,6.);\nfloat ballspeed = 1.;\nfloat cameraspeed = .3;\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat getdist(vec3 raypos)\n{\nfloat time = iTime * ballspeed;\n    float planedist = raypos.y - texture(iChannel0,raypos.xz *0.01).x*0.5;\n    float spheredist = length(raypos-vec3(0.,1.,0.))-1.;\n    float spheredist2 = length(raypos-vec3(0.,2.2 + 1. + 0.5 *sin(time * .25),sin(time * .5)))-.6;\n    float spheredist3 = length(raypos-vec3(0.,3.5 - sin(time * .125),-1.))-.2;\n    float dist = opSmoothUnion(planedist,spheredist,1.0);\n    dist =opSmoothUnion(dist,spheredist2,.5);\n    dist =opSmoothUnion(dist,spheredist3,.25);\n    //return dist;\n    return smoothstep(0.,3.,dist);\n}\nvec3 getnormal(vec3 p)\n{\n \treturn normalize(sphere.xyz-p);   \n}\nfloat getlight(vec3 p)\n{\n    vec3 lightdir = normalize(lightpos-p);\n    vec3 normal = getnormal(p);\n    float diff = dot(normal,lightdir);\n    return diff;\n}\nfloat raymarch(vec3 camera, vec3 dir)\n{\n\tfloat dist = 0.; \n    for(int i=0; i<MAX_STEPS; i++){\n   \t\tvec3 pos = camera+dir*dist;\n        float stepdist = getdist(pos);\n        dist+=stepdist;\n        if(dist>MAX_DIST || dist<MIN_DIST) break;\n    }\n    return dist;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*HALF)/iResolution.y;\n    vec3 col = vec3(0.);\n    float time = iTime * cameraspeed;\n\t\n    vec3 camera = vec3(sin(time -PIH) * RADIUS,2. +sin(time),cos(time -PIH) * RADIUS);\n    vec3 ray = vec3(sin(time) * uv.x + cos(time), uv.y - sin(time)*0.2,cos(time)*uv.x - sin(time));\n    float d = raymarch(camera, normalize(ray));\n    vec3 p = camera + ray*d;\n    float diff = getlight(p);\n    col+=vec3(1.-diff);\n    col = col *.5;\n    \n    \n    \n    fragColor = vec4(mix(vec3(.1,-.1,.3),vec3(1.5,.7,-.6),col),1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29458, "src": "https://soundcloud.com/lofi_girl/momentary?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 375, 375, 474], [475, 475, 503, 503, 1052], [1053, 1053, 1077, 1077, 1116], [1117, 1117, 1141, 1141, 1274], [1275, 1275, 1314, 1314, 1540], [1541, 1541, 1598, 1598, 2147]], "test": "untested"}
{"id": "fdVXWw", "name": "Fab20 #inktober2021 \"sprout\"", "author": "FabriceNeyret2", "description": "WIP. hard to unroll & grow small spir\n[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera\nref: [url]https://www.google.com/search?q=fern+sprout&&tbm=isch[/url]\nsee ref images at bottom", "tags": ["raymarching", "fern", "reproduction", "inktober2021"], "likes": 22, "viewed": 362, "published": 3, "date": "1634760415", "time_retrieved": "2024-07-30T18:54:31.448207", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n\n#define S(r,x,Y,z,R,w,l1) (                                        /* --- spiral   */    \\\n          a = atan(r.z,r.Y), d = 1.*length(vec2(r.Y,r.z)),                               \\\n          l1 = floor((d-a)/6.28)*6.28 + a,                 /* coord along spiral   */    \\\n          y = mod(d-a+1.,6.28)-1.-3.14,                    /* coord radial to spir */    \\\n          length(vec2(r.x,y)/R) - (w)  )                   /* spiral tube          */\n#define L(l,Y) (                                                   /* --- sub-spiral  */ \\\n          r = vec3( (mod(l,.628)-.314)*6.28, Y+3.14, 3.-abs(q.z) ),/* local frame  */    \\\n          S(r,x,y,z,vec2(4,1),.25,l1) )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,a,d,l,l1,y,v,s,c,cf;                                          \n    vec3  R = iResolution, C, N,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),                  // ray direction\n          p = 50./R, q,r,                                          // marching point along ray \n          M = iMouse.z > 0. ? vec3(2,.5,0)-6.*(iMouse.xyz/R -.5):  // mouse camera rot\n                              vec3(-.5*iTime,.6*sin(.2*iTime),0);\n    \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p, \n        q.yz *= rot(M.y),                                          // rotations\n        q.xz *= rot(M.x),\n        t = s = S(q,z,x,y,1.,.1+.2*l,l), l1=l,                          // fern spiral\n        v = atan(q.z,y),\n        t = min(t, max( L(l-iTime,y),                              // sub-spirals\n                        max(abs(q.z)-8.,min(l-9.43+6.28,-r.y+.05)) )), // clamping\n       // r.y+=1.+.2*l-3.14, t = min(t, length(r)-.1*l),           // spheres in local frame\n        t = max(t, l-9.43 ),                                       // spiral end\n        t = min(t, c = max(length(vec2(q.z,q.x+12.56))-2., q.y)),  // stem tube\n        t = min(t, cf= max( L(q.y/12.56+iTime,-q.x-12.56),         // sub-spirals\n                        max(max(q.y,abs(q.z)-8.),abs(r.y)-4.) )),  //   clamping\n        t = min(t, length(vec3(q.x-1.,q.y,2.-abs(q.z)))-2.),       // sphere bud\n\n        p += .5*t*D;                                               // step forward = dist to obj\n\n    if (t==c||t==cf) l = .95+q.y/12.56+iTime, v = -atan(q.z,q.x+12.56); else l -= iTime;\n    O *= (.7-.3*sin(10.*v))  * vec4(0,1,0,0) + texture(iChannel0,vec2(l,v)); // color scheme\n    if (t>.01) O = .3*texture(iChannel1,q);                        // background\n}\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[753, 753, 789, 789, 2548]], "test": "untested"}
{"id": "NdKXWm", "name": "Glacial valleys v10", "author": "jarble", "description": "A mountain terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "erosion"], "likes": 27, "viewed": 701, "published": 3, "date": "1634755376", "time_retrieved": "2024-07-30T18:54:32.289957", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    \n    float f = 2.15; //change this number to change the spacing of the mountains \n    //Another interesting variation:\n    //float f = 2.15+(sin(uv.x/i1)+cos(uv.x/i1))*value1;\n    \n    float value = value1;\n    float amplitude = i1*value1;\n    float freq = i1/f;\n    float n1 = 0.;\n    vec2 noise2,noise1;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise1.yx+uv/freq);\n        noise1 = noise2-vec2(value)-noise1.yx*freq;\n        freq /= -f;\n        n1 = noise1.x+noise1.y;\n\n        value += n1*(amplitude-freq);\n\n        uv += noise2.yx*freq;\n    }\n    \n    return value/3.5;\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    //uv /= 2.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result -= fbm1(uv,oct,i1,result/i1);\n        oct /= 2;\n    }\n    return result;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 887], [889, 889, 917, 917, 1106], [1108, 1108, 1130, 1130, 1160], [1162, 1162, 1192, 1192, 1242], [1244, 1244, 1264, 1264, 1316], [1318, 1318, 1351, 1351, 1545], [1547, 1547, 1614, 1614, 1832], [2206, 2206, 2258, 2258, 2803], [2805, 2805, 2856, 2856, 3057], [3059, 3059, 3085, 3085, 3161], [3229, 3229, 3286, 3286, 5233]], "test": "untested"}
{"id": "ssGSDm", "name": "Quaternion Kinematics", "author": "spalmer", "description": "simple demo of my wee quaternion library", "tags": ["animation", "quaternion", "bones"], "likes": 19, "viewed": 383, "published": 3, "date": "1634740940", "time_retrieved": "2024-07-30T18:54:33.175589", "image_code": "#define quat vec4\n\nconst quat qidentity = quat(0,0,0,1);\n\n// quaternion from 2 unit vectors\nquat qfromto(vec3 vsrc, vec3 vdst) // construct rotation that maps vsrc to vdst\n{\n    vec3 vhalf = vsrc + vdst;\n    vhalf *= length(vdst) / length(vhalf);\n    return quat(cross(vsrc, vhalf), dot(vsrc, vhalf));\n}\n\nquat qaxisangle(vec3 axis, float rad)\t// axis should be unit length!!\n{\n    rad *= .5;\n    return quat(sin(rad) * axis, cos(rad));\n}\n\n// conjugate\nquat qrev(quat q)\n{\n    q.w = -q.w;\n    return q;\n}\n\n// quaternion composition\nquat qmul(quat a, quat b)\n{\n\tvec3 va = a.xyz, vb = b.xyz;\n\treturn quat(b * a.w) - quat(cross(vb, va) - va * b.w, dot(va, vb));\n}\n\nquat qrenormalize(quat q)\n{\n    float l2 = dot(q, q);\n\treturn l2 == 1. ? q : .5 * (3. - l2) * q;\n}\n\nvec3 qrot(quat q, vec3 r)\n{\n\tvec3 axis = q.xyz;\n\tfloat w = q.w;\n\treturn 2.*((cross(axis,r) + r * w) * w + axis * dot(axis,r)) - r;\n}\n\n#if 0\n// unused here, enjoy\nquat qlog(quat q)\n{\n\tvec3 v = q.xyz;\n\tfloat l = length(v), s = 2. * atan(l / q.w) / l;\n\treturn quat(v * s, l);\n}\n\nquat qexp(quat v)\n{\n\tvec3 v3 = v.xyz;\n\tfloat a = dot(v3, v3);\n\tif (a < 1e-7) return qidentity;\n\ta = .5 * sqrt(a);\n\treturn quat(v3 * (sin(a) * .5 / a), cos(a));\n}\n\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\nquat qslerp(quat a, quat b, float i)\n{\n    // BUG yeah it'll go around the wrong long \n    // hyper-geodesic half the time, needs bit of work\n    if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qmul(a, qexp(qlog(qmul(qrev(a), b)) * i));\n}\n#endif\n\n// not super efficient,\n// just showing how to use this\n// mini quaternion library.\nvec3 QrbitCamera(vec2 a, vec3 d)\n{\n    a.y = clamp(a.y, -.5, .5);\n    const float pi = acos(-1.);  //3.141592\n    a *= pi;\n    quat q = qidentity;\n    q = qmul(q, qaxisangle(vec3(0,1,0), 2.*a.x));\n    q = qmul(q, qaxisangle(vec3(-1,0,0), a.y));\n    q = qrenormalize(q);\n    return qrot(q, d);\n}\n\nfloat dbox(vec3 p, vec3 e)\n{\n    p = abs(p); p -= e; \n    return all(lessThan(p, vec3(0)))\n     ? max(max(p.x, p.y), p.z)\n     : length(max(p, vec3(0)));\n}\n\nvec2 scene(vec3 e)\n{\n    e.xz = abs(e.xz); // duplicate scene into quadrants\n    //if (e.x > e.z) e.xz = e.zx;\n    e.zx -= 6.;\n    float dp = e.y + .1*(cos(9.*e.x) + cos(9.*e.z));\n    vec2 r = vec2(dp, 1);\n    vec3 p0 = vec3(0), p1;\n    float a = .2 * sin(iTime * 1.7);\n    quat q = qidentity, R = quat(normalize(vec3(.5,1,-.2)) * sin(a), cos(a));\n    for (int i = 8; i-- > 0; ) {\n        p1 = p0;\n        p0 += qrot(q, vec3(0,1,0));\n        float d = dbox(qrot(qrev(q), e - .5*(p0 + p1)), vec3(.1,.4,.1)) - .1;\n        if (d < r.x) r = vec2(d, i+2);\n        q = qmul(q, R);\n        q = qrenormalize(q);\n    }\n    return r;\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o = iMouse; // bonus: initializes o\n    vec3 e = iResolution,\n      d = normalize(vec3((p - .5 * e.xy) / e.y, 1));\n\to.xy /= e.xy; // last use of resolution, now e -> eye pos\n    if (abs(o.z) > 1.) // quality detail in lists and prior to click\n        o -= .5;\n    else\n        o.x += .1*sin(.2*iTime);    \n    d = QrbitCamera(o.xy, d); // quaternion look\n    d = normalize(d);\n    e -= e; e.y += 4.; // ray init    \n    float r = 24., t = 0.; // sphere caster\n    vec2 h;\n    for (int i = 40; \n      h = scene(e),\n      h.x *= .8,\n      t += h.x, e += h.x * d, // march\n      i-- > 0 && abs(h.x) >= .001 * t && t < r && e.y < 9.; );\n    o -= o - exp(-.06 * min(r, t)); // black fog\n    float g = (scene(e + vec3(.1)).x - scene(e).x) / length(vec3(.1)); // directed gradient\n    o.rgb *= clamp(g * .25 + .5, 0., 1.); // simple lighting\n    o.rgb *= cos(vec3(0,2,4)-1.+11.7*h.y) * .5 + .5; // albedo\n    if (e.y >= 9. || t > r) o *= 0.;\n    o = sqrt(o); // gamma\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 92, 173, 173, 303], [305, 305, 376, 376, 437], [439, 452, 471, 471, 503], [505, 531, 558, 558, 659], [661, 661, 688, 688, 759], [761, 761, 788, 788, 893], [1561, 1645, 1679, 1679, 1939], [1941, 1941, 1969, 1969, 2096], [2098, 2098, 2118, 2118, 2723], [2725, 2725, 2761, 2761, 3728]], "test": "untested"}
{"id": "NsGXWm", "name": "Recursive Box Filtering", "author": "paniq", "description": "demonstrating the well known effect of recursively box filtering a single impulse. each shape has the same volume and produces a B-spline window of increasing order", "tags": ["filter", "recursive", "box", "gaussian"], "likes": 7, "viewed": 362, "published": 3, "date": "1634717743", "time_retrieved": "2024-07-30T18:54:33.934559", "image_code": "const float R = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n\n    vec2 p = ((fragCoord / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n    float m = iResolution.x / R;\n    int x = int(iResolution.x + p.x * R * 2.0) / 2;\n    float h = float((x + 1000) % 2);\n    float y = texelFetch(iChannel0, ivec2(x, 0), 0).r;\n    \n    fragColor.rgb = vec3(mix(0.25, 0.75, step(y, p.y + 0.618*0.5)) - h * 0.1); \n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float triangular(int n, int N, int L) {\n    // triangular window\n    // 0 <= n <= N\n    // L can be N,N+1 or N+2\n    return 1.0 - abs(float(n - N/2) / float(L/2));    \n}\n\nfloat wendland(float x) {\n    // approximates the right half of a truncated gaussian\n    // x must be in the range 0..1\n    // first derivative is zero at x = 0\n    // first three derivatives are zero at x = 1\n    // the integral of the interval 0..1 is 1/3\n    float h = (1.0 - x);\n    h = h * h;\n    return h * h * (4.0 * x + 1.0);\n}\n\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);    \n    const int steps = 10;\n    int speed = 30;\n    int frame = (iFrame / speed) % steps;\n    int frame1 = ((iFrame - 1) / speed) % steps;\n    \n    if (frame == 0) {\n        if (fc.x == int(iResolution.x) / 2) {\n            fragColor = vec4(1.0);\n        } else {\n            fragColor = vec4(0.0);\n        }\n    } else if (frame1 == frame) {\n        fragColor = texelFetch(iChannel0, fc, 0);\n    } else {        \n     #if 1\n        const int R = 2;\n        float w = 0.0;\n        vec4 c = vec4(0.0);\n        for (int i = -R; i <= R; ++i) {\n            c += texelFetch(iChannel0, fc + ivec2(i, 0), 0);\n            w += 1.0;\n        }\n        fragColor = c / w;\n    #elif 1\n        const int R = 4;\n        const int N = R*2+1;\n        const int L = N+1;\n        float w = 0.0;\n        vec4 c = vec4(0.0);\n        for (int i = -R; i <= R; ++i) {\n            float a = triangular(i+R, N, L);\n            c += a*texelFetch(iChannel0, fc + ivec2(i, 0), 0);\n            w += a;\n        }\n        fragColor = c / w;\n    #else\n        // wendland filter kernel\n        const int R = 9;\n        float w = 0.0;\n        vec4 c = vec4(0.0);\n        for (int i = -R; i <= R; ++i) {\n            float a = wendland(float(abs(i)) / float(R+1));\n            c += a*texelFetch(iChannel0, fc + ivec2(i, 0), 0);\n            w += a;\n        }\n        fragColor = c / w;\n    #endif\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 464]], "test": "untested"}
{"id": "NdGSDm", "name": "Shredded Art", "author": "dr2", "description": "Pseudo-Banksyan endlessly self-shredding art (unsigned)", "tags": ["mandelbrot", "banksy", "modernism"], "likes": 13, "viewed": 274, "published": 3, "date": "1634715140", "time_retrieved": "2024-07-30T18:54:34.736415", "image_code": "// \"Shredded Art\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, pWid, hMax, hFrac, hCur, nCyc;\nint idObj;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, sWid, fx;\n  dMin = dstFar;\n  q = p;\n  q.y -= hFrac - hCur;\n  d = PrRoundBoxDf (q, vec3 (pWid, hMax - hCur, 0.), 0.005);\n  DMINQ (1);\n  sWid = 0.1;\n  q = p;\n  d = abs (q.x) - pWid;\n  q.y -= - hMax + hFrac - hCur;\n  fx = floor (q.x / sWid);\n  q.x -= sWid * (fx + 0.5);\n  q.xz = Rot2D (q.xz, 0.2 * pi * (Hashff (fx + 17.33 * nCyc) - 0.5) * (q.y - hCur));\n  d = max (d, PrRoundBoxDf (q, vec3 (0.5 * sWid - 0.008, hCur, 0.), 0.005));\n  DMINQ (1);\n  q = p;\n  q.y -= hFrac;\n  d = SmoothMax (PrRoundBoxDf (q, vec3 (pWid + 0.15, hMax + 0.15, 0.02), 0.02),\n     - PrBox2Df (q.xy, vec2 (pWid, hMax)), 0.02);\n  DMINQ (2);\n  q.z -= 0.01;\n  d = PrBoxDf (q, vec3 (pWid, hMax, 0.01));\n  DMINQ (3);\n  q = p;\n  q.z -= 10.;\n  d = - q.z;\n  DMINQ (4);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 MandCol (vec2 p)\n{\n  vec2 v, w;\n  float h;\n  p.x -= 0.85;\n  v = p;\n  h = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    w = v * v;\n    if (w.x + w.y > 4.) {\n      h = float (j + 1);\n      break;\n    } else v = p + vec2 (w.x - w.y, 2. * v.x * v.y);\n  }\n  return (h > 0.) ? HsvToRgb (vec3 (mod (h / 60. + 0.01 * nCyc, 1.), 1., 1.)) : vec3 (0.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 q;\n  float dstObj, t;\n  pWid = 1.;\n  hMax = 1.3;\n  hFrac = 0.7 * hMax;\n  t = fract (tCur / 15.);\n  nCyc = floor (tCur / 15.);\n  hCur = hMax * (0.1 + 0.8 * (1. - smoothstep (0.75, 0.8, t)) * smoothstep (0.1, 0.4, t)) - 0.15;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (1., 1., 1., 0.);\n      if (qHit.z < 0.) {\n        q = ro.xy;\n        q.y -= hFrac - 2. * hCur;\n        if (PrBox2Df (q, vec2 (pWid)) < -0.05) col4 = vec4 (MandCol (2. * q), 0.1);\n      }\n    } else if (idObj == 2) {\n      col4 = vec4 (0.4, 0.3, 0., 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.8, 0.5, 0.1, 0.) * (0.8 + 0.2 * Fbm2 (64. * ro.xy));\n    } else if (idObj == 4) {\n      col4 = vec4 (0., 0.4, 0., 0.);\n      vn= VaryNf (32. * ro, vn, 1.);\n    }\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col *= 1. - smoothstep (0.2, 0.6, dstObj / dstFar);\n  } else {\n    col = vec3 (0., 0., 0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  az = clamp (az, -0.6 * pi, 0.6 * pi);\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -12.);\n  zmFac = 4.5;\n  dstFar = 100.;\n  ltDir = normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGSDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[703, 703, 725, 725, 1506], [1508, 1508, 1541, 1541, 1724], [1726, 1726, 1747, 1747, 2002], [2004, 2004, 2027, 2027, 2355], [2357, 2357, 2392, 2392, 3520], [3564, 3564, 3620, 3620, 4646], [4648, 4648, 4680, 4680, 4780], [4782, 4782, 4815, 4815, 4904], [4906, 4906, 4952, 4952, 4999], [5001, 5001, 5046, 5046, 5138], [5140, 5140, 5185, 5185, 5223], [5225, 5225, 5249, 5249, 5366], [5368, 5368, 5404, 5404, 5610], [5612, 5612, 5642, 5642, 5755], [5789, 5789, 5813, 5813, 5850], [5852, 5852, 5876, 5876, 5936], [5938, 5938, 5962, 5962, 6074], [6076, 6076, 6101, 6101, 6287], [6289, 6289, 6310, 6310, 6465], [6467, 6467, 6496, 6496, 6708], [6710, 6710, 6749, 6749, 7001]], "test": "untested"}
{"id": "fsySWm", "name": "Wave Rave Cube", "author": "Tater", "description": "One of my previous subdivision shaders but simplified without the random parts. ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 77, "viewed": 2524, "published": 3, "date": "1634711496", "time_retrieved": "2024-07-30T18:54:35.601105", "image_code": "// Fork of \"Box Singularity\" by Tater. https://shadertoy.com/view/7dVGDd\n// 2021-10-20 06:09:34\n\n#define MDIST 350.0\n#define STEPS 200.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//iq box sdf\nfloat ebox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec3 rdg = vec3(0);\n//No Cell bounds SDF of the blocks\nfloat nsdf = 0.;\nbool rnsdf = false;\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime;\n    \n    bvec3 isEdge = bvec3(true);\n    // the domain of the fractal being generated\n    // will be modified in the iteration part\n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    vec3 dMini = dMin;\n    vec3 dMaxi = dMax;\n    \n    float id = 0.;\n    float seed = floor(t/8.)+0.2;\n    \n    float ITERS = 5.;\n    \n    vec3 dim = dMax - dMin;\n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n\n        vec3 divHash = vec3(\n            0.49,\n            0.501,\n            0.511\n        );\n        vec3 divide = divHash * dim + dMin;\n        // update the box domain\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        float pad = 0.01;\n        if(dMaxi.x>dMax.x+pad&&dMini.x<dMin.x-pad)isEdge.x=false;\n        if(dMaxi.y>dMax.y+pad&&dMini.y<dMin.y-pad)isEdge.y=false;\n        if(dMaxi.z>dMax.z+pad&&dMini.z<dMin.z-pad)isEdge.z=false;\n        \n        // id will be used for coloring and hash seeding\n        \n        vec3 diff = mix( -divide, divide, step( p, divide));\n        id = length(diff + 10.0);\n    \n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n    float b = 0.;\n    if(any(isEdge)) {\n    \n        float expand = 1.05+0.45*(sin(length(center+100.0)*0.35+t*3.0*pi/3.)*0.5+0.5);\n        //expand = 1.5; \n        if(isEdge.x){\n        dim.x+=abs(center.x*expand-center.x)*2.0;\n        center.x*=expand;\n        }\n        if(isEdge.y){\n        dim.y+=abs(center.y*expand-center.y)*2.0;\n        center.y*=expand;\n        }\n        if(isEdge.z){\n        dim.z+=abs(center.z*expand-center.z)*2.0;\n        center.z*=expand;\n        }\n        //id = 1.;\n    }\n    \n    vec3 edgeAxis = mix(dMin, dMax, step(0.0, rd));\n    vec3 dAxis = abs(p - edgeAxis) / (abs(rd) + 1E-4);\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    b= dEdge;\n    vec3 d = abs(center);\n    dim-=0.4;\n    float a = ebox(p-center,dim*0.5)-0.2;\n\n\n    nsdf = a;\n    a = min(a, b);\n\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec3 map(vec3 p){\n    float t = iTime;\n\n    vec3 po = p;\n    vec2 a = vec2(1);\n\n    vec3 scl = vec3(15,15,15);\n    vec3 rd2 = rdg;\n    p.yz*=rot(t*0.5*pi/3.);\n    rd2.yz*=rot(t*0.5*pi/3.);\n    p.xy*=rot(t*0.5*pi/3.);\n    rd2.xy*=rot(t*0.5*pi/3.);\n    a = blocks(p,scl,rd2)+0.01;\n    \n   \n    a.x = max(box(p,vec3(scl*1.3)),a.x);\n    \n\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11.5,-20)*1.8;\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n   // else ro.xz*=rot(t*0.3);\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec3 d = vec3(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(abs(d.x)<0.0001||i==STEPS-1.){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,0.9,-0.9));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y+t*10.0/12.0)*0.6-0.2,e*1.5,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        \n        //lighting EQs from @blackle\n        float spec = length(sin(r*5.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*0.9;\n        \n        float diff = length(sin(n*2.)*.5+.7)/sqrt(3.);\n        \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n        col = al*diff+pow(spec,5.0)*fres*diff*vec3(1.000,0.878,0.792);\n        col*=pow(ao,0.4);\n        \n    }\n    //col = pow(col,vec3(0.99));\n    vec3 bg = mix(vec3(0.345,0.780,0.988),vec3(0.424,0.059,0.925),length(uv));\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n/*\n#define AA 2.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            rdg = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsySWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 263, 330, 330, 369], [370, 370, 390, 390, 461], [462, 462, 483, 483, 535], [536, 536, 562, 562, 621], [622, 635, 665, 665, 752], [754, 754, 784, 784, 887], [980, 980, 1019, 1019, 3192], [3194, 3194, 3211, 3211, 3555], [3556, 3556, 3574, 3574, 3702], [3703, 3703, 3760, 3760, 5490]], "test": "untested"}
{"id": "NsyXWw", "name": "Desert mesas v4", "author": "jarble", "description": "A desert terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["terrain", "fbm", "mountain", "desert", "erosion", "mesa"], "likes": 15, "viewed": 312, "published": 3, "date": "1634702411", "time_retrieved": "2024-07-30T18:54:36.446842", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    float value = value1;\n    float amplitude = i1*value1;\n    float freq = i1/2.;\n    float n1 = 0.;\n    vec2 noise2;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise2.yx+uv/(freq));\n        vec2 noise1 = noise2-value;\n        freq /= 2.15;\n        n1 = noise1.x+noise1.y;\n\n        value += n1*(amplitude-freq);\n\n        uv += (noise2.yx)*freq;\n    }\n    \n    return -value;\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    uv /= 2.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result += fbm1(uv,oct,i1,result/i1);\n        oct /= 2;\n    }\n    return result/16.;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 683], [685, 685, 713, 713, 904], [906, 906, 928, 928, 958], [960, 960, 990, 990, 1040], [1042, 1042, 1062, 1062, 1114], [1116, 1116, 1149, 1149, 1343], [1345, 1345, 1412, 1412, 1630], [2004, 2004, 2056, 2056, 2601], [2603, 2603, 2654, 2654, 2855], [2857, 2857, 2883, 2883, 2959], [3027, 3027, 3084, 3084, 5031]], "test": "untested"}
{"id": "ssVXDD", "name": "Gaussian Kernel Visual", "author": "oneshade", "description": "For a personal website I'm working on. Maybe I'll share it in the future :)", "tags": ["math", "graph", "gaussian", "kernel", "visualize"], "likes": 16, "viewed": 210, "published": 3, "date": "1634696784", "time_retrieved": "2024-07-30T18:54:37.296570", "image_code": "#define draw(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n    float PI = 3.14159265;\n\n    uv.y += 1.0;\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5), vec4(0.0, 0.0, 1.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5), vec4(0.0, 0.0, 1.0, 1.0));\n\n    // Subgrid\n    draw(abs(mod(uv.x + 0.125, 0.25) - 0.125) + 0.001, vec4(0.75, 0.75, 1.0, 1.0));\n    draw(abs(mod(uv.y + 0.125, 0.25) - 0.125) + 0.001, vec4(0.75, 0.75, 1.0, 1.0));\n\n    // Axes\n    draw(abs(uv.x) - 0.002, vec4(1.0, 0.0, 0.0, 1.0));\n    draw(abs(uv.y) - 0.002, vec4(1.0, 0.0, 0.0, 1.0));\n\n    // Filter width or \"blurriness\"\n    float w = iMouse.z > 0.0 ? abs((iMouse.x - 0.5 * iResolution.x) / iResolution.y * 4.0) : 1.125;\n\n    // Draw the function\n    float t = uv.x / w;\n    float norm = w * sqrt(PI) / 2.0;\n    float y = exp(-t * t) / norm;\n    float dydx = -2.0 * t / w * exp(-t * t) / norm;\n    draw(abs(uv.y - y) / sqrt(1.0 + dydx * dydx) - 0.005, vec4(0.6, 0.0, 0.8, 1.0));\n    draw((uv.y - y) / sqrt(1.0 + dydx * dydx) - 0.005, vec4(0.6, 0.0, 0.8, 0.5));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 144, 144, 1293]], "test": "untested"}
{"id": "7dVXDD", "name": "truchet 3d -basic", "author": "jorge2017a2", "description": "truchet 3d -basic", "tags": ["3d", "basic", "truchet"], "likes": 8, "viewed": 235, "published": 3, "date": "1634696470", "time_retrieved": "2024-07-30T18:54:38.071499", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//referencia\n//https://www.youtube.com/watch?v=2R7h76GoIJM ....Art Code\n//https://www.shadertoy.com/user/BigWIngs\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat Hash21(vec2 p)\n{   p=fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.26);\n    return fract(p.x*p.y);\n}\n\nvec4 truchet( in vec2 uv )\n{   uv= rotatev2(uv, radians(45.0));\n    vec3 col=vec3(0.0);\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n    float n=Hash21(id); //rango 0.0 a 1.0\n    float width=0.1;\n\n    if(n<0.5) gv.x*=-1.0;\n\n    //----------\n    /// Tip Shane....9/jun/2021\n    float d=abs(gv.x + gv.y)*.7071; // Diagonal line.\n    gv = abs(gv) - .5; // Corners.\n    d = min(d, abs(gv.x + gv.y)*.7071); \n    //----------\n    float  mask= d-width;\n    float r = pow(1.0-sqrt( d),1.5 );\n    float g = pow(1.0-sqrt( d),1.5 );\n    float b = 1.0*(r+g);\n    col+=vec3(r,g-0.8,b-0.8)*mask;\n    return vec4(col,mask);\n}\n \nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    vec3 pp=p;\n    vec4 t1= truchet(p.xy*0.65);\n    float  d1=sdBox( p, vec3(20.0,20.0,1.0) );\n    \n    vec4 t2= truchet(p.xy*0.65);\n    float d2=sdBox( p-vec3(0.0,0.0,10.0), vec3(20.0,20.0,1.0) );\n    \n    \n    float inter1= intersectSDF( d1,t1.w);\n    float inter2= intersectSDF( d2,t2.w);\n    \n    res =opU3(res, vec3(inter1,1.0,-1.0));\n    res =opU3(res, vec3(inter2,2.0,-1.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n         vec3 r = reflect(rd, norm);\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh+=occlusion(hit,r);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}    \n    \n        \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, 20.0 ); light_color2 =vec3( 1.0 ); \n    vec3 ro=vec3(0.0,7.0,-10.0+5.0*sin(iTime));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1-=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n   \n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};   \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[575, 575, 607, 607, 691], [693, 737, 784, 784, 811], [812, 812, 855, 855, 882], [883, 883, 931, 931, 959], [960, 1025, 1059, 1059, 1155], [1156, 1156, 1190, 1190, 1281], [1282, 1282, 1316, 1316, 1407], [1408, 1408, 1442, 1442, 1537], [1539, 1539, 1561, 1561, 1648], [1650, 1650, 1678, 1678, 2265], [2268, 2268, 2293, 2293, 2777], [2779, 2779, 2803, 2803, 2965], [2967, 2967, 3016, 3016, 3683], [3685, 3685, 3721, 3721, 3966], [3968, 3968, 3995, 3995, 4012], [4014, 4014, 4050, 4050, 4142], [4143, 4143, 4189, 4189, 4314], [4316, 4316, 4353, 4353, 4629], [4631, 4631, 4698, 4698, 4975], [4977, 4977, 5060, 5060, 6059], [6062, 6062, 6155, 6155, 6285], [6287, 6287, 6319, 6319, 6516], [6519, 6519, 6612, 6612, 6783], [6785, 6785, 6816, 6816, 7415], [7417, 7417, 7443, 7443, 7553], [7555, 7555, 7613, 7613, 7665], [7667, 7667, 7724, 7724, 8278]], "test": "untested"}
{"id": "7dKXDW", "name": "Color Experiment 001", "author": "darknoon", "description": "some casual triangles", "tags": ["color"], "likes": 2, "viewed": 287, "published": 3, "date": "1634678539", "time_retrieved": "2024-07-30T18:54:38.870362", "image_code": "\n// via iq\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 c0 = vec3(0.63, 0.5, 0.5);\nvec3 c1 = vec3(0.7, 0.8, 0.5);\nvec3 c2 = vec3(0.1, 0.1, 0.7);\n\n\nconst float PI = 3.14159;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat sinc( float x, float k )\n{\n    float a = PI*(k*x)+PI;\n    return saturate(sin(a) / x);\n}\n\n// cite https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n  const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nmat2 rotation(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n    \n\nvoid mainImage( out vec4 result, in vec2 fragCoord )\n{\n    \n    result.rgb = c2 * 0.5;\n    \n    float tile = 18.0;\n    float sharp = 2.0 / iResolution.x * tile;\n    \n\n    // iterate neighbors\n    for (int i=-2; i<=2; i++) {\n    for (int j=-2; j<=2; j++) {\n        vec2 uv = fragCoord/iResolution.xy * vec2(1.0, iResolution.y / iResolution.x);\n\n        // get grid id of current object\n        ivec2 id = ivec2(floor(uv*tile) + vec2(i,j));\n        vec2 idf = vec2(id) / tile;\n\n        uv = fract(uv * tile);\n        // account for coord in neighborhood\n        uv -= vec2(i,j);\n\n\n        vec2 tri = vec2(0.6, 0.8 + 0.5*sin(iTime));\n        float rndg = 0.1234;\n\n        // TODO: rotation matrix!\n\n        // offset even rows\n        float off = id.y % 2 == 0 ? 1.0/3.0 : 0.0;\n        // tile\n        vec2 ctr = 0.5 + vec2(off, 0.0);\n        float r = 0.125;\n        \n        uv = rotation(PI / 4.0 + sin(idf.x + iTime)) * (uv - 0.5);\n        \n        //float dist = length(uv-ctr) - r;\n        float dist = sdTriangleIsosceles(uv + vec2(off, 0.0), tri) - rndg;\n        \n        \n\n        float a = sinc(dist * 22.0, 2.0);\n        float a_ = 1.0 - a;\n        \n        vec3 col = id.x % 2 == 0 ? c0 : c1;\n        vec3 other = mix(hash(uvec3(id.xyx)), c2, 0.7);\n        col = mix(col, other, 1.0 - 2.0*idf.y);\n\n        // source-over\n        result.rgb = result.rgb * a_ + col.rgb * a;\n        result.a   = result.a * a_ + a;\n    }}\n\n    // Output to screen\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKXDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 11, 62, 62, 370], [496, 496, 521, 521, 554], [556, 556, 588, 588, 650], [652, 698, 720, 720, 894], [897, 897, 921, 921, 988], [995, 995, 1049, 1049, 2450]], "test": "untested"}
{"id": "ssGXWD", "name": "colorblinds", "author": "_samuelcho_", "description": "color blinds", "tags": ["simple"], "likes": 10, "viewed": 295, "published": 3, "date": "1634663259", "time_retrieved": "2024-07-30T18:54:39.874677", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    col = vec3(sin(uv.y*900. + snoise(vec3(uv.x*3.0,uv.y,iTime*0.69)) * 5.));\n    //col = smoothstep(snoise(vec3(uv*4.1, iTime)),1.,col);\n    col = step(snoise(vec3(uv.x*2.,uv.y+iTime*2.0, iTime*0.)),col);\n    col = palette(col.x *0.4 + iTime*0.5+uv.y*0.5,\n    vec3(0.5),\n    vec3(0.5),\n    vec3(0.5),\n    vec3(0.5, cos(iTime), 0.0));\n   \n    float d = length(uv);\n    d = step(0.5,d);\n    d = 1.-d;\n    col *= vec3(d);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 711]], "test": "untested"}
{"id": "NdKSDD", "name": "line sdf composite study 1", "author": "_samuelcho_", "description": "Inspired by Zach Lieberman's compositions. ", "tags": ["sdf", "line", "zachlieberman"], "likes": 5, "viewed": 329, "published": 3, "date": "1634663227", "time_retrieved": "2024-07-30T18:54:40.915893", "image_code": "//inspired by https://twitter.com/zachlieberman/status/1450410944404852744\n\n\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n    \n    float d = line_segment(uv, vec2(-0.5,0.0), vec2(0.5,0.0));\n    d *= 3.;\n    d = fract(d+iTime);\n    d = 1.-d;\n    vec3 c1 = palette(d - iTime*0.42,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)) * d;\n    \n    float d2 = line_segment(uv, vec2(cos(iTime)*0.4,cos(iTime*0.69)*0.3), vec2(0.4,0.4));\n    d2 *= 3.;\n    d2 = fract(d2);\n    d2 = 1.-d2;\n    vec3 c2 = palette(d2 - iTime*0.69,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)) * d2;\n    \n    float d3 = line_segment(uv, vec2(-0.3,sin(iTime*1.42)*0.2), vec2(0.3, sin(iTime*0.94)));\n    d3 *= 3.;\n    d3 = fract(d3);\n    d3 = 1.-d3;\n    vec3 c3 = palette(d3 - iTime*0.5,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.33,.66)) * d3;\n    \n    vec3 col = max(max(c1,c2),c3);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 131, 131, 251], [252, 252, 324, 324, 367], [368, 368, 425, 475, 1318]], "test": "untested"}
{"id": "fsKSWD", "name": "swirls on sphere (2D swirl seed)", "author": "FabriceNeyret2", "description": "2D variant of https://shadertoy.com/view/ssGSDh\nPrinciple:\nWorley-like 2D grid on surface with 1 seed point per cell. \nrotate sur coordinates around it.\nclick: no noise texture.", "tags": ["procedural", "swirl", "texture", "planet", "short", "loopless", "jupiter"], "likes": 18, "viewed": 661, "published": 3, "date": "1634660845", "time_retrieved": "2024-07-30T18:54:41.769611", "image_code": "// 2D version of https://shadertoy.com/view/ssGSDh\n// operate on a Worley grid on surface instead of Worley grid in volume.\n\n// WIP. Many discontinuities to fix.   \n// See options and coefs.\n\n#define H(p)       fract(sin((p)*mat2(246.1, 113.5, 271.9, 124.6 ))*43758.5453123)\n#define R(p,a)   (p)*mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define hue(v)   ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n\n    O-=O;\n    float r = length(U), y,w=0., l=9., s = 4.;      // s: swirls size\n    int i,k;\n    if ( r > 1. ) return;\n    \n    vec3 p = vec3( U, sqrt(1.-r*r) );          // raytracing point in sphere\n    vec2 P0 = vec2( atan(p.z,p.x) - .1*iTime, atan(p.y,length(p.xz)) ),\n     // TODO: compress lattitudes near pole to get conform cells \n         P = s*P0, I,F, H,D;\n     //  F = abs(fract(P+.5)-.5); y = min(F.x,F.y); O += smoothstep(12./R.y,0.,y); // debug: grid\n         I = floor(P), F = fract(P);           // coords in 2D grid\n    y = P0.y;                                  // latitude ( to tune swirl direction & amplitude )\n    y = 4.*cos(4.*y); \n // if (mod(I.x+I.y,2.)>0.) y=-y;              // if checkered rotation direction\n    P-=P;\n#define dist2seed  \\\n        D = vec2( k%3, k/3 ) -1.;              /* cell offset         */    \\\n        D += H(I+D)-.5;                        /* random seed point   */    \\\n        r = length(F-D);                       /* distance to seed    */\n\n    for ( k = 0; k < 9; k++) {                 // visit neighbor cells to find closest seed point\n        dist2seed;\n     // y = -y;                                // checkered rotation direction\n        F  =   R( F-D, y*smoothstep(.5,0.,r) ) + D; P = F+I;\n     // P  =   R( F-D, y*smoothstep(.5,0.,r) ) + D+I;  I = floor(P),F = fract(P);\n     // P += ( R( F-D, y*smoothstep(.5,0.,r) ) + D+I )/r; w += 1./r;\n        r < l ? l = r, i = k : i;              // keep closest dot \n     }\n    // P /= w;\n/** k = i;\n    dist2seed;\n // if ( i%2 < 1 ) y = -y;                                        // checkered rotation direction\n    P = R( F-D, y * smoothstep(.5,0.,r) ) + D+I;                  // rotate coords around seed point\n/**/       \n // O += vec4(smoothstep(12./R.y,0., l-.2) ); return;             // test: plot seed points\n    \n    U = P/s; U.x -= .1*iTime;                                     // surface coordinates\n    O += ( iMouse.z > 0. ? vec4(.6) \n             : smoothstep(.8,.2, texture(iChannel0, U*vec2(1,3))))// swirled texture\n        * (.5+.5*hue(abs(U.y*2./3.14)))                           // color\n        * ( .3 + 1.2* max(0., dot(p,vec3(1,0,1))));               // shading\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdVSWD", "name": "idk if tis will work", "author": "_Dark_Wolf_", "description": "idk", "tags": ["cineshader"], "likes": 0, "viewed": 4440, "published": 3, "date": "1634658248", "time_retrieved": "2024-07-30T18:54:42.620336", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(1.000,0.903,0.803,2.000);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.672 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    fragColor = vec4(1.0, 1.0, 1.0, noise);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"idk\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2200], [2202, 2202, 2223, 2223, 2441], [2443, 2443, 2500, 2500, 2862]], "test": "untested"}
{"id": "fsVSWW", "name": " Fab19 #inktober2021 \"loop\" 2", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nvariant of https://shadertoy.com/view/sdGXWD\nHard to get nice ribbon borders !  another approach here: https://www.shadertoy.com/view/fdVSDW", "tags": ["2d", "short", "fourierseries", "inktober2021"], "likes": 20, "viewed": 398, "published": 3, "date": "1634655375", "time_retrieved": "2024-07-30T18:54:43.476049", "image_code": "// variant of https://shadertoy.com/view/sdGXWD\n// another approach here: https://www.shadertoy.com/view/fdVSDW\n\n// --- utils inspired from https://www.shadertoy.com/view/llySRh\n\n#define H(p)     fract( sin( (p) * 78.233 ) * 43758.5453 ) // hash\n#define hue(v) ( .88 + .18 * cos( v  + vec3(0,23,21)  ) )  // desaturated hue\n#define S(v)     smoothstep(  8./R.y, 0.,   v )            // AA draw\n#define s(a,b)   t=a, a=b, b=t                             // swap\n\nfloat line(vec2 p, vec2 a,vec2 b, out float h) { // h = pos on segment ( possibly out )\n    p -= a, b -= a;\n    return length( p - b * clamp( h = dot(p, b) / dot(b, b), 0., 1.) );\n}\n\n// -----------------------------------------------------------\n\nvec2 f(float t) {                               // curve P(t)\n    vec2 P = vec2(0);\n    for (float f, i = 0.; i < 6.; i++ )         // Fourier series \n        f = exp2(i)*t + 6.283*H(i) + i*iTime,\n        P += vec2(cos(f),sin(f)) / pow(1.4, i); // spectrum 1.4^-f, random phase\n    return P;\n}\n#define D(t)  l = dot( P = f(t) - U, P )        // distance² to curve(t)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = 2.5*( u+u - R ) / R.y;\n    float l, d0 = 9., d1=d0, T0,T1,t0,t1,e,h0,h1,h_,c0,c1, t=0., dt = .015, dt2 = dt/4.;\n    O-=O;\n    for ( ; t < 6.283; t+=dt )                  // Sample the curve and get the 2 closests\n        D(t),                                   //   that are not on the same segment.\n          l < d0 ?  t<=T0+dt ? d0=l,T0=t        // Prev best was on same segment: don't update 2nd best\n                             : ( d1=d0, T1=T0, d0=l, T0=t ) // independant best: save old as 2nd best\n        : l < d1 && t> T0+dt ? d1=l,T1=t : t;   // update 2nd best only if not on best segment\n        \n    if (iMouse.z > 0.) O += smoothstep(8./R.y, 0., sqrt(min(d0,d1))-.01 ); // test: draw dots\n\n    t0=T0; t1=T1;    \n    for ( t = -dt; t < dt; t += dt2 )           // Look more accurately around 1st and second\n        D(T0+t), l < d0 ? d0=l,  t0=T0+t : t,   //   closest curve segments.\n        D(T1+t), l < d1 ? d1=l,  t1=T1+t : t;\n        \n   // draw upstream and dowstream segment for 1st and 2nd best\n   // the mess with h & c is to draw the borders pushed only at the right extra angle on the round segment junction\n#define  L(t,h,c) ( d0 = line(U, f(t-dt2), f(t), h  ),  h  = (abs(h -.5)-.5)*length(f(t)-f(t-dt2)), \\\n                    d1 = line(U, f(t+dt2), f(t), h_ ),  h_ = (abs(h_-.5)-.5)*length(f(t)-f(t-dt2)), \\\n                  c = dot( normalize( f(t) - f(t-dt2) ), normalize( f(t+dt2) - f(t) ) ),            \\\n                ( d1 < d0 ? h=h_, d1 : d0 ) -.06 ) \n    T0 = L(t0,h0,c0), T1 = L(t1,h1,c1);\n\nif ( cos(t1) < cos(t0) ) s(T0,T1), s(t0,t1), s(h0,h1), s(c0,c1); // z-sort\n                                       // ribbon pattern (up to a bit of the joint)         , ribbon color,  ribbon mask\n#define B(h,t,T,c) O += (1.-O.a)* vec4( ( h > sqrt(1.-c*c)*(.2+6./R.y) ? 1. : S(T + 6./R.y) ) * hue(t), 1 ) * S(T) // blend ribon pattern*mask\n    B(h0,t0,T0,c0);                             // draw top segment\n    B(h1,t1,T1,c1);                             // draw bottom segment\n    O +=  1.-O.a ;                              // background\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 510, 549, 643], [709, 709, 726, 770, 1002], [1078, 1078, 1116, 1116, 3234]], "test": "untested"}
{"id": "fdKSDW", "name": "Day  670", "author": "jeyko", "description": "aaotato", "tags": ["monochrome", "design", "poster", "mdtmjvm"], "likes": 33, "viewed": 626, "published": 3, "date": "1634654611", "time_retrieved": "2024-07-30T18:54:44.559657", "image_code": "// Fork of \"Day 670\" by jeyko. https://shadertoy.com/view/7dGSWW\n// 2021-10-19 14:31:23\n\n// Fork of \"Day 539\" by jeyko. https://shadertoy.com/view/slSGz1\n// 2021-06-11 08:12:26\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 3.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    n = sin(n*2.);\n    return n;\n}\n\nvec3 get(vec2 fc, vec2 uv){\n    vec2 coord = fc/iResolution.xy;\n    float chrabamt = 0.*smoothstep(0.,1.,dot(uv,uv));\n    vec3 c = vec3(\n        texture(iChannel0,coord+ chrabamt*vec2(0.000,0.00)).x,\n        texture(iChannel0,coord + chrabamt*vec2(-0.0003,0.00)).y,\n        texture(iChannel0,coord + chrabamt*vec2(0.,0.001)).z\n        );\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //fragCoord += 150.*noise(vec3(uv*2.5,5.))/iResolution.xy;\n    col = get(fragCoord,uv);\n    \n    float no = noise(vec3(uv*2.,35.));\n    //col = mix(col,vec3(0),smoothstep(0.,0.5,max(noise(vec3(uv*2.2 + 0.1,35.)) - 0.5,0.))*0.4);\n    \n    col = mix(col,vec3(1),smoothstep(0.,5.,max(no - 0.5,0.))*.05);\n    \n    //col += min(no - 0.5,0.)*0.02;\n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame)*0.,0.),256.)),0).x*0.5;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz*0.6;\n    \n    \n    //C = smoothstep(0.,1.,C);z\n    \n    //col.xyz = pow(max(col.xyz,0.), vec3(0.55) + n*0.1);\n    \n    \n    \n    col = pow(clamp(col,0.,1.),vec3(0.6545));\n\n    col.xyz += smoothstep(1.,0.,length(col))*n*0.2;\n    \n    col.xyz -= smoothstep(0.,1.,length(col))*n*0.1;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iTime (iTime + 56.)\n\n\n// from iq\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n// from iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1./rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdSegmentPersp( in vec2 p, in vec3 _a, in vec3 _b )\n{\n    float amt = 1.;\n    vec2 a = _a.xy/_a.z*amt;\n    vec2 b = _b.xy/_b.z*amt;\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n#define xord(a,b,c) min(max(a,-(b) + c),max(b,-(a)))\n    #define xor(a,b) float(int(a)^int(b))\n    #define and(a,b) float(int(a)&int(b))\n    #define or(a,b) float(int(a)|int(b))\n    #define pi acos(-1.)\n    #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n    #define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\n// dave hoskins hash\nvec4 r14(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n", "buffer_a_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 1.+smoothstep(1.,0.,dot(uv,uv))*0.05;\n    vec3 col = vec3(1);\n    float pxSz = fwidth(uv.y);\n    \n    float seg = 1.;\n    \n    \n    \n    // ----- 2d stuf ----- //\n    {\n        float range = 4.;\n        float a = 0.;\n        float b = 1.;\n        float fact = smoothstep(0.,0.1,fract(iTime/range));\n        float id = floor(iTime/range);\n        float bs;\n        if(mod(id,2.) == 0.){\n            bs = mix(a,b,fact);\n        }else {\n            bs = mix(b,a,fact);\n        }\n        \n        vec2 smallsz = vec2(0.4,0.42)*1.;\n        if(mod(id-1.,4.) < 2.){\n            smallsz *= 0.5;\n        }\n        \n        \n        vec2 s = mix(smallsz,vec2(2),bs);\n        float d = sdBox( uv, s );\n        col = mix(col,1.-col,smoothstep(pxSz,0.,-d));\n        \n        /*\n        float cnt = 20.;\n        for(float i = 0.; i < cnt; i++){\n            \n            vec4 r = r14(i);\n            vec2 bpos = r.xy*2. - 1.;\n            bpos.x*=0.5;\n            bpos.x += sign(bpos.x)*float(abs(bpos.x) < 0.5)*0.5;\n            bpos.y = mod(bpos.y + iTime*abs(sin(i))*0.2  + sin(i*4. + iTime)*0.1 + i,1.)*3.-1.;\n\n            vec2 p = uv - bpos;\n            vec3 c = pal(vec3(0.5,0.8,0.7),vec3(1,0.6,1),vec3(3,2,1),1.*sin(i),floor(p.y*20.)  + iTime);\n            c = pow((c),vec3(.1,.8,0.9));\n            //c = 1.-c;\n            \n            float d = sdBox(p,vec2(0.02,0.1));\n            col = mix(col,c,smoothstep(pxSz,0.,d-0.0003));\n            \n        }\n        */\n        // lines\n        {\n        vec2 p = uv;\n        float liters = 52.;\n        for(float i = 0.; i < liters; i++){\n            float T = iTime*0.4;\n            float lt = (T*(1. + sin(i) ) + sin(T + i*20.)*0.5)*0.1;\n            vec2 bpos = + vec2(mod(\n                lt\n                ,1.)*3. - 1.5,cos(i*16.)*0.5);\n            \n            bpos.y += sign(bpos.y)*float(abs(bpos.y) < 0.5)*0.5;\n            \n            vec2 p = uv.yx + bpos;\n\n            p *= rot(0.5*pi);\n            float d = sdBox(p,vec2(0.01,0.1 + sin(i*20. + iTime + sin(i+iTime)))*0.4);\n            \n            p *= rot(0.5*pi);\n            float md = 0.04;\n            float id = floor(p.x/md + iTime*4.);\n            p.x = pmod(p.x,md);\n            \n            d = max(d,abs(p.x) - 0.03*abs(sin(id*4. + i)) + 0.01);\n            //col = mix(col,vec3(0.,0.6,0.5)-col*1.,smoothstep(pxSz,0.,d));\n            col = mix(col,vec3(1.)-col*1.,smoothstep(pxSz,0.,d));\n        \n        }  \n        }\n        {\n            vec2 p = uv;\n            float liters = 42.;\n            for(float i = 0.; i < liters; i++){\n\n                float lt = (iTime*(1. + sin(i) ) + sin(iTime + i*210.)*0.5)*0.1;\n                vec2 p = uv + vec2(mod(\n                    lt\n                    ,1.)*3. - 1.5,cos(i*16.)*0.7);\n                float d = length(p) - 0.2;\n\n                p = pmod(p,0.015);\n                d = max(d,length(p) - 0.000);\n                //col = mix(col,vec3(0.,0.6,0.5)-col*1.,smoothstep(pxSz,0.,d));\n\n            }    \n        }\n\n    }\n    \n    float deye = 10e5;\n    {\n        vec2 p = uv;\n        float liters = 125.*float(seg==0.) + 40.*float(seg==1.) ;\n        for(float i = 0.; i < liters; i++){\n        \n            float lt = (iTime*(1. + sin(i) ) + sin(iTime + i*20.)*0.5)*0.1;\n            vec2 p = -uv.yx + vec2(mod(\n                lt\n                ,1.)*3. - 1.5,cos(i*16.)*0.5);\n            p = p.yx;\n            \n            float d = sdBox(p,vec2(0.05,0.2));\n            \n            deye = min(deye,d);\n            //deye = min(deye,sdBox(uv + vec2(0.1,0.2),vec2(0.2)));\n\n\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,abs(d) - 0.002));\n\n        }\n    }\n    {\n        float circ = length(uv);\n        \n        \n    }\n    \n    \n    \n    // ----- 3d stuf ----- //\n    float boxCnt = 52.;\n    vec3 ro = vec3(0,0.,-0);\n    vec3 rd = normalize(vec3(uv,1.));\n    rd += 0.001;\n    for(float i = 0.; i < boxCnt; i++){\n        \n        vec3 n = vec3(0);\n        vec4 r = r14(i);\n        vec4 rb = r14(i+13.);\n        \n        vec3 sz = vec3(0.1,0.2,0.1) ;\n        \n        vec3 bpos = r.xyz*2. - 1.;\n        bpos.z += 2.;\n        bpos.x*=0.8;\n        bpos.y = mod(bpos.y + iTime*abs(sin(i))*0.3  + sin(i*4. + iTime)*0.04 + i,1.)*4.-2.;\n        vec2 b = boxIntersection( ro-bpos, rd, sz,  n);\n        sz -= 0.005 + (sin(iTime+i)*2.+1.)*.0;\n        if(b.x > 0. && b.y > 0.  ) {\n            col = mix(\n                col,\n                0.3*abs(dot(col,col))-col,\n                smoothstep(pxSz,0.,deye)\n            );\n         \n            vec3 vertxyz = bpos + sz;\n            vec3 vertnxnynz = bpos - sz;\n            vec3 vertnxyz = bpos + vec3(-sz.x,sz.y,sz.z);\n            vec3 vertxnyz = bpos + vec3(sz.x,-sz.y,sz.z);\n            vec3 vertxynz = bpos + vec3(sz.x,sz.y,-sz.z);\n            vec3 vertnxynz = bpos + vec3(-sz.x,sz.y,-sz.z);\n            vec3 vertnxnyz = bpos + vec3(-sz.x,-sz.y,sz.z);\n            vec3 vertxnynz = bpos + vec3(sz.x,-sz.y,-sz.z);\n            float d = 10e5;\n            d = min(d,sdSegmentPersp( uv.xy, vertxyz, vertxnyz ));\n            d = min(d,sdSegmentPersp( uv.xy, vertxyz, vertnxyz ));\n            d = min(d,sdSegmentPersp( uv.xy, vertxyz, vertxynz ));\n            \n            d = min(d,sdSegmentPersp( uv.xy, vertnxnynz, vertnxnyz ));\n            d = min(d,sdSegmentPersp( uv.xy, vertnxnynz, vertxnynz ));\n            d = min(d,sdSegmentPersp( uv.xy, vertnxnynz, vertnxynz ));\n            \n            d = min(d,sdSegmentPersp( uv.xy, vertnxynz, vertnxyz ));\n            d = min(d,sdSegmentPersp( uv.xy, vertnxynz, vertxynz ));\n            \n            d = min(d,sdSegmentPersp( uv.xy, vertnxnyz, vertnxyz ));\n            d = min(d,sdSegmentPersp( uv.xy, vertnxnyz, vertxnyz ));\n            \n            d = min(d,sdSegmentPersp( uv.xy, vertxnynz, vertxynz ));\n            d = min(d,sdSegmentPersp( uv.xy, vertxnynz, vertxnyz ));\n            \n            //col = mix(col,1.-col,smoothstep(fwidth(abs(d)),0.,d - 0.0004));\n            col = mix(col,vec3(1),smoothstep(pxSz,0.,d-0.001));\n            \n            \n        }\n    }\n            \n    if(iMouse.z > 0.)\n        col = 1. - col;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 351, 351, 747], [749, 749, 776, 776, 1102], [1104, 1104, 1161, 1161, 2106]], "test": "untested"}
{"id": "NsVSWW", "name": "its also burning", "author": "Arrangemonk", "description": "tried to make waves for an ocean shader, ended up making a very inefficient noise function, then i added domain transformation and now ", "tags": ["wavesnoise"], "likes": 6, "viewed": 401, "published": 3, "date": "1634651983", "time_retrieved": "2024-07-30T18:54:45.445289", "image_code": "//Arrangemonk 2021, innefficient noise function\n//in the unlikely event of someone forking this: yeah, do that\n\nfloat PI  = 3.14159265359;\nfloat TAU = 6.28318530718;\nfloat E = 2.71828182846;\nfloat iters = 4.;\nfloat octaves = 8.;\n\nfloat wave(float x,float time)\n{\n   return sin(x * PI - time) *.5 + .5;\n}\n\nvec2 rot(vec2 uv, float phi)\n{\n    return vec2(sin(phi)*uv.x + cos(phi)*uv.y,cos(phi)*uv.x - sin(phi)*uv.y);\n}\n\nfloat rotfbm(vec3 pos)\n{\nfloat result = 0.;\nfloat m = 0.;\nfor(float i = 1.; i < octaves;i++)\n    {\n    float tmp = 1./i;\n    m += tmp;\n    result += wave(rot(pos.xy*i,PI * E * i).x * iters,pos.z)* tmp;\n    }\nreturn result /m;\n}\n\nvec3 NormalMap(in vec2 uv)\n{ \n    float time = iTime * 0.2;\n    float p  = rotfbm(vec3(uv,time));\n    float h1 = rotfbm(vec3(uv + vec2(.1,0),time));\n    float v1 = rotfbm(vec3(uv + vec2(0,.1),time));      \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1));\n    return normalize(vec3(normal, 1.));\n}\n\nfloat curvature(in vec2 uv)\n{\n    vec3 p  = NormalMap(uv);\n    vec3 h1 = NormalMap(uv + vec2(.001,0));\n    vec3 v1 = NormalMap(uv + vec2(0,.001));      \n\n    return (h1.x -p.x + v1.y -p.y - p.z)*.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x * 4.;\n\n    float val = rotfbm(vec3(uv,iTime));\n    vec2 pos = .25 * (uv + NormalMap(.5 *(uv + NormalMap(1. *(uv + NormalMap(uv + vec2(0,-iTime * 0.1)).xy)).yz)).zx);\n    vec3 col = NormalMap(pos);\n    float occ = curvature(pos);\n\n    fragColor = texture(iChannel0,uv + col.xy * col.z);\n    \n    fragColor = fragColor * fragColor * 4.;\n    \n    float amount = uv.y + col.y * col.z;\n    //amount = sqrt(amount);\n    \n    fragColor = mix(vec4(4,1.5,0,1),vec4(0,0,0.2,1),amount)+occ*.1;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 262, 262, 303], [305, 305, 335, 335, 415], [417, 417, 441, 441, 644], [646, 646, 674, 674, 937], [939, 939, 968, 968, 1139], [1142, 1142, 1199, 1199, 1723]], "test": "untested"}
{"id": "sdGXWD", "name": " Fab19 #inktober2021 \"loop\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nTry to be smart by tracking the closest samples on 2 different curve segments.\nFourier-series based curves: see https://www.desmos.com/calculator/iej4fjazoe", "tags": ["2d", "short", "fourierseries", "inktober2021"], "likes": 16, "viewed": 388, "published": 3, "date": "1634650550", "time_retrieved": "2024-07-30T18:54:46.306985", "image_code": "// --- utils from https://www.shadertoy.com/view/llySRh\n\n#define H(p)     fract( sin( (p) * 78.233 ) * 43758.5453 )\n#define hue(v) ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length( p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );\n}\n// -----------------------------------------------------------\n\nvec2 f(float t) {                               // curve P(t)\n    vec2 P = vec2(0);\n    for (float f, i = 0.; i < 6.; i++ )         // Fourier series \n        f = exp2(i)*t + 6.283*H(i) + i*iTime,\n        P += vec2(cos(f),sin(f)) / pow(1.4, i); // spectrum 1.4^-f, random phase\n    return P;\n}\n#define D(t)  l = dot( P = f(t) - U, P )        // distance² to curve(t)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U = 2.5*( u+u - R ) / R.y;\n    float l, d0 = 9., d1=d0, T0,T1,t0,t1,e, t=0., dt = .015, dt2 = dt/4.;\n    O-=O;\n    for ( ; t < 6.283; t+=dt )                  // Sample the curve and get the 2 closests\n        D(t),                                   //   that are not on the same segment.\n          l < d0 ?  t<=T0+dt ? d0=l,T0=t        // Prev best was on same segment: don't update 2nd best\n                             : ( d1=d0, T1=T0, d0=l, T0=t ) // independant best: save old as 2nd best\n        : l < d1 && t> T0+dt ? d1=l,T1=t : t;   // update 2nd best only if not on best segment\n        \n    if (iMouse.z > 0.) O += smoothstep(8./R.y, 0., sqrt(min(d0,d1))-.01 ); // test: draw dots\n \n    t0=T0; t1=T1;    \n    for ( t = -dt; t < dt; t += dt2 )           // Look more accurately around 1st and second\n        D(T0+t), l < d0 ? d0=l,  t0=T0+t : t,   //   closest curve segments.\n        D(T1+t), l < d1 ? d1=l,  t1=T1+t : t;\n        \n                           // draw upstream and dowstream segment for 1st and 2nd best\n#define  L(t) smoothstep(  8./R.y, 0.,                      \\\n                           min ( line(U, f(t-dt2), f(t) ),  \\\n                                 line(U, f(t+dt2), f(t) )   \\\n                        ) -.01 )                            \\\n              * hue(t) \n    O += max( L(t0), L(t1) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 210, 210, 300], [365, 365, 382, 426, 658], [734, 734, 772, 772, 2147]], "test": "untested"}
{"id": "NdKSWW", "name": "its shiny tho", "author": "Arrangemonk", "description": "tried to make waves for an ocean shader, ended up making a very inefficient noise function, then i added domain transformation and now ", "tags": ["wavesnoise"], "likes": 25, "viewed": 925, "published": 3, "date": "1634649961", "time_retrieved": "2024-07-30T18:54:47.158708", "image_code": "//Arrangemonk 2021, innefficient noise function\n//in the unlikely event of someone forking this: yeah, do that\n\nfloat PI  = 3.14159265359;\nfloat TAU = 6.28318530718;\nfloat E = 2.71828182846;\nfloat iters = 4.;\nfloat octaves = 8.;\n\nfloat wave(float x,float time)\n{\n   return sin(x * PI - time) *.5 + .5;\n}\n\nvec2 rot(vec2 uv, float phi)\n{\n    return vec2(sin(phi)*uv.x + cos(phi)*uv.y,cos(phi)*uv.x - sin(phi)*uv.y);\n}\n\nfloat rotfbm(vec3 pos)\n{\nfloat result = 0.;\nfloat m = 0.;\nfor(float i = 1.; i < octaves;i++)\n    {\n    float tmp = 1./i;\n    m += tmp;\n    result += wave(rot(pos.xy*i,PI * E * i).x * iters,pos.z)* tmp;\n    }\nreturn result /m;\n}\n\nvec3 NormalMap(in vec2 uv)\n{ \n    float time = iTime * 0.1;\n    float p  = rotfbm(vec3(uv,time));\n    float h1 = rotfbm(vec3(uv + vec2(.1,0),time));\n    float v1 = rotfbm(vec3(uv + vec2(0,.1),time));      \n   \tvec2 n2 = 0.5 + (p - vec2(h1, v1));\n    return normalize(vec3(n2, 1.));\n    \n}\n\nfloat curvature(in vec2 uv)\n{\n    vec3 p  = NormalMap(uv);\n    vec3 h1 = NormalMap(uv + vec2(.001,0));\n    vec3 v1 = NormalMap(uv + vec2(0,.001));      \n\n    return (h1.x -p.x + v1.y -p.y - p.z)*.5;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x *.5;\n\n    float val = rotfbm(vec3(uv,iTime));\n    \n    vec2 pos = .25 * (uv + NormalMap(.5 *(uv + NormalMap(1. *(uv + NormalMap(uv).xy)).yz)).zx);\n    \n    vec3 col = NormalMap(pos);\n    \n    float occ = curvature(pos);\n\n    fragColor = texture(iChannel0,uv + col.xy * col.z);\n    \n    fragColor = fragColor * fragColor * 4.;\n    \n    fragColor = (fragColor + occ *.1);\n    \n    //fragColor = vec4(occ,occ,occ,1.);\n\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 262, 262, 303], [305, 305, 335, 335, 415], [417, 417, 441, 441, 644], [646, 646, 674, 674, 934], [936, 936, 965, 965, 1136], [1140, 1140, 1197, 1197, 1653]], "test": "untested"}
{"id": "7dyXDW", "name": "Twizzly Twizzlers", "author": "SnoopethDuckDuck", "description": "Messy code again, sometimes camera goes through shape + a few artifacts", "tags": ["raymarching", "template", "artofcode"], "likes": 6, "viewed": 335, "published": 3, "date": "1634648138", "time_retrieved": "2024-07-30T18:54:48.004447", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n    \n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float r1 = 2.;\n    float r2 = 0.5;\n    float d1 = length(p.xz) - r1;\n    float a = atan(p.y,length(p.xz));\n    float td = length(vec2(d1,p.y) * 5. \n               * (1. + 0.5 * cos(14. * a * p.y - 4. * iTime)) / cosh(p.y) \n               * vec2(cos(p.x), sin(p.z))) - r2;\n\n    vec3 n = vec3(cos(0.), 0., sin(0.));\n    float pd = dot(p + 3. * cos(iTime),n);\n    float pd2 = dot(p - 3. * cos(iTime),n);\n\n    float b = .6;//+ .5 * cos(iTime);\n   // return b * td + (1.-b) * max(pd, td);\n\n    float d = sdBox(p, vec3(1));\n    d = mix(length(p) - 2., d, .5 );\n   // return min(0.05 * td/d, 0.8 * d);\n   return 0.1 * td * cos(0.6 * d);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float rad = 3. + 1.5 * cos(0.35 * iTime);\n    vec3 ro = vec3(rad * cos(0.2 * iTime),2. * cos(0.5 * iTime),rad * sin(0.2 * iTime));\n   \n   //vec3(1.5 * cos(0.2 * iTime),2. * cos(0.5 * iTime),1.5 * sin(0.2 * iTime));\n   // ro = vec3(0.1 * cos(0.2 * iTime), 0.5 + 0.05 * cos(0.5 * iTime), 0.1 * sin(0.2 * iTime));\n    //vec3(4.6 * cos(0.5 * iTime), cos(0.3 * iTime) * 2.5, 4.6 * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0, 0.5,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        float b = .5 + .5 * cos(iTime);\n        \n        uv = fragCoord.xy / iResolution.xy;\n        col += 2. * texture(iChannel0,r / (0.5 + n)).rgb;\n         \n        float a = atan(rf.z, rf.x);\n        float c = atan(rf.z,rf.y);\n        vec3 col2 = 1. * col + 0.5;\n        float k = 1.;\n        float m = 1.;\n        col2.r += 0.5 * cos(k * a + m * p.x + iTime - 2. * 3.1415 / 3.);\n        col2.g += 0.5 * cos(k * a + m * p.y + iTime);\n        col2.b += 0.5 * cos(k * a + m * p.z + iTime + 2. * 3.1415 / 3.);\n        col *= col2;\n        \n        col *= col2 * 30. / (cosh(10. * (1.-pow(cos(0.3 * length(p.xz) - 0.5 * iTime),2.))) * pow(length(p), 2.5));\n        if (length(col) < 0.1)\n            col = 0.005 * col2/ texture(iChannel0,r / (0.5 + n)).rgb;\n       \n       //col = 200. /col;\n   } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXDW.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1559, 1588, 1588, 1813], [1816, 1816, 1839, 1839, 2475], [2477, 2477, 2511, 2511, 2722], [2724, 2724, 2748, 2748, 2939], [2941, 2941, 2991, 2991, 3182], [3184, 3184, 3202, 3202, 3300], [3303, 3303, 3360, 3360, 5269]], "test": "untested"}
{"id": "ssGXWW", "name": "Parallelepiped from 3-Simplex", "author": "paniq", "description": "Based on Varignon's Theorem. Performed here entirely in projective space.", "tags": ["parallelogram", "quadliteral", "varignon"], "likes": 15, "viewed": 405, "published": 3, "date": "1634639199", "time_retrieved": "2024-07-30T18:54:49.124452", "image_code": "// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nconst float R = 0.02;\nvoid paint_plane(vec2 p4, vec2 p5, vec2 p6, vec2 p7) {\n    circle(p4, R);\n    circle(p5, R);\n    circle(p6, R);\n    circle(p7, R);\n\tfill();\n\n    move_to(p4);\n\tline_to(p5);\n    line_to(p6);\n    line_to(p7);\n    close_path();\n    stroke();\n}\n\nvoid paint() {\n    float t = iTime * 0.1;\n\n    // clear screen with a subtle gradient\n\n    set_source_rgb(vec3(0.0));\n    clear();\n    \n    scale(0.7);\n    set_source_rgb(vec3(1.0));\n\tset_line_width_px(1.0);\n    \n    vec2 p0 = lissajous(t, 5.0, 4.0);\n    vec2 p1 = lissajous(t + 1.0, 5.0, 4.0);\n    vec2 p2 = lissajous(t + 2.0, 5.0, 4.0);\n    vec2 p3 = lissajous(t + 3.0, 5.0, 4.0);\n    \n    vec2 p01 = (p0 + p1)*0.5;\n    vec2 p02 = (p0 + p2)*0.5;\n    vec2 p03 = (p0 + p3)*0.5;\n    vec2 p12 = (p1 + p2)*0.5;\n    vec2 p13 = (p1 + p3)*0.5;\n    vec2 p23 = (p2 + p3)*0.5;\n    \n    // center\n    vec2 p0123 = (p0 + p1 + p2 + p3)*0.25;\n    // orthogonal vectors\n    float S = 1.0 / 3.0;\n    vec2 gx = (p23 - p0123) * S;\n    vec2 gy = (p13 - p0123) * S;\n    vec2 gz = (p12 - p0123) * S;\n    // cube vertices\n    vec2 c000 = p0123 - gx - gy - gz;\n    vec2 c001 = p0123 - gx - gy + gz;\n    vec2 c010 = p0123 - gx + gy - gz;\n    vec2 c011 = p0123 - gx + gy + gz;\n    vec2 c100 = p0123 + gx - gy - gz;\n    vec2 c101 = p0123 + gx - gy + gz;\n    vec2 c110 = p0123 + gx + gy - gz;\n    vec2 c111 = p0123 + gx + gy + gz;\n\n    circle(p0, R);\n    circle(p1, R);\n    circle(p2, R);\n    circle(p3, R);\n\tfill();\n    \n    set_source_rgba(1.0, 0.5, 0.5, 1.0);\n    move_to(p0);\n    line_to(p2);\n    stroke();\n\tmove_to(p1);\n    line_to(p3);\n    stroke();\n    paint_plane(p01, p12, p23, p03);\n    set_source_rgba(0.5, 1.0, 0.5, 1.0);\n    move_to(p0);\n\tline_to(p1);\n    stroke();\n    move_to(p2);\n\tline_to(p3);\n    stroke();\n    paint_plane(p02, p12, p13, p03);\n    set_source_rgba(0.5, 0.5, 1.0, 1.0);\n    move_to(p0);\n\tline_to(p3);\n    stroke();\n    move_to(p1);\n\tline_to(p2);\n    stroke();\n    paint_plane(p01, p13, p23, p02);\n    \n    \n    set_source_rgb(vec3(1.0));\n    move_to(c000);\n    line_to(c010);\n    line_to(c110);\n    line_to(c100);\n    close_path();\n    move_to(c001);\n    line_to(c011);\n    line_to(c111);\n    line_to(c101);\n    close_path();\n    move_to(c000);\n    line_to(c001);\n    move_to(c010);\n    line_to(c011);\n    move_to(c110);\n    line_to(c111);\n    move_to(c100);\n    line_to(c101);\n    stroke();\n    \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6125, 6125, 6168, 6168, 6207], [6231, 6231, 6285, 6285, 6470], [6472, 6472, 6486, 6486, 8576], [8813, 8813, 8840, 8840, 8866], [8928, 8928, 8949, 8949, 9056], [9058, 9058, 9095, 9095, 9181], [9183, 9183, 9229, 9229, 9262], [9402, 9402, 9430, 9430, 9890], [9918, 9918, 9937, 9937, 9970], [9972, 9972, 9990, 9990, 10023], [10025, 10025, 10049, 10049, 10153], [10155, 10155, 10172, 10172, 10193], [10195, 10195, 10222, 10244, 10527], [10529, 10529, 10557, 10557, 10791], [10793, 10793, 10817, 10817, 10903], [10905, 10905, 10932, 10932, 11145], [11147, 11147, 11173, 11173, 11401], [11403, 11403, 11425, 11425, 11551], [11553, 11553, 11573, 11573, 11633], [11635, 11635, 11667, 11667, 11694], [11696, 11696, 11717, 11717, 11739], [11741, 11741, 11765, 11765, 11825], [11827, 11827, 11861, 11861, 11885], [11887, 11887, 11901, 11901, 11965], [11967, 11967, 11993, 11993, 12031], [12033, 12033, 12059, 12059, 12080], [12082, 12082, 12105, 12105, 12200], [12202, 12202, 12226, 12226, 12295], [12297, 12297, 12322, 12322, 12369], [12371, 12371, 12388, 12388, 12501], [12503, 12503, 12526, 12526, 12655], [12657, 12657, 12685, 12685, 12813], [12815, 12815, 12839, 12839, 12979], [12981, 12981, 13019, 13019, 13153], [13155, 13155, 13192, 13192, 13227], [13229, 13229, 13256, 13256, 13306], [13308, 13308, 13338, 13338, 13394], [13396, 13396, 13425, 13425, 13606], [13608, 13608, 13630, 13630, 13797], [13799, 13799, 13812, 13812, 13851], [13853, 13853, 13883, 13883, 13912], [13914, 13914, 13947, 13947, 14004], [14006, 14006, 14032, 14032, 14082], [14084, 14084, 14105, 14105, 14170], [14172, 14172, 14196, 14196, 14279], [14281, 14281, 14296, 14296, 14337], [14339, 14339, 14355, 14355, 14393], [14395, 14395, 14413, 14413, 14470], [14472, 14472, 14502, 14524, 14906], [14908, 14908, 14966, 14966, 15004], [15006, 15006, 15035, 15035, 15071], [15073, 15073, 15121, 15121, 15152], [15154, 15154, 15188, 15188, 15247], [15249, 15249, 15326, 15326, 15491], [15493, 15493, 15570, 15570, 15650], [15652, 15652, 15728, 15728, 15844], [15846, 15846, 15922, 15922, 16000], [16002, 16002, 16040, 16040, 16074], [16076, 16076, 16098, 16098, 16144], [16146, 16146, 16173, 16173, 16217], [16219, 16219, 16241, 16241, 16635], [16637, 16637, 16666, 16666, 16694], [16696, 16696, 16745, 16745, 17006], [17008, 17008, 17081, 17081, 17135], [17137, 17137, 17169, 17169, 17205], [17207, 17207, 17263, 17263, 17319], [17321, 17321, 17351, 17351, 17444], [17445, 17445, 17485, 17485, 17508], [17510, 17556, 17595, 17595, 18751], [18753, 18753, 18783, 18783, 18885], [18887, 18887, 18939, 18939, 18979], [18981, 18981, 19003, 19003, 19054], [19056, 19056, 19088, 19088, 19110], [19112, 19127, 19149, 19149, 19441], [19443, 19443, 19475, 19475, 19497], [19499, 19499, 19518, 19518, 19550], [19599, 19662, 19704, 19704, 19770], [19772, 19842, 19893, 19893, 20245], [20247, 20281, 20327, 20327, 20839], [20841, 20910, 20956, 20956, 21462], [21464, 21464, 21497, 21497, 21713], [21715, 21715, 21774, 21774, 21819], [21821, 21821, 21864, 21864, 21925], [21927, 21927, 21969, 21969, 22011], [22073, 22073, 22130, 22130, 22329]], "test": "untested"}
{"id": "sdyXWW", "name": "dmt, no! not the drug", "author": "Arrangemonk", "description": "you know , the day starts, you search for new articles from iq you see and old one and try it out, and then it looks the same and you realize you achieved nothing", "tags": ["domaintransform"], "likes": 6, "viewed": 391, "published": 3, "date": "1634639151", "time_retrieved": "2024-07-30T18:54:50.065935", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    vec3 col = texture(iChannel0,uv).rgb*0.2;\n    uv*= 0.2;\n    float time = iTime * 0.2;\n\n    col += texture(iChannel0,uv+ \n     vec2(time *.05,0.) +0.5 * texture(iChannel0,uv+ \n     vec2(0.,time *.025) + 0.25 *texture(iChannel0,0.5*uv+\n     vec2(time *.0125,-time *.0125) + 0.125 *texture(iChannel0,.25*uv).rg).rb).gb).rgb;\n\n    col = vec3(col.g,col.r,col.b);\n    fragColor = vec4(col * col * col * 4.,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 509]], "test": "untested"}
{"id": "7sySWW", "name": "A Black Hole", "author": "pancakespeople", "description": "Black hole with an accretion disk", "tags": ["space", "blackhole"], "likes": 5, "viewed": 321, "published": 3, "date": "1634635414", "time_retrieved": "2024-07-30T18:54:51.011408", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float bhRadius = 0.1;\n    float n = fbm(uv*2.0*rotate(iTime/4.0))+0.8;\n    float dist = length(uv);\n\n    vec3 col = vec3(smoothstep(0.35, 0.0, dist - bhRadius));\n    col += smoothstep(0.3, 0.0, dist - bhRadius) * vec3(1.0, 0.8, 0.5);\n    col *= smoothstep(bhRadius, bhRadius + 0.01, dist) * n;\n    col *= fbm((uv+1.0/(dist+bhRadius))*2.0*(dist-bhRadius)*rotate(iTime/16.0))+0.8;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sySWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1143, 1644]], "test": "untested"}
{"id": "NdGXDD", "name": "Vessel Climbing", "author": "dr2", "description": "Virtually climbing the \"Vessel\" in NYC - now closed; mouseable", "tags": ["tower", "geometry", "architecture"], "likes": 20, "viewed": 299, "published": 3, "date": "1634630131", "time_retrieved": "2024-07-30T18:54:52.042650", "image_code": "// \"Vessel Climbing\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Virtually climbing the \"Vessel\" in NYC - now closed; mouseable.\n\n/*\n  No. 4 in \"Vessel\" series\n    \"Stairs to Nowhere\"         (wtB3R3)\n    \"Submerging Tower\"          (wdcGWr)\n    \"Mountain Lake with Tower\"  (3tdcWj)\n*/\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec4 szFlr;\nvec3 ltDir, qHit, pvU[5], pvD[5];\nfloat dstFar, tCur, twrScl, flSpc, nFlr, twrRad, bSizeV, cIdV;\nint idObj;\nconst int idFlr = 1, idStr = 2, idRl = 3, idStn = 4, idCln = 5, idMovBU = 6, \n   idMovHU = 7, idMovBD = 8, idMovHD = 9, idWall = 10, idRfEx = 11, idGrEx = 12;\nconst float pi = 3.1415927, sqrt2 = 1.41421;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, stSpc, xLim1, xLim2, bRad, r, a, x;\n  bool topFlr, botFlr;\n  dMin = dstFar / twrScl;\n  p /= twrScl;\n  r = length (p.xz) - twrRad;\n  d = r - 20.;\n  if (d < 1.) {\n    a = 2. * pi * ((floor (6. * atan (p.x, - p.z) / (2. * pi)) + 0.5) / 6.);\n    stSpc = 6.;\n    xLim1 = abs (dot (p.xz, sin (a + vec2 (0.5 * pi, 0.)))) - 22.;\n    xLim2 = xLim1 + 16.;\n    bRad = 0.5 * 0.5;\n    topFlr = (cIdV == 2. * nFlr - 1.);\n    botFlr = (cIdV == 0.);\n    if (topFlr) {\n      d = length (max (abs (vec2 (p.y + 0.5 * szFlr.w, r + szFlr.z + stSpc)) -\n         vec2 (0.5 * szFlr.w, szFlr.z), 0.));\n      DMIN (idFlr);\n      d = max (length (vec2 (p.y + 0.4, abs (r + szFlr.z + stSpc - 0.5)) - (szFlr.z - 0.1)) -\n         bRad, - xLim2);\n      DMIN (idRl);\n    }\n    d = max (length (max (abs (vec2 ((topFlr ? - p.y : abs (p.y)) - flSpc,\n       r - 0.4 * (szFlr.z + stSpc))) - vec2 (szFlr.w, 1.4 * (szFlr.z + stSpc)), 0.)), - xLim1);\n    DMIN (idFlr);\n    d = max (length (max (abs (vec2 (p.y + szFlr.w, r)) - vec2 (szFlr.w, 2. * szFlr.z + stSpc +\n       0.5), 0.)), xLim2);\n    DMIN (idFlr);\n    p.zx = Rot2D (p.zx, a);\n    p.z = abs (p.z) - twrRad;\n    x = abs (p.x) - szFlr.x;\n    for (float sz = -1.; sz <= 1.; sz += 2.) {\n      if (! topFlr || sz < 0.) {\n        q.x = x;\n        q.yz = p.yz - sz * vec2 (szFlr.y - szFlr.w, - (szFlr.z + stSpc));\n        d = abs (q.y) - (szFlr.y - szFlr.w - 0.005);\n        q.xy = vec2 (q.x + sz * q.y, - sz * q.x + q.y) / sqrt2;\n        d = max (max (max (q.y - 0.5 * sqrt2 - abs (0.5 * sqrt2 - mod (q.x, sqrt2)),\n           abs (q.z) - szFlr.z), -1. - q.y), d);\n        DMIN (idStr);\n      }\n    }\n    d = max (length (vec2 (p.y + flSpc - 4., abs (r - szFlr.z) - (2. * szFlr.z + stSpc -\n       0.8))) - bRad, - xLim1);\n    DMIN (idRl);\n    d = max (length (vec2 (p.y - 3.5, abs (r - 0.4) - (2. * szFlr.z + stSpc - 0.1))) - bRad, xLim2);\n    DMIN (idRl);\n    q = vec3 (x - 4., p.y + 0.5 * flSpc, abs (p.z - (szFlr.z + stSpc)) - szFlr.z);\n    d = max (length (vec2 ((q.x + q.y) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n    DMIN (idRl);\n    q.xz = vec2 (x + 4., abs (p.z + szFlr.z + stSpc) - szFlr.z);\n    if (! botFlr) {\n      d = max (length (vec2 ((q.x - (p.y + 1.5 * flSpc)) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n      DMIN (idRl);\n    }\n    if (! topFlr) {\n      d = max (length (vec2 ((q.x - (p.y - 0.5 * flSpc)) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n      DMIN (idRl);\n    }\n    x = abs (p.x);\n    q.x = x - 22.;\n    d = min (length (vec2 (q.x, p.y + flSpc - 4.)), length (vec2 (x - 6., p.y - 3.5))) - bRad;\n    d = max (d, max (abs (p.z) - (2. * szFlr.z + stSpc), szFlr.z - abs (abs (p.z) - (szFlr.z + stSpc))));\n    DMIN (idRl);\n    q.yz = vec2 (p.y + flSpc - 2.5, abs (abs (p.z) - (szFlr.z + stSpc)) - szFlr.z);\n    d = PrCapsDf (q.xzy, 0.7 * 0.7, 2. + 0.2);\n    DMIN (idStn);\n    if (! topFlr) {\n      d = length (vec2 (q.x, p.z)) - 0.8 * 0.8;\n      DMIN (idCln);\n    }\n    d = PrCapsDf (vec3 (x - 6., p.y - 2.5, q.z).xzy, 0.7 * 0.7, 2. + 0.2);\n    DMIN (idStn);\n    dMin *= 0.7;\n  } else dMin = d;\n  return twrScl * dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, eps, sy;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.y == 0.) rd.y = 0.001;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cIdV = floor (p.y / bSizeV);\n    sy = (bSizeV * (cIdV + step (0., rd.y)) - p.y) / rd.y;\n    d = abs (sy) + eps;\n    if (cIdV >= 0. && cIdV < 2. * nFlr) {\n       d = min (GObjDf (p - vec3 (0., bSizeV * (cIdV + 0.5), 0.)), d);\n    }\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps || p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  cIdV = floor (p.y / bSizeV);\n  p.y -= bSizeV * (cIdV + 0.5);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, wz, h;\n  int idb;\n  dMin = dstFar;\n  p.y -= bSizeV * (nFlr - 0.5);\n  p /= twrScl;\n  h = bSizeV * (nFlr - 0.5) / twrScl;\n  q = p;\n  r = length (q.xz) - twrRad;\n  q.y -= 1.3 * flSpc + h;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (3. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 3.));\n  d = dot (vec2 (q.x, abs (q.z)), sin (0.09 * pi + vec2 (0., 0.5 * pi)));\n  q.x = r + szFlr.z + 5.;\n  d = max (d, length (max (abs (q.xy) - vec2 (2.1, 0.3 * flSpc), 0.)) - 0.02);\n  DMINQ (idRfEx);\n  q = p;\n  q.y -= 0.25 * flSpc - h;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (3. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 3.));\n  wz = q.z;\n  d = abs (abs (q.z) - 18.) - 5.;\n  q.x = r + szFlr.z + 1.3;\n  d = max (d, length (max (abs (q.xy) - vec2 (2.9, 0.3 * flSpc), 0.)) - 0.02);\n  DMINQ (idGrEx);\n  q = p;\n  q.y -= 0.4 * flSpc - h;\n  d = max (length (max (abs (vec2 (r - 2. * szFlr.z - 15., q.y)) -\n     vec2 (0.5, 0.4 * flSpc), 0.)) - 0.02, 0.2 - length (max (abs (vec2 (abs (wz) - 40., q.y)) -\n     vec2 (4., 0.3 * flSpc), 0.))); \n  DMINQ (idWall);\n  return twrScl * dMin;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float r)\n{\n  vec3 vn;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + r * r;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      vn = (ro + d * rd) / r;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float r, float h)\n{\n  vec3 s, vn;\n  vec2 e;\n  e = vec2 (-1., 1.);\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  ro.yz = ro.zy * e;\n  rd.yz = rd.zy * e;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - r * r);\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    d /= max (a, 1e-6);\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < h) {\n      dMin = d;\n      vn = vec3 (s.xy, 0.);\n    } else {\n      drz = - h * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - r * r);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vn = ro + d * rd;\n        }\n      }        \n    }\n  }\n  vn.yz = - vn.zy * e;\n  return vec4 (dMin, vn);\n}\n\nvoid PathVerts ()\n{\n  pvU[0] = vec3 (4., - flSpc, 5.);\n  pvU[1] = vec3 (-14., - flSpc, -2. * szFlr.z - 5.);\n  pvU[2] = vec3 (4., 0., - szFlr.z - 5.);\n  pvU[3] = vec3 (-4., 0., szFlr.z + 5.);\n  for (int k = 0; k < 4; k ++) pvU[k] += vec3 (1., 0., - twrRad);\n  pvU[4] = pvU[0];\n  pvU[2].xz = Rot2D (pvU[2].xz, - pi / 6.);\n  pvU[3].xz = Rot2D (pvU[3].xz, - pi / 6.);\n  pvU[4].xz = Rot2D (pvU[4].xz, - 2. * pi / 6.);\n  pvU[4].y += 2. * flSpc;\n  pvD[0] = vec3 (14., flSpc, -2. * szFlr.z - 5.);\n  pvD[1] = vec3 (-4., flSpc, 5.);\n  pvD[2] = vec3 (4., 0., szFlr.z + 5.);\n  pvD[3] = vec3 (-4., 0., - szFlr.z - 5.);\n  for (int k = 0; k < 4; k ++) pvD[k] += vec3 (-1., 0., - twrRad);\n  pvD[4] = pvD[0];\n  pvD[2].xz = Rot2D (pvD[2].xz, - pi / 6.);\n  pvD[3].xz = Rot2D (pvD[3].xz, - pi / 6.);\n  pvD[4].xz = Rot2D (pvD[4].xz, - 2. * pi / 6.);\n  pvD[4].y -= 2. * flSpc;\n}\n\nvec4 MovObjHit (vec3 ro, vec3 rd)\n{\n  vec4 dc4;\n  vec3 s[5], s1, s2, ss, vn;\n  float dMin, d, r, t, h, iDir;\n  int idb, iUD;\n  dMin = dstFar;\n  h = bSizeV * (nFlr - 0.5);\n  ro.y -= h;\n  h += 0.5 * flSpc * twrScl;\n  iDir = 1.;\n  for (float iMul = 0.; iMul < 6.; iMul ++) {\n    iDir = 1. - iDir;\n    idb = (iDir == 0.) ? idMovBU : idMovBD;\n    for (int j = 0; j < 5; j ++) s[j] = (iDir == 0.) ? pvU[j] : pvD[j];\n    t = fract (0.3 * tCur + 0.5 * iDir);\n    r = 2. * t - 0.5 * (sign (t - 0.5) + 1.);\n    for (int iSec = 0; iSec < 6; iSec ++) {\n      s1 = (t < 0.5) ? mix (s[0], s[1], r) : mix (s[1], s[2], r);\n      s2 = (t < 0.5) ? mix (s[2], s[3], r) : mix (s[3], s[4], r);\n      iUD = 1;\n      for (float iRep = 0.; iRep < 6.; iRep ++) {\n        iUD = 1 - iUD;\n        ss = (iUD == 0) ? s1 : s2;\n        ss.y += (4. - 12. * mod (iRep, 3.) + 4. * mod (iMul, 3.)) * flSpc *\n           sign (0.5 - iDir) + 2.9;\n        dc4 = CapsHit (ro - ss * twrScl, rd, 1.2 * twrScl, 1.5 * twrScl);\n        if (dc4.x < dMin && abs (ro.y + dc4.x * rd.y - flSpc * twrScl + 3.8 * twrScl) <\n           h + 3.8 * twrScl) {\n          dMin = dc4.x;\n          vn = dc4.yzw;\n          idObj = idb;\n        }\n        ss.y += 3.7;\n        dc4 = SphHit (ro - ss * twrScl, rd, 1.1 * twrScl);\n        if (dc4.x < dMin && abs (ro.y + dc4.x * rd.y - flSpc * twrScl + 3.8 * twrScl) <\n           h + 3.8 * twrScl) {\n          dMin = dc4.x;\n          vn = dc4.yzw;\n          idObj = idb + 1;\n        }\n      }\n      for (int j = 0; j < 5; j ++) {\n        s[j].xz = Rot2D (s[j].xz, - 2. * pi / 6.);\n        s[j].y += 2. * flSpc * sign (0.5 - iDir);\n      }\n    }\n  }\n  return vec4 (dMin, normalize (vn));\n}\n\nfloat ObjAO (vec3 p)\n{\n  vec3 q, w, s[5], s1, s2;\n  float d, r, t, iDir;\n  int iUD;\n  d = dstFar;\n  p.y -= bSizeV * (nFlr - 0.5);\n  p /= twrScl;\n  iDir = 1.;\n  for (float iMul = 0.; iMul < 6.; iMul ++) {\n    iDir = 1. - iDir;\n    q.xz = p.xz;\n    for (int j = 0; j < 5; j ++) s[j] = (iDir == 0.) ? pvU[j] : pvD[j];\n    t = fract (0.3 * tCur + 0.5 * iDir);\n    r = 2. * t - 0.5 * (sign (t - 0.5) + 1.);\n    for (int iSec = 0; iSec < 6; iSec ++) {\n      s1 = (t < 0.5) ? mix (s[0], s[1], r) : mix (s[1], s[2], r);\n      s2 = (t < 0.5) ? mix (s[2], s[3], r) : mix (s[3], s[4], r);\n      iUD = 1;\n      for (float iRep = 0.; iRep < 6.; iRep ++) {\n        iUD = 1 - iUD;\n        q.y = p.y - (4. - 12. * mod (iRep, 3.) + 4. * mod (iMul, 3.)) * flSpc * sign (0.5 - iDir);\n        q.y -= 3.;\n        w = q - ((iUD == 0) ? s1 : s2);\n        if (abs (w.y) < 4.) d = min (d, length (w.xz));\n      }\n      for (int j = 0; j < 5; j ++) {\n        s[j].xz = Rot2D (s[j].xz, - 2. * pi / 6.);\n        s[j].y += 2. * flSpc * sign (0.5 - iDir);\n      }\n    }\n  }\n  return 0.6 + 0.4 * smoothstep (1.3, 2.6, d);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0002 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  if (idObj == idFlr) {\n    col4 = vec4 (0.5, 0.2, 0., 0.1);\n    if (vn.y > 0.99) col4 *= 0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (mod (0.25 * length (ro.xz) / twrScl + 0.5, 1.) - 0.5) - 0.07);\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.6, 0.3, 0.1, 0.1);\n  } else if (idObj == idRl) {\n    col4 = vec4 (0.9, 0.9, 1., 0.2);\n  } else if (idObj == idStn) {\n    col4 = vec4 (0.8, 0.8, 1., 0.2);\n  } else if (idObj == idCln) {\n    col4 = vec4 (1., 0., 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (mod (ro.y / twrScl +\n       0.5, 1.) - 0.5) - 0.07));\n  } else if (idObj == idMovBU) {\n    col4 = vec4 (0.8, 0.8, 0., 0.2);\n  } else if (idObj == idMovHU) {\n    col4 = vec4 (0.8, 0.8, 0., -1.);\n  } else if (idObj == idMovBD) {\n    col4 = vec4 (0., 0.8, 0.8, 0.2);\n  } else if (idObj == idMovHD) {\n    col4 = vec4 (0., 0.8, 0.8, -1.);\n  } else if (idObj == idWall) {\n    col4 = vec4 (0.8, 0.4, 0.2, 0.) * (0.8 + 0.2 * smoothstep (0., 0.02, \n       abs (mod (64. * atan (qHit.z, - qHit.x) / pi + 0.5, 1.) - 0.5) - 0.05));\n  } else if (idObj == idRfEx) {\n    col4 = vec4 (0.8, 0.5, 0.3, 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (mod (qHit.y +\n       0.5, 1.) - 0.5) - 0.07));\n    if (abs (qHit.y + 0.6) < 4.1 && qHit.x > 0. && abs (abs (qHit.z) - 2.6) < 1.7)\n       col4 = (qHit.z > 0.) ? vec4 (0.6, 0.6, 0., -1.) : vec4 (0., 0.6, 0.6, -1.);\n  } else if (idObj == idGrEx) {\n    col4 = vec4 (0.8, 0.5, 0.3, 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (mod (qHit.y +\n       0.5, 1.) - 0.5) - 0.07));\n    if (abs (qHit.y + 0.6) < 4.1 && abs (qHit.z) - 18. > 0. && abs (qHit.x) < 1.7)\n       col4 = (qHit.z > 0.) ? vec4 (0.6, 0.6, 0., -1.) : vec4 (0., 0.6, 0.6, -1.);\n  }\n  return col4;\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return vec3 (normalize (vec3 (Fbm2 (p) - vec2 (Fbm2 (p + e.xy),\n     Fbm2 (p + e.yx)), 4. * e.x)).xzy);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.02 * (0.1 + 0.9 * IFbm1 (32. * atan (rd.z, - rd.x) / pi))) {\n    col = 0.8 * vec3 (0.35, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * ltDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.3, 0.4, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn;\n  float dstObj, dstObjG, dstObjM, s;\n  int idObjG, idObjM;\n  PathVerts ();\n  dstObjG = GObjRay (ro, rd);\n  idObjG = idObj;\n  dc4 = MovObjHit (ro, rd);\n  dstObjM = dc4.x;\n  idObjM = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, min (dstObjM, dstObjG))  < dstFar) {\n    if (dstObj < min (dstObjM, dstObjG)) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n    } else if (dstObjG < dstObjM) {\n      dstObj = dstObjG;\n      idObj = idObjG;\n      ro += dstObj * rd;\n      vn = GObjNf (ro);\n    } else {\n      dstObj = dstObjM;\n      idObj = idObjM;\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n    }\n    col4 = ObjCol (ro, vn);\n    if ((idObj == idFlr || idObj == idStr) && vn.y > 0.) col4.rgb *= ObjAO (ro);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    s = length (ro.xz);\n    if (s < (twrRad + 2. * szFlr.z + 15.) * twrScl) {\n      col = vec3 (0.2, 0.3, 0.2) * (0.7 + 0.3 * Fbm2 (4. * ro.xz));\n    } else {\n      vn = GrndNf (0.5 * ro.xz);\n      col = (0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n         0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)))) *\n         (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n      col *= 0.7 + 0.3 * smoothstep (0., 0.5, s - 9.3);\n      col = mix (col, 0.8 * vec3 (0.35, 0.4, 0.5), pow (1. + rd.y, 16.));\n    }\n    col *= 0.7 + 0.3 * smoothstep (0., 2., abs (s - (twrRad + 2. * szFlr.z + 15.) * twrScl));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  twrScl = 0.3;\n  szFlr = vec4 (14., 8.5, 4., 0.5);\n  flSpc = 2. * szFlr.y - szFlr.w;\n  nFlr = 4.;\n  twrRad = 60.;\n  bSizeV = 2. * flSpc * twrScl;\n  az = 0.;\n  el = -0.05 * pi;\n  ro = vec3 (0., 1.9 * flSpc * nFlr * twrScl, -120.);\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    ro.y += 1.9 * 2. * flSpc * nFlr * twrScl * mPtr.y;\n  } else {\n    az += 0.05 * pi * tCur;\n    ro.y += 1.8 * flSpc * nFlr * twrScl * (2. * SmoothBump (0.25, 0.75, 0.22,\n       mod (0.022 * tCur, 1.)) - 1.);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * ro;\n  zmFac = 2.2 / (1. - 0.85 * abs (mod (az + pi, 2. * pi) - pi) / pi);\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 10.;\n  for (int j = 0; j < 3; j ++) {\n    f += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / (1.75 * a));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGXDD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1085, 1085, 1108, 1108, 4183], [4185, 4185, 4219, 4219, 4750], [4752, 4752, 4774, 4774, 5093], [5095, 5095, 5117, 5117, 6199], [6201, 6201, 6242, 6242, 6491], [6493, 6493, 6544, 6544, 7277], [7279, 7279, 7298, 7298, 8135], [8137, 8137, 8172, 8172, 9806], [9808, 9808, 9830, 9830, 10900], [10902, 10902, 10935, 10935, 11182], [11184, 11184, 11205, 11205, 11460], [11462, 11462, 11494, 11494, 13206], [13208, 13208, 13230, 13230, 13371], [13373, 13373, 13407, 13407, 14022], [14024, 14024, 14059, 14059, 15748], [15792, 15792, 15848, 15848, 17239], [17241, 17241, 17284, 17284, 17348], [17350, 17350, 17407, 17407, 17490], [17492, 17492, 17528, 17528, 17734], [17736, 17736, 17766, 17766, 17879], [17913, 17913, 17937, 17937, 17990], [17992, 17992, 18016, 18016, 18128], [18130, 18130, 18155, 18155, 18301], [18303, 18303, 18328, 18328, 18514], [18516, 18516, 18539, 18539, 18706], [18708, 18708, 18729, 18729, 18884]], "test": "untested"}
{"id": "fdySWW", "name": "earth ship 2d", "author": "jorge2017a2", "description": "earth ship 2d", "tags": ["earthship2d"], "likes": 0, "viewed": 200, "published": 3, "date": "1634607945", "time_retrieved": "2024-07-30T18:54:53.051951", "image_code": "///earth ship 2d- por-JFP\n///por jorge2017a2...2021-oct-18\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n    return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{   vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{   vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nvec3 Cielo(vec2 p, vec3 col)\n{  col=DrawFig(vec3(0.2,0.0,0.3), col, -p.y+3.5 );\n return col;\n}\n\nvec3 colina(vec2 p, vec3 col)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,2.0) );\n    col=DrawFigBordeCol(vec3(0.3), col, d1 , vec3(0.35));\n    return col;\n}\n\nvec3 columna2(vec2 p, vec3 col)\n{   //esta funcion se puede mejorar....solo con usar la funcion  DrawFigBordeCol\n    // y asi se eliminan funciones ...ver la nave\n    float d1= sdTrapezoid( vec2(p.x, -p.y), 1.2, 1.5, 0.5 );\n    float d2= sdTrapezoid( vec2(p.x, -p.y)-vec2(-0.5,0.0), 0.5, 0.8, 0.4 );\n    float d3=sdParallelogram(vec2(p.x,-p.y)-vec2(0.8,0.0), 0.4, 0.4, 0.15 );    \n    float d4=sdBox(p-vec2(-0.5,-3.0), vec2(0.9,2.5) );\n    float d5=sdBox(p-vec2(0.9,-3.0), vec2(0.55,2.5) );\n    float d4a=sdBox(p-vec2(-0.5,-2.9), vec2(0.8,2.4) );\n    float d5a=sdBox(p-vec2(0.9,-2.9), vec2(0.4,2.4) );\n    //parte inferior\n    float d6= sdTrapezoid( vec2(p.x, -p.y)-vec2(-0.5,5.8), 0.8, 1.4, 0.5 );\n    float d7=sdParallelogram(vec2(p.x,-p.y)-vec2(1.25,5.85), 0.65, 0.45, 0.25 );    \n    float d6a= sdTrapezoid( vec2(p.x, -p.y)-vec2(-0.5,5.8), 0.6, 1.2, 0.35 );\n    float d7a=sdParallelogram(vec2(p.x,-p.y)-vec2(1.2,5.8), 0.5, 0.3, 0.25 );    \n    \n    col=DrawFig(vec3(1.0), col, d1);\n    col=DrawFig(vec3(0.0), col, d2);\n    col=DrawFig(vec3(0.0), col, d3);\n    col=DrawFig(vec3(1.0), col, d4);\n    col=DrawFig(vec3(1.0), col, d5);\n    col=DrawFig(vec3(0.0), col, d4a);\n    col=DrawFig(vec3(0.0), col, d5a);\n    col=DrawFig(vec3(1.0), col, d6);\n    col=DrawFig(vec3(1.0), col, d7);\n    col=DrawFig(vec3(0.0), col, d6a);\n    col=DrawFig(vec3(0.0), col, d7a);\n    return col;\n}\n\n\nvec3 Nave(vec2 p, vec3 col)\n{   float d1= sdTriangleIsosceles(vec2(p.x, -p.y), vec2(1.0,1.0) );\n    float d2=sdParallelogram(vec2(p.x,-p.y)-vec2(1.1,0.5), 0.5, 0.5, 0.45 );    \n    float d3=sdParallelogram(vec2(p.x,-p.y)-vec2(2.1,0.5), 0.5, 0.5, 0.45 );    \n    float d4= sdBox(p-vec2(1.0,-1.5), vec2(2.0,0.5) );\n    float d5= sdTrapezoid( vec2(p.x, -p.y)-vec2(1.1,2.4), 2.0, 1.5, 0.35 );\n    col=DrawFigBordeCol(vec3(0.0),col,d1,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d2,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d3,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d4,vec3(1.0));\n    col=DrawFigBordeCol(vec3(0.0),col,d5,vec3(1.0));    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.5)-uv.y*0.125;\n    uv*=8.0;\n    vec2 uv1=uv;\n    \n    uv1.x= opRep1D(uv1.x-5.0+iTime*5.0, 25.0 );\n    col= Cielo(uv, col);\n    col=colina(uv1-vec2(0.0,5.0), col);\n    col=columna2(uv1*2.0-vec2(10.0,12.0), col);\n    col=columna2(uv1*1.5-vec2(5.0,5.0), col);\n    col=columna2(uv1*1.5-vec2(15.0,6.0), col);\n    col= Nave(uv-vec2(0.0,1.0+2.0*sin(iTime*0.5)),col);\n    col=columna2(uv1, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdySWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 315, 351, 351, 396], [401, 445, 492, 492, 519], [520, 520, 563, 563, 590], [591, 591, 639, 639, 667], [673, 673, 735, 735, 931], [933, 933, 1014, 1014, 1141], [1143, 1143, 1200, 1200, 1270], [1272, 1272, 1309, 1309, 1387], [1388, 1388, 1413, 1413, 1432], [1434, 1434, 1485, 1485, 1791], [1793, 1793, 1858, 1858, 2168], [2170, 2170, 2236, 2236, 2576], [2578, 2578, 2608, 2608, 2672], [2674, 2674, 2705, 2705, 2878], [2880, 2880, 2913, 3042, 4257], [4260, 4260, 4289, 4289, 4935], [4937, 4937, 4994, 4994, 5530]], "test": "untested"}
{"id": "7dKXDz", "name": "Cavern Explorer mf", "author": "milkfat", "description": "Geometry is generated from a single texture and should go on forever with no obvious repetition.\nAutopilot can be disabled. It also has adjustable parameters in Buffer A.\nAA and other options in Common tab.\nKeyboard and mouse control: WASD + shift ", "tags": ["procedural", "heightmap", "autopilot"], "likes": 17, "viewed": 424, "published": 3, "date": "1634597569", "time_retrieved": "2024-07-30T18:54:54.289642", "image_code": "\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    F=texelFetch(iChannel0,ivec2(C-.5),0);\n    //if(distance(C,texelFetch(iChannel1,ivec2(6,0),0).zw)<10.0)F=vec4(1);  //navigation dot\n    //F=vec4(texelFetch(iChannel0,ivec2(C-.5),0).w/1000.0);                 //depth map\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//inputs and navigation\n\n#define SPEED 50.0          //travel speed\n#define DIVISOR 10.0        //rate of turning (low numbers = fast, high numbers = slow) \n#define SMOOTHING 221.0     //the number of frames over which to smooth our navigation choices\n#define DAMPENING .25        //the amount of dampening, avoids bouncing back and forth\n#define CENTER_WEIGHT 1.0   //navigation preference toward the center of the screen\n#define DISTANCE_WEIGHT 2.0 //navigation preference toward far away pixels\n\n\n#define NAVIGATION_GRID 30 //grid density to sample the scene for navigation: lower numbers = jittery, higher numbers = smooth\n\n\nvoid mainImage( out vec4 F, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord-.5);\n    if(coord.x>8||coord.y>0)return;\n    \n    //(0,0).xy  = mouse click position\n    //(1,0).xy  = mouse down position\n    //(2,0).xyz = camera position\n    //(3,0).xy  = camera click angle\n    //(4,0).xy  = camera current angles\n    //(5,0).xyz  = camera direction\n    //(6,0).xyz  = furthest pixel\n    //(7,0).xyz  = amount to move next frame\n    //(8,0).x  = center pixel distance\n    vec4 mc   = texelFetch(iChannel0,ivec2(0,0),0);\n    vec4 md   = texelFetch(iChannel0,ivec2(1,0),0);\n    vec3 pos  = texelFetch(iChannel0,ivec2(2,0),0).xyz;\n    vec2 ang  = texelFetch(iChannel0,ivec2(3,0),0).xy;\n    vec2 angb = texelFetch(iChannel0,ivec2(4,0),0).xy;\n    vec3 dir  = vec3(0,0,1);\n    vec2 aim  = texelFetch(iChannel0,ivec2(6,0),0).xy;\n    float cdist  = texelFetch(iChannel0,ivec2(8,0),0).x;\n#ifndef DISABLE_AUTOPILOT\n    float move  = texelFetch(iChannel0,ivec2(7,0),0).x;\n    ang+=aim;\n#else\n    float move = 0.0;\n#endif\n    \n\n    if(iFrame==1){\n        F=vec4(0);\n        F=coord==ivec2(5,0)?vec4(0,0,1,0):F;  //initial direction\n        F=coord==ivec2(3,0)?vec4(hash(iTimeDelta*.97137)*2.0-1.0,hash(iTimeDelta)-.5,0,0):F;  //initial direction\n        F=coord==ivec2(2,0)?vec4(-10,3,-32,0):F; //initial position\n        \n        return;\n    }\n    \n    if(iMouse.w>0.)\n    {\n        mc = iMouse;\n        ang+=angb;\n        angb = vec2(0);\n    }\n    vec2 rot = -ang-angb;\n    if(iMouse.z>0.)\n    {\n        md = iMouse;\n        angb=(iMouse.xy-mc.xy)/iResolution.xy;\n    }\n    \n    dir.yz = rotate(dir.yz,rot.y*3.14159);\n    dir.xz = rotate(dir.xz,rot.x*3.14159);\n    \n    \n    if(coord==ivec2(0,0))F=mc;\n    if(coord==ivec2(1,0))F=md;\n    if(coord==ivec2(2,0))\n    {\n        float shift = texelFetch(iChannel1,ivec2(16,0),0).x > 0.?4.0:1.0;\n        if(texelFetch(iChannel1,ivec2(87,0),0).x > 0.)pos+=dir*shift;\n        pos+=dir*move*iTimeDelta*SPEED;\n        if(texelFetch(iChannel1,ivec2(83,0),0).x > 0.)pos-=dir*shift;\n        vec3 dirr = vec3(1,0,0);\n        dirr.yz = rotate(dirr.yz,rot.y*3.14159);\n        dirr.xz = rotate(dirr.xz,rot.x*3.14159);\n        if(texelFetch(iChannel1,ivec2(68,0),0).x > 0.)pos+=dirr*shift;\n        if(texelFetch(iChannel1,ivec2(65,0),0).x > 0.)pos-=dirr*shift;\n        float up = texelFetch(iChannel1,ivec2(32,0),0).x > 0.?1.0:0.0;\n        float down = texelFetch(iChannel1,ivec2(67,0),0).x > 0.?1.0:0.0;\n        pos.y+=up;\n        pos.y-=down;\n        F.xyz = pos;\n    }\n    \n    int samps = 0;\n    \n    if(coord==ivec2(6,0))samps=NAVIGATION_GRID;\n    \n    vec4 pix = vec4(0);\n    \n    vec2 accum = vec2(0);\n    float cnt = 0.0;\n    float min_d = 1000.0;\n    float avg = 0.0;\n    float cnt2 = 0.0;\n    \n\n    //sample the scene depth (alpha channel) for navigation\n    for(int y = 0; y < samps; y++)\n    {\n        for(int x = 0; x < samps; x++)\n        {\n            cnt2++;\n            ivec2 c = ivec2(x*int(iResolution.x)/samps,y*int(iResolution.y)/samps);\n            vec2 c2 = vec2(c);\n            vec4 tpix = texelFetch(iChannel2,c,0);\n            //weight the farthest pixels more highly than close\n            float adj = pow(tpix.w/VIEW_DISTANCE,DISTANCE_WEIGHT);\n            \n            avg+=tpix.w;\n            //weight the center of the screen more highly than the edges\n            float cent = pow(1.0-(distance(c2,iResolution.xy*.5)/iResolution.x*.5),CENTER_WEIGHT);\n            adj*=cent;\n            cnt+=adj;\n            accum+=c2*adj;\n            min_d=min(min_d,tpix.w);\n            if(tpix.w>pix.w)\n            {\n                pix.xy = c2;\n                pix.w = tpix.w;\n            }\n      }\n    }\n    avg/=cnt2;\n    accum/=cnt;\n    float frame_mult = iTimeDelta*60.0;\n    aim=aim*(SMOOTHING-frame_mult)+frame_mult*(accum.xy-iResolution.xy*.5)/(avg*DIVISOR);\n    aim/=(SMOOTHING-frame_mult);\n    aim*=1.0-DAMPENING;\n\n    \n    //limit camera up/down angle to avoid ending upside down \n    float ty = min(max(ang.y+angb.y,-.5),.5);\n    ang.y += ty-(ang.y+angb.y);\n    \n    if(coord==ivec2(3,0))F.xy=ang;\n    if(coord==ivec2(4,0))F.xy=angb;\n    if(coord==ivec2(5,0))F.xyz=dir;\n    if(coord==ivec2(6,0))F=vec4(aim.xy,accum.xy); //adjust our direction\n    if(coord==ivec2(8,0))F=texelFetch(iChannel2,ivec2(iResolution.xy*.5),0);\n    \n#ifndef DISABLE_AUTOPILOT\n    //slow down before running into something\n    float mv = texelFetch(iChannel2,ivec2(iResolution.xy*.5),0).w;\n    mv = clamp((mv-10.0)/50.0,0.0,1.0);\n    if(coord==ivec2(7,0))F=vec4(min(mv,move+mv*.01));\n#endif\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//render\n\n#define LIGHTBULB (cam+dir*DYNAMIC_LIGHT_Z*clamp((texelFetch(iChannel3,ivec2(8,0),0).w-10.0)/DYNAMIC_LIGHT_Z,0.0,1.0))\n#define u vec2(.1,0)\n\n\nfloat scene(vec3 p)\n{\n\n    //heightmap\n    float h = texture(iChannel0,fract((p.xz+vec2(p.z*.1,0))*.03)).r;\n    float h2 = texture(iChannel0,fract(p.xz*.0007+vec2(p.y*.00015,0.0))).r;\n    float h3 = texture(iChannel0,fract(p.yz*.0007+vec2(.01,p.x*.00005))).r;\n    float h4 = texture(iChannel0,fract(p.xy*.0007+vec2(0.0,p.z*.00007))).r;    \n\n    //ground\n    float d =  (h2+h3+h4)-h/50.;\n\n    return (d*60.-58.8);\n}\n\nvec4 render_pixel(vec2 C)\n{\n    vec4 F = vec4(0);\n    vec3 p = texelFetch(iChannel3,ivec2(2,0),0).xyz;\n    vec3 ps = normalize(vec3(C,iResolution.x*FOV));\n    vec3 cam = p;\n    vec3 dir  = texelFetch(iChannel3,ivec2(5,0),0).xyz;\n    vec2 ang  = texelFetch(iChannel3,ivec2(3,0),0).xy + texelFetch(iChannel3,ivec2(4,0),0).xy + texelFetch(iChannel3,ivec2(6,0),0).xy;\n\n    ps.yz=rotate(ps.yz,-ang.y*3.14159);\n    ps.xz=rotate(ps.xz,-ang.x*3.14159);\n    \n    float min_d = 100000.0;\n    float travel = 0.0;\n    float cnt = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        cnt++;\n        float d = scene(p);\n        if(d<0.0)d*=.3;             //limit our backtracking (for super tall heightmap)\n        d=sign(d)*min(abs(d),15.0); //limit max distance\n        min_d = min(min_d,d);\n        p+=d*ps;   //limit our travel to a fraction of distance\n        travel+=d;\n        if(abs(d)<.01 ||travel > VIEW_DISTANCE)break;\n    }\n\n    vec3 norm = normalize(vec3(scene(p+u.xyy)-scene(p-u.xyy), scene(p+u.yxy)-scene(p-u.yxy), scene(p+u.yyx)-scene(p-u.yyx)));\n    \n#ifdef DYNAMIC_LIGHTING\n    int id3 = 0;\n    float travel2 = 0.0;\n    float cnt2 = 0.0;\n    vec3 p2 = p;\n    vec3 ps2 = normalize(LIGHTBULB-p2);\n    p2+=ps2*3.;\n    float min_d2 = 10000.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        cnt2++;\n        float d = scene(p2);\n        float db = d;\n        d = min(d,distance(p2,LIGHTBULB)-2.0);\n        id3 = (d==db)?id3:2;\n        min_d2 = id3==0?min(d,min_d2):min_d2;\n        if(d<0.0)d*=.3;             //limit our backtracking (for super tall heightmap)\n        d=sign(d)*min(abs(d),15.0); //limit max distance\n        p2+=d*ps2*((id3==0)?.8:1.0);   //limit our travel to a fraction of distance\n        travel2+=d*((id3==0)?.8:1.0);\n        if(abs(d)<.01 ||travel2 > VIEW_DISTANCE)break;\n    }\n#endif\n\n    //3d texture\n    vec4 tex0a = pow(texture(iChannel1,p.xz*.02),vec4(2.2));\n    vec4 tex0b = pow(texture(iChannel1,p.yz*.02),vec4(2.2));\n    vec4 tex0c = pow(texture(iChannel1,p.xy*.02),vec4(2.2));\n    vec4 tex0 = abs(norm.x)*tex0b+abs(norm.y)*tex0a+abs(norm.z)*tex0c;\n    \n    //blend textures together\n    float v = clamp((p.y+20.0)/5.0,0.0,1.0);\n    vec4 tex = tex0*v+tex0*(1.0-v);\n    float v2 = clamp((p.y-2.0)/15.0,0.0,1.0);\n    //tex = tex*(1.0-v2)+tex2*v2;\n\n    float bri = clamp(dot(norm, normalize(cam+LIGHT-p)),0.,1.);\n    bri = pow(bri,2.);\n    float ld = 1.0-distance(p,cam+LIGHT)/VIEW_DISTANCE;\n    ld=ld*ld*ld;\n    \n    if(min_d < .01) F=tex;\n    \n#ifndef DYNAMIC_LIGHTING\n    F*=bri*ld*2.0;\n    F*=1.0-travel/VIEW_DISTANCE;\n#else\n    if(id3==2)\n    {    \n        float bri = clamp(dot(norm, normalize(LIGHTBULB-p)),0.,1.);\n        bri = pow(bri,2.);\n        float bri2 = 1.0-clamp((SOFT_LIGHT-min_d2)/SOFT_LIGHT,0.0,1.0);\n        float ld = clamp(1.0-distance(p,LIGHTBULB)/BRIGHT,0.0,1.0);\n        ld=ld*ld*ld;\n        F.xyz=F.xyz*bri*ld*2.0*bri2+F.xyz*.00;\n    } else {F.xyz*=.00;}\n#endif\n\n    F.w=travel;\n    return F;\n}\n\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    const int ss = max(AA,1);\n\n    \n    F=vec4(0);\n    C-=iResolution.xy*.5;\n\n    for(int y = 0; y < ss; y++) //super sampling\n    {\n        for(int x = 0; x < ss; x++)\n        {\n            F+=render_pixel(C+vec2(float(x)/float(ss),float(y)/float(ss)));\n        }\n    }\n    \n    F/=float(ss*ss);\n    F.xyz=pow(F.xyz,vec3(1.0/2.2));\n}", "buffer_b_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n//#define DISABLE_AUTOPILOT  //disables automatic navigation\n\n#define AA 1                 //amount of super sampling AA\n#define FOV .4\n#define VIEW_DISTANCE 1000.0 //max render distance\n#define LIGHT vec3(0,1,3)    //position of static light source relative to the camera\n#define MAX_STEPS 200        //max number of marching steps\n\n\n//#define DYNAMIC_LIGHTING   //enables dynamic lighting, experimental\n#define DYNAMIC_LIGHT_Z 50.0 //distance of dynamic light source in front of the camera\n#define BRIGHT 1050.0        //dynamic light distance\n#define SOFT_LIGHT 2.0       //shadow softness\n\n\n\nfloat hash(float p) {\n   // p=isnan(p)?0.0:p;\n    p=fract(p*.917331);\n    uint b = uint(p*123456.7);\n\tb += 0x9e3779b9u;\n\tb ^= b >> 15;\n\tb *= 0x85ebca6bu;\n\tb ^= b >> 13;\n\tb *= 0xc2b2ae3du;\n\tb ^= b >> 16;\n\treturn fract(abs(float(b)/1000000.0));\n}\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);}\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 268]], "test": "untested"}
{"id": "7sVXW1", "name": "sound wave interference", "author": "Veggiebob", "description": "shows wave interference of two sources, one in the (0,0) corner and one the mouse", "tags": ["trig", "intereference"], "likes": 5, "viewed": 404, "published": 3, "date": "1634594791", "time_retrieved": "2024-07-30T18:54:55.251071", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec2 p1 = vec2(0.0, 0.0);\n    vec2 p2 = iMouse.xy / iResolution.xy;\n    \n    \n    float f = 55.0;\n    \n    float sync = 0.; // sin(iTime * 1.0); // phase offset\n    float beat = 0.; // 20. * sin(iTime); // frequency offset\n    \n    float p1_mag = sin(f * length(uv - p1));\n    float p2_mag = sin((f + beat) * length(uv - p2) + sync);\n    \n    float total = p1_mag + p2_mag;\n    // Output to screen\n    fragColor = vec4(vec3(total),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 623]], "test": "untested"}
{"id": "sdySWh", "name": "Day 669", "author": "jeyko", "description": "potate", "tags": ["design", "poster", "mdtmjvm", "acidgraphics"], "likes": 27, "viewed": 540, "published": 3, "date": "1634583905", "time_retrieved": "2024-07-30T18:54:56.194549", "image_code": "// Fork of \"Day 539\" by jeyko. https://shadertoy.com/view/slSGz1\n// 2021-06-11 08:12:26\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 3.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    n = sin(n*2.);\n    return n;\n}\n\nvec3 get(vec2 fc, vec2 uv){\n    vec2 coord = fc/iResolution.xy;\n    float chrabamt = 0.;\n    vec3 c = vec3(\n        texture(iChannel0,coord+ chrabamt*vec2(0.00,0.001)).x,\n        texture(iChannel0,coord + chrabamt*vec2(0.001,0.00)).y,\n        texture(iChannel0,coord + chrabamt*vec2(-0.001,0.00)).z\n        );\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //fragCoord += 250.*noise(vec3(uv*2.5,5.))/iResolution.xy;\n    col = get(fragCoord,uv);\n    \n    float no = noise(vec3(uv*2.,35.));\n    //col = mix(col,vec3(0),smoothstep(0.,0.5,max(noise(vec3(uv*2.2 + 0.1,35.)) - 0.5,0.))*0.4);\n    \n    col = mix(col,vec3(1),smoothstep(0.,5.,max(no - 0.5,0.))*.05);\n    \n    //col += min(no - 0.5,0.)*0.02;\n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame)*0.,0.),256.)),0).x*0.5;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz*0.6;\n    \n    \n    //C = smoothstep(0.,1.,C);z\n    \n    //col.xyz = pow(max(col.xyz,0.), vec3(0.55) + n*0.1);\n    \n    \n    \n    col = pow(clamp(col,0.,1.),vec3(0.4545));\n\n    col.xyz += smoothstep(1.,0.,length(col))*n*0.2;\n    \n    col.xyz -= smoothstep(0.,1.,length(col))*n*0.1;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 gg(vec3 p){\n    p.xz *=rot(0.25);\n    p.x += (iTime + sin(iTime))*0.2;\n    vec3 c = vec3(0);\n    p*=4.16;\n    gp = p;\n    float md = 2.;\n    //p.x += iTime + sin(iTime);\n    vec3 id = floor(p/md);\n    //p.x = pmod(p.x,md);\n    c += mod(id.x,2.);\n    c = vec3(dot(c,c));\n    c = clamp(c*20.,0.06,1.);\n    return c;\n}\n    \nvec3 get(vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float pxSz = fwidth(uv.y);\n    vec3 col = vec3(1);\n\n    \n\n    // 3d\n    {\n        vec3 ro = vec3(0);\n        vec3 rd = normalize(vec3(uv,0.2));\n        rd.yx*=rot(0.5);\n        float t = iTime + sin(iTime + 3.);\n        vec3 p = ro;\n        vec3 att = vec3(1);\n        vec3 C = vec3(0);\n        \n        for(float bnc = 0.; bnc < 1.; bnc++){\n            vec2 box = intersect(p,rd);\n            p = p + rd*box.y;\n            vec3 c = gg(p);\n            //C.xyz += c*att;\n            att *= c;\n            float bncSubCnt = 10.;\n            float ratio = 0.1 + 0.9*floor(mod(gp.y*2.,2.));;\n\n            p += n*0.002;\n            for(float bncSub = 0.; bncSub < bncSubCnt; bncSub++){\n                vec3 diff = hash33(vec3(uv*16.,bncSub + float(iFrame)*0.6));\n                diff = normalize(diff);\n                if(dot(diff,n)<0.)\n                    diff = -diff;\n\n                vec3 brd = reflect(rd,n);\n                brd = mix(-brd,diff,ratio);\n                brd = normalize(brd);\n                vec2 scene = intersect(p,brd);\n                vec3 pp = p + brd * scene.y;\n                vec3 c = gg(pp);\n                C += c*att/bncSubCnt;\n                //att *= c;\n\n                //vec2 \n            }\n        }\n        C = clamp(C,0.,1.);\n        vec2 luv = uv;\n        luv.y += 0.3;\n        float d = sdBox( luv, vec2(0.,0.3) ) - 0.3;\n        \n        //C = mix(vec3(0.8,0.6,0.5)*1.,vec3(1.,0.4,0.1)*0.,C);\n        C = mix(vec3(0.8,0.6,0.5)*1.,vec3(1.,0.6,0.5)*0.2,C);\n        \n        //C = 1.-C*0.5;\n        //col = mix(col,C,smoothstep(pxSz,0.,d));\n        //col = col - (1.-col)*C*1.;\n        //col = mix(col,C,smoothstep(0.9,1.,col));\n        col = mix(col,C,col);\n    \n    }\n    \n        // Left thing\n    {\n        float p = 0.;\n        vec2 luv = uv + vec2(0.5,-0.02);\n        vec2 u = luv*1. + 1. ;\n        float acc = 0.;\n        for(float i = 1.; i < 17.; i++){\n            float mul = 2.*i;\n            if(mod(i,2.) == 0.){\n                p += xor(u.y*mul,u.x*mul + floor(iTime*2. + u.y))*1.;\n                acc += p;\n            } else {\n                u += and(u.x*mul - floor(iTime*4. + u.y) ,u.y*mul)*1.;\n\n                p += xor(u.x*mul + floor(iTime*4. + u.y) ,u.y*mul)*1.;\n                acc += p ;\n            }\n            p = mod(p*1.,2.);\n        }\n        \n        \n        vec3 c = pal(vec3(1.,0.2,0.5),0.5,vec3(3,2,1),1.,acc*20. + iTime);\n        c = pow(abs(c),vec3(0.1,0.2,1));\n        \n        p = clamp(p,0.,1.);\n        vec2 bsz = vec2(0.0,0.0);\n        float d = sdBox( luv, bsz ) - 0.05;\n        bsz += 0.156;\n        d -= 0.001;\n        \n        float db = sdBox( luv, bsz );\n        db = max(  \n            max(db,-abs(d - 0.14)+0.014)  ,\n            -d + 0.14);\n        \n        db = min(db, abs(luv.x - 0.2)-0.001);\n        db = min(db, abs(luv.x - 0.8)-0.001);\n        \n        db = min(db, \n                max(\n                    abs(luv.y - 0.255)-0.001,\n                    -abs(luv.x - 0.5) + 0.3\n                )\n            );\n            \n        // remove maybe\n        db = min(db, \n                max(\n                    abs(luv.y - 0.29)-0.001,\n                    (luv.x - 0.5) + 0.3\n                )\n            );\n        db = min(db, \n                max(\n                    abs(luv.y + 0.256)-0.001,\n                    (luv.x - 0.5) + 0.3\n                )\n            );\n            \n        // star thing\n        float s = 0.06;\n        \n        vec2 lluv = abs(luv) - vec2(0.2,0);\n        float dc = length(lluv) - s;\n        \n        dc = max(dc,lluv.x);\n        lluv = abs(lluv) - s;\n        dc = max(dc,-length(lluv) + s);\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,dc));\n        \n        // aaaaa\n        \n        //db = min(db,sdBox( luv + vec2(bsz.x*2.,0.), bsz ));\n        col = mix(col,vec3(0),smoothstep(pxSz,0.,db));\n        \n        col = mix(col,mix(vec3(0),c,p),smoothstep(pxSz,0.,d - 0.07));\n        \n        //col = mix(col,vec3(p),smoothstep(pxSz,0.,d - 0.07));\n        col = mix(col,vec3(0),smoothstep(pxSz,0.,abs(d - 0.07) - 0.003));\n        \n    }\n    // Top thing\n    {\n        float p = 0.;\n        vec2 luv = uv + vec2(0.,-0.4);\n        vec2 u = luv*1. + 1. ;\n        p = clamp(p,0.,1.);\n        vec2 bsz = vec2(0.1,0.00);\n        float d = sdBox( luv, bsz );\n        float s = 0.02;\n        d -= 0.01;\n        col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n        \n        float db = sdBox( luv, vec2(0.3,0.001) );\n        float dbb = sdBox( -luv, vec2(0.3,0.001) );\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,db));\n        col = mix(col,vec3(0),smoothstep(pxSz,0.,dbb));\n        \n        luv = abs(luv) - vec2(bsz*2.);\n        float dc = length(luv) - s;\n        \n        dc = max(dc,luv.x);\n        luv = abs(luv) - 0.02;\n        dc = max(dc,-length(luv) + s);\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,dc));\n        \n        \n    }\n\n    // deez balls\n    {\n        float range = 3.;\n        float id = floor(iTime/range);\n        float a = abs(sin(id))*10.;\n        float b = abs(sin(id + 1.))*10.;\n        float fact = smoothstep(0.,0.5,fract(iTime/range));\n        float bs;\n        bs = mix(a,b,fact);\n        \n        float ballCnt = 16. + bs;\n        float layerCnt = 2.;\n        for (float ball = 0.; ball < ballCnt; ball++){\n            for (float layer = 0.; layer < layerCnt; layer++){\n                \n                float ttt = mod(iTime + ball/ballCnt,3.);\n                float pump = smoothstep(0.,0.2,ttt)*smoothstep(0.4,0.,ttt);\n    \n                float env = mod((iTime + layer/layerCnt + ball/ballCnt*(2.) + sin(iTime)*0.3)*0.5,0.99);\n                \n                float ballidx = ball/ballCnt*pi*4. +layer/layerCnt*pi*0. + env;\n                vec2 p = vec2(\n                    sin(ballidx),cos(ballidx)\n                    ) *(0. +env*2.5 + pump)*0.1;\n                \n                float size = smoothstep(0.,1.,env)*smoothstep(1.,0.2,env)*0.1 -0.01;\n                //float size = 0.01;\n                col = mix(col,vec3(0),smoothstep(pxSz,0.,length(uv - p) - size));\n                    \n            }\n\n        }\n    \n    }\n    // top left\n    {\n        vec2 luv = uv;\n        luv.x += 0.64;\n        luv.y -= 0.37;\n        // blocks\n        for(float i = 0.; i < 3.; i++){\n            float d = sdBox(luv, vec2(0.007));    \n            vec3 c = pal(vec3(1.,0.2,0.5),0.5,vec3(3,2,1),1.,i + iTime);\n            c = pow(abs(c),vec3(0.1,0.2,1));\n            col = mix(col,c,smoothstep(pxSz,0.,d));\n            \n            d = abs(d) - 0.003;\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n            luv.x -= 0.04;\n        }\n        luv.x -= 0.1;\n        luv.y += 0.0;\n        \n        float range = 1.;\n        float a = abs(sin(iTime));\n        float b = abs(sin(iTime*1.4));\n        float fact = smoothstep(0.,0.5,fract(iTime/range));\n        float id = floor(iTime/range);\n        float bs;\n        if(mod(id,2.) == 0.){\n            bs = mix(a,b,fact);\n        }else {\n            bs = mix(b,a,fact);\n        }\n        \n        float d = sdBox(luv + vec2(bs*2. - 1.,0.)*0.02, vec2(0.007));\n        d = abs(d) - 0.003;\n        luv.y = abs(luv.y);\n        d = min(d,sdBox(luv - vec2(0,0.01),vec2(0.04,0.001)) - 0.001);\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n                \n        \n    }\n    // Bottom thing\n    {\n        float p = 0.;\n        vec2 luv = uv + vec2(-0.01,0.4);\n        vec2 u = luv*1. ;\n        u = abs(u);\n        u.x += u.y;\n        float acc = 0.;\n        float T = iTime + sin(iTime);\n        T *= 0.5;\n        for(float i = 1.; i < 7.; i++){\n            float mul = 2.*i;\n            if(mod(i,2.) == 0.){\n                p += xor(u.y*mul,u.x*mul- T  )*1.;\n            } else {\n                u += and(u.x*mul - T   ,u.y*mul- T)*1.;\n\n                p += xor(u.x*mul  ,u.y*mul)*1.;\n\n            }\n            acc += p + u.x + u.y;\n            p = mod(p*1.,3.);\n        }\n        vec3 c = pal(vec3(1.,0.2,0.5),0.5,vec3(3,2,1),1.,acc + iTime);\n        c = pow(abs(c),vec3(0.1,0.2,1));\n        c = 1.-col*vec3(0.,0.8,0.2)*0.5 + c*0.5;\n        p = clamp(p,0.,1.);\n        vec2 bsz = vec2(0.1,0.0);\n        float d = sdBox( luv, bsz );\n        luv   -= vec2(-0.01,0.);\n        float db = sdBox( luv  , vec2(0.3,0.001) );\n        float dbb = sdBox( -luv , vec2(0.3,0.001) );\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,db));\n        col = mix(col,vec3(0),smoothstep(pxSz,0.,dbb));\n        \n        d = d - 0.03;\n        col = mix(col,mix(vec3(0),c,p),smoothstep(pxSz,0.,d));\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,abs(d) - 0.004));\n        \n        \n        float s = 0.02;\n        luv = abs(luv) - vec2(bsz*3.);\n        float dc = length(luv) - s;\n        \n        dc = max(dc,luv.x);\n        luv = abs(luv) - 0.02;\n        dc = max(dc,-length(luv) + s);\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,dc));\n        \n    }\n    // right\n    {\n        vec2 luv = uv;\n        luv.x -= 0.4;\n        luv.y -= 0.2;\n        // blocks\n        for(float i = 0.; i < 5.; i++){\n            float d = sdBox(luv, vec2(0.007));    \n            vec3 c = pal(vec3(1.,0.2,0.5),0.5,vec3(3,2,1),1.,i + iTime);\n            c = pow(abs(c),vec3(0.1,0.2,1));\n            col = mix(col,c,smoothstep(pxSz,0.,d));\n            \n            d = abs(d) - 0.003;\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n            luv.y += 0.04;\n        }\n        luv.y += 0.02;\n        // balls\n        float balld = 0.2;\n        float balliters = 5.;\n        \n        float env = sin(iTime);\n        float bd = sdBox(luv +vec2(0.,balld*0.79 + env*balld*0.6),vec2(0,balld*(0.4-abs(env)*0.4)));\n        col = mix(col,vec3(0),smoothstep(pxSz,0.,bd-0.003));\n            \n        for(float i = 0.; i < balliters-1.; i++){\n            luv.y += balld/balliters;\n            float d = length(luv);\n            d = abs(d) - 0.004;\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n            luv.y += 0.04;\n        }\n        // other blocks\n        luv.y -= 0.4;\n        luv.x += 0.1;\n        float iters = 5.;\n        for(float i = 0.; i < iters; i++){\n            vec2 u = luv;\n            //u *= rot(i*iters*pi);\n            float d = sdBox(luv, vec2(0.002,0.01));    \n            d = abs(d) - 0.003;\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n            luv.y += 0.04;\n        }\n    }\n    // bottom left\n    {\n        vec2 luv = uv;\n        luv.x += 0.55;\n        luv.y += 0.35;\n        float iters = 15.;\n        for(float i = 0.; i < iters; i++){\n            vec2 u = luv;\n            u *= rot(i/iters*pi*2.);\n            u.y -= 0.02+ 0.03*abs(sin(iTime*2. + i));\n            float d = sdBox(u, vec2(0.00,0.003));    \n            d = abs(d) - 0.002;\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n        }\n        luv.x -= 0.15;\n        luv.y += 0.;\n        /*\n        iters = 8.;\n        float d = 10e5;    \n            \n        for(float i = 0.; i < iters; i++){\n            vec2 u = luv;\n            u *= rot(i/iters*pi*4. + sin(iTime + i));\n            //u.y -= 0.02+ 0.03*abs(sin(iTime*2. + i));\n            float ld = length(u + 0.01) - 0.02*(sin(iTime*2. + i*0.6)) - 0.02;\n            //ld = abs(ld) - 0.002;\n            d = xord(d,ld,0.02);\n        }\n        d = abs(d) - 0.001;\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n        */\n        luv.y += 0.005;\n        float md = 0.015;\n        float range = 4.;\n        vec2 lluv = luv;\n        vec2 id = floor(lluv/md);\n        lluv = pmod(lluv,md);\n        if(abs(id.x) < range && abs(id.y) < range ){\n            float d = length(lluv) - 0.004*sin(dot(id,id) + iTime*5. + sin(iTime*2.) + id.y);\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n        }\n        \n        // other blocks\n        luv.x -= 0.1;\n        iters = 5.;\n        for(float i = 0.; i < iters; i++){\n            vec2 u = luv;\n            //u *= rot(i*iters*pi);\n            float d = sdBox(luv, vec2(0.002,0.01));    \n            d = abs(d) - 0.003;\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n            luv.y += 0.04;\n        }\n        // other blocks\n        luv.x += 0.35;\n        luv.y -= 0.25;\n        iters = 6.;\n        for(float i = 0.; i < iters; i++){\n            vec2 u = luv;\n            float env = smoothstep(1.,0.,abs(i - mod(iTime*2.,iters + 1.) + 1.));\n            u = abs(u) - 0.02*env;\n            //u *= rot(i*iters*pi);\n            float d = sdBox(u, vec2(0.002,0.002));    \n            d = abs(d) - 0.001;\n            col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n            luv.y += 0.02;\n        }\n        \n    }\n    \n    // Upper black block\n    {\n        vec2 luv = uv;\n        luv.y -= 0.56;\n        float d = sdBox(luv,vec2(0.3,0.1));\n        col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n    }\n    // Outer\n    // edges\n    {\n        vec2 luv = uv;\n        luv = abs(luv) - 0.45;\n        \n        luv *= rot(1.*pi*smoothstep(0.,1.,mod(iTime + float(uv.x>0.) - float(uv.y<0.),4.)));\n        float d = length(luv) - 0.02;\n        luv = abs(luv);\n        luv *= rot(-(1.)*pi);\n        d = max(d,-sdBox(luv,vec2(0.005,0.05)));\n        \n        col = mix(col,vec3(0),smoothstep(pxSz,0.,d));\n    }\n    // colorline\n    {\n        vec2 luv = uv;\n        float d = sdBox(luv - vec2(0.62,0.),vec2(0.075,0.5));\n        vec3 c = pal(vec3(1.,0.2,0.5),0.5,vec3(3,2,1),1.,floor(luv.y*15.) + iTime);\n        c = pow(abs(c),vec3(0.1,0.2,1));\n        col = mix(col,c,smoothstep(pxSz,0.,d));\n    }\n    // dark stuff\n    col = mix(col,col*0.,smoothstep(pxSz,0.,abs(uv.x - 0.5) - 0.05));\n    col = mix(col,vec3(0),smoothstep(pxSz,0.,abs(uv.y + 0.5) - 0.05));\n    col = mix(col,vec3(0),smoothstep(pxSz,0.,-((uv.x) - 0.7) - 0.02));\n    col = mix(col,vec3(0),smoothstep(pxSz,0.,((uv.x) + 0.72) - 0.02));\n    \n    // sticker\n    /*\n    {\n        vec2 luv = uv;\n        luv -= vec2(-0.58,-0.37);\n        luv *= rot(0.1);\n        float boxw = 0.2;\n        float db = sdBox(luv,vec2(boxw,0.1));\n        //vec3 c = pal(vec3(0.9,1,0.5),0.5,vec3(3,2,1),1.,floor(luv.y*15.) + iTime);\n        //c = pow(abs(c),vec3(0.2,5,1));\n        for(float i = 0.; i < 3.; i++){\n        \n            float w = 0.07;\n            vec2 lluv = (luv + vec2(boxw*0.25,0))*0.6;\n            lluv -= vec2(boxw*i/7.*1.,0.);\n            //luv *= rot(0.25*i + iTime);\n            \n            lluv.y *= 2.;\n            \n            float d = length(lluv ) - w;\n            d = max(d,-length(abs(lluv) - w) + w);\n            db = max(db,-d);\n\n        }\n        col = mix(col,vec3(0.1,0.9,0.4),smoothstep(fwidth(db),0.,db));\n        \n        \n    }\n    */\n    // boxes\n    {\n        vec2 luv = uv;\n        luv -= vec2(-0.6,0.5);\n        float d = sdBox(luv,vec2(0.06,0.02));\n        //vec3 c = pal(vec3(0.9,1,0.5),0.5,vec3(3,2,1),1.,floor(luv.y*15.) + iTime);\n        //c = pow(abs(c),vec3(0.2,5,1));\n        col = mix(col,vec3(0.9,0.1,0.2)*0.,smoothstep(pxSz,0.,d));\n        \n        luv = uv;\n        luv -= vec2(0.4,0.29);\n        d = sdBox(luv,vec2(0.1,0.02));\n        //vec3 c = pal(vec3(0.9,1,0.5),0.5,vec3(3,2,1),1.,floor(luv.y*15.) + iTime);\n        //c = pow(abs(c),vec3(0.2,5,1));\n        col = mix(col,vec3(0.9,0.1,0.2)*0.,smoothstep(pxSz,0.,d));\n        \n        \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    float aaSteps = 1.;\n    float pxSz = fwidth(fragCoord.y);\n    for(float i = 0.; i < aaSteps*aaSteps; i++){\n        vec2 coord = fragCoord \n            + (vec2(\n                mod(i,aaSteps),\n                floor(aaSteps)\n            )/aaSteps*2. - 1.)*pxSz/2.;\n        col += get(coord);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat r11(float g){return fract(sin(g*12.5)*4.5);}\n// from iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n// from iq\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n#define xord(a,b,c) min(max(a,-(b) + c),max(b,-(a)))\n    #define xor(a,b) float(int(a)^int(b))\n    #define and(a,b) float(int(a)&int(b))\n    #define or(a,b) float(int(a)|int(b))\n    #define pi acos(-1.)\n    #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n    #define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define pmod(p,a) mod(p,a) - 0.5*a\nvec3 gp;\nvec3 n;\nvec2 intersect(vec3 ro, vec3 rd){\n    //return sphIntersect( ro, rd, vec3(0), 1. );\n    return boxIntersection(ro,rd,vec3(1),n);\n\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdySWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 262, 262, 658], [660, 660, 687, 687, 985], [987, 987, 1044, 1044, 1989]], "test": "untested"}
{"id": "ssVXWh", "name": "Game 2d transition", "author": "ferchoposting", "description": "game 2d transition", "tags": ["transition"], "likes": 2, "viewed": 279, "published": 3, "date": "1634580140", "time_retrieved": "2024-07-30T18:54:56.969477", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv = fract(uv * 4.0);\n    \n    \n    float p = sin(iTime * 2.) / 2.0 + 0.5;\n    \n    // Textures\n    vec3 text = texture(iChannel1, st).rgb;\n    vec3 trans = texture(iChannel0, uv).rgb;\n\n    // Time varying pixel color\n    vec3 col;\n    \n    float m;\n    m = step(trans.x, p);\n    \n    col = vec3(m);\n    col *= text;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    \n    float m;\n    \n    // XY\n    m = dot(st, vec2(0.5));\n    \n    vec3 c = vec3(m);\n    fragColor = vec4(c, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 592]], "test": "untested"}
{"id": "ssKXWh", "name": "Videogame 2D Dash Wave Bubble", "author": "ferchoposting", "description": "Videogame 2D Dash Wave Bubble", "tags": ["wave"], "likes": 2, "viewed": 289, "published": 3, "date": "1634578728", "time_retrieved": "2024-07-30T18:54:57.729445", "image_code": "# define PI 3.141592\n\nfloat scircle(vec2 st, vec2 pos, float r, float s) {\n    float m = distance(pos, st);\n    return 1.0 - smoothstep(r-s, r+s, m);\n}\n\nfloat circle(vec2 st, vec2 pos, float r) {\n    float m = distance(pos, st);\n    return 1.0 - step(r, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Wave progress range from: 0 -> 1.0\n    float p = fract(iTime * 2.5);\n    \n    // Wave position\n    vec2 pos = iMouse.xy/ iResolution.xy;\n    pos.x *= iResolution.x / iResolution.y;\n    \n    // Wave radius\n    float r = pow(p, .9) / 2.0;\n    float rw = 0.01 + 0.05 * pow(p, 0.25);\n    \n    \n    // UV\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    \n    // Textures\n    vec3 col = texture(iChannel0, st).rgb;\n    vec3 col2 = texture(iChannel0, st + vec2(0.1)).rgb;\n    \n    \n    // Wave boolean mask\n    float m;\n    // Create exapnsive circle with a hole in the middle\n    m = circle(st, pos, r) * (1.0 - scircle(st, pos, r - rw, 0.025));\n    // Fade wave linearly from 0. -> 1.0\n    m *= (1.0 - p);\n    \n    // Cut texture with wave boolean mask \n    col = (1.0 - m) * col;\n    // Paste texture with offset\n    col += m * col2;\n    \n    // col = vec3(m);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 74, 74, 151], [153, 153, 195, 195, 259], [261, 261, 318, 360, 1283]], "test": "untested"}
{"id": "fsVSzw", "name": "Voronoi Tunnel golf [429 Char]", "author": "Tater", "description": "I tried (and failed) to golf this shader into a tweet via twigl so I will publish it on shadertoy.\n\nThis is also why I'm using the 3d noise texture.", "tags": ["3d", "raymarching", "voronoi", "tunnel", "golf"], "likes": 24, "viewed": 919, "published": 3, "date": "1634576558", "time_retrieved": "2024-07-30T18:54:58.499386", "image_code": "\n//429 By Xor\n#define V vec3\n#define v(c) q+=sin(texture(iChannel0,(q=round(f+s.c))/19.).x*6.+t*3.)*.3;\\\nn=length(q-f);\\\nm=n<m.x?V(n,m):n<m.y?V(m.x,n,0):m;\n\nvoid mainImage(out vec4 o,vec2 C)\n{\n    float i,g,e=.5,n,t=iTime;\n    \n    for(V q,f,p,m,s = V(e,-e,0),r=iResolution; i++<2e2 && e>1e-3; g+=e*.6)\n    {\n        p = q = V((C-.5*r.xy)/r.y,1)*g;\n        f = q*.2+t*V(0,1,6);   \n        m += 9.;\n        v(xxx)v(xxy)v(xyx)v(xyy)v(yxx)v(yxy)v(yyx)v(yyy)\n        p.y -= p.z*p.z/7e2;\n        e = max(9.-length(p.xy),.4-(m.y-m.x)*2.);\n    }\n    o+=i/2e2-o;\n}\n\n//Original 488 by Tater\n/*\n#define N(p) texture(iChannel0,(p)/19.).x\n#define k vec2\nfloat i,g,e=.5,n,t;\nvec3 q,f,p;\nk m,s,r;\n#define v(s)q=round(f+s);q+=sin(N(q)*6.+t*3.)*.3;n=length(q-f);m=n<m.x?k(n,m.x):n<m.y?k(m.x,n):m;   \n#define u;v(s\n\nvoid mainImage(out vec4 o,k FC){\n    t=iTime;r=iResolution.xy;\n    for(s = k(e,-e);i++<3e2&&e>.001;g+=e*.6){\n        q=vec3((FC.xy-.5*r)/r.y*g,g-1.);\n        p = q;\n        f = q*.2+vec3(0,t,t*6.);    \n        m = k(9)\n        u.xxx)u.xxy)u.xyx)u.xyy)u.yxx)u.yxy)u.yyx)u.yyy); \n        p.y-=p.z*p.z*1e-3;\n        e= max(-length(p.xy)+9.,-(m.y-m.x)*2.+.4);        \n    }    \n    o=o-o+i/2e2;\n}\n*/\n\n\n\n", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdKSD1", "name": "so this is space", "author": "Arrangemonk", "description": "everything is a space, if you're brave enough", "tags": ["spacefbm"], "likes": 18, "viewed": 452, "published": 3, "date": "1634570885", "time_retrieved": "2024-07-30T18:54:59.351109", "image_code": "void mainImageOld( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x * 0.05;\n    float time = iTime * 0.0001;\n\n    vec3 col1 = texture(iChannel0,uv +vec2(time,0)).rgb;\n    uv *=2.; time *=4.;    \n    vec3 col2 = texture(iChannel0,uv +vec2(time,0)).rgb;\n    uv *=2.; time *=4.;  \n    vec3 col3 = texture(iChannel0,uv +vec2(time,0)).rgb;\n    uv *=2.; time *=4.; \n    vec3 col4 = texture(iChannel0,uv +vec2(time,0)).rgb;\n    uv *=2.; time *=4.;   \n    vec3 col5 = texture(iChannel0,uv +vec2(time,0)).rgb;\n    uv *=2.; time *=4.; \n    vec3 col6 = texture(iChannel0,uv +vec2(time,0)).rgb;\n    uv *=2.; time *=4.;  \n    vec3 col7 = texture(iChannel0,uv +vec2(time,0)).rgb;\n   // uv *=2.; time *=4.; \n   // vec3 col8 = texture(iChannel0,uv +vec2(time,0)).rgb;\n\n    vec3 col = \n      col1 \n    + col2*col2  \n    + col3*col3*col3 \n    + col4*col4*col4*col4\n    + col5*col5*col5*col5*col5\n    + col6*col6*col6*col6*col6*col6\n    + col7*col7*col7*col7*col7*col7*col7\n   // + col8*col8*col8*col8*col8*col8*col8*col8\n    ;\n\n    // Output to screen\n    fragColor = vec4(col *col * 0.8 ,1.0);\n}\n\n//Golfed\nvoid mainImage(out vec4 c,in vec2 u)\n{\n    u = u/iResolution.x* .05;\n    float t = iTime* .0001;\n    c = vec4(0.,0.,0.,1.);\n    for(float i = 1.;i< 8.;i++){\n        c += pow(texture(iChannel0,u +vec2(t,0)),vec4(i,i,i,1));\n        u *=2.;\n        t *=4.;   \n    }\n    c *= c* .8;\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 1109], [1111, 1120, 1158, 1158, 1400]], "test": "untested"}
{"id": "NdKSWh", "name": " Fab18b #inktober2021 \"moon\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n", "tags": ["2d", "short", "loopless", "inktober2021", "croissant"], "likes": 14, "viewed": 335, "published": 3, "date": "1634559262", "time_retrieved": "2024-07-30T18:55:00.308549", "image_code": "/**/\n\n#define S(v) smoothstep(0., -4./R.y/.15, v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, S,\n         U = ( u+u - R ) / R.y; U.y += .4;\n    O-=O;\n    float a = round( atan(U.y/.7 , U.x ) * 3. ) / 3. -.01, l; // sky sector\n    vec3 P;\n\n    S = ( U - 1.4* vec2(cos(a), .7*sin(a) ) ) / .15;          // 2D Moon frame\n    l = length(S);\n    if ( l < 1. && a >-.2 ) \n        P = vec3( S, sqrt(1.-l*l) ),                          // 3D coords on Moon\n        a = 2.*a - 1. - iTime,                                // remap visible phases\n        a = dot( P, vec3(cos(a),0,sin(a)) ),                  // Sun direction\n        O =   vec4(.2,.2,0,1)                                 // ambiant\n            + S( -a )                                         // moon phase\n            * S( l - 1. );                                    // disk AA\n}\n\n\n\n\n\n/** // --- 288 char by Xor  -6 by Fab\n\n\n#define A smoothstep(0.,26./R.y\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, S,\n         U = ( u+u - R ) / R.y;\n    float a = round( atan( U.y+=.4, U.x*.7 ) * 3. ) / 3. -.01;\n\n    S = U/.15 - 9.3* vec2(cos(a), .7*sin(a) );\n    O = a > -.2\n            ? (   vec4(.2,.2,0,1)\n                + A, S.x* cos(a -= iTime - a--) + sqrt(1.-dot(S,S)) * sin(a) )\n              ) * A, 1.-length(S) )\n            : O-O;\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKSWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 90, 90, 863]], "test": "untested"}
{"id": "7sGXD1", "name": "Foilscape", "author": "hnh", "description": "Crinkled foil effect + evil glow. Making use of IQ's analytical noise derivatives.\nIt's a relatively simple effect based on the normalized gradient - haven't seen it before, however.\n", "tags": ["noise", "texture", "gradient", "effect", "pattern", "foil"], "likes": 5, "viewed": 260, "published": 3, "date": "1634558321", "time_retrieved": "2024-07-30T18:55:01.321840", "image_code": "\nvec2 hash(vec2 p){   // by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy)*2.-1.;\n}\n\n\nvec3 noised( in vec2 p ){  // by IQ: https://www.shadertoy.com/view/XdXBRH\n// return gradient noise (in x) and its derivatives (in yz)\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n    vec2 du = 30.*f*f*(f*(f-2.)+1.);\n    \n    vec2 ga = hash( i + vec2(0,0) );\n    vec2 gb = hash( i + vec2(1,0) );\n    vec2 gc = hash( i + vec2(0,1) );\n    vec2 gd = hash( i + vec2(1,1) );\n    \n    float va = dot( ga, f - vec2(0,0) );\n    float vb = dot( gb, f - vec2(1,0) );\n    float vc = dot( gc, f - vec2(0,1) );\n    float vd = dot( gd, f - vec2(1,1) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n\nvoid mainImage( out vec4 O, in vec2 P ){\n    vec2 p= (P-.5*iResolution.xy)/iResolution.y, pp= p;\n    p= p/(.8-p.y);  // perspective\n    p*= vec2(.5,1);  // horizontal stretch\n    p+= .1*iTime;  // diagonal scroll\n    p*= 300.;  // scale\n\n    vec3 nd= .4*noised(p/64.) + .3*noised(p/32.) + .2*noised(p/16.);  // 3-octave noise\n    vec2 n= normalize(nd.yz);\n    float a= dot(pp,vec2(2));  // changing light dir\n    \n    //O= .5*vec4(1.+dot(n,vec2(sin(a),cos(a))));  // basic (\"aluminium foil\")\n    O= .8*dot(n,vec2(sin(a),cos(a)))*(1.+.9/(nd.x-.5)*vec4(1,0,0,0));  // fancy\n    O= pow(O,vec4(3.));  // tone-map\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGXD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 19, 79, 218], [221, 221, 246, 355, 1045], [1048, 1048, 1088, 1088, 1658]], "test": "untested"}
{"id": "ssGXD1", "name": "shader-web-background JS lib 5", "author": "morisil", "description": "Check mouse!  I tweaked a bit this older shader of mine\n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 12, "viewed": 465, "published": 3, "date": "1634557376", "time_retrieved": "2024-07-30T18:55:02.228416", "image_code": "// Fork of \"shader-web-background JS lib 4\" by morisil. https://shadertoy.com/view/fsVSWR\n// 2021-10-18 11:42:30\n\n// Fork of \"shader-web-background JS lib 3\" by morisil. https://shadertoy.com/view/NdKXRm\n// 2021-10-17 11:03:28\n\n// Fork of \"shader-web-background JS lib 2\" by morisil. https://shadertoy.com/view/fs3XDB\n// 2021-10-16 23:27:09\n\n// Fork of \"shader-web-background JS lib\" by morisil. https://shadertoy.com/view/wlKyR1\n// 2021-10-09 22:16:29\n\n/*\n  This shader is here to spread the news about JavaScript library:\n  \n  https://xemantic.github.io/shader-web-background/\n \n  It is designed to be compatible with Shadertoy while adding more\n  integration options and saving many once-per-frame computations.\n  Even complex shaders should work on almost any hardware. I wanted\n  to build a base, which would let me use shaders as part of my\n  regular web development process, to transform my future website\n  into more immersive experiences. Check the project on mobile and\n  how it is reacting to device orientation, parallax scrolling, etc.\n  \n  Note: Mouse movement will make feedback follow the cursor.  \n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, gl_FragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst float iFeedbackZoomRate         = .003;\nconst float iFeedbackFadeRate         = .998;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .006;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 1.25;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .1;\nconst float iBlob1PowFactor           = 50.;\nconst float iBlob1ColorPulseSpeed     = .13;\nconst float iBlob2Radius              = .15;\nconst float iBlob2PowFactor           = 50.;\nconst float iBlob2ColorPulseSpeed     = .2;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = 1.7;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    vec2 iFeedbackZoomCenter = vec2(sin(iTime * .6), cos(iTime * .7)) * .2;\n    vec2 iDrawCenter = iFeedbackZoomCenter;\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.) \n    )\n    ;\n    //* vec3(.7, .3, 1.);\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    )\n    ;\n    //* vec3(.7, .3, 1.);\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.rg - .5) * iFeedbackColorShiftImpact * vec2(sin(iTime * .2), cos(iTime * .3));\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n    stShift *= (1. + cos(drawAngle * 60. + drawDist * 60. + iTime * 1.5)) * 2.5;\n\n    vec3 prevColor = repeatedTexture(iChannel0, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1120, 1120, 1175, 1175, 1247]], "test": "untested"}
{"id": "sdGSD1", "name": " Fab18 #inktober2021 \"moon\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n", "tags": ["procedural", "swirl", "texture", "planet", "loopless", "jupiter", "inktober2021"], "likes": 18, "viewed": 469, "published": 3, "date": "1634556006", "time_retrieved": "2024-07-30T18:55:03.247691", "image_code": "// reuse \"swirls on sphere\"  https://shadertoy.com/view/ssGSDh\n\n#define H(p)       fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define R(p,a,r) ( mix( a*dot(p,a), p, cos(r) ) + sin(r)*cross(p,a) )\n#define hue(v)     vec4( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) , 1 )\n#define S(v)       smoothstep( 0., -6./R.y, v )\n#define shad(P)    vec4(vec3( .2 + .8* max(0., dot(P,vec3(1,.5,1)))), 1)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, S,\n         U = 2.* ( 2.*u - R ) / R.y;\n\n    O-=O;\n    float r = length(U), y, l=9., t = -iTime; int i,k;\n    vec3 P;\n#define moon(d,v,w,h)                                         \\\n        S = d* vec2(2.*cos(v*t), .2*sin(v*t) );               \\\n        if ( r > 1. || S.y < 0.)                              \\\n            if ( length( S = (U-S)/w ) < 1.)                  \\\n                P = vec3( S, sqrt(1.-dot(S,S)) ),             \\\n                O +=    S( length(S) - 1. )                   \\\n                      * shad(P) * (.7+.3*hue(h)) \n    moon(1., 1.,.1,.0);\n    moon(2.,.4,.07,.5);\n    moon(3.,.2,.05,.3);\n    moon(4.,.15,.03,.0);\n    moon(5.,.1,.03,.5);\n    \n    if ( r > 1. ) return;\n    \n    vec3 P0 = vec3( U, sqrt(1.-r*r) ),         // raytracing point in sphere\n         I,F, H,D,A;\n         P = 4.*P0;\n         P.xz *= mat2(cos( .2*iTime + vec4(0,11,33,0) )); // planet rotation\n         I = floor(P), F = fract(P);           // coords in 3D grid\n\n#define dist2seed  \\\n        D = vec3( k%3, (k/3)%3, k/9 ) -1.;     /* cell offset         */  \\\n        D += H(I+D)-.5;                        /* random seed point   */  \\\n        A = normalize(I+D);                                               \\\n        D = 4.*A - I;                          /* project it on sphere ( for even radius ) */ \\\n        r = length(F-D);                       /* distance to seed    */\n\n    for ( k = 0; k < 27; k++) {                // visit neighbor cells to find closest seed point\n        dist2seed;\n     // P = R( F-D, A, 10.*smoothstep(.5,0.,r) ) + D+I; // shouldn't we blend effects ?\n        r < l ? l = r, i = k : i;              // keep closest dot \n     }\n    k = i;\n    dist2seed;\n    y = atan(P.y,length(P.xz));                                   // latitude ( to tune swirl direction & amplitude )\n    y = 4.*cos(4.*y);\n    P = R( F-D, A, y * smoothstep(.5,0.,r) ) + D+I;               // rotate coords around seed point\n       \n // O = vec4(smoothstep(12./R.y,0., l-.2) ); return;              // test: plot seed points\n    \n    S = vec2( atan(P.z,P.x) - .1*iTime, atan(P.y,length(P.xz)) ); // surface coordinates\n//  S = vec2(acos(U.x/sqrt(1.-U.y*U.y)) , asin(U.y) );            // debug\n    O += (1.-O.a) * mix( \n          smoothstep( .8, .2, texture(iChannel0, S*vec2(1,3) ) )  // swirled texture\n        * (.5+.5*hue(abs(U.y*2./3.14)))                           // color\n        , vec4(.7,.8,.9,0), 1.-abs(P0).z )                        // atmosphere\n        * S( length(U)-1.)                                        // antialiasing\n        * 1.5*shad(P0);                                           // shading\n    \n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dKSDz", "name": "Test-Screen", "author": "hnh", "description": "Minimalistic design - inspired by some hardware test found on my Thinkpad.\nMin 60 fps guaranteed ;-)", "tags": ["2d", "test", "basic", "oldschool", "silly", "tool"], "likes": 3, "viewed": 238, "published": 3, "date": "1634554730", "time_retrieved": "2024-07-30T18:55:04.141302", "image_code": "#define RX (.5*iResolution.x)\n#define RY (.5*iResolution.y)\n#define A trunc(.1*RY)  //grid size\n\nvoid mainImage(out vec4 O, in vec2 U){\n    U= abs(U-.5*iResolution.xy);  //H-V mirrored coords\n\n    float o= min(mod(U.x,A), mod(U.y,A));  //grid\n    o= min(o, abs(U.x*RY/RX - U.y));  //diagonals\n    o= min(o, abs(length(U) - RY));  //large circle\n    o= min(o, abs(length(U - .4*iResolution.xy) - 2.*A));  //small circles\n\n    O= vec4(1.-o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 135, 135, 441]], "test": "untested"}
{"id": "ssGSDh", "name": "swirls on sphere (3D swirl seed)", "author": "FabriceNeyret2", "description": "Principle:\nWorley-like 3D grid with 1 seed point per cell. \nproject it on sphere, and rotate 3D coordinates around it.\n\nTODO: there are discontinuities, because cells sliced by sphere can be small, plus even some internal cells are considered.", "tags": ["procedural", "swirl", "texture", "planet", "short", "loopless", "jupiter"], "likes": 49, "viewed": 1147, "published": 3, "date": "1634552316", "time_retrieved": "2024-07-30T18:55:04.999008", "image_code": "// WIP. Many discontinuities to fix.   \n// See options and coefs.\n\n#define H(p)       fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define R(p,a,r) ( mix( a*dot(p,a), p, cos(r) ) + sin(r)*cross(p,a) )\n#define hue(v)   ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n\n    O-=O;\n    float r = length(U), y, l=9., s = 4.;      // s: swirls size\n    int i,k;\n    if ( r > 1. ) return;\n    \n    vec3 P0 = vec3( U, sqrt(1.-r*r) ),         // raytracing point in sphere\n         P = s*P0, I,F, H,D,A;\n         P.xz *= mat2(cos( .2*iTime + vec4(0,11,33,0) )); // planet rotation\n      // F = abs(fract(P+.5)-.5); y = min(F.x,min(F.y,F.z)); O += smoothstep(12./R.y,0.,y); // debug: grid\n         I = floor(P), F = fract(P);           // coords in 3D grid\n\n#define dist2seed  \\\n        D = vec3( k%3, (k/3)%3, k/9 ) -1.;     /* cell offset         */    \\\n        D += H(I+D)-.5;                        /* random seed point   */    \\\n     /* if( abs( length(I+D) - s ) < .5 ) */   /* only if close to surf */  \\\n            A = normalize(I+D),                                             \\\n            D = s*A - I,                       /* project it on sphere ( for even radius ) */ \\\n            r = length(F-D);                   /* distance to seed    */\n\n    for ( k = 0; k < 27; k++) {                // visit neighbor cells to find closest seed point\n        dist2seed;\n     // P = R( F-D, A, 10.*smoothstep(.5,0.,r) ) + D+I; // shouldn't we blend effects ?\n        r < l ? l = r, i = k : i;              // keep closest dot \n     }\n    k = i;\n    dist2seed;\n    y = atan(P.y,length(P.xz));                                   // latitude ( to tune swirl direction & amplitude )\n    y = 4.*cos(4.*y);\n // if ( i%2 < 1 ) y = -y;                                        // checkered rotation direction\n    P = R( F-D, A, y * smoothstep(.5,0.,r) ) + D+I;               // rotate coords around seed point\n       \n // O += vec4(smoothstep(12./R.y,0., l-.2) ); return;             // test: plot seed points\n    \n    U = vec2( atan(P.z,P.x) - .1*iTime, atan(P.y,length(P.xz)) ); // surface coordinates\n // U = vec2(acos(U.x/sqrt(1.-U.y*U.y)) , asin(U.y) );            // debug\n    O += ( iMouse.z > 0. ? vec4(.6)\n             : smoothstep(.8,.2, texture(iChannel0, U*vec2(1,3))))// swirled texture\n        * (.5+.5*hue(abs(U.y*2./3.14)))                           // color\n        * ( .3 + 1.2* max(0., dot(P0,vec3(1,0,1))));              // shading\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdyXWh", "name": "Volumetric noise", "author": "_samuelcho_", "description": "Trying to learn raymarching", "tags": ["raymarching", "noise", "volumetric"], "likes": 1, "viewed": 335, "published": 3, "date": "1634546854", "time_retrieved": "2024-07-30T18:55:05.934507", "image_code": "#define MAX_STEPS 256\n#define MAX_DIST 1000. \n#define SURF_DIST .001 \n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1.5, 6, 1);\n    float sphereDist =  length(p-s.xyz)-s.w;\n    sphereDist += snoise(vec4(p*2.0,iTime*0.1));\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n   //d = sphereDist;\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    \n    for(int i = 0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO; \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);    \n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0,6, 6);\n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float diffuse = clamp(dot(n,l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*6., l);\n    if(d < length(lightPos-p)) diffuse *= 0.1;\n    return diffuse;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.5,0 ); //camera, ray origin\n    vec3 rd = normalize(vec3(uv.x,uv.y,2)); // ray direction\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d; //point in scene\n    float diffuse = GetLight(p);\n    \n     col = vec3(diffuse);\n     \n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 94, 94, 334], [336, 336, 369, 369, 581], [583, 583, 606, 606, 791], [793, 793, 816, 816, 1120], [1123, 1123, 1180, 1180, 1568]], "test": "untested"}
{"id": "fsGXW1", "name": "90s Anime Background 3", "author": "Xibanya", "description": "another Sailor Moon-inspired background. Unlike in the previous shaders on this theme I've done, I came up with a way to procedurally generate the window patterns rather than place them by hand.", "tags": ["sdf", "night", "city", "90s", "anime", "skyline"], "likes": 4, "viewed": 572, "published": 3, "date": "1634545700", "time_retrieved": "2024-07-30T18:55:06.871003", "image_code": "#define saturate(x) clamp(x, 0., 1.)\nfloat nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nfloat Luminance(vec3 col)\n{\n    return dot(col, vec3(0.2126729f,  0.7151522f, 0.0721750f));\n}\nvec3 Saturation(vec3 c, float sat)\n{\n    vec3 luma = vec3(Luminance(c));\n    return luma + vec3(sat) * (c - luma);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.00075;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col = Saturation(col, 1.3) * 1.1;\n    \n    vec2 texel = 1. / iResolution.xy;\n    float n = fract(cos(\n        (sin(uv.x / texel.x) * uv.y / texel.y + iTime * 0.01)\n        * 89.) * 343.4);\n\tcol = mix(col, saturate(min(col, n)), 0.15);\n    \n    float vignette = saturate(\n        pow(length(uv * 2. - 1.), 3.) * 0.25);\n    col = mix(col, col * vec3(0.05, 0.2, 0.45), vignette);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n#define XTILT 12.\n#define YTILT -90.\n#define FOV 65.\n#define MIN_DIST 0.005\n#define MAX_DIST 100.\n#define MAX_STEPS 75\n#define saturate(x) clamp(x, 0., 1.)\n#define EPS vec3(0.001, 0.0, 0.0)\n#define BGCOLOR vec3(0.0509804, 0.2078432, 0.454902)\n#define WINDOWCOLOR vec3(0.2196079, 0.5764706, 0.482353)\n#define FOG_COLOR vec3(0.1803922, 0.682353, 0.5215687)\n#define STREET_COLOR vec3(0.5255, 0.851, 0.9098)\n#define OUTLINE_COLOR vec3(0.2275, 0.2118, 0.2824)\n#define BGUPPER vec3(0.08235294, 0.5529412, 0.6235294)\n#define BGLOWER vec3(0.0627451, 0.3411765, 0.5176471)\n#define WINDOW_COLOR_0 vec3(0.07058824, 0.3882353, 0.4941177)\n#define WINDOW_COLOR_1 vec3(0.2039216, 1.192157, 0.9960784)\n#define WINDOW_COLOR_2 vec3(0.1960784, 1.262745, 0.9647059)\n#define WINDOW_COLOR_3 vec3(1.283019, 1.207728, 0.3086507)\n#define STAR_COLOR vec3(0.28, 0.28, 0.4)\n#define FOG_SMALL vec3(0.6901961, 0.5176471, 0.7098039)\n\n#define TOTAL_SCALES 5\n#define TOTAL_SIZES 5\n\n#define INIT_SCALES vec2[TOTAL_SCALES] scales; \\\n  scales[0] = vec2(16., 20.); \\\n  scales[1] = vec2(10., 25.); \\\n  scales[2] = vec2(20., 10.); \\\n  scales[3] = vec2(8., 12.); \\\n  scales[4] = vec2(16., 18.)\n\n#define INIT_SIZES vec2[TOTAL_SIZES] sizes; \\\n  sizes[0] = vec2(3., 1.); \\\n  sizes[1] = vec2(2., 2.); \\\n  sizes[2] = vec2(2.75, 1.25); \\\n  sizes[3] = vec2(2., 2.); \\\n  sizes[4] = vec2(2.75, 1.25)\n\n\n// Antialiased step\n// https://github.com/glslify/glsl-aastep\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\n/////////// FBM ///////////////\n// see: https://thebookofshaders.com/13/\nfloat FBMRandom(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat FBMNoise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = FBMRandom(i);\n    float b = FBMRandom(i + vec2(1.0, 0.0));\n    float c = FBMRandom(i + vec2(0.0, 1.0));\n    float d = FBMRandom(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nfloat FBM(vec2 st, float octaves)\n{\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (float i = 0.; i < octaves; i++)\n    {\n        value += amplitude * FBMNoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\nvec3 WindowFBM(vec2 uv)\n{\n    vec2 st = uv * 2.;\n    float time = iTime * 0.2;\n    vec2 q = vec2(FBM(st + time, 8.), FBM(st + 1., 2.));\n    vec2 r = vec2(\n        FBM(st + q + vec2(1.7, 9.2) + 0.15 * time, 2.),\n        FBM(st + q + vec2(8.3, 2.8) + 0.126 * time, 2.)\n    );\n    float f = FBM(st + r, 8.);\n    float next = saturate((f * f) * 4.);\n    vec3 color = mix(WINDOW_COLOR_0, WINDOW_COLOR_1, next);\n    next =  saturate(length(q));\n    color = mix(color, WINDOW_COLOR_2, next);\n    next = saturate(length(r.x));\n    color = mix(color, WINDOW_COLOR_3, next);\n\n    float finalFactor = (f * f * f + 0.6 * f * f + 0.5 * f);\n    return mix(WINDOWCOLOR, color, saturate(finalFactor));\n}\n///////////////////////////////////////////\n// Perlin \n// see: https://thebookofshaders.com/11/\nfloat SmoothCos(float a, float b, float x)\n{\n    float f = (1. - cos(x * 3.1415927)) * 0.5;\n    return a * (1. - f) + b * f;\n}\n// params.x = precision, params.y = octaves\nfloat Perlin(vec2 uv, vec2 params)\n{\n    float p = 0.;\n    float t = params.x;\n    for (float i = 0.; i < params.y; i++)\n    {\n        float a = FBMRandom(vec2(floor(t * uv.x) / t, floor(t * uv.y) / t));\t   \n        float b = FBMRandom(vec2(ceil (t * uv.x) / t, floor(t * uv.y) / t));\t\t\n        float c = FBMRandom(vec2(floor(t * uv.x) / t, ceil (t * uv.y) / t));\t\t\n        float d = FBMRandom(vec2(ceil (t * uv.x) / t, ceil (t * uv.y) / t));\n        if ((ceil(t * uv.x) / t) == 1.)\n        {\n            b = FBMRandom(vec2(0., floor(t * uv.y) / t));\n            d = FBMRandom(vec2(0., ceil(t * uv.y) / t));\n        }\n        float coef1 = fract(t * uv.x);\n        float coef2 = fract(t * uv.y);\n        p += SmoothCos(\n                SmoothCos(a, b, coef1),\n                SmoothCos(c, d, coef1),\n                coef2\n                ) * (1. / pow(2., (i + 0.6)));\n        t *= 2.;\n    }\n    return p;\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n/// triplanar uv functions from Catlike Coding\n// https://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\nstruct TriplanarUV\n{\n\tvec2 x, y, z;\n};\nTriplanarUV GetTriplanarUV(vec3 pos, vec3 normal, float scale)\n{\n\tTriplanarUV triUV;\n\tvec3 p = pos * scale;\n\ttriUV.x = p.zy;\n\ttriUV.y = p.xz;\n\ttriUV.z = p.xy;\n\tif (normal.x < 0.) triUV.x.x = -triUV.x.x;\n\tif (normal.y < 0.) triUV.y.x = -triUV.y.x;\n\tif (normal.z >= 0.)\ttriUV.z.x = -triUV.z.x;\n\ttriUV.x.y += 0.5;\n\ttriUV.z.x += 0.5;\n\treturn triUV;\n}\nvec3 TriW(vec3 normal)\n{\n  vec3 triW = abs(normal);\nreturn triW / (triW.x + triW.y + triW.z);\n}\nfloat mirror( float p, float offset )\n{\n    p = abs( p );\n    p -= offset;\n    return p;\n}\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nfloat sdBox(const in vec3 p, const in vec4 b) \n{\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat ClearWindows(vec2 uv, vec2 scale)\n{\n    float threshold = 0.6;\n    vec2 s2 = uv * scale;\n    float noise = hash12(floor(s2));\n    float square = step(threshold, noise);\n    return square;\n}\nfloat Grid(vec2 uv, vec2 scale)\n{\n    vec2 st = fract(uv) * scale;\n    vec2 fpos = fract(st);\n    vec2 ipos = floor(st);\n    float grid = saturate(sign(sdBox(fpos, vec2(0.9, .8))));\n    float borderRows = max(\n        step(scale.y - 1., ipos.y), \n        step(ipos.y, 0.));\n    float borderCols = max(\n        step(scale.x - 1., ipos.x),\n        step(ipos.x, 0.)\n    );\n    float borders = max(borderRows, borderCols);\n    grid = max(borders, grid);\n    grid = max(grid, ClearWindows(uv, scale));\n    return grid;\n}\nfloat Bubble(vec2 uv)\n{\n\tfloat circle = sdCircle(uv * 2. + vec2(-1.), .0005);\n\tcircle =  1. - saturate(circle);\n    float mask = aastep(0.01, circle);\n    return max(0., (1. - circle) * mask);\n}\nvec4 Bubbles(vec2 uv)\n{\n    uv.y *= iResolution.y / iResolution.x;\n    vec2 perlin = vec2(Perlin(uv, vec2(2., 6.)));\n    uv += perlin * 0.15;\n    \n    vec2 st = fract(uv + vec2(iTime * 0.012, -0.05)) * vec2(14., 14.);\n    vec2 fpos = fract(st);\n    vec2 ipos = floor(st);\n    float grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 2., 7.), 0.), \n        step(mod(ipos.x - 2., 5.), 0.)\n    );\n    \n    vec4 wcColor = vec4(2.6, 1.2, 1.7, 1.) * 0.35 * grid;\n    \n    st = fract(uv + vec2(iTime * 0.01, -0.02)) * vec2(12., 12.);\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 2., 7.), 0.), \n        step(mod(ipos.x - 8., 5.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(3.9, 2.9, 1.2, 1) * 0.35, grid);  \n    \n    st = fract(uv + vec2(-iTime * 0.01, 0.1)) * vec2(16., 16.);\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 4., 14.), 0.), \n        step(mod(ipos.x - 5., 7.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(3.9, 2.9, 1.2, 1)  * 0.35, grid); \n    \n    st = fract(uv +\n        vec2(iTime * 0.0175, 0.3)) * vec2(16., 16.);\n    fpos = fract(st);\n    ipos = floor(st);\n    grid = Bubble(fpos);\n    grid *= min(step(mod(ipos.y - 7., 14.), 0.), \n        step(mod(ipos.x - 5., 4.), 0.)\n    );\n    wcColor = mix(wcColor, vec4(1.9, 1.1, 2.6, 1) * 0.35, grid);\n    \n    return wcColor;\n}\nint WrappedType(float type)\n{\n  return int(mod(type, float(TOTAL_SCALES)));\n}\nvec2 GetScale(float type)\n{\n  INIT_SCALES;\n  return scales[WrappedType(type)];\n}\n\nfloat CubeDist(vec3 p, out float type)\n{\n  type = 0.;\n  INIT_SIZES;\n  vec2 size = sizes[int(type)];\n  float scene = sdBox(p + vec3(-1., size.x, 0.), vec4(1., size.y, .5, 0.));\n\n  size = sizes[3];\n  float c0 = sdBox(p + vec3(1., size.x, 0.), vec4(1., size.y, .5, 0.));\n  type = scene < c0? type : 3.;\n  scene = min(scene, c0);\n\n  size = sizes[1];\n  float c1 = sdBox(p + vec3(-3., size.x, 0.), vec4(1., size.y, .5, 0.));\n  type = scene < c1? type : 1.;\n  scene = min(scene, c1);\n\n  size = sizes[2];\n  float c2 = sdBox(p + vec3(-5., size.x, 0.), vec4(1., size.y, .5, 0.));\n  type = scene < c2? type : 2.;\n  scene = min(scene, c2);\n  \n  size = sizes[3];\n  float c3 = sdBox(p + vec3(-1., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c3? type : 3.;\n  scene = min(scene, c3);\n\n  size = sizes[0];\n  float c35 = sdBox(p + vec3(1., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c35? type : 0.;\n  scene = min(scene, c35);\n\n  size = sizes[4];\n  float c4 = sdBox(p + vec3(-3., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c4? type : 4.;\n  scene = min(scene, c4);\n\n  size = sizes[0];\n  float c5 = sdBox(p + vec3(-5., size.x, -4.), vec4(1., size.y, .5, 0.));\n  type = scene < c5? type : 5.;\n  scene = min(scene, c5);\n  return scene;\n}\nfloat CubeBack(vec3 p, out float type)\n{\n  type = 1.;\n  INIT_SIZES;\n  float scene = sdBox(p + vec3(-12., 2., -1.), vec4(1., 2., 1., 0.));\n  vec2 size = sizes[2];\n  float c2 = sdBox(p + vec3(-12., size.x, -3.), vec4(1., size.y, 1., 0.));\n  type = scene < c2? type : 2.;\n  scene = min(scene, c2);\n\n  size = sizes[3];\n  float c3 = sdBox(p + vec3(-12., size.x, -5.), vec4(1., size.y, 1., 0.));\n  type = scene < c3? type : 3.;\n  scene = min(scene, c3);\n\n  size = sizes[4];\n  float c4 = sdBox(p + vec3(-12., size.x - 0.25, 1.), \n    vec4(1., size.y + 0.26, 1., 0.));\n  type = scene < c4? type : 4.;\n  scene = min(scene, c4);\n  return scene;\n}\nfloat GetNormalDist(vec3 p)\n{\n  //only need to get normal for one box and use it for everything\n  // since we are just going to use flat uvs for the back boxes\n  float scene = sdBox(p + vec3(-2., 2., 0.), vec4(4., 2., .5, 0.));\n  return scene;\n}\nfloat GetScene(vec3 p, out vec3 col)\n{\n  vec2 uvX = p.zy;\n  vec2 uvY = p.xz;\n  vec2 uvZ = p.xy;\n  float type = 0.;\n  float scene = CubeDist(p, type);\n  int wType = WrappedType(type);\n \n  vec3 normal = normalize(vec3(\n      GetNormalDist(p + EPS.xyy) - GetNormalDist(p - EPS.xyy),\n      GetNormalDist(p + EPS.yxy) - GetNormalDist(p - EPS.yxy),\n      GetNormalDist(p + EPS.yyx) - GetNormalDist(p - EPS.yyx)));\n  \n  vec3 buildingColor = BGCOLOR;\n  vec2 scale = GetScale(type);\n  vec2 buildUV = uvZ * 0.5;\n  float blend = saturate(smoothstep(-0.5, 0.9, p.y + 3.));\n  vec3 fog = FOG_COLOR;\n  buildingColor = mix(fog, BGCOLOR, blend);\n \n  if (wType == 1 || wType == 3)\n  {\n    buildUV.y *= .5;\n  }\n  if (wType == 2 || wType == 4)\n  {\n    buildUV.y *= .75;\n    buildUV.y += 0.5;\n  }\n  float grid = Grid(buildUV, scale);\n  vec3 windowColor = mix(fog, WindowFBM(uvZ), blend);\n  vec3 facade = mix(windowColor, buildingColor, grid);\n  col = mat3(buildingColor, buildingColor, facade) * TriW(normal);\n\n  float backType = 0.;\n  float back = CubeBack(p, backType);\n  vec2 backUV = uvX * 0.5;\n  if (backType == 1. || backType == 3.)\n  {\n    backUV.y *= .5;\n  }\n  if (backType == 2.)\n  {\n    backUV.y *= .75;\n    backUV.y += 0.5;\n  }\n  if (backType == 4.)\n  {\n    backUV.y *= 0.6;\n    backUV.y += 1.25;\n  }\n  float backGrid = Grid(backUV, GetScale(backType));\n  vec3 backCol = mix(windowColor, buildingColor, backGrid);\n  col = scene < back? col : backCol;\n  scene = min(scene, back);\n \n  return scene;\n}\nfloat CastRay(vec3 pos, vec3 dir, out vec3 col) \n{\n  float d = MIN_DIST;\n  for(int i = 0; i < MAX_STEPS; i++) \n  {\n    float dist = GetScene(pos + dir * d, col);\n    if (d > MAX_DIST || d < MIN_DIST) break;\n    d += dist;\n  }\n  col = d > MAX_DIST ? vec3(-1.0) : col;\n  return d;\n}\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\nfloat noiseFloat(vec2 p)\n{\n    p = fract(p * vec2(1000. * 0.21353, 1000. * 0.97019));\n    p = p + dot(p, p + 1000. * 0.54823);\n    return fract(p.x * p.y);\n}\nvec2 noiseVector(vec2 p)\n{\n    float n = noiseFloat(p);\n    return vec2(n, noiseFloat(p + n));\n}\nvec2 GetPos(vec2 id, vec2 offsets, float time)\n{\n    vec2 n = noiseVector(id + offsets) * 500. * \n        ((8000. + time) / (1000. * 50.));\n    return (sin(n) * 0.9) + offsets;\n}\nfloat Stars(vec2 uv, float time, float gain)\n{\n    uv -= 1.;\n    float m = 0.;\n    uv = uv * 10.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int n = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[n++] = GetPos(id, vec2(x, y), time);\n        }\n    }\n    for (int i=0; i < 9; i++)\n    {\n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (gain / (8000.0 + time));\n        m = m + sparkle * (sin(((8000.0 + time)+p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    return m;\n}\nfloat Voronoi(vec2 uv)\n{\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\n\tfloat d = 64.;\n\tfor(float y = -1.; y <= 1.; ++y)\n\t{\n\t\tfor (int x = -1; x <= 1; ++x)\n\t\t{\n\t\t\tvec2 b = vec2(x, y);\n            float vNoise = fract(sin(\n                dot(i + b, vec2(101.9364, 96.45418))\n                ) * 100000.0);\n\t\t\tvec2 c = b + vNoise - f;\n\t\t\td = min(d, dot(c, c));\n\t\t}\n\t}\n\treturn sqrt(d);\n}\nvec3 Background(vec2 uv)\n{\n  uv.y += 0.5;\n  float bgBlend = smoothstep(0.4, 0.6, uv.y);\n  bgBlend *= Voronoi(uv * vec2(2., 1.) + vec2(0.2, 0.05) * iTime);\n  vec3 col = mix(BGLOWER, BGUPPER * 1.5, saturate(bgBlend));\n  float stars = saturate(Stars(uv * 2., 0., 100.));\n  col = mix(col, STAR_COLOR * 5., stars);\n  col = mix(col, FOG_SMALL, step(uv.y, 0.35)); \n  return col;\n}\n\nmat3 ViewMatrix(vec3 ro, vec3 ta)\n{\n  vec3 cw = normalize(ta - ro);\n  vec3 up = vec3(0., 1., 0.);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu,cw) );\n  return mat3(cu, cv, cw);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 uv) \n{\n    vec2 xy = uv - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 RotateX(vec3 dir, float degrees)\n{\n    float angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat4 rotateXMatrix = mat4(1., 0., 0., 0.,\n\t\t0., c, -s, 0.,\n\t\t0., s, c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateXMatrix).xyz;\n}\nvec3 RotateY(vec3 dir, float degrees)\n{\n    float angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat4 rotateYMatrix = mat4(\n        c, 0., s, 0.,\n\t\t0., 1., 0., 0.,\n\t\t-s, 0., c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateYMatrix).xyz;\n}  \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy - .5;\n  uv.y *= iResolution.y / iResolution.x;\n\n  vec3 dir = rayDirection(FOV, iResolution.xy, fragCoord.xy);\n  vec2 m = iMouse.z > 0.? (iMouse.xy / iResolution.xy) * 5. : vec2(0.);\n  dir = RotateX(dir, XTILT);\n  dir = RotateY(dir, YTILT);\n  \n  vec3 p = vec3(-5.5 + m.y, -3.8, 2.);\n\n  vec3 bg = Background(uv);\n  vec3 col = vec3(-1.);\n  float d = CastRay(p, dir, col);\n  float y = fragCoord.y / iResolution.y;\n  col = col.r < 0. ? bg : col;\n\n  col = mix(FOG_SMALL, col, smoothstep(0.2, 0.75, y + 0.15));  \n  vec4 bubbles = Bubbles(fragCoord.xy / iResolution.xy);\n  col = mix(col, bubbles.rgb * 4., saturate(bubbles.a));\n  fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 69, 69, 166], [167, 167, 194, 194, 260], [261, 261, 297, 297, 377], [378, 378, 435, 435, 1055]], "test": "untested"}
{"id": "NdyXW1", "name": "Gaussian Filtered Saw Wave", "author": "oneshade", "description": "Testing a gaussian filtered saw wave.", "tags": ["filter", "approximation", "waveform", "gaussian", "sawtooth"], "likes": 6, "viewed": 272, "published": 3, "date": "1634538842", "time_retrieved": "2024-07-30T18:55:07.619003", "image_code": "// https://www.desmos.com/calculator/41jsrnvv41\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default shader\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    fragColor = vec4(color, 1.0);\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    uv = (uv - 0.5) * 1.5 + 0.5; // Scale 1.5x\n\n    float unit = 3.0 / iResolution.y; // 2x pixel size\n\n    float w = 0.251 - 0.25 * cos(0.25 * iTime); // Filter width\n    float x = uv.x + iTime;\n\n    // Graph\n    float y = gsaw(x, w);\n    float dydx = (gsaw(x + 0.001, w) - y) / 0.001;\n    float dist = abs(uv.y - y) / sqrt(1.0 + dydx * dydx);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(unit, 0.0, dist));\n\n    // Undo scale\n    uv = (uv - 0.5) / 1.5 + 0.5;\n\n    // \"Sound In\" notification\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.3, 0.3), vec2(0.1), 83); // S\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.4, 0.3), vec2(0.1), 79); // O\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.5, 0.3), vec2(0.1), 85); // U\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.6, 0.3), vec2(0.1), 78); // N\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.7, 0.3), vec2(0.1), 68); // D\n\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(0.9, 0.3), vec2(0.1), 73); // I\n    drawChar(fragColor.rgb, vec3(1.0), uv, vec2(1.0, 0.3), vec2(0.1), 78); // N\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(int samp, float time) {\n    return vec2(makeNoise(time));\n}", "sound_inputs": [], "common_code": "// Error function approximation\nfloat erf(in float x) {\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered saw wave\n// Works for filter widths between 0 and 1\n// Increase k to allow for larger filter widths\nconst float k = 3.0; // k → ∞\nfloat gsaw(in float x, in float w) {\n    x = fract(x);\n    float y = 0.0;\n    for (float n=-k; n <= k; n++) y += erf((x - n) / w);\n    return (1.0 - y) / 2.0 + x;\n}\n\nfloat makeNoise(in float time) {\n    return 0.25 * gsaw(time * 200.0, 0.251 - 0.25 * cos(0.25 * time));\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 127, 230, 230, 495], [497, 497, 552, 574, 1866]], "test": "untested"}
{"id": "NdySDh", "name": "ship on moon 2d", "author": "jorge2017a2", "description": "ship on moon 2d", "tags": ["shiponmoon2d"], "likes": 7, "viewed": 239, "published": 3, "date": "1634523954", "time_retrieved": "2024-07-30T18:55:08.368998", "image_code": "///ship on moon 2d-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec4 construccion(vec2 uv,vec3 col)\n{\n\n    float d2= sdTriangleIsosceles(vec2(uv.x, -uv.y)-vec2(-14.0,0.0), vec2(2.0,3.0) );\n    float d3=sdBox(uv-vec2(0.0,-7.0), vec2(15.0,2.0) );\n    float d4=sdBox(uv-vec2(11.0,-3.0), vec2(3.0,2.0) );\n    float d5=sdBox(uv-vec2(-9.5,-4.0), vec2(5.0,1.0) );\n    float d6= sdTriangleIsosceles(vec2(uv.x, -uv.y)-vec2(-4.5,3.0), vec2(2.0,3.0) );\n    \n    float dtot=unionSDF(d2, d3);\n    dtot=unionSDF(dtot, d4);\n    dtot=unionSDF(dtot, d5);\n    dtot=unionSDF(dtot, d6);\n    \n    col= DrawFig(vec3(1.0), col, dtot );\n    return  vec4(col,dtot);\n}\n\nvec3 paisajeLineas(vec2 p, vec3 col)\n{   vec2 uv=p;\n    p.y=opRep1D(p.y, 0.025 );\n    float d1= sdBox(p, vec2(16.0,0.0032) );\n    vec4 col4= construccion(uv,col);   \n    float dt=intersectSDF(d1,col4.w);\n    col= DrawFig(vec3(1.0), col, dt);\n    return col;\n}\n\nvec3 casa1(vec2 p, vec3 col)\n{  float d1= sdBox(p-vec2(10.0,-0.7), vec2(1.0,0.25) ); \n   float d2= sdBox(p-vec2(10.0,-0.7), vec2(0.8,0.2) ); \n   vec2 pos=vec2(10.0,0.0);\n   float d3=sdCircle(p-pos, 1.0 );\n   float d4=sdCircle(p-pos, 0.8 );\n   d3= differenceSDF(d3,d1);\n   d4= differenceSDF(d4,d1);\n   d3= differenceSDF(d3, d4);\n   float dif= differenceSDF(d1, d2);\n   col= DrawFig(vec3(1.0), col, dif);\n   col= DrawFig(vec3(1.0), col,d3);  \n   return col;\n}\n\nvec3 nave(vec2 p, vec3 col)\n{  \n    vec2 uv=p;\n    p= rotatev2(p, radians(90.0));\n\n   float d1= sdTriangleIsosceles( p, vec2(1.5,1.5) ) ;\n   float d2= sdTriangleIsosceles( p-vec2(0.0,0.2), vec2(1.1,1.2) ) ;\n   float d3= sdTriangleIsosceles( p-vec2(0.0,0.95), vec2(1.2,1.2) ) ;\n   \n    d1= differenceSDF(d1, d3);\n    d2= differenceSDF(d2, d3);\n   float dif= differenceSDF(d1, d2);\n   \n   col= DrawFig(vec3(1.0), col,dif);\n   vec2 rep=uv;\n   rep.x=mod(uv.x-1.0+iTime*5.0,2.0);\n   float d5= sdBox(rep, vec2(0.5,0.05) );\n   float d6= sdBox(uv-vec2(7.5,0.0), vec2(8.0,0.5) );\n   d5= differenceSDF(d5, d6);\n   \n   float d5b= sdBox(rep, vec2(0.5,0.08) );\n   float d6b= sdBox(uv-vec2(7.5,0.0), vec2(8.0,0.8) );\n   d5b= differenceSDF(d5b, d6b);\n   \n   col= DrawFig(vec3(1.0,1.0,0.0), col,d5b);\n   col= DrawFig(vec3(1.0,0.0,0.0), col,d5);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.0);\n    uv*=8.0;\n    vec2 uv1=uv;\n    vec2 uv2=uv;\n        \n    col= paisajeLineas(uv, col);\n    col= casa1(uv, col);\n    col= nave(uv-vec2(sin(iTime), cos(iTime)), col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdySDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 315, 315, 410], [412, 443, 479, 479, 524], [529, 573, 620, 620, 647], [648, 648, 691, 691, 718], [719, 719, 767, 767, 795], [801, 801, 863, 863, 1059], [1061, 1061, 1142, 1142, 1272], [1274, 1274, 1331, 1331, 1397], [1399, 1399, 1436, 1436, 1516], [1518, 1518, 1553, 1553, 1576], [1578, 1578, 1629, 1629, 1937], [1940, 1940, 1977, 1977, 2518], [2520, 2520, 2558, 2558, 2779], [2781, 2781, 2811, 2811, 3238], [3240, 3240, 3269, 3269, 4085], [4088, 4088, 4145, 4145, 4464]], "test": "untested"}
{"id": "fdySDh", "name": "Desert mesas v2", "author": "jarble", "description": "A desert terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["terrain", "fbm", "mountain", "desert", "erosion", "mesa"], "likes": 3, "viewed": 285, "published": 3, "date": "1634523358", "time_retrieved": "2024-07-30T18:55:09.168859", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    float value = value1;\n    float amplitude = .5/i1;\n    float freq = i1/2.;\n    float n1 = 0.;\n    vec2 noise2;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise2.yx+uv/(freq));\n        vec2 noise1 = noise2-value;\n        freq /= 2.15;\n        n1 = noise1.x+noise1.y;\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += n1 * (amplitude-freq);\n        //value += n1/freq;\n        \n        amplitude *= -amplitude;\n        uv += (noise2.yx+n1*freq)*freq;\n        \n\n        //uv += (noise1+vec2(1.))/freq;\n        //uv1 = uv*freq;\n\n        //uv = uv.yx;\n    }\n    \n    return -value;\n}\n\nfloat fbm(vec2 uv, int oct){\n    float result = 0.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result += fbm1(uv,oct,i1,result/i1);\n        oct -= 2;\n    }\n    return result/4.;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+4);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdySDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 929], [931, 931, 959, 959, 1135], [1137, 1137, 1159, 1159, 1189], [1191, 1191, 1221, 1221, 1271], [1273, 1273, 1293, 1293, 1347], [1349, 1349, 1382, 1382, 1576], [1578, 1578, 1645, 1645, 1863], [2237, 2237, 2289, 2289, 2834], [2836, 2836, 2887, 2887, 3088], [3090, 3090, 3116, 3116, 3192], [3260, 3260, 3317, 3317, 5264]], "test": "untested"}
{"id": "7syXWz", "name": "Frozen Window", "author": "davidar", "description": "A variation of mherreshoff's implementation of Reiter's snowflake CA", "tags": ["refraction", "glass", "snowflake", "snow", "window", "ca", "crystal", "growth"], "likes": 50, "viewed": 1310, "published": 3, "date": "1634514440", "time_retrieved": "2024-07-30T18:55:10.052497", "image_code": "#define AA 2\n\n#define T(p) texture(iChannel0, mat2(1,0,.5,1) * mat2(1,0,0,1.25) * (p) / (1.25 * iResolution.xy)).x\n\nvec4 render(vec2 fragCoord)\n{\n    float cell  = T(fragCoord);\n    float cellx = T(fragCoord + vec2(1,0));\n    float celly = T(fragCoord + vec2(0,1));\n\n    vec4 fragColor = 0.75 * texture(iChannel2, vec3((fragCoord - iResolution.xy/2.)/iResolution.y, -0.5));\n    fragColor = mix(fragColor, vec4(1), smoothstep(0., 1., cell));\n    fragColor = mix(fragColor, vec4(0.25), smoothstep(1., 6., cell));\n\n    float focus = 6. - clamp(cell, 0., 4.);\n    vec2 grad = vec2(cellx, celly) - cell;\n    vec2 uv = (fragCoord + 100. * grad) / iResolution.xy;\n    vec3 ray = vec3(uv, -0.5) - vec3(0.5,0.1,0);\n    fragColor = textureLod(iChannel2, ray, focus);\n    fragColor = mix(fragColor, texture(iChannel3, ray), smoothstep(0., 0.9, cell) - smoothstep(0.9, 1., cell));\n    fragColor += 0.2 * dot(grad, vec2(1));\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (int i = 0; i < AA; i++) for (int j = 0; j < AA; j++)\n        fragColor += render(fragCoord + vec2(i,j)/2.) / float(AA*AA);\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, pw = 1./R, uv = U/R;\n    vec3 o = vec3(1,0,-1);\n#define N(swizzle) texture(iChannel0, uv+pw*o.swizzle)\n    vec4 v = N(yy);\n    vec4[6] n = vec4[6](N(xy), N(xx), N(yx), N(yz), N(zz), N(zy));\n    bool receptive = v.x >= 1.0;\n    for (int i = 0; i < 6; i++) {\n        receptive = receptive || (n[i].x >= 1.0); \n    }\n    O = vec4(v.x, float(receptive), 0, 0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, pw = 1./R, uv = U/R;\n    vec3 o = vec3(1,0,-1);\n#define N(swizzle) texture(iChannel0, uv+pw*o.swizzle)\n    vec4 v = N(yy);\n    vec4[6] n = vec4[6](N(xy), N(xx), N(yx), N(yz), N(zz), N(zy));\n    float change;\n    change = (v.y == 1.0) ? GAMMA : -ALPHA*v.x;\n    float nrs = 0.0;\n    for (int i = 0; i < 6; i++) if(n[i].y == 0.0) nrs += n[i].x;\n    change += (nrs/6.0)*ALPHA;\n    O = vec4(v.x + change, 0,0,0);\n    if (iFrame < 10) {\n      O = vec4(BETA + 0.1 * (hash12(U) - 0.5),0,0,0);\n      if (floor(U) == vec2(0,0) || (hash22(U).x < 1e-3 && hash22(U).y < 1e-2))  O = vec4(1.1,0,0,0);\n    }\n    if (iFrame % 100 == 0 && hash23(vec3(U,iFrame)).x < 1e-3 && hash23(vec3(U,iFrame)).y < 1e-3) O.x++;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ALPHA mix(0.5, 1.5, uv.y) /* Diffusion rate. */\n#define BETA mix(0.4, 0.6, abs(2.*uv.x - 1.)) /* Initial water density. */\n#define GAMMA 0.003 /* External condensation. */\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 145, 145, 935], [938, 938, 995, 995, 1154]], "test": "untested"}
{"id": "ssKSDz", "name": "Desert mesas", "author": "jarble", "description": "A desert terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["terrain", "fbm", "mountain", "desert", "erosion", "mesa"], "likes": 11, "viewed": 297, "published": 3, "date": "1634508636", "time_retrieved": "2024-07-30T18:55:10.891255", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x),cos(uv.y))+vec2(1.);\n}\n\n#define OCTAVES 8\nfloat fbm1(in vec2 uv,int octaves,float i1,float value1)\n{\n    //this function generates the terrain height\n    float value = value1;\n    float amplitude = .65/i1;\n    //float amplitude = .6/(i1+value1/4.);\n    \n    float freq = 2.1/i1;\n    float n1 = 0.;\n    vec2 noise2;\n    for (int i = 0; i < octaves; i++)\n    {\n        \n        \n        noise2 = noise(noise2.yx+uv*(freq));\n        vec2 noise1 = noise2-value;\n        freq *= 2.1;\n        n1 = noise1.x+noise1.y;\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = (value+abs(n1) * amplitude)-n1/freq;\n        //value += n1/freq;\n        \n        amplitude *= amplitude;\n        uv -= (n1)/freq;\n        \n\n        //uv += (noise1+vec2(1.))/freq;\n        //uv1 = uv*freq;\n\n        //uv = uv.yx;\n    }\n    \n    return value;\n}\n\nfloat fbm(vec2 uv, int oct){\n    //uv *= 2.;\n    float result = 0.;\n    for(float i = 1.; i < 3.; i++){\n        float i1 = i*i;\n        result -= fbm1(uv/i1,oct,i1,result/i1);\n        oct -= 2;\n    }\n    return result/6.;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+4);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\n/*\n//raymarching with LOD\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    int oct = 2;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            if(oct < 8) oct += 2;\n            else break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n*/\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(0., 1., -1.));\n    \n    vec3 camStep = vec3(-1., 0., 0.) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iTime/8.-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 136], [156, 156, 214, 263, 974], [976, 976, 1004, 1020, 1199], [1201, 1201, 1223, 1223, 1253], [1255, 1255, 1285, 1285, 1335], [1337, 1337, 1357, 1357, 1411], [1413, 1413, 1446, 1446, 1640], [1642, 1642, 1709, 1709, 1927], [2301, 2301, 2353, 2353, 2898], [2900, 2900, 2951, 2951, 3152], [3154, 3154, 3180, 3180, 3256], [3324, 3324, 3381, 3381, 5337]], "test": "untested"}
{"id": "sdKXDR", "name": "Ma Planete", "author": "Edwy", "description": "Pour mes devoirs du Petit Prince dans ma classe de français. Bonjour Monsieur S! Crédit pour l'exact hexagone SDF d'IQ, et l'implémentation de OS2S par K.jpg. Je suis fier de cette shader mais il y a une bonne chance que je vais la reviser dans la future.", "tags": ["raymarch", "planet", "hexagon", "opensimplex"], "likes": 3, "viewed": 342, "published": 3, "date": "1634500563", "time_retrieved": "2024-07-30T18:55:11.643244", "image_code": "mat2 getr(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat heart(vec2 p) {\n    p.x = abs(p.x);\n    p.y -= 0.35 * pow(p.x, 0.55);\n    return length(p) - 0.2;\n}\n\nfloat sdHexagon( in vec2 p, in float r ) { //IQ's 2D Hexagon SDF\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvec3 Image(vec2 uv) {\n    vec4 starnoise = openSimplex2SDerivatives_Classical(vec3(uv.xy * 100.0, iTime / 20.0));\n\n    float s = 0.6;\n    vec2 c = vec2(0.0);\n\n    mat2 sr = getr(0.7 - iTime / 25.0);\n    mat2 pr = getr(-iTime / 5.0);\n    mat2 mr = getr(iTime / 40.0);\n\n    vec2 suv = sr * uv;\n    vec2 puv = pr * uv;\n\n    vec2 src = sr * vec2(0.5);\n\n    vec3 col = (1.0 - 0.85 * distance(src, uv)) * vec3(0.45, 0.45, 0.9);\n    col += max(1.0 - 12.0 * distance(src, uv), 0.0) * vec3(1.0, 0.6, 0.0);\n\n\n\n    vec2 rp = src;\n    for(int i = 0; i < 128; i++){\n        rp += min(sdHexagon(pr * rp, s/2.0), sdHexagon(mr * getr(1.2) * (rp - vec2(1.1, -0.25)), 0.065)) * normalize(uv - src);\n        if(min(sdHexagon(pr * rp, s/2.0), sdHexagon(mr * getr(1.2) * (rp - vec2(1.1, -0.25)), 0.065)) < 0.001 && distance(src, rp) <= distance(src, uv)){\n            col *= 0.55;\n            break;\n        }\n    }\n\n    col = max(vec3(0.0), col);\n\n    col += smoothstep(0.4, 1.0, distance(uv, src)) * vec3(1.0) * smoothstep(0.7, 1.0, starnoise[3]);\n    \n    vec4 noise = openSimplex2SDerivatives_Classical(vec3(uv.xy * 0.1, iTime / 7.5));\n    vec2 huv = getr(0.75) * (uv + vec2(1.0, -0.5)) * 2.0;\n    col += vec3(0.35, 0.0, 0.45) * (smoothstep(0.6, 1.0, distance(uv, src))) * max(0.0, step(-0.1, -heart(huv + 0.05 * normalize(noise.xy))) * sin(heart(huv + 0.05 * normalize(noise.xy)) * 6.2832 * 10.0));\n    \n    float mtime = iTime * 2.0;\n    vec4 mnoise = openSimplex2SDerivatives_Classical(vec3(uv.x * 50.0 + mtime * cos(1.2), uv.y * 50.0 + mtime * sin(1.2), 0.0));\n    vec2 muv = getr(1.2) * (uv - vec2(1.1, -0.25));\n    col += vec3(1.0, 0.8, 0.9) * min(step(0.0,  -muv.x), step(0.8, (muv.x + 0.65 - 8.0 * abs(muv.y) - mnoise[3])));\n    col += (vec3(0.0, 0.8, 0.9) - col) * min(step(0.0,  -muv.x), step(0.8, (muv.x + 0.5 - 8.0 * abs(muv.y) - mnoise[3])));\n    \n    muv = mr * muv;\n    \n    col += vec3(0.0, 0.8, 1.0) * smoothstep(0.1, 1.0, length(col)) *  step(max(abs(muv.y), dot(abs(muv), normalize(vec2(1.7321, 1.0)))), 0.08);\n    col = max(col, step(max(abs(muv.y), dot(abs(muv), normalize(vec2(1.7321, 1.0)))), 0.065));\n    \n    \n    col += vec3(0.0, 1.0, 0.0) * smoothstep(0.1, 1.0, length(col)) *  step(max(abs(puv.y), dot(abs(puv), normalize(vec2(1.7321, 1.0)))), (s + 0.007) / 2.0);\n    col *= 1.0 - step(max(abs(puv.y), dot(abs(puv), normalize(vec2(1.7321, 1.0)))), s / 2.0);\n\n    return col;\n}\n\nMAIN_FUNCTION(Image)", "image_inputs": [], "common_code": "const int aa = 2;\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \tvec2 uv = ((fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5)) * 1.5;\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    fragColor = vec4(total, 1.0);\\\n}\n\n/////////////// K.jpg's Re-oriented 8-Point BCC Noise (OpenSimplex2S) ////////////////\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2SDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 openSimplex2SDerivatives_Classical(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = openSimplex2SDerivativesPart(X) + openSimplex2SDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 92], [94, 94, 115, 115, 199], [201, 201, 243, 265, 455], [457, 457, 478, 478, 2844]], "test": "untested"}
{"id": "7dKXDR", "name": "newton memes", "author": "pema99", "description": "you should play vrchat, it's a good game", "tags": ["newton"], "likes": 3, "viewed": 310, "published": 3, "date": "1634499178", "time_retrieved": "2024-07-30T18:55:12.476017", "image_code": "// operations on complex numbers\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 conjugate(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nvec2 cdiv(vec2 a, vec2 b)\n{\n    return cmul(a, conjugate(b)) / (b.x * b.x + b.y * b.y);\n}\n\nvec2 cpow(vec2 a, int e)\n{\n    vec2 res = a;\n    for (int i = 1; i < e; i++)\n    {\n        res = cmul(res, a);\n    }\n    return res;\n}\n\n// 4th degree polynomial with no constant term\nvec2 f(vec2 a, vec2 r[4])\n{\n    vec2 res = vec2(0.);\n    for (int i = 0; i < 4; i++)\n    {\n        res += cpow(cmul(r[i], a), 4-i);\n    }\n    return res;\n}\n\n// derivative\nvec2 df(vec2 a, vec2 r[4])\n{\n    vec2 res = vec2(0.);\n    for (int i = 0; i < 4; i++)\n    {\n        res += float(4-i) * cpow(cmul(r[i], a), 4-i-1);\n    }\n    return res;\n}\n\n// newton-raphson\nvec2 newton(vec2 guess, vec2 r[4])\n{\n    for (int i = 0; i < 30; i++)\n    {\n        guess = guess - cdiv(f(guess, r), df(guess, r));\n    }\n    return guess;\n}\n\nvec3 hs(vec3 Color, float Shift)\n{\n    vec3 P = vec3(0.55735, 0.55735, 0.55735)*dot(vec3(0.55735, 0.55735, 0.55735),Color);\n    vec3 U = Color-P;\n    vec3 V = cross(vec3(0.55735, 0.55735, 0.55735),U);\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*((fragCoord/iResolution.xy)-0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 r[4];\n    for (int i = 0; i < 4; i++)\n    {\n        r[i] = vec2(cos(float(i)*6.28*0.25 +3.14*0.5), sin(float(i)*6.28*0.25 +3.14*0.5));\n    }\n    r[0].x = sin(iTime)*0.7;\n    r[2].x = sin(-iTime)*0.7;\n    r[1] += vec2(cos(iTime*0.5), sin(iTime*0.5))*0.2;\n    r[3] -= vec2(cos(iTime*0.5), sin(iTime*0.5))*0.2;\n    vec2 guess = newton(uv, r);\n    \n    float minDist = distance(guess, r[0]);\n    vec2 minNum = r[0];\n    for (int i = 1; i < 4; i++)\n    {\n        float dist = distance(guess, r[i]);\n        if (dist < minDist)\n        {\n            minNum = r[i];\n            minDist = dist;\n        }\n    }\n\n    fragColor = vec4(hs(hs(vec3(1., 0., 0.), log(abs(guess.x))/5.), log(abs(guess.y))/5.), 1.);\n    \n    // Debug\n    /*for (int i = 0; i < 4; i++)\n    {\n        if (distance(r[i], uv) < 0.05)\n        {\n            fragColor = vec4(0.);\n        }\n    }*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 60, 60, 125], [127, 127, 151, 151, 181], [183, 183, 210, 210, 272], [274, 274, 300, 300, 408], [410, 457, 484, 484, 612], [614, 628, 656, 656, 799], [801, 819, 855, 855, 977], [979, 979, 1013, 1013, 1258], [1260, 1260, 1317, 1317, 2283]], "test": "untested"}
{"id": "7dyXDz", "name": " Fab17 #inktober2021 \"collide\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nclick to reset.   set n² = nb partics in Common.   try other B(U)  shapes.\n\n", "tags": ["2d", "simulation", "physics", "inktober2021"], "likes": 22, "viewed": 377, "published": 3, "date": "1634491064", "time_retrieved": "2024-07-30T18:55:13.229004", "image_code": "// reusing bits of https://shadertoy.com/view/sdtSRs\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O = T(U);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- draw scene + gradient ( could be done just once )\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n     vec2  U = ( u+u - R ) / R.y;\n     float d = B(U);\n     U = abs( 2.*u/R-1. ); d -= 4.*max(0.,max(U.x,U.y)-.9); // band guard at screen borders.\n     O = vec4( d, normalize(vec2(dFdx(d), dFdy(d))), 0 );\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R         iResolution.xy\n#define S(v)      smoothstep(5./R.y,0., v ) \n//#define H(p)    ( 2.*fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) -1. )\n#define T(U)      texelFetch( iChannel0, ivec2(U), 0 )\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nint n = 12;       // n*n particles\n\n// --- custom scene SDF\n\n//float K = 32.;    // smooth min: https://iquilezles.org/articles/smin\n//#define B(U) ( .9 + log2(exp2(-K*length(U-vec2(.7,0)))+exp2(-K*length(U+vec2(.7,0))) )/K )\n  #define B(U) ( .9 - length(U/vec2(2,1)) + map(U).x-.4 ) \n\n#define map(U) texture(iChannel1, .5+.5*((U)*R.y/R) )", "buffer_b_code": "// --- physics: simulate particles   .xy = pos, .zw = v.dt\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    if ( max(U.x,U.y) > float(n) ) return;                    // only 64 partics\n    \n    if (iFrame==0 || iMouse.w>0.) \n     // { O = vec4( H(U), .01*H(U+.1) ); return; }            // init\n        { U-=.5; float i = U.x+float(n)*U.y;\n          O = vec4( 0,0, .01*cos(3.1415*(2.*i/float(n*n)-1.)+vec2(0,-1.57)) ); return; } // init\n                      // variant: .7+.2*(\n    O = T(U);                                                 // recover previous state\n    O.xy += O.zw;                                             // move particle\n    \n    vec4 T = map(O.xy);                                       // scene SDF + gradient \n    if ( T.x < 0.)                                            // collision with border\n        O.zw = reflect( O.zw, T.yz ),                         // bounce\n        O.xy += 2.*O.zw; // decollision.  NB: can't be merged with previous line: GLSL bug !\n    if ( length(O.xy) > 2. ) O.xy *= 0.;                      // in case a particle escaped, relauch\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// --- draw particles with memory\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  U = ( u+u - R ) / R.y;\n    float d = 9., l; int i, k=0;\n\n    for (; k <n*n; k++)                               // particle closest to pixel\n      l = length( T(vec2(k%n,k/n)).xy - U ),\n      l < d ? d = l, i = k : i;\n    \n    O = max(     S(d-.01) * hue(float(i)/float(n*n))  // draw particle\n               + S( map(U).x)                         // draw scene\n             , .99 *texture(iChannel2,u/R)            // blend past for trajectories\n           );\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 90, 90, 106]], "test": "untested"}
{"id": "NdVXWz", "name": "Pixelized IceCreamSwirl", "author": "foxic", "description": "Yummy Pixelized IceCreamSwirl. :P", "tags": ["swirl", "pixel", "icecream", "pixelized"], "likes": 6, "viewed": 304, "published": 3, "date": "1634485906", "time_retrieved": "2024-07-30T18:55:14.073745", "image_code": "\n#define PixelSize 32.\n\nvec2 rotate2D(vec2 _st,float _angle){\n    _st=mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y;\n    uv = ceil(uv*PixelSize)/PixelSize; //pixelise\n\n    vec2 uv1 = rotate2D(uv, (length(uv*5.)+iTime)*2. );\n    uv += vec2(0.,0.025);\n    vec2 uv2 = rotate2D(uv, (length(uv*5.)+iTime)*2. );\n    \n    \n    vec3 col1 = vec3(0.97,0.5,0.74);\n    vec3 col2 = vec3(0.03);\n    vec3 col3 = mix(col1,col2,0.8);\n    col2 = mix(col3,col2,float((uv2.x) > 0.05));\n    \n    vec3 col = mix(col1,col2,float((uv1.x) > 0.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVXWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 61, 61, 152], [154, 154, 211, 211, 723]], "test": "untested"}
{"id": "fdVSWz", "name": "2d basic building", "author": "jorge2017a2", "description": "2d basic building", "tags": ["2dbasicbuilding"], "likes": 5, "viewed": 225, "published": 3, "date": "1634483855", "time_retrieved": "2024-07-30T18:55:14.917489", "image_code": "///2d basic building-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r;}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\nvec3 Suelo1(vec2 p, vec3 col)\n{   col=DrawFig(vec3(0.45), col, p.y-2.5 );\n return col;\n}\n\nvec3 colina(vec2 p, vec3 col)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,2.0) );\n    col=DrawFigBordeCol(vec3(0.0,0.95,0.2), col, d1 , vec3(0.35));\n    return col;\n}\n\nvec4 sujeto(vec2 p, vec3 col)\n{  float d1= sdCircle(p-vec2(0.0,0.0), 0.25);\n    float d2= sdBox(p-vec2(0.0,-0.8), vec2(0.1,0.6) ); //cuerpo\n    float d3=sdOrientedBox( p-vec2(0.0,-1.2), vec2(1.0,0.0), vec2(0.0,0.8), 0.2 );\n    float d4=sdOrientedBox( p-vec2(-1.0,-1.2), vec2(0.0,0.0), vec2(1.0,1.0), 0.2 );\n    float d5=sdOrientedBox( p-vec2(0.0,-2.2), vec2(1.0,0.0), vec2(0.0,0.8), 0.2 );\n    float d6=sdOrientedBox( p-vec2(-1.0,-2.2), vec2(0.0,0.0), vec2(1.0,1.0), 0.2 );\n    float d=unionSDF(d1,d2);\n    d=unionSDF(d,d3);\n    d=unionSDF(d,d4);\n    d=unionSDF(d,d5);\n    d=unionSDF(d,d6);\n    \n    return vec4(vec3(0.0),d);\n}\n\n\n\nvec3 Edificio0(vec2 p, vec3 col)\n{  \n    float d1=sdBox(p-vec2(-4.0,4.0), vec2(10.0,3.5) ); //frente\n    float d2=sdParallelogram( p.yx-vec2(5.0,7.0), 3.5, 1.0, 1.0 ); //pared derecha\n    float d3=sdParallelogram( p-vec2(-3.0,8.5), 10.0, 1.0, 1.0 );  //techo\n    \n    //ventana\n    float d4= sdTunnel(p- vec2(-10.0,2.0), vec2(1.0,1.5) );\n    float d5= sdTunnel(p- vec2(-6.0,2.0), vec2(1.0,1.5) );\n    float d6= sdTunnel(p- vec2(-2.0,2.0), vec2(1.0,1.5) );\n    float d7= sdTunnel(p- vec2(2.0,2.0), vec2(1.0,1.5) );\n    \n    vec3 coltex=texture(iChannel0, p*0.25).rgb;\n    //col= DrawFigBorde(vec3(0.2),col,d1);\n    col= DrawFigBorde(coltex,col,d1);\n    col= DrawFigBorde(vec3(0.3),col,d2);\n    col= DrawFigBorde(vec3(0.45),col,d3); //-\n    col= DrawFigBorde(vec3(0.0),col,d4);\n    col= DrawFigBorde(vec3(0.0),col,d5);\n    col= DrawFigBorde(vec3(0.0),col,d6);\n    col= DrawFigBorde(vec3(0.0),col,d7);\n    return col;\n}\n\n\nvec3 Edificio1(vec2 p, vec3 col)\n{  \n    ///suelo\n    float d1=sdParallelogram( p-vec2(-6.0,-2.5), 7.0, 2.0, 2.0 );\n    float d2=sdParallelogram( p-vec2(-5.8,-2.9), 7.0, 2.0, 2.0 );\n    float d3=sdBox(p-vec2(-8.0,-4.7), vec2(7.0,0.25) );\n    //edificio\n    float d4=sdBox(p-vec2(-6.0,1.0), vec2(4.0,4.0) ); //frente \n    float d5=sdParallelogram( p.yx-vec2(2.0,-1.0), 4.0, 1.0, 1.0 ); //pared derecha\n    float d6=sdParallelogram( p-vec2(-5.0,6.0), 4.0, 1.0, 1.0 );  //techo\n    //marco\n    float d7=sdBox(p-vec2(-6.0,1.0), vec2(0.5,4.0) );\n    float d8=sdBox(p-vec2(-6.0,1.0), vec2(4.0,0.5) );\n    //ventana\n    float d9= sdTunnel(p- vec2(-8.0,-1.0), vec2(1.0,1.5) );\n    float d10= sdTunnel(p-vec2(-4.0,-1.0), vec2(1.0,1.5) );\n    float d11= sdTunnel(p-vec2(-8.0,3.5), vec2(1.0,1.5) );\n    float d12= sdTunnel(p-vec2(-4.0,3.5), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(vec3(0.6),col, d2 );\n    col= DrawFigBorde(vec3(0.5,0.6,0.1),col, d1 );\n    col= DrawFigBorde(vec3(0.6),col, d3 );\n    //col= DrawFigBorde(vec3(0.6),col,d4);\n    vec3 coltex=texture(iChannel0, p*0.25).rgb;\n    col= DrawFigBorde(coltex,col,d4);\n    col= DrawFigBorde(vec3(0.3),col,d5);\n    col= DrawFigBorde(vec3(0.7),col,d6);\n    col= DrawFigBorde(vec3(0.8),col,d7);\n    col= DrawFigBorde(vec3(0.8),col,d8);\n    \n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d9);\n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d10);\n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d11);\n    col= DrawFigBorde(vec3(0.2,0.1,1.0),col,d12);\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=10.0;\n    \n    uv.x+=4.0*sin(iTime*2.0);\n    col=colina(uv-vec2(0.0,4.0),col);\n    col=Suelo1(uv, col);\n    col=Edificio0(uv-vec2(-10.0,0.0),col);\n    col=Edificio0(uv-vec2(14.0,0.0),col);\n    col= Edificio1(uv-vec2(-5.0,-2.0),col);\n    col= Edificio1(uv-vec2(15.0,-2.0),col);\n    vec4 col4=sujeto(uv, col);\n    col=DrawFigBorde(col4.xyz, col, col4.w);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 317, 317, 412], [414, 445, 481, 481, 526], [531, 575, 622, 622, 649], [650, 650, 693, 693, 720], [721, 721, 769, 769, 797], [803, 803, 865, 865, 1061], [1063, 1063, 1144, 1144, 1274], [1276, 1276, 1333, 1333, 1399], [1401, 1401, 1438, 1438, 1518], [1520, 1520, 1555, 1555, 1577], [1579, 1579, 1630, 1630, 1938], [1941, 1941, 2007, 2007, 2349], [2351, 2351, 2373, 2373, 2392], [2393, 2393, 2434, 2434, 2703], [2705, 2705, 2771, 2771, 2988], [2991, 2991, 3022, 3022, 3079], [3081, 3081, 3112, 3112, 3294], [3296, 3296, 3327, 3327, 3923], [3927, 3927, 3961, 3961, 4843], [4846, 4846, 4880, 4895, 6349], [6354, 6354, 6411, 6411, 6972]], "test": "untested"}
{"id": "NsKXDR", "name": "shooter demo WIP", "author": "yasuo", "description": "shooter demo WIP", "tags": ["shooter"], "likes": 5, "viewed": 308, "published": 3, "date": "1634480000", "time_retrieved": "2024-07-30T18:55:15.675462", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 80\n#define MAX_DIST 32.\n#define SURF_DIST .001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL0 0\n#define MATERIAL1 1\n#define MATERIAL2 2\n#define SPEED 2.0\n#define ZERO (min(iFrame,0))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec3 tex(vec2 p, vec3 col, vec3 col2){\n    p*=3.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    vec2 randP = fract(sin(id*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    \n    float speed = 0.8;\n    if(rand<0.5){\n        uv*=Rot(radians(90.0));\n        speed = 0.6;\n        uv.x+=0.4;\n    } else {\n        uv.x-=0.4;\n    }\n    \n    float dd = S(B(uv,vec2(0.04,0.5)),-0.05);\n    speed*=1.8;\n    uv.y*=0.5;\n    uv.y+=sin(iTime*speed)*0.4;\n    col=mix(col,col2,dd+S(length(uv)-0.18,-0.2));\n    return col;\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat ship(vec3 p){\n    p*=0.6;\n    vec3 prevP = p;\n    p.z*=0.8;\n    float d = sdOctahedron(p,0.3);\n    float d2 = sdOctahedron(p-vec3(0.0,0.0,-0.25),0.2);\n    d = min(d,d2);\n    d2 = sdOctahedron(p-vec3(0.0,0.0,-0.5),0.1);\n    d = min(d,d2);\n    \n    p.xy*=Rot(radians(iTime*-100.0));\n    p.z*=0.3;\n    p.x = abs(p.x);\n    p.x-=0.45;\n    d2 = sdOctahedron(p-vec3(0.0,0.0,-0.1),0.1);\n    d = min(d,d2);\n    return d;\n}\n\nfloat sdBase( in vec3 p)\n{\n    p = mod(p,4.2)-2.1;\n    float d = B3D(p, vec3(0.3));\n    for(float i = 1.; i<=2.; i++){\n        p = abs(p);\n        p -= 1.5*i;\n        p.xz *= Rot(radians(i*45.0));\n        p.yz *= Rot(radians(i*-30.0));\n        d = min(d,B3D(p+vec3(cos(i)*0.3,sin(i)*0.5,0.0), vec3(sin(i)*0.8)));\n    }\n    return d;\n}\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * 0.7, cos(z * .8), z);\n    return p;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*1000.0)*0.1;\n    \n    vec3 q = p+1.5;\n    q.z -= iTime*SPEED;\n    if(mod(iTime,20.0)<15.0){\n        q.z +=2.0;\n    } else {\n        q.z -=6.0;\n    }\n    \n    q.x-=1.5;\n    q.y-=1.5;\n    float sp = ship(q);\n    \n    vec3 prevP = p;\n    p.xy -= path(p.z).xy;\n    \n    p.z = 0.;\n    float d = B3D(p,vec3(3.0,2.5,2.5));\n    \n    p = prevP;\n    p.z += iTime*SPEED;\n    float d2 = sdBase(p);\n    \n    p.z += iTime*SPEED*1.05;\n    p.z = mod(p.z,2.0)-1.0;\n    p.x = abs(p.x);\n    p.x-=2.3;\n    p.xy*=Rot(radians(45.0));\n    float d3 = sdOctahedron(p,0.4);\n    \n    vec2 res = combine(vec2(max(-d,d2),MATERIAL0),vec2(d3,MATERIAL1));\n    res = combine(res,vec2(sp,MATERIAL2));\n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(p.x,p.y,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(0.8,0.7,-1.5)*diff*occ;\n    diffCol += col*vec3(0.8,0.5,1.9)*skyDiff*occ;\n    diffCol += col*vec3(1.3,1.3,1.7)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL0){\n        vec3 np = p;\n        np.z+=iTime*SPEED;\n        float nn = noise3d(np*5.0)*0.15;\n        col = diffuseMaterial(n,rd,p,tex(p.xy,vec3(0.2,0.3,0.9)*nn+0.3,vec3(0.9,0.3,0.3)));\n    } else if(mat == MATERIAL1){\n        col = diffuseMaterial(n,rd,p,vec3(0.6,0.3,0.7));\n    } else if(mat == MATERIAL2){\n        col = diffuseMaterial(n,rd,p,vec3(0.2,0.1,1.5)+tex(p.xy,vec3(0.2,0.3,1.5),vec3(0.9,0.9,1.2)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*SPEED;\n    vec3 ro = path(t+1.5);\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    \n    if(mod(iTime,20.0)<15.0){\n        rd*=matRotateZ(radians(iTime*15.0));\n    } else {\n        rd*=matRotateZ(radians(iTime*15.0))*matRotateX(radians(180.0));\n    }\n    \n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.0001*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);   \n    }\n    \n    // POST EFFECTS    \n    rd.z+=iTime*2.0;\n    \n    // dust effect\n    float c = noise3d(rd) * 0.5 + noise3d(rd * 5.0) * 0.25 + noise3d(rd * 10.0) * 0.1;    \n    col+=vec3(0.7,0.1,0.9)*c*0.3;    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[672, 672, 710, 710, 1243], [1245, 1357, 1382, 1382, 1721], [1723, 1723, 1759, 1759, 1801], [1803, 1803, 1830, 1830, 1884], [1886, 1886, 1924, 1924, 1981], [1983, 1983, 2002, 2002, 2402], [2404, 2404, 2430, 2430, 2738], [2740, 2740, 2760, 2760, 2825], [2827, 2827, 2849, 2849, 3551], [3553, 3553, 3611, 3611, 3882], [3884, 3884, 3908, 3908, 4109], [4111, 4111, 4153, 4153, 4348], [4350, 4391, 4440, 4440, 4731], [4733, 4733, 4790, 4790, 5347], [5349, 5349, 5408, 5408, 5865], [5867, 5867, 5924, 5924, 6908]], "test": "untested"}
{"id": "fdVXRm", "name": "Gyroid Exploded Sections II", "author": "byt3_m3chanic", "description": "Experiments while trying to figure out other shader problems (always have a B shader going on) - Working on some biological / media scenes -how to emulate organic items and processes.. \n(Mouseable) ", "tags": ["raymarching", "refraction", "transparent", "layers", "gyroid"], "likes": 12, "viewed": 371, "published": 3, "date": "1634477611", "time_retrieved": "2024-07-30T18:55:16.429447", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Just an experiment into doing some\n    visual representations / layers like in\n    those old science textbooks.\n    \n    AA chugs a bit/2pass hack bit anything\n    more kills it on my PC\n\n*/\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI      3.14159265358\n#define PI2     6.28318530718\n\n// set to 1.0 if it chugs for you\n#define AA 2.0\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*43758.5453); }\n\n//@iq\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cap( vec3 p, float h, float r ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdGry(vec3 p, float s, float t, float b) {\n    p *= s;\n    float sw = 1.25+1.25*sin(23.3);\n    return abs(dot(sin(p*1.57-sw), cos(p.zxy))-b)/(s)-t;\n}\n\n//global\nvec3 hit=vec3(0),hitPoint=vec3(0);\nvec2 uv=vec2(0);\nmat2 turn,rx,ry;\nfloat g1,g2,g5,g4,gg5;\nfloat dz = .38;\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    float cutbox = cap(p, 7.,5.);\n\n    vec3 q = p;\n    q.xz*=turn;\n \n    float gdens = 1.35, g1 = 0.;\n\n    g2 = sdGry(q, gdens*8., .028, .2);\n    g5 = sdGry(q, gdens*7., .058, .2)*.5;\n\n    g1 = sdGry(q, gdens, .008, .5);\n    g1 = max(g1-.05,g2);\n\n    g1 = max(cutbox,g1*.5); \n    if(g1<res.x&&uv.x>dz) {\n        res=vec2(g1,1.);\n        hit=q;\n    }\n\n    g1 = sdGry(q, gdens, .02, .8);\n    g1 = max(g1,g5);\n    \n    g1 = max(cutbox,g1*.5); \n    if(g1<res.x&&uv.x>-dz) {\n        res=vec2(g1,2.);\n        hit=q;\n    }\n    \n    g1 = sdGry(q, gdens, .098, 1.15);\n    g1 = max(g1,g5);\n    \n    g1 = max(cutbox,g1*.5); \n    if(g1<res.x) {\n        res=vec2(g1,3.);\n        hit=q;\n    }\n \n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float e) {\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d);\n    vec3 lpos = vec3(.1,9,7);\n    vec3 l = normalize(lpos);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 8.5);\n    fresnel = mix(.0, .9, fresnel);\n    \n    vec3 h = vec3(.01);\n    if(m==1.) h = vec3(0.690,0.408,0.012);\n    if(m==2.) h = vec3(0.012,0.306,0.549);\n    if(m==3.) h = vec3(0.161,0.129,0.173);\n    if(m==3.) {\n        h = mix(vec3(0.161,0.129,0.173),vec3(0.690,0.271,0.620),g5*4.);\n    }\n\n    return diff*h;\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 F) {\n   \n    vec3 C = vec3(0);\n    vec3  p = ro + rd * .1;\n    float atten = 1., k = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n        float fresnel=0.;\n        float d = ray.x*.65;\n        float m = ray.y;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n \n            hitPoint=hit;\n            \n            C+=shade(p,rd,d,m,n,fresnel)*atten;\n\n            atten *= .45;\n            p += rd*.1;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n\n            if((int(F.x)%3 != int(F.y)%3)&&m!=3.) {\n                rd = refract(rd,n,m==2.?.8:.5);\n            }else{\n                rd=reflect(-rd,n);\n                p+=n*.015;\n            } \n         \n            \n        }  \n        if(distance(p,rd)>30.) { break; }\n       \n    }\n    return C;\n}\n\nvoid image( out vec4 O, in vec2 F ) {   \n    turn = rot(T*1.25*PI/180.);\n\n    vec3 C = vec3(.0);\n    \n    uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    dz = .42+.11*sin(uv.y*2.3+T);\n\n    vec3 ro = vec3(0,0,M.z>0.?11.:9.),\n         rd = normalize(vec3(uv,-1));\n    vec2 mm = M.xy/R.xy;\n    float x = M.xy == vec2(0) ? .0 : -(mm.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? .0 :  (mm.x * 2. - 1.) * PI;\n\n    rx = rot(x);ry = rot(y);\n\n    ro.yz *= rx;rd.yz *= rx;\n    ro.xz *= ry;rd.xz *= ry;\n\n    C = render(ro,rd,F);\n    \n    float px = fwidth(uv.x)*PI;\n    if(uv.x<px-dz&& uv.x>-(dz+px)) C = vec3(1);\n    if(uv.x>(dz-px)&& uv.x<(dz+px)) C = vec3(1);\n    \n    C = clamp(C,vec3(.03),vec3(.98));\n    O = vec4(C,1.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 F){\n    vec4 C = vec4(0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float px = .125;\n    \n    if(AA==1.0) {\n        image(C,F);\n    } else {\n    \n        vec4 C2;\n        image(C2,F.xy+vec2(px,px));\n        C.rgb+=C2.rgb;\n        image(C2,F.xy+vec2(-px,-px));\n        C.rgb+=C2.rgb;\n        C/=2.0;\n    }\n    \n    C = sqrt(smoothstep(0.,1.,C));\n    O = vec4(C);\n}\n\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[466, 466, 485, 485, 530], [531, 531, 553, 553, 612], [614, 620, 648, 648, 735], [737, 737, 775, 775, 886], [888, 888, 936, 936, 1043], [1163, 1163, 1180, 1180, 1908], [1910, 1979, 2009, 2009, 2210], [2212, 2212, 2294, 2294, 2780], [3744, 3744, 3781, 3781, 4457], [4459, 4459, 4497, 4497, 4862]], "test": "untested"}
{"id": "fsVSWR", "name": "shader-web-background JS lib 4", "author": "morisil", "description": "Check mouse!  I tweaked a bit this older shader of mine\n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 7, "viewed": 378, "published": 3, "date": "1634468621", "time_retrieved": "2024-07-30T18:55:17.291143", "image_code": "// Fork of \"shader-web-background JS lib 3\" by morisil. https://shadertoy.com/view/NdKXRm\n// 2021-10-17 11:03:28\n\n// Fork of \"shader-web-background JS lib 2\" by morisil. https://shadertoy.com/view/fs3XDB\n// 2021-10-16 23:27:09\n\n// Fork of \"shader-web-background JS lib\" by morisil. https://shadertoy.com/view/wlKyR1\n// 2021-10-09 22:16:29\n\n/*\n  This shader is here to spread the news about JavaScript library:\n  \n  https://xemantic.github.io/shader-web-background/\n \n  It is designed to be compatible with Shadertoy while adding more\n  integration options and saving many once-per-frame computations.\n  Even complex shaders should work on almost any hardware. I wanted\n  to build a base, which would let me use shaders as part of my\n  regular web development process, to transform my future website\n  into more immersive experiences. Check the project on mobile and\n  how it is reacting to device orientation, parallax scrolling, etc.\n  \n  Note: Mouse movement will make feedback follow the cursor.  \n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, gl_FragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst float iFeedbackZoomRate         = .003;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .006;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 1.25;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .15;\nconst float iBlob1PowFactor           = 60.;\nconst float iBlob1ColorPulseSpeed     = .13;\nconst float iBlob2Radius              = .3;\nconst float iBlob2PowFactor           = 60.;\nconst float iBlob2ColorPulseSpeed     = .2;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = 1.7;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    vec2 iFeedbackZoomCenter = vec2(sin(iTime * .6), cos(iTime * .7)) * .2;\n    vec2 iDrawCenter = iFeedbackZoomCenter;\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.) \n    ) \n    * vec3(.7, .3, 1.);\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    )\n    * vec3(.7, .3, 1.);\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.rg - .5) * iFeedbackColorShiftImpact * vec2(sin(iTime * .2), cos(iTime * .3));\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n    stShift *= (1. + cos(drawAngle * 30. + drawDist * 100. + iTime * 2.5));\n\n    vec3 prevColor = repeatedTexture(iChannel0, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1006, 1006, 1061, 1061, 1133]], "test": "untested"}
{"id": "7dVXRm", "name": "You're tellin' me...?", "author": "Xibanya", "description": "experiment with unpacking textures and doing tangent space normal mapping with SDFs. Not that special but this is the first time I've tried it. mainly just muddling through the way I'm used to shading meshes, but I think it turned out ok", "tags": ["sdf", "food", "lit"], "likes": 8, "viewed": 496, "published": 3, "date": "1634454173", "time_retrieved": "2024-07-30T18:55:18.042135", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define saturate(x) clamp(x, 0., 1.)\n#define ZOOM 0.35\n#define LIGHT_COLOR vec3(1.00, 0.85, 0.55)\n#define SHADOW_COLOR vec3(0.5294, 0.3569, 0.5804)\n#define EPS vec3(0.001, 0.0, 0.0)\n\n#define BOWL_COLOR  vec3(0.84,0.34,0.34)\n#define RICE_COLOR vec3(0.93,0.9,0.8)\n#define TABLE_COLOR vec3(0.5098, 0.3804, 0.298)\n#define SHRIMP vec3(1.0, 0.62, 0.5)\n\n// prototyped scene in https://stephaneginier.com/archive/editSDF/\n\n// Basic Bump Mapping\n// https://www.shadertoy.com/view/ld2GRh\nvec3 TangentNormal(sampler2D tex, vec2 coord)\n{\n    const float diff = 0.001;\n\t// Get the local difference of height along the X axis.\n\tfloat diffX = texture(tex, vec2(coord.x + diff, coord.y)).x\n\t\t-texture(tex, vec2(coord.x-diff, coord.y)).x;\n\t\n\t// Do the same along the Y axis.\n\tfloat diffY = texture(tex, vec2(coord.x, coord.y+diff)).x\n\t\t-texture(tex, vec2(coord.x, coord.y-diff) ).x;\n\n\tvec2 localDiff = vec2(diffX, diffY);\n\tlocalDiff *= -1.0;\n\tlocalDiff = (localDiff/2.0)+.5;\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(1.0 - pow(localDiffMag, 2.0));\n\treturn vec3(localDiff, z) * 2. - 1.;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\nfloat ShrimpDist(vec3 p) \n{   \n    p += vec3(0., -0.2, 0.);\n    vec3 pos = (mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0,0.0,1.0) * vec4(p, 1.0)).xyz;\n  float s = sdTorus(pos, vec2(0.33,0.15) * 0.5);  \n    s = max(s, \n    -sdSphere((mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0126,-0.22,1.0) * \n    vec4(p, 1.0)).xyz, 0.4 * 0.5));\ns = min(s, sdBox((mat4(\n    5.84,0.0,1.085,\n    0.0,0.0,5.94,0.0,0.0,\n    -1.085, 0.0,5.84,0.0,\n    1.750817894935608,0.0, -0.47,1.0) * \n    vec4(p, 1.0)).xyz + vec3(-0.7, 0., 0.), \n    vec4(0.2,0.24,0.91,0.84) * 0.5) * 0.17);\n\nvec3 tailPos = (mat4(\n    1.85,0.0,-0.64,0.0,\n    0.0,1.96,0.0,0.0,\n    0.64,0.0,1.85,0.0,\n    -0.74,0.0,-0.38,1.0) * \n    vec4(p, 1.0)).xyz + vec3(0.4, 0., 0.);\ns = min(s, sdEllipsoid(tailPos, \n    vec3(0.0353, 0.0863, 0.1725) * 2.));\n    return s;\n}\n\nfloat BowlDist(vec3 p)\n{\n  vec3 bowlPos = (mat4(\n        0.63,0.0,0.0,0.0,\n        0.0,0.63,0.0,0.0,\n        0.0,0.0,0.63,0.0,\n        0.0,-0.066,0.0,1.0) * \n      vec4(p, 1.0)).xyz;\n  float s = sdSphere(bowlPos, 0.4) * 1.59;\n  vec3 subTopPos = (mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,-0.49,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  vec3 innerPos = (mat4(\n    0.66,0.0,0.0,0.0,\n    0.0,0.66,0.0,0.0,\n    0.0,0.0,0.66,0.0,\n    0.0,-0.0625,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  float negativeBowl = min(\n    sdBox(subTopPos, vec4(0.68,0.4,0.8,0.0)),\n    sdSphere(innerPos, 0.4) * 1.52\n  );   \n  s = max(s, -negativeBowl);\n  return s;\n}\n\nfloat RiceDist(vec3 p)\n{\n  vec3 ricePos = (mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,0.125,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  return sdEllipsoid(ricePos, vec3(0.57,0.27,0.56));\n}\n\nfloat TableDist(vec3 p)\n{\n  vec3 tablePos = (mat4(\n    1.0,0.0,0.0,0.0,\n    0.0,1.0,0.0,0.0,\n    0.0,0.0,1.0,0.0,\n    0.0,0.55,0.0,1.0) * \n    vec4(p, 1.0)).xyz;\n  float table = sdBox(tablePos, vec4(1.48,0.01,1.48,0.0));\n  return table;\n}\n\nfloat mapDistance(const in vec3 p, out vec3 normal, out vec3 col, \n    out float shiny) \n{\n  vec2 uvX = p.zy;\n  vec2 uvY = p.xz;\n  vec2 uvZ = p.xy;\n\n  float s = BowlDist(p);\n  col = BOWL_COLOR;\n  shiny = 1.5;\n\n  normal = normalize(vec3(\n      BowlDist(p + EPS.xyy) - BowlDist(p - EPS.xyy),\n      BowlDist(p + EPS.yxy) - BowlDist(p - EPS.yxy),\n      BowlDist(p + EPS.yyx) - BowlDist(p - EPS.yyx)));\n  vec3 tNormalX = TangentNormal(iChannel2, uvX * 0.25);\n  vec3 tNormalY = TangentNormal(iChannel2, uvY * 0.25);\n  vec3 tNormalZ = TangentNormal(iChannel2, uvZ * 0.25);\n  shiny *= pow(tNormalZ.x * 0.5 + 0.5, 0.05);\n  vec3 aSign = sign(normal);\n  \n  float rice = RiceDist(p);\n  vec3 riceNorm = normalize(vec3(\n      RiceDist(p + EPS.xyy) - RiceDist(p - EPS.xyy),\n      RiceDist(p + EPS.yxy) - RiceDist(p - EPS.yxy),\n      RiceDist(p + EPS.yyx) - RiceDist(p - EPS.yyx)));\n  tNormalX = s < rice? tNormalX : TangentNormal(iChannel1, uvX * 2.);\n  tNormalY = s < rice? tNormalY : TangentNormal(iChannel1, uvY * 2.);\n  tNormalZ = s < rice? tNormalZ : TangentNormal(iChannel1, uvZ * 2.);\n  float riceTex = (mat3(\n        texture(iChannel1, p.yz * vec2(4., 2.)).rgb,\n        texture(iChannel1, p.xz * vec2(4., 2.)).rgb,\n        texture(iChannel1, p.xy * vec2(4., 2.)).rgb\n        ) * abs(riceNorm)).r;\n  vec3 riceColor = smoothstep(-0.35, 0.8, riceTex) * RICE_COLOR;\n  aSign = s < rice? aSign : sign(riceNorm);\n  col = s < rice? col : riceColor;\n  normal = s < rice? normal : riceNorm;\n  shiny = s < rice? shiny : 0.;\n  s = min(s, rice);\n\n    float shrimp = ShrimpDist(p);\n    col = s < shrimp? col : SHRIMP;\n    vec3 shrimpNorm = normalize(vec3(\n      ShrimpDist(p + EPS.xyy) - ShrimpDist(p - EPS.xyy),\n      ShrimpDist(p + EPS.yxy) - ShrimpDist(p - EPS.yxy),\n      ShrimpDist(p + EPS.yyx) - ShrimpDist(p - EPS.yyx)));\n    tNormalX = s < shrimp? tNormalX : TangentNormal(iChannel3, uvX * 2.);\n    tNormalY = s < shrimp? tNormalY : TangentNormal(iChannel3, uvY * 2.);\n    tNormalZ = s < shrimp? tNormalZ : TangentNormal(iChannel3, uvZ * 2.);\n    normal = s < shrimp? normal : shrimpNorm;\n    shiny = s < shrimp? shiny : 0.15;\n    s = min(s, shrimp);\n\n  float table = TableDist(p);\n  vec3 tableNorm = normalize(vec3(\n      TableDist(p + EPS.xyy) - TableDist(p - EPS.xyy),\n      TableDist(p + EPS.yxy) - TableDist(p - EPS.yxy),\n      TableDist(p + EPS.yyx) - TableDist(p - EPS.yyx)));\n\n  vec3 tableTex = mat3(\n        texture(iChannel0, uvX * 0.5).rgb,\n        texture(iChannel0, uvY * 0.5).rgb,\n        texture(iChannel0, uvZ * 0.5).rgb\n        ) * abs(tableNorm);\n    \n    vec3 tableColor = mix(TABLE_COLOR * 0.65, TABLE_COLOR, tableTex.r);\n    col = s < table? col : tableColor;\n    \n    tNormalX = s < table? tNormalX : TangentNormal(iChannel0, uvX * 0.5);\n    tNormalY = s < table? tNormalY : TangentNormal(iChannel0, uvY * 0.5);\n    tNormalZ = s < table? tNormalZ : TangentNormal(iChannel0, uvZ * 0.5);\n\n    tNormalX.z *= aSign.x;\n    tNormalY.z *= aSign.y;\n    tNormalZ.z *= aSign.z;\n    normal = s < table? normal : tableNorm;\n\n  normal = normalize(\n    tNormalX.zyx * normal.x +\n    tNormalY.xzy * normal.y +\n    tNormalZ.xyz * normal.z +\n    normal\n  );\n  shiny = s < table? shiny : 1.;\n  s = min(s, table);\n  return s;\n}\n\nfloat JustScene(vec3 p)\n{\n  float s = min(BowlDist(p), RiceDist(p));\n  s = min(s, ShrimpDist(p));\n  return min(s, TableDist(p));\n}\n// packing glossiness into w of nrm\nvec4 CastRay(vec3 ro, vec3 rd, out vec4 nrm) \n{\n  float d = 1.0;\n  const float maxDist = 50.0;\n  const float minDist = 0.001;\n  vec3 col;\n  for(int i = 0; i < 150; i++) \n  {\n    float dist = mapDistance(ro + rd * d, \n        nrm.xyz, col, nrm.w);\n    if (dist < abs(minDist) || d > maxDist) break;\n    d += dist;\n  }\n  col = d > maxDist ? vec3(-1.0) : col;\n  return vec4(d, col);\n}\n\nfloat Attenuate(const in vec3 dir, const in vec3 rd) \n{\n  float d = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 20; i++) \n  {\n    float dist = JustScene(dir + rd * d);\n    res = min(res, 20.0 * dist / d);\n    d += clamp(dist, 0.02, 0.10);\n    if (dist < precis || d > tmax) break;\n  }\n  return saturate(res);\n}\nvec4 Draw(const in vec3 dir, const in vec3 eyeVec) \n{\n  vec3 col;\n  float a = 0.;\n  vec4 nrm;\n  vec4 res = CastRay(dir, eyeVec, nrm);\n  if (res.y >= 0.0) \n  {\n    float shiny = nrm.w;\n    vec3 pos = dir + res.x * eyeVec;\n    vec3 lightDir = normalize(vec3(-0.6, 0.2, -0.4));\n    float atten = Attenuate(pos, lightDir);\n    vec3 albedo = res.yzw;\n    vec3 worldNormal = nrm.xyz;\n    vec3 refl = reflect(-lightDir, worldNormal);\n    float r = pow(max(dot(refl, -eyeVec), 0.), 1.5);\n    vec3 halfDir = normalize(lightDir - eyeVec);\n    float nDotH = smoothstep(0.7, 0.8, \n        dot(worldNormal, halfDir) * 0.5 + 0.5);\n    float nDotV = dot(worldNormal, -eyeVec) * 0.5 + 0.5;\n    float rimTerm = 1. - pow(nDotV, 2.);\n    // this is a hack, the hardened fresnel looks good\n    // on the bowl but bad on the table, and I'm\n    // writing 1. to shiny only if it is the table\n    if (shiny != 1.)\n    {    \n        rimTerm = smoothstep(0.5, 0.65, rimTerm);\n    }\n    float nDotL = (dot(worldNormal, lightDir) * 0.5 + 0.5) * atten;\n    nDotL = smoothstep(0.3, 0.5, nDotL);\n    vec3 diffuse = mix(SHADOW_COLOR, LIGHT_COLOR, nDotL);\n   \n    vec3 rim = rimTerm * diffuse * 0.75 * shiny;\n    vec3 specular = shiny * (nDotH + r) * LIGHT_COLOR * (albedo * 0.5);\n    col = albedo * (diffuse * 1.2 + rim);\n    col += specular;\n    a = 1.;\n  }\n  return vec4(saturate(col), a);\n}\n\nmat3 ViewMatrix(vec3 ro, vec3 ta)\n{\n  vec3 cw = normalize(ta - ro);\n  vec3 up = vec3(0., 1., 0.);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu,cw) );\n  return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  vec3 camRotation = ZOOM * vec3(\n      -5. * cos(mo.x), \n      0.5 + 3.0 * mo.y, \n      3.5);\n\n  if (iMouse.xy==vec2(0)) \n  {\n      camRotation = 0.45 * vec3(-3., 1., 2.5);\n  }\n\n  vec3 camPos = vec3(2.5, -1., -2.);\n\n  mat3 view = ViewMatrix(camRotation, camPos);\n  vec3 dir = view * normalize(vec3(p.xy, 2.0));\n  vec3 bg = mix(\n      vec3(0.4, 0.4, 0.5), \n      vec3(0.3, 0.1, 0.3), \n      dot(uv, vec2(0.7, 0.1)));\n  vec4 col = Draw(camRotation, dir);\n  fragColor = vec4(mix(bg, col.rgb, col.a), 1.0);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 179]], "test": "untested"}
{"id": "7dVXzw", "name": "MetaTorus autodiff 2O", "author": "cyperus", "description": "Implicit trace using a second order approximation for the distance. \nExact gradient/hessian is generated using a forward autodiff scheme. \nMove the camera by holding down the left mouse button and drag. ", "tags": ["distancefield", "spheretracing", "implicit", "curvature", "hessian", "autodiff", "automaticdifferentiation"], "likes": 26, "viewed": 823, "published": 3, "date": "1634441419", "time_retrieved": "2024-07-30T18:55:19.023511", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"MetaTorus autodiff 2O\" created by Colling Patrik (cyperus) in 2021\n//\n// BASED ON\n// - sibaku https://www.shadertoy.com/view/MdtXWM\n//          https://www.shadertoy.com/view/Nd3GRS\n//          https://github.com/sibaku/glsl-autodiff\n//\n// - iq     https://iquilezles.org/articles/intersectors\n//          iq https://www.shadertoy.com/view/3s33zj // adjugate matrix\n//\n// - cyperus https://www.shadertoy.com/view/wlBfzW\n//\n// DESCRIPTION:\n// - Testing implicit trace using a 2nd order approximation for the distance\n//   estimation.\n// - Exact gradient/hessian is generated using a forward autodiff scheme.\n// - Display surface normal and curvatures.\n//\n// TODO:\n//  (0) Fix correct shading of the near-slicing-face. \n//\n// CONTROLS:\n// <mouse>: change view direction\n// <up/down>: move camera to center\n// <page_up/page_down>: cycle through colormodes.\n//   0 cubemap\n//   1 ray march step iterations exp    [i<10, i ,i<i_max-10] -> [blue, gray, red]\n//   2 ray march step iterations linear [i<10, i ,i<i_max-10] -> [blue, gray, red]\n//   3 surface gradient length    [-inf, 0., +inf] -> [blue, white, red]\n//   4 surface normal orientation incoded as rgb-color \n//   5 gaussian curvature         [-inf, 0., +inf] -> [blue, white, red]\n//   6 mean curvature             [-inf, 0., +inf] -> [blue, white, red]\n//   7 principal_curvature-u      [-inf, 0., +inf] -> [cayen, black, yellow]\n//   8 principal_curvature-v      [-inf, 0., +inf] -> [cayen, black, yellow]\n// 's': toggle on/off shading\n// 'b': toggle on/off bounding sphere contour\n// 'f': toggle second/first order approximation\n// 'p': toggle eigenvalue estimate/frobenius norm\n//\n//********************************************************************\n//\n// Global defines\n//\n//********************************************************************\n\n// consts\n#define AUTO_INFINITY 3.402823e+38\n#define PI 3.14159265\n\n// application state defined by keyboard texture.\n#define useShading     ( !keytoggle(CHAR_S) )\n#define showBB         (  keytoggle(CHAR_B) )\n#define useFirstOrder  (  keytoggle(CHAR_F) )\n#define usePowerMethod (  keytoggle(CHAR_P) )\n\n// application state defined by buffered key values.\n#define subKeycount_DOWN_UP       ( keycount(KEY_DOWN)-keycount(KEY_UP) )\n#define subKeycount_PAGE_DOWN_UP  ( keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP) )\n\n// mouse state\n#define mouseInit ( iMouse == vec4(0.) )\n\n// animation\nconst float anim_velocity = 0.5;\n\n// camera\nconst float cam_dist = 10.0;\nconst float cam_fle  = 4.;\nconst float cam_tmin = 2.0;\nconst float cam_tmax = 1000.;\n\n// rayintersection\nconst float bb_size = 3.;\n\n// raymarch SDF\nconst float eps = 0.0005;\nconst int maxSteps = 150;\nconst float sl_mul = 1./sqrt(3.); // step length multiplier\n// color\nconst int num_colormode = 9;\n\n// SDF transformation level activation (comment in out)\n#define level1\n#define level2\n#define level3\n\n// SDF \nstruct surface {\n  //\n  float r0;     // float\n  #ifdef level1\n  float au10;   // float\n  float au11;   // float\n  float fracu1; // int in [1,2,3,..]\n  float pu1;\n\n  float twist1; // int in [...,-1,0,+1,...]\n  float fracv1; // int in [1,2,3,..]\n  float pv1;    // float\n  #endif\n  #ifdef level2\n  float au20;   // float\n  float au21;   // float\n  float fracu2; // int in [1,2,3,..]\n  float pu2;\n\n  float twist2; // int in [...,-1,0,+1,...]\n  float fracv2; // int in [1,2,3,..]\n  float pv2;    // float\n  #endif\n  \n  float au30;\n  #ifdef level3  \n  float au31;\n  float fracu3;\n  #endif\n};\n\n// SDF parametrisation\nvoid getsurface(out surface paras, in float time) {\n  // level0\n  paras.r0 = 4.; //paras.r0 *= sin( 0.5*iTime );\n  // level1\n  #ifdef level1\n  paras.au10 = 2.;  // float\n  paras.au11 = 1.;  // float\n  paras.fracu1 = 1.; // int in [1,2,3,..]\n  paras.pu1 = 0.5*time;\n \n  paras.twist1 = 1.; // int in [...,-1,0,+1,...]\n  paras.fracv1 = 2.; // int in [1,2,3,..]\n  paras.pv1 = 0.2*time;  // float\n  #endif\n  // level2\n  #ifdef level2\n  paras.au20 = -4.;  // float\n  paras.au21 =  4.;  // float\n  paras.fracu2 = 5.; // int in [1,2,3,..]\n  paras.pu2 = 0.5*time;\n  \n  paras.twist2 = 4.;   // int in [...,-1,0,+1,...]\n  paras.fracv2 = 2.;   // int in [1,2,3,..]\n  paras.pv2 = 0.*time; // float\n  #endif\n  // level3\n  paras.au30 = 3.;\n  #ifdef level3  \n  paras.au31 = cos(time);\n  paras.fracu3 = 3.;\n  #endif\n}\n\n// SDF implicit function f(x,y,z,paras)\nHNum3 implicit(in HNum3 x, in HNum3 y, in HNum3 z, in surface pa) {\n  /// level-0:\n  // torus\n  HNum3 au = a_atan2(x,z);\n  c_HNum3 z0 = c_HNum3( a_length(z, x), y);  \n  z0 = csub(cmul(z0, z0), c_HNum3(constH3(pa.r0), constH3(0.)));\n  \n  /// level-1:\n  #ifdef level1\n  HNum3 shift1   = add(pa.au10, mult(pa.au11, a_cos(add(mult(pa.fracu1, au), constH3(pa.pu1)))) );\n  HNum3 torsion1 = sub(mult(au, constH3(pa.twist1/pa.fracv1)), constH3(pa.pv1));\n  z0 = crpt(z0,torsion1, int(pa.fracv1), shift1);\n  #endif\n  \n  /// level-2:\n  #ifdef level2\n  HNum3 shift2   = add(pa.au20, mult(pa.au21, a_cos(add(mult(pa.fracu2, au), constH3(pa.pu2)))) );\n  HNum3 torsion2 = sub(mult(au, constH3(pa.twist2/pa.fracv2)), constH3(pa.pv2));\n  z0 = crpt(z0,torsion2, int(pa.fracv2), shift2);\n  #endif\n  \n  /// level-3:\n  #ifdef level3\n  HNum3 r3 = add( pa.au30, mult( pa.au31, a_cos(mult(pa.fracu3, au))));\n  #else\n  HNum3 r3 = constH3(pa.au30);\n  #endif\n  \n  return sub(a_length(z0.x , z0.y) ,r3);\n}\n\n// distance estimation\nfloat DE(in vec3 p, in surface paras) {\n  HNum3 result;\n  HESSIAN3(implicit, p.x, p.y, p.z, paras, result);\n\n  float g2 = dot(result.g, result.g);\n  float g = sqrt(g2);\n  float v = sl_mul * result.val;\n\n  // First order distance estimation\n  if (useFirstOrder) {\n    if (g < eps) return v;\n    else         return v / g;\n  } else {\n  // Second order uses any compatible matrix norm\n    // Default here is frobenius ->  fast and simple\n    // power method assumes the hessian to be symmetric to calculate spectral\n    // norm (should be for functions with continuous second order partials)\n    float m = usePowerMethod ? powerNorm(result.h): frobenius(result.h);\n\n    // Special cases for zero values\n    if (m < eps) {\n        if (g < eps) return v;\n        else              return v / g; }     \n    else\n        if (g < eps) return sqrt(2. * abs(v) / m) * sign(v);\n        else              return (sqrt(g2 / m / m + 2. * abs(v) / m) - g / m) * sign(v);\n  }\n}\n\n// ray march \nbool raymarch(in vec3 ro, in vec3 rd,\n              inout float t, in float tmax, in surface paras,\n              out float dist, out int steps) {      \n      steps = 0;\n      dist = 10.0;\n      vec3 pos;\n      float lastT = 0.;  \n      for (int i = 0; i < maxSteps; i++) {\n        pos = ro + t * rd;\n        float d = DE(pos, paras);\n        // hit surface\n        if (d < eps)        \n        {                              \n          dist = 0.;\n          t = lastT;\n          return true;\n        }\n        // update step\n        lastT = t;\n        t += d;\n        steps++;\n        // ray outside rang\n        if (t > tmax)\n          return false;\n      }\n      return false; // i >= maxSteps      \n}\n\n// normalized centered uv coordinates\nvec2 centerUV(in vec2 uv) {\n    return (2.0*uv-iResolution.xy)/iResolution.y;}\n\n// world => came coords\nvec3 transform(in vec3 p, in vec2 uv) {\n    if (mouseInit) uv = vec2(0.5, -0.3);\n    p.yz = crot(p.yz,  PI * uv.y);\n    p.zx = crot(p.zx, -PI * uv.x);\n\treturn p;}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  // global time\n  float time = anim_velocity*iTime;\n  \n  // animation parameters\n  surface paras;\n  getsurface(paras,time);\n  \n  //camera\n  float moveCame = 1.- 0.0666*float(subKeycount_DOWN_UP);\n  moveCame *= sign(moveCame)*moveCame; // 1/r²\n  vec2 uv_mouse = centerUV(iMouse.xy);\n  vec2 uv_pix   = centerUV(fragCoord);\n  vec3 ro = moveCame * transform(vec3(0.,0.,-cam_dist), uv_mouse);\n  vec3 rd = normalize(transform(vec3(uv_pix, cam_fle), uv_mouse));\n\n  // light\n  vec3 LPos = vec3(-2., -2., -cam_dist);\n  LPos = transform(LPos, uv_mouse);\n  \n  // ray\n  vec3 col ;      \n  float tmin = cam_tmin;\n  float tmax = cam_tmax;\n  // TODO_0:\n  //  - get camera-view-range near-surface-normal.\n  //  - initialize near-slicing-face-normal.\n  \n  // get bb-ray-range (bb boundingbox)\n  vec2 bb_t = isphere( ro, rd ,abs(bb_size));\n  // TODO 0: (for correct shading of the near-slicing-face)\n  //  - get BB near-surface-normal.\n \n  // check ray-range for raymarching\n  if( (bb_t.y > tmin) && (bb_t.x < tmax) ) {\n      // get new ray-range\n      tmin = max(tmin, bb_t.x);\n      tmax = min(tmax, bb_t.y);\n      // TODO_0:\n      //  - update near-slicing-face-normal;\n      \n      // raymarch inside bb\n      int steps;\n      float d;\n      float t = tmin; // ray length\n      if (raymarch(ro, rd, t, tmax, paras, d, steps)) {\n        // surface geometric properties\n        vec3 P = ro + t * rd;\n        HNum3 result = implicit(varH3x(P.x), varH3y(P.y), varH3z(P.z), paras);\n        vec3 N =  normalize(result.g);\n        // surface color\n        int iColorMode = abs(subKeycount_PAGE_DOWN_UP) % num_colormode;\n        col = (iColorMode == 0)? texture(iChannel1, reflect(rd,N)).xyz // reflection cubemap //  TODO 0: - use the near-slicing-face-normal.\n            : (iColorMode == 1)? colormapstep(steps, maxSteps, BLUE, RED, true)\n            : (iColorMode == 2)? colormapstep(steps, maxSteps, BLUE, RED, false)\n            : (iColorMode == 3)? colormap3(-sign(dot(rd, N)) * length(result.g) * 0.04, BLUE, WHITE, RED) // gradient length\n            : (iColorMode == 4)? 0.5*N +0.5 // normal orientation \n            : (iColorMode == 5)? colormap3(gaussian_curvature(result) * 4., BLUE, WHITE, RED)\n            : (iColorMode == 6)? colormap3(mean_curvature(result) * 4., BLUE, WHITE, RED)\n            : (iColorMode == 7)? colormap2(principal_curvature(result).x, CAYEN, YELLOW)\n            :                    colormap2(principal_curvature(result).y, CAYEN, YELLOW);\n        // shade\n        if (useShading) {\n            vec3 L = normalize(LPos - P);\n            // TODO_0:\n            //  - use the near-slicing-face-normal.\n            col *= max(dot(L, N), 0.) + 0.2;} }\n      else {\n         // background color inside bb\n         col = texture(iChannel1, rd).xyz; col *= col;// cubemap, gamma\n         if (showBB) col += vec3(smoothpuls(abs(bb_t.x - bb_t.y) -1.,0.25),0.,0.);}}\n  else{\n       // background color outside bb\n       col = texture(iChannel1, rd).xyz; col *= col;}// cubemap, gamma\n  // gamma\n  fragColor = vec4(sqrt(col), 1.);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// sibaku: forward-autodiff code from https://github.com/sibaku/glsl-autodiff\n#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\n\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\n\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\n\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\n\nHNum3 inv(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\n\n//HNum3 a_pow(in HNum3 a, in HNum3 b);\n//HNum3 a_pow(in HNum3 a, in float b);\n//HNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_ipow(in HNum3 x, in int n);\n\nHNum3 a_sqrt(in HNum3 a);\n//HNum3 a_inversesqrt(in HNum3 a);\n\nHNum3 a_exp(in HNum3 a);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\n\nHNum3 neg(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\n/*\nHNum3 a_floor(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\n\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\n*/\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\n//HNum3 a_acos(in HNum3 a);\n//HNum3 a_asin(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\n/*\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\n*/\n/*\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n*/\nHNum3 a_length2(in HNum3 x, in HNum3 y);\nHNum3 a_length2(in HNum3 x, in HNum3 y, in HNum3 z);\nHNum3 a_length(in HNum3 x, in HNum3 y);\nHNum3 a_length(in HNum3 x, in HNum3 y, in HNum3 z);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z, paras, result)  {\\\n    result = f(varH3x(x), varH3y(y), varH3z(z), paras);\\\n    }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\n\n//----------------------------------------------------------------\n// Implementation\n//----------------------------------------------------------------\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//----------------------------------------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//----------------------------------------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//----------------------------------------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + outerProduct(b.g,a.g) + outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//----------------------------------------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - outerProduct(b.g/b2, a.g)\n        - outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//----------------------------------------------------------------\n/*\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n*/\n//--------------------------------\nHNum3 a_ipow(in HNum3 x, in int n)\n{\n    // based on https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    if (n < 0)\n    {   \n        x = div(1.0,x);\n        n = -n;\n    }\n    if (n == 0) \n    {\n        return constH3(1.0);\n    }\n    HNum3 y = constH3(1.0);\n    while (n > 1)\n    {\n        if (n % 2 == 0)\n        {   \n            x = mult(x,x);\n            \n        }\n        else\n        {    \n            y = mult(x, y);\n            x = mult(x, x);\n        }\n\n        n = n / 2;\n    }\n    \n    return mult(x, y);\n}\n//----------------------------------------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\n/*\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n*/\n//----------------------------------------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//----------------------------------------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//----------------------------------------------------------------\n/*\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//----------------------------------------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n*/\n//----------------------------------------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));       \n}\n//--------------------------------\n/*\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n*/\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265;\n    \n    #if 0\n    // orginal version by sibaku \n    // tangent_half-angle_formula\n    // https://en.wikipedia.org/wiki/Atan2\n    const float epsi = 1E-6;\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));     \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > epsi)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n        return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= epsi)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0);\n    #else        \n    // version by ollj\n    // A compact expression with four overlapping half-planes\n    // https://en.wikipedia.org/wiki/Atan2#Definition_and_computation\n    if(x.val >0.) return a_atan(div(y,x));\n    if(y.val >0.) return  sub( constH3( pi*.5), a_atan(div(x,y)) );\n    if(0.>y.val ) return  sub( constH3(-pi*.5), a_atan(div(x,y)) );\n    if(0.>x.val ) return  add( pi   ,a_atan(div(y,x)));\n    return constH3(0.);\n    # endif\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//----------------------------------------------------------------\n/*\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * outerProduct(a.g,a.g));\n}\n*/\n//----------------------------------------------------------------\n/*\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n*/\n//----------------------------------------------------------------\nHNum3 a_length2(in HNum3 x, in HNum3 y)\n{\n  return add(mult(x, x), mult(y, y));\n}\n//--------------------------------\nHNum3 a_length2(in HNum3 x, in HNum3 y, in HNum3 z)\n{\n  return add(add(mult(x, x), mult(y, y)), mult(z, z));\n}\n//----------------------------------------------------------------\nHNum3 a_length(in HNum3 x, in HNum3 y)\n{\n  return a_sqrt(a_length2(x, y));\n}\n//--------------------------------\nHNum3 a_length(in HNum3 x, in HNum3 y, in HNum3 z)\n{\n  return a_sqrt(a_length2(x, y, z));\n}\n//----------------------------------------------------------------\n// Implementation prototypes\n//----------------------------------------------------------------\n#if __VERSION__<300\nmat3 outerProduct(in vec3 a, in vec3 b) {\n  return mat3(a * b[0], a * b[1], a * b[2]);\n}\n#endif\n\n//--------------------------------\n// complex Hessian Number in 3D-Space (added by cyperus)\n//--------------------------------\n// complex number operations in 3D-space :)\n\nstruct c_HNum3  {  // z = x + iy\n  HNum3 x; //real-part\n  HNum3 y; //complex-part\n};\n\n//--------------------------------\n\nc_HNum3 cadd(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 csub(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 cmul(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 cinv(in c_HNum3 z);\nc_HNum3 cdiv(in c_HNum3 za, in c_HNum3 zb);\nc_HNum3 cipow(in c_HNum3 z, in int n);\nc_HNum3 crot(in c_HNum3 z, in HNum3 a);\nc_HNum3 crpt(in c_HNum3 z, in HNum3 a, in int n, in HNum3 x0);\n\n//--------------------------------\n\nc_HNum3 cadd(in c_HNum3 za, in c_HNum3 zb) { // za + zb\n  return c_HNum3(add(za.x ,zb.x), add(za.y ,zb.y));\n}\n\nc_HNum3 csub(in c_HNum3 za, in c_HNum3 zb) {  // za - zb\n  return c_HNum3(sub(za.x ,zb.x), sub(za.y ,zb.y));\n}\n\nc_HNum3 cmul(in c_HNum3 za, in c_HNum3 zb) {  // za * zb\n  return c_HNum3(sub(mult(za.x ,zb.x), mult(za.y ,zb.y)),\n                add(mult(za.x ,zb.y), mult(za.y ,zb.x)));\n}\n\nc_HNum3 cinv(in c_HNum3 z) {  // 1/z\n  HNum3 denom = add(mult(z.x, z.x), mult(z.y, z.y));  \n  return c_HNum3(div(z.x, denom), div(neg(z.y), denom));\n}\n\nc_HNum3 cdiv(in c_HNum3 za, in c_HNum3 zb) {  // za/zb\n  return cmul(za,cinv(zb));\n}\n\nc_HNum3 cipow(in c_HNum3 z, in int n) { // z^n\n  c_HNum3 w = c_HNum3(constH3(1.), constH3(0.));\n  if ( n == 0) {\n    return w;}\n  if ( n < 0) {\n    z = cinv(z);\n    n = -n;}\n  for (int i = 0; i < n; i++) {\n    w = cmul(w,z);}\n  return w;\n}\n\nc_HNum3 crot(in c_HNum3 z, in HNum3 a) {  // z*e^(i*a)\n  return cmul(z, c_HNum3(a_cos(a), a_sin(a)));\n}\n\nc_HNum3 crpt(in c_HNum3 z, in HNum3 a, in int n, in HNum3 x0) { // (z*e^ia)^n-x0\n  return csub( cipow(crot(z, a), n), c_HNum3(neg(x0), constH3(0.)) );\n}\n//--------------------------------\n\nfloat frobenius(in mat3 m) {\n  return sqrt(dot(m[0], m[0]) + dot(m[1], m[1]) + dot(m[2], m[2]));\n}\n\n// Simple power iteration to find the eigenvalue with largest absolute value\nfloat powerNorm(in mat3 m) {\n  vec3 bk = vec3(1.);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  bk = normalize(m * bk);\n  return length(m * bk);\n}\n#endif // HESSNUM_3_H_\n\n// -----------------------------------\n// https://en.wikipedia.org/wiki/adjugate_matrix\nmat3 adjugate_m3(in mat3 m) {\n    #if 0\n    return mat3(\n    // c0\n     m[1][1]*m[2][2]-m[2][1]*m[1][2],\n     m[2][0]*m[1][2]-m[1][0]*m[2][2],\n     m[1][0]*m[2][1]-m[2][0]*m[1][1],\n    // c1 \n     m[2][1]*m[0][2]-m[0][1]*m[2][2],\n     m[0][0]*m[2][2]-m[2][0]*m[0][2],\n     m[0][1]*m[2][0]-m[0][0]*m[2][1],\n    // c2 \n     m[0][1]*m[1][2]-m[1][1]*m[0][2],\n     m[1][0]*m[0][2]-m[0][0]*m[1][2],\n     m[0][0]*m[1][1]-m[1][0]*m[0][1] );\n    #endif\n    #if 1\n    return mat3(\n    // by iq https://www.shadertoy.com/view/3s33zj\n     cross(m[1].xyz, m[2].xyz), \n     cross(m[2].xyz, m[0].xyz), \n     cross(m[0].xyz, m[1].xyz) );\n    #endif \n}\n\n// -----------------------------------\n// https://en.wikipedia.org/wiki/Gaussian_curvature\nfloat gaussian_curvature(HNum3 fx) {\n  // numerator of gaussian curvature for implicit surfaces\n  #if 0\n  // calculation with determinante\n  mat4 G = mat4(fx.h);\n  G[3].xyz = fx.g;\n  G[0][3] = fx.g[0];\n  G[1][3] = fx.g[1];\n  G[2][3] = fx.g[2];\n\n  G[3][3] = 0.0;\n\n  float gl2 = dot(fx.g, fx.g);\n\n  return -determinant(G) / (gl2 * gl2);\n  #else\n  // calculation with adjugate\n  float gl2 = dot(fx.g, fx.g);\n  return  dot(fx.g, adjugate_m3(fx.h) * fx.g) / (gl2 * gl2);\n  #endif\n}\n\n//--------------------------------\n// https://en.wikipedia.org/wiki/Mean_curvature\nfloat mean_curvature(HNum3 fx) {\n  float gl2 = dot(fx.g, fx.g);\n  float gl3 = gl2 * sqrt(gl2);\n  return ( dot(fx.g, fx.h * fx.g) - gl2 \n           * (fx.h[0][0]+fx.h[1][1]+fx.h[2][2]) ) / (2. * gl3);\n}\n\n//--------------------------------\n// TEST:\nvec2 principal_curvature(HNum3 fx) {\n  float km = mean_curvature(fx);\n  float kg = gaussian_curvature(fx);\n  float k = sqrt(km*km-kg);\n  return vec2(km+k, km-k); \n}\n\n//--------------------------------\nfloat smoothpuls(float x,float b){\n    return smoothstep(abs(b),0.,abs(x));\n    }\n//--------------------------------\nvec2 crot(vec2 z,float a){\n    float si = sin(a), co = cos(a); // z*e^(j*a)\n    return mat2(co,-si,si,co)*z;\n}\n\n//--------------------------------\nvec2 isphere(in vec3 ro, in vec3 rd, in float r ) {\n  // sphere centered at the origin, with size rd\n  float b = dot(ro,rd);\n  float c = dot(ro,ro) - r*r;\n  float h = b*b - c;\n\n  if( h<0.0 ) return vec2(-1.0);  \n  h = sqrt( h );  \n  return -b + vec2(-h,h);\n}\n\n//--------------------------------\nconst float PI_2 = acos(0.);\n    \nconst vec3 \n     BLUE = vec3(0.0, 66.0, 157.0)/ 255.0,\n     RED = vec3(147.0, 0.0, 58.0)/ 255.0,\n     CAYEN = vec3( 66.,245.,242.)/ 255.0,\n     YELLOW = vec3(245.,242., 66.)/ 255.0,\n     WHITE = vec3(200.0, 200.0, 200.0) / 255.0;\n\n    \nvec3 hsv2rgb (float h, float s, float v )\n{\n    return mix(vec3(1.), 0.5*(1.+cos(4.*PI_2*(h + vec3(0,1,2)/3. ))), s)*v;\n}    \n\nvec3 colormapBRG(float k) {\n    // k in [-inf, 0., +inf] => [blue, red, green]\n    k = atan(k)/PI_2;    \n    return hsv2rgb(-k/3., 0., 1.);\n}\n\nvec3 colormap2(float k, vec3 c0, vec3 c1) {\n    // k in [-inf, 0., +inf] => [c0, black, c1]\n    vec3 col = (k<0.)? c0:c1;\n    col *= abs(atan(k)/PI_2);\n    return col;\n}\n\nvec3 colormap3(float k, vec3 c0, vec3 c1, vec3 c2) {\n    // k in [-inf, 0., +inf] => [c0, c1, c2]\n    k = atan(k)/PI_2;\n    vec3 col;\n    if (k < 0.0) {\n      col = mix(c0, c1, smoothstep(-1., 0., k));\n    } else {\n      col = mix(c1, c2, smoothstep(0., +1., k));}\n    return col;\n}\n\nvec3 colormapstep(int i, int i_max, vec3 c0, vec3 c1, bool EXP) {\n    int b = 10; //\n    float k_dist = 10.;\n    float r = float(i)/float(i_max);    \n    if (EXP) r = 1.-exp(-k_dist * pow(r,2.));\n    \n    return (i <= b)       ? c0       // no step \n         : (i <= i_max-b) ? vec3(r)  // gray\n         :                  c1;      // max steps  \n}\n//--------------------------------\n\n#define store(i,j) ( texelFetch(iChannel2, ivec2((i),(j)),0) )\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n#define keytoggle(key) ( texelFetch(iChannel3, ivec2((key),2),0).x != 0.0 )\n#define keycount(key) ( int(store(0,(key)).x) )\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = store(i,j);\n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXzw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3645, 3668, 3719, 3731, 4468], [4470, 4510, 4577, 4603, 5487], [5489, 5512, 5551, 5551, 6473], [6475, 6489, 6635, 6635, 7192], [7194, 7232, 7259, 7259, 7310], [7312, 7336, 7375, 7375, 7498], [7500, 7500, 7555, 7573, 10596]], "test": "untested"}
{"id": "7sVXzw", "name": "Julia Investigation", "author": "oneshade", "description": "Inspired by 3Blue1Brown's video: [url=https://www.youtube.com/watch?v=LqbZpur38nw]https://www.youtube.com/watch?v=LqbZpur38nw[/url]", "tags": ["fractal", "juliaset", "cycles", "analysis", "3blue1brown"], "likes": 18, "viewed": 179, "published": 3, "date": "1634440833", "time_retrieved": "2024-07-30T18:55:19.770514", "image_code": "// https://www.desmos.com/calculator/tl1f1kcb1h\n\n// Red dots: fixed points\n// Blue dots: points cycling every two iterations\n// Pink dots: points that fall into fixed points\n// Green dots: points that fall into double cycles\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 3.0;\n    float unit = 6.0 / iResolution.y;\n\n    Complex z = uv;\n    Complex p = 0.6 * cexp(0.1 * iTime * i);\n    Complex c = csub(0.25, csqr(cadd(0.5, p)));//Complex(-0.196, -0.68) + 0.1 * cexp(0.5 * iTime * i) + Complex(-0.1, 0.15);\n\n    // Iterate function f(z) = z^2 + c (for z = uv)\n    float a = 0.0;\n    for (int iter=0; iter < 100; iter++) {\n        z = csqr(z) + c;\n        a += (c.im - z.im) / (length(z - c) + 0.001); // cross(normalize(z - c), vec2(1, 0))\n        if (cmod(z) > 2.0) break;\n    }\n\n    vec2 q = csqr(csqr(csqr(uv) + c) + c) + c;\n    vec3 color = 0.5 * (hue2rgb(0.01 * a) + cos(0.25 * a + iTime)) * exp(-0.1 * cmod(q));\n\n    // Iterate function f(z) = z^2 + c (for z = mouse)\n    if (iMouse.z > 0.0) {\n        z = (iMouse.xy - center) / iResolution.y * 3.0;\n        for (int iter=0; iter < 25; iter++) {\n            Complex zn = csqr(z) + c;\n            drawSDF(sdLine(uv, z, zn), vec3(0.0, 1.0, 0.0));\n            z = zn;\n        }\n    }\n\n    // Calculate fixed points (f(z) = z)\n    Complex u = csqrt(csub(0.25, c));\n    Complex fixed1 = cadd(0.5, u), fixed2 = csub(0.5, u);\n\n    // Draw fixed points\n    drawSDF(sdDisk(uv, fixed1, 0.04), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, fixed2, 0.04), vec3(1.0, 0.0, 0.0));\n\n    // Calculate double cycle points (f(f(z)) = z)\n    Complex v = csqrt(csub(-0.75, c));\n    Complex cycle21 = cadd(-0.5, v), cycle22 = csub(-0.5, v);\n\n    // Draw double cycle points\n    drawSDF(sdDisk(uv, cycle21, 0.04), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdDisk(uv, cycle22, 0.04), vec3(0.0, 0.0, 1.0));\n\n    // Points opposite the fixed points fall into the fixed points anyways\n    drawSDF(sdDisk(uv, -fixed1, 0.04), vec3(0.8, 0.0, 1.0));\n    drawSDF(sdDisk(uv, -fixed2, 0.04), vec3(0.8, 0.0, 1.0));\n\n    // Points opposite the double cycling points fall into them and start cycling\n    drawSDF(sdDisk(uv, -cycle21, 0.04), vec3(0.2, 1.0, 0.0));\n    drawSDF(sdDisk(uv, -cycle22, 0.04), vec3(0.2, 1.0, 0.0));\n\n    // Unfortunately triple cycle points can only be found by\n    // solving a 6th degree polynomial which isn't possible with\n    // only elementary functions (+, -, *, /, nthroot, sin, cos, tan, exp, etc.) :(\n    // I might try implementing a numerical solver but its rather tricky business\n\n    // (f(f(f(z))) - z) / (f(z) - z) =\n    // z^6 + z^5 + (3c + 1)z^4 + (2c + 1)z^3 + (3c^2 + 3c + 1)z^2 + (c^2 + 2c + 1)z + c^3 + 2c^2 + c + 1\n\n    fragColor += vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.0, 0.5));\n    render(fragColor, fragCoord + 1.0);\n    fragColor /= 4.0;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Complex Math Utilities - https://www.shadertoy.com/view/sst3WH\n\n// Joke of the day:\n// Complex numbers are real.\n\n// Constants\n#define pi 3.14159265359\n#define rho 1.57079632679\n#define tau 6.28318530718\n#define e 2.7182818284\n#define i Complex(0.0, 1.0)\n\n// Hue to RGB conversion (https://www.desmos.com/calculator/amac5m7utl)\nvec3 hue2rgb(in float hue) {\n    //return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n    //return smoothstep(0.0, 1.0, abs(2.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0)) - 1.0)) * 1.2;\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\n// -------------------------- Complex math --------------------------\n#define Complex vec2\n#define re x\n#define im y\n\n// Miscellaneous\nfloat carg(in Complex z) { return atan(z.im, z.re); }\nfloat cmod(in Complex z) { return length(z); }\nComplex cconj(in Complex z) { return Complex(z.re, -z.im); }\n\n// Elementary operations (+, -, *, /)\nComplex cadd(in Complex z, in Complex w) { return z + w; }\nComplex cadd(in Complex z, in float w) { return Complex(z.re + w, z.im); }\nComplex cadd(in float z, in Complex w) { return Complex(z + w.re, w.im); }\n\nComplex csub(in Complex z, in Complex w) { return z - w; }\nComplex csub(in Complex z, in float w) { return Complex(z.re - w, z.im); }\nComplex csub(in float z, in Complex w) { return Complex(z - w.re, -w.im); }\n\nComplex cmul(in Complex z, in Complex w) { return mat2(z, -z.im, z.re) * w; }\nComplex cmul(in Complex z, in float w) { return z * w; }\nComplex cmul(in float z, in Complex w) { return z * w; }\n\nComplex cinv(in Complex z) { return Complex(z.re, -z.im) / dot(z, z); }\nComplex cdiv(in Complex z, in Complex w) { return cmul(z, cinv(w)); }\nComplex cdiv(in Complex z, in float w) { return z / w; }\nComplex cdiv(in float z, in Complex w) { return z * cinv(w); }\n\n// Exponentials\nComplex cexp(in Complex z) { return exp(z.re) * Complex(cos(z.im), sin(z.im)); }\nComplex clog(in Complex z) { return Complex(0.5 * log(dot(z, z)), carg(z)); }\n\n// Powers\nComplex cpow(in Complex z, in Complex w) { return cexp(cmul(clog(z), w)); }\nComplex cpow(in float z, in Complex w) { return cexp(log(z) * w); }\nComplex cpow(in Complex z, in float w) {\n    float a = carg(z) * w;\n    return Complex(cos(a), sin(a)) * pow(dot(z, z), 0.5 * w);\n}\n\nComplex csqr(in Complex z) { return Complex(z.re * z.re - z.im * z.im, 2.0 * z.re * z.im); }\nComplex csqrt(in Complex z) {\n    Complex c = 0.5 * Complex(cmod(z), z.x);\n    return Complex(sqrt(c.re + c.im), sign(z.im) * sqrt(c.re - c.im));\n}\n\n// Hyperbolic functions\nComplex csinh(in Complex z) { return Complex(sinh(z.re) * cos(z.im), cosh(z.re) * sin(z.im)); }\nComplex ccosh(in Complex z) { return Complex(cosh(z.re) * cos(z.im), sinh(z.re) * sin(z.im)); }\nComplex ctanh(in Complex z) {\n    vec4 c = vec4(sinh(z.re), cosh(z.re), sin(z.im), cos(z.im));\n    return cdiv(c.xy * c.wz, c.yx * c.wz);\n}\n\n// Inverse hyperbolic functions\nComplex casinh(in Complex z) { return clog(z + cpow(cadd(cmul(z, z), 1.0), 0.5)); }\nComplex cacosh(in Complex z) { return clog(z + cpow(csub(cmul(z, z), 1.0), 0.5)); }\nComplex catanh(in Complex z) { return 0.5 * clog(cdiv(cadd(1.0, z), csub(1.0, z))); }\n\n// Trigonometric functions\nComplex csin(in Complex z) { return csinh(z.yx).yx; }\nComplex ccos(in Complex z) { return ccosh(Complex(z.im, -z.re)); }\nComplex ctan(in Complex z) {\n    vec4 c = vec4(sin(z.re), cos(z.re), sinh(z.im), cosh(z.im));\n    return cdiv(c.xy * c.wz, Complex(c.im, -c.re) * c.wz);\n}\n\n// Inverse trigonometric functions\nComplex casin(in Complex z) { return casinh(z.yx).yx; }\nComplex cacos(in Complex z) { return csub(rho, casin(z)); }\nComplex catan(in Complex z) { return catanh(z.yx).yx; }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 234, 282, 282, 314], [316, 316, 363, 363, 471], [553, 553, 607, 607, 3138], [3140, 3140, 3195, 3195, 3422]], "test": "untested"}
{"id": "NddSzl", "name": "Synthwave song (sound)", "author": "athibaul", "description": "Let's compose a synthwave song on GPU!", "tags": ["sound", "analog", "synth", "bass", "gpusound"], "likes": 137, "viewed": 6870, "published": 3, "date": "1634433043", "time_retrieved": "2024-07-30T18:55:20.706012", "image_code": "\nvec4 applyColor(vec4 c1, vec4 c2)\n{\n    vec3 col = mix(c1.rgb, c2.rgb, c2.a);\n    float alpha = 1. - (1.-c1.a) * (1.-c2.a);\n    \n    return vec4(col, alpha);\n}\n\n\nvec2 wheelPos(float time)\n{\n    // Angle of the wheels of the tape machine at given time\n    \n    float phase1 = phasePortamento(time, 0., 1.25, 0.5, 4.0);\n    float phase2 = phasePortamento(time, 0., 0.48, 0.5, 4.0);\n    \n    return TAU*vec2(phase1, phase2); \n}\n\n\nvec4 drawWheel(vec2 p, float theta0)\n{\n    // theta0 : angle of symmetry (TAU/3, TAU/4...)\n    float d = length(p) - 1.0; // disk\n    float theta = atan(p.y,p.x);\n    theta = theta0*round(theta/theta0);\n    p *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    \n    // Symmetric pattern\n    d = max(d, 0.2-length(p-vec2(0.62,0.0)));\n    \n    vec3 col = vec3(0.5);\n    float alpha = smoothstep(0.001,-0.001,d);\n    \n    return vec4(col, alpha);\n}\n\n\nfloat scoreTime()\n{\n    return iTime - 4.;\n}\nfloat drumTime()\n{\n    return iTime - 4. - 8.*beatdur;\n}\nfloat timeSinceKick()\n{\n    float t = drumTime();\n    return (t > 0.) ? mod(t, 2.*beatdur) : 20.;\n}\nfloat timeSinceSnare()\n{\n    float t = drumTime() - beatdur;\n    return (t > 0.) ? mod(t, 2.*beatdur) : 20.;\n}\n\n\n\nvec2 lensDistortion(vec2 p, float dist)\n{\n    return (dist > 0.) ? p * (1. + dist*length(p)) : p / (1. - dist*length(p));\n}\n\n\nvec3 sceneOne(vec2 p)\n{\n    float dist = 1.0*smoothstep(4.0,0.0,iTime);\n    // \"Acceleration effect\": distort picture on riser\n    float riserTime = (scoreTime() - 40.*beatdur)/(7.*beatdur);\n    riserTime = clamp(riserTime, 0., 1.);\n    dist += riserTime * (1.- 0.167/ (1.-riserTime));\n    p = lensDistortion(p, dist);\n\n    // Horizontal grid of magenta lines\n    \n    // Calculate projection onto floor plane\n    vec2 q = vec2(p.x/p.y, 1./p.y);\n    \n    // Animate depending on time\n    float offs = -0.2*iTime - phasePortamento(max(scoreTime(),0.), 1.0, 20.0, 40.*beatdur,47.*beatdur);\n    q.y += offs;\n    \n    // Find closest horizontal/vertical line\n    vec2 qh = vec2(q.x, round(q.y));\n    vec2 qv = vec2(round(q.x), q.y);\n    qh.y -= offs;\n    qv.y -= offs;\n    \n    // Reproject onto screen\n    vec2 ph = vec2(qh.x/qh.y, 1./qh.y);\n    vec2 pv = vec2(qv.x/qv.y, 1./qv.y);\n    \n    // Clamp vertically to lower half\n    ph.y = min(ph.y, 0.);\n    pv.y = min(pv.y, 0.);\n    \n    // Shade according to distance\n    float dh = length(p-ph);\n    float dv = length(p-pv);\n    vec3 col = vec3(0);\n    \n    float eps = 0.01;\n    dh = max(dh-0.1*eps*abs(qh.y),0.);\n    dv = max(dv-0.1*eps*abs(qv.y),0.);\n    \n    float intensity = 0.2 + exp(-8.*timeSinceKick());\n    \n    col += vec3(1., 0.1, 1.) * 0.001/(dh*dh+eps*eps) * intensity;\n    col += vec3(1., 0.1, 1.) * 0.001/(dv*dv+eps*eps) * intensity;\n    \n    //col = vec3(0.05) * abs(qv.y);\n    \n    \n    // Synthwave \"sun\"\n    \n    intensity = 1. + 5.*exp(-5.*timeSinceSnare());\n    float d = length(p - vec2(0,0.5)) - 0.62*0.5;\n    \n    float expo = min(1./abs(p.y),8.);\n    vec3 sunBase = vec3(2.,0.6,0.1);\n    vec3 sunCol = pow(sunBase, vec3(expo));\n    float occl = 0.5+0.5*sin(8./p.y - TAU*offs);\n    occl = max(occl - 0.5, 0.);\n    //occl = mix(occl, 1., 0.03);\n    occl = mix(occl, 1., smoothstep(0.3,0.8,p.y));\n    col += 1.5 * sunCol * smoothstep(0.02,0.0,d) * occl * intensity;\n    \n    // Add sun halo\n    col += 0.2 * sunBase * min(0.03/(d*d + 0.3*0.3), 1.) * intensity;\n    col += 0.2 * vec3(0.1,1.0,1.0) * smoothstep(0.,0.01,d) * 0.002/(d*d+0.005) * intensity;\n    \n    \n    // Arpeggio animation\n    \n    for(float i=0.; i < 17.; i++)\n    {\n        float timeSinceArpUp = mod(scoreTime() - i*0.125*beatdur, 4.*beatdur);\n        float timeSinceArpDown = mod(scoreTime() - 4.*beatdur + i*0.125*beatdur, 4.*beatdur);\n        float timeSinceNote = min(timeSinceArpUp, timeSinceArpDown);\n        timeSinceNote = (scoreTime() >= i*0.125*beatdur) ? timeSinceNote : 10.;\n        \n        intensity = 5.*exp(-10.*timeSinceNote) + exp(-8.*timeSinceNote);\n        \n        float d = length(p + vec2(1.62,-0.5) - vec2(0.,0.05*(i-8.))) - 0.01;\n        d = min(d, length(p + vec2(-1.62,-0.5) - vec2(0.,0.05*(i-8.))) - 0.01);\n        \n        col += intensity * smoothstep(0.01,0.0,d) * vec3(0.1,1.,1.) * 2.;\n        col += intensity * smoothstep(0.0,0.01,d) * vec3(0.1,1.,1.) * 0.001 / (d*d+0.01);\n    }\n    \n    \n    return col * smoothstep(1.0,4.0,iTime);\n    \n}\n\n\nfloat quinticInflectionCurve(float x)\n{\n    // Polynomial of degree 5 such that:\n    //  P(0) = 0 ;  P(1) = 0 ;\n    // P'(0) = 1 ; P'(1) = 0 ;\n    // P\"(0) = 0 ; P\"(1) = 0.\n    \n    // Its maximum is a bit below 0.2\n    \n    \n    return x*(1.-x) + x*x*(x-1.) + 2.*x*x*(x-1.)*(x-1.) - 3.*x*x*x*(x-1.)*(x-1.);\n}\n\nvec4 drawCar(vec2 p)\n{\n\n    // Curve of the main body \n    float hx = (p.x+0.25)/(1.3+0.25);\n    float h = quinticInflectionCurve(hx) * 0.6 + 0.5;\n    float alpha = step(-0.25,p.x) * smoothstep(0.,0.01, h - p.y) * step(p.x, 1.3) * step(0.1,p.y);\n    \n    // Back of the car\n    float hy = (p.y-0.1)/(0.5-0.1);\n    h = 0.2* hy * (1.-hy) + 1.3;\n    alpha = max(alpha, smoothstep(0.,0.01, h-p.x) * step(0.1,p.y) * step(p.y,0.5) * step(1.3,p.x));\n    \n    // Front of the car\n    hx = (p.x+1.35)/(-0.25+1.35);\n    h = 0.2 * (1. -(1.-hx)*(1.-hx)) + 0.3;\n    alpha = max(alpha, smoothstep(0.,0.01,h-p.y) * step(-1.35,p.x) * step(p.x,-0.25) * step(0.1,p.y));\n    // Carve out the intake\n    hy = (p.y-0.1)/(0.5-0.1);\n    h = -1.35 + 0.2*hy*(1.-hy);\n    alpha = min(alpha, smoothstep(0.,0.01,p.x-h));\n    // Front lower slope\n    hx = (p.x+1.1)/(-1.1+1.35);\n    h = 0.2 - 0.1*(1. - hx*hx);\n    alpha = min(alpha, 1. - smoothstep(0.,0.01,h-p.y) * step(p.x,-1.1));\n    // Back lower slope\n    hx = (p.x-1.)/(1.-1.3);\n    h = 0.15 - 0.05*(1. - hx*hx);\n    alpha = min(alpha, 1. - smoothstep(0.,0.01,h-p.y) * step(1.0,p.x));\n    \n    // Wheels\n    float d = length(p - vec2(-0.85,0.2)) - 0.2;\n    alpha = max(alpha, smoothstep(0.01,0.,d));\n    d = length(p - vec2(0.85,0.2)) - 0.2;\n    alpha = max(alpha, smoothstep(0.01,0.,d));\n    \n    vec3 col = vec3(0);\n    \n    // Side line\n    vec2 q = p;\n    q.x = clamp(q.x, -0.5, 0.6);\n    q.y = 0.2 + 0.2*smoothstep(-0.3,0.5,q.x);\n    d = length(q-p);\n    float intensity = pow(0.5 + 0.5*sin(TAU*p.x - 2.*iTime), 3.) + 0.1;\n    col += vec3(0.1,1,1) * 0.0001/(d*d + 0.00001) * smoothstep(-0.8,1.,p.x) * intensity;\n    // Headlights\n    hy = (p.y-0.3)/(0.5-0.3);\n    h = -1.1+0.4*hy*hy;\n    col += vec3(8) * smoothstep(0.32,0.33,p.y) * smoothstep(0.,0.01,h-p.x) * smoothstep(-0.95,-1.3,p.x);\n    // Backlights\n    hy = (p.y-0.1)/(0.5-0.1);\n    h = 0.1* hy * (1.-hy) + 1.3;\n    col += vec3(2,0.01,0.01) * smoothstep(0.,0.01,p.x-h) * smoothstep(0.35,0.36,p.y);\n    \n    return vec4(col, alpha);\n}\n\nvec3 sceneTwo(vec2 p)\n{\n    vec3 col = vec3(0.);\n\n    // Backdrop: setting sun\n    float intensity = exp(-5.*timeSinceSnare());\n    float d = length(p - vec2(-1.0,0.5)) - 0.62*0.5;\n    \n    float expo = min(1./abs(p.y),8.);\n    vec3 sunBase = vec3(2.,0.6,0.1);\n    vec3 sunCol = pow(sunBase, vec3(expo));\n    float occl = 0.5+0.5*sin(8./p.y + iTime);\n    occl = max(occl - 0.5, 0.);\n    //occl = mix(occl, 1., 0.03);\n    occl = mix(occl, 1., smoothstep(0.3,0.8,p.y));\n    col += 20. * sunCol * smoothstep(0.02,0.0,d) * occl;\n    \n    // Add sun halo\n    col += 2. * sunBase * min(0.03/(d*d + 0.3*0.3), 1.) * intensity;\n    \n    // Add sky\n    expo = 4./(p.y+1.03);\n    vec3 fogCol = 2.*pow(vec3(0.9,0.5,0.1), vec3(expo));\n    col += fogCol;\n    \n    // Add slight grid in the sky\n    vec2 q = 10.*vec2(p.x/(p.y+1.), 2./(p.y+1.));\n    vec2 qh = vec2(q.x, round(q.y)), qv = vec2(round(q.x-0.5*iTime)+0.5*iTime, q.y);\n    float dq = min(length(q-qh), length(q-qv));\n    intensity = exp(-8.*timeSinceKick());\n    col += 0.5*fogCol * smoothstep(0.1,0.0,dq) * smoothstep(-0.9,0.5,p.y) * (0.5+intensity);\n    \n    \n    // Background : add skyline\n    float bh = rand(round(p.x*10. - 2.*iTime));\n    float opacity = 0.8*step(p.y+1.,bh);\n    bh = rand(round(p.x*20. - 2.*iTime))*0.5 + 0.2;\n    opacity = max(opacity, 0.5*step(p.y+1.,bh));\n    col = (opacity > 0.) ? mix(fogCol, vec3(0), opacity) : col;\n    \n    \n    // Draw pretty car\n    vec4 car = drawCar(p + vec2(0,1));\n    \n    col = applyColor(vec4(col,1.), car).rgb;\n    \n    \n    // Add light poles (with bass rhythm)\n    float polePos = 8.*(mod(scoreTime() - 0.25*beatdur, 0.5*beatdur)/(0.5*beatdur) - 0.5);\n    col = mix(col, vec3(0), smoothstep(0.6,0.0,abs(p.x-polePos)));\n    \n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n    // Time varying pixel color\n    vec3 col = sceneOne(uv);\n    if(scoreTime() > 47.*beatdur)\n    {\n        // Fade from white to black on clap\n        float tClap = scoreTime() - 47.*beatdur;\n        col = vec3(10.)* exp(-8.*tClap) * smoothstep(1., 0., tClap);\n    }\n    if(scoreTime() > 48.*beatdur)\n    {\n        col = sceneTwo(uv);\n    }\n    \n\n    //col = applyColor(col, drawWheel(uv, TAU/4.));\n\n    // Output to screen\n    col.rgb = 1.-exp(-col.rgb); // Tonemap\n    col.rgb = pow(col.rgb, vec3(1./2.2));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "sound_code": "// See \"Common\" tab\n\n// For anyone interested, I have started a tutorial series \n// on how to make music like this\n// Making Music in Shadertoy - Episode 1 : Basics, Waveforms, and a Simple Tune\n// https://www.shadertoy.com/view/ssjyDD\n", "sound_inputs": [], "common_code": "// Notations :\n// t = absolute time in seconds\n// tb = time in beats\n// te = time in seconds since start of envelope\n\n#define TAU (2.*3.1415926)\n\n// ESin --- Exponentially-decaying sine wave\n//     f: frequency\n//     d: decay rate\n#define ESin(f,d) sin(TAU*(f)*t)*exp(-d*t)\n\n#define midiratio(x) exp2((x)/12.)\n#define midicps(x) (440.*midiratio((x)-69.))\n\nconst float bpm = 100.;\nconst float bps = bpm/60.; // beats per second\nconst float beatdur = 1./bps; // beat duration\n\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*vec2(noise(t*df),noise(-1000.-t*df));\n}\n\nfloat sweep(float t, float dur)\n{\n    // Exponential sweep from 20kHz to 20Hz in \"dur\" seconds\n    // Running freq: 20000*exp(-t/dt)\n    // freq=20 at t=dur  ==>  20 = 20000*exp(-dur/dt)\n    //                   ==>  exp(-dur/dt) = 1/1000\n    //                   ==>  -dur/dt = log(1/1000)\n    //                   ==>  dt = dur/log(1000)\n    float dt = dur/log(1e3);\n    float intfreq = 20000.*exp(-t/dt)*dt;\n    float phase = TAU*fract(intfreq);\n    float sig = sin(phase);\n    float env = step(0., t) * smoothstep(dur, 0.7*dur, t);\n    return sig*env*0.1;\n}\n\n\nfloat triBipolar(float x)\n{\n    // Triangle wave going from -1 to +1, starting at zero, 4-periodic.\n    return 1. - abs(2.-mod(x+1.,4.));\n}\n\n\nfloat triUnipolar(float x)\n{\n    // Triangle wave going from 0 to +1, starting at zero, 2-periodic.\n    return abs(1.-mod(x+1.,2.));\n}\n\nfloat fold(float x, float a, float b)\n{\n    // Force x to lie between a and b, \"bounce back\" when going too far.\n    return triUnipolar((x-a)/(b-a)) * (b-a) + a;\n}\n\n\nfloat curve(float x, float a, float b, float curvature)\n{\n    // When x is on the a-side, outputs 0\n    // When x is on the b-side, outputs 1\n    // When x is between a and b, interpolates.\n    // curvature = 0 -> linear interpolation\n    // Negative curvature gives lower values, positive gives higher values.\n    x = (x-a)/(b-a);\n    x = clamp(x, 0., 1.);\n    return pow(x, exp(-curvature));\n}\n\nfloat percEnv(float t, float atk, float rel, float cur)\n{\n    return curve(t, 0., atk, cur) * curve(t, atk+rel, atk, cur);\n}\n\nfloat rampIntegral(float x)\n{\n    // Integral of clamp(x,0.,1.).\n    // Used to calculate phase with portamento\n    return (x<=0.) ? 0. : (x < 1.) ? x*x*0.5 : x-0.5;\n}\n\nfloat phasePortamento(float t, float f1, float f2, float t1, float t2)\n{\n    // Integral of frequency of a note with portamento\n    // Transition lasts from t1 to t2, with initial frequency f1 and final frequency f2.\n    // freq(t) = f1 for t < t1\n    // ... = f2 for t > t2\n    // ... = linear interpolation in between\n    \n    \n    // Change of variable : x = (t-t1)/(t2-t1).\n    // dt = (t2-t1)*dx\n    // int freq(t) dt = int freq(t(x)) * (t2-t1) dx\n    // ... = int (f1 + saturate(x)*(f2-f1)) * (t2-t1) dx\n    // ... = f1*t + rampIntegral(x)*(t2-t1).\n    \n    float phase = rampIntegral((t-t1)/(t2-t1)) * (f2-f1) * (t2-t1) + f1*t;\n    phase = mod(phase, 1.);\n    return phase;\n}\n\n///////////////////////////////////\n////////////// SOUNDS /////////////\n///////////////////////////////////\n\n\nfloat lpfSaw3(float t, float f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    // https://www.shadertoy.com/view/wsGyWm\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\n\n//////////////////////////////////////\n////////////// INSTRUMENTS ///////////\n//////////////////////////////////////\n\nvec2 bassStab(float t, float te, float f)\n{\n    // \"Analog bass\" sound based on a filtered sawtooth wave\n    float fc = 100. + 18000.*exp(-53.*te);\n    float env = smoothstep(0.,0.001,te) * exp(-6.*te);\n    vec2 sig = vec2(0);\n    sig += vec2(1.) * lpfSaw3(t, f, fc, 1.);\n    sig += vec2(-1,1) * 0.2 * lpfSaw3(t - 0.05, f+1., fc, 1.); // Widen in stereo\n    return sig * env * 0.08;\n}\n\nfloat kick(float t, float te, float atk)\n{\n    float f0 = midicps(34.), df = 300., spd = 40.;\n    // Instantaneous frequency\n    float ifreq = f0 + df*exp(-te*spd);\n    // Integrate to obtain\n    float phase = TAU*f0*te + TAU*df/spd * (1.-exp(-te*spd));\n    float env = exp(-8.*te) + 2.5*exp(-100.*te);\n    env *= smoothstep(-1e-6,0.,te);\n    env *= (1. + 0.3*smoothstep(0.01,0.0,te)); // Enhance attack\n    float v = sin(phase) * env;\n    float click = noise(20000.*te) * smoothstep(0.,0.001,te) * smoothstep(0.01,0.001,te) * 0.8;\n    click += sweep(te, 0.005) * 2.;\n    v /= 1. + 0.3*abs(v);\n    v *= (1. + 4.*smoothstep(0.05,0.15,te)*smoothstep(0.2,0.1,te)); // Enhance tail\n    v += click; // Don't distort the click\n    return v * smoothstep(-1e-6,atk,te);\n}\n\nfloat snare(float t, float te, float atk)\n{\n    // Snare is \"body\" + \"white noise\" + \"click\"\n    float wnoise = noise(20000.*te) + coloredNoise(te, 6500.,1000.)*0.3;\n    float nenv = (exp(-5.*te) + exp(-30.*te)) * smoothstep(0.2,0.0,te) * 0.5;\n    \n    float spd = 50.;\n    float phase = TAU*180.*te + TAU*80./spd * (1.-exp(-te*spd));\n    float body = sin(phase) * 1.5 * smoothstep(0.,0.005,te) * smoothstep(0.05,0.,te);\n    float v = wnoise*nenv + body;\n    v = 0.5*v;\n    v /= 1. + abs(v);\n    \n    //float click = noise(20000.*t) * exp(-600.*t);\n    float click = sweep(te, 0.005);\n    //v += click * 2.;\n    \n    v *= smoothstep(-1e-6,atk,te);\n    v *= (1. + 0.3* smoothstep(0.01,0.0,te) + 0.2*smoothstep(0.05,0.2,te));\n    \n    return v;\n}\n\n\nvec2 tomDrum(float te, float f0, float df)\n{\n    float spd = 5.;\n    // Instantaneous frequency\n    float ifreq = f0 + df*exp(-te*spd);\n    // Integrate to obtain\n    float phase = f0*te + df/spd * (1.-exp(-te*spd));\n    \n    float env = smoothstep(0.,0.0005,te) * curve(te, 0.35, 0.0, -1.3);\n    float noiseEnv = smoothstep(0.,0.0005,te) * curve(te, 0.8, 0.0, -2.) * (1. + 5.*curve(te, 0.022,0.0,0.));\n    vec2 sig = vec2(0);\n    \n    sig += triBipolar(4.*phase) * env * 0.15;\n    vec2 noise = (coloredNoise2(te, 1000., 20000.) + coloredNoise2(te, 4500., 6000.));\n    \n    sig += (noise.xx + noise.yy)*0.7 * noiseEnv * 0.03;\n    sig /= 1. + abs(sig);\n    sig += noise.yx * smoothstep(0.,0.05,te) * curve(te, 2.0, 0.0, -2.5) * 0.02; // Fake echo\n    \n    return sig;\n}\n\nfloat hihat(float t, float te)\n{\n    float sig = coloredNoise(te, 7500., 4500.) + coloredNoise(te, 2000., 1800.) * 0.1;\n    //float env = smoothstep(0.0,0.0002,te) * (smoothstep(0.05,0.0,te) + 0.5*smoothstep(0.01,0.,te));\n    float env = smoothstep(0.0,0.0002,te) * (curve(te, 0.2,0.0,-2.) + 0.5*smoothstep(0.01,0.,te));\n    return sig * env;\n}\n\nvec2 clap(float t)\n{\n    // A \"clap\" sound effect\n    vec2 sig = vec2(0);\n    sig += (0.8*coloredNoise2(t, 1000., 800.) + 0.5*coloredNoise2(t, 3300.,3100.) + 0.4*coloredNoise2(t,8240.,8000.));\n    \n    sig *= smoothstep(0.,0.01,t) * (curve(t,1.0,0.03, -2.3) + 0.2*curve(t,5.0,0.1,-1.));\n    // Fast envelope \"stutter\" is at the root of the \"clap\" sound\n    sig *= mix(0.7, 0.5+0.5*sin(TAU*80.*t), smoothstep(0.06,0.03,t));\n    sig /= 1.+abs(sig); // Distort\n    \n    return sig;\n}\n\nvec2 sawLead(float t, float te, float f)\n{\n    vec2 sig = vec2(0);\n    te = max(te,0.);\n    float env = exp(-5.*te) * smoothstep(0.,0.01,te);\n    float fc0 = 2.*f;\n    float fc = fc0 + (10000.-fc0)*exp(-8.*te);\n    sig += lpfSaw3(t, f, fc, 1.);\n    sig += vec2(-1,1) * lpfSaw3(t-0.05, f+1.618, fc, 2.);\n    return sig * env * 0.1;\n}\n\nvec2 analogBrass(float t, float te, vec4 f)\n{\n    vec2 sig = vec2(0);\n    float fc = 800. + 8000. * curve(te, 0.,0.3,-1.) * curve(te,2.,0.3,-2.); // Quick swell\n    float env = smoothstep(0.,0.15,te); // Fade in only\n    \n    float amp = 1.;\n    for(float i=0.; i<3.; i++){\n        float dt = 0.06 * 0.05 * noise(t+5.62*i);\n        sig += vec2(1.0,0.0) * lpfSaw3(t+dt, f.z, fc, 1.5) * amp;\n        sig += vec2(0.8,0.6) * lpfSaw3(t+dt, f.x, fc, 1.5) * amp;\n        sig += vec2(0.6,0.8) * lpfSaw3(t+dt, f.y, fc, 1.5) * amp;\n        sig += vec2(0.0,1.0) * lpfSaw3(t+dt, f.w, fc, 1.5) * amp;\n        amp *= 0.7;\n    }\n    \n    vec2 warm = vec2(0);\n    warm += vec2(1.0,0.0) * sin(TAU*f.z*t + sin(TAU*f.z*t));\n    warm += vec2(0.8,0.6) * sin(TAU*f.x*t + sin(TAU*f.x*t));\n    warm += vec2(0.6,0.8) * sin(TAU*f.y*t + sin(TAU*f.y*t));\n    warm += vec2(0.0,1.0) * sin(TAU*f.w*t + sin(TAU*f.w*t));\n    \n    return sig * 0.05 + warm * 0.03;\n}\n\nvec2 fmLead(float te, float f1, float f2, float t1, float t2, float dur)\n{\n    // Lead synth sound\n    \n    // f1, f2, t1, t2 : portamento from f1 to f2 between time t1 and t2\n    \n    float phase = phasePortamento(te, f1, f2, t1, t2);\n    vec2 phase2 = phase + te*vec2(-1,1);\n    \n    // vibrato\n    float vibHz = 5.5;\n    float vibAmp = smoothstep(0.5,1.2,te);\n    float vibrato = sin(TAU*vibHz*te) * vibAmp;\n    phase += 0.06*0.2*f1 * vibrato/(TAU*vibHz);\n    \n    float env = smoothstep(0.,0.01,te) * (1.3 - 0.5*smoothstep(0.,0.1,te) + 0.1*vibrato) * smoothstep(dur,dur-0.1,te);\n    \n    float iom = 5500./max(f1,f2);\n    vec2 sig = vec2(0);\n    sig += 3.*sin(TAU*phase + sin(TAU*phase2));\n    sig += sin(TAU*phase*7. + (3.+vibrato)*sin(2.*TAU*phase2));\n    sig += sin(TAU*(phase2+2.*te) + iom*sin(TAU*phase2));\n    sig += sin(TAU*5000. + (5.+ vibrato)*sin(TAU*phase2.yx));\n    \n    return sig * env * 0.02;\n}\n\n\nvec2 shepardRiser(float t, float dt, float bandwidth)\n{\n    vec2 sig = vec2(0);\n    \n    for(float nn=30.; nn<100.; nn+=8.)\n    {\n        float midinote = nn + 15.*fract(t/dt);\n        float fc = midicps(midinote);\n        float df = bandwidth*fc;\n        sig += coloredNoise2(mod(t,dt), fc, df) * 0.01;\n    }\n    \n    return sig;\n}\n\nvec2 noiseRiseFall(float t, float dt)\n{\n    //float phase = smoothstep(0., dt, t) * dt;\n    float x = t/dt;\n    float phase = dt * x*x*x*(3.-2.25*x);\n    vec2 sig = coloredNoise2(phase, 7000., 10000.) * 0.1;\n    sig *= smoothstep(0., 0.01, t) * smoothstep(dt, dt-0.01, t);\n    return sig;\n}\n\nvec2 machineButtonClick(float t)\n{\n    float reson = sin(TAU*805.*t + sin(TAU*302.*t) + sin(TAU*419.*t)) + 0.5*sin(TAU*100.*t);\n    float noise = coloredNoise(t, 4393., 6000.) + 0.2*coloredNoise(t, 7000., 10000.);\n    \n    float sig = 0.;\n    float env = percEnv(t, 0.001, 0.03, -1.) * 0.01 + percEnv(t-0.021, 0.001, 0.03, -1.) * 0.015\n    + percEnv(t-0.045, 0.001, 0.04, -1.)*0.1 + percEnv(t-0.056, 0.001, 0.1, -1.)*0.15 + percEnv(t-0.09, 0.001, 0.3,-1.8) * 0.1;\n    \n    sig += (reson*0.1+noise) * env;\n    \n    return vec2(sig);\n}\n\nvec2 machineButtonClickVerb(float t)\n{\n    return machineButtonClick(t) + vec2(0.5,0)*machineButtonClick(t-0.0062) + vec2(0,0.3)*machineButtonClick(t-0.01);\n}\n\nvec2 crashCymbal(float t, float atk)\n{\n    float reson = sin(TAU*429.*t + 5.*sin(TAU*1120.*t) + 5.*sin(TAU*1812.*t));\n    vec2 sig = coloredNoise2(t, 7150., 10000.) + 0.1*reson*smoothstep(0.,0.05,t);\n    float env = curve(t, 15.0, 0.0,-3.) * curve(t, 0.0, 0.08, 1.);\n    env *= (1. + smoothstep(0.02,0.0,t) * 2.);\n    env *= (1. - smoothstep(0.0,0.05,t)*smoothstep(0.5,0.0,t) * 0.5);\n    env *= smoothstep(0., atk, t);\n    return sig * env * 0.2;\n}\n\nvec2 crashCymbalVerb(float t)\n{\n    vec2 sig = crashCymbal(t, 0.);\n    sig += crashCymbal(t-0.75*beatdur, 0.05).yx * 0.5;\n    sig += crashCymbal(t-1.50*beatdur, 0.10).xy * 0.25;\n    return sig;\n}\n\n\n\n///////////////////////////////////\n////////// PATTERNS ///////////////\n///////////////////////////////////\n\nvec2 drums(float t, float atk)\n{\n    // atk: zero, or greater for smoother signal attack.\n    vec2 v = vec2(0);\n    \n    float te = mod(t, beatdur * 2.);\n    v += kick(t, te, atk) * 0.1;\n    \n    te = mod(t-beatdur, 2.*beatdur);\n    v += snare(t, te, atk) * 0.25;\n    \n    te = mod(t, beatdur * 0.5);\n    float vel = 1. + mod(t,beatdur);\n    vec2 panHH = 1. + 0.5 * vec2(-1,1) * cos(TAU*t/(4.*beatdur));\n    v += hihat(t, te) * 0.03 * vel * panHH;\n    \n    return v * smoothstep(-1e-6,atk,t);\n}\n\nvec2 clapPattern(float t)\n{\n    vec2 v = vec2(0);\n    float te = mod(t-7.*beatdur, 8.*beatdur);\n    v += clap(te) * 0.25;\n    \n    return v * smoothstep(-1e-6,0.,t);\n}\n\nvec2 tomFill(float t)\n{\n    if(t < 0.5*beatdur || t > 3.*beatdur) return vec2(0);\n    \n    t = t - 0.5*beatdur;\n    float te = mod(t, 0.75*beatdur);\n    float num = floor(t / (0.75*beatdur));\n    float f0i = 0.;\n    float dfi = (200. - 20.*num)*2.;\n    \n    vec2 sig = vec2(0);\n    sig += tomDrum(te, f0i, dfi);\n    \n    return sig;\n}\n\nvec2 pentatonicArp(float t)\n{\n    if(t < 0.) return vec2(0);\n    float notedur = beatdur / 8.;\n    float te = mod(t, notedur);\n    float nthNote = floor(t / notedur);\n    vec2 sig = vec2(0);\n    for(float ni = 0.; ni < 8.; ni++) // Also play the tail of the previous notes\n    {\n        float nn = nthNote-ni;\n        // fold back after 16 notes\n        nn = fold(nn, 0., 16.);\n        float degree = mod(nn, 5.); // degree in pentatonic scale\n        float octave = floor(nn/5.);\n        float note = floor(12.*degree/5.+0.6); // midi note number in pentatonic scale\n        float midiNoteNum = 69. + 12.*octave + note;\n        float f = midicps(midiNoteNum);\n\n        float tei = te+notedur*ni;\n        vec2 sigi = sawLead(t, tei, f);\n        sigi *= smoothstep(notedur*8., notedur*7., tei); // fade out note to avoid clicks\n        sig += sigi;\n    }\n    return sig;\n}\n\nvec2 pentatonicArpVerb(float t)\n{\n    vec2 pan = (1. + 0.7*vec2(-1,1)*sin(0.7*TAU*t));\n    return pan * pentatonicArp(t) + vec2(0.7,0.3)*pentatonicArp(t-3./8.*beatdur-0.02)\n     - vec2(0.2,0.5)*pentatonicArp(t-4./8.*beatdur-0.05);\n}\n\nvec2 bassLine(float t)\n{\n    float notedur = 0.5*beatdur;\n    float te = mod(t, notedur);\n    float nthNote = floor(t/notedur);\n    nthNote = mod(nthNote + 1., 32.); // Start all chords one half note in advance\n    \n    float midiNoteNum = \n        (nthNote < 8.) ? 45. : // A\n        (nthNote < 16.) ? 43. : // G major\n        (nthNote < 28.) ? 48. : // C major\n        50.; // D\n    float freq = midicps(midiNoteNum);\n    \n    float pumping = smoothstep(0.,beatdur*0.5, mod(t,beatdur));\n    vec2 sig = vec2(0);\n    sig += bassStab(t, te, freq) * mix(1.,pumping,0.5) * 0.7;\n    sig += bassStab(t, te, freq/2.) * mix(1.,pumping,0.6) * 0.7;\n    \n    return sig;\n}\n\nvec2 brassPad(float t)\n{\n    float nthNote = floor(t/beatdur);\n    nthNote = mod(nthNote, 16.);\n    vec4 midiNoteNum =\n        (nthNote < 4.) ? vec4(60,62,64,69) : // A minor (+D)\n        (nthNote < 8.) ? vec4(59,62,67,69) : // G\n        (nthNote < 14.) ? vec4(60,62,64,67) : // C (+D)\n        vec4(60,62,65,69); // Dm7\n        \n    vec2 env_startend = \n        (nthNote < 4.) ? vec2(0,4) : \n        (nthNote < 8.) ? vec2(4,8) :\n        (nthNote < 14.) ? vec2(8,14) :\n        vec2(14,16);\n        \n    float te = mod(t, 16.*beatdur) - env_startend.x * beatdur;\n    float noteDur = (env_startend.y - env_startend.x) * beatdur;\n    float fadeout = smoothstep(noteDur, noteDur-0.2, te);\n    \n    vec4 freq = midicps(midiNoteNum);\n    \n    vec2 sig = analogBrass(t, te, freq);\n    sig *= fadeout;\n    \n    return sig;\n}\n\nvec2 brassPadVerb(float t)\n{\n    return brassPad(t) + 0.5*brassPad(t-0.1).yx + 0.2*brassPad(t-1.);\n}\n\nvec2 fmLeadPhrase(float t)\n{\n    if(t<0.) return vec2(0);\n    \n    t = mod(t, 32.*beatdur);\n    if(t < 28.*beatdur) t = mod(t, 16.*beatdur); // variation on second time\n    \n    float tb = t / beatdur;\n    \n    // Each note may contain one portamento\n    // Note data is (tb0, dur, midiNN1, midiNN2, beats until porta, porta duration in beats).\n    mat3x2 noteData = \n        (tb < 2.5) ? mat3x2(0.0, 2.5, 74, 76, 0.5, 0.1) : // D-E\n        (tb < 3.5) ? mat3x2(2.5, 1, 74, 72, 0.5, 0.2) :// D-C\n        (tb < 6.5) ? mat3x2(3.5, 3, 79, 79, 10, 10) : // G\n        (tb < 8.5) ? mat3x2(7.5, 1, 81, 83, 0.0, 0.05) : // B\n        (tb < 9.5) ? mat3x2(8.5, 1, 84, 83, 0.5, 0.2) : // C-B\n        (tb < 11.) ? mat3x2(9.5, 1.5, 76,76,10,10): // E\n        (tb < 11.5) ? mat3x2(11., 0.5, 77,79,0.0,0.1): // G\n        (tb < 12.5) ? mat3x2(11.5, 1., 77,77,10,10): // F\n        (tb < 13.5) ? mat3x2(12.5, 1., 76,76,10,10): // E\n        (tb < 15.) ? mat3x2(13.5, 1.5, 76,74,0.0,0.05): // E-D\n        (tb < 16.) ? mat3x2(15., 1., 72,72,10,10) : // C\n        // identical repeat until...\n        (tb < 29.5) ? mat3x2(27.5,2., 77,77,10,10) : // F (continued)\n        mat3x2(29.5, 1.7, 76,76,10,10) // E\n        ;\n    \n    \n    float t0 = noteData[0][0]*beatdur;\n    float te = t - t0;\n    float dur = noteData[0][1]*beatdur;\n    float f1 = midicps(noteData[1][0]);\n    float f2 = midicps(noteData[1][1]);\n    float t1 = noteData[2][0] * beatdur;\n    float t2 = t1 + noteData[2][1] * beatdur;\n    vec2 sig = fmLead(te, f1, f2, t1, t2, dur);\n    \n    return sig;\n}\n\nvec2 fmLeadPhraseVerb(float t)\n{\n    return fmLeadPhrase(t) + vec2(0.2,0.7) * fmLeadPhrase(t-beatdur+0.01) + vec2(0.5,0.1) * fmLeadPhrase(t-2.*beatdur-0.02);\n}\n\n\n/////////////////////////////////////\n//////////// SONG STRUCTURE /////////\n/////////////////////////////////////\n\nvec2 introSequence(float t)\n{\n    // arps intro\n    // +drums\n    // +brass\n    // +riser, tom fill\n    \n    float tb = t / beatdur;\n    \n    \n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n    float arpPump = 0.7*smoothstep(7.9,8.0,tb);\n    sig += pentatonicArpVerb(t) * 0.09 * mix(1.,pumping,arpPump);\n    \n    t -= 8.*beatdur;\n    vec2 drumSig = drums(t, 0.);\n    sig /= 1. + 3.*abs(drumSig); // Distort the signal according to the drums\n    sig += drumSig;\n    \n    \n    pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.3, te);\n    t -= 8.*beatdur;\n    sig += brassPadVerb(t) * 0.4 * mix(1.,pumping,0.9)  * curve(t, 0., 24., 0.5);\n    \n    t -= 24.*beatdur;\n    \n    sig += noiseRiseFall(t, 7.*beatdur) * 0.2;\n    // Play the first clap louder\n    pumping = smoothstep(0.05,0.,te) + smoothstep(0.05,0.3, te);\n    sig += clapPattern(t) * smoothstep(3.*beatdur,4.*beatdur,t) * (1. + 0.3*smoothstep(15.*beatdur, 8.*beatdur, t))\n     * mix(1., pumping, 0.3);\n    \n    t -= 4.*beatdur;\n    vec2 fill = tomFill(t);\n    sig /= 1.+2.*abs(fill); // Distort signal according to toms\n    sig += fill;\n    \n    return sig;\n}\n\n\nvec2 chorusPattern(float t)\n{\n    // Should be overlayed with intro sequence (t > 48.*beatdur)\n    \n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n    \n    sig += crashCymbalVerb(mod(t,32.*beatdur)) * 0.5 * mix(1., pumping, 0.5);\n    sig += fmLeadPhraseVerb(t) * mix(1.,pumping, 0.8) * 0.7;\n    sig += bassLine(t);\n    \n    return sig;\n}\n\nvec2 bootUp(float t)\n{\n    // Sequence of glitchy sounds\n    // like a tape loading up.\n    // Runs in 4 seconds\n    \n    vec2 sig = vec2(0);\n    \n    sig += machineButtonClickVerb(t-0.5);\n    \n    t -= 1.;\n    \n    float phase = rampIntegral(t / 3.) * 3.;\n    \n    vec2 sig1 = vec2(0);\n    sig1 += 0.1 * pentatonicArpVerb(phase);\n    sig1 += 0.02 * noise(5000.*phase);\n    sig1 *= smoothstep(0.,0.1,t) * smoothstep(3.0,2.999,t);\n    \n    sig += machineButtonClick(1.05*(t-2.9));\n    \n    return sig + sig1 * 0.5;\n}\n\n\nvec2 fullSong(float t)\n{\n    vec2 sig = vec2(0);\n    \n    if(0. < t)\n        sig += introSequence(t);\n    if (12.*4.*beatdur < t)\n    {\n        t -= 12.*4.*beatdur;\n        sig += chorusPattern(t);\n    }\n    \n    return sig;\n}\n\nvec2 mainSound( int samp, float t )\n{\n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n\n    \n    \n    sig += bootUp(t);\n    \n    t -= 4.;\n    \n    sig += fullSong(t);\n    \n    //sig /= 1. + 0.5 * abs(sig);\n    \n    \n    return sig;\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 160], [163, 163, 190, 251, 425], [428, 428, 466, 518, 883], [886, 886, 905, 905, 930], [931, 931, 949, 949, 987], [988, 988, 1011, 1011, 1087], [1088, 1088, 1112, 1112, 1198], [1202, 1202, 1243, 1243, 1325], [1328, 1328, 1351, 1351, 4341], [4344, 4344, 4383, 4559, 4653], [4655, 4655, 4677, 4709, 6679], [6681, 6681, 6704, 6704, 8434], [8438, 8438, 8495, 8545, 9154]], "test": "untested"}
{"id": "sdySzm", "name": "Twizzly Maze", "author": "SnoopethDuckDuck", "description": "Messy code", "tags": ["raymarching", "template", "artofcode"], "likes": 7, "viewed": 339, "published": 3, "date": "1634427995", "time_retrieved": "2024-07-30T18:55:21.546765", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 120\n#define MAX_DIST 10.\n#define SURF_DIST 0.001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\n// not in use atm\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float b = length(pow(sin(p),vec3(2.)));\n    float d =  b - 1.25 + .1 * cos(iTime);\n    return 1. * d;\n    // for cubey things:\n    //return b - 0.4;//1.2 + .1 * cos(iTime);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(iTime,cos(0.5 * iTime),0.5 * sin(0.2 * iTime));//vec3(iTime, 1.,iTime);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    float time = 0.4 * iTime;\n    vec3 rd = GetRayDir(uv, ro, ro + vec3(cos(time - 2. *3.1415 / 3.),0.,cos(time + 2. * 3.1415 / 3.)), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.5 *vec3(dif);\n      \n        float b = .5 + .5 * cos(iTime);\n        uv = fragCoord.xy / iResolution.xy;\n        col += 0.6 * texture(iChannel0,r / (.9 + n)).rgb;\n     \n        col.r += 0.2 * 0.7 + .3 * cos(3. * rf.x + n.x + p.x + iTime - 3.1415 / 2.);\n        col.g += 0.2 * 0.7 + .3 * cos(3. * rf.y + n.y + p.y + iTime);\n        col.b += 0.2 * 0.7 + .3 * cos(3. * rf.z + n.z + p.z + iTime + 3.1415 / 2.);\n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    //col.r =0.02;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdySzm.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1577, 1606, 1606, 1826], [1829, 1829, 1852, 1852, 2031], [2033, 2033, 2067, 2067, 2278], [2280, 2280, 2304, 2304, 2494], [2496, 2496, 2546, 2546, 2737], [2739, 2739, 2757, 2757, 2855], [2858, 2858, 2915, 2915, 4193]], "test": "untested"}
{"id": "NdKXRm", "name": "shader-web-background JS lib 3", "author": "morisil", "description": "Check mouse!  I tweaked a bit this older shader of mine\n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 5, "viewed": 309, "published": 3, "date": "1634426856", "time_retrieved": "2024-07-30T18:55:22.428407", "image_code": "// Fork of \"shader-web-background JS lib 2\" by morisil. https://shadertoy.com/view/fs3XDB\n// 2021-10-16 23:27:09\n\n// Fork of \"shader-web-background JS lib\" by morisil. https://shadertoy.com/view/wlKyR1\n// 2021-10-09 22:16:29\n\n/*\n  This shader is here to spread the news about JavaScript library:\n  \n  https://xemantic.github.io/shader-web-background/\n \n  It is designed to be compatible with Shadertoy while adding more\n  integration options and saving many once-per-frame computations.\n  Even complex shaders should work on almost any hardware. I wanted\n  to build a base, which would let me use shaders as part of my\n  regular web development process, to transform my future website\n  into more immersive experiences. Check the project on mobile and\n  how it is reacting to device orientation, parallax scrolling, etc.\n  \n  Note: Mouse movement will make feedback follow the cursor.  \n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, gl_FragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst float iFeedbackZoomRate         = .003;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .006;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 1.25;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .15;\nconst float iBlob1PowFactor           = 60.;\nconst float iBlob1ColorPulseSpeed     = .13;\nconst float iBlob2Radius              = .2;\nconst float iBlob2PowFactor           = 60.;\nconst float iBlob2ColorPulseSpeed     = .2;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = 1.7;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    vec2 iFeedbackZoomCenter = vec2(sin(iTime * .6), cos(iTime * .7)) * .2;\n    vec2 iDrawCenter = iFeedbackZoomCenter;\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.) \n    ) \n    * vec3(.7, .3, 1.);\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    )\n    * vec3(.7, .3, 1.);\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.rg - .5) * iFeedbackColorShiftImpact * vec2(sin(iTime * .2), cos(iTime * .3));\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n    stShift *= cos(drawAngle + drawDist * 2. + iTime * .5);\n\n    vec3 prevColor = repeatedTexture(iChannel0, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[892, 892, 947, 947, 1019]], "test": "untested"}
{"id": "7sVXzD", "name": "QuadTree Traversal [Reflection]", "author": "Yusef28", "description": "This quadtree traversal is simplified from my last commented verion: [url]https://www.shadertoy.com/view/7dVSRh[/url]\nbut then I went ahead and added reflections to it for only cells with scale == 2.\n\nMouse enabled!", "tags": ["reflection", "quadtree", "traverslao"], "likes": 17, "viewed": 345, "published": 3, "date": "1634422263", "time_retrieved": "2024-07-30T18:55:23.228269", "image_code": "#define pi acos(-1.)\n#define eps 3./iResolution.y\n#define MAX_LEVEL 6.\n#define FAR 40.\n#define reflectiveTileNum pow(2.,floor(mod(iTime/2.,MAX_LEVEL-1.)))*2.\n\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \nfloat rnd(vec2 st){\n    return fract(sin(dot(vec2(12.563,19.99),st)*19.)*9439.8);}\n    \nfloat drawPoint(vec2 uv, vec2 p, float r){\n     return 1.-smoothstep(r-eps, r+eps, length(uv - p));\n}\n\nfloat distLine(vec2 p, vec2 A, vec2 B){\n  vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    return smoothstep(r+eps, r-eps, distLine(uv,A,B));\n}\n\n// SHORTER, NEATER, BRANCHLESS, UNIQUE, SINGULAR PURPOSE\n// This map function returns the largest scaling factor for a given posision\n// the inverse of that is the cell size\nfloat map(vec2 p){\n  float s = 0.5, level = 1.; vec2 CP;\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    s *= 2.;\n    CP = abs( fract(p * s) - 0.5 );\n    //if we don't pass the random check, add max to index so we break\n    i += step( rnd(floor(p * s)), 0.5 ) * MAX_LEVEL;\n  }\n  return s;\n}\n\n//SINGULAR // return the minimum distance to an axis in the rd direction\nvec4 calcT(vec2 p, vec2 rd, vec2 delta){\n    float s = map(p);\n    vec2 t;\n    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x : ((ceil(p.x*s) - p.x*s)/s)*delta.x; \n    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y : ((ceil(p.y*s) - p.y*s)/s)*delta.y; \n    vec2 n = t.x < t.y ? vec2(1.,0.) * -sign(rd.x) : \n                         vec2(0.,1.) * -sign(rd.y) ;\n    \n    return vec4(min(t.x,t.y), s, n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n  uv*=2.;\n  \n  //get local uv scale\n  float s = map(uv);\n  vec2 CP = abs( fract(uv * s) - 0.5 );\n  \n  \n  //make scale 0 wherever the localUV would be an edge\n  //s *= (1.-step(0.5 - 0.002 * s, max(CP.x, CP.y)));\n  //set color to inverse of scale, the cell size at each uv\n  float f = sqrt(s)/(MAX_LEVEL);\n  vec3 col = clamp(vec3(f*f*f,f*f,f), 0., 1.);\n  col = mix(col,vec3(0.,0.,0.1)/max(CP.x, CP.y),float(s==reflectiveTileNum));\n  col *= (1.-step(0.5 - eps * s*1., max(CP.x, CP.y)));\n  \n // col /= ;\n  \n  vec2 ro = vec2(0.5), rd = vec2(-1.,0.);\n  rd *= rot(iTime/8.);\n  if(iMouse.z > 0.5) \n      rd = normalize((iMouse.xy*2.-iResolution.xy)*2./iResolution.y - ro);\n  //col = mix(col, vec3(0.,1.,0.), drawLine(uv,ro,ro+rd*8.,0.01));\n  vec2 delta = 1./max(abs(rd), eps);\n  float t = calcT(ro + rd * .01, rd, delta).x;\n  col = mix(col, vec3(0.,1.,0.), 1.-step(0.03,length(uv-ro)));\n  col = mix(col, vec3(0.,1.,0.), drawLine(uv,ro,ro+rd*t,0.01));\n  //ro += rd * t;\n  \n  //the tricky part of this algorithm as I have it is\n  //I collect t, scale and normal in t_s_n\n  //but the scale is for cell of the current position\n  //the normal is for the cell that we will hit\n  //so for each iteration I have to use the normal found in\n  //the previous interation to because that becomes the normal\n  //as we hit it, which allows for calculating the reflected ray\n  //if we need to reflect\n  vec4 t_s_n; vec2 n;\n  for(float i = 0.; i < FAR; i++){\n  \n    //get t,scale and normal all at once\n    t_s_n = calcT(ro+rd*0.01, rd, delta);\n    \n    //if the scale of the current cell the ro is on is 2,\n    //don't advance the ray, just calculate a relfected ray\n    //and a new delta for that ray, \n    //optionally nudge the ro out in the direction of the normal\n    if(t_s_n.y == reflectiveTileNum) { \n        rd = reflect(rd,n); \n        delta = 1./max(abs(rd), eps);\n        //ro += n*0.01;\n        }\n    \n    //if we hit any other cell, we advance the ray to that cell\n    //and draw the line from oldRo to new o\n    else{\n        vec2 oldRo = ro;\n        ro += rd * t_s_n.x*1.001;\n        col = mix(col, vec3(0.,.8,1.), drawLine(uv,oldRo,ro,0.015));\n        }\n        \n    //save the normal we just approached to use in the nect\n    //iteration\n    n = t_s_n.zw;\n    //draw our hit point\n    col = mix(col, vec3(1.,0.,0.), 1.-step(0.03,length(uv-ro)));\n    }\n\n    col = pow(col,vec3(0.7));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 178, 178, 236], [242, 242, 261, 261, 324], [330, 330, 372, 372, 431], [433, 433, 472, 472, 589], [591, 591, 640, 640, 697], [699, 873, 891, 891, 1160], [1162, 1235, 1275, 1275, 1650], [1653, 1653, 1710, 1761, 4253]], "test": "untested"}
{"id": "NsVSRw", "name": "Animated Phyllotaxis 2D ", "author": "mvaios", "description": "First attempt to visualize an animated phyllotaxis arrangement using shader.", "tags": ["colors", "animated", "phyllotaxis"], "likes": 4, "viewed": 324, "published": 3, "date": "1634415697", "time_retrieved": "2024-07-30T18:55:24.068023", "image_code": "// First attempt to visualize a phyllotaxis arrangement using shader.\n// I am a beginner with the shaders, so the code might not be very optimal.\n\n// A tshirt and probably a mug with this design will be available in my store soon. \n// Feel free to check it out here:\n// https://threadhub.store/products/phyllotaxis-t-shirt\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x = uv.x * ratio + (iResolution.y - iResolution.x)/iResolution.y / 2.;\n    float time = iTime + 1.;\n    float c = 0.025;\n    vec2 center = vec2(0.5, 0.5);\n    vec2 _uv = uv - center;\n    float minDiff = 1.;\n    float index = 0.;\n    for(float i = 0.; i < 400.; i++) {\n        float angle = 137.5 * (i + (i / 2300.) * iTime / 20.);\n        float radius = c * sqrt(i);\n        float x = radius * cos(angle);\n        float y = radius * sin(angle);\n        \n        vec2 pos = vec2(x, y);\n        float diff = abs(distance(pos, _uv)) * 60.;\n        \n        if(diff < minDiff) {\n            minDiff = diff;\n            index = i + 1.;\n        }\n    }\n    \n    minDiff = smoothstep(0., .5, minDiff);\n    minDiff = minDiff * minDiff;\n    minDiff = 1. - minDiff;\n    float changeRate = .05;\n    float r = minDiff * (sin((time * 1. * index) * changeRate) + 1.);\n    float g = minDiff * (sin((time * 2. * index) * changeRate) + 1.);\n    float b = minDiff * (sin((time * 3. * index) * changeRate) + 1.);\n\n    fragColor = vec4(r, g, b, 1);\n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 381, 381, 1520]], "test": "untested"}
{"id": "NsdSDf", "name": "portalx", "author": "Sergeindamix", "description": "animated mask", "tags": ["mask", "transform"], "likes": 3, "viewed": 282, "published": 3, "date": "1634412788", "time_retrieved": "2024-07-30T18:55:25.214957", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}\n\n\n\nfloat sdfPlanet(vec3 p,float r){\n    return length(p)-r;\n}\n\nfloat map(vec3 p){\n    mat2 rot=Rot(iTime*.08);\n    \n    vec3 bp=p;\n    bp.xz*=rot;\n    \n    float d=sdfPlanet(bp,.4);\n    d+=texture(iChannel2,bp.xy*3.).r*.015;\n    return d;\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    d=map(p);//length(p)-10.5;\n    /*vec2 uv = vec2(atan(p.x, p.z)/6.2832, p.y/3.)+.5;\n    float disp = texture(iChannel0, uv).r;\n    \n    disp *= smoothstep(1.4, 1., abs(p.y));\n    d -= disp*.3;*/\n    \n    return d=map(p);\n}\n\nvec3 Transform(vec3 p) {\n     /*p.xy *= Rot(iTime*.4);\n     p.xz *= Rot(iTime*.2);*/\n     p.xz*=Rot(T*.2);\n     p.xy*=Rot(T*.1);\n     p.yz*=Rot(T*.15);\n     \n     return p;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = Transform(ro + rd*dO);    \t\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat stars(vec2 uv,float time){\n    vec2 fuv=fract(uv*20.);\n    vec2 fluv=floor(uv*40.);\n    float res;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 offs=vec2(x,y);\n            float r=rand(fluv+offs);\n            float l=length(fuv-offs-r);\n            float d=(.02*r*r/l);\n            d=smoothstep(.01,1.,d);\n            res+=d*((1.-sin(r*r*time*2.)));\n            res-=max(uv.y-uv.x-.5,0.);\n        }\n    }\n    return clamp(res,.01,1.);\n}\n\nvec3 lights(vec3 n, vec2 fragCoord, vec2 uv, vec3 col)\n{\n    mat2 rot=Rot(iTime*.08);\n    // Lighting\n    n.xz*=inverse(rot);\n    \n    vec3 light=vec3(.5);\n    vec3 sun_lig=normalize(vec3(-.5,.45,-.3));\n    float sun_dif=clamp(dot(n,sun_lig),0.,1.);\n    light+=sun_dif*vec3(.6,.6,.6);\n    \n    vec3 sky_lig=normalize(vec3(0.,.5*n.y+.5,0.));\n    float sky_dif=clamp(dot(n,sky_lig),0.,1.);\n    light+=sky_dif*vec3(.3,.05,.01);\n    \n    vec3 planet_lig=normalize(vec3(-.05,.03,.4));\n    float planet_dif=smoothstep(.9,1.,clamp(dot(n,planet_lig),0.,1.))*4.;\n    light+=planet_dif*vec3(.2,1.,1.);//+n*-0.1;\n    \n    col*=light;\n    vec2 pv=fragCoord/iResolution.xy;\n    vec3 curve=texture(iChannel1,pv).rgb;\n    col+=curve;\n    \n    uv-=vec2(-.58,.35);\n    vec2 bfuv=abs(uv*mat2(2.5,0,1.4,1.7))*mat2(2,sin(iTime)*.2-2.,sin(iTime)*.4-.5,1.5);\n    float bright_flare=.1/max(bfuv.x,bfuv.y)*smoothstep(-.7,1.,uv.x);\n    \n    col+=bright_flare*1.*vec3(.8,.9,.6);\n    return col;\n    }\n    \n    // The constant Pi.\nfloat pi = 3.14159;\n\n// Sphere radius, relative.\nfloat radius_rel = 0.45;\n\n// Sphere centre, relative.\nvec2 centre_rel = vec2(0.5, 0.5);\n\n// Sphere rotation speed, rpm.\nfloat rot_vel = 5.0;\n\nvec4 circle(out vec4 color, in vec2 coord)\n{\n    // Sphere radius, px.\n    float radius = radius_rel * min(iResolution.x, iResolution.y);\n    \n    // Sphere centre, px.\n    vec2 centre = centre_rel * iResolution.xy;\n    \n    // Screen coordinates relative to sphere centre.\n    vec2 coord_rel = coord - centre;\n    \n    // Relative screen coordinates normalised to [-1, 1].\n    vec2 coord_rel_norm = coord_rel / radius;\n    \n    // Relative and normalised screen coordinates squared.\n    vec2 coord_rel_norm_sq = coord_rel_norm * coord_rel_norm;\n\t\n    // Output black if screen coordinates outside sphere.\n    if (coord_rel_norm_sq.x + coord_rel_norm_sq.y > 1.0)\n    {    \n\t\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    \treturn color;\n    }\n    \n    // Ratio between parallel radius and sphere radius.\n    float radius_ratio = cos(asin(coord_rel_norm.y));\n\t\n    // Texture coordinates for these screen coordinates.\n    vec2 coord_tex = 0.5 + vec2(\n        asin(coord_rel_norm.x / radius_ratio),\n        asin(coord_rel_norm.y)) / pi;\n\t\n    // Rotate sphere according to elapsed time.\n    //coord_tex.x -= rot_vel * iTime / 30.0;\n    \n\t// Output color at these texture coordinates.\n    color = texture(iChannel0, coord_tex);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0, -50.+fract(mix(10.,10.1, T))*100.);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    //ro= Transform(ro);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    uv = fragCoord/iResolution.xy;//\n    vec3 col = texture(iChannel2, uv).xyz;//vec3(0);\n    {\n    uv = fragCoord/iResolution.xy;\n    vec3 col1 = texture(iChannel0, uv).xyz;\n    vec3 col2 = texture(iChannel1, uv).xyz;\n    }\n    float d = RayMarch(ro, rd);\n    vec3 p = Transform(ro + rd * d);\n    vec3 n = GetNormal(p);\n    if(d<MAX_DIST) {\n        \n        \n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n\n        //6 faces texturing\n        vec3 colXZ = circle(  fragColor,  fragCoord ).rgb;//texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colYZ = circle(  fragColor,  fragCoord ).rgb;//texture(iChannel0, p.yz*.5+.5).rgb;\n        vec3 colXY = circle(  fragColor,  fragCoord ).rgb;//texture(iChannel0, p.xy*.5+.5).rgb;\n        \n        n = abs(n);\n        \n        \n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n        \n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    }else{\n        uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n        col+=stars(uv,iTime)*1.;\n    }\n    \n    col = lights(n, fragCoord, uv, col);\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float det=.001,t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 path(float t)\n    {\n    vec3 p=vec3(vec2(sin(t*.1),cos(t*.05))*10.,t);\n    p.x+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\n    return p;\n}\n\nfloat fractal(vec2 p)\n{\n    p=abs(5.-mod(p*.2,10.))-5.;\n    float ot=1000.;\n    for (int i=0; i<7; i++)\n    {\n        p=abs(p)/clamp(p.x*p.y,.25,2.)-1.;\n        if(i>0)ot=min(ot,abs(p.x)+.7*fract(abs(p.y)*.05+t*.05+float(i)*.3));\n        \n    }\n    ot=exp(-10.*ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c=abs(p)-l;\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat de(vec3 p)\n{\n    boxhit=0.;\n    vec3 p2=p-adv;\n    p2.xz*=rot(t*.2);\n    p2.xy*=rot(t*.1);\n    p2.yz*=rot(t*.15);\n    float b=box(p2,vec3(1.));\n    p.xy-=path(p.z).xy;\n    float s=sign(p.y);\n    p.y=-abs(p.y)-3.;\n    p.z=mod(p.z,20.)-10.;\n    for (int i=0; i<5; i++)\n    {\n        p=abs(p)-1.;\n        p.xz*=rot(radians(s*-45.));\n        p.yz*=rot(radians(90.));\n    }\n    float f=-box(p,vec3(5.,5.,10.));\n    float d=min(f,b);\n    if (d==b) boxp=p2, boxhit=1.;\n    return d*.7;\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 p,n,g=vec3(0.);\n    float d, td=0.;\n    for (int i=0; i<80; i++)\n    {\n        p=from+td*dir;\n        d=de(p)*(1.-hash(gl_FragCoord.xy+t)*.3);\n        if (d<det && boxhit<.5) break;\n        td+=max(det,abs(d));\n        float f=fractal(p.xy)+fractal(p.xz)+fractal(p.yz);\n        //boxp*=.5;\n        float b=fractal(boxp.xy)+fractal(boxp.xz)+fractal(boxp.yz);\n        vec3 colf=vec3(f*f,f,f*f*f);\n        vec3 colb=vec3(b+.1,b*b+.05,0.);\n        g+=colf/(3.+d*d*2.)*exp(-.0015*td*td)*step(5.,td)/2.*(1.-boxhit);\n        g+=colb/(10.+d*d*20.)*boxhit*.5;\n    }\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up) \n{\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    t=iTime*7.;\n    vec3 from=path(t);\n    adv=path(t+6.+sin(t*.1)*3.);\n    vec3 dir=normalize(vec3(uv,.7));\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from, dir);\n    fragColor=vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "/*\n\n  Video Transitions by Mark Craig (Copyright © 2021)\n\n    I originally wrote this as a \"filter\" to create transition frames\n  for videos (C program which outputted PPM files).  But eventually,\n  I figured it could be relatively easily ported to GLSL - this is the\n  result.\n\n*/\n\nint n = 50;            // number of \"frames\" in transition\nfloat sa = .05;        // smooth amount - size of smooth edges\nbool roto = true;      // if true, rotate transitions that can optionally rotate\nfloat rota = 360.0;    // amount of rotation from start to end of transition\nint rn = 1, rd = 0;    // select based on whether to start with full\n//int rn = 0, rd = -1; //   frame of source1 (only for some transitions)\n\n#define SPEEDADJ .75\n//#define NEEDMOD 1\n\n#define imod(a,b) (int((float(a)-(float(b)*floor(float(a)/float(b))))))\n\n#define iGlobalTime (iTime / SPEEDADJ)\n\n#define num_transitions 33\n\n// macros for selecting/mixing the textures\n\n#define MEM2 col = alt ? col1 : col2;\n#define MEM1 col = alt ? col2 : col1;\n#define MEM12 col = alt ? v1 * col2 + v2 * col1 : v1 * col1 + v2 * col2;\n#define MEM1S { col = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\n// Solve some incompatibilities\n\n#define atan2 atan\n#define fmod mod\n#define texture2D texture\n\n// Useful values\n\n#define _TWOPI 6.283185307\n#define M_PI 3.141592654\n\nfloat intersect(vec2, vec2, vec2, vec2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / iResolution.xy, uv2;\nbool alt = false;\nint type, i, i2, j;\nvec3 col, col3;\nfloat v1, v2;\nfloat ye, yfe, dx, dy, cx, cy, rad, slope, theta, xc1, yc1, b, rad0, rad2;\nfloat xc2, yc2, b2, cx2, cy2, r1, vy1, vy2, dx2, dy2, ro, ri, ang, a, a1;\nfloat r, r2, l, l2, theta2, theta3, tang, ang1, ang2, angt, angs, c1, s1;\nfloat xc0, yc0;\nvec2 p1, p2, po, pd;\n\nfloat aspect = iResolution.y / iResolution.x;\nvec3 col1 = texture2D(iChannel0, uv).xyz;\nvec3 col2 = texture2D(iChannel1, uv).xyz;\n#ifdef NEEDMOD\ni = imod(int(iGlobalTime * 20.0) , n);\ntype = imod((int(iGlobalTime * 20.0) / n) , num_transitions);\nif (imod(type , 2)== 1) { alt = true; } else { alt = false; }\n#else\ni = int(iGlobalTime * 20.0) % n;\ntype = (int(iGlobalTime * 20.0) / n) % num_transitions;\nif (type % 2 == 1) { alt = true; } else { alt = false; }\n#endif\n\nswitch (type)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tcol1 = texture2D(iChannel2, uv).xyz;\n                    col2 = texture2D(iChannel3, uv).xyz;\n\t\t\t\t\tbreak;\n                default:\n\t\t\t\t\tcol1 = texture2D(iChannel0, uv).xyz;\n                    col2 = texture2D(iChannel1, uv).xyz;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//type = 32;\n\n// some of these equations are long, so I'll forego extra spaces\n\n// was a switch, but some GPUs won't do switch\n\n\t\tif (type==0) // fade in/out\n\t\t\t{\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tMEM12\n\t\t\t}\n\t\telse if (type==1) // window down with soft edge\n\t\t\t{\n\t\t\tye=1.0-float(i)/float(n-1);\n\t\t\tyfe=ye+sa;\n\t\t\tif (uv.y<=ye) MEM1\n\t\t\telse if (uv.y>yfe) MEM2\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv2=float(uv.y-ye)/sa; if (v2>1.0) { v2=1.0; } v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==2) // increasing box\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==3) // increasing diamond\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM1\n\t\t\telse if (dy>slope*dx+cy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==4) // increasing circle\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tif (sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy))>rad) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==5) // increasing and decreasing diamonds\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM2\n\t\t\telse if (dy>slope*dx+cy) MEM2\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\t}\n\t\telse if (type==6) // four corner vanish\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>cx-dx)&&(uv.x<cx+dx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.y<cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.y>cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.x<cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.x>cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==7) // increasing circle with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+10.0*sa;\n\t\t\trad2=rad+sa;\n\t\t\tr1=sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy));\n\t\t\tif (r1>rad2) MEM1\n\t\t\telse if (r1>rad) { v1=(r1-rad)/(rad2-rad); v2=1.0-v1; MEM12 }\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==8) // increasing diamond with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+7.0*sa;\n\t\t\trad2=rad+.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx2) MEM1\n\t\t\telse if (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+b2;\n\t\t\t\tv1=(dy-vy1)/(vy2-vy1); v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==9) // increasing & decreasing diamonds w/ soft edge\n\t\t\t{\n\t\t\tfloat xc1s,yc1s,xc2s,yc2s,rads,rad2s,bs,b2s,cxs,cys,cx2s,cy2s;\n\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\t//rads=rad+7.0*sa;\n\t\t\trads=rad+.7*sa;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\t//rad2s=rad2-7.0*sa;\n\t\t\trad2s=rad2-.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\txc1s=rads*cos(theta); yc1s=rads*sin(theta);\n\t\t\txc2s=rad2s*cos(theta); yc2s=rad2s*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tbs=yc1s-slope*xc1s;\n\t\t\tb2s=yc2s-slope*xc2s;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tcys=bs; cxs=(-bs/slope);\n\t\t\tcy2s=b2s; cx2s=(-b2s/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cxs) MEM2\n\t\t\telse if (dy>slope*dx+cys) MEM2\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+bs;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy2s)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b2;\n\t\t\t\tvy2=slope*dx+b2s;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==10) // increasing box with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=(cx*float(i+rn)/float(n+rd));\n\t\t\tdy=(cy*float(i+rn)/float(n+rd));\n\t\t\tdx2=(cx*float(i+rn)/float(n+rd)+sa);\n\t\t\tdy2=(cy*float(i+rn)/float(n+rd)+sa);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse if ((uv.x>=cx-dx2)&&(uv.x<=cx+dx2)&&(uv.y>=cy-dy2)&&(uv.y<=cy+dy2))\n\t\t\t\t{\n\t\t\t\tif ((abs(uv.x-cx)>dx)&&(abs(uv.y-cy)>dy))\n\t\t\t\t\t{\n\t\t\t\t\tif (abs(uv.y-cy)-dy>abs(uv.x-cx)-dx) v1=float(abs(uv.y-cy)-dy)/(sa);\n\t\t\t\t\telse v1=float(abs(uv.x-cx)-dx)/(sa);\n\t\t\t\t\t}\n\t\t\t\telse if (abs(uv.x-cx)>dx) { v1=float(abs(uv.x-cx)-dx)/(sa); }\n\t\t\t\telse if (abs(uv.y-cy)>dy) { v1=float(abs(uv.y-cy)-dy)/(sa); }\n\t\t\t\tv2=1.0-v1; MEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==11) // rotating vanishing (gets smaller) square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = vec3(0,0,0); }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==12) // rotating vanishing (gets smaller) square with fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==13) // increasing flower with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { r=theta2/ang*(ro-ri)+ri; }\n#else\n\t\t\tif (i2%2==0) { r=theta2/ang*(ro-ri)+ri; }\n#endif\n\t\t\telse { r=(1.0-theta2/ang)*(ro-ri)+ri; }\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==14) // increasing star with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tpo.x=po.y=0.0;\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#else\n\t\t\tif (i2%2==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#endif\n\t\t\telse { p1.x=ro; p1.y=0.0; p2.x=ri*cos(ang); p2.y=ri*sin(ang); }\n\t\t\tpd.x=cos(theta2); pd.y=sin(theta2);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==15) // dissolve\n\t\t\t{\n\t\t\t// easier to use this common shadertoy random number gen rather than the one I used in original\n\t\t\tint v=int(fract(sin(dot(uv, vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n\t\telse if (type==16) // split horizontal\n\t\t\t{\n\t\t\tcy=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.y<cy-ye) MEM1\n\t\t\telse if (uv.y>=cy+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==17) // split vertical\n\t\t\t{\n\t\t\tcx=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.x<cx-ye) MEM1\n\t\t\telse if (uv.x>=cx+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==18) // slide\n\t\t\t{\n\t\t\tye=float(i+rn)/float(n+rd);\n\t\t\tuv2.x=uv.x;\n\t\t\tuv2.y=uv.y+ye;\n\t\t\tif (uv.y>=1.0-ye) MEM2\n\t\t\telse MEM1S\n\t\t\t}\n\t\telse if (type==19) // window right with soft edge\n\t\t\t{\n\t\t\tye=float(i)/float(n-1);\n\t\t\tyfe=ye+(10.0*sa);\n\t\t\tif (uv.x<=ye) MEM2\n\t\t\telse if (uv.x>yfe) MEM1\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv1=(uv.x-ye)/(10.0*sa); if (v1>1.0) { v1=1.0; } v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==20) // inset down right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==21) // inset down left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==22) // inset up right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (uv.y>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==23) // inset up left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if ((uv.y)>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==24) // pixelate\n\t\t\t{\n\t\t\t// this is simpler (not as good) as my original non-glsl code\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tif (i<n/2) { j=int(float(i)/(float(n)/2.0)*50.0); }\n\t\t\telse { j=int(float(n-i-1)/(float(n)/2.0)*50.0); }\n\t\t\tif (j<1) { j=1; }\n\t\t\tuv2.x=float(int(uv.x*iResolution.x/float(j))*j)/iResolution.x;\n\t\t\tuv2.y=float(int(uv.y*iResolution.y/float(j))*j)/iResolution.y;\n\t\t\tcol = v1 * (alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz) + v2 * (alt ? texture2D(iChannel0, uv2).xyz : texture2D(iChannel1, uv2).xyz);\n\t\t\t}\n\t\telse if (type==25) // fan in\n\t\t\t{\n\t\t\ttheta2=M_PI*float(i+rn)/float(n+rd);\n\t\t\tdy=1.0/4.0; dx=1.0/2.0; dy2=1.0*3.0/4.0;\n\t\t\txc1=M_PI/180.0*sa; cy=.5;\n\t\t\ttheta=atan2(abs(dx-uv.x),dy-uv.y);\n\t\t\ttheta3=atan2(abs(dx-uv.x),uv.y-dy2);\n\t\t\tif ((theta<theta2)||(theta3<theta2)) MEM2\n\t\t\telse if (abs(theta2-M_PI)<=.00001) MEM2\n\t\t\telse if ((theta<theta2+xc1)&&(uv.y<=cy)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse if (theta3<theta2+xc1) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==26) // fan out\n\t\t\t{\n\t\t\ttheta2=_TWOPI*float(i+rn)/float(n+rd);\n\t\t\tdx=1.0/4.0; dy=.5; dx2=1.0*3.0/4.0; cx=.5;\n\t\t\txc1=M_PI/180.0*sa;\n\t\t\ttheta=M_PI+atan2(1.0-uv.y-dy,dx-uv.x);\n\t\t\ttheta3=M_PI+atan2(1.0-uv.y-dy,uv.x-dx2);\n\t\t\tif (theta2<=M_PI)\n\t\t\t\t{\n\t\t\t\tif ((theta<theta2)&&(theta3<theta2)) MEM2\n\t\t\t\telse if ((theta<theta2+xc1)&&(uv.x<=cx)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse if ((theta3<theta2+xc1)&&(uv.x>=cx)) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse MEM1\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ((theta>theta2+xc1)&&(uv.x<=cx)) MEM1\n\t\t\t\telse if ((theta3>theta2+xc1)&&(uv.x>=cx)) MEM1\n\t\t\t\telse if (!((theta>theta2)&&(theta3>theta2))) MEM2\n\t\t\t\telse if (uv.x<=cx) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==27) // fan up\n\t\t\t{\n\t\t\ttheta2=M_PI/2.0*float(i+rn)/float(n+rd);\n\t\t\tdy=0.0; dx=1.0/2.0; xc1=M_PI/180.0*sa;\n\t\t\ttheta=atan2(abs(dx-uv.x),1.0-uv.y);\n\t\t\tif (theta<theta2) MEM2\n\t\t\telse if (theta<theta2+xc1) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 33: // roll\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w; cy=h;\n\t\t\ttheta=M_PI/2.0*((float)(i+rn)/(float)(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=.5)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=.5)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=(xc1*c1-yc1*s1);\n\t\t\t\t\tyc2=(xc1*s1+yc1*c1);\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==28) // bars\n\t\t\t{\n\t\t\tint v=int(fract(sin(dot(vec2(uv.y,0), vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 34: // slide up center\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w/2; cy=0;\n\t\t\trad=((float)(n-(i+1))/(float)(n+rd));\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=1.0)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=1.0)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=rad*xc1;\n\t\t\t\t\tyc2=rad*yc1;\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==29) // diagonal down right\n\t\t\t{\n\t\t\trad=sqrt(2.0+2.0)*(1.0-(float(i+rn)/float(n+rd)));\n\t\t\tslope=-1.0/1.0;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1-sa;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(uv.y);\n\t\t\tdx=abs(1.0-uv.x);\n\t\t\t//if (dx>cx-sa) MEM2\n\t\t\tif (dy>slope*dx+cy+sa) MEM2\n\t\t\telse if (dy>slope*dx+cy) { v2=(dy-(slope*dx+cy))/(sa); v1=1.0-v2; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==30) // diagonal cross out\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope); vy1=sa;\n\t\t\tdy=(uv.y-.5);\n\t\t\tdx=(uv.x-.5);\n\t\t\tif (!(((dy>slope*dx+cy)||(dy<slope*dx-cy))&&((dy>(-slope)*dx+cy)||(dy<(-slope)*dx-cy)))) MEM2\n\t\t\telse if ((sa!=0.0)&&(!(((dy>slope*dx+cy+vy1)||(dy<slope*dx-cy-vy1))&&\n\t\t\t\t((dy>(-slope)*dx+cy+vy1)||(dy<(-slope)*dx-cy-vy1)))))\n\t\t\t\t{\n\t\t\t\tif ((dx>=0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx>=0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==31) // increasing gear with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tro=sqrt(cx*cx+cy*cy)/.9*float(i+rn)/float(n+rd);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tri=ro*.9;\n\t\t\tpo.x=po.y=0.0;\n\t\t\tangt=5.0;\n\t\t\tangs=2.5;\n\t\t\ttang=(angt+angs)*2.0;\n\t\t\tang=tang*M_PI/180.0;\n\t\t\tyc1=uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1);\n\t\t\ttheta2=fmod(theta+M_PI+vy1,ang);\n\t\t\tif (theta2<=angt*M_PI/180.0) { r1=r2=ri; ang2=angt; ang1=theta2; }\n\t\t\telse if (theta2<=(angt+angs)*M_PI/180.0) { r1=ri; r2=ro; ang2=angs; ang1=theta2-angt*M_PI/180.0; }\n\t\t\telse if (theta2<=(angt+angs+angt)*M_PI/180.0) { r1=r2=ro; ang2=angt; ang1=theta2-(angt+angs)*M_PI/180.0; }\n\t\t\telse { r1=ro; r2=ri; ang2=angs; ang1=theta2-(angt+angs+angt)*M_PI/180.0; }\n\t\t\tang2*=(M_PI/180.0);\n\t\t\tp1.x=r1; p1.y=0.0; p2.x=r2*cos(ang2); p2.y=r2*sin(ang2);\n\t\t\tpd.x=cos(ang1); pd.y=sin(ang1);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==32) // rotating expanding square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=rad*(xc1*c1-yc1*s1);\n\t\t\tyc2=rad*(xc1*s1+yc1*c1);\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\t//col=col3;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\nfragColor = vec4(col, 1.0);\n}\n\nfloat intersect(vec2 origin, vec2 direction, vec2 point1, vec2 point2)\n{\nvec2 v1, v2, v3;\nfloat dot, t1, t2;\n\nv1.x = origin.x - point1.x;\nv1.y = origin.y - point1.y;\nv2.x = point2.x - point1.x;\nv2.y = point2.y - point1.y;\nv3.x = -direction.y;\nv3.y = direction.x;\ndot = v2.x * v3.x + v2.y * v3.y;\nif (abs(dot) < 0.000001) return(-1000.0);\nt1 = (v2.x * v1.y - v2.y * v1.x) / dot;\nt2 = (v1.x * v3.x + v1.y * v3.y) / dot;\nif ((t1 >= 0.0) && (t2 >= 0.0) && (t2 <= 1.0)) return(t1);\nreturn(-1000.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// The Universe Within - by Martijn Steinrucken aka BigWings 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// After listening to an interview with Michael Pollan on the Joe Rogan\n// podcast I got interested in mystic experiences that people seem to\n// have when using certain psycoactive substances. \n//\n// For best results, watch fullscreen, with music, in a dark room.\n// \n// I had an unused 'blockchain effect' lying around and used it as\n// a base for this effect. Uncomment the SIMPLE define to see where\n// this came from.\n// \n// Use the mouse to get some 3d parallax.\n\n// Music - Terrence McKenna Mashup - Jason Burruss Remixes\n// https://soundcloud.com/jason-burruss-remixes/terrence-mckenna-mashup\n//\n// YouTube video of this effect:\n// https://youtu.be/GAhu4ngQa48\n//\n// YouTube Tutorial for this effect:\n// https://youtu.be/3CycKKJiwis\n\n#define t iTime\n#define re iResolution.xy\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define colorRange 24.0\nvec4 fragColor;\n\nfloat Band(float t, float start, float end, float blur) {\n\n\t\t\t\tfloat step1 = smoothstep(start - blur, start + blur, t);\n\t\t\t\tfloat step2 = smoothstep(end + blur, end - blur, t);\n\n\t\t\t\treturn step1 * step2;//overlap edges\n\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur) {\n\t\t\t\tfloat band1 = Band(uv.x, left, right, blur);\n\t\t\t\tfloat band2 = Band(uv.y, bottom, top, blur);\n\n\t\t\t\treturn band1 * band2;//overlap horizontal and vertical bands\n\n}\nvoid getTriangle(vec2 uv, vec2 t0, vec2 t1, vec2 t2 ) {\n\t\t\t\t//Colors\n\t\t\t\tvec3 fgColor = vec3(0.741, 0.635, 0.471);\n\t\t\t\tvec3 bgColor = vec3(0.192, 0.329, 0.439);\n\n\t\t\t\t//Triangle barycentric coordinates defined on screen space\n\t\t\t\t/*vec2 t0 = vec2(0.5, 0.375);//base izq\n\t\t\t\tvec2 t1 = vec2(0.75, 0.25);//base der\n\t\t\t\tvec2 t2 = vec2(0.75, 0.50);//punta*/\n\t\t\t\tvec2 tCentroid = (t0 + t1 + t2) / 3.0;\n\t\t\t\t//Compute UV coordinates\n\t\t\t\t\n\n\t\t\t\tvec2 v0 = t2 - t0;\n\t\t\t\tvec2 v1 = t1 - t0;\n\t\t\t\tvec2 v2 = uv - t0;\n\n\t\t\t\t//Compute barycentric coordinates \n\t\t\t\tfloat dot00 = dot(v0, v0);\n\t\t\t\tfloat dot01 = dot(v0, v1);\n\t\t\t\tfloat dot02 = dot(v0, v2);\n\t\t\t\tfloat dot11 = dot(v1, v1);\n\t\t\t\tfloat dot12 = dot(v1, v2);\n\n\t\t\t\tfloat invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\t\t\t\tfloat baryX = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\t\t\t\tfloat baryY = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n\t\t\t\tif ((baryX >= 0.0) && (baryY >= 0.0) && (baryX + baryY <= 1.0)) {\n\t\t\t\t\tfragColor = vec4(fgColor, 1.0);\n\t\t\t\t}\n\t\t\t\t//else discard;\n\t\t\t\t/*{\n\t\t\t\t\tfragColor = vec4(bgColor, 1.0);\n\t\t\t\t}*/\n\t\t\t\t\n}\n\nfloat triangle( in vec2 uv, in vec2 n ) {\n    vec2 uuv = vec2(abs(uv.x), uv.y);\n    return max(-uv.y, dot(n, uuv));\n}\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat CircleShape(vec2 pos, float radius){    \n    \n    return step(radius, length(pos));\n}\n\nfloat polygon(vec2 pos, float rad, float sides){\n    pos = pos * 2. - 1.;\n    float angle = atan(pos.x, pos.y);\n    float slice = PI * 2.0/ sides;\n    \n    return step(rad, cos(floor(0.5 + angle/ slice) * slice - angle) * length(pos));\n\n}\n\n// Created by beautypi - beautypi/2012\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat length2( vec2 p )\n{\n    vec2 q = p*p*p*p;\n    return pow( q.x + q.y, 1.0/4.0 );\n}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An example showing the use of iChannelData[] in order to synchronize an aimation\n\n#define BPM 140.0\n#define STROBEPREVENTION\n#define PI_2 6.28\nfloat rand (vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noisex(vec2 n)\n{\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat getPoly (vec2 uv, float gonSide, float gonAngle, float thickness, float percent)\n{\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gonSlice = 6.28319 / gonSide;\n    float gonSize = percent;\n    float gonWidth = thickness;\n  \t\n    vec2 deltaUV = vec2(0.5) - uv;\n    float deltaAngle = atan(deltaUV.x,deltaUV.y) + (gonAngle / PI);\n    float dist = cos(floor(.5 + deltaAngle / gonSlice) * gonSlice - deltaAngle) * length(deltaUV.xy) * 2.0;\n    return min(smoothstep(gonSize - gonWidth - 0.001, gonSize - gonWidth, dist), smoothstep(gonSize + gonWidth, gonSize + gonWidth - 0.001, dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    //p*=rot(t);\n\n    float r = length( p );\n    float a = atan( p.y, p.x );\n\n    float dd = 0.2*sin(4.0*iTime);\n    float ss = 1.0 + clamp(1.0-r,0.0,1.0)*dd;\n\n    r *= ss;\n\n    vec3 col = vec3( 0.0, 0.3, 0.4 );\n\n    float f = fbm( 5.0*p );\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n\n    col = mix( col, vec3(0.9,0.6,0.2), 1.0-smoothstep(0.2,0.6,r) );\n\n    a += 0.05*fbm( 20.0*p );\n\n    f = smoothstep( 0.3, 1.0, fbm( vec2(20.0*a,6.0*r) ) );\n    col = mix( col, vec3(1.0,1.0,1.0), f );\n\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*a,10.0*r) ) );\n    col *= 1.0-0.5*f;\n\n    col *= 1.0-0.25*smoothstep( 0.6,0.8,r );\n\n    f = 1.0-smoothstep( 0.0, 0.6, length2( mat2(0.6,0.8,-0.8,0.6)*(p-vec2(0.3,0.5) )*vec2(1.0,2.0)) );\n\n    col += vec3(1.0,0.9,0.9)*f*0.985;\n\n    col *= vec3(0.8+0.2*cos(r*a));\n\n    f = 1.0-smoothstep( 0.2, 0.25, r );\n    col = mix( col, vec3(0.0), f );\n\n    f = smoothstep( 0.79, 0.82, r );\n    col = mix( col, vec3(1.0), f );\n\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    /////////////\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    col *= mix(col, baseCol*m, 0.10);\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    //pulse star\n\n    vec3 star;\n    float l,z=t;\n    for(int i=0;i<3;i++) {\n        vec2 uv,p=fragCoord.xy/r;\n        p-=.5;\n        //p.x*=r.x/r.y;\n        uv=p;\n\t\tz+=.07;\n        l=length(p);\n        uv+=p*abs(sin(l*7.-z*1.35));\n        uv *= smoothstep(0.0005, 0.0006, l);\n        //uv+= vec2(0.0,0.4);\n        star[i]=0.05/length(uv);\n        \n        }\n        \n    //tube    \n    float x=uv.x;\n    float y=uv.y;\n    //y=x;//vertical\n    float d= smoothstep(.1,.2,length(y));\n    x=y;//horiz\n    float d2= fract(smoothstep(.1,.2,length(x+y)));//wide + or *\n    d2+= mix(d2,fract(smoothstep(.1,.2,length(x+y))),1.0);//wide + or *\n    \n    //cones\n    //move position\n    p = vec2(.0, .0);\n\t\t\t\t\n    x += .0;//move horizontal\n    y += .0;//move vertical\n\n    m = -(x - .5)*(x + .5);//distortion parabola\n    y = uv.y - m;//distortion x\n    //circle mask\n    float mask = smoothstep(.03,.003,length(uv) - .4);//esfera Circle(uv, p, .5, .01);\n    //mask += max(mask,  p.y-0.35);//cortar altura del circulo\n    col += vec3(1.3, 0.75, 0.5)*mask;\n    mask += smoothstep(.02,.01,length(uv) - .2);\n    //cut another circle or add with symbol + or overlap multipling *\n    //mask -= Circle(uv, p - vec2(.0, .0), .49, .01);\n    mask += length(uv) + .1;//esferaCircle(uv, vec2(.0, .0), .3, .01);\n    //col += vec3(0., 0., 1.)*mask;\n    //cut another circle or add with symbol + or overlap multipling *\n    mask -= CircleShape(uv,  .1);\n    mask += length(uv) - .1;//esferaCircle(uv, vec2(.0, .0), .1, .01);\n    //col += vec3(0.7, 0.8, 1.0)*mask;\n    mask -= CircleShape(uv,  .1);\n    p = uv - vec2(.0, .125);\n    //getTriangle(p, vec2(0.5, 0.375), vec2(0.75, 0.25), vec2(0.75, 0.50));\n    mask -= Rect(uv, .5, .9, -.08, .09, .001);\n    //getTriangle(p, vec2(0.5, 0.375), vec2(0.25, 0.25), vec2(0.25, 0.5));\n    mask -= Rect(uv, -.9, -.5, -.08, .09, .001);\n    mask += smoothstep(.001,.001,triangle( abs(st*rot)-vec2(.0,0.22), vec2(.008,.006) ));\n\t\t\t\n\n    //set color of circle and background\n    if(d<.3) c = 0.0; else c= 1.0;\n\n    //colorize circle\n    //col /= vec3(1., 1., 1.)*mask;\n    \n    \n    //polygon\n    uv*=6.0;\n    float polygon = polygon(rot* -uv+vec2(.5,.5), .6,3.0) * polygon(rot* uv+vec2(.5,.5), .6,3.0);\n    \n    col += polygon*star;\n    \n    //bpm\n    uv*=.2;\n    t = fract(iTime*(BPM/60.));\n    float h = fract( 0.25 + 0.5*iChannelTime[0]*BPM/60.0 );\n\tf = 1.0-smoothstep( 0.0, 1.0, h );\n\tf *= smoothstep( 4.5, 4.51, iChannelTime[0] );\n\tr = length(uv-0.0) + 0.2*cos(25.0*h)*exp(-4.0*h);\n\tf = pow(f,0.5)*(1.0-smoothstep( 0.5, 0.55, r) );\n\tfloat rn = r/0.55;\n\tcol = mix( col, vec3(0.4+1.5*rn,0.1+rn*rn,0.50)*rn, f );\n\t\n\n\tcol = mix( col, vec3(1.0), smoothstep(  0.0,  3.0, iChannelTime[0] )*exp( -1.00*max(0.0,iChannelTime[0]- 2.5)) );\n\tcol = mix( col, vec3(1.0), smoothstep( 16.0, 18.0, iChannelTime[0] )*exp( -0.75*max(0.0,iChannelTime[0]-19.0)) );\n\t\n    ////drums\n    float beattime = 1.0-fract(iTime/60.*BPM)/(BPM/60.0);\n    float claptime = 1.0-fract((iTime-0.5)/120.*BPM)/(BPM/120.0);\n    float hatintime = 1.0-fract((iTime-0.25)/60.*BPM)/(BPM/120.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv /= fract(uv);\n    float kick = smoothstep(0.333,0.33,uv.x);\n    float hat = smoothstep(0.66,0.662,uv.x);\n    float clap = 1.0-max(kick,hat);\n    \n    col += vec3(kick*beattime,\n                    hat*hatintime,\n                    clap*claptime);\n    #ifdef STROBEPREVENTION\n    // desaturate to possibly reduce strobing?\n    //col = ( col * 0.3 ) + 0.7;\n    #endif\n    \n    ////bpmstuff\n    vec2 pixelSz = vec2(1.0) / iResolution.xy;\n    \n\tuv = fragCoord / iResolution.xy;\n    vec4 final = texture(iChannel0, uv);\n    \n    const float stepsize = 0.1;\n    const float stepmult = stepsize * 0.5;\n    float samplescale = pixelSz.x * 64.0;\n    \n    for (float i=0.0; i<= 1.0; i+= stepsize)\n    {\n        float bias = i - 0.5;\n        float samplerand = rand(uv) - 0.5;\n        vec2 sampleuv = vec2(bias * samplescale + samplerand * samplescale, 0.0);\n        \n        final += texture(iChannel0, uv + sampleuv) * stepmult * (1.0 - abs(samplerand));\n        final += texture(iChannel0, uv - sampleuv) * stepmult * (1.0 - abs(samplerand));\n    }\n    \n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    final.a = 1.0;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvOrig = fragCoord / iResolution.xy;\n    vec2 ctDelta = uvOrig - vec2(0.5);\n    float ctLen = length(ctDelta);\n    vec2 ctDir = normalize(ctDelta);\n    \n    // Aspect ratio corrected uv\n    uv = uvOrig;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\tuv += 0.5;\n    \n    // Beat?\n    //const float BPM = 120.0;\n    const float BPS = 60.0 / BPM;\n    const float BPS2 = BPS * 2.0;\n    float beatDelta = mod(iTime, BPS) / BPS;\n    float beatDelta2 = mod(iTime, BPS2) / BPS2;\n    float beatIncr = 3.0 + mod(floor(iTime / BPS), 4.0);\n    float beatIncr2 = 3.0 + mod(floor(iTime / BPS2), 4.0);\n    \n    float beatTime = iTime / BPS;\n    float powerBeat = pow(1.0 - beatDelta, 1.4);\n    \n    // Flashy background\n    float bgr = mod(beatIncr, 6.0) / 6.0;\n    vec3 flash = vec3(sin(iTime * 2.0 + 60.0) * 0.5 + 0.5, cos(iTime * 4.0 + 0.5) * 0.5 + 0.5, abs(sin(iTime))) * 0.4 * pow(1.0 - beatDelta, 3.0);\n    final.xyz = flash * (uv.y + sin(uv.x * 10.0) * 0.05);\n    // Rad BG\n    float radRand = rand(vec2(floor(uv.x * 8.0) / 8.0, beatIncr));\n    vec2 raduv = vec2(uv.x, min(uv.y + radRand * 0.5, 1.0));\n    \n    float radIntensity = pow(min(powerBeat + radRand * 0.3, 1.0), 2.0) * 0.52 + abs(sin(beatTime * 10.0 + radRand * 42.0)) * 0.1;\n    float radDelta = 1.0 - abs(radIntensity - raduv.y) * 2.0;\n    float radPercent = max(round(sin(raduv.y * 128.0) * pow(radDelta, 2.0)) * pow(max(radDelta, 0.0), 6.0), smoothstep(radIntensity, radIntensity - 0.001, raduv.y));\n    // radPercent *= pow(radDelta, 3.0);\n    \n    vec3 radColour = mix(vec3(0.0), vec3(0.9, 0.55, 0.15) * (1.0 + radRand * 0.1), radPercent);\n    final.xyz += radColour * (1.0 + noise(uv * 5.0 + iTime) * 0.4 + noise(uv * 100.0 + iTime) * 0.9);\n    \n    // BG with stars?\n    float ctAngle = atan(ctDir.y, ctDir.x) / PI_2 + 0.5;\n    float starSamp = smoothstep(0.98, 1.0, noise(vec2(ctAngle * 2.0, ctLen * 0.05 - beatTime * 0.05) * 100.0));\n    final.xyz += starSamp;\n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    // rotato potato\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gon1Side = beatIncr; // sides\n    float gon1Angle = beatDelta * 4.0 - 2.0;\n    float gon2Angle = beatDelta2 * 4.0 - 2.0;\n    float gon1Width = 0.01 + pow(beatDelta, 3.0) * 0.1;\n    \n    float t1 = (beatDelta + abs(sin(beatDelta * 5.0)) * 0.2) / 1.2;\n    float gon1Size = pow(1.0 - pow(1.0 - t1, 1.0), 3.0) * 2.0;\n    float gon2Size = pow(1.0 - pow(1.0 - beatDelta2, 0.5), 2.5) * 2.0;\n    \n    float gon1 = getPoly(uv, gon1Side, gon1Angle, gon1Width, gon1Size);\n    float gon2 = getPoly(uv, gon1Side + 1.0, gon2Angle, 0.01, gon2Size);\n    \n    final.xyz = mix(final.xyz, vec3(1.0), gon1);\n    final.xyz += vec3(fract(0.5 - bgr), bgr, 0.5) * 0.25 * gon2; //mix(final.xyz, vec3(fract(0.5 - bgr), bgr, 0.5), gon2 * 0.2);\n    for (float i=0.1; i<=1.0; i+=0.1)\n    {\n        float disp = 1.0 - pow(1.0 - i, 3.0);\n        \n        float gon3Size = pow(1.0 - pow(1.0 - t1 - 0.1 * disp, 1.0), 3.0) * 2.0;\n        float gon3 = getPoly(uv, gon1Side, gon1Angle, gon1Width * 0.3 * i, gon3Size - 0.2);\n    \tfinal.xyz += vec3(sin(iTime * 2.0 + 60.0), tan(iTime * 4.0 + 0.5), abs(sin(iTime))) * gon3 * disp;\n        // final.xyz = mix(final.xyz, vec3(sin(iTime * 2.0 + 60.0), tan(iTime * 4.0 + 0.5), abs(sin(iTime))), gon3);\n    }\n    \n    // Output to screen\n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    final.a = 1.0;\n    \n    \n    col += final.xyz;\n    \n    fragColor = vec4(col-polygon,final.a);\n}", "buffer_c_inputs": [], "buffer_d_code": "// Fork of \"The Cave\" by BoyC. https://shadertoy.com/view/MsX3RH\n// 2018-12-30 22:01:35\n\n// constants for the camera tunnel\nconst vec2 cama=vec2(-2.6943,3.0483);\nconst vec2 camb=vec2(0.2516,0.1749);\nconst vec2 camc=vec2(-3.7902,2.4478);\nconst vec2 camd=vec2(0.0865,-0.1664);\n\nconst vec2 lighta=vec2(1.4301,4.0985);\nconst vec2 lightb=vec2(-0.1276,0.2347);\nconst vec2 lightc=vec2(-2.2655,1.5066);\nconst vec2 lightd=vec2(-0.1284,0.0731);\n\n// calculates the position of a single tunnel\nvec2 Position(float z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\treturn sin(z*a)*b+cos(z*c)*d;\n}\n\n// calculates 3D positon of a tunnel for a given time\nvec3 Position3D(float time, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\treturn vec3(Position(time,a,b,c,d),time);\n}\n\n// 2d distance field for a slice of a single tunnel\nfloat Distance(vec3 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, float r)\n{\n\tvec2 pos=Position(p.z,a,b,c,d);\t\n\tfloat radius=max(5.0,r+sin(p.z*e.x)*e.y)/10000.0;\n\treturn radius/dot(p.xy-pos,p.xy-pos);\n}\n\n// 2d distance field for a slice of the tunnel network\nfloat Dist2D(vec3 pos)\n{\n\tfloat d=0.0;\n\t\n\td+=Distance(pos,cama,camb,camc,camd,vec2(2.1913,15.4634),70.0000);\n\td+=Distance(pos,lighta,lightb,lightc,lightd,vec2(0.3814,12.7206),17.0590);\n\td+=Distance(pos,vec2(2.7377,-1.2462),vec2(-0.1914,-0.2339),vec2(-1.3698,-0.6855),vec2(0.1049,-0.1347),vec2(-1.1157,13.6200),27.3718);\n\td+=Distance(pos,vec2(-2.3815,0.2382),vec2(-0.1528,-0.1475),vec2(0.9996,-2.1459),vec2(-0.0566,-0.0854),vec2(0.3287,12.1713),21.8130);\n\td+=Distance(pos,vec2(-2.7424,4.8901),vec2(-0.1257,0.2561),vec2(-0.4138,2.6706),vec2(-0.1355,0.1648),vec2(2.8162,14.8847),32.2235);\n\td+=Distance(pos,vec2(-2.2158,4.5260),vec2(0.2834,0.2319),vec2(4.2578,-2.5997),vec2(-0.0391,-0.2070),vec2(2.2086,13.0546),30.9920);\n\td+=Distance(pos,vec2(0.9824,4.4131),vec2(0.2281,-0.2955),vec2(-0.6033,0.4780),vec2(-0.1544,0.1360),vec2(3.2020,12.2138),29.1169);\n\td+=Distance(pos,vec2(1.2733,-2.4752),vec2(-0.2821,-0.1180),vec2(3.4862,-0.7046),vec2(0.0224,0.2024),vec2(-2.2714,9.7317),6.3008);\n\td+=Distance(pos,vec2(2.6860,2.3608),vec2(-0.1486,0.2376),vec2(2.0568,1.5440),vec2(0.0367,0.1594),vec2(-2.0396,10.2225),25.5348);\n\td+=Distance(pos,vec2(0.5009,0.9612),vec2(0.1818,-0.1669),vec2(0.0698,-2.0880),vec2(0.1424,0.1063),vec2(1.7980,11.2733),35.7880);\n\t\n\treturn d;\n}\n\nvec3 nmap(vec2 t, sampler2D tx, float str)\n{\n\tfloat d=1.0/1024.0;\n\n\tfloat xy=texture(tx,t).x;\n\tfloat x2=texture(tx,t+vec2(d,0)).x;\n\tfloat y2=texture(tx,t+vec2(0,d)).x;\n\t\n\tfloat s=(1.0-str)*1.2;\n\ts*=s;\n\ts*=s;\n\t\n\treturn normalize(vec3(x2-xy,y2-xy,s/8.0));///2.0+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime/3.0+291.0;//+43.63/3.0;\n\n\t//calculate camera by looking ahead in the tunnel\n\t\n\tvec2 p1=Position(time+0.05,cama,camb,camc,camd); //position ahead\n\tvec3 Pos=Position3D(time,cama,camb,camc,camd); //current position\n\tvec3 oPos=Pos;\n\t\n\tvec3 CamDir=normalize(vec3(p1.x-Pos.x,-p1.y+Pos.y,0.1));\n\tvec3 CamRight=normalize(cross(CamDir,vec3(0,1,0)));\n\tvec3 CamUp=normalize(cross(CamRight,CamDir));\t\n\tmat3 cam=mat3(CamRight,CamUp,CamDir);\n\n\t//ray calculation\t\n\tvec2 uv=2.0*fragCoord.xy/iResolution.xy-1.0;\n\tfloat aspect=iResolution.x/iResolution.y;\n\t\n\tvec3 Dir=normalize(vec3(uv*vec2(aspect,1.0),1.0))*cam;\n\t\n\t//raymarching\n\tfloat fade=0.0;\n\t\n\tconst float numit=75.0; //raymarch precision\n\tconst float threshold=1.20; //defines the thickness of tunnels\n\tconst float scale=1.5; //tunnel z depth\n\t\n\tvec3 Posm1=Pos;\n\t\n\t//calculate first hit\n\tfor (float x=0.0; x<numit; x++)\n\t{\n\t\tif (Dist2D(Pos)<threshold)\n\t\t{\n\t\t\tfade=1.0-x/numit;\n\t\t\tbreak;\n\t\t}\n\t\tPosm1=Pos;\n\t\tPos+=Dir/numit*scale;//*(1.0+x/numit);\n\t}\n\n\t//track back to get better resolution\n\tfor (int x=0; x<6; x++)\n\t{\n\t\tvec3 p2=(Posm1+Pos)/2.0;\n\t\tif (Dist2D(p2)<threshold) \n\t\t\tPos=p2;\n\t\telse\n\t\t\tPosm1=p2;\n\t}\t\n\n\t//lighting\t\n\tvec3 n=normalize(vec3(Dist2D(Pos+vec3(0.01,0,0))-Dist2D(Pos+vec3(-0.01,0,0)),\n\t\t\t\t\t\t  Dist2D(Pos+vec3(0,0.01,0))-Dist2D(Pos+vec3(0,-0.01,0)),\n\t\t\t\t\t\t  Dist2D(Pos+vec3(0,0,0.01))-Dist2D(Pos+vec3(0,0,-0.01))));\n\t\n\t//triplanar blend vector\n\tvec3 tpn=normalize(max(vec3(0.0),(abs(n.xyz)-vec3(0.2))*7.0))*0.5;\n\t\n\t//position of the light - uncomment the second line to get a more interesting path\n\tvec3 lp=Position3D(time+0.5,cama,camb,camc,camd); //current light position\n\t//lp=Position3D(time+0.3,lighta,lightb,lightc,lightd);\n\t\n\tvec3 ld=lp-Pos;\t//light direction\n\tfloat lv=1.0;\n\t\n\tconst float ShadowIT=15.0; //shadow precision\n\t\n\t//shadow calc\n\tfor (float x=1.0; x<ShadowIT; x++)\n\t\tif (Dist2D(Pos+ld*(x/ShadowIT))<threshold) \n\t\t{\n\t\t\tlv=0.0;\n\t\t\tbreak;\n\t\t}\n\n\tvec3 tuv=Pos*vec3(3.0,3.0,1.5);\t//texture coordinates\n\t\n\t//normal mapping\n\tfloat nms=0.19;\n\tvec3 nmx=nmap(tuv.yz,iChannel0,nms)+nmap(-tuv.yz,iChannel0,nms);\n\tvec3 nmy=nmap(tuv.xz,iChannel1,nms)+nmap(-tuv.xz,iChannel1,nms);\n\tvec3 nmz=nmap(tuv.xy,iChannel2,nms)+nmap(-tuv.xy,iChannel2,nms);\n\t\n\tvec3 nn=normalize(nmx*tpn.x+nmy*tpn.y+nmz*tpn.z);\n\t\n\tfloat dd;\n\t//normalmapped version:\n\tdd=max(0.0,dot(nn,normalize(ld*mat3(vec3(1,0,0),vec3(0,0,1),n))));\n\t//standard version:\n\t//dd=max(0.0,dot(n,normalize(ld)));\n\t\n\tvec4 diff=vec4(dd*1.2*lv)+vec4(0.2);\n\n\t//wisp\n\tfloat w=pow(dot(normalize(Pos-oPos),normalize(lp-oPos)),5000.0);\n\tif (length(Pos-oPos)<length(lp-oPos)) w=0.0;\t\n\n\t//texturing\n\t//double sampling to fix seams on texture edges\n    \n    float ctx=max(sin(Pos.x*200.),cos(Pos.y*200.));\n     ctx=min( ctx,sin(Pos.z*200.));\n    ctx=ctx*2.2;\n    \n    //tex stripes\n   float zStripes=min(atan(sin(Pos.z*5.)*55.),sin(Pos.z*111.));\n   zStripes*=10.;\n    \n    //tex dots\n    float ctxDots=sin(Pos.x*130.)*sin(Pos.y*130.)*sin(Pos.z*130.);\n    \tctxDots=ctxDots*ctxDots*ctxDots*10.;\n    \n   //mux   \n   ctx =max(ctx, zStripes*(sin(1.6+iMouse.x/100.)));\n\n    if (iMouse.xy==vec2(0)) //startup\n    {\n       ctx =mix(ctx,ctxDots,sin(iTime/2.));\n    }\n    else\n       ctx =mix(ctx,ctxDots,iMouse.y/iResolution.y);  \n    \n    \n    vec4 tx=vec4(\n        ctx*sin(Pos.x*10.) ,//+atan(sin(Pos.x*55.)*55.),\n        ctx*sin(Pos.y*10.)  ,\n       ctx*sin(Pos.z*10.) //+atan(sin(Pos.y*55.)*55.)\n        , 1.);\n\tvec4 col=tx*tpn.x;\n\t\n\tfragColor = col*min(1.0,fade*10.0)+w; //*diff\n  \n     \n\n}", "buffer_d_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSDf.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1672, 1672, 1692, 1692, 1755], [1759, 1759, 1791, 1791, 1817], [1819, 1819, 1837, 1837, 1996], [1999, 1999, 2022, 2022, 2281], [2283, 2283, 2307, 2367, 2457], [2459, 2459, 2493, 2493, 2723], [2725, 2725, 2749, 2749, 2939], [2941, 2941, 2991, 2991, 3182], [3184, 3184, 3216, 3216, 3658], [3660, 3660, 3716, 3716, 4634], [4855, 4855, 4899, 4925, 6090], [6093, 6093, 6150, 6150, 7661]], "test": "untested"}
{"id": "7dGSRw", "name": "Newton fractal bouncy balls", "author": "praggmars", "description": "Newton fractal but the zeros are bouncy balls", "tags": ["fractal"], "likes": 4, "viewed": 358, "published": 3, "date": "1634405998", "time_retrieved": "2024-07-30T18:55:25.995869", "image_code": "#define SHOW_BALLS 0\n#define PIXEL_ZERO 1\n#define BALL_COLOR vec4(1.0f, 0.5f, 0.0f, 1.0f)\n\n#define MAX_ITERATIONS   128\n#define COLOR_SCALE      64.0f\n#define NEWTON_STEP      vec2(1.0f, 0.0f)\n#define TOLERANCE        1e-5f\n#define ZOOM             1.0f\n#define CENTER           vec2(0.0f, 0.0f)\n#define SIZE_SCALING     0.0005f\n\nstruct Ball\n{\n    vec2 p;\n    vec2 v;\n    float r;\n};\n#define BALL_COUNT 5\n\nconst Ball balls[BALL_COUNT] = Ball[BALL_COUNT](\n    Ball(vec2(100.80927f, 71.011841), vec2(91.7454071f, 202.384338f), 23.8096046f),\n    Ball(vec2(782.947998f, 214.937714f), vec2(65.9425812f, -236.301651f), 29.2450104f),\n    Ball(vec2(303.452515f, 244.819077f), vec2(113.372017f, -16.9429722f), 36.4064445f),\n    Ball(vec2(142.07959f, 618.159912f), vec2(33.1328812f, -246.717346f), 49.0308456f),\n    Ball(vec2(1159.59851f, 604.708252f), vec2(93.8061142f, -80.5465546f), 48.7150116f)\n);\n\nvec2 GetBallPosition(in Ball ball)\n{\n    float scale = length(iResolution.xy) * SIZE_SCALING;\n    vec2 rect = iResolution.xy - (2.0f * ball.r * scale);\n    float t = iTime;\n    \n    return abs(mod(ball.p + ball.v * t * scale, 2.0f * rect) - rect) + ball.r * scale;\n}\n\nvec2 ComplexMul(vec2 z1, vec2 z2)\n{\n\treturn vec2(z1.x * z2.x - z1.y * z2.y, z1.x * z2.y + z1.y * z2.x);\n}\nvec2 ComplexDiv(vec2 z1, vec2 z2)\n{\n\treturn vec2(z1.x * z2.x + z1.y * z2.y, z1.y * z2.x - z1.x * z2.y) / (z2.x * z2.x + z2.y * z2.y);\n}\n\nfloat ToRatio(float iterations, float dist)\n{\n    return iterations / COLOR_SCALE;\n}\n\nvec4 ToColor(float ratio, int zero)\n{\n\tfloat R = abs(ratio * 6.0f - 3.0f) - 1.0f;\n\tfloat G = 2.0f - abs(ratio * 6.0f - 2.0f);\n\tfloat B = 2.0f - abs(ratio * 6.0f - 4.0f);\n    \n    /*const float PI = 3.141592654f;\n    float phase = 1.85f;\n    R = sin(phase + ratio * 2.0f * PI) * 0.5f + 0.5f;\n    B = sin(phase + ratio * 2.0f * PI + PI * 2.0f / 3.0f) * 0.5f + 0.5f;\n    G = sin(phase + ratio * 2.0f * PI + PI * 4.0f / 3.0f) * 0.5f + 0.5f;*/\n    \n\treturn vec4(clamp(vec3(R, G, B), 0.0f, 1.0f)*(1.0f - R * 0.49f), 1.0f);\n}\n\nvec2 Transform(vec2 screen)\n{\n\treturn (screen * 2.0f - iResolution.xy) / (iResolution.y * ZOOM) + CENTER;\n}\n\nvec4 FunctionColor(vec2 coord)\n{\n#if PIXEL_ZERO\n    vec2 zeros[BALL_COUNT + 1];\n    vec2 z = coord;\n    zeros[BALL_COUNT] = z;\n    int ballCount = BALL_COUNT + 1;\n#else\n    vec2 zeros[BALL_COUNT];\n    int ballCount = BALL_COUNT;\n#endif\n    for (int i = 0; i < BALL_COUNT; i++)\n    {\n        zeros[i] = Transform(GetBallPosition(balls[i]));\n#if PIXEL_ZERO\n        z += zeros[i];\n    }\n    z /= float(BALL_COUNT + 1);\n#else\n    }\n\tvec2 z = coord;\n#endif\n    \n\tfor (int i = 0; i < MAX_ITERATIONS; i++)\n\t{\n        vec2 funcValue = z - zeros[0];\n        for (int j = 1; j < ballCount; j++)\n            funcValue = ComplexMul(funcValue, z - zeros[j]);\n\n        vec2 derivValue = vec2(0.0f, 0.0f);\n        for (int j = 0; j < ballCount; j++)\n        {\n            vec2 tmp = vec2(1.0f, 0.0f);\n            for (int k = 0; k < ballCount; k++)\n                if (j != k)\n                    tmp = ComplexMul(tmp, z - zeros[k]);\n            derivValue += tmp;\n        }\n        \n\t\tz -= ComplexMul(NEWTON_STEP, ComplexDiv(funcValue, derivValue));\n\n        for (int j = 0; j < ballCount; j++)\n        {\n            float dist = length(z - zeros[j]);\n            if (dist < TOLERANCE)\n                return ToColor(ToRatio(float(i), dist), j);\n        }\n\t}\n\treturn vec4(0.0f, 0.0f, 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = FunctionColor(Transform(fragCoord));\n    \n#if SHOW_BALLS\n    float scale = length(iResolution.xy) * SIZE_SCALING;\n    for (int i = 0; i < BALL_COUNT; i++)\n    {\n        float d = length(GetBallPosition(balls[i]) - fragCoord);\n        if (d < balls[i].r * scale && d > balls[i].r * 0.7f * scale)\n        {\n            fragColor = BALL_COLOR;\n            break;\n        }\n    }\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[893, 893, 929, 929, 1159], [1161, 1161, 1196, 1196, 1266], [1267, 1267, 1302, 1302, 1402], [1404, 1404, 1449, 1449, 1488], [1490, 1490, 1527, 1527, 2008], [2010, 2010, 2039, 2039, 2117], [3405, 3405, 3462, 3462, 3863]], "test": "untested"}
{"id": "7syXzw", "name": "Twizzly Thingy", "author": "SnoopethDuckDuck", "description": "Just messing around so messy code", "tags": ["raymarching", "template", "artofcode"], "likes": 9, "viewed": 433, "published": 3, "date": "1634402903", "time_retrieved": "2024-07-30T18:55:26.775784", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n} \n\nfloat sdBox(vec3 p, vec3 s) {\n    float a = atan(p.z, p.x);\n    float b = atan(p.z, p.y);\n    p = 1.1 + .1 * cos(p  + p.x * 8. + iTime)-s;\n    //p.xz += .5 + .5 * cos(4. * p.y + iTime);\n\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    d = mix(length(p) - 2., d, .5 );\n    return 1. * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(4.6 * cos(0.5 * iTime), cos(0.3 * iTime) * 2.5, 4.6 * sin(0.5 * iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 rf = refract(rd, n,0.1);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = 0.42 *vec3(dif);\n        \n        col += 0.7 * texture(iChannel0,r / (0.5 + n)).rgb;\n         \n        col.r += 0.15 + .3 * cos(10. * rf.y + 4. * iTime - 3.1415 / 2.);\n        col.g += 0.15 + .3 * cos(10. * rf.y + 4. * iTime);\n        col.b += 0.15 + .3 * cos(10. * rf.y + 4. * iTime + 3.1415 / 2.);\n    } else {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syXzw.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1559, 1559, 1588, 1588, 1808], [1811, 1811, 1834, 1834, 1925], [1927, 1927, 1961, 1961, 2172], [2174, 2174, 2198, 2198, 2388], [2390, 2390, 2440, 2440, 2631], [2633, 2633, 2651, 2651, 2749], [2752, 2752, 2809, 2809, 3872]], "test": "untested"}
{"id": "ssGXzw", "name": "Buityfull Triangle", "author": "MrNissenDK", "description": "I know its not perfect, but I had fun mainking, still learing Shadertoy and all it's functions.", "tags": ["triangle", "color", "buityfull"], "likes": 2, "viewed": 240, "published": 3, "date": "1634401326", "time_retrieved": "2024-07-30T18:55:27.546722", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //debug = true;\n    uv =  ((fragCoord - .5 * iResolution.xy) / (iResolution.y/res)); //within Common\n    pixelSize = res / iResolution.x; //within Common\n\n    float TriAngle = TAU / 3.;\n    float TriAngle1 = iTime + TriAngle * 1.;\n    float TriAngle2 = iTime + TriAngle * 2.;\n    float TriAngle3 = iTime + TriAngle * 3.;\n    \n    vec2 p1 = vec2(sin(TriAngle1), cos(TriAngle1));\n    vec2 p2 = vec2(sin(TriAngle2), cos(TriAngle2));\n    vec2 p3 = vec2(sin(TriAngle3), cos(TriAngle3));\n    \n    vec3 col1 = vec3(cos(uv),sin(TriAngle1));\n    vec3 col2 = vec3(cos(uv),sin(TriAngle2));\n    vec3 col3 = vec3(cos(uv),sin(TriAngle3));\n    \n    //point(p1, col1);\n    //point(p2, col2);\n    //point(p3, col3);\n    \n    line(p1, p2, col1, col2);\n    line(p2, p3, col2, col3);\n    line(p3, p1, col3, col1);\n    \n    DebugLines();\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "float PI = 3.14159265359;\nfloat TAU = 6.28318530718;\nvec2 uv;\nvec3 col = vec3(0);\n\nbool debug = false;\n\nfloat debugLineSize = 2.;\nfloat pointSize = 5.;\nfloat pixelSize;\n\nfloat res = 3.;\n\nvoid DebugLines(){\n    vec2 cv = fract(uv);\n    if(\n        debug\n    &&  (\n                cv.x / pixelSize < debugLineSize / 2.\n        || (1.- cv.x)/ pixelSize < debugLineSize / 2.\n        ||      cv.y / pixelSize < debugLineSize / 2.\n        || (1.- cv.y)/ pixelSize < debugLineSize / 2.\n        )\n    ) col = 1. - col;\n}\n\nvoid cirkle(vec2 pos, float size, vec3 color){\n    col += smoothstep(0.5, 0.485, length(pos - uv) / size) * color;\n}\n\nvoid cirkle(vec2 pos, float size){\n    cirkle(pos, size, vec3(1));\n}\n\nvoid point(vec2 pos, vec3 color){\n    cirkle(pos, pixelSize * pointSize, color);\n}\nvoid point(vec2 pos){\n    cirkle(pos, pixelSize * pointSize);\n}\n\nbool inBound(vec2 p1, vec2 p2, vec2 pos){\n    vec2 start = vec2(min(p1.x, p2.x), min(p1.y, p2.y));\n    vec2 end = vec2(max(p1.x, p2.x), max(p1.y, p2.y));\n    return\n            start.x <= pos.x\n        &&  end.x   >= pos.x\n        &&  start.y <= pos.y\n        &&  end.y   >= pos.y;\n}\n\nvec3 _projection(vec2 pos, vec2 v1, vec2 v2){\n    vec2 e1 = v2 - v1;\n    vec2 e2 = pos - v1;\n    \n    float dPro = dot(e1, e2);\n    \n    float l1 = length(e1);\n    float l2 = length(e2);\n    \n    float ang = dPro / (l1 * l2);\n    \n    float pLength = ang * l2;\n    \n    vec2 pro = v1 + (pLength * e1) / l1;\n    \n    if(!inBound(v1,v2,pro)) {\n        float l3 = length(v2 - pos);\n        float _min = min(l3, l2);\n        if(_min == l3) pro = v2;\n        else pro = v1;\n    }\n    \n    return vec3(pro, pLength/l1);\n}\n\nvec2 _lineDist(vec2 v1, vec2 v2, float size){\n    vec3 pro = _projection(uv, v1, v2);\n    return vec2(1.-smoothstep(0.8,1.,length(uv - pro.xy) / (size / 2.)), pro.z);\n}\n\nvoid line(vec2 v1, vec2 v2, float size, vec3 col1, vec3 col2){\n    vec2 lineD = _lineDist(v1, v2, size);\n    col += vec3(lineD.x) * mix(col1, col2, lineD.y);\n}\n\nvoid line(vec2 v1, vec2 v2, float size, vec3 col1){\n    col += vec3(_lineDist(v1, v2, size).x) * col1;\n}\n\nvoid line(vec2 v1, vec2 v2, float size){\n    col += vec3(_lineDist(v1, v2, size).x);\n}\n\n\nvoid line(vec2 v1, vec2 v2){\n    col += vec3(_lineDist(v1, v2, pixelSize * pointSize).x);\n}\n\nvoid line(vec2 v1, vec2 v2, vec3 col1){\n    col += vec3(_lineDist(v1, v2, pixelSize * pointSize).x) * col1;\n}\n\nvoid line(vec2 v1, vec2 v2, vec3 col1, vec3 col2){\n    vec2 lineD = _lineDist(v1, v2, pixelSize * pointSize);\n    col += vec3(lineD.x) * mix(col1, col2, lineD.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 77, 935]], "test": "untested"}
{"id": "7dySRw", "name": " MatCap", "author": "aiekick", "description": "use mouse for rotate the df", "tags": ["matcap"], "likes": 19, "viewed": 923, "published": 3, "date": "1634397186", "time_retrieved": "2024-07-30T18:55:28.316664", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2021 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// new tex each 2.0 secs\n#define time_step 2.0 \n\nfloat df(vec3 p)\n{\n\tp += sin(p.zxy*3.36) * 0.44; // iq tech in  shader Sculpture III\n\tp += 0.5 * sin(p.zxy*3.36) * 0.44;\n\treturn length(p) - 1.;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nvec4 getMatCap(sampler2D sam, vec3 rd, vec3 n)\n{\n\tvec3 r = reflect( rd, n );\n    r.z = 1.0 - r.z;\n\tfloat m = 2. * length(r);\n\tvec2 tN = r.xy / m + .5;\n    return texture(sam, tN);\n}\n    \nvec4 getMatCap(vec3 rd, vec3 n)\n{\n    float rt = mod(iTime / time_step, 4.0);\n    if (rt > 3.0)\n        return getMatCap(iChannel3, rd, n);\n    else if (rt > 2.0)\n        return getMatCap(iChannel2, rd, n);\n    else if (rt > 1.0)\n        return getMatCap(iChannel1, rd, n);\n    return getMatCap(iChannel0, rd, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vars\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 mo = iMouse.xy;\n\tfloat time = iTime;\n\t\n\tvec3 col = vec3(0);\n\t\n\t// cam control\n\tfloat camd = 3.5;\n\tfloat cama = time*0.3;\n\tfloat came = 3.14159;\n\t\n    cama = 10. * mo.x/si.x;\n    came = 3.14159 * mo.y/si.y - 1.5;\n            \n\tvec3 ro = vec3(cos(cama), sin(came), sin(cama)) * camd; // cam point\n\t\n\tvec3 cv = vec3(0); // view center\n\tvec3 cu = normalize(vec3(0,1,0)); // cam up\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    \n    float fov = 0.5;\n    \n  \tvec2 uv = (g+g-si)/si.y;\n   \tvec3 rd = normalize(z + uv.x*x*fov + uv.y*y*fov); // cam dir view\n\n\tfloat md = 10.; // max distance\n\n\tconst float iter = 250.;\n\t\n\t// shape\n\tfloat s = 1., d = 0.;\n\tfor (float i=0.; i<iter; i++)\n\t{\n\t\tif (d*d/s>1e5 || d > md) break;\n\t\ts = df(ro+rd*d);\n\t\td += s * 0.4;\n\t}\n\t\n\tif ( d < md)\n\t{\n\t\tvec3 p = ro+rd*d; // surf point\n\t\tvec3 n = nor(p, 0.01);\n        col.rgb = getMatCap(rd, n).rgb;\n\t}\n\n    fragColor = vec4(col, 1.0);\n    \n    float thumbailSize = iResolution.y / 4.;\n    \n    // thumbail buffer D\n    if (g.x < thumbailSize && g.y < thumbailSize * 4. && g.y >= thumbailSize * 3.)\n    \tfragColor = texture(iChannel3, (g.xy - vec2(0,thumbailSize * 3.))/vec2(thumbailSize));\n    // thumbail buffer C\n    if (g.x < thumbailSize && g.y < thumbailSize * 3. && g.y >= thumbailSize * 2.)\n    \tfragColor = texture(iChannel2, (g.xy - vec2(0,thumbailSize * 2.))/vec2(thumbailSize));\n    // thumbail buffer B\n    if (g.x < thumbailSize && g.y < thumbailSize * 2. && g.y >= thumbailSize)\n    \tfragColor = texture(iChannel1, (g.xy - vec2(0,thumbailSize))/vec2(thumbailSize));\n    // thumbail buffer A\n    if (g.x < thumbailSize && g.y < thumbailSize)\n    \tfragColor = texture(iChannel0, g.xy/vec2(thumbailSize));\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "///////////////////////////////////////////////////////////////////////////////////////\n// https://www.shadertoy.com/view/ldfyW2\nvoid subImage( out vec4 f, vec2 g )\n{\n    g = g /iResolution.xy * 2.-1.;\n\t\n    float d = pow( max(.3 - dot(g*=0.55,g), 0.), .2);\n\t\n   \tf = d * vec4(g*=g+=d,d,1);\n}\n///////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n    if (iFrame < 240)\n    {\n    \tsubImage(fragColor, g);\n    }\n    else\n    {\n        vec2 v = fragCoord / iResolution.xy;\n    \tfragColor = texture(iChannel0, v);\n    }\n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "///////////////////////////////////////////////////////////////////////////////////////\n//https://www.shadertoy.com/view/4sjfWz\n\n#define E (n=n.zxy, d(p+n)-d(p-n))\n//#define d(p) (length(p) - 2. + texture(iChannel2, (p+iTime/5.).xy).x*.01)\n\n// other with better shape for 276c :\n#define d(p) (length(p) - 2. + textureLod(iChannel2, (p).xy/5.+iTime/15.,1.).x*.1)\n\nvoid subImage( out vec4 f, vec2 g )\n{\n    vec3 \n        n = iResolution,\t\t\t\t\t// screensize, normal variable\n    \tr = normalize(vec3(g+g-n.xy,n.y)),\t// ray direction\n    \tp = n -= n;\t\t\t\t\t\t\t// ray origin at zero, normal reset to zero\n    \n    r.x *= 0.55;\n    p.z -= 2.85;\t\t\t\t\t\t\t\t// ray origin at -3 along z axis\n    \n    //for (int i=99;i-->0;p+=r*d(p));\t\t// webgl2 form of for loop with included sphere tracing iteration\n    for(int i=99;i>0;i--)\n    \tp+=r*d(p);\n    \n    n.z=.01;\t\t\t\t\t\t\t\t// normal precision\n    \n    f = texture(iChannel1,vec3(E,E,E));\t\t// cubemap lookup with calculated normal\n}\n///////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n    if (iFrame < 240)\n    {\n    \tsubImage(fragColor, g);\n    }\n    else\n    {\n        vec2 v = fragCoord / iResolution.xy;\n    \tfragColor = texture(iChannel0, v);\n    }\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "///////////////////////////////////////////////////////////////////////////////////////\n// https://www.shadertoy.com/view/ldfyW2\nvoid subImage( out vec4 f, vec2 g )\n{\n    vec2 v = g/iResolution.xy * 2.-1.;\n\n    vec3 col;\n    col.r = 1.0 / dot(v,v);\n\tcol.g = 0.5 / dot(v,v);\n    col.b = 0.9 / dot(v,v);\n    col *= (col*0.2);\n    \n    f = vec4(col,1.0);\n}\n///////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n    if (iFrame < 240)\n    {\n    \tsubImage(fragColor, g);\n    }\n    else\n    {\n        vec2 v = fragCoord / iResolution.xy;\n    \tfragColor = texture(iChannel0, v);\n    }\n}\n", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "///////////////////////////////////////////////////////////////////////////////////////\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 561e5 * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 1e2 * log(Temp) - 623.;\n   \tif (Temp > 6500.) col.y = 352e5 * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194. * log(Temp) - 1448.;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1e3) col *= Temp/1e3;\n   \treturn col;\n}\n\nvoid subImage( out vec4 f, vec2 g )\n{\n     vec2 v = g/iResolution.xy * 2.-1.;\n\n    vec3 col = vec3(0);\n    col = blackbody(length(v) * (atan(abs(v.x),-v.y*abs(v.x))*3.14159) * 1500.);\n    //col /= sqrt(col * col * 0.5);\n    \n    f = vec4(col,1.0);\n}\n///////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n    //if (iFrame < 240)\n    {\n    \tsubImage(fragColor, g);\n    }\n    /*else\n    {\n        vec2 v = fragCoord / iResolution.xy;\n    \tfragColor = texture(iChannel0, v);\n    }*/\n}", "buffer_d_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dySRw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[206, 206, 224, 224, 352], [354, 354, 388, 388, 588], [590, 590, 638, 638, 771], [777, 777, 810, 810, 1092], [1094, 1094, 1151, 1163, 2954]], "test": "untested"}
{"id": "fdVSz1", "name": "Trees 3", "author": "guil", "description": "Some trees", "tags": ["trees"], "likes": 10, "viewed": 353, "published": 3, "date": "1634377084", "time_retrieved": "2024-07-30T18:55:29.084610", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define igt iTime\n\nvec4 ot=vec4(1.);\nfloat g=1.25;\n\nconst int MaxIter = 12;\n\nfloat zoom=1.3;\n\n\nfloat a1 = 1.25;\nfloat a2 = -.53;\nfloat a3 = 2.15;\nvec2 vr1; \nvec2 vr2; \nvec2 vr3;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\n\nfloat capsule( vec3 p)\n{\n   \tp.y -= clamp( p.y, 0.0, 6.0 );\n    return length( p-.05 ) - .6;\n}\n\nfloat sphere( vec3 p, float r)\n{\n   \tp.y *= .4;\n    return length( p ) - r;\n}\n\n\nfloat branches(in vec3 p,in float l, in float dr, in int maxi , in int type)\n{ \n    l= min(l,capsule(p));\n    //float b = sphere(p,11./dr);if(b>.5)return min(b,l);\n    for(int i=0;i<maxi;i++) {\n        p.y-=2.5;   \t\t\n        p.xz = abs(p.xz);\n        p.xz = cmul(vr1,p.xz);\n        p.xy = cmul(vr2,p.xy);\t\n        if (type==0)\n            if (i<maxi-2)p =  p * g; else p *=.8;\n        else if (type==1)\n            p *= g;\n        else\n            if (i>0 && i<maxi-1)p =  p * g; else p *=.9;\n        dr *= g;\n        l= min (l ,capsule(p) / dr);\n    }\n\treturn l;\n}\n\nfloat map(vec3 p)\n{ \n   \n    int a = int(floor(mod(p.x/20.+.5,3.)));\n    int b = int(floor(mod(p.z/20.+.5,4.)));\n    p.xz=mod(10.+p.xz,20.)-10.; \n    p.xz=cmul(p.xz, vec2(cos(float(b)),sin(float(b))));\n    float dr = 1.0;  \t\n    float l=p.y;\n   \n    if(p.y>.15){   \n\t\tfor(int i=0;i<5+b;i++){\n            l=branches(p,l,dr,MaxIter-i-b,a);\n            p.xz = cmul(vr3,p.xz);  \n            p.y-=5.5-float(b);\n            if(p.y<0.)break;\n            p*=g,dr*=g;   \n        }\n    }\t\t\t\n    return l;   \n}\n\nvec4 branchesOt(in vec3 p,in vec4 ot, in int maxi, in int type)\n{ \n   \n \n    for(int i=0;i<maxi;i++) {\n        p.y-=2.5;   \t\t\n        p.xz = abs(p.xz);\n        p.xz = cmul(vr1,p.xz);\n        p.xy = cmul(vr2,p.xy);\t\n        if (type==0)\n            if (i<maxi-2)p =  p * g; else p *=.8;\n        else if (type==1)\n            p *= g;\n        else\n            if (i>0 && i<maxi-1)p =  p * g; else p *=.9;\n        ot=min(ot,vec4(abs(p),1./float(1+i)));\n    }\n\treturn ot;\n}\n\nvec4 mapOt(vec3 p)\n{ \n   \n    int a = int(floor(mod(p.x/20.+.5,3.)));\n    int b = int(floor(mod(p.z/20.+.5,4.)));\n    p.xz=mod(10.+p.xz,20.)-10.; \n    p.xz=cmul(p.xz, vec2(cos(float(b)),sin(float(b))));\n    float dr = 1.0;\n    ot = vec4(1.);    \t\n   \n    if(p.y>.15){   \n\t\tfor(int i=0;i<5;i++){\n            ot=branchesOt(p,ot,MaxIter-i-b,a);\n            p.xz = cmul(vr3,p.xz);  \n            p.y-=5.5-float(b);\n            p*=g;dr*=g;   \n        }\n    }\t\t\t\n    return ot;   \n}\n\nfloat trace( in vec3 ro, in vec3 rd )\n{\n    float maxd = 120.;\n    float precis = 0.001;\n    float k = .5;\n      \n    float dt=1.;\n    float t = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( t>maxd ||  dt<precis*(.1+t)) continue;             \n        t += dt*k;\n        k *= 1.01;\n\t\tdt = map( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  eps = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n\tnor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n\tnor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n\treturn normalize(nor);\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n\tfloat res = 1.0;\n        float precis = 0.1;\n\tfloat t = tmin;\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tfloat dt = 2.*map( ro + rd*t );\n\t\tres = min(res, 16.0*dt/t);\n\t\tt += dt;\n\t\tif( dt<precis || t>tmax ) break;\n\t}\n\treturn clamp(res*t/tmax, 0.0, 1.0);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 m = vec2(-0.5)*6.28;\n\tm = (iMouse.xy/iResolution.xy-.5)*6.28;\n\tm += .5*vec2(cos(0.15*igt),cos(0.09*igt))+.3; \n    \n\tvr1 = vec2(cos(a1),sin(a1));\n    vr2 = vec2(cos(a2),sin(a2));\n    vr3 = vec2(cos(a3),sin(a3));\n    // camera\n\n\t\n\tvec3 ta = vec3(.5*igt,8.,4.);\n\tvec3 ro =ta  + zoom*4.*(5.+sin(.2*igt))*vec3( cos(m.x)*cos(m.y), 1.+sin(m.y), sin(m.x)*cos(m.y));\n\t\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.,1.,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\n    // trace\n\n   \n\t\n\tvec3 col = vec3(0.8,0.8,1.);\n\tfloat t = trace( ro, rd );\n\tif( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n        ot = mapOt(pos);\n\t\t\n\t\t// lighting\n        \n        vec3  light1 = normalize(vec3( 0.4, 0.9,0.4  ));\n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tif(pos.y<.15){\n            key*=softShadow(pos,light1,1.,25.);\n            ot=texture(iChannel0,(pos.xz / 16.0));\n            ot.a=0.;\n        }\n\t\t\n\t\tfloat amb = (0.4+0.6*nor.y);\n\t\tfloat ao = pow( clamp(1.-.5*ot.a,0.2,1.0), 1.2 );\t\t\n        vec3 brdf = vec3(ao)*(.6*amb+key);\n\n        // material\t\t\t\t\n\t\tot.g=max(ot.g,.8*ot.b);\n        vec3 rgb =ot.rgb*vec3(1.,.7,.2);        \n        if(pos.y>.15)rgb.rb = clamp(rgb.rb,0.,1.5*rgb.g);\n            \n        \n        \n        \n\t\t// color\n        col = rgb*brdf;\n\t\tcol = mix(vec3(0.8,0.8,1.),col,exp(-0.01*t));\n        \n\n\t}\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVSz1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[266, 266, 296, 296, 351], [354, 354, 378, 378, 448], [450, 450, 482, 482, 527], [530, 530, 608, 608, 1095], [1097, 1097, 1116, 1116, 1596], [1598, 1598, 1663, 1663, 2066], [2068, 2068, 2088, 2088, 2543], [2545, 2545, 2584, 2584, 2898], [2900, 2900, 2932, 2932, 3141], [3143, 3143, 3216, 3216, 3463], [3466, 3466, 3523, 3523, 5075]], "test": "untested"}
{"id": "7dVXzD", "name": "Fab16 #inktober2021 \"compass\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera\nsee reference at bottom", "tags": ["raymarching", "glints", "reproduction", "inktober2021"], "likes": 19, "viewed": 416, "published": 3, "date": "1634376833", "time_retrieved": "2024-07-30T18:55:29.854552", "image_code": "// --- font utils from https://www.shadertoy.com/view/llySRh ---------------------\n\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nvec4 pInt(vec2 p, float n) {  \n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n// ------------------------------------------------------------------------ \n \n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,y,a,c,n;                                            // c,n: hit object id \n    vec3  R = iResolution, C, N,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),                  // ray direction\n          p = 5./R, q,                                             // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(1,0,0),       // mouse camera rot\n          A = vec3(.7,.3,0)*cos(iTime+vec3(0,11,0)) - vec3(-.5,0,0);\n    M = vec3(2,.5,0)-6.*M;\n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p, \n        q.yz *= rot(M.y),                                          // compass rotations\n        q.xz *= rot(M.x), \n        t = c = max( length(q)-1., q.y - .3 ), C=q,                // compass shape\n        t = min(t, n = length(q/vec3(1,30,1))-.02), \n        q.yz *= rot(A.y),                                          // box rotations\n        q.xz *= rot(A.x), \n        t = min( t, max( abs( length(q)-1.2)-.1  , -length(q.yz-vec2(1,-1))+1.1 ) ), // box shape\n       \n        p += .5*t*D;                                               // step forward = dist to obj\n\n    if(O.a<0.) O.rgb+= .5;                                         // background\n    else\n                                            // --- texturing & shading -----------------\n    if (t==n) O *= vec4(.2,0,0,1);                                 // needle\n    else if (t==c)                                                 // --- compass\n              y = abs(C.y), a = mod(atan(C.z,-C.x),6.283), c = floor(a*12./6.283+.2)*30.,\n              O *= length(C)>.99 \n                  ? y < .2\n                        ? t = cos( a *( y < .05 ? 72. : y < .1 ? 12. : 8.) ),  // ticks\n                           clamp(.5 + .5*(t- ( y < .05 ? .5  : y < .1 ? .98 : .99 ))/fwidth(t), 0.,1.)\n                        + pInt(vec2((a-c*6.283/360.)*8.,C.y*10.-1.),c).x       // numbers\n                        : ( c = floor(a*8./6.283+.2),                          // letters\n                            char( vec2( (a-c*6.283/8.)*5.+.5 , C.y*6.-1.1 ) * (mod(c,2.)<1.?1.:1.3) ,\n                                  64+int[](14,14,5,19,19,19,23,14)[int(c)]).x \n                          + char( vec2( (a-c*6.283/8.)*5.+.1 , C.y*6.-1.1 ) * 1.3 , // opt second letter\n                                  64+int[](-32,5,-32,5,-32,23,-32,23)[int(c)]).x \n                          )\n                  : .5* smoothstep( 50./R.y,0., abs(fract(5.*length(C))-.5))   // compass center pattern\n                      * (.5+.5*sin(72.*a) );\n    else                                                           // --- box\n         N = -normalize(q + texture(iChannel2,q*5.).rgb),\n         N.xz *= rot(-A.x),   \n         N.yz *= rot(-A.y),                                        // back to camera frame\n         N.xz *= rot(-M.x),   \n         N.yz *= rot(-M.y),                                        \n      // O *= .3 + pow( max(0., dot(normalize(D+vec3(0,-.95,.3)),N)), 6.); // BUG on windows !\n         O *= .3 + pow( vec4(max(0., dot(normalize(D+vec3(0,-.95,.3)),N))), vec4(6)); // glints\n                             // -N.y\n    q = p, p = 5./R; a = dot(p,D), c = dot(p,p)-1.2, t = a*a-c;    // --- RT box glass\n    p += (-a-sqrt(t)) * D;\n    if (t>0. && p.z > q.z )                                        // reflect\n              O += .5*texture(iChannel0, reflect(D,-normalize(p))).r*vec4(.8,.9,1,1),\n              p.yz *= rot(M.y),                                    // camera rotations\n              p.xz *= rot(M.x), \n              p.yz *= rot(A.y),                                    // box rotations\n              p.xz *= rot(A.x), \n              a = atan(p.z,p.x),                                   // ticks on box glass\n              O.rg +=  abs(p.y)<.5 ? t = cos(8.*a), clamp(.5 + .5*(t-.995)/fwidth(t),0.,1.) : 0.;\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 110, 110, 341], [342, 342, 370, 370, 492]], "test": "untested"}
{"id": "ssKSRh", "name": "90s Anime Background 2", "author": "Xibanya", "description": "Another Sailor Moon-inspired background\n\nmobile-friendly version: https://www.shadertoy.com/view/fsySRw", "tags": ["sunset", "sdf", "city", "90s", "anime", "skyline", "lit"], "likes": 9, "viewed": 695, "published": 3, "date": "1634371330", "time_retrieved": "2024-07-30T18:55:30.810995", "image_code": "float nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= (1. - length(uv - vec2(0.5, 0.5))) * 0.025;\n    \n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.0015;\n    \n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec3 blur = texture(iChannel0, uv.xy - duv.xy).rgb;\n\tblur += texture(iChannel0, uv.xy - duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.zy).rgb;\n\tblur += texture(iChannel0, uv.xy + duv.xy).rgb;\n\tblur /= 4.;\n    \n    float sub = -0.1;\n    float hard = 0.3;\n\n    float modulo = floor(mod(uv.x / texel.x * 0.25, 3.0));\n    vec3 tmp = blur.rgb;\n    float is0 = step(modulo, 0.) * step(0., modulo);\n    float is1 = step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(0., sub * hard, \n        sub * hard * 2.0) * is0;\n    tmp -= vec3(sub * hard, 0., \n        sub * hard) * step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(sub * hard * 2.0, \n        sub * hard, 0.) * (1. - is0) * (1. - is1);\n    vec3 col = Blend(vec4(tmp, 0.9), vec4(blur, 1.)).rgb;\n    \n    float scanline = \n        sin((uv.y - sin(iTime / 200.)) * iResolution.y) * 0.01;\n    col.rgb -= scanline;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n#define saturate(x) clamp(x, 0., 1.)\n#define EPSILON 0.0001\n#define XTILT 12.\n#define YTILT 19.\n#define MAX_DIST 200.\n#define FOV 30.\n#define LIGHTDIR vec3(1., 0.2, -1.)\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\nvec3 GetDir(vec3 pos, vec3 dir)\n{\n    vec3 f = normalize(0. - pos);\n    vec3 s = normalize(cross(f, vec3(0., 1., 0.)));\n    vec3 u = cross(s, f);\n    mat4 viewToWorld = mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n    return (viewToWorld * vec4(dir, 0)).xyz;\n}\nfloat cube(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b,0.));\n}\nfloat Repeat(float p, float f)\n{\n    p = mod(p + f * .25, f);\n    p = abs(p - f * .5 );\n    return p;\n}\nfloat circle(vec2 uv, float radius)\n{\n\tvec2 dist = uv - vec2(0.5, 0.5);\n\treturn 1. - smoothstep(radius - (radius * 0.01),\n\t\tradius + (radius * 0.01),\n\t\tdot(dist, dist) * 4.0);\n}\nfloat Scene(vec3 p, out vec3 color, out float shiny)\n{\n    vec3 pos = p;\n    pos.z = Repeat(pos.z, 10.);\n    vec3 windowColor = vec3(0.5, 0.25, 0.63);\n    vec3 b1Color = vec3(0.83, 0.38, 0.58);\n    vec3 bld1Pos = pos + vec3(10., 4., -1.);\n    vec3 b1Size = vec3(4.75, 2., 2.);\n    float s = cube(bld1Pos, b1Size);\n\n    float b1y = fract(bld1Pos.y + .1);\n    float b1W = aastep(0.5, mod(b1y, 1.));\n    b1W *= step(1., bld1Pos.x);\n    b1W *= aastep(0.8, mod(bld1Pos.z * 1.5 + 1.9, 2.2));\n\n    color = mix(b1Color, windowColor, b1W);\n    shiny = b1W;\n\n    vec3 b2Pos = bld1Pos + vec3(0., -1., -3.);\n    vec3 b2Color = vec3(0.83, 0.38, 0.58);\n    float by = fract(b2Pos.y * 2.);\n    float b2W = aastep(0.5, mod(by, 1.));\n    b2W *= step(1., b2Pos.x);\n    b2W *= aastep(0.5, mod(b2Pos.z * 2. + 2., 0.));\n   \n    float wCirc = saturate(1. - b2Pos.z - 0.75);\n    vec3 accent = vec3(0.65, 0.34, 0.68);\n\n    vec2 cPos = b2Pos.zy * vec2(0.5, 0.2) + vec2(0., .1);\n    float wA = circle(cPos, 0.9);\n    float c2 = circle(cPos, 1.0);\n    wA = smoothstep(0.1, .9, 1. - saturate(distance(\n        cPos, pos.zy * vec2(.05, -0.05) + vec2(0., .2))));\n    wA += max(0., exp(-wA * 0.025) * .3);\n\n    b2Color = mix(b2Color, accent, saturate(wA));\n    windowColor = mix(windowColor, accent, wCirc);\n    b2Color = mix(b2Color, windowColor, b2W);\n\n    vec3 b2Size = vec3(5., 3., 1.);\n    float b2 = cube(b2Pos, b2Size);\n    shiny = b2 < s? b2W : shiny;\n    color = b2 < s? b2Color : color;\n    s = min(b2, s);\n\n    vec3 rdPos = pos + vec3(0., 6., 0.);\n    vec3 rdColor = vec3(0.2);\n    float rd = cube(rdPos, vec3(50., 0., 500.));\n    color = rd < s? rdColor : color;\n    s = min(rd, s);\n    return s;\n}\nvec3 GetNormal(vec3 p) \n{\n    vec3 c;\n    float s;\n    return normalize(vec3(\n        Scene(vec3(p.x + EPSILON, p.y, p.z), c, s) - \n        Scene(vec3(p.x - EPSILON, p.y, p.z), c, s),\n        Scene(vec3(p.x, p.y + EPSILON, p.z), c, s) - \n        Scene(vec3(p.x, p.y - EPSILON, p.z), c, s),\n        Scene(vec3(p.x, p.y, p.z  + EPSILON),c, s) - \n        Scene(vec3(p.x, p.y, p.z - EPSILON), c, s)\n    ));\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 uv) \n{\n    vec2 xy = uv - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 RotateX(vec3 dir, float degrees)\n{\n    float angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat4 rotateXMatrix = mat4(1., 0., 0., 0.,\n\t\t0., c, -s, 0.,\n\t\t0., s, c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateXMatrix).xyz;\n}\nvec3 RotateY(vec3 dir, float degrees)\n{\n    float angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat4 rotateYMatrix = mat4(\n        c, 0., s, 0.,\n\t\t0., 1., 0., 0.,\n\t\t-s, 0., c, 0.,\n\t\t0., 0., 0., 1.);\n    return (vec4(dir, 1.) * rotateYMatrix).xyz;\n}         \t\n/////////// FBM ///////////////\n// see: https://thebookofshaders.com/13/\nfloat FBMRandom(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat FBMNoise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = FBMRandom(i);\n    float b = FBMRandom(i + vec2(1.0, 0.0));\n    float c = FBMRandom(i + vec2(0.0, 1.0));\n    float d = FBMRandom(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nfloat FBM(vec2 st, float octaves)\n{\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (float i = 0.; i < octaves; i++)\n    {\n        value += amplitude * FBMNoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n    float bgBlend = smoothstep(-0.2, 0.9, dot(uv, vec2(-0.1, 1.)) * 4.);\n    vec3 col = mix(\n        vec3(0.9451, 0.7216, 0.4275), \n        vec3(0.8471, 0.4706, 0.3294), saturate(bgBlend));\n    \n    vec3 dir = rayDirection(FOV, iResolution.xy, fragCoord.xy);\n    dir = RotateX(dir, XTILT);\n    dir = RotateY(dir, YTILT);\n    vec3 p = vec3(0., -5., 0. );\n    \n    vec2 sunPos = vec2(0.25, 0.2);\n    vec3 coronaColor = vec3(0.93, 0.16, 0.31);\n    vec3 lightColor = vec3(0.96, 0.53, 0.29);\n    float coronaDist = distance(uv * vec2(0.8, 1.1),sunPos);\n    float isCorona = 1. - smoothstep(0.05, 0.25, dot(coronaDist, coronaDist) * 5.);\n    col = mix(col, coronaColor, isCorona);\n    float sundist = distance(uv * vec2(0.8, 1.1), sunPos);\n    float isSun = 1. - smoothstep(0.04, 0.06, dot(sundist, sundist) * 4.);\n    col = mix(col, pow(lightColor, vec3(sundist * 5.)) * 1.15, isSun);\n\n    vec2 cloudSpeed = vec2(iTime * 0.05, 0.);\n    float cloud = smoothstep(0.5, 0.9, \n        FBM(uv * vec2(1.5, 10.) + cloudSpeed, 5.));\n    vec3 cloudColor = vec3(0.9608, 0.5098, 0.6);\n    col = mix(col, cloudColor * 1.5, cloud);\n    cloud = smoothstep(0.5, .9, \n        FBM(uv * vec2(1., 10.) + vec2(0.025, -0.25) + cloudSpeed, 8.));\n    col = mix(col, cloudColor * 0.8, cloud);\n\n    float d = 0.;\n    vec3 dCol;\n    float isShiny = 0.;\n    for(float i = 0.; i < MAX_DIST; i++ )\n    {\n        d = Scene(p, dCol, isShiny);\n        p += dir * d;\n    }\n   \n    if (d < .01)\n    {\n        vec3 shadowColor = vec3(0.15, 0.1, 0.3);\n        vec3 normal = GetNormal(p);\n        vec3 lightDir = LIGHTDIR;\n        float mouseTiltY = iMouse.x * 3./iResolution.x - 0.5;\n        float mouseTiltX = iMouse.y/iResolution.y - 1.5;\n        lightDir = RotateY(lightDir, -mouseTiltY);\n        lightDir = RotateX(lightDir, -mouseTiltX);\n        float term = smoothstep(0.4, 0.7, \n            pow(dot(normal, lightDir) * 0.5 + 0.5, 2.));\n        vec3 diffuse = mix(shadowColor, dCol, term);\n        float ndV = min(1., pow(\n            max(0., dot(normal, normalize(lightDir + -dir))), 50.));\n        float specTerm = smoothstep(0.8, 1., ndV) * isShiny;\n        col = diffuse + specTerm * lightColor;\n    }\n    float overlay = smoothstep(0.15, 1., 0.2 - dot(uv.y, 1.));\n    col = mix(col, lightColor, max(0., overlay));\n\n\tfragColor = vec4(col, d);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define EPSILON         1.0e-4\n#define MAX_RADIUS min(0.05, 16. * 4. + 6. / iResolution.y)\n\nfloat Max3(float a, float b, float c)\n{\n    return max(max(a, b), c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 original = texture(iChannel0, uv);\n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec4 c0 = texture(iChannel0, uv.xy - duv.xy);\n\tvec3 c1 = texture(iChannel0, uv.xy - duv.zy).rgb;\n\tvec3 c2 = texture(iChannel0, uv.xy + duv.zy).rgb;\n\tvec3 c3 = texture(iChannel0, uv.xy + duv.xy).rgb;\n\tfloat w0 = 1. / (Max3(c0.r, c0.g, c0.b) + 1.);\n\tfloat w1 = 1. / (Max3(c1.r, c1.g, c1.b) + 1.);\n\tfloat w2 = 1. / (Max3(c2.r, c2.g, c2.b) + 1.);\n\tfloat w3 = 1. / (Max3(c3.r, c3.g, c3.b) + 1.);\n\n\tvec3 avg = c0.rgb * w0 + c1 * w1 + c2 * w2 + c3 * w3;\n\tavg /= max(w0 + w1 + w2 + w3, EPSILON);\n\n\tfloat maxRadius = MAX_RADIUS / 0.15;\n    \n\tavg *= smoothstep(0., texel.y * 2., maxRadius);\n    fragColor = vec4(avg, original.a);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define EPSILON         1.0e-4\n#define MAX_RADIUS min(0.05, 16. * 4. + 6. / iResolution.y)\n#define saturate(x) clamp(x, 0., 1.)\nfloat Luminance(vec3 linearRgb)\n{\n\treturn dot(linearRgb, vec3(0.2126729, 0.7151522, 0.0721750));\n}\nfloat Luminance(vec4 linearRgba)\n{\n\treturn Luminance(linearRgba.rgb);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec4 original = texture(iChannel0, uv);\n    float margin = 8.;\n    float screenMargin = texel.y * 2.;\n    float depth = original.a;\n    vec4 blur;\n    \n    for (int i = 0; i < 16; i++)\n\t{\n        vec2 disk;\n        // this is ridiculous but it\n        // won't compile on mobile if I try\n        // to use an array!\n        if (i == 0) disk = vec2(0.,0.);\n        else if (i == 1) disk = vec2(0.54545456,0.);\n        else if (i == 2) disk = vec2(0.16855472,0.5187581);\n        else if (i == 3) disk = vec2(-0.44128203,0.3206101);\n        else if (i == 4) disk = vec2(-0.44128197,-0.3206102);\n        else if (i == 5) disk = vec2(0.1685548,-0.5187581);\n        else if (i == 6) disk = vec2(1.,0.);\n        else if (i == 7) disk = vec2(0.809017,0.58778524);\n        else if (i == 8) disk = vec2(0.30901697,0.95105654);\n        else if (i == 9) disk = vec2(-0.30901703,0.9510565);\n        else if (i == 10) disk = vec2(-0.80901706,0.5877852);\n        else if (i == 11) disk = vec2(-1.,0.);\n        else if (i == 12) disk = vec2(-0.80901694,-0.58778536);\n        else if (i == 13) disk = vec2(-0.30901664,-0.9510566);\n        else if (i == 14) disk = vec2(0.30901712,-0.9510565);\n        else if (i == 15) disk = vec2(0.80901694,-0.5877853);\n        \n\t\tvec2 disp = (disk * MAX_RADIUS) / margin;\n\t\tfloat dist = length(disp);\n\t\tfloat aspect = iResolution.x / iResolution.y;\n\t\tvec2 duv = vec2(disp.x * (1. / aspect), disp.y);\n\t\tvec3 samp = texture(iChannel0, uv.xy + duv).rgb;\n\n\t\tfloat avgD = (abs(duv.y) + abs(duv.x)) / 2.;\n\t\tfloat blurZone = max(0., min(avgD / depth, MAX_RADIUS / margin));\n\t\tfloat weight = saturate((blurZone - dist + screenMargin) / screenMargin);\n\t\tblur += vec4(samp.rgb, 1.) * weight;\n\t}\n\tblur.rgb /= max(blur.a, EPSILON);\n\tfloat lum = Luminance(original);\n\tfloat blend = saturate(blur.a) * step(0.01, lum) * step(lum, 1.);\n\tblur = mix(original, blur, blend);\n    fragColor = blur;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 129], [130, 130, 166, 166, 361], [362, 362, 419, 419, 1627]], "test": "untested"}
{"id": "NsVSzR", "name": "Planet - Jupiter", "author": "Zi7ar21", "description": "Trying to create a simple but faithful recreation of the beloved planet Jupiter.", "tags": ["procedural", "planet", "gasgiant", "gas", "jupiter", "giant"], "likes": 12, "viewed": 696, "published": 3, "date": "1634357982", "time_retrieved": "2024-07-30T18:55:31.767437", "image_code": "// ####### Planet - Jupiter #######\n// Made by Jacob Bingham (Zi7ar21) on October 16th, 2021\n\n// Last Updated on October 18th, 2021 at 12:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/NsVSzR\n\n// \"License\":\n// You can use this code in any way you want, as long as you keep credits to things that aren't mine\n// e.g. Triple32: https://nullprogram.com/blog/2018/07/31/\n// We are programmers, not lawyers! :)\n\n/*\nThis is my attempt at creating a simple but faithful recreation of the beloved planet Jupiter.\n*/\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n// peabrainiac\n// https://www.shadertoy.com/user/peabrainiac\n\n// ##### Constants #####\n\nconst float pi = 3.141592653589793;\n\n// ##### Parameters #####\n\n#define fov 0.5\n\n#define exposure 1.0\n\n// ##### Hashes #####\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p *= 0.1031;\n    p  = fract(p);\n    p *= p+33.33;\n    p *= p+p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n    p3 *= 0.1031;\n    p3  = fract(p3);\n    p3 += dot(p3, p3.zyx+31.32);\n    return fract( (p3.x+p3.y)*p3.z );\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n    p4 *= vec4(0.1031, 0.1030, 0.0973, 0.1099);\n    p4  = fract(p4);\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract( (p4.xxyz+p4.yzzw)*p4.zywx );\n}\n\n// ##### Additional Functions #####\n\nfloat dotp(vec2 vector) { return dot(vector, vector); }\nfloat dotp(vec3 vector) { return dot(vector, vector); }\nfloat dotp(vec4 vector) { return dot(vector, vector); }\n\nvec2 rotate(vec2 vector, float rotation)\n{\n    float s = sin(rotation), c = cos(rotation);\n    return vec2(vector.x*c-vector.y*s, vector.x*s+vector.y*c);\n}\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos( 2.0*pi*(c*t+d) );\n}\n\n// https://www.schemecolor.com/jupiter-planet-colors.php\nvec3 jupiter_palette(float t)\n{\n    const vec3 c0 = vec3( 64,  68,  54)/256.0; // #404436\n    const vec3 c1 = vec3(167, 156, 134)/256.0; // #A79C86\n    const vec3 c2 = vec3(210, 207, 218)/256.0; // #D2CFDA\n    const vec3 c3 = vec3(211, 156, 126)/256.0; // #D39C7E\n    const vec3 c4 = vec3(144,  97,  77)/256.0; // #90614D\n    const vec3 c5 = vec3(200, 139,  58)/256.0; // #C88B3A\n\n    vec3 interpolated_color =\n    t > 0.0/5.0 && t < 1.0/5.0 ? mix( c0, c1, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 1.0/5.0 && t < 2.0/5.0 ? mix( c1, c2, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 2.0/5.0 && t < 3.0/5.0 ? mix( c2, c3, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 3.0/5.0 && t < 4.0/5.0 ? mix( c3, c4, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    t > 4.0/5.0 && t < 5.0/5.0 ? mix( c4, c5, smoothstep( 0.0, 1.0, fract(t/5.0) ) ) :\n    vec3(0.0);\n\n    return interpolated_color;\n}\n\n// ##### Noise #####\n\nfloat noise(float p)\n{\n    float i = floor(p);\n    float f = fract(p);\n\n    float u = smoothstep(0.0, 1.0, f);\n\n    float h0 = hash11(i+0.0);\n    float h1 = hash11(i+1.0);\n\n    return mix(h0, h1, u);\n}\n\nfloat noise(vec3 p, int octave)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    vec2 h0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xy;\n    vec2 h7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xy;\n\n    /* // Not Spherically Uniform\n    vec3 v0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    vec3 v7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    */\n\n    vec2 r0 = vec2( 2.0*pi*h0.x, acos(2.0*h0.y-1.0) );\n    vec2 r1 = vec2( 2.0*pi*h1.x, acos(2.0*h1.y-1.0) );\n    vec2 r2 = vec2( 2.0*pi*h2.x, acos(2.0*h2.y-1.0) );\n    vec2 r3 = vec2( 2.0*pi*h3.x, acos(2.0*h3.y-1.0) );\n    vec2 r4 = vec2( 2.0*pi*h4.x, acos(2.0*h4.y-1.0) );\n    vec2 r5 = vec2( 2.0*pi*h5.x, acos(2.0*h5.y-1.0) );\n    vec2 r6 = vec2( 2.0*pi*h6.x, acos(2.0*h6.y-1.0) );\n    vec2 r7 = vec2( 2.0*pi*h7.x, acos(2.0*h7.y-1.0) );\n\n    vec2 s0 = sin(r0), c0 = cos(r0);\n    vec2 s1 = sin(r1), c1 = cos(r1);\n    vec2 s2 = sin(r2), c2 = cos(r2);\n    vec2 s3 = sin(r3), c3 = cos(r3);\n    vec2 s4 = sin(r4), c4 = cos(r4);\n    vec2 s5 = sin(r5), c5 = cos(r5);\n    vec2 s6 = sin(r6), c6 = cos(r6);\n    vec2 s7 = sin(r7), c7 = cos(r7);\n\n    vec3 v0 = vec3(c0.x*s0.y, s0.x*s0.y, c0.y);\n    vec3 v1 = vec3(c1.x*s1.y, s1.x*s1.y, c1.y);\n    vec3 v2 = vec3(c2.x*s2.y, s2.x*s2.y, c2.y);\n    vec3 v3 = vec3(c3.x*s3.y, s3.x*s3.y, c3.y);\n    vec3 v4 = vec3(c4.x*s4.y, s4.x*s4.y, c4.y);\n    vec3 v5 = vec3(c5.x*s5.y, s5.x*s5.y, c5.y);\n    vec3 v6 = vec3(c6.x*s6.y, s6.x*s6.y, c6.y);\n    vec3 v7 = vec3(c7.x*s7.y, s7.x*s7.y, c7.y);\n\n    float t0 = dot( v0, f-vec3(0.0, 0.0, 0.0) );\n    float t1 = dot( v1, f-vec3(1.0, 0.0, 0.0) );\n    float t2 = dot( v2, f-vec3(0.0, 1.0, 0.0) );\n    float t3 = dot( v3, f-vec3(1.0, 1.0, 0.0) );\n    float t4 = dot( v4, f-vec3(0.0, 0.0, 1.0) );\n    float t5 = dot( v5, f-vec3(1.0, 0.0, 1.0) );\n    float t6 = dot( v6, f-vec3(0.0, 1.0, 1.0) );\n    float t7 = dot( v7, f-vec3(1.0, 1.0, 1.0) );\n\n    return 0.5*(mix(mix(mix(t0, t1, u.x), mix(t2, t3, u.x), u.y), mix(mix(t4, t5, u.x), mix(t6, t7, u.x), u.y), u.z)+1.0);\n}\n\nvec3 distortion_noise(vec3 p, float t)\n{\n    const int octave = -1;\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    vec2 h0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xy;\n    vec2 h2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xy;\n    vec2 h4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xy;\n    vec2 h6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xy;\n    vec2 h7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xy;\n\n    /* // Not Spherically Uniform\n    vec3 v0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xyz;\n    vec3 v2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xyz;\n    vec3 v4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xyz;\n    vec3 v6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    vec3 v7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xyz;\n    */\n\n    vec2 r0 = vec2( 2.0*pi*h0.x, acos(2.0*h0.y-1.0) );\n    vec2 r1 = vec2( 2.0*pi*h1.x, acos(2.0*h1.y-1.0) );\n    vec2 r2 = vec2( 2.0*pi*h2.x, acos(2.0*h2.y-1.0) );\n    vec2 r3 = vec2( 2.0*pi*h3.x, acos(2.0*h3.y-1.0) );\n    vec2 r4 = vec2( 2.0*pi*h4.x, acos(2.0*h4.y-1.0) );\n    vec2 r5 = vec2( 2.0*pi*h5.x, acos(2.0*h5.y-1.0) );\n    vec2 r6 = vec2( 2.0*pi*h6.x, acos(2.0*h6.y-1.0) );\n    vec2 r7 = vec2( 2.0*pi*h7.x, acos(2.0*h7.y-1.0) );\n\n    vec2 s0 = sin(r0), c0 = cos(r0);\n    vec2 s1 = sin(r1), c1 = cos(r1);\n    vec2 s2 = sin(r2), c2 = cos(r2);\n    vec2 s3 = sin(r3), c3 = cos(r3);\n    vec2 s4 = sin(r4), c4 = cos(r4);\n    vec2 s5 = sin(r5), c5 = cos(r5);\n    vec2 s6 = sin(r6), c6 = cos(r6);\n    vec2 s7 = sin(r7), c7 = cos(r7);\n\n    vec3 v0 = vec3(c0.x*s0.y, s0.x*s0.y, c0.y);\n    vec3 v1 = vec3(c1.x*s1.y, s1.x*s1.y, c1.y);\n    vec3 v2 = vec3(c2.x*s2.y, s2.x*s2.y, c2.y);\n    vec3 v3 = vec3(c3.x*s3.y, s3.x*s3.y, c3.y);\n    vec3 v4 = vec3(c4.x*s4.y, s4.x*s4.y, c4.y);\n    vec3 v5 = vec3(c5.x*s5.y, s5.x*s5.y, c5.y);\n    vec3 v6 = vec3(c6.x*s6.y, s6.x*s6.y, c6.y);\n    vec3 v7 = vec3(c7.x*s7.y, s7.x*s7.y, c7.y);\n\n    /*\n    v0 = vec3(rotate(v0.xz, t), v0.y).xzy;\n    v1 = vec3(rotate(v1.xz, t), v1.y).xzy;\n    v2 = vec3(rotate(v2.xz, t), v2.y).xzy;\n    v3 = vec3(rotate(v3.xz, t), v3.y).xzy;\n    v4 = vec3(rotate(v4.xz, t), v4.y).xzy;\n    v5 = vec3(rotate(v5.xz, t), v5.y).xzy;\n    v6 = vec3(rotate(v6.xz, t), v6.y).xzy;\n    v7 = vec3(rotate(v7.xz, t), v7.y).xzy;\n    */\n\n    v0 = vec3(rotate(v0.xy, t), v0.z);\n    v1 = vec3(rotate(v1.xy, t), v1.z);\n    v2 = vec3(rotate(v2.xy, t), v2.z);\n    v3 = vec3(rotate(v3.xy, t), v3.z);\n    v4 = vec3(rotate(v4.xy, t), v4.z);\n    v5 = vec3(rotate(v5.xy, t), v5.z);\n    v6 = vec3(rotate(v6.xy, t), v6.z);\n    v7 = vec3(rotate(v7.xy, t), v7.z);\n\n    return mix(mix(mix(v0, v1, u.x), mix(v2, v3, u.x), u.y), mix(mix(v4, v5, u.x), mix(v6, v7, u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 p)\n{\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        value += atten*noise(scale*p, i);\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.0;\n    }\n\n    return value/accum;\n}\n\n// ##### Rendering #####\n\nstruct rayData {\n    float tMin;\n    float tMax;\n    bool hit;\n    bool expire;\n    vec3 normal;\n};\n\nrayData traceSphere(vec3 ro, vec3 rd, vec3 sphPos, float sphRad)\n{\n    rayData raycastOut;\n\n    raycastOut.tMin = -1.0;\n    raycastOut.tMax = -1.0;\n    raycastOut.hit = false;\n    raycastOut.expire = false;\n    raycastOut.normal = vec3(0.0);\n\n    vec3 oc = ro-sphPos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc)-sphRad*sphRad;\n    float h = b*b-c;\n\n    if(h < 0.0)\n    {\n        return raycastOut;\n    }\n\n    h = sqrt(h);\n\n    raycastOut.tMin = -b-h;\n    raycastOut.tMax = -b+h;\n    raycastOut.hit = true;\n    raycastOut.normal = normalize(ro+rd*raycastOut.tMin);\n\n    return raycastOut;\n}\n\nrayData process_hit(rayData raycast0, rayData raycast1)\n{\n    if(raycast0.hit)\n    {\n        if(raycast1.hit)\n        {\n            rayData raycastOut;\n\n            raycastOut.tMin = min(raycast0.tMin, raycast1.tMin);\n            raycastOut.tMax = max(raycast0.tMax, raycast1.tMax);\n\n            raycastOut.hit  = true;\n\n            raycastOut.expire  = false;\n\n            raycastOut.normal  = raycast0.tMin < raycast1.tMin ? raycast0.normal : raycast1.normal;\n\n            return raycastOut;\n        }\n\n        return raycast0;\n    }\n\n    return raycast1;\n}\n\nrayData trace(vec3 ro, vec3 rd)\n{\n    return traceSphere(ro, rd, vec3(0.0), 0.5);\n}\n\nvec3 skyColor(vec3 rd)\n{\n    return vec3(0.000, 0.000, 0.000);\n}\n\nfloat shade_point(vec3 ro, vec3 rd, vec3 normal, vec3 hitPos, vec3 lightPos)\n{\n    vec3 lightDir = lightPos-hitPos;\n    float lightIntensity = ( 1.0/max(dot(lightDir, lightDir), 0.001) );\n    lightDir = normalize(lightDir);\n\n    return max(dot(normal, lightDir), 0.0)*lightIntensity;\n}\n\nfloat shade_sun(vec3 ro, vec3 rd, vec3 normal, vec3 lightDir)\n{\n    return max(dot(normal, lightDir), 0.0);\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    rayData t = trace(ro, rd);\n\n    if(!t.hit)\n    {\n        return skyColor(rd);\n    }\n\n    vec3 hitPos = ro+rd*t.tMin;\n    vec3 normal = t.normal;\n\n    //vec3 lightPos = vec3( 2.0*sin(0.25*pi*iTime), 2.0, 2.0*cos(0.25*pi*iTime) );\n    vec3 lightPos = vec3(10.0, 0.0, 10.0);\n\n    //float lambert = 500.0*shade_point( ro, rd, normal, hitPos, lightPos);\n    float lambert = 3.0*shade_sun( ro, rd, normal, normalize(lightPos) );\n\n    vec3 surfacePos = normalize(hitPos);\n\n    float noise0 = fbm( 10.0*(vec3(rotate(surfacePos.xz, -0.005*2.0*pi*iTime), surfacePos.y).xzy) )-0.5;\n    float noise1 = fbm(  8.0*(vec3(rotate(surfacePos.xz,  0.001*2.0*pi*iTime), surfacePos.y).xzy)+(surfacePos.y*4.0*noise0) );\n    //float noise1 = fbm(  8.0*(vec3(rotate(surfacePos.xz,  0.001*2.0*pi*iTime), surfacePos.y).xzy)+distortion_noise(20.0*surfacePos, 0.125*2.0*pi*iTime) );\n    float noise2 = noise( (48.0*surfacePos.y)+(6.0*noise1) );\n\n    vec3 baseColor = vec3(noise2);\n    //vec3 baseColor = jupiter_palette(noise2)*noise2;\n\n    return baseColor*lambert;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    vec3 camPos = vec3(0.0, 0.0, 2.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 upvect = vec3(0.0, 1.0, 0.0);\n\n    if(iMouse.z > 0.0)\n    {\n        vec2 mouseUV = 2.0*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n        //camPos = vec3(mouseUV, 2.0);\n        camPos = vec3( 2.0*sin(2.0*pi*mouseUV.x), 2.0*mouseUV.y, 2.0*cos(2.0*pi*mouseUV.x) );\n    }\n\n    mat3 rotmat;\n\n    rotmat[2] = normalize(target-camPos);\n    rotmat[0] = normalize( cross(rotmat[2], upvect) );\n    rotmat[1] = cross(rotmat[0], rotmat[2]);\n\n    vec3 ro = camPos;\n    vec3 rd = normalize( rotmat*vec3(fov*uv, 1.0) );\n\n    vec3 color = radiance(ro, rd);\n\n    color = clamp(1.0-exp(-max(color, 0.0)*exposure), 0.0, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1044, 1085, 1108, 1108, 1199], [1201, 1242, 1265, 1265, 1377], [1379, 1420, 1442, 1442, 1594], [1633, 1633, 1658, 1658, 1688], [1689, 1689, 1714, 1714, 1744], [1745, 1745, 1770, 1770, 1800], [1802, 1802, 1844, 1844, 1957], [1959, 2000, 2051, 2051, 2091], [2093, 2150, 2181, 2181, 3044], [3068, 3068, 3090, 3090, 3269], [3271, 3271, 3304, 3304, 6170], [6172, 6172, 6212, 6212, 9375], [9377, 9377, 9396, 9396, 9669], [9798, 9798, 9864, 9864, 10396], [10398, 10398, 10455, 10455, 10957], [10959, 10959, 10992, 10992, 11042], [11044, 11044, 11068, 11068, 11108], [11110, 11110, 11188, 11188, 11395], [11397, 11397, 11460, 11460, 11506], [11508, 11508, 11541, 11541, 12586], [12588, 12588, 12645, 12645, 13485]], "test": "untested"}
{"id": "7dtXDs", "name": "Glass Tesseract", "author": "davidar", "description": "Subtractive blending of coloured cells of a tesseract. Use the mouse to rotate. Slight pause in movement is on the B4 Coxeter plane projection.", "tags": ["2d", "math", "4d", "tesseract", "hypercube", "polytope"], "likes": 14, "viewed": 530, "published": 3, "date": "1634351565", "time_retrieved": "2024-07-30T18:55:32.540372", "image_code": "#define PI 3.1415926536\n\nmat4 rot(float wx, float wy, float wz, float xy, float xz, float yz) {\n    mat4 result = mat4(cos(wx), 0, 0, -sin(wx),\n                       0, 1, 0, 0,\n                       0, 0, 1, 0,\n                       sin(wx), 0, 0, cos(wx)\n                       );\n    result *= mat4(1, 0, 0, 0,\n                   0, cos(wy), 0, -sin(wy),\n                   0, 0, 1, 0,\n                   0, sin(wy), 0, cos(wy)\n                   );\n    result *= mat4(1, 0, 0, 0,\n                   0, 1, 0, 0,\n                   0, 0, cos(wz), -sin(wz),\n                   0, 0, sin(wz), cos(wz)\n                   );\n    result *= mat4(cos(xy), -sin(xy), 0, 0,\n                   sin(xy), cos(xy), 0, 0,\n                   0, 0, 1, 0,\n                   0, 0, 0, 1\n                   );\n    result *= mat4(cos(xz), 0, -sin(xz), 0,\n                   0, 1, 0, 0,\n                   sin(xz), 0, cos(xz), 0,\n                   0, 0, 0, 1\n                   );\n    result *= mat4(1, 0, 0, 0,\n                   0, cos(yz), -sin(yz), 0,\n                   0, sin(yz), cos(yz), 0,\n                   0, 0, 0, 1\n                   );\n    return result;\n}\n\nfloat inQuad(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return smoothstep(2e-3, -2e-3, sdQuad(p, a, b, c, d)) +\n           smoothstep(2e-3, -2e-3, sdQuad(p, d, c, b, a));\n}\n\nvec3 colCell(vec2 p) {\n    return hsv2rgb(vec3(atan(p.y,p.x) / (2.*PI), 1, 0.3));\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 m = 2.0*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    if (iMouse.z <= 0.) m = vec2(0);\n\n    float t = 0.5 * smoothstep(0., 1., fract(0.1 * iTime));\n    mat4 R = rot(1.75*PI + m.x, 1.5*PI + m.y, PI*(1.25 + 2.*t), PI*(0.5 + 3.*t), PI*(1.75 + 5.*t), PI*(1. + 7.*t));\n    vec3 col = vec3(0);\n\n    #define H vec3(0.5, -0.5, 0)\n    #define FACE(i0,i1,i2,i3) mask += inQuad(xy, (R*H.i0).xy, (R*H.i1).xy, (R*H.i2).xy, (R*H.i3).xy);\n    #define FACExx(idx) FACE(xxxx.idx, xxxy.idx, xxyy.idx, xxyx.idx)\n    #define FACExy(idx) FACE(xyxx.idx, xyxy.idx, xyyy.idx, xyyx.idx)\n    #define FACEyx(idx) FACE(yxxx.idx, yxxy.idx, yxyy.idx, yxyx.idx)\n    #define FACEyy(idx) FACE(yyxx.idx, yyxy.idx, yyyy.idx, yyyx.idx)\n\n    #define CELLx(idx) { \\\n        float mask = 0.; \\\n        FACExx(xyzw.idx); FACExx(xzyw.idx); FACExx(xzwy.idx); \\\n        FACExy(xyzw.idx); FACExy(xzyw.idx); FACExy(xzwy.idx); \\\n        col += clamp(mask, 0., 1.) * colCell((R*H.xzzz.idx).xy); \\\n    }\n    #define CELLy(idx) { \\\n        float mask = 0.; \\\n        FACEyx(xyzw.idx); FACEyx(xzyw.idx); FACEyx(xzwy.idx); \\\n        FACEyy(xyzw.idx); FACEyy(xzyw.idx); FACEyy(xzwy.idx); \\\n        col += clamp(mask, 0., 1.) * colCell((R*H.yzzz.idx).xy); \\\n    }\n\n    CELLx(xyzw);\n    CELLy(xyzw);\n    CELLx(yxzw);\n    CELLy(yxzw);\n    CELLx(yzxw);\n    CELLy(yzxw);\n    CELLx(yzwx);\n    CELLy(yzwx);\n\n    fragColor = vec4(sqrt(1. - col), 1);\n}", "image_inputs": [], "common_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a quad.\n//\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n//\n// Gradient of a quad here: https://www.shadertoy.com/view/WtVcD1\n\n\n// signed distance to a 2D quad\nfloat sdQuad( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 e0 = p1 - p0; vec2 v0 = p - p0;\n\tvec2 e1 = p2 - p1; vec2 v1 = p - p1;\n\tvec2 e2 = p3 - p2; vec2 v2 = p - p2;\n\tvec2 e3 = p0 - p3; vec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n    \n    vec2 ds = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                        vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                   min( vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ),\n                        vec2( dot( pq3, pq3 ), v3.x*e3.y-v3.y*e3.x ) ));\n\n    float d = sqrt(ds.x);\n\n\treturn (ds.y>0.0) ? -d : d;\n}\n\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Somehow optimized HSV and HSL to RGB conversion functions. \n\n//========================================================================\n\nconst float eps = 0.0000001;\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + eps)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              // H\n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + eps),  // S\n                 (minc+maxc)*0.5 );                           // L\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 95, 95, 1156], [1158, 1158, 1212, 1212, 1333], [1335, 1335, 1357, 1357, 1418], [1424, 1424, 1479, 1479, 2948]], "test": "untested"}
{"id": "NdtXDf", "name": "Segment Simplex Grid #5", "author": "Yusef28", "description": "It's just about the idea in this one so I'm not worrying about efficiency.", "tags": ["simplex"], "likes": 16, "viewed": 352, "published": 3, "date": "1634349304", "time_retrieved": "2024-07-30T18:55:33.487837", "image_code": "#define FAR 30.\n\n/*\nThe code is still not cleaned up here so good luck!\n*/\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    p/=1.9;\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    //f += 0.1250*noise( p ); p = m*p*2.01;\n    //f += 0.0625*noise( p ); \n    return f*1.3;\n}\n\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 snoise3( in float x )\n{\n#if 1    \n    return -1.0 + 2.0*textureLod( iChannel2, vec2(x,4.5)/256.0, 0.0 ).xyz;\n#else    \n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return -1.0 + 2.0*mix( hash3(p+0.0), hash3(p+1.0), f );\n#endif    \n}\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat seggy( vec3 P, vec3 A, vec3 B){\n    \n    //dist auf line segment zu punkt\n    //nahrest dist auf line zu punkt\n    //P = A + t*(B-A);\n    //dot((P-P3),(B-A)) = 0\n    //(A+t*(B-A)-P3)*(B-A)) = 0;\n    //A*(B-A)+t*(B-A)*(B-A)-P3*(B-A) = 0\n    //A*(B-A) - P3*(B-A) + t*(B-A)*(B-A)\n    //(A-P3)*(B-A) + t*(B-A)*(B-A)\n    //t = dot((A-P3),(B-A)) / dot((B-A),(B-A));\n    vec3 AP = P-A;\n    vec3 BA = B-A;\n    \n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n                    \n    vec3 P3 = A + t*BA;                \n    float dist = length(P - P3) - 0.02;\n    return dist;\n}\n\n\nvec2 planeVonTri(vec3 p, vec3 A, vec3 B, vec3 C){\n    \n    vec3 BA = A - B;\n    vec3 CA = A - C;\n    vec3 n  = normalize(cross(BA,CA));\n    //where is the intersection of line and plane?\n    //plane = dot(n,P) = 0\n    //line = ro + rd*t = P\n    float t = dot(n,p-A);\n    \n    //dist from point to line AB, BC, and CA\n    float dAB = length(cross(p-A, B-A));\n    float dBC = length(cross(p-B,C-B));\n    float dCA = length(cross(p-C, A-C));\n\n    //I'm pretty certain there is an easier way to do this\n    //I'l have to experiment with it later\n    float edgeLines = min(\n        abs(dAB - dBC)/(1.-float(dCA < min(dAB,dBC))),\n    min(abs(dBC - dCA)/(1.-float(dAB < min(dBC,dCA))),\n        abs(dCA - dAB)/(1.-float(dBC < min(dCA,dAB)))\n        ));\n\n                      \n    float bumpLines = min(dAB,min(dBC,dCA));\n    \n    float oppLines = max(dAB,max(dBC,dCA));\n    float distCenter = bumpLines;\n    float planeHeight = t + distCenter/1.8;\n    if(distCenter == dAB) planeHeight += sin(distCenter*130.)/400. ;\n \n return vec2(planeHeight, edgeLines*2.);\n \n}\n\n\nmat2 rot(float a){\n    float cs = cos(a),si = sin(a);\n    return mat2(cs, si, -si, cs);\n}\n\n\nfloat objectID = 0.;\nfloat glow = 0.;\n\n//FROM DAVE HOSKINS\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//FROM DAVE HOSKINS\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 objColGlobal = vec3(0.);\n\nfloat map(vec3 p){\n\n    \n    p *= 0.9;   \n    \n    p.xz *= mat2(1.1547, 0., 1.1547*0.5,1.);\n    float sphere_radius = 0.35;\n    vec3 sp = p;\n   // sp.y -= 0.23;\n    //float k = length(sp) - sphere_radius;\n    float alle = 100.;\n    //sp = p;\n    \n\n    //sp.y += 0.5;\n    //sp.xz *= rot(sp.y*3.);\n    \n    \n    \n    \n    sp.xz = fract(p.xz)-0.5;\n    vec2 id = floor(p.xz);\n    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);\n    float t = 0.;//iTime;\n    \n    float gross = 1.3;\n    \n    float height = fbm4(id+t)*gross;\n    float heightL = fbm4((id + vec2(0.,1.))+t)*gross;\n    float heightR = fbm4((id + vec2(0.,-1.))+t)*gross;\n    float heightV = fbm4((id + vec2(-1.,0.))+t)*gross;\n    float heightH = fbm4((id + vec2(1.,0.))+t)*gross;\n    \n    \n    float k = seggy(sp, vec3(0.,height,0.), vec3(-1.,heightV,0.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0., heightL,1.0));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0.,heightR,-1.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(1.0,heightH,0.0));\n    alle = smin(alle, k, 0.);\n    \n    //k = length(sp - vec3(0.,height,0.))-0.03-ball_gross*0.037;\n    //alle = smin(alle, k, 0.);\n    \n    //k = seggy(sp - vec3(id.x, height, id.y), vec3(id.x, height, id.y), \n    //                   vec3(0.0,0.,0.0));\n    //alle = smin(alle, k, 0.);\n    \n    vec3 st = p;\n    \n    //this screwed me up for a (h)while\n   // st.y += 0.5;\n    \n    //HERE:\n    //I create a new shifted coord system so that I can get \n    //that pesky diagonal segment\n    st.xz = fract(p.xz-0.5)-0.5;\n    vec2 id2 = floor(p.xz-0.5);\n    \n    \n    //for floor here, actually:\n    //the mid point is the + 0.5,0.5\n    //the bottom is 0,0 because that is the floor value, id\n    //and the top would have to be + 1.,1.\n    \n    float heightDB = fbm4(id2 +t)*gross;\n    float heightDT = fbm4(id2 + vec2(1.) +t)*gross;\n    \n    /////\n    float heightTLT = fbm4(id2 + vec2(0.,1.) +t)*gross;\n    float heightBRB = fbm4(id2 + vec2(1.,0.) +t)*gross;\n    \n    //float heightMD = fbm4(id2 - vec2(0.5))*gross;\n    \n    //THE DIAGONAL!!\n    k = seggy(st, vec3(-0.5, heightDB, -0.5), \n                  vec3( 0.5, heightDT,  0.5) );\n                  \n    alle = smin(alle, k, 0.);\n    \n    //check which side of the diagonal of the square we are on\n    //and make a plane with the three coordinates of that triangle\n    \n    vec2 pl = st.x < st.z \n    \n                         ?\n                        \n               planeVonTri(st,\n                     vec3( 0.5, heightDT,  0.5),\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3(-0.5, heightTLT, 0.5) )\n                     \n                         : \n                        \n               planeVonTri(st,\n                     //you need to have this exact order for A,B and C!\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3( 0.5, heightDT,  0.5),\n                     \n                     vec3( 0.5, heightBRB, -0.5) );\n    \n    //calculate colors\n    float colID = hash12(floor(p.xz - 0.5) + sign(st.x-st.z)*80.)+0.2;\n    objColGlobal = 0.5+0.5*cos(vec3(colID*0.1,colID*0.4,colID) + vec3(2.,5.,5.)/4. + colID*80.)/1.5;\n    \n    //fake ambient occlusion in the holes here.\n    objColGlobal = mix(objColGlobal, \n                   objColGlobal*.82, \n                   smoothstep(0.2,0.02,pl.y)*4.);\n    \n    //kind of a Shane x Nusan hybrid ID check\n    if(pl.x < 0.005){\n       // glow += 0.0001/pow(pl,0.2);\n        objectID = 1.;   \n    }\n  // if(objColGlobal.x > 2.) glow += 0.0005/pow(pl.x,2.);\n    alle = min(alle, pl.x);\n\n   //\n   //alle = min(alle, length(st)-0.15);\n    return alle;// min(alle, sp.y+0.7-fbm4(p.xz));\n    \n}\n\n//FROM SHANE\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        //low step to get rid of artifacts on object ids\n        t += d*.85;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n//FROM SHANE\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n//FROM SHANE?\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nvec3 triPlanar(vec3 p, vec3 n){\n    n = max(abs(n), 0.001);\n    vec3 tex = vec3(texture(iChannel1,p.xy).rgb*n.z +\n                    texture(iChannel1,p.yz).rgb*n.x +\n                    texture(iChannel1,p.xz).rgb*n.y\n                    );\n                    \n    return tex;\n}\n//FROM SHANE!\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = objectID == 1.    ? \n    objColGlobal*triPlanar(sp,sn).x :\n    vec3(.5)*0.7;\n    //objCol = objectID == 2. ? vec3(1.) : \n      //    objCol;//getObjectColor(sp);\n   // if(objectID == 2.) objCol = vec3(1.);\n    \n    float specFact = objectID == 1. ? 8. : 6.;\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff*8. ) + vec3(.8, .5, .2)*spec*specFact) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, pow(t/FAR,5.));\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n   // sceneCol = glow*0.2;\n    sceneCol = mix(sceneCol, vec3(0.), fogF); \n\n    //sceneCol = mix(sceneCol, sceneCol + glow*0.2, clamp(.2-fogF,0.,1.)); \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.yz *= rot(-0.5);\n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    //rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    //rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 4. + sin(iTime)*0.1, -4.5 + iTime*1.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 2., 3.5);\n    \n    vec3 sceneColor;\n    float t = trace(ro, rd);\n    //sceneColor = mix(sceneColor, vec3(0.3,0.051,0.), clamp(pow(t/FAR, 20.),0.,1.));\n    if(t < FAR){\n    ro += rd*t;\n    vec3 sn = getNormal(ro);\n    sceneColor = doColor(ro, rd, sn, lp, t);\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n    ///sceneColor += \n    sceneColor *= sh;\n    //sceneColor += glow;\n    }\n    else{\n    \n    sceneColor = vec3(0.);//texture(iChannel1,rd).xyz*0.51;\n\n    }\n    \n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0;\n    \n    vig = pow(vig, 0.15);\n    \n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor*vig, 0., 1.)), 1);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi acos(-1.)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 154, 154, 183], [185, 185, 207, 207, 417], [420, 420, 443, 443, 537], [539, 539, 567, 567, 808], [809, 809, 860, 860, 967], [968, 968, 1008, 1008, 1115], [1116, 1116, 1156, 1156, 1263], [1264, 1264, 1301, 1629, 1886], [1889, 1889, 1938, 1938, 2945], [2948, 2948, 2966, 2966, 3037], [3100, 3119, 3141, 3141, 3258], [3259, 3279, 3301, 3301, 3426], [3459, 3459, 3477, 3477, 7215], [7217, 7230, 7260, 7260, 7567], [7569, 7582, 7626, 7743, 9040], [9042, 9056, 9083, 9083, 9240], [9242, 9242, 9273, 9273, 9523], [9524, 9538, 9608, 9608, 11141], [11142, 11142, 11198, 11226, 12758]], "test": "untested"}
{"id": "7dVSRh", "name": "QuadTree Traversal [Commented]", "author": "Yusef28", "description": "It's commented but messy. I'll put up a way shorter version later that should be clearer.\nI only use euclidean distance no step size moves. I guess there could be a fully integer version if we made each level's cell size an int power of 2", "tags": ["commented", "quadtree", "traversal"], "likes": 41, "viewed": 1259, "published": 3, "date": "1634348671", "time_retrieved": "2024-07-30T18:55:34.250798", "image_code": "/* \n   This leads directily into my 3D version (Octree):\n   https://www.shadertoy.com/view/fdyXDR\n   \n   \n   SPOILERS:\n\n   The Basic Idea\n    \n   It might not be obvious from this code as it's a bit\n   convoluted, but there are three main concepts\n   \n   Quadtrees, DDA algorithms, and traversing a grid\n   \n   Together it is traversing a quadtree grid with a modified dda algo\n   \n   1. \n   \"Build the quad tree\" which really is just running that\n   space partitioning until a random stop level for each pixel\n   in a given cell at that level. \n   I can paint the quatree to final color using just the ending level \n   or the ending scale\n   \n   Important is this returns the cellsize (1./levelScale)\n  \n   2. \n   Most dda algos have an intialization phase where you have to snap\n   the start position to the nearest axis in the rd direction. I use\n   cellSize to calculate that based on the cellsize of the level the ro \n   is in, in the quadtree. Thats just a slight modification from the\n   fixed cellsize dda algorithm in lodev's tutorial. I scale the\n   ro, floor(ro), ceil(ro) by 1./cellSize to get to the local uv of the\n   quadtree, do the subtraction to get dist to nearest wall of that cell,\n   and then scale by cellSize to get back to global coordinates.\n   This dda initialization gives us the t value (euclidian distance)\n   to the nearest axis in the quadtree.\n   \n   3. \n   Carrying on from step two I basically do the same thing at every \n   step as I step through with t values based on current cell size,\n   and then calculate new t values and make new steps. I paint green \n   dots at every iteration.\n   \n   -----------------------------\n   \n   I have a version now that is a lot more simple.\n   It has just one quadtree function, since having a \n   quadtree and then a \"map\" that does almost the same is\n   redundant. There are also variables that are unessesary, \n   and some parts of the code can be branchless and some can\n   take advantage of the componentwise operations of min,max,abs,etc\n   more.\n        \n    \n   Random Note \n   \n   ------------\n   \n   Nudging the current position a bit in the ray direction was critical\n   otherwise we remain at the last floor value and the calculations\n   of t values in my code depend on that not being the case\n   \n   Another option might have been subtracting the cellsize of that\n   level by the result so that if the result was 0 (meaning\n   we were infact on a boundary, we would get a full cellsize instead of 0.\n   This wasn't nessesary though\n   \n   \n  \n*/\n\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define MAX_LEVEL 6.\n#define debugCoord vec2(-1.,0.)\n#define debug 1.\n#define globalScale 2.\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n//  1 out, 2 in...\nfloat rnd(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Drawing stuff\nfloat drawPoint(vec2 uv, vec2 p, float r){\n    float c = length(uv - p);\n    float ss = eps * 4.;\n    c = 1.-smoothstep(r-ss, r+ss, c);\n  return c;\n}\n//Drawing stuff\nfloat distLine(vec2 p, vec2 A, vec2 B){\n    vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n//Drawing stuff\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    float ss = eps*3.;\n    float d = distLine(uv,A,B);\n    d = smoothstep(r+ss, r-ss, d);\n  return d;\n}\n\n//The map that partitions space until we reach the level\n//where the hash of the cellID gives back a value < 0.5\nfloat map(vec2 pos){\n  \n  vec2 localUV;\n  vec2 cellID;\n  float currentCellSize = 2.;// ?\n  float s = 1.;\n\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    \n      localUV = s * pos;\n      cellID = floor(localUV);\n      float rndID = rnd(cellID);\n\n      \n      s *= 2.;\n    \n    //starting cellSize at 2 because we only break after dividing by 2.\n     currentCellSize /=2.;\n    //divide by 2 AFTER currentCellSize because otherwise you don't\n    //calculate the steps properly at the random exit points\n    if( rndID < 0.5 ) break;\n  }\n  //give back cellsize, that's critical\n  return currentCellSize;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n  \n  vec3 col = vec3(0.);\n  uv *= globalScale;\n  \n  //step 1. Quad Tree ----------------------------------------\n  \n  //way too many variables for a quatree \n  vec2 globalUV = uv;\n  vec2 localUV = uv;\n  float level = 0.;\n  vec2 cellUV;\n  vec2 cellID;\n  float currentCellSize = 1.;\n  float s = 1.;\n  float extraLevel = float(floor(uv) == debugCoord)*debug;\n  \n  \n  \n  //if( max( abs(uv.x), abs(uv.y) ) > currentCellSize)\n  for(float i = 1.; i < MAX_LEVEL; i++){\n      level++;\n      localUV = s * globalUV;\n      cellUV = fract(localUV);\n      cellID = floor(localUV);\n    \n     //interessant float rndID = rnd(vec2(cellID.x,0.));\n      float rndID = rnd(cellID);\n    \n      if( max(abs(cellUV.x-0.5),\n           abs(cellUV.y-0.5) ) > 0.49-s/200.) {\n               level = 0.;\n               break;\n             }\n             \n     if( rndID < 0.5 ) break;\n     s *= 2.;\n     //currentCellSize /=2.;\n             \n  }\n  \n  \n  //drawing the quad tree\n  col = vec3(level/MAX_LEVEL);\n  \n  \n  \n  //Step 2. Ray and DDA Initialize  //------------------------------------\n  \n  \n  //starting a new section of initializing\n  //(maybe for this one we'll go simplified\n  //so start point is always 0,0\n  \n  vec2 ro = vec2(sin(iTime/8.)*.25,cos(iTime/8.)*.25);\n  vec2 rd = vec2(-1.,0.);\n  rd *= rot(iTime/4.);\n  float lineLength = 4.*globalScale;\n  \n  //drawing the ray\n  col=mix(col, vec3(1.,0.,0.), drawPoint(uv, ro, 0.02));\n  col=mix(col, vec3(1.,0.,0.), drawLine(uv, ro, ro+rd*lineLength, 0.014));\n  col=mix(col, vec3(1.,0.,0.), drawPoint(uv, ro+rd*lineLength, 0.02));\n  col=mix(col, vec3(0.,1.,0.), drawPoint(uv, ro, 0.02));\n  \n  //get delta (from lodev raycasting tutorial\n  vec2 delta;\n       delta.x  = abs(rd.x) < eps ? 1e30 : abs(1./rd.x);\n       delta.y  = abs(rd.y) < eps ? 1e30 : abs(1./rd.y);\n \n  \n  \n  //this would only evaulate the first level of the quad tree no matter where the ro\n  //was. \n  //We need to replace t with the distance to the first cell regardless of size\n  //to do that we need to find the distance from ro to that \n  \n  //This right here is the final cellsize for the ro position in the tree\n  float cellSize = map(ro);\n  \n  \n  //get the initial t value (basic version of this is in the lodev tutorial)\n  //I use \"cellSize\" to transform the ro back to the local coordinates and get what the difference\n  //would be locally which is how we get the initial t value in any level of the quadtree\n  \n  vec2 tStart;\n  tStart.x = rd.x < 0. ? ( ro.x/cellSize - floor(ro.x/cellSize) ) * cellSize * delta.x \n                           : ( ceil(ro.x/cellSize) - ro.x/cellSize ) * cellSize * delta.x;\n                           \n  tStart.y = rd.y < 0. ? ( ro.y/cellSize - floor(ro.y/cellSize) ) * cellSize * delta.y \n                           : ( ceil(ro.y/cellSize) - ro.y/cellSize ) * cellSize * delta.y;\n  \n \n //we'll hit the closest axis first\n  float tCurr = min(tStart.x,tStart.y);\n  vec2 currentPos;\n  vec2 tNext;\n  \n  \n  //Step 3. Running the Modified DDA---------------------------------------\n  \n  \n  for( float i = 0.; i < 30.; i++ ){\n     \n    currentPos = ro + rd*tCurr*1.01;//this slight nudge in the rd direction is critical\n    //without it, you are stuck on the floor values\n    //if it's too low, like 1.00001 you get too much flickering\n    \n    col=mix(col, vec3(0.,1.,0.), drawPoint(uv, currentPos, 0.02));\n    \n    float newSize = map(currentPos);\n    \n    //because I nudge a bit along the rd direction, the currentPos\n    //is never on an axis, so these calculations work fine. Otherwise\n    //I'd need something like what I mentioned at the top.\n    \n    tNext.x = rd.x < 0. ? ( ( currentPos.x/newSize - floor(currentPos.x/newSize)) * newSize ) * delta.x \n                        : (  ( ceil(currentPos.x/newSize) - currentPos.x/newSize ) * newSize ) * delta.x;\n    \n    tNext.y = rd.y < 0. ? (( currentPos.y/newSize - floor(currentPos.y/newSize))  * newSize ) * delta.y \n                        : ( ( ceil(currentPos.y/newSize) - currentPos.y/newSize)  * newSize ) * delta.y;\n    \n    \n    tCurr += min(tNext.x, tNext.y);\n    \n  } \n \n\tfragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2680, 2680, 2698, 2698, 2756], [2762, 2781, 2800, 2800, 2917], [2919, 2935, 2977, 2977, 3084], [3085, 3101, 3140, 3140, 3259], [3260, 3276, 3325, 3325, 3429], [3431, 3544, 3564, 3564, 4141], [4142, 4142, 4199, 4249, 8410]], "test": "untested"}
{"id": "7sKSRh", "name": "An Error Function Approximation", "author": "oneshade", "description": "An approximation of the error function erf(x) based on the fact that erf(x)^2 looks very similar to a gaussian distribution (bell curve).\nOrange: graphical approximation\nBlue: numerically integrated", "tags": ["erf", "errorfunction", "specialfunction", "gaussianintegral"], "likes": 13, "viewed": 261, "published": 3, "date": "1634344924", "time_retrieved": "2024-07-30T18:55:35.013758", "image_code": "#define draw(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n#define PI 3.14159265359\n#define K (2.0 / sqrt(PI))\n\n// Graphical approximation\nfloat erf(in float x) {\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\n\n// Numerically integrated\nfloat erf2(in float x) {\n    float a = abs(x), y = 0.0;\n    float dt = a / 250.0;\n    for (float t=0.0; t < a; t += dt) y += exp(-t * t) * dt;\n    return K * sign(x) * y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Draw the function (alternating between graphical approximation and numerical integration)\n    float dx = K * exp(-uv.x * uv.x);\n    if (mod(iTime, 4.0) < 2.0) draw(abs(uv.y - erf(uv.x)) / sqrt(1.0 + dx * dx) - 0.01, vec3(1.0, 0.5, 0.0));\n    else draw(abs(uv.y - erf2(uv.x)) / sqrt(1.0 + dx * dx) - 0.01, vec3(0.0, 0.5, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 158, 181, 240, 337], [339, 365, 389, 389, 537], [539, 539, 594, 594, 1351]], "test": "untested"}
{"id": "NdVSR1", "name": "newton's fractal", "author": "thacks42", "description": "simple implementation of newtons fractal\nFun fact: this works without evaluating the polynomial and its derivative.\nInstead it relies on the logarithmic derivative of the polynomial.\nThe newton iteration step can thus be calculated directly from the roots", "tags": ["fractal", "newton", "rootfinding", "polynom"], "likes": 1, "viewed": 363, "published": 3, "date": "1634329068", "time_retrieved": "2024-07-30T18:55:35.809630", "image_code": "#define no_roots 4\n#define anti_alias 1\n#define no_iterations 15\n\nvec2 complex_reciprocal(vec2 z){ //computes 1/z\n    float div = z.x * z.x + z.y * z.y;\n    float div_r = 1.0f / div;\n    vec2 result = vec2(z.x * div_r, -z.y * div_r);\n    return result;\n}\n\n/*\n * Newton-rhapsody based root finding:\n * x_n+1 = x_n - f(x)/f'(x)\n * \n * interestingly the reciprocal of f(x)/f'(x) is the logarithmic derivative:\n * d/dx ln( f(x) ) = f'(x) / f(x)\n * \n * If we think of the polynomial in terms of its roots we have:\n * \n * P(x) = (x - x1) * (x - x2) * ... * (x - xn)\n * thus d/dx ln( P(x) ) = d/dx ln[ (x - x1) * (x - x2) * ... * (x - xn) ]\n * = d/dx [log(x - x1) + log(x - x2) + ... + log(x - xn)]\n * = 1/(x - x1) + 1/(x - x2) + ... + 1/(x - xn)\n * \n * which means that the reciprocal of this sum is equal to f(x)/f'(x)\n * So we can compute the newton iteration step directly from the zeros of our polynomial.\n * \n */\nvec2 newton_iteration(vec2 z, const vec2 roots[no_roots]){\n    vec2 sum = vec2(0.0f);\n    for(int i = 0; i < no_roots; i++){\n        vec2 delta = vec2(z.x - roots[i].x, z.y - roots[i].y); //calculate x - x0\n        float div = delta.x * delta.x + delta.y * delta.y;     //calculate the divisior for calculating the complex reciprocal\n        if(div < 0.0001f){                                     //if the divisor is close to zero, we've already found a root.\n            return z;\n        }\n        float div_r = 1.0f/div;\n        vec2 complex_reciprocal_delta = vec2(delta.x * div_r, -delta.y * div_r); //calculate the complex reciprocal\n        sum += complex_reciprocal_delta;                      //add the complex reciprocal to our sum\n    }\n    vec2 result = complex_reciprocal(sum);                    //calculate the complex reciprocal of the sum\n    return z - result;                                        //do the newton \"step\"\n}\n\nint find_closest_root(vec2 z, const vec2 roots[no_roots]){\n    int index = 0;\n    float dist = 10000.0f;\n    for(int i = 0; i < no_roots; i++){\n        float dx = (z.x - roots[i].x);\n        float dy = (z.y - roots[i].y);\n        float d = dx * dx + dy * dy;\n        if(d < dist){\n            dist = d;\n            index = i;\n        }\n    }\n    return index;\n}\n\nvec2 calculate_coord(vec2 c){\n    vec2 normalized_coord = c/iResolution.xy;\n    float t = iTime;\n    normalized_coord -= vec2(0.5f) + vec2(sin(t*0.1f)*0.3f, cos(t*0.1f)*0.3f);\n    normalized_coord *= 3.0 - cos(t*0.2)*2.0f;\n    return normalized_coord;\n}\n\nvec3 sample_no_AA(vec2 c, vec2 roots[no_roots], vec3 colors[no_roots]){\n    vec2 z1 = calculate_coord(c);\n    for(int i = 0; i < no_iterations; i++){\n        z1 = newton_iteration(z1, roots);\n    }\n    int index1 = find_closest_root(z1, roots);\n    \n    vec3 col = colors[index1];\n    return col;\n}\n\nvec3 sample_AA(vec2 c, vec2 roots[no_roots], vec3 colors[no_roots]){\n    vec2 z1 = calculate_coord(c + vec2( 0.114f, -0.377f));\n    vec2 z2 = calculate_coord(c + vec2( 0.351f,-0.105f));\n    vec2 z3 = calculate_coord(c + vec2(-0.123f,0.342f));\n    vec2 z4 = calculate_coord(c + vec2(-0.360f, -0.140f));\n    for(int i = 0; i < no_iterations; i++){\n        z1 = newton_iteration(z1, roots);\n        z2 = newton_iteration(z2, roots);\n        z3 = newton_iteration(z3, roots);\n        z4 = newton_iteration(z4, roots);\n    }\n    int index1 = find_closest_root(z1, roots);\n    int index2 = find_closest_root(z2, roots);\n    int index3 = find_closest_root(z3, roots);\n    int index4 = find_closest_root(z4, roots);\n    \n    vec3 col = colors[index1] + colors[index2] + colors[index3] + colors[index4];\n    col /= 4.0f;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime;\n    vec2 roots[no_roots] = vec2[no_roots](\n                                 vec2(1.1f  + 0.326f * cos(t*0.162f), -1.4f + 0.25f * sin(t*0.072f)),\n                                 vec2(1.2f  + 0.217f * sin(t*0.417f),  1.9f + 0.43f * cos(t*0.109f)),\n                                 vec2(-1.3f + 0.421f * cos(t*0.481f),  1.3f + 0.51f * sin(t*0.542f)),\n                                 vec2(-1.7f + 0.517f * sin(t*0.378f), -1.5f + 0.67f * cos(t*0.379f)));\n    \n    const vec3 colors[no_roots] = vec3[no_roots](\n                                  vec3(0.098f, 0.521f, 0.56f),\n                                  vec3(0.290f, 0.043f, 0.345f),\n                                  vec3(0.122f, 0.627f, 0.812f),\n                                  vec3(0.345f, 0.722f, 0.369f));\n    \n    \n    vec3 col;\n    if(anti_alias == 1){\n        col = sample_AA(fragCoord, roots, colors);\n    }\n    else{\n        col = sample_no_AA(fragCoord, roots, colors);\n    }\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVSR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 98, 113, 254], [256, 912, 970, 970, 1854], [1856, 1856, 1914, 1914, 2217], [2219, 2219, 2248, 2248, 2472], [2474, 2474, 2545, 2545, 2772], [2774, 2774, 2842, 2842, 3603], [3605, 3605, 3659, 3659, 4652]], "test": "untested"}
{"id": "fdVXRh", "name": "angular lines", "author": "FabriceNeyret2", "description": "drawing polylines with angular junctions.\nMouse control.", "tags": ["lines"], "likes": 13, "viewed": 455, "published": 3, "date": "1634326997", "time_retrieved": "2024-07-30T18:55:36.575582", "image_code": "#define S(v) smoothstep( 3./R.y, 0., (v) -.07 )\n\nfloat line0(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b);   // proj coord on line\n    return length(p - b * h);          // dist to segment\n}\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b);   // proj coord on line\n    h = clamp(h, 0.,1.);               // round end\n    return length(p - b * h);          // dist to segment\n}\n \nvec2 P,_D,D, M;\n// #define L(B)  v = min( v, line(U,P,B) ); P = B;  // rounded lines \n#define L(B)  v = min( v, line(U,P,B) );                                        \\\n              _D = D; D = normalize(B-P); M = _D+D;                             \\\n              if (dot(U-P,D) < 0. && dot(U-P,_D) > 0. )                         \\\n                 v = min( v, dot(U-P,M) < 0. ? line0(U,P-_D,P) : line0(U,P,B)); \\\n              P = B; \n#define L0(A) P = A; D = vec2(0);\n\n             \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y ;   \n    \n    float a, v = 99.;\n    L0( vec2(-1.5,.7) ); \n    L( vec2(-1,-.5)+.4*cos(iTime+vec2(0,33)) ); \n    L( vec2(1.2,.7) ); L( vec2(.5,-.75) ); L( vec2(1.5,-.3) );\n    L( ( 2.*iMouse.xy - R ) / R.y );\n\n                 // bg  line pattern    line mask    \n    O = vec4(  mix( .5, S( v+2./R.y) , a = S( v ) ) );\n    v = max(0.,cos(.5*R.y*v)-.5); if (a==0.) O.b += v; else O.gb -= v; // show distance field\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 85, 85, 227], [228, 228, 263, 263, 457], [945, 945, 983, 983, 1457]], "test": "untested"}
{"id": "NdtSDf", "name": "newton raphson", "author": "kp1197", "description": "An implementation of the 3blue1brown video", "tags": ["3blue1brown"], "likes": 1, "viewed": 73, "published": 3, "date": "1634315785", "time_retrieved": "2024-07-30T18:55:37.534019", "image_code": "\n#define AA 1\n\n#define LOOP_TIME 10.\n\n// set programmatically at generaiton time\n#define JITTER_SALT 0.\n\nconst float EPS = 1e-12;\nconst float PI = 3.1415962;\nconst float e = 2.7182818284;\n\n\nconst float RATE_1 = 2. * PI / LOOP_TIME;\nconst float PHASE_1 = PI / 2.;\nconst float NUM_CELLS = 10.;\n\n\nmat2 noise2d_rotator = mat2(-0.8, 0.6, 0.6, 0.8);\n\n\n// { \"loop\": (\"-1.\", 0.10), \"blue\": (\"0.\", 0.23), \"red\": (\"1.\", 0.23), \"green\":(\"2.\", 0.22), \"teal\": (\"3.\", 0.22) }\n#define COLOR_MODE 3.\n\n// undocumented value: 0: none\n// { \"twist\": (\"1\", 0.33), \"fritz\": (\"2\", 0.33), \"pulsar\": (\"3\", 0.33) }\n#define ANIMATION_STYLE 2\n\n// { \"kalm\": (\"0.\", 0.80), \"jittery\": (\"1.\", 0.20) }\n#define JITTERY 0.\n\n\n\n// { \"clearview\": (\"-1\", 0.70), \"tiles\": (\"0\", 0.10), \"gems\": (\"1\", 0.10), \"cubist\": (\"3\", 0.10)}\n#define FRACTURE_STYLE 1\n\n#define SCANLINE 0.\n\n// { \"ghost\": (\"3\", 0.20), \"sharp\": (\"0\", 0.80) }\n#define TRAILS 0\n\n\n// { \"dragon\": (\"2.\", 0.25), \"tri\": (\"3.\", 0.25), \"quad\": (\"4.\", 0.25),  \"sept\": (\"6.\", 0.25) }\n#define LEADING_EXPONENT 2.\n\n// { \"stripeworld\": (\"-1.\", 0.50), \"spiralworld\": (\"1.\", 0.50) }\n#define LEADING_EXPONENT_SIGN 1.\n\n// { \"zoomout\": (\"-0.1\", 0.25), \"nakedeye\": (\"-1.\",0.75)}\n#define CONSTANT_REAL_TERM -1.0\n\n// { \"polar\": (\"1\",0.25), \"cartesian\": (\"0\",0.75) }\n#define POLAR 1\n\n// {  \"regularness\": (\"0\", 0.625), \"velvet\": (\"1\", 0.125), \"neons\": (\"2\", 0.125), \"fantasy\": (\"3\", 0.125) } \n#define SHADE_STYLE 3\n\n// { \"no\": (\"0\", 0.50), \"yes\": (\"1\", 0.50) }\n#define INVERT_COLORS 0\n\n// { \"yes\": (\"1\", 0.30), \"no\": (\"0\", 0.70) }\n#define FBM 1\n\n#define VIGNETTE 1.\n\n#define LEADING_TERM_COEF 5.\n\n#define CONSTANT_IMAG_TERM 0.\n\n#define LINEAR_TERM 0.0\n\n#define QUADRATIC_TERM 0.0\n\n#define SHAPES 10\n\n#define Gx 0\n\nconst int MAX_ITER = SHAPES;\n\nstruct Poly3 {\n\n    float A;\n    float expA;\n\n    float B;\n    float expB;\n\n    float C;\n    float expC;\n\n    float D;\n\n    float E;\n};\n\nstruct Z {\n    float real;\n    float imag;\n};\n\n\n\n\nPoly3 getPoly(float time) {\n\n    float bounce =  (ANIMATION_STYLE == 1) ? sin(RATE_1 * time) : 0.0;\n\n    //float constant_radius = CONSTANT_REAL_TERM + bounce;\n    //float constant_real = constant_radius*cos(time);\n    //float constant_imag = constant_radius*sin(time);\n\n    return Poly3(LEADING_TERM_COEF, LEADING_EXPONENT_SIGN * LEADING_EXPONENT, QUADRATIC_TERM, LEADING_EXPONENT_SIGN * 2., LINEAR_TERM, LEADING_EXPONENT_SIGN, CONSTANT_REAL_TERM + bounce, CONSTANT_IMAG_TERM);\n}\n\n\n\nfloat _exp(float x) {\n    return pow(e, x);\n}\n\n\nZ add(Z a, Z b, Z c, Z d, Z e, Z f) {\n    return Z(a.real + b.real + c.real + d.real + e.real + f.real, a.imag + b.imag + c.imag + d.imag + e.imag + f.imag);\n}\n\nZ add(Z a, Z b, Z c, Z d, Z e) {\n    return Z(a.real + b.real + c.real + d.real + e.real, a.imag + b.imag + c.imag + d.imag + e.imag);\n}\n\nZ add(Z a, Z b, Z c, Z d) {\n    return Z(a.real + b.real + c.real + d.real, a.imag + b.imag + c.imag + d.imag);\n}\n\nZ add(Z a, Z b, Z c) {\n    return Z(a.real + b.real + c.real, a.imag + b.imag + c.imag);\n}\n\nZ add(Z a, Z b) {\n    return Z(a.real + b.real, a.imag + b.imag);\n}\n\nZ power(Z a, float exponent) {\n    float r = pow(length(vec2(a.real, a.imag)), float(exponent));\n    float cis = float(exponent) * atan(a.imag, a.real);\n    return Z(r * cos(cis), r * sin(cis));  \n}\n\nZ conj(Z a) {\n    return Z(a.real, -a.imag);\n}\n\nZ mult(float x, Z z) {\n    return Z(x * z.real, x * z.imag);\n}\n\nZ mult(Z a, Z b) {\n    return Z(a.real * b.real - a.imag * b.imag, a.real * b.imag + a.imag * b.real);\n}\n\nZ div(Z a, Z b) {\n    \n    Z numerator = mult(a, conj(b));\n    float denom = mult(b,conj(b)).real;\n    denom = denom == 0. ? 1. : denom;\n    return mult(1./denom, numerator);\n}\n\nZ _ln(Z a) {\n    return Z(length(vec2(a.real, a.imag)),  atan(a.imag, a.real));\n}\n\nZ _exp(Z a) {\n    return mult(_exp(a.real), Z(cos(a.imag), sin(a.imag)) );\n}\n\nZ _cos(Z x) {\n    float a = x.real;\n    float b = x.imag;\n    return Z(cos(a) * cosh(b), -1. * sin(a) * sinh(b));\n}\n\nZ _sin(Z x) {\n    float a = x.real;\n    float b = x.imag;\n    return Z(sin(a) * cosh(b), -1. * cos(a)* sinh(b));\n}\n\nfloat _length(Z x) {\n    return length(vec2(x.real, x.imag));\n}\n\nfloat _length_squared(Z x) {\n    return x.real*x.real + x.imag*x.imag;\n}\n\n// Inner implementation - not to be called directly\nZ _fz(Z z, Poly3 poly) {\n    return add(mult(poly.A, power(z, poly.expA)), mult(poly.B, power(z, poly.expB)), mult(poly.C, power(z, poly.expC)), Z(poly.D,poly.E)); \n}\n\n// Inner implementation - not to be called directly\nZ _dfdx(Z z, Poly3 poly) {\n    Z t1 = mult(poly.expA*poly.A, power(z, poly.expA-1.));\n    Z t2 = mult(poly.expB*poly.B, power(z, poly.expB-1.));\n    Z t3 = mult(poly.expC*poly.C, power(z, poly.expC-1.));\n    return add(t1, t2, t3);\n}\n\n// F(z) = f(p(z)) = f(az^m-b)\nZ fz(Z z, Poly3 poly) {\n    Z a = _fz(z, poly);\n    #if Gx == 0\n        // identity\n        return a;\n    #elif Gx == 1\n        // sin\n        return _sin(a);\n    #elif Gx == 2\n        // exp\n        return _exp(a);\n    #elif Gx == 3\n        // (1+f(x))/f(x)\n        return div(add(Z(1.,0.), a), a);\n    #else\n        return 0.; // deliberate compiler error\n    #endif\n}\n\n// F'(z) = F'(p(z))*p'(z)\nZ dfdx(Z z, Poly3 poly) {\n    Z a = _dfdx(z, poly);\n    #if Gx == 0\n        // chain rule applied to identity function\n        return a;\n    #elif Gx == 1\n        // chain rule applied to sin\n        return mult(_cos(_fz(z, poly)), a);\n    #elif Gx == 2\n        // chain rule applied to exp\n        return mult(_exp(_fz(z, poly)), a);\n    #elif Gx == 3\n        // chain rule applied to (1+f(x))/f(x)\n        Z numerator = a;\n        Z denominator = power(_fz(z, poly), 2.); \n        return div(numerator,denominator);\n    #else\n        return 0.; // deliberate compiler error\n    #endif \n}\n\n// TODO: handle divide by zero without branches or additive smoothing\nZ next(Z z, Poly3 poly, Z multiplier) {\n    return add(z, mult(multiplier,div(fz(z, poly), dfdx(z, poly))));\n}\n\n\nZ _multiplier(float time) {\n\n    Z multiplier = Z(1.,1.);\n\n    if (ANIMATION_STYLE == 1) {\n        multiplier = Z(-1.+0.9*sin(RATE_1*time),-0.1+0.9*cos(RATE_1*time));\n    }\n    else if (ANIMATION_STYLE == 2) {\n        multiplier = div( Z(-1. + cos(RATE_1*time), 1. + sin(RATE_1*time) ), Z( 1. + sin(RATE_1*time) , -1. + cos(RATE_1*time) ) );\n        //return Z(2., -3. + cos(RATE_1*time));\n    }\n    else if (ANIMATION_STYLE == 3 && LEADING_EXPONENT_SIGN == 1.) {\n        multiplier = mult(Z(-0.1,-0.1), Z(sin(RATE_1*time), cos(RATE_1*time)));   \n    }   \n    else if (ANIMATION_STYLE == 3 && LEADING_EXPONENT_SIGN == -1.) {\n        multiplier = mult(Z(-0.1,-0.1), Z(sin(RATE_1*time), cos(RATE_1*time))); \n        multiplier = add(multiplier, Z(-2.,0.));\n    }\n    \n    return multiplier;\n}\n\nfloat HUE_SHIFT_FRAC(float time) {\n    if (COLOR_MODE == -1.) {\n        return floor(5.*(time / LOOP_TIME))/5.;\n    }\n    else if (COLOR_MODE == 0.) {\n        return 0.0;\n    }\n    else if (COLOR_MODE == 1.) {\n        return 0.24;\n    }\n    else if (COLOR_MODE == 2.) {\n        return 0.6;\n    }\n    else if (COLOR_MODE == 3.) {\n        return 0.85;\n    }\n    else {\n        return 0.0;\n    }\n}\n\n\n\n// from https://www.shadertoy.com/view/MsjXRt\n// todo: my own implementation\nvec3 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return Color;\n}\n\n\nstruct Result {\n    int iterations;\n    Z zero;\n    float success;\n    float d;\n};\n\n\n\nResult newtown_raphson(Z z, Poly3 poly, Z multiplier) {\n    \n    if (POLAR == 1) {\n        z = div(Z(0.05,0.0),z);\n    }\n    \n    #if SHADE_STYLE == 3\n    float tot_d = 1.;\n    #else\n    float tot_d = 0.;\n    #endif\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        float d = z.real*z.real + z.imag*z.imag;\n        \n        #if SHADE_STYLE == 1\n            tot_d = min(abs(atan(z.real,z.imag)), abs(atan(z.imag, z.real)));\n        #elif SHADE_STYLE ==2\n            //tot_d = max(tot_d, d);\n            tot_d = (z.real + z.imag) / 2.;\n        #elif SHADE_STYLE == 3\n            tot_d *= (((z.real / z.imag)));\n        #endif\n        \n        if (d < EPS) {\n            return Result(i, z, 1., tot_d);\n        }\n        z = next(z, poly, multiplier);           \n        \n    }\n    float d =  z.real*z.real + z.imag*z.imag;\n    \n    \n    return Result(MAX_ITER, z, 0., tot_d);\n}\n\n\nvec3 render(in vec2 fragCoord, float time ) {\n    // Normalized pixel coordinates (from 0 to 1)\n\n    // AA accumulation\n    vec3 tot = vec3(0.);\n\n    vec2 uv = fragCoord.xy/iResolution.xx;\n    \n    uv -= 0.5 * (iResolution.xy/iResolution.xx);\n\n    Z z = Z(uv.x, uv.y);\n    \n    Z a = _multiplier(time);\n    Result result = newtown_raphson(z, getPoly(time), a);\n    \n    vec3 root_color = 0.5*(1.+clamp(vec3(result.zero.real, result.zero.imag, 1.), -1., 1.));\n\n    #if SHADE_STYLE == 0\n        float shade = clamp(float(result.iterations) / float(SHAPES), 0., 1.);                \n    #elif SHADE_STYLE > 0\n        float shade = clamp(result.d, 0., 1.);\n    #else\n        float shade = vec2(0.); // DELIBERATE COMPILER ERROR\n    #endif\n\n    // Time varying pixel color\n    vec3 color = shade * shade * shade * root_color;\n\n    tot += (0.15*9.)*(HueShift(color, HUE_SHIFT_FRAC(time)));\n    \n    #if INVERT_COLORS == 1\n    tot = (1. - tot);\n    #endif\n\n    // Output to screen\n    return tot;\n}\n\n// from IQ @ https://www.shadertoy.com/view/XdXGW8\nvec2 grad2( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;                             \n}\n\nfloat noise2_octave(in vec2 p, float intensity) \n{\n     ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( intensity*grad2( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( intensity*grad2( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( intensity*grad2( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( intensity*grad2( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// from IQ @ https://www.shadertoy.com/view/XdXGW8\nfloat noise2( in vec2 p, int octaves, float intensity )\n{\n    float f = 0.;\n    for (int i = 0; i < octaves; i++) {\n        float coef = pow(2., -float(i + 1));\n        f += coef*noise2_octave(p,intensity); \n        p = p*noise2d_rotator*2.01;\n    }\n    //f = 0.5 + 0.5*f;\n    return f;\n}\n\nfloat fbm2( in vec2 x, int octaves, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise2(f*x, 1, 1.);\n        f *= 2.01;\n        a *= G;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/warp\nvec2 distort2(in vec2 u, int iters, float scale, float intensity, float time) {\n    vec2 p = vec2(u);\n    p = vec2(\n            fbm2(u+vec2(0.0,0.0),1,1.),\n            fbm2(u+vec2(5.2,1.3),1,1.));\n    for (int i = 0; i < iters-1; i++) \n    {\n        p = vec2(\n            fbm2(u + scale*p+vec2(1.7,9.2),1,1.),\n            fbm2(u + scale*p+vec2(8.3,2.8),1,1.));\n            \n        p += vec2(time);\n    }\n    return u+intensity*p;\n}\n\nvec2 getFBM(in vec2 uv, float time) {\n    float UV_SCALE = 4./iResolution.x;\n    float STRENGTH = (1./8.)*iResolution.x;\n    return STRENGTH*(distort2(vec2(UV_SCALE*uv + JITTER_SALT + time), 2, 1., 1., 0.) - vec2(UV_SCALE*uv + JITTER_SALT + time));\n}\n\nvec2 fbm(in vec2 fragCoord, float time) {\n    vec2 _fbm1 = getFBM(fragCoord, mod(time,LOOP_TIME));\n    vec2 _fbm2 = getFBM(fragCoord, mod(time,LOOP_TIME) - LOOP_TIME);\n    vec2 _fbm = mix(_fbm1, _fbm2, mod(time/LOOP_TIME,1.));\n    return _fbm + fragCoord;\n}\n\nvec2 getJitter(float time)\n{\n    return 0.3*(distort2(vec2(JITTER_SALT + time), 5, 1., 1., 0.) - vec2(JITTER_SALT + time)); \n}\n\n// this jitter implementatoin blends two jitters with 100% of A at t=0.0 and 100% of B at t=LOOP_TIME\n// The blends are offset by t = -LOOP_TIME, that way, you have seemless looping of length LOOP_TIME\nvec2 jitter(in vec2 fragCoord, float time) {\n    vec2 jitter1 = getJitter(mod(time,LOOP_TIME));\n    vec2 jitter2 =  getJitter(mod(time,LOOP_TIME) - LOOP_TIME);  \n    vec2 jitter = mix(jitter1, jitter2, mod(time/LOOP_TIME,1.));\n    return jitter;\n}\n\nvec2 random2f( vec2 p ) {\n    return fract(\n        sin(\n            vec2(\n                dot(p,vec2(127.1,311.7)),\n                dot(p,vec2(269.5,183.3)))\n        )*(43758.5453)\n    );\n}\n\n\nfloat veronoi_metric( in vec2 r, float exponent, float angle ) {\n    // manhattan\n    //return dot(abs(r), vec2(1.));\n    // euclidean\n    //return dot(r,r);\n    return dot(pow(abs(r),vec2(exponent)), 0.01+abs(vec2(cos(angle), sin(angle))));\n}\n\nstruct Voronoi {\n    vec3 col;\n    float res;\n    vec2 ij;\n};\n\nVoronoi voronoi_f1_colors( in vec2 x, float randomness, float power, float angle )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res = 8.0;\n    vec3 res_col = vec3(0.);\n    ivec2 ij = ivec2(0);\n    \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2 point = random2f( vec2(p + b) );\n        vec2  r = vec2( b ) - f + randomness*point;\n        float d = veronoi_metric( r, power, angle);\n        vec3 col = vec3(point,1.);\n\n        ij = (d < res) ? ivec2(i,j) : ij;\n        res_col = (d < res) ? col : res_col;\n        res = min( res, d );\n        \n    }\n    \n    return Voronoi(res_col, res, vec2(ij));\n    //return vec4(res_col, sqrt( res ));\n}\n\n\n\nvec3 renderMainImage(in vec2 fragCoord, float time )\n{\n    vec2 oFragCoord = fragCoord;\n    \n    vec2 jitter_amt = 500.*jitter(fragCoord, time);\n    fragCoord += JITTERY * jitter_amt;  \n    \n    vec2 uv = fragCoord.xy / iResolution.xx;    \n    \n    Voronoi voronoi = Voronoi(vec3(0.),0.,vec2(0));\n    float voronoi_amt = 0.;\n    vec2 renderFragCoord = fragCoord;\n    if (FRACTURE_STYLE >= 0) {\n        voronoi = voronoi_f1_colors( NUM_CELLS*uv, float(FRACTURE_STYLE), 2. + 0.2*sin(RATE_1*time), PI/4. );\n        voronoi_amt =  sin(5. * RATE_1 * time / LOOP_TIME);\n        float a = mod(1.*(RATE_1 * time),2.*PI);\n        vec2 center = (floor(NUM_CELLS*uv) + voronoi.ij + vec2(0.5)) / NUM_CELLS;\n        mat2 spin = mat2(cos(a), -sin(a), sin(a), cos(a));\n        renderFragCoord = iResolution.xx*((spin * (uv - center)) + center);// + voronoi_amt * 50. * voronoi.xy;\n    }\n\n    #if FBM > 0\n    renderFragCoord = fbm(renderFragCoord, time);\n    #endif\n\n    vec3 color = render(renderFragCoord, time);\n    \n    if (FRACTURE_STYLE >= 0) {\n        color = mix(voronoi.col.xyz, color, 1.-voronoi_amt/4.);\n        color = color + voronoi_amt * 0.25 * dot(vec2(cos(RATE_1*time), sin(RATE_1*time)), (voronoi.col.xy));\n        color = mix(color, vec3(1.), voronoi.res);\n    }\n\n\n    if (VIGNETTE == 1.) {\n        float d= length(oFragCoord.xy / iResolution.xy - vec2(0.5));\n        float vignette = abs(1. - pow(d,1.));\n        color = vignette * color;\n    }\n    \n    //color = scanline_mask * mix(vec3(0.6,1.,0.6),color,0.1) + (1.-scanline_mask) * color;\n    \n    return color;\n}\n\nvec3 _mainImage(in vec2 fragCoord) {\n    vec3 color = renderMainImage(fragCoord, iTime);\n    \n    \n\n    \n    \n    if (TRAILS > 0) {\n        color = (1./float(1+TRAILS)) * color;\n    }\n    \n    for (int i = 1; i <= TRAILS; i++) {\n        vec3 trail = renderMainImage(fragCoord, iTime-0.35*(1./float(TRAILS))*float(i));\n        float coef = (1./float(1+TRAILS));//pow(2.,float(i));\n        color += coef * vec3(length(trail)/pow(3.,0.5));\n    }\n    \n    return color;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA > 0\n    \n    float AA_scale = 0.5;\n    float coef = 0.;\n    float denom = 0.0;\n    float max_coef = float(1+2*AA);\n    \n    for (int i = -1*AA; i <= 1*AA; i++) {\n        for (int j = -1*AA; j <= 1*AA; j++) {\n            fragCoord += AA_scale * vec2(i,j);\n            coef = max_coef - float(i+j);\n            tot += coef * _mainImage(fragCoord);\n            denom += coef;\n        }\n    }\n    \n    tot /= denom;\n    \n    #else\n    \n    tot = _mainImage(fragCoord);\n    \n    #endif\n    \n\n    \n    fragColor = vec4(tot, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1936, 1936, 1963, 1963, 2416], [2420, 2420, 2441, 2441, 2465], [2468, 2468, 2505, 2505, 2627], [2629, 2629, 2661, 2661, 2765], [2767, 2767, 2794, 2794, 2880], [2882, 2882, 2904, 2904, 2972], [2974, 2974, 2991, 2991, 3041], [3043, 3043, 3073, 3073, 3241], [3243, 3243, 3256, 3256, 3289], [3291, 3291, 3313, 3313, 3353], [3355, 3355, 3373, 3373, 3459], [3461, 3461, 3478, 3478, 3637], [3639, 3639, 3651, 3651, 3720], [3722, 3722, 3735, 3735, 3798], [3800, 3800, 3813, 3813, 3915], [3917, 3917, 3930, 3930, 4031], [4033, 4033, 4053, 4053, 4096], [4098, 4098, 4126, 4126, 4170], [4172, 4224, 4248, 4248, 4390], [4392, 4444, 4470, 4470, 4677], [4679, 4709, 4732, 4732, 5079], [5081, 5107, 5132, 5132, 5696], [5698, 5768, 5807, 5807, 5878], [5881, 5881, 5908, 5908, 6671], [6673, 6673, 6707, 6707, 7067], [7071, 7148, 7195, 7195, 7406], [7495, 7495, 7550, 7550, 8370], [8373, 8373, 8418, 8492, 9364], [9366, 9417, 9495, 9549, 9927], [9929, 9929, 9979, 9979, 10465], [10468, 10519, 10576, 10576, 10807], [10809, 10809, 10859, 10859, 11077], [11079, 11119, 11198, 11198, 11551], [11553, 11553, 11590, 11590, 11803], [11805, 11805, 11846, 11846, 12062], [12064, 12064, 12092, 12092, 12190], [12192, 12394, 12438, 12438, 12641], [12643, 12643, 12668, 12668, 12833], [12836, 12836, 12900, 12993, 13079], [13144, 13144, 13228, 13228, 13868], [13872, 13872, 13926, 13926, 15442], [15444, 15444, 15480, 15480, 15916], [15919, 15919, 15974, 15974, 16546]], "test": "untested"}
{"id": "fdGXzz", "name": "Alhambra Captive Tower Rosácea 2", "author": "FabriceNeyret2", "description": "re-coding https://www.shadertoy.com/view/sstXDs a different way for native antialiasing.\nUse smoothstep AA + depth chose blending above vs below.\nMissing:\n- acute corners (not round)\n- z-fight near center\n- end should go above/below ( need 1 extra blend )", "tags": ["star", "tilings", "islamic", "reproduction", "alhambra", "rosacea"], "likes": 14, "viewed": 398, "published": 3, "date": "1634302803", "time_retrieved": "2024-07-30T18:55:38.367790", "image_code": "#define S(v)   smoothstep( 3./R.y, 0., v ) \n\n// --- draw line with round ends\nfloat line(vec2 p, vec3 A,vec3 B, out float z) {      // z return interpolated 3rd coord\n    p -= A.xy; vec2 b = B.xy - A.xy;                  // 2D line drawing\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    z = mix(A.z, B.z, h);                             // interpol z values\n    return length(p - b * h);                         // distance to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   R = iResolution.xy,\n           U =  1.04*(2.*u - R ) / R.y, V;\n    vec3   P;\n    float PI = 3.14159265359, a,_a, d=9.,d2,z,z2,_z, v=0., \n           h = .077, w = .016,    // height of horiz ribbon ;  ribbon width\n           l = length(U);\n    mat2   M = mat2(cos( -PI/8.+vec4(0,-.5,.5,0)*PI));         // rot matrix\n\n    U = l * sin( mod( atan(U.y,U.x) +PI/16., PI/8. ) - PI/16. + vec2(PI/2.,0) ); // 16-fold rotation symmetry\n\n#define L(B) d2 = line(U,P,B,z2); P = B; if (d2<d) d=d2, z=z2; // get dist and z of closest point on ribbon\n\n#define T                                  \\\n    P = vec3(.11,h,-1),        /* horiz */ \\\n    L( vec3( .3 ,h, 1) );                  \\\n    L( vec3(.685-.4*h, h,-1) );/*  X    */ \\\n    L( vec3(.685+.4*h,-h,-1) );/* horiz */ \\\n    L( vec3(.9 ,-h, 1) );                  \\\n    L( vec3(.96,-h,-5) );                  \\\n    P = vec3(.77, .15, 1),     /* crown */ \\\n    L( vec3(.95,-h/2.,-1) );               \\\n    L( vec3(.95,-.2,5) );\n           // crown should be drawn and blended separatly to not merge with ribbon ends \n#define D    v = mix( v, S(d-w+2./R.y), a= S(d-w) )            // draw ribbon\n\n    T                                                          // draw main\n    V=U; U *= M; T; U=V;                                       // and its rot version\n    D;\n    _z=z, d = 9.,\n    \n    U.y=-U.y;  T;                                              // same in mirror\n    V=U; U *= M; T;  U=V;\n    U.y=-U.y; z = -z;  \n    \n    if ( z > _z )  _a=a, D;                                    // draw above \n    else _a = S(d-w), v += (1.-a) *  S(d-w+2./R.y) * _a;       // draw below\n    a += (1.-a) * _a;\n    v += (1.-a) * ( l<.15 ? .2 : .3 - (U.y>0.?0.:.07)*(1.-.55*l) ); // draw background\n   \n    O = vec4(v); O.b += .04;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 78, 126, 166, 469]], "test": "untested"}
{"id": "7sKXzz", "name": "James Bond intro", "author": "Jivago77", "description": "Everything in the title", "tags": ["intro", "jamesbond"], "likes": 0, "viewed": 234, "published": 3, "date": "1634286300", "time_retrieved": "2024-07-30T18:55:39.131748", "image_code": "float Circle(vec2 uv,vec2 p, float r, float blur)\n{\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur,d);\n    return c;\n}\n\nfloat CoorUvX()\n{\n    return -cos(iTime/3.)*1.5+1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float mask = Circle(uv, vec2(CoorUvX(),0.5), 0.07,0.005);\n    \n    float decalRebord = 0.1;\n    float coeffRapid = 4.5;\n    if(iTime >2.2)\n    {\n        mask += Circle(uv, vec2( floor( (decalRebord+CoorUvX() )*coeffRapid)/coeffRapid-decalRebord, 0.5 ),0.07,0.005);\n    }\n    \n    //mask += Circle(uv, vec2( floor( (CoorUv(iTime)).x), 0.5) ,0.08,0.01);\n    // Output to screen\n    \n    vec3 vecColor = vec3(0.,0.,0.);\n    \n    if(iTime < 6.)\n    {\n        mask = mask;\n    }\n    else if(6.<=iTime && iTime < 10.07)\n    {\n        mask = (0.,0.,0.);\n        vecColor = texture(iChannel0,uv-vec2(0.5,-0.2)).rgb *vec3(Circle(uv-0.5, vec2(0.2-cos((iTime+6.)/3.5)*1.5,0.), 0.24,0.005));\n    }\n    else if(10.07<iTime && iTime < 11.5)\n    {\n        mask = (0.,0.,0.);\n        vecColor = texture(iChannel0,uv-vec2(0.5,-0.2)).rgb *vec3(Circle(uv-0.5, vec2(0.3865,0.), 0.24,0.005));\n        \n    }\n    else if(11.5<iTime && iTime < 15.5)\n    {\n        mask = Circle( uv-0.5, vec2(0.3865,0.), 0.24,0.005 )*((iTime-11.5)/4.,0.+(17.5-iTime)/6.,0.+(17.5-iTime)/4.);\n        vecColor = vec3((iTime-11.5)/4.,0.,0.);\n        //\n        \n    }\n    else if(15.5<iTime && iTime < 20.)\n    {\n        mask = (1.,0.,0.);\n        vecColor = vec3(1.,0.,0.);\n    }\n    else if(20.<iTime && iTime < 22.)\n    {\n        mask = (1.,0.,0.);\n        vecColor = texture(iChannel0,uv).rgb;\n    }\n    else\n    {\n        mask = (0.,0.,0.);\n    }\n    fragColor = vec4(vec3(mask)+vecColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 134], [136, 136, 153, 153, 190], [192, 192, 249, 300, 1848]], "test": "untested"}
{"id": "7sKXRz", "name": "Straightedge Construction", "author": "dr2", "description": "Draw a perpendicular to the circle diameter from a point on the circumference using only a straightedge (and pencil)", "tags": ["sketch", "geometry", "proof"], "likes": 11, "viewed": 372, "published": 3, "date": "1634283905", "time_retrieved": "2024-07-30T18:55:39.975492", "image_code": "// \"Straightedge Construction\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Draw a perpendicular to the circle diameter from a point on the circumference\n using only a straightedge (and pencil).\n\n Construction steps shown in sequence. As with good Scandinavian furniture and toys,\n written instructions are superfluous.\n The final animated sequence shows that the results are independent of where the\n vertex of the second triangle is located.\n \n Remember:\n   Triangles with the diameter as hypotenuse and a vertex on the circumference are\n   right-angled (Thales).\n   Lines from a vertex that are perpendicular to the opposite edge intersect at a\n   common point (orthocenter).\n*/\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (3.5, 0.02, 3.5), 0.01);\n  DMINQ (1);\n  q.yz -= vec2 (0.07, -3.);\n  d = PrRoundBoxDf (q, vec3 (2.5, 0.01, 0.15), 0.03);\n  DMINQ (2);\n  q = p;\n  q -= vec3 (0.2, 0.05, -2.5);\n  q.xz = Rot2D (q.xz, 0.5 * pi);\n  q *= 2.5;\n  q.y -= 0.35;\n  d = PrRoundCylDf (q, 0.33, 0.03, 5.);\n  d = max (d, - dot (vec2 (q.z, dot (q.xy, cos (2. * pi * floor (16. * (atan (q.y, - q.x) / (2. * pi) +\n     0.5) + 0.5) / 16. + vec2 (0., 0.5 * pi)))), sin (-0.4 * pi + vec2 (0.5 * pi, 0.))) - 1.6);\n  d /= 2.5;\n  DMINQ (3);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (3.7, 0.06, 3.7), 0.02), - PrBox2Df (q.xz, vec2 (3.5, 3.5)));\n  DMINQ (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat DrLine (vec2 p, vec2 a, vec2 b, float w)\n{\n  vec2 v;\n  float s;\n  v = a - b;\n  s = 0.5 * length (v);\n  v = Rot2D (p - b, atan (v.y, - v.x)) + vec2 (s, 0.);\n  return smoothstep (0., 0.02, PrRoundBox2Df (v, vec2 (s, 0.001 * w), 0.0001 * w));\n}\n\nfloat DrSqr (vec2 p, vec2 a, float w)\n{\n  return smoothstep (0., 0.02, PrRoundBox2Df (p - a, vec2 (0.001 * w), 0.0001 * w));\n}\n\nfloat DrDot (vec2 p, vec2 a, float r)\n{\n  return smoothstep (0., 0.02, length (p - a) - 0.001 * r);\n}\n\nfloat Cross2 (vec2 u, vec2 v)\n{\n  return u.x * v.y - u.y * v.x;\n}\n\nvec2 LineInt (vec2 a, vec2 u, vec2 b, vec2 v)\n{\n  return b + (Cross2 (a - b, u) / Cross2 (v, u)) * v;\n}\n\nvec4 GeomCol (vec2 p, vec4 col4)\n{\n  vec3 col;\n  vec2 pc[2], pd[2], pr[2], pt[4], vDir[4], c, sb;\n  float tCyc, tFlic, ang[2], vt[2], rad, lWid, sqSz, dotSz;\n  tCyc = mod (tCur, 26.);\n  tFlic = step (0.5, mod (4. * tCur, 1.));\n  c = vec2 (1., 0.);\n  lWid = 3.;\n  sqSz = 40.;\n  dotSz = 50.;\n  rad = 1.;\n  pd[0] = vec2 (rad, 0.);\n  pd[1] = vec2 (- rad, 0.);\n  ang[0] = 0.2 * pi;\n  ang[1] = (0.6 + 0.2 * sin (max (0., tCyc - 14.))) * pi;\n  for (int k = 0; k < 2; k ++) {\n    pr[k] = Rot2D (pd[0], ang[k]); // triangle vert on circle\n    vDir[k] = normalize (pr[k] - pd[k]);\n    vt[k] = atan (vDir[k].y, - vDir[k].x);\n  }\n  pt[0] = LineInt (pd[0], vDir[0], pd[1], vDir[1]); // top line-line intersect\n  pc[0] = vec2 (pt[0].x, sqrt (rad * rad - pt[0].x * pt[0].x)); // top line-circle intersect\n  pc[1] = pc[0] * vec2 (1., -1.); // bottom line-circle intersect\n  vDir[2] = normalize (pr[0] - pc[0]);\n  pt[1] = LineInt (pc[0], vDir[2], vec2 (0.), vec2 (1., 0.)); // right line-axis intersect\n  pt[2] = LineInt (pd[0], pr[1] - pd[0], pd[1], pr[0] - pd[1]);  // orthocenter\n  vDir[3] = normalize (pt[1] - pc[1]);\n  pt[3] = pc[1] + (sqrt (dot (pc[1], vDir[3]) * dot (pc[1], vDir[3]) + rad * rad - dot (pc[1], pc[1])) -\n     dot (pc[1], vDir[3])) * vDir[3]; // lower-right line-circle intersect\n  sb = vec2 (0.05, -0.05);\n  col = col4.rgb;\n  if (tCyc >= 2.) {\n    col = mix (c.xyy, col, DrDot (p, pr[0], 2. * dotSz));\n  }\n  if (tCyc >= 1.) {\n    col = mix (c.yyx, col, smoothstep (0., 0.02, abs (length (p) - rad)));\n    col = mix (c.yxy, col, smoothstep (0., 0.02, PrRoundBox2Df (p, pd[0], 0.01)));\n  }\n  if (tCyc >= 2. && tCyc < 4.) {\n    col = mix (0.3 * c.xxx, col, max (tFlic, DrLine (p, pr[0], vec2 (pr[0].x, 0.), 3. * lWid)));\n    col = mix (0.3 * c.xxx, col, max (tFlic, DrSqr (p, vec2 (pr[0].x, 0.) + sb.yx, sqSz))); \n  }\n  if (tCyc >= 4.) {\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.yxy, col, DrLine (p, pd[k], pr[0], 2. * lWid));\n    if (tCyc < 10.) col = mix (0.3 * c.xxx, col, DrSqr (Rot2D (p - pr[0], vt[0]), sb, sqSz)); \n  }\n  if (tCyc >= 5.) {\n    col = mix (c.xyy, col, DrDot (p, pr[1], dotSz));\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.yxy, col, DrLine (p, pd[k], pr[1], 2. * lWid));\n    if (tCyc < 10.) col = mix (0.3 * c.xxx, col, DrSqr (Rot2D (p - pr[1], vt[1]), sb.xx, sqSz)); \n  }\n  if (tCyc >= 6.) {\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.yxx, col, DrLine (p, pr[k], pr[k] + 2.9 * vDir[k], lWid));\n    col = mix (c.xyy, col, DrDot (p, pt[0], dotSz));\n    col = mix (0.5 * c.xyx, col, DrDot (p, pt[2], dotSz));\n  }\n  if (tCyc >= 7.) {\n    col = mix (0.8 * c.xxy, col, DrLine (p, pt[0], pt[2] + 1.8 * rad * normalize (pt[2] - pt[0]), lWid));\n    for (int k = 0; k < 2; k ++)\n       col = mix (c.xyy, col, DrDot (p, pc[k], dotSz));\n    if (tCyc < 9.) col = mix (0.3 * c.xxx, col, DrSqr (p, vec2 (pt[0].x, 0.) + sb.xx, sqSz)); \n  }\n  if (tCyc >= 8.) {\n    col = mix (c.yxx, col, DrLine (p, pc[0], pc[0] + 2.7 * vDir[2], lWid));\n    col = mix (c.yxx, col, DrLine (p, pd[0], pd[0] + 1.5 * vec2 (1., 0.), lWid));\n    col = mix (c.xyy, col, DrDot (p, pt[1], dotSz));\n  }\n  if (tCyc >= 9.) {\n    col = mix (c.yxx, col, DrLine (p, pc[1], pt[1], 1.5 * lWid));\n  }\n  if (tCyc >= 10.) {\n    col = mix (c.xyy, col, DrDot (p, pt[3], dotSz));\n    if (tCyc < 14.) {\n      col = mix (0.3 * c.xxx, col, max (tFlic, DrLine (p, pt[3], pr[0], 3. * lWid)));\n      col = mix (0.3 * c.xxx, col, max (tFlic, DrSqr (p, vec2 (pr[0].x, 0.) + sb.yx, sqSz))); \n    } else {\n      col = mix (0.3 * c.xxx, col, DrLine (p, pt[3], pr[0], 3. * lWid));\n    }\n  }\n  if (tCyc >= 0.5) {\n    for (int k = 0; k < 2; k ++)\n       col = mix (0.3 * c.xxx, col, DrDot (p, pd[k], 0.6 * dotSz));\n  }\n  if (col != col4.rgb) col4 = vec4 (col, 0.2);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, r, z, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 1) {\n      col4 = vec4 (0.95, 0.95, 0.95, 0.);\n      if (qHit.y > 0.) col4 = GeomCol (ro.xz, col4);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.8, 0.7, 0.5, 0.3);\n     } else if (idObj == 3) {\n      r = length (qHit.xy);\n      col4 = mix (vec4 (0.9, 0.7, 0.1, 0.1), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));\n      col4 = mix (vec4 (0.3, 0.3, 0.3, 0.1), col4, step (0.18, r));\n      col4 = mix (vec4 (0.8, 0.4, 0.1, 0.), col4, step (qHit.z, 4.5));\n      z = abs (qHit.z - 4.2);\n      col4 = mix (vec4 (0.9, 0.9, 1., 0.3), col4, step (0.3, z));\n      col4 = mix (vec4 (0.5, 0.5, 0.5, 0.3), col4, step (0.03, abs (z - 0.27)));\n    } else if (idObj == 4) {\n      col4 = vec4 (0.2, 0.2, 0.5, 0.1);\n    }\n    if (idObj == 2 || idObj == 3 && step (0.3, z) < 0.) nDotL *= nDotL * nDotL;\n    col = col4.rgb * ((0.2 + 0.8 * nDotL) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n  } else {\n    col = vec3 (0., 0., 0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.35 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -0.2, -20.);\n  zmFac = 5.5;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKXRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1215, 1215, 1237, 1237, 1950], [1952, 1952, 1985, 1985, 2169], [2171, 2171, 2192, 2192, 2447], [2449, 2449, 2497, 2497, 2696], [2698, 2698, 2737, 2737, 2824], [2826, 2826, 2865, 2865, 2927], [2929, 2929, 2960, 2960, 2994], [2996, 2996, 3043, 3043, 3099], [3101, 3101, 3135, 3135, 6867], [6869, 6869, 6904, 6904, 8092], [8136, 8136, 8192, 8192, 9156], [9158, 9158, 9204, 9204, 9251], [9253, 9253, 9286, 9286, 9375], [9377, 9377, 9424, 9424, 9471], [9473, 9473, 9530, 9530, 9606], [9608, 9608, 9644, 9644, 9850], [9852, 9852, 9882, 9882, 9995]], "test": "untested"}
{"id": "7dtSDl", "name": "SAT + giant box blur kernels", "author": "paniq", "description": "Arbitrarily big box blur kernels in O(1) by precomputing a summed-area table", "tags": ["blur", "kernel", "sat"], "likes": 10, "viewed": 600, "published": 3, "date": "1634281726", "time_retrieved": "2024-07-30T18:55:40.874089", "image_code": "\nconst float tau = 6.283185;\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec2 pw = 1.0 / iChannelResolution[0].xy;\n    vec2 uv = fragCoord * pw;\n    vec2 rb = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);    \n    float R = mix(1.0,24.0,cos(length(rb) * tau - iTime)*0.5+0.5);\n    pw *= R;\n    float v = 4.0*R*R;\n#if 1\n    vec4 p00 = texture(iChannel0, uv + vec2(-pw.x,-pw.y));\n    vec4 p10 = texture(iChannel0, uv + vec2( pw.x,-pw.y));\n    vec4 p01 = texture(iChannel0, uv + vec2(-pw.x, pw.y));\n    vec4 p11 = texture(iChannel0, uv + vec2( pw.x, pw.y));\n    \n    fragColor = (p11 - p10 - p01 + p00) / v;\n    fragColor = fragColor * dc_scale + dc_offset;\n#else    \n    float r = texture(iChannel0, uv).r;\n    fragColor = vec4(hue(r) * mix(0.5, 1.0, 0.5 + 0.5*sign(r)),1.0);\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame;\n    if (frame < 60) { // input; we give it a second so the viewer has a chance to change to fullscreen ;)\n        vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n        fragColor = texture(iChannel1, (uv*0.5*vec2(1.0, 16.0 / 9.0))*0.5 + 0.5);\n        // box bokeh demo\n        fragColor += 10.0*max(1.0 - length(uv - vec2(0.55, 0.0))*50.0, 0.0);\n        // DC offset correction, causing integral to become non-monotonic\n        fragColor = (fragColor - dc_offset) / dc_scale;\n    } else {\n        frame -= 60;\n        ivec2 fc = ivec2(fragCoord);\n        vec4 d = texelFetch(iChannel0, fc + ivec2( 0, 0), 0);\n        fragColor = d; // as-is\n        if (frame < 12) {\n            // sum horizontally via jump flooding\n            int S = 1 << frame;\n            int x = fc.x - S;\n            if (x >= 0) {\n                vec4 b = texelFetch(iChannel0, ivec2(x, fc.y), 0);\n                fragColor += b;\n            }\n        } else if (frame < 24) {\n            // sum vertically via jump flooding\n            int S = 1 << (frame - 12);\n            int y = fc.y - S;\n            if (y >= 0) {\n                vec4 b = texelFetch(iChannel0, ivec2(fc.x, y), 0);\n                fragColor += b;\n            }            \n        }\n    }    \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float dc_offset = 0.6;\n\nconst float dc_scale = 100000.0;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 51, 51, 158], [160, 160, 217, 217, 978]], "test": "untested"}
{"id": "7dVXzR", "name": "Simple ray-marching scene", "author": "busybeaver", "description": "Simple ray-marching scene", "tags": ["raymarching"], "likes": 10, "viewed": 281, "published": 3, "date": "1634280574", "time_retrieved": "2024-07-30T18:55:41.637049", "image_code": "#define enable_color_correction 1\n\nfloat max_d = 100000.;\nfloat min_d = 0.0015;\nint max_i = 220;\nfloat rotation_speed = .2;\n\nvec4 s0 = vec4(-4.5, 0., -3., 4.);\nvec4 s1 = vec4(3., -1.8, -2., 2.2);\nvec4 c0 = vec4(1., -1.5, 4., 2.5);\nfloat p1 = -4.03;\nvec4 c2 = vec4(.5, 2.02, 3.5, 1.);\nvec4 s2 = vec4(.5, 4.5, 3.5, 1.5);\nvec4 s3 = vec4(-7., 4., 5., 1.);\n\n#if enable_color_correction\nfloat gamma = 2.2; // For gamma correction.\nfloat exposure = 0.6;\nfloat tone_pow = 0.35; // Represents how strong the tone mapping is.\n\nvec3 correct_color(vec3 c) {\n    c *= exposure;\n    c = pow(c, vec3(1. / tone_pow));\n    c = pow(c / (c + 1.), vec3(tone_pow));\n    c = pow(c, vec3(1. / gamma));\n    return c;\n}\n#endif\n\nfloat sum(vec3 v) { return v.x + v.y + v.z; }\nfloat max_abs(vec3 v) { return max(max(abs(v.x), abs(v.y)), abs(v.z)); }\n\nfloat sphere(vec3 p, vec3 s, float r) { return sqrt(sum((p - s) * (p - s))) - r; }\n\nfloat cube(vec3 p, vec3 s, float r) { return max_abs(p - s) - r; }\n\nvec3 cube_m(vec3 p, vec4 c, vec3 ray) {\n    if(abs(p.x - c.x) > max(abs(p.z - c.z), abs(p.y - c.y))) { ray.x *= -1.; }\n    if(abs(p.y - c.y) > max(abs(p.z - c.z), abs(p.x - c.x))) { ray.y *= -1.; }\n    if(abs(p.z - c.z) > max(abs(p.y - c.y), abs(p.x - c.x))) { ray.z *= -1.; }\n    return ray;\n}\n\nvec3 col(vec3 cam, vec3 ray) {\n    vec3 p = cam;\n    vec3 col = vec3(1., 1., 1.);\n    vec3 col_1 = col;\n    vec3 pcol = vec3(0., 0., 0.);\n    float min_s3d = 2.;\n    bool t;\n    for(int i = 0; i < max_i; i ++) {\n        t = true;\n        float d = max_d;\n        d = min(d, sphere(p, s0.xyz, s0.a));\n        if(d < min_d && t) {\n            ray -= normalize(s0.xyz - p) * dot(s0.xyz - p, ray) / s0.a * 2.;\n            col *= vec3(1., .5, .5);\n            t = false;\n        }\n        d = min(d, sphere(p, s1.xyz, s1.a));\n        if(d < min_d && t) {\n            ray -= normalize(s1.xyz - p) * dot(s1.xyz - p, ray) / s1.a * 2.;\n            col *= vec3(.5, 1., .5) * (float(sin(atan((s1.x - p.x) / (s1.z - p.z)) * 10. + sin(iTime) * 30.) > 0.) * .7 + .3);\n            t = false;\n        }\n        d = min(d, sphere(p, s2.xyz, s2.a));\n        if(d < min_d && t) {\n            ray -= normalize(s2.xyz - p) * dot(s2.xyz - p, ray) / s2.a * 2.;\n            col *= vec3(.2, 1., 1.) * (float(sin(atan(length(s2.xz - p.xz) / (s2.y - p.y)) * 12.) > 0.) * .7 + .3);\n            t = false;\n        }\n        float s3d = sphere(p, s3.xyz, s2.a);\n        if(s3d < min_s3d && s3d < 2.) { min_s3d = s3d; }\n        d = min(d, s3d * .4);\n        if(d < min_d && t) {\n            pcol += vec3(2., 2., 4.) * col;\n            t = false;\n            break;\n        }\n        d = min(d, cube(p, c0.xyz, c0.a));\n        if(d < min_d && t) {\n            ray = cube_m(p, c0, ray);\n            col *= vec3(.4, .4, 1.);\n            t = false;\n        }\n        if(ray.y < 0.) {\n            d = min(d, (p1 - p.y) / ray.y);\n            if(d < min_d && t) {\n                ray.y *= -1.;\n                col *= vec3(.3, .3, .3);\n                t = false;\n            }\n        }\n        d = min(d, cube(p, c2.xyz, c2.a));\n        if(d < min_d && t) {\n            ray = cube_m(p, c2, ray);\n            col *= vec3(1., 1., .1);\n            t = false;\n        }\n        if(!t) {\n            p += ray * min_d * 2.;\n            pcol += col_1 * vec3(1., 1., 2.) * (2. - min_s3d) * (2. - min_s3d) * .5;\n            min_s3d = 2.;\n            col_1 = col;\n        }\n        p += ray * d;\n        if(length(p) > max_d) { break; }\n    }\n    pcol += col * vec3(1., 1., 2.) * (2. - min_s3d) * (2. - min_s3d) * .5;\n    if(length(p) <= max_d && t) { return pcol; }\n    col = col * (ray.yxz * vec3(.65, .45, .45) + vec3(.35, .55, .55)).rgb * (ray.y * 2.5 + .4) *\n    (0.9 + .2 * float(sin(atan(ray.x / ray.z) * 30.) > 0.6)) *\n    (0.9 + .2 * float(sin(atan(ray.y / ray.z) * 30.) > 0.6)) *\n    (0.9 + .2 * float(sin(atan(ray.y / ray.x) * 30.) > 0.6)) + pcol;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / (iResolution.x + iResolution.y) * 4.;\n\n    float x = iTime * 1.5 - float(int(iTime * 1.5)) - .5;\n    s2.y = 4.52 + (1. - x * x * 4.) * 2.;\n\n    float t = iTime * rotation_speed;\n    \n    vec3 color = col(\n        vec3(sin(t) * 25., 4., - cos(t) * 25.),\n        normalize(vec3(- sin(t) * 1.3 + cos(t) * uv.x,\n            uv.y - .3, cos(t) * 1.3 + sin(t) * uv.x))\n    );\n    \n    #if enable_color_correction\n    fragColor.rgb = correct_color(color);\n    #else\n    fragColor.rgb = color;\n    #endif\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[703, 703, 722, 722, 748], [749, 749, 772, 772, 821], [823, 823, 862, 862, 905], [907, 907, 944, 944, 973], [975, 975, 1014, 1014, 1269], [3901, 3901, 3956, 3956, 4526]], "test": "untested"}
{"id": "fdyXzz", "name": "90s Anime Background", "author": "Xibanya", "description": "a Sailor Moon-inspired scene", "tags": ["sdf", "night", "city", "90s", "anime", "skyline"], "likes": 18, "viewed": 1131, "published": 3, "date": "1634276098", "time_retrieved": "2024-07-30T18:55:42.596484", "image_code": "// This shader is inspired by the backgrounds in Sailor Moon\n// this is the first really substantial shader I've written in GLSL.\n// Learned a lot doing this!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec2 duv = texel * vec2(-1., 1.);\n    vec3 col1 = texture(iChannel0, uv + duv).rgb;\n    vec3 col2 = texture(iChannel0, uv - duv).rgb;\n    vec3 col = vec3((col1.r + col2.r) * 0.5, col1.g, col2.b) * 1.3;\n    col = pow(col, vec3(1.5));\n    \n    //noise\n    float n = fract(cos(\n        (sin(uv.x / texel.x) * uv.y / texel.y + iTime * 0.01)\n        * 89.) * 343.4);\n\tcol = mix(col, max(col, n), 0.1);\n    \n    // vignette\n    float vignette = saturate(\n        pow(length(uv * 2. - 1.), 3.) * 0.25);\n    col = mix(col, col * OUTLINE_COLOR, vignette);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n#define saturate(x) clamp(x, 0., 1.)\n#define Hash(x) fract(cos(x) * 34214.0)\n\n#define BGUPPER vec3(0.08627451, 0.6509804, 0.7254902)\n#define BGLOWER vec3(0.07058824, 0.427451, 0.5411765)\n#define OVERLAY_COLOR vec3(1.113726, 0.6196079, 0.7529412)\n#define STAR_COLOR vec3(0.28, 0.28, 0.4)\n#define MOON_COLOR vec3(0.7098039, 0.7490196, 0.3058824)\n#define OUTLINE_COLOR vec3(0.0627451, 0.2509804, 0.3098039)\n\nconst vec3 BUILDING_COLOR_0 = vec3(0.06, 0.27, 0.47);\nconst vec3 BUILDING_COLOR_1 = vec3(0.07, 0.27, 0.43);\nconst vec3 BUILDING_COLOR_2 = vec3(0.07, 0.34, 0.48);\nconst vec3 BUILDING_COLOR_3 = vec3(0.07, 0.32, 0.49);\nconst vec3 BUILDING_COLOR_4 = vec3(0.07, 0.33, 0.52);\n\n#define WINDOW_COLOR_0 vec3(0.07058824, 0.3882353, 0.4941177)\n#define WINDOW_COLOR_1 vec3(0.2039216, 1.192157, 0.9960784)\n#define WINDOW_COLOR_2 vec3(0.1960784, 1.262745, 0.9647059)\n#define WINDOW_COLOR_3 vec3(1.283019, 1.207728, 0.3086507)\n\n#define OUTLINE_OFFSET 0.\n#define OUTLINE_THICKNESS 0.009\n#define OUTLINE_THRESHOLD 0.7\n\nstruct Building\n{\n    // xy scale, zw translate\n    vec2 scale;\n    vec2 pos;\n    vec3 color;\n    vec2 wScale;\n    vec2 wPos;\n    vec2 offset;\n    // building grid dimentions\n    // x columns, y rows\n    vec2 dim;\n};\n// Antialiased step\n// https://github.com/glslify/glsl-aastep\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\n\nvoid Rotate2D(inout vec2 original, float angle)\n{\n    mat2 r2D = mat2(cos(angle), -sin(angle), \n        sin(angle), cos(angle));\n    original = r2D * original;\n}\nvoid LerpWhiteTo(inout float a, float b, float c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec2 a, vec2 b, float c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec3 a, vec3 b, float c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec3 a, vec3 b, vec3 c)\n{\n    a = mix(a, b, c);\n}\nvoid LerpWhiteTo(inout vec4 a, vec4 b, float c)\n{\n    a = mix(a, b, c);\n}\n// SDF functions from iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n/////////////////////////////////////////////////////\n///// Skyline functions\n////////////////////////////////////////////////////\n// create moon shape by drawing a circle then \n// taking a bite out of it with a smaller circle\nfloat Moon(vec2 uv)\n{\n   vec2 moonPos = uv + vec2(0.2);\n   float moon = sdCircle(moonPos, 0.15);\n   float crescent = sdCircle(moonPos + vec2(0.05, -0.04), 0.1);\n   return max(-crescent, moon);\n}\n/// put an outline around a SDF rectangle\nvec3 DoOutline(float d, vec3 color)\n{\n    float o = d + OUTLINE_OFFSET;\n    if (o < 0.)\n    {\n        float t = -o / OUTLINE_THICKNESS;\n        t = t * t;\n        color = mix(OUTLINE_COLOR, color, step(OUTLINE_THRESHOLD, t));\n    }\n    return color;\n}\n// rgb is combined color\n// a channel is the distance\nvec4 OutlineBox2D(vec2 uv, vec4 st, vec3 color)\n{\n    float d = sdBox(uv + st.zw, st.xy);\n    color = DoOutline(d, color);\n    return vec4(color, d);\n}\n// draw rows and columns of specified rectangles\n// relative to the uv coords passed in\nfloat DrawWindow(vec2 uv, vec4 st, vec4 windowOffset)\n{\n    float window;\n    float rows = windowOffset.w;\n    float cols = windowOffset.z;\n\n    for (float i = 0.; i < rows; i++)\n    {\n        for (float n = 0.; n < cols; n++)\n        {\n            vec2 offset = vec2(\n                windowOffset.x * n, windowOffset.y * i) + st.zw;\n            float wD = sdBox(uv + offset, st.xy);\n            if (n == 0. && i == 0.) window = wD;\n            else window = min(window, wD);\n        }\n    }\n    return window;\n}\nvoid ApplyWindow(float scene, vec2 uv, Building b,\n    vec3 windowColor, inout vec3 color)\n{\n    uv = uv * b.scale + b.pos;\n    vec4 windowOffset = vec4(b.offset, b.dim);\n    float window = DrawWindow(uv, \n        vec4(b.wScale, b.wPos), windowOffset);\n    window = max(window, scene);\n    float diff = max(scene, -window);\n    color = diff < window? color : windowColor;\n    color = DoOutline(scene, color);\n}\n// draw building w/ windows \nfloat Build(vec2 uv, Building b, vec3 windowColor,\n    inout vec3 color)\n{\n    float scene = sdBox(uv + b.pos, b.scale);\n    color = DoOutline(scene, b.color);\n    ApplyWindow(scene, uv, b, windowColor, color);\n    return scene;\n}\n// draws tiling bubbles\nfloat Bubble(vec2 uv, vec2 offset, float margin)\n{\n    float wrap = step(\n        mod(floor(uv.y / margin + 0.5) + offset.y, 2.0), 0.);\n\tuv.x += margin * wrap; \n\tuv = mod(uv + 0.5 * margin + offset, margin) - 0.5 * margin;\n\n\tfloat circle = sdCircle(uv, 0.005);\n\tcircle =  1. - saturate(circle);\n    // want to invert the circle so it is brighter on the edges\n    // but also don't want to invert the entire scene or everything\n    // except the bubble would get covered\n    // so mask the inverted bubble\n    float mask = aastep(0.01, circle);\n    return max(0., (1. - circle) * mask);\n}\n\n/////////////////////////////////////////////////////////\n// star functions adapted from \n// https://www.shadertoy.com/view/ssK3Dt by Scintoth\nfloat noiseFloat(vec2 p)\n{\n    p = fract(p * vec2(1000. * 0.21353, 1000. * 0.97019));\n    p = p + dot(p, p + 1000. * 0.54823);\n    return fract(p.x * p.y);\n}\nvec2 noiseVector(vec2 p)\n{\n    float n = noiseFloat(p);\n    return vec2(n, noiseFloat(p + n));\n}\nvec2 GetPos(vec2 id, vec2 offsets, float time)\n{\n    vec2 n = noiseVector(id + offsets) * 500. * \n        ((8000. + time) / (1000. * 50.));\n    return (sin(n) * 0.9) + offsets;\n}\nfloat Stars(vec2 uv, float time, float gain)\n{\n    uv -= 1.;\n    float m = 0.;\n    uv = uv * 10.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int n = 0;\n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            p[n++] = GetPos(id, vec2(x, y), time);\n        }\n    }\n    for (int i=0; i < 9; i++)\n    {\n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (gain / (8000.0 + time));\n        m = m + sparkle * (sin(((8000.0 + time)+p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    return m;\n}\n//////////////////////////\nfloat Voronoi(vec2 uv)\n{\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\n\tfloat d = 64.;\n\tfor(float y = -1.; y <= 1.; ++y)\n\t{\n\t\tfor (int x = -1; x <= 1; ++x)\n\t\t{\n\t\t\tvec2 b = vec2(x, y);\n            float vNoise = fract(sin(\n                dot(i + b, vec2(101.9364, 96.45418))\n                ) * 100000.0);\n\t\t\tvec2 c = b + vNoise - f;\n\t\t\td = min(d, dot(c, c));\n\t\t}\n\t}\n\treturn sqrt(d);\n}\n\n/////////// FBM ///////////////\n// see: https://thebookofshaders.com/13/\nfloat FBMRandom(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat FBMNoise(in vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = FBMRandom(i);\n    float b = FBMRandom(i + vec2(1.0, 0.0));\n    float c = FBMRandom(i + vec2(0.0, 1.0));\n    float d = FBMRandom(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nfloat FBM(vec2 st, float octaves)\n{\n    float value = 0.;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (float i = 0.; i < octaves; i++)\n    {\n        value += amplitude * FBMNoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n///////////////////////////////////////////\n// Perlin \n// see: https://thebookofshaders.com/11/\nfloat SmoothCos(float a, float b, float x)\n{\n    float f = (1. - cos(x * 3.1415927)) * 0.5;\n    return a * (1. - f) + b * f;\n}\n// params.x = precision, params.y = octaves\nfloat Perlin(vec2 uv, vec2 params)\n{\n    float p = 0.;\n    float t = params.x;\n    for (float i = 0.; i < params.y; i++)\n    {\n        float a = FBMRandom(vec2(floor(t * uv.x) / t, floor(t * uv.y) / t));\t   \n        float b = FBMRandom(vec2(ceil (t * uv.x) / t, floor(t * uv.y) / t));\t\t\n        float c = FBMRandom(vec2(floor(t * uv.x) / t, ceil (t * uv.y) / t));\t\t\n        float d = FBMRandom(vec2(ceil (t * uv.x) / t, ceil (t * uv.y) / t));\n        if ((ceil(t * uv.x) / t) == 1.)\n        {\n            b = FBMRandom(vec2(0., floor(t * uv.y) / t));\n            d = FBMRandom(vec2(0., ceil(t * uv.y) / t));\n        }\n        float coef1 = fract(t * uv.x);\n        float coef2 = fract(t * uv.y);\n        p += SmoothCos(\n                SmoothCos(a, b, coef1),\n                SmoothCos(c, d, coef1),\n                coef2\n                ) * (1. / pow(2., (i + 0.6)));\n        t *= 2.;\n    }\n    return p;\n}", "buffer_a_code": "vec3 WindowFBM(vec2 uv)\n{\n    vec2 st = uv * 2.;\n    float time = iTime * 0.2;\n    vec2 q = vec2(FBM(st + time, 8.), FBM(st + 1., 8.));\n    vec2 r = vec2(\n        FBM(st + q + vec2(1.7, 9.2) + 0.15 * time, 8.),\n        FBM(st + q + vec2(8.3, 2.8) + 0.126 * time, 8.)\n    );\n    float f = FBM(st + r, 8.);\n    float next = saturate((f * f) * 4.);\n    vec3 color = mix(WINDOW_COLOR_0, WINDOW_COLOR_1, next);\n    next =  saturate(length(q));\n    LerpWhiteTo(color, WINDOW_COLOR_2, next);\n    next = saturate(length(r.x));\n    LerpWhiteTo(color, WINDOW_COLOR_3, next);\n\n    float finalFactor = (f * f * f + 0.6 * f * f + 0.5 * f);\n    return mix(WINDOW_COLOR_0, color, saturate(finalFactor));\n}\n\nfloat Buildings(vec2 uv, out vec3 color)\n{\n    Building[5] buildings = Building[5]\n    (\n        // long thin windows\n        Building(\n            vec2(0.25, 0.85), vec2(0.406, 0.5),\n            BUILDING_COLOR_0,\n            vec2(0.00275, 0.08), vec2(-0.358, -0.65),\n            vec2(0.0105, 0.18), vec2(11, 9)\n        ),\n        // many small windows with small gap\n        Building(\n            vec2(0.25, 0.94), vec2(-0.56, 1.1),\n            BUILDING_COLOR_1,\n            vec2(0.006, 0.04), vec2(0.37, -0.835),\n            vec2(0.014, 0.12), vec2(8, 9)\n        ),\n        // square windows\n        Building(\n            vec2(0.27, 0.94), vec2(-0.09, 0.87),\n            BUILDING_COLOR_2,\n            vec2(0.01, 0.04), vec2(0.025, -0.8351),\n            vec2(0.03, 0.12), vec2(6, 9)\n        ),\n        // lerger wide windows, small gap\n        Building(\n            vec2(0.27, 0.73), vec2(.78, 0.71),\n            BUILDING_COLOR_3,\n            vec2(0.02, 0.025), vec2(-0.66, -0.66),\n            vec2(0.045, 0.07), vec2(4, 11)\n        ),\n        // vertically thin horizontally wide windows\n        Building(\n            vec2(0.38, 0.5), vec2(-1., 0.5),\n            BUILDING_COLOR_4,\n            vec2(0.02, 0.01), vec2(0.52, -0.45),\n            vec2(0.05, 0.05), vec2(5, 11)\n        )\n    );\n    // cache the window color so I don't\n    // have to recalculate it for every building\n    vec3 windowColor = WindowFBM(uv);\n    uv = uv * vec2(1.5, 2) + vec2(1.5, 0.8);\n    float scene = Build(uv, buildings[0], windowColor, color);\n    \n    for (int i = 1; i < 5; i++)\n    {\n        vec3 bColor;\n        float b = max(\n            Build(uv, buildings[i], windowColor, bColor), \n            -scene); \n        color = scene < b ? color : bColor;\n        scene = min(scene, b);\n    }\n    \n    // repeating some buildings to fill in the gaps!\n    vec3 bColor;\n    float b = max(Build(uv + vec2(-1.9, 0.5), \n        buildings[0], windowColor, bColor), -scene); \n    LerpWhiteTo(bColor, OUTLINE_COLOR, 0.5);\n    color = scene < b ? color : bColor;\n    scene = min(scene, b);\n    \n    b = max(Build(uv + vec2(1.7, 0.1), buildings[1], \n        windowColor, bColor), -scene); \n    LerpWhiteTo(bColor, OUTLINE_COLOR, 0.5);\n    color = scene < b ? color : bColor;\n    scene = min(scene, b);\n    return scene;\n}\n\nvec4 Bubbles(vec2 uv)\n{\n    uv = uv * vec2(5.);\n    vec2 wUV = uv * vec2(2., 2.) + iMouse.xy * 0.25;\n    // it's just a bunch of tiling circles but I \n    // rotate the UVs and space the repetition \n    // out so that it seems more random\n    Rotate2D(wUV, -25.);\n    \n    // using this to make the bubble edges wobble\n    vec2 perlin = vec2(Perlin(uv, vec2(1., 8.)));\n    \n    wUV += perlin * 0.2;\n    float wc = Bubble(\n        wUV, \n        vec2(-1., 2.) + iTime * 0.25, 8.);\n    vec4 wcColor = vec4(2.6, 1.2, 1.7, 1.) * 0.35 * wc;\n\n    wUV = uv * vec2(4.) - iMouse.xy * 0.1;\n    Rotate2D(wUV, 151.);\n    wUV -= perlin;\n    wc = Bubble(wUV, vec2(-16., 3.) + iTime * 0.5, 16.);\n    LerpWhiteTo(wcColor, vec4(3.9, 2.9, 1.2, 1) * 0.35, wc);  \n    \n    wUV = uv * vec2(2.5) + iMouse.xy * 0.15;\n    Rotate2D(wUV, - 0.36);\n    wUV += perlin * vec2(.75, -.75);\n    wc = Bubble(wUV, vec2(-4.5, 2.) - iTime * 0.25, 30.5);\n    LerpWhiteTo(wcColor, vec4(3.9, 2.6, 1.2, 1) * 0.3, wc);\n    \n    wUV = uv * vec2(1.5) + iMouse.xy * 0.1;\n    Rotate2D(wUV, 24.2);\n    wUV += perlin * 0.1;\n    wc = Bubble(wUV, vec2(1.6, 6.) + iTime * 0.25, 12.);\n    LerpWhiteTo(wcColor, vec4(1.9, 1.1, 2.6, 1) * 0.25, wc);\n    \n    return wcColor;\n}\nfloat Water(vec2 uv, out vec3 color)\n{\n    color = vec3(0.086, 0.651, 0.725) * \n        smoothstep(0.15, -0.05, saturate(uv.y));\n    uv *= 2.;\n    // the reflection highlight is just one of the bubbles\n    // really stretched out\n    vec2 perlin = vec2(Perlin(uv + vec2(0.05) * iTime, vec2(5., 8.)));\n    vec3 highlight = MOON_COLOR * 1.2;\n    float circle = sdCircle(\n        uv * vec2(.4, 6.) + vec2(1.3, 11.5) - perlin, \n        0.00005);\n\tcircle =  1. - saturate(circle);\n    float mask = aastep(0.01, circle);\n    circle = max(0., (1. - circle) * mask);\n    LerpWhiteTo(color, highlight, circle * 0.25);\n    \n    float x = uv.x * 1.0 + Hash(floor(uv.y * 30.)) * iTime * 0.01;\n    float stars = Stars(uv * vec2(2., 2.5) + \n        vec2(iTime * -0.1, 0.), iTime * 0.2, 1000.0);\n    stars *= aastep(0.5, Hash(floor(x * 30.)) * \n        aastep(0.8, fract(x * 30.)));\n    LerpWhiteTo(color, STAR_COLOR * 5., saturate(stars));\n    float scene = sdBox(uv + vec2(0., 1.9), vec2(4., 0.1));\n    color = DoOutline(scene, color);\n  \n    return scene;\n}\n\nvec3 DrawScene(vec2 fragCoord)\n{\n    float y = dot(fragCoord.y / iResolution.y, 1.);\n    vec2 uv = (fragCoord - 1. * iResolution.xy) / iResolution.y;\n    float bgBlend = smoothstep(0.4, 0.8, y);\n    vec2 bgUV = uv * vec2(3.9, 1.15) + vec2(0.5, 0) * iTime * 0.25;\n    bgBlend *= Voronoi(bgUV);\n    vec3 col = mix(BGLOWER, BGUPPER, saturate(bgBlend));\n    \n    float stars = Stars(uv, iTime, 75.0);\n    LerpWhiteTo(col, STAR_COLOR * 6., saturate(stars));\n    \n    float moon = Moon(uv);\n    moon = 1. - aastep(0.001, moon);\n    LerpWhiteTo(col, MOON_COLOR, moon);\n    \n    vec3 bColor;\n    float bd = Buildings(uv, bColor);\n    LerpWhiteTo(col, bColor, saturate(1. - sign(bd)));\n    \n    float overlay = smoothstep(.6, -0.1, y);\n    LerpWhiteTo(col, OVERLAY_COLOR, overlay);\n    \n    vec3 wColor;\n    float waterDist = Water(uv, wColor);\n    LerpWhiteTo(col, wColor, saturate(1. - sign(waterDist)));\n    \n    vec4 bubbles = Bubbles(uv);\n    LerpWhiteTo(col, bubbles.rgb * 4., saturate(bubbles.a));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = DrawScene(fragCoord.xy);\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 217, 217, 885]], "test": "untested"}
{"id": "NsVSzz", "name": "Heat Equation - Square Wave", "author": "oneshade", "description": "Heat equation solution with a square wave as the initial function of heat using fourier series.\nMouse control is enabled after 10 seconds.\n[url=https://en.wikipedia.org/wiki/Heat_equation]https://en.wikipedia.org/wiki/Heat_equation[/url]", "tags": ["heat", "fourier", "squarewave", "series", "heatequation"], "likes": 9, "viewed": 209, "published": 3, "date": "1634272478", "time_retrieved": "2024-07-30T18:55:43.360441", "image_code": "#define PI 3.14159265359\n\nvec2 u(in float x, in float t) {\n    float y = 0.0;\n    float dx = 0.0;\n    float s = 4.0 / PI;\n    for (float n=0.0; n < 25.0; n++) {\n        float k = 2.0 * n + 1.0, kx = k * x;\n        float w = exp(-k * k * t);\n        y += s / k * cos(kx) * w;\n        dx -= s * sin(kx) * w;\n        s = -s;\n    }\n\n    return vec2(y, dx);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    vec2 y = u(uv.x, max(0.0, iTime < 10.0 ? 0.5 * (iTime - 2.0) : iMouse.x / iResolution.x * 5.0));\n    float stroke = smoothstep(10.0 / iResolution.y, 0.0, abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y));\n    fragColor = vec4(stroke, 0.0, stroke, 1.0);\n    fragColor.rb *= mix(vec2(0.0, 1.0), vec2(1.0, 0.0), 0.5 + 0.5 * y.x);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVSzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 58, 58, 354], [356, 356, 411, 411, 807]], "test": "untested"}
{"id": "fsKXzR", "name": "Taste of Noise 10", "author": "leon", "description": "mecha vibes", "tags": ["weird"], "likes": 22, "viewed": 706, "published": 3, "date": "1634262659", "time_retrieved": "2024-07-30T18:55:44.127390", "image_code": "\n// taste of noise 10 by leon denise 2021/10/15\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "\n// taste of noise 10 by leon denise 2021/10/15\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time\n    float t = floor(iTime/10.)*178.;\n    \n    // keep original pos\n    vec3 pp = p;\n    \n    // rotation parameter\n    vec3 angle = vec3(-.1,-.2,.3)-t*.1;\n    \n    // kif\n    const float count = 8.0;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (float index = 0.0; index < count; ++index)\n    {        \n        \n        // fold\n        p.xz = abs(p.xz)-0.3*a;\n        \n        // rotate\n        p.yx *= rot(angle.z/a);\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        \n        // sdf object\n        shape = sdBox(p, vec3(0.05,0.2,0.01)*a*2.);\n        \n        // material\n        material = shape < scene ? index : material;\n        \n        // add\n        scene = min(scene, shape);\n        \n        // falloff\n        a /= 1.3;\n    }\n    \n    // crop\n    scene = max(scene, -sdBox(pp,vec3(0.1,0.2,.5)));\n        \n    return scene;\n}\n\nvec3 color (vec3 pos, vec3 ray, vec3 normal)\n{    \n    // lighting\n    vec3 rf = reflect(ray, normal);\n    float ld = dot(rf, vec3(0,1,0))*0.5+0.5;\n    vec3 light = vec3(1.000,1.000,1.000) * sqrt(ld)-.5;\n    ld = dot(rf, vec3(0,1,0))*0.5+0.5;\n    light += vec3(1.000,1.000,1.000) * pow(ld, 5.)*.5;\n\n    // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*material*.2);\n\n    // compositing\n    return tint + light;\n}\n\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // pixel coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // blur edges\n    vec3 dof = hash33(seed+78.);\n    uv += vec2(cos(dof.x*6.28),sin(dof.x*6.28))*.2*pow(length(uv), 3.)*dof.y;\n    \n    // camera coordinates\n    vec3 eye = vec3(0,0,0);\n    vec3 at = vec3(0,0,1);\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5);\n    mouse *= step(0.1,length(mouse.xy+.5));\n    at.yz *= rot(-mouse.y);\n    at.xz *= rot(mouse.x);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = (cross(x, z));\n    vec3 ray = normalize(vec3(z * .5 + uv.x * x + uv.y * y));\n    vec3 pos = eye;\n    \n    float bounces = 0.0;\n    \n    // raymarch\n    const float steps = 30.0;\n    float index;\n    for (index = steps; index > 0.0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.001)\n        {\n            float shade = index/steps;\n            \n            // bounces\n            if (bounces++ > 1.) break;\n\n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(0.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n            // coloring\n            fragColor.rgb += color(pos, ray, normal) * shade * 0.5;\n\n            // bounces\n            float roughness = 0.2;\n            if (material < 0.) roughness = 1.;\n            ray = reflect(ray, normal);\n            ray = normalize(ray+normalize(hash33(pos*1000.)*2.-1.)*roughness);\n            dist = 0.1;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n    \n    // temporal buffer\n    if (iMouse.z < 0.5)\n    {\n        vec3 frame = texture(iChannel0, gl_FragCoord.xy/iResolution.xy).rgb;\n        fragColor.rgb = max(fragColor.rgb, frame - 0.005);\n    }\n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKXzR.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[243, 243, 300, 300, 370]], "test": "untested"}
{"id": "fdKXRR", "name": "Taste of Noise 9", "author": "leon", "description": "mecha vibes", "tags": ["weird"], "likes": 19, "viewed": 536, "published": 3, "date": "1634256293", "time_retrieved": "2024-07-30T18:55:44.992079", "image_code": "// taste of noise 9 by leon denise 2021/10/15\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time\n    float t = iTime;\n    \n    // keep original pos\n    vec3 pp = p;\n    \n    // domain repeat\n    float grid = 2.5;\n    p.z += t * 0.05;\n    vec3 cell = floor((p+grid/2.)/grid);\n    p = repeat(p+grid/2.,grid);\n    \n    // rotation parameter\n    vec3 angle = vec3(-.1,-.2,.3)+cell*78.-t*.01;\n    \n    // kif\n    const float count = 11.0;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (float index = 0.0; index < count; ++index)\n    {        \n        \n        // fold\n        p.xz = abs(p.xz)-0.5*a;\n        \n        // rotate\n        p.yx *= rot(angle.z/a);\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        \n        // sdf object\n        shape = sdBox(p, vec3(0.05,0.2,0.01)*a*2.5);\n        \n        // material\n        material = shape < scene ? index : material;\n        \n        // add\n        scene = min(scene, shape);\n        \n        // falloff\n        a /= 1.25;\n    }\n    \n    // crop tunnel\n    scene = max(scene, -sdBox(pp,vec3(0.1,0.05,.5)));\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,0);\n    vec3 at = vec3(0,0,1);\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*step(0.5,iMouse.z);\n    at.yz *= rot(-mouse.y);\n    at.xz *= rot(mouse.x);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = (cross(x, z));\n    vec3 ray = normalize(vec3(z * .5 + uv.x * x + uv.y * y));\n    vec3 pos = eye;\n    \n    float pixelSize = 1./iResolution.y;\n    \n    // raymarch\n    const float steps = 30.0;\n    float index;\n    for (index = steps; index > 0.0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < pixelSize)\n        {            \n            break;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n    \n    float shade = index/steps;\n\n    // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n    vec2 off=vec2(pixelSize,0);\n    vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n    // lighting\n    float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n    vec3 light = vec3(0.914,0.569,0.086) * sqrt(ld);\n    ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n    light += vec3(0.576,0.898,0.941) * pow(ld, 5.);\n\n    // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n    vec3 tint = .5+.5*cos(vec3(1,2,3)+material*2.+length(pos)*.5-2.);\n\n    // pixel color\n    fragColor.rgb = (tint + light) * shade;\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKXRR.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[288, 295, 315, 327, 1364], [1366, 1404, 1461, 1480, 3215]], "test": "untested"}
{"id": "sddSWs", "name": "Hemi Maxn vs Hemi Oct Normals", "author": "Dain", "description": "Top is HemiMaxN 2x8bit\nBottom is HemiOct  2x8bit\n\nThese are for encoding only the top hemisphere, for example they both could be used for encoding a 2 channel normal map or a skydome\n\nSee : https://gist.github.com/Niadb/794ea32f856820bc7e4f5a67c4246791\n", "tags": ["normals", "compression", "hemioct", "hemimaxn"], "likes": 3, "viewed": 526, "published": 3, "date": "1634252962", "time_retrieved": "2024-07-30T18:55:45.887684", "image_code": "//Hemi Oct is from: https://jcgt.org/published/0003/02/01/paper.pdf\n//HemiMaxn is alternative encoding I found\n\n//See this gist for code and compares them: https://gist.github.com/Niadb/794ea32f856820bc7e4f5a67c4246791\n//they have very similar average and maximum error\n\n//HemiOct is more accurate around z == 1\n//While HemiMaxn is more accurate along the diagnals and near z == 0\n\n/*\nError results for 2x8bit encodings\n\nUsing 4 million Fib points:\n\t\t Mean Error:  \n\t\t MaxN 0.23557  \n\t\t Oct  0.239541 \n\t\t Winner MaxN by Ratio 0.98342\n\t\n\t\t Max Error: \n\t\t MaxN 0.547869  \n\t\t Oct  0.548226 \n\t\t Winner MaxN by Ratio 0.999349\n         \n Using 4 million lat/long points:\n\t\t Mean Error:\n\t\t MaxN 0.235312\n\t\t Oct  0.23831\n\t\t Winner MaxN by Ratio 0.987419\n         \n\t\t Max Error:\n\t\t MaxN 0.545722\n\t\t Oct  0.548226\n\t\t Winner MaxN by Ratio 0.995432\n         \n\t My hemi oct results are very close to this papers https://jcgt.org/published/0003/02/01/paper.pdf\n\t HemiOct16  Mean error 0.24000   Max Error 0.55112\n     \n     As far as encode/decode time, HemiMaxn is less instructions in both cases, and should be slightly faster.\n\t HemiOct decode: 4 arith + 2 abs + normalize\n\t HemiMaxn decode: 2 abs + 1 max + 1 arith + normalize\n*/\n\n\n//The comparision & rendering code is taken from IQs Normal Comparison: https://www.shadertoy.com/view/llfcRl\n\n\n\n//-------------------------------------------------------------------------------------------\nuint   packSnorm2x12(vec2 v) { uvec2 d = uvec2(round(2047.5 + v*2047.5)); return d.x|(d.y<<12u); }\nuint   packSnorm2x8( vec2 v) { uvec2 d = uvec2(round( 127.5 + v* 127.5)); return d.x|(d.y<< 8u); }\nvec2 unpackSnorm2x8( uint d) { return vec2(uvec2(d,d>> 8)& 255u)/ 127.5 - 1.0; }\nvec2 unpackSnorm2x12(uint d) { return vec2(uvec2(d,d>>12)&4095u)/2047.5 - 1.0; }\n\n\n\nuint euclidean_to_hemi_maxn(in vec3 e) {\n\tfloat d = max(abs(e.x), abs(e.y));\n\tfloat sz = 1.0/(abs(e.z) + (d));   //could drop the abs(z)\n\tvec2 o = e.xy * sz;\n    return packSnorm2x8(o);\n}\nvec3 hemi_maxn_to_euclidean(uint c) {\n    vec2 e= unpackSnorm2x8(c);\n    float z = 1.0 - max(abs(e.x), abs(e.y));\n\treturn normalize(vec3(e,z));\n}\n\nuint hemi_octahedral_16( in vec3 nor )\n{\n    nor.xy *=  1.0/( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );//could drop the abs(z)\n \n    return packSnorm2x8(vec2(nor.x + nor.y, nor.x-nor.y));\n}\n\nvec3 i_hemi_octahedral_16( uint data )\n{\n    vec2 e = unpackSnorm2x8(data);\n    \n    vec2 temp = vec2(e.x + e.y, e.x - e.y) ;\n\tvec3 v = vec3(temp, 2.0 - abs(temp.x) - abs(temp.y));\n\treturn normalize(v);;\n}\n\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Encoding surface normals, which are 96 bits normally (pun!), into 16, 24 and 32 bits\n// (6x, 4x and 3x compression respectively). Similar by Aras' blog post\n//\n// http://aras-p.info/texts/CompactNormalStorage.html\n//\n// but more complete hopefully.\n//\n// Left to Right: Direct, ZIgnore, Cube Spherical, Spheremap and Octahedral encoding. \n// Top is 16 bits, middle is 24 bits, bottom is 32 bits. See at full screen for best comparison.\n//\n// Error Color Encoding:   blue = 0.0, red = 0.5 degrees\n// \n//\n// Octaheral compression with different bitrates: https://www.shadertoy.com/view/Mtfyzl\n//\n// You can compare ithese to Fibonacci projection here: https://www.shadertoy.com/view/4t2XWK\n\n\n\n// undef this to try a different shape\n//#define SPHERES\n//-------------------------------------------------------------------------------------------\n\n//----\n\n//=============================================================\n\nfloat map( vec3 p )\n{\n    p.x *= 0.8;\n    p *= 2.6;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    //p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.15;\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 4.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    // from Paul Malin (4 samples only in a tetrahedron\t\n    vec2 e = vec2(1.0,-1.0)*0.002;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n//============================================================\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 off = vec2(i,j)/float(AA) - 0.5;\n        \n        vec2  uv = vec2(1.0,2.0)*(fragCoord+off)/iResolution.xy;\n        ivec2 cx = ivec2(uv);\n        int   id = cx.y + cx.x;\n        vec2  px = uv - vec2(cx);\n\n        float anim = cos( 0.15*iTime + 2.2 );\n        float zoom = smoothstep( 0.2, 0.5, anim ); \n        float serr = smoothstep( 0.85, 0.9, abs(anim) ); \n\n\n        //-----------------------------------------------------\n        // camera\n        //-----------------------------------------------------\n        vec2  p = (-1.0+2.0*px) * 4.6 / (vec2(6.0*iResolution.y,3.0*iResolution.x)/iResolution.y);\n        vec3 ro = vec3(0.0,0.3*zoom,2.9);\n\n        vec3 ta = vec3(0.0,0.0,0.0);\n\n        vec3 rd = normalize( vec3(p.xy,-2.0-6.0*zoom) );\n\n        vec3 col = vec3(0.0);\n\n        //-----------------------------------------------------\n        // intersect geometry\n        //-----------------------------------------------------\n        #ifdef SPHERES\n        float b = dot( ro, rd );\n        float c = dot( ro, ro ) - 1.0;\n        float h = b*b - c;\n        #else\n        float h = intersect( ro, rd );\n        #endif\n        if( h>0.0 )\n        {\n            #ifdef SPHERES\n            // compute intersection\n            float t = -b - sqrt( h );\n            // compute normal\n            vec3 nor = normalize( ro + t*rd );\n            #else\n            vec3 pos = ro + h*rd;\n            vec3 nor = calcNormal( pos );\n            #endif\n\n            //-----------------------------------------------------\n            // compress/encode and decompress/decode normal\n            //-----------------------------------------------------\n            uint data = 0u;\n            vec3 mor = vec3(0.0);\n\n           if( id== 1 ) { data = euclidean_to_hemi_maxn( nor );     mor = hemi_maxn_to_euclidean( data );} //Top \n            else { data = hemi_octahedral_16( nor );       mor = i_hemi_octahedral_16( data );} //Bottom\n\n            //-----------------------------------------------------\n            // render reflection\n            //-----------------------------------------------------\n\n            vec3 ref = reflect( rd, mor );\n            col = texture(iChannel2,ref).xyz;\n\n            if( p.x>0.0 )\n            {\n                col = 0.4 + 0.4*ref + 32.0*pow( clamp(dot(ref,vec3(0.5773)),0.0,1.0), 128.0 );\n            }\n\n            // error\n            float err = acos(dot(mor,nor));\n            err = clamp( err/radians(0.5), 0.0, 1.0 );\n            col = mix( col, 0.5 - 0.5*cos( sqrt(err)*3.1416 + vec3(0.0,2.0,4.0) ), serr );\n\n            // a bit of shading...\n            col *= abs(mor.z);\n        }\n        tot += col;\n    }   \n    tot /= float(AA*AA);\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1335, 1429, 1459, 1459, 1527], [1528, 1528, 1558, 1558, 1626], [1627, 1627, 1657, 1657, 1707], [1708, 1708, 1738, 1738, 1788], [1792, 1792, 1832, 1832, 1979], [1980, 1980, 2017, 2017, 2125], [2127, 2127, 2167, 2167, 2320], [2322, 2322, 2362, 2362, 2527], [4527, 4527, 4548, 4548, 4713], [4716, 4716, 4759, 4759, 5013], [5015, 5015, 5047, 5104, 5296], [5375, 5375, 5432, 5432, 8261]], "test": "untested"}
{"id": "NscXWf", "name": "Newton_Fractals", "author": "Hitthesurf", "description": "Uses Newtons Method to create Fractals, z^5 = 1", "tags": ["newtonsmethod"], "likes": 5, "viewed": 230, "published": 3, "date": "1634251327", "time_retrieved": "2024-07-30T18:55:46.659620", "image_code": "const float h = 0.0001;\nconst int max_iter = 60;\n\nvec2 cjg(in vec2 c) {\n    //Complex conjugate\n\treturn vec2(c.x, -c.y);\n}\n\nvec2 cmul(in vec2 a, in vec2 b) {\n\n    //Complex multiple\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 cinv(in vec2 a){\n    //Complex inverse, returns 1/a\n    return vec2(a.x,-a.y)/(a.x*a.x+a.y*a.y);\n}\n\nvec2 csin(in vec2 z){\n    return vec2(sin(z.x)*cosh(z.y),cos(z.x)*sinh(z.y));\n}\n\nvec2 ccosh(in vec2 z) {\n    return vec2(cosh(z.x)*cos(z.y), sinh(z.x)*sin(z.y));\n}\n\nvec2 cpow(in vec2 z, in int p){\n    //cpow is slower than using cmul multiple times\n    vec2 zeta = vec2(1.,0.);\n    for (int i = 0; i<10;i++)\n    {\n        if (i<p){zeta = cmul(z,zeta);}\n    }\n    return zeta;\n\n}\n\nfloat cmpxmodsquared(in vec2 a)\n{\n    return (a.x*a.x+a.y*a.y);\n}\n\n\nvec2 f(vec2 z)\n{\n    //return cmul(cmul(z,z),cmul(cmul(z,z),z))-vec2(1.,0.);\n    //return csin(0.5*(z-vec2(3.,0.)))-vec2(0.5,0.);\n    return cpow(z,8)+15.*cpow(z,5)-vec2(16.,0.)+csin(z);\n    //return ccosh(z)-vec2(1.,0.);\n    //return (cpow(z,3)-2.*z+vec2(2.,0.));\n}\n\nvec2 f_p(vec2 z)\n{\n    return (f(z+vec2(h,0.0))-f(z))/h;\n\n}\n\n/*\nvec2 f_p(vec2 z)\n{\n    return 3.*cmul(z,z);\n}\n*/\n\nvec3 Newtons_Method(vec2 z_0)\n{\n    vec2 z = z_0;\n    int counter = 0;\n    for (int i = 0; i <max_iter; i++) \n    {\n            z = z - cmul(cinv(f_p(z)),f(z));\n            if (cmpxmodsquared(f(z)) > h)\n            {\n                counter ++;\n            }\n    }\n    return vec3(z, float(counter));\n    //counter iterations until convergence\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Normalises x between -1 and 1\n    vec2 uv = 3.*(fragCoord-0.5*iResolution.xy)/iResolution.x + vec2(0.,0.);\n    \n    \n    // Normalized y pixel coordinates (from -1 to 1)\n    //vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 outputNM = Newtons_Method(uv);\n    float b_ratio =1. - outputNM.z/float(max_iter);  //Brightness ratio\n    vec2 col = outputNM.xy;\n    col = normalize(col);\n    // Output to screen\n    fragColor = b_ratio*vec4(col,-col.x,1.0); //Make sure no +- reals with same imag\n    //fragColor = vec4(col,-col.y,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 71, 95, 122], [124, 124, 157, 181, 243], [245, 245, 266, 301, 348], [350, 350, 371, 371, 429], [431, 431, 454, 454, 513], [515, 515, 546, 598, 728], [730, 730, 763, 763, 795], [798, 798, 814, 927, 1064], [1066, 1066, 1084, 1084, 1125], [1180, 1180, 1211, 1211, 1525], [1528, 1528, 1585, 1622, 2177]], "test": "untested"}
{"id": "fddXWs", "name": "Taste of Noise 8", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 8, "viewed": 405, "published": 3, "date": "1634249164", "time_retrieved": "2024-07-30T18:55:47.650970", "image_code": "// Fork of \"Taste of Noise 7\" by leon. https://shadertoy.com/view/NddSWs\n// 2021-10-14 00:25:36\n\n\n// taste of noise 8 by leon denise 2021/10/15\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "// taste of noise 8 by leon denise 2021/10/15\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time\n    float t = iTime*2.+rng*9.;\n    \n    /*float grid = 5.;\n    vec3 cell = floor(p/grid);\n    p = repeat(p,grid);*/\n    \n    float dp = length(p);\n    \n    // rotation parameter\n    vec3 angle = vec3(.1,-5.5,.1)+t*.1;//+dp*.5;//+cell;\n    \n    float size = sin(rng*3.14);\n    \n    //float wave = sin(t*.4+p.y);\n    //float w = wave*.5+.5;\n    \n    // kif\n    const int count = 4;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        float wave = sin(t*.4+p.y+float(index)*.2);\n        // fold\n        p.xz = abs(p.xz)-(.6+wave*.2)*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-0.2*a*size;\n        \n        // material blending\n        material = mix(material, float(index), smoothing(shape, scene, 0.3*a));\n        \n        // add\n        scene = smin(scene, shape, (1.+wave*.2)*a);\n        \n        // falloff\n        a /= 2.;\n    }\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,3.);\n    vec3 at = vec3(0,0,0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = (cross(x, z));\n    vec3 ray = normalize(vec3(z * 1. + uv.x * x + uv.y * y));\n    vec3 pos = eye;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // raymarch\n    const float steps = 30.0;\n    float index;\n    for (index = steps; index > 0.0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.001)\n        {            \n            break;\n        }\n        \n        // dithering\n        dist *= 0.5 + .1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n    \n    float shade = index/steps;\n\n    // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n    vec2 off=vec2(.001,0);\n    vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n    // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n    vec3 tint = vec3(.5)+vec3(.5)*cos(vec3(1,2,3)+material*.2+length(pos)*1.5-1.);\n\n    // lighting\n    float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n    vec3 light = vec3(0.537,0.733,0.243) * sqrt(ld);\n    ld = dot(reflect(ray, normal), -vec3(0,0,1))*0.5+0.5;\n    light += vec3(1) * pow(ld, 4.)*.5;\n\n    // pixel color\n    fragColor.rgb = (tint + light) * shade;\n\n    // temporal buffer\n    fragColor = max(fragColor, texture(iChannel0, fragCoord.xy/iResolution.xy) - 0.005);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXWs.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[339, 377, 434, 434, 504]], "test": "untested"}
{"id": "7dGXzz", "name": "Metaballs - MrNissenDK", "author": "MrNissenDK", "description": "Metaballs inspired by https://www.youtube.com/watch?v=ccYLb7cLB1I\nJust wanted to do something today", "tags": ["metaballs", "colors"], "likes": 5, "viewed": 390, "published": 3, "date": "1634243531", "time_retrieved": "2024-07-30T18:55:48.425898", "image_code": "/***************************************\n  *              Settings              *\n  ***************************************/\n  \nfloat res = 15.; // how many sqrs along the x axes\nfloat seed = 429496.7295;\nbool debug = false;\nfloat timeSpeed = 0.1;\nint balls = 20;\nfloat ballSize = 5.;\n\n/***************************************\n  *          Define Variables          *\n  ***************************************/\n  \nfloat pixelSize = 0.0;\nfloat time = 0.;\n\n\n/***************************************\n  *               Random               *\n  ***************************************/\n\nfloat random (vec2 st) {\n    return\n        fract(\n                sin( \n                    dot(\n                         st.xy\n                        ,vec2(12.9898,78.233)\n                    )\n                )\n            *seed\n            +seed\n        );\n}\n\n/***************************************\n  *               Lerp                 *\n  ***************************************/\nfloat lerp(float f1, float f2, float t)\n{\n\treturn (f1 + t * (f2-f1));\n}\n\nvec2 lerp(vec2 v1, vec2 v2, float t){\n\treturn (v1 + t * (v2-v1));\n}\nvec2 initPos(int id){\n    return vec2(\n        random(vec2(id)),\n        random(vec2(id + 313))\n    ) * res * 2. - res;\n}\n\n/***************************************\n  *                Mod                 *\n  ***************************************/\n  \nint modInt(int i, int j){\n    return int(mod(float(i),float(j)));\n}\n\n/***************************************\n  *             Main Code              *\n  ***************************************/\nvec2 pos(int id){\n    //float time = iTime / 10.;\n    int first = id + int(time) * 3;\n    int second = first + 1;\n    int third = first + 2;\n    int forth = first + 3;\n    \n    vec2 pos1 = initPos(first);\n    vec2 pos2 = initPos(second);\n    vec2 pos3 = initPos(third);\n    vec2 pos4 = initPos(forth);\n    \n    float t =  fract(time);\n    \n    vec2 lerp1 = lerp(pos1, pos2, t);\n    vec2 lerp2 = lerp(pos3, pos4, t);\n    \n    return lerp(lerp1, lerp2, t);\n}\n\nvec3 randomCol(int id){\n    return vec3(\n        random(vec2(id)),\n        random(vec2(id + 513)),\n        random(vec2(id + 541313))\n    );\n}\n\nfloat cirkle(vec2 uv,vec2 pos, float size)\n{\n    float dist = length(uv - pos);\n    float m = smoothstep(size, .01, dist);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * timeSpeed;\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    pixelSize = res / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    for(int i = 0; i < balls; i++){\n        int id = i * 500;\n        vec3 addCol = \n             randomCol(id)\n            *vec3(\n                cirkle(\n                     uv\n                    ,pos(id)\n                    ,ballSize\n                )\n            );\n        col += addCol;\n        \n        if(debug){\n            id += int(time) * 3;\n            float id1 = .1/length(uv - initPos(id + 0));\n            float id2 = .1/length(uv - initPos(id + 1));\n            float id3 = .1/length(uv - initPos(id + 2));\n            float id4 = .1/length(uv - initPos(id + 3));\n\n            col += vec3(id1, 0, 0);\n            col += vec3(0, id2, 0);\n            col += vec3(0, 0, id3);\n            col += vec3(id4);\n        }\n    }\n    if( debug && (\n        fract(uv.x) <= pixelSize || fract(uv.x) >= 1.-pixelSize || \n        fract(uv.y) <= pixelSize || fract(uv.y) >= 1.-pixelSize)\n    ) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[582, 582, 606, 606, 845], [847, 972, 1013, 1013, 1043], [1045, 1045, 1082, 1082, 1112], [1113, 1113, 1134, 1134, 1234], [1364, 1364, 1389, 1389, 1431], [1433, 1558, 1575, 1607, 2014], [2016, 2016, 2039, 2039, 2157], [2159, 2159, 2203, 2203, 2302], [2304, 2304, 2361, 2361, 3528]], "test": "untested"}
{"id": "ssyXRz", "name": "Computer Graphics assignment 1", "author": "Borisz42", "description": "Look around with mouse drag and move with WASD.", "tags": ["sdf", "camera", "spheretracing"], "likes": 2, "viewed": 182, "published": 3, "date": "1634240924", "time_retrieved": "2024-07-30T18:55:49.297567", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const int k = 4;\n    fragColor = vec4(0);\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\n//Primitives begin\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n//Primitives end\n\n//Rotations begin\nvec3 rotX(vec3 z, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(z.x, c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvec3 rotY(vec3 z, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c*z.x - s*z.z, z.y, c*z.z + s*z.x);\n}\nvec3 rotZ(vec3 z, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(c*z.x + s*z.y, c*z.y - s*z.x, z.z);\n}\n//Rotations end\n\nfloat sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    float head = sdSphere(p-vec3(0,12,0), 2.);\n    float g = sdBox(p,vec3(4,1,4));\n    float body = sdVerticalCapsule(p, 9.2, 0.8);\n    float torus = sdTorus(p-vec3(0,14.5,0), vec2(1.5,0.1));\n    float arms= sdCappedTorus(rotY(p-vec3(0,6,0), pi/2.), vec2(sin(1.7),cos(1.7)), 3., 0.7);\n    \n    float hornl = sdSphere(p-vec3(0,13.5,1.8), 1.);\n    float p1 = sdPlane(p-vec3(0,13.5,1.8), normalize(vec3(0,1,-1)), 0.);\n    hornl = max(hornl, p1);\n    \n    float hornr = sdSphere(p-vec3(0,13.5,-1.8), 1.);\n    float p2 = sdPlane(p-vec3(0,13.5,-1.8), normalize(vec3(0,1,1)), 0.);\n    hornr = max(hornr, p2);\n    \n    float eyel = sdSphere(p-vec3(-2,12,0.8), 0.5);\n    head = max(head,-eyel);\n    float eyer = sdSphere(p-vec3(-2,12,-0.8), 0.5);\n    head = max(head,-eyer);\n    \n    float mouth = sdSphere(p-vec3(-2,11.4,0), 0.95);\n    float mouthneg = sdSphere(p-vec3(-2,11.9,0), 1.);\n    mouth = max(mouth, -mouthneg);\n    head = max(head,-mouth);\n    \n    float frame = sdBoxFrame(p, vec3(4,16,4), 0.15);    \n    \n    float minDist = min(head, g);        \n    minDist = min(minDist, body);\n    minDist = min(minDist, torus);\n    minDist = min(minDist, arms);\n    minDist = min(minDist, hornl);\n    minDist = min(minDist, hornr);\n    minDist = min(minDist, frame);\n    minDist = min(minDist, p.y+1.);\n    return minDist;\n}", "buffer_a_code": "// This file contains the \n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    vec4 col = vec4(0.7, 0.7, 0.9, 1.0) - max(ray.V.y,0.0);\n    return vec4( clamp(col,0.0,1.0) );\n    //return vec4(texture(iChannel2, ray.V).xyz,1.); //eredeti\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 p = ray.P + ray.V*t;\n    vec3 n = normal(p);\n    \n        //light1 bengin\n        vec3 lightPos=rotY(vec3(10.,10.*(sin(iTime*0.7)+1.1),10.), iTime*0.7+pi);\n    \n    vec3 v = -ray.V;\n    vec3 l = normalize(lightPos-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = vec3(1./pi);\n    \n    //specular\n    vec3 k_s = vec3(0.4);\n    \n    vec3 h = normalize(l+v);\n    float si = pow(clamp(dot(h,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta;\n    //light1 end\n    \n        //light2 begin\n        vec3 lightPos2=rotY(vec3(10.,10.*(sin(iTime*0.7+pi)+1.1),10.), iTime*0.7);\n    \n    vec3 l2 = normalize(lightPos2-p);\n    \n    //diffuse\n    float costheta2 = max(dot(n,l2),0.);\n    vec3 k_d2 = vec3(1./pi);\n    \n    //specular\n    vec3 k_s2 = vec3(0.4);\n    \n    vec3 h2 = normalize(l2+v);\n    float si2 = pow(clamp(dot(h2,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col2 = (k_d2 + si2*k_s2)*costheta2;\n    //light2 end\n    \n        //light3 begin\n        vec3 lightPos3=rotY(vec3(100.,30.,0.), iTime*0.1);\n    \n    vec3 l3 = normalize(lightPos3-p);\n    \n    //diffuse\n    float costheta3 = max(dot(n,l3),0.);\n    vec3 k_d3 = vec3(1./pi);\n    \n    //specular\n    vec3 k_s3 = vec3(0.4);\n    \n    vec3 h3 = normalize(l3+v);\n    float si3 = pow(clamp(dot(h3,n),0.,1.),2000.);\n    \n    //sum\n    vec3 col3 = (k_d3 + si3*k_s3)*costheta3;\n    //light3 end\n    \n    \n    return vec4(col+col2/1.+col3/1.,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-30.,10.,3.);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.001, 256);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T);\n   // else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n    vec3 prevcol = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    float lambda = 0.3;\n    fragColor.rgb = (1.-lambda)*fragColor.rgb + lambda*prevcol;\n\n    fragColor.w = result.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyXRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 162]], "test": "untested"}
{"id": "NsyXzz", "name": "Physically based area light", "author": "hyperknot", "description": "Physically based lightness calculation\nfor a rectangular area light perpendicular to a\nmatte (Lambertian) ground plane, expanding up and down.\ndetails: https://hyperknot.com/blog/area_lights_in_shaders/", "tags": ["light", "area", "physics"], "likes": 10, "viewed": 681, "published": 3, "date": "1634228485", "time_retrieved": "2024-07-30T18:55:50.155274", "image_code": "// Physically based lightness calculation\n// for a rectangular area light perpendicular to a\n// matte (Lambertian) ground plane, expanding up and down.\n// details: https://hyperknot.com/blog/area_lights_in_shaders/\n\nfloat area_light_antideriv(vec2 uv, float i, float h, float t) {\n  float lxh = length(vec2(uv.x, h));\n  return -i * uv.x * atan((t-uv.y)/lxh) / lxh;\n}\n\nfloat area_light(vec2 uv, float i, float h_bottom, float h_top, float t_start, float t_end) {\n  // i - light's intensity\n  // h_top and h_bottom - the light's top and bottom above the ground\n  // t_start and t_end - the light's start and end on the y-axis\n  float v =\n  + area_light_antideriv(uv, i, h_top, t_end)\n  + area_light_antideriv(uv, i, h_bottom, t_start)\n  - area_light_antideriv(uv, i, h_bottom, t_end)\n  - area_light_antideriv(uv, i, h_top, t_start);\n  return max(0., v);\n}\n\n\nfloat lin_to_srgb ( float val ) {\n  if( val < 0.0031308 )\n    return val * 12.92;\n  else\n    return 1.055 * pow(val,1.0/2.4) - 0.055;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv *= 2.;\n\n    float h_top = pow(sin(iTime/3.), 2.) * 0.1 + 0.001;\n\n    float v = area_light(uv, 0.05, 0.0, h_top, -0.5, 0.5);\n    v += area_light(uv, -0.5, 0.0, h_top, -0.5, 0.5);\n    v = lin_to_srgb(v);\n\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyXzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 280, 280, 366], [368, 368, 461, 623, 853], [856, 856, 889, 889, 991], [993, 993, 1049, 1049, 1349]], "test": "untested"}
{"id": "7sdSWs", "name": "Maptoy - template", "author": "iY0Yi", "description": "This is a \"Maptoy\" template.\nI wanted an editor dedicated to distance functions, so I created it in Shadertoy.\nYou can bookmark this page, fork, and edit it.\nI've tried to keep everything but the map functions in the Common tab.", "tags": ["maptoy"], "likes": 24, "viewed": 428, "published": 3, "date": "1634221352", "time_retrieved": "2024-07-30T18:55:51.206463", "image_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.1.0\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Hotkeys:\n//  -------------------------------------------------------------\n//  1   | Camera: Front\n//  -------------------------------------------------------------\n//  3   | Camera: Side\n//  -------------------------------------------------------------\n//  7   | Camera: Top\n//  -------------------------------------------------------------\n//  0   | Camera: Free (release specific views above.)\n//  -------------------------------------------------------------\n//  W/S | Camera: Zoom +/-\n//  -------------------------------------------------------------\n//  Q   | ViewMode: Quad view\n//  -------------------------------------------------------------\n//  T   | ViewMode: Turntable\n//  -------------------------------------------------------------\n//  I   | Debug: ISO line\n//  -------------------------------------------------------------\n//  C   | Debug: Cost\n//  -------------------------------------------------------------\n//  N   | Debug: Normal\n//  -------------------------------------------------------------\n//  M   | Debug: Matcap (overwrite the Normal debug drawing.)\n//  -------------------------------------------------------------\n\n\nfloat map(vec3 p){\n    vec3 q = p;\n    float d = length(p)-.5;\n    p.xz += vec2(sin(p.z*.5+10.),cos(8.))*sin(iTime*.25);\n    p+=sin(p/PI*20.+sin(p.y*5.)*.5)*.2;\n    return (d + sin(length(p*50.))*.01) * .8;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.1.0\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.1.0 @ 2022/09/14 \n//        - Fixed long compilation in Quad view.\n//        - Many of the features went to hotkeys from #defines.\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n#define INIT_CAM_POS vec3(2,-2,2)\n#define CAM_DIST 8.\n#define CAM_INIT_SCALE 1.5\n#define TURN_TABLE_SPEED .5\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(.11)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_DEBUG_ISO vec2(14,0)\n#define C_DEBUG_COST vec2(16,0)\n#define C_DEBUG_MATCAP vec2(18,0)\n#define C_DEBUG_NORMAL vec2(20,0)\n#define render() \\\nbool isTurntable = false;\\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), INIT_CAM_POS.y, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-1,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x>.5;\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        vec2 offset;\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n        fragColor = vec4(renderRect(fragCoord*2.-offset),1);\\\n        if((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) || (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.))fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n    }\n    \n    if(ID(C_CAMERA)){\n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n    }\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        fragColor = last;\n        return;\n    }\n    \n    if(ID(C_QUAD_VIEW)){fragColor = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE)){fragColor = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO)){fragColor = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST)){fragColor = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){fragColor = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){fragColor = vec4(getToggle(K_N));return;}\n    \n    \n    \n    // Blank\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1609, 1609, 1627, 1627, 1817]], "test": "untested"}
{"id": "NdGSRz", "name": "Newton's fractal with roots", "author": "ninofiliu", "description": "Following, 3b1b's excellent youtube video on Newton's fractal, I just HAD to code it!", "tags": ["newton", "polynomial", "3blue1brown", "3b1b", "threeblueoneblrown"], "likes": 3, "viewed": 309, "published": 3, "date": "1634221246", "time_retrieved": "2024-07-30T18:55:52.084117", "image_code": "struct Closest {\n    int i;\n    float d;\n};\n\nvec2 mul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\nvec2 inv(vec2 a) { return vec2(a.x, -a.y) / (a.x*a.x + a.y*a.y); }\n\nconst int deg = 10;\nvec2 roots[deg];\n\nvec2 f(vec2 a) {\n    vec2 ret = vec2(1.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        ret = mul(ret, a-roots[i]);\n    }\n    return ret;\n}\n\nvec2 fp(vec2 a) {\n    vec2 sum = vec2(0.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        sum += inv(a-roots[i]);\n    }\n    return inv(sum);\n}\n\nClosest getClosest(vec2 u) {\n    Closest closest = Closest(0, distance(u, roots[0]));\n    for (int i = 1; i < deg; i++) {\n        float d = distance(u, roots[i]);\n        if (d < closest.d) {\n            closest.i = i;\n            closest.d = d;\n        }\n    }\n    return closest;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 a = 2.5 * (fragCoord - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for (int i = 0; i < deg; i++) {\n        float rot = 0.1 * iTime * (float(i)+1.0);\n        roots[i] = vec2(cos(rot), sin(rot));\n    }\n    \n    vec2 u = a;\n    Closest c;\n    for (int i = 0; i < 100; i++) {\n        u -= fp(u);\n        c = getClosest(u);\n        if (c.d < 0.1) { break; }\n    }\n    \n    fragColor.rgb = vec3(float(c.i) / float(deg));\n    \n    for (int i = 0; i < deg; i++) {\n        if (distance(roots[i], a) < 0.05) {\n            fragColor.r = 1.0;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 71, 71, 120], [121, 121, 139, 139, 187], [227, 227, 243, 243, 370], [372, 372, 389, 389, 517], [519, 519, 547, 547, 802]], "test": "untested"}
{"id": "fdySzR", "name": "Fab15 #inktober2021 \"helmet\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera\nInspiration: https://www.artyomprops.com/store/daft-punk-helmet-phftk ( see at bottom)", "tags": ["raymarching", "short", "reproduction", "daftpunk", "inktober2021"], "likes": 16, "viewed": 381, "published": 3, "date": "1634219877", "time_retrieved": "2024-07-30T18:55:52.952794", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n#define rB      length(max(a,0.)) + min(max(a.x,max(a.y,a.z)),0.)  // round cube https://iquilezles.org/articles/distfunctions\n#define C(r,l)  max( length(q.xy) - r, a.z-l )                     // cylinder\nfloat h;                                                           // material id\n\nfloat map( vec3 q) {               // --- scene SDF\n    vec3 a = abs(q) - vec3(1,1,0);                                 // glass part\n    float t = rB - 1., c,b,j;\n    q.xy -= .5,\n    c = min(q.x, j=.5*q.x+q.y),\n    t = h = max(t, -c );\n    \n    t = min(t, length(q-vec3(-.2,.5,0)) - 1. );                    // rear part\n    \n    a = abs(q) - vec3(.5,.5,0),                                    // top & jow arch\n    b = rB - 1.1;\n    b = max( b, abs(c)-.15 );\n    a.x+=.2; b = min( b, max(rB-1., j-.8 ) );                      // rear arch\n    q -= vec3(-.2,.1,0);\n    b = min(b, C(.7,1.1 ) );                                       // ears\n    b = min(b, c = max( abs(length(q.xy)-.45)-.05,a.z-1.2) );\n    b = min(b, max(C(.5,1.2), abs(j+.05)-.1));\n    q.y-=.08; b = min(b, C(.2,1.2) );\n    t = min( t,b );\n    t = max( t, -min(j+.15, rB-.95) );\n    return t;\n}\n\nvoid M(out vec4 O, vec2 U)       // --- mainImage, oversampled below\n{\n    float t=9.,_h;                                                 // hit object id \n    vec3  R = iResolution, e = vec3(-1,1,1)*1e-3, N,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),                  // ray direction\n          p = 9./R, q,                                             // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(.3*iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                                    // rotations\n        q.xz *= rot(2.-6.*M.x), \n        t = map(q),\n        p += .5*t*D;                                               // step forward = dist to obj\n    \n    _h=h;                                                          // normal\n    N = normalize( vec3( map(q+e.xyy)/e.xyy + map(q+e.yxy)/e.yxy + map(q+e.yyx)/e.yyx + map(q+e.xxx)/e.xxx ));\n    N.xz *= rot(-2.+6.*M.x);\n    N.yz *= rot(-.5+6.*M.y);                                       // back to cam space\n\n    if (t>=.01) return;\n  //O = vec4(dot(N,vec3(1,1,1))/1.7);\n    O = texture(iChannel0, reflect(D,N));                          // reflection map\n    t==_h ? O *= 10.*mix(pow(1.+dot(D,N),5.),1., .03)              // glass: Fresnel ( Schlick approx )\n          : O *= 2.*vec4(1,.8,.4,1);                               // metal: gold\n}\n\n\n\n\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    M(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { M(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdySzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 368, 388, 419, 1228], [1230, 1230, 1300, 1300, 2675], [2680, 2883, 2919, 2919, 3241]], "test": "untested"}
{"id": "3lXGD2", "name": "Interpollation between two obj", "author": "sevrin", "description": "big shade", "tags": ["inter"], "likes": 0, "viewed": 237, "published": 3, "date": "1634212446", "time_retrieved": "2024-07-30T18:55:53.837429", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float radius){\n \n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    \n    float t = dot(ap,ab) / dot(ab,ab);\n    t = clamp(t,0.,1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-radius;\n}\n\nfloat sdBox(vec3 p, vec3 size){\n    return length(max(abs(p)-size,.0));\n}\n\nfloat S( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nvec3 opRep(in vec3 p, in vec3 c){\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\n\n\nfloat GetDist(vec3 point){\n    \n \tvec4 sphere = vec4(0,1.+sin(iTime),6,0.2);\n    \n    float sphereDist = length(point - sphere.xyz) - sphere.w;\n    float planeDist = point.y;\n    \n    float capsuleDist = sdCapsule(point, vec3(-2,1,6), vec3(1,2,6), .3);\n\tfloat boxDist = sdBox(point-vec3(0,0.5,6), vec3(.5));\n    float sdP = sdPlane(point-vec3(0,1,8), vec4(0,1,0,1));\n    \n    \n    float d = min(sphereDist,planeDist);\n    d = min(d,S(sphereDist,boxDist,0.5));\n    d = min(d,S(sphereDist, sdP,0.2));\n   \t\n    \n    return d;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection){\n    \n \tfloat distanceOrigin = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 point = rayOrigin + rayDirection * distanceOrigin;\n        float distanceScene = GetDist(point);\n    \tdistanceOrigin += distanceScene;\n    \tif(distanceOrigin > MAX_DIST || distanceScene<SURF_DIST * 0.5) break;\n    }\n    return distanceOrigin;\n}\n\nvec3 GetNormal(vec3 point){\n    float dist = GetDist(point);\n    vec2 e = vec2(.01,0);\n    vec3 normal = dist - vec3(\n        GetDist(point-e.xyy),\n        GetDist(point-e.yxy),\n        GetDist(point-e.yyx)\n        );\n\n   \treturn normalize(normal);\n}\n\nfloat GetLight(vec3 point){\n    \n \tvec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    \n    vec3 light = normalize(lightPos - point);\n    vec3 normal = GetNormal(point);\n    float diffuse = clamp(dot(normal, light),0.,1.);\n    float dist = RayMarch(point + normal * SURF_DIST,light);\n    if(dist < length(lightPos - point)) diffuse *= .1;\n    return diffuse;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = vec3(0,2,1);\n    vec3 rayDirection = normalize(vec3(uv.x,uv.y,1));\n    vec3 col = vec3(0);\n    \n    float d = RayMarch(rayOrigin, rayDirection);\n    \n    vec3 point = rayOrigin + rayDirection * d;\n    \n    float diffuse = GetLight(point);\n    \n    col = vec3(diffuse);\n    \n    float s = abs(sin(iTime));\n    float c = cos(iTime);\n    \n    fragColor = vec4(col.x * c,col.y * s,col.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 121, 121, 295], [297, 297, 328, 328, 370], [372, 372, 412, 412, 512], [514, 514, 547, 573, 604], [605, 605, 638, 638, 683], [687, 687, 713, 713, 1211], [1213, 1213, 1263, 1263, 1600], [1602, 1602, 1629, 1629, 1852], [1854, 1854, 1881, 1881, 2244], [2247, 2247, 2304, 2304, 2778]], "test": "untested"}
{"id": "sdtXDl", "name": " Fab14 #inktober2021 \"tick\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nsound would be in sync if not for the iDate.w bug in Sound tab ;-)  . try rewind", "tags": ["2d", "clock", "short", "ease", "tick", "inktober2021"], "likes": 9, "viewed": 449, "published": 3, "date": "1634198825", "time_retrieved": "2024-07-30T18:55:54.598394", "image_code": "\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y, P;\n    \n    float t = mod(iDate.w,60.),\n          s = 2.*fract(t+.5)-1.;\n    s = s < 0. ? s += 1.145, s*=s*s, s = -s*s*(3.-2.*s)       // mad ease function. before tick\n               : 8.*sin(25.*s)/(1.+1e2*s);                    //                    after tick\n    P = .7*sin( (floor(t)+s)*.10471976 + vec2(0,33) );        // needle location\n\n    O = 1.-R.yyyy/4.*min( abs( length(U) - .8 ) -.03,         // circle\n                          length( U - P * clamp( dot(U,P)/dot(P,P), 0.,1.) ) -.01 ); // needle\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int s, float t )\n{\n    return vec2( fract( t + fract(iDate.w) ) );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 40, 40, 616]], "test": "untested"}
{"id": "flfXzf", "name": "black hole!", "author": "Arthas_me", "description": "It's a black hole now!", "tags": ["ripple"], "likes": 3, "viewed": 407, "published": 3, "date": "1634192225", "time_retrieved": "2024-07-30T18:55:55.384293", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2. * gl_FragCoord.xy) / iResolution.y; // -1 <> 1 by height\n\n    vec2 p_mouse = (-iResolution.xy + 2. * iMouse.xy) / iResolution.y;\n    \n\n    vec2 displace = (p - p_mouse) * pow(1./max( length(p - p_mouse), .25) * .3, 3.);\n    vec3 col = texture(iChannel0, p - displace).rgb;\n//    col = texture(iChannel0, p).rgb;\n    col = col * clamp(0., 1., pow(length(p - p_mouse) + 0.68, 35.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 546]], "test": "untested"}
{"id": "7ddSWl", "name": "Color Value Noise", "author": "theschwa", "description": "Value color noise", "tags": ["noise"], "likes": 0, "viewed": 216, "published": 3, "date": "1634186691", "time_retrieved": "2024-07-30T18:55:56.156229", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 pos2col ( vec2 ipos ) {\n\n    ipos += vec2(9.,0.); // Just moved to pick some nice colors\n    \n    float r = random( ipos + vec2( 12., 2. ) );\n    float g = random( ipos + vec2(7., 5. ) );\n    float b = random( ipos );\n\n    \n    vec3 col = vec3(r,g,b);\n    return col;\n}\n\nvec3 colorNoise ( vec2 st ) {\n    vec2 ipos = floor( st );\n    vec2 fpos = fract( st );\n\n    \n    // Four corners in 2D of a tile\n    vec3 a = pos2col(ipos);\n    vec3 b = pos2col(ipos + vec2(1.0, 0.0));\n    vec3 c = pos2col(ipos + vec2(0.0, 1.0));\n    vec3 d = pos2col(ipos + vec2(1.0, 1.0));\n    \n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = fpos*fpos*(3.0-2.0*fpos);\n    // u = smoothstep(0.,1.,fpos);\n    \n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec2 uv = st;\n    \n    float scale = 2.*abs(iTime/15. - floor(iTime/15. + .5) )*50.;\n    st *= scale;\n    \n    vec3 col = colorNoise( st );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 161, 161, 407], [409, 409, 438, 438, 973], [975, 975, 1032, 1082, 1375]], "test": "untested"}
{"id": "NstSDs", "name": "Hyperbolic Group Limit Set", "author": "neozhaoliang", "description": "old version of https://www.shadertoy.com/view/WdGBz3", "tags": ["3d", "tiling", "hyperbolic", "limitset"], "likes": 165, "viewed": 5733, "published": 3, "date": "1634176278", "time_retrieved": "2024-07-30T18:55:57.039866", "image_code": "/*\n=============================================\n\nLimit set of rank 4 hyperbolic Coxeter groups\n\n                                by Zhao Liang\n=============================================\n\nThis program shows the limit sets of rank 4 hyperbolic Coxeter groups.\n\nSome math stuff:\n\nLet G be a hyperbolic Coxeter group, and let x be a point located\nwithin the hyperbolic unit ball. The orbit S_x = { gx | g \\in G }\nhas accumulation points (under the Euclidean metric) only on the\nboundary of the space. These accumulation points are called the limit\nset of the group. This set is independent of the choice of x, and it\nis the smallest closed subset of the boundary that remains invariant\nunder the action of the group.\n\nThe Coxeter-Dynkin diagram of a rank 4 Coxeter group of string type\nhas the form\n\n   A --- B --- C --- D\n      p     q     r\n\nHere A, B, D can be chosen as ususal Euclidean planes,\nC is a sphere orthongonal to the unit ball. This is taken from\n@mla's notation, and as far as I know this is also used by\nusers on fractalforums. (fragmentarium)\n\nIn this animation these points are colored in \"brass metal\".\n\n==========\n!important\n==========\n\nThe limit set is a closed set with no interior points, to show them\nwe have to use an approximate procedure: we simply try to reflect a\npoint p on the boundary back to the fundamental domain up to a maximum\nsteps, once failed then we think p belongs to the limit set.\n\n**So the number MAX_REFLECTIONS is an important parameter**,\nif it's set too high then little limit set will be shown, or if it's\nnot high enough then the boundary of the set will look too coarse,\nso beware of this.\n\nAs always, you can do whatever you want to this work.\n\nUpdate: thanks @mla for helping fix some bugs!\n\nYou can try more patterns like\n(3, 7, 3), (4, 6, 3), (4, 4, 5), (5, 4, 4), (7, 3, 4), ..., etc.\n5, 4, 4) is my favorite!\nSet PQR below to see the result.\nFor large PQRs the limit set will become too small to be visible,\nyou need to adjust MAX_REFLECTIONS and tweak with the function\nchooseColor to get appealling results.\n*/\n\n#define inf        -1.\n\n// Try this one!\n//const vec3 PQR = vec3(6, 3, inf);\n\n// and this one!\n//const vec3 PQR = vec3(4, 4, 5);\n\nconst vec3 PQR = vec3(3, 3, 7);\n\n// --------------------------\n// some global settings\n\n#define MAX_TRACE_STEPS  100\n#define MIN_TRACE_DIST   0.1\n#define MAX_TRACE_DIST   100.0\n#define PRECISION        0.0001\n#define AA               2\n#define MAX_REFLECTIONS  500\n#define PI               3.141592653\n\n// another pattern\n//#define CHECKER1  vec3(0.196078, 0.33, 0.82)\n//#define CHECKER2  vec3(0.75, 0.35, 0.196078)\n\n/*\n#define CHECKER1  vec3(0.82, 0.196078, 0.33)\n#define CHECKER2  vec3(0.196078, 0.35, 0.92)\n#define MATERIAL  vec3(0.71, 0.65, 0.26)\n#define FUNDCOL   vec3(0., 0.82, .33)\n*/\n\n// Shane's color scheme\n#define CHECKER1  vec3(0., 0., 0.05)\n#define CHECKER2  vec3(0.2)\n#define MATERIAL  vec3(10, 0.3, 0.2)\n#define FUNDCOL   vec3(.3, 1, 8)\n\n\n// used to highlight the limit set\n#define LighteningFactor 8.\n// --------------------------\n\nvec3 A, B, D;\nvec4 C;\nfloat orb;\n\nfloat dihedral(float x) { return x == inf ? 1. : cos(PI / x); }\n\n// minimal distance to the four mirrors\nfloat distABCD(vec3 p)\n{\n    float dA = abs(dot(p, A));\n    float dB = abs(dot(p, B));\n    float dD = abs(dot(p, D));\n    float dC = abs(length(p - C.xyz) - C.w);\n    return min(dA, min(dB, min(dC, dD)));\n}\n\n// try to reflect across a plane with normal n and update the counter\nbool try_reflect(inout vec3 p, vec3 n, inout int count)\n{\n    float k = dot(p, n);\n    // if we are already inside, do nothing and return true\n    if (k >= 0.0)\n    \treturn true;\n\n    p -= 2.0 * k * n;\n    count += 1;\n    return false;\n}\n\n// similar with above, instead this is a sphere inversion\nbool try_reflect(inout vec3 p, vec4 sphere, inout int count)\n{\n    vec3 cen = sphere.xyz;\n    float r = sphere.w;\n    vec3 q = p - cen;\n    float d2 = dot(q, q);\n    if (d2 == 0.0)\n    \treturn true;\n    float k = (r * r) / d2;\n    if (k < 1.0)\n    \treturn true;\n    p = k * q + cen;\n    count += 1;\n    orb *= k;\n    return false;\n}\n\n// sdf of the unit sphere at origin\nfloat sdSphere(vec3 p, float radius) { return length(p) - 1.0; }\n\n// sdf of the plane y=-1\nfloat sdPlane(vec3 p, float offset) { return p.y + 1.0; }\n\n// inverse stereo-graphic projection, from a point on plane y=-1 to\n// the unit ball centered at the origin\nvec3 planeToSphere(vec2 p)\n{\n    float pp = dot(p, p);\n    return vec3(2.0 * p, pp - 1.0).xzy / (1.0 + pp);\n}\n\n// iteratively reflect a point on the unit sphere into the fundamental cell\n// and update the counter along the way\nbool iterateSpherePoint(inout vec3 p, inout int count)\n{\n    bool inA, inB, inC, inD;\n    for(int iter=0; iter<MAX_REFLECTIONS; iter++)\n    {\n        inA = try_reflect(p, A, count);\n        inB = try_reflect(p, B, count);\n        inC = try_reflect(p, C, count);\n        inD = try_reflect(p, D, count);\n        p =  normalize(p);  // avoid floating error accumulation\n        if (inA && inB && inC && inD)\n            return true;\n    }\n    return false;\n}\n\n// colors for fundamental domain, checker pattern and limit set.\nvec3 chooseColor(bool found, int count)\n{\n    vec3 col;\n    if (found)\n    {\n        if (count == 0) return FUNDCOL;\n        else if (count >= 300) col = MATERIAL;\n        else\n            col = (count % 2 == 0) ? CHECKER1 : CHECKER2;\n\n    }\n    else\n        col = MATERIAL;\n\n    float t =  float(count) / float(MAX_REFLECTIONS);\n    col = mix(MATERIAL*LighteningFactor, col, 1. - t * smoothstep(0., 1., log(orb) / 32.));\n    return col;\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\nvec2 map(vec3 p)\n{\n    float d1 = sdSphere(p, 1.0);\n    float d2 = sdPlane(p, -1.0);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * t)\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 12; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.2);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.02, lDist, 32.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = 2. / (1. + lDist * lDist * .01);\n\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 32.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n\n    col += basecol * diff;\n    col += basecol * vec3(1., 0.8, 0.3) * spec * 20.;\n    col += basecol * vec3(0.8) * pow(fres, 5.0) * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.y, 0., 1.) * 0.5;\n    return col;\n}\n\nmat3 sphMat(float theta, float phi)\n{\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(cy, -sy * -sx, -sy * cx,\n                0,   cx,  sx,\n                sy,  cy * -sx, cy * cx);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 finalcol = vec3(0.);\n    int count = 0;\n    vec2 m = vec2(0.0, 1.0) + iMouse.xy / iResolution.xy;\n    float rx = m.y * PI;\n    float ry = -m.x * 2. * PI;\n    mat3 mouRot = sphMat(rx, ry);\n\n// ---------------------------------\n// initialize the mirrors\n\n    float P = PQR.x, Q = PQR.y, R = PQR.z;\n    float cp = dihedral(P), sp = sqrt(1. - cp*cp);\n    float cq = dihedral(Q);\n    float cr = dihedral(R);\n    A = vec3(0,  0,   1);\n    B = vec3(0, sp, -cp);\n    D = vec3(1,  0,   0);\n\n    float r = 1.0 / cr;\n    float k = r * cq / sp;\n    vec3 cen = vec3(1, k, 0);\n    C = vec4(cen, r) / sqrt(dot(cen, cen) - r * r);\n\n// -------------------------------------\n// view setttings\n\n    vec3 camera = vec3(3., 3.2, -3.);\n    vec3 lp = vec3(0.5, 3.0, -0.8); //light position\n    camera.xz = rot2d(camera.xz, iTime*0.3);\n    vec3 lookat  = vec3(0., -0.5, 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n// -------------------------------------\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++)\n    {\n        for(int jj=0; jj<AA; jj++)\n        {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 3.0 * forward);\n            orb = 1.0;\n            // ---------------------------------\n            // hit the scene and get distance, object id\n\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            bool found;\n            float edist;\n            vec3 col;\n            // the sphere is hit\n            if (id == 0.)\n            {\n                vec3 nor = pos;\n                vec3 q = pos * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n\n                col = getColor(camera, rd, pos, nor, lp, basecol);\n            }\n            // the plane is hit\n            else if (id == 1.)\n            {\n                vec3 nor = vec3(0., 1., 0.);\n                vec3 q = planeToSphere(pos.xz);\n                q = q * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n                col = getColor(camera, rd, pos, nor, lp, basecol) * .9;\n            }\n            // draw the arcs\n            col = mix(col, vec3(0.), (1.0 - smoothstep(0., 0.005, edist))*0.85);\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            finalcol += col;\n        }\n    }\n    finalcol /= (float(AA) * float(AA));\n\n// ------------------------------------\n// a little post-processing\n\n    finalcol = mix(finalcol, 1. - exp(-finalcol), .35);\n    fragColor = vec4(sqrt(max(finalcol, 0.0)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3084, 3084, 3109, 3109, 3147], [3149, 3189, 3213, 3213, 3395], [3397, 3467, 3524, 3524, 3704], [3706, 3764, 3826, 3826, 4096], [4098, 4134, 4172, 4172, 4198], [4200, 4225, 4262, 4262, 4282], [4284, 4392, 4420, 4420, 4501], [4503, 4619, 4675, 4675, 5074], [5076, 5141, 5182, 5182, 5580], [5582, 5597, 5626, 5626, 5674], [5676, 5676, 5694, 5694, 5831], [5833, 5858, 5882, 5882, 6130], [6132, 6186, 6225, 6225, 6512], [6514, 6514, 6551, 6551, 6809], [6812, 6812, 6881, 6881, 7160], [7163, 7163, 7239, 7239, 7916], [7918, 7918, 7955, 7955, 8173]], "test": "untested"}
{"id": "NddXWs", "name": "pac land-house", "author": "jorge2017a2", "description": "pac land-house", "tags": ["2d", "house", "land", "pac"], "likes": 6, "viewed": 219, "published": 3, "date": "1634173123", "time_retrieved": "2024-07-30T18:55:57.881616", "image_code": "///pac land-house-2d-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n    return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{   vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{   vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n\nvec3 Suelo1(vec2 p, vec3 col)\n{  col=DrawFig(vec3(0.75,0.35,0.2), col, p.y-0.5 );\n return col;\n}\n\nvec3 colina(vec2 p, vec3 col)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,2.0) );\n    col=DrawFigBordeCol(vec3(0.0,0.95,0.2), col, d1 , vec3(0.35));\n    return col;\n}\n\nvec3 colina2(vec2 p, vec3 col, float escala)\n{   p.x=opRep1D(p.x, 8.5 );\n    float d1= sdTriangleIsosceles(vec2(p.x,-p.y+0.5), vec2(4.0,5.0) );\n    col=DrawFigBordeCol(vec3(0.0,0.95,0.2)*escala, col, d1 , vec3(0.35));\n    return col;\n}\n\n\nvec3 casa1(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-1.0), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    col= DrawFigBorde(vec3(0.5,0.6,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d4 );\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    return col;\n}\n\n\nvec3 casa2(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.4,-5.0), vec2(1.1,2.5) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.7), 4.0, 1.3, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    col= DrawFigBorde(vec3(0.4,0.8,1.00),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\n\nvec3 casa3(vec2 p, vec3 col)\n{   float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.5,-5.3), vec2(1.2,3.2) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.6), 4.0, 1.9, 0.5 );\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.7, 0.5 );\n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n   \n   col= DrawFigBorde(vec3(1.0,0.8,0.1),col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );\n    col= DrawFigBorde(vec3(0.0),col, d2 );\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 );\n    col= DrawFigBorde(vec3(0.2,0.2,1.0),col, d4 ); //puerta\n    col= DrawFigBorde(vec3(1.0,0.0,0.0),col, d5 );\n    col= DrawFigBorde(vec3(0.0),col, d7a );\n    col= DrawFigBorde(vec3(0.0),col, d8a );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 );\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 );\n    return col;\n}\n\n\nvec3 grupo1(vec2 uv, vec3 col)\n{   col=casa3(uv-vec2(0.0,-1.0), col);\n    col=casa2(uv-vec2(12.0,-1.0), col);\n    col=casa1(uv-vec2(25.0,-1.0), col);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=8.0;\n    vec2 uv1=uv;\n    vec2 uv2=uv;\n    uv1.x=opRep1D(uv1.x,100.);\n    uv2.x=opRep1D(uv2.x,100.0);\n    float tt=mod(iTime,14.0)*4.0;\n    \n    uv1.x+=tt;\n    uv2.x+=tt;\n    //col=colina2(uv1-vec2(3.0,3.0), col,0.8);\n    col=colina(uv1-vec2(0.0,1.0), col);\n    col=Suelo1(uv1-vec2(0.0,-1.0), col);\n    col= grupo1(uv1-vec2(0.0,1.2), col);\n    col= grupo1(uv2*2.0-vec2(70.0,1.0), col);\n    col= grupo1(uv1-vec2(20.0,-7.0), col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 317, 317, 412], [413, 444, 480, 480, 525], [530, 574, 621, 621, 648], [649, 649, 692, 692, 719], [720, 720, 768, 768, 796], [802, 802, 864, 864, 1060], [1062, 1062, 1143, 1143, 1270], [1272, 1272, 1329, 1329, 1399], [1401, 1401, 1438, 1438, 1516], [1518, 1518, 1553, 1553, 1576], [1578, 1578, 1629, 1629, 1935], [1938, 1938, 2004, 2004, 2344], [2347, 2347, 2378, 2378, 2443], [2445, 2445, 2476, 2476, 2658], [2660, 2660, 2706, 2706, 2895], [2898, 2898, 2928, 2928, 3623], [3626, 3626, 3656, 3656, 4823], [4826, 4826, 4856, 4856, 6020], [6023, 6023, 6055, 6055, 6190], [6193, 6193, 6250, 6250, 6863]], "test": "untested"}
{"id": "NddSWs", "name": "Taste of Noise 7", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 481, "viewed": 17924, "published": 3, "date": "1634170297", "time_retrieved": "2024-07-30T18:55:58.756277", "image_code": "\n// taste of noise 7 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "// taste of noise 7 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// thanks to Fabrice Neyret for code reviews\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time stretched with noise\n    float t = iTime*1. + rng*0.9;\n    \n    // domain repetition\n    float grid = 5.;\n    vec3 cell = floor(p/grid);\n    p = repeat(p,grid);\n    \n    // distance from origin\n    float dp = length(p);\n    \n    // rotation parameter\n    vec3 angle = vec3(.1,-.5,.1) + dp*.5 + p*.1 + cell;\n    \n    // shrink sphere size\n    float size = sin(rng*3.14);\n    \n    // stretch sphere\n    float wave = sin(-dp*1.+t+hash13(cell)*6.28)*.5;\n    \n    // kaleidoscopic iterated function\n    const int count = 4;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        // fold and translate\n        p.xz = abs(p.xz)-(.5+wave)*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-0.2*a*size;\n        \n        // material blending\n        material = mix(material, float(index), smoothing(shape, scene, 0.3*a));\n        \n        // add with a blend\n        scene = smin(scene, shape, 1.*a);\n        \n        // falloff transformations\n        a /= 1.9;\n    }\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(1,1,1.);\n    vec3 at = vec3(0,0,0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = cross(x, z);\n    vec3 ray = normalize(vec3(z + uv.x * x + uv.y * y));\n    vec3 pos = eye;\n    \n    // camera control\n    vec2 M = 6.28*(iMouse.xy-.5);\n    ray.xz *= rot(M.x), pos.xz *= rot(M.x);\n    ray.xy *= rot(M.y), pos.xy *= rot(M.y);\n    \n    // white noise\n    vec3 seed = vec3(fragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // raymarch\n    const float steps = 30.0;\n    float index;\n    for (index = steps; index > 0.0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            break;\n        }\n        \n        // dithering\n        dist *= 0.9 + .1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n    \n    // ambient occlusion from steps count\n    float shade = index/steps;\n\n    // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n    vec2 off=vec2(.001,0);\n    vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n\n    // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n    vec3 tint = .5+.5*cos(vec3(3,2,1)+material*.5+length(pos)*.5);\n\n    // lighting\n    float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n    vec3 light = vec3(1.000,0.502,0.502) * sqrt(ld);\n    ld = dot(reflect(ray, normal), vec3(0,0,-1))*0.5+0.5;\n    light += vec3(0.400,0.714,0.145) * sqrt(ld)*.5;\n\n    // pixel color\n    fragColor.rgb = (tint + light) * shade;\n\n    // temporal buffer\n    fragColor = max(fragColor, texture(iChannel0, fragCoord/iResolution.xy) - 0.01);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddSWs.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[242, 280, 337, 337, 404]], "test": "untested"}
{"id": "NstSDl", "name": "Polynomial experimentations #3", "author": "ninofiliu", "description": "Polynomial experimentations #3", "tags": ["polynomial"], "likes": 6, "viewed": 287, "published": 3, "date": "1634167887", "time_retrieved": "2024-07-30T18:55:59.634929", "image_code": "const int deg = 5;\nvec2 roots[deg];\n    \nvec2 mul(vec2 a, vec2 b) {\n    return vec2(\n        a.x*b.x - a.y*b.y,\n        a.x*b.y + a.y*b.y\n    );\n}\n\nvec2 div(vec2 a, vec2 b) {\n    return mul(a, vec2(b.x, -b.y))/(b.x*b.x+b.y*b.y);\n}\n\nvec2 inv(vec2 a) {\n    return vec2(a.x, -a.y) / (a.x*a.x + a.y*a.y);\n}\n\nvec2 f(vec2 a) {\n    vec2 ret = vec2(1.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        ret = mul(ret, a-roots[i]);\n    }\n    return ret;\n}\n\nvec2 fp(vec2 a) {\n    vec2 sum = vec2(0.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        sum += inv(a-roots[i]);\n    }\n    return inv(sum);\n}\n\nvec4 col(vec2 a) {\n    return vec4(\n        1.0/(1.0+abs(a.x)),\n        1.0/(1.0+abs(a.y)),\n        1.0/(1.0+0.01*abs(a.y)),\n        1.0\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    roots[0] = vec2(cos(0.6*iTime), sin(0.6*iTime));\n    roots[1] = vec2(cos(0.4*iTime), sin(0.5*iTime));\n    roots[2] = vec2(cos(0.1*iTime), sin(0.1*iTime));\n    roots[3] = vec2(cos(0.1*iTime), sin(0.3*iTime));\n    roots[4] = vec2(cos(0.3*iTime), sin(0.4*iTime));\n    vec2 u0 = 2.0*(fragCoord-iResolution.xy/2.0)/min(iResolution.x, iResolution.y);\n    vec2 u = u0;\n    for(int i = 0; i < 3; i++) {\n        u -= div(f(u), fp(u));\n    }\n    fragColor = col(u);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 67, 67, 146], [148, 148, 174, 174, 230], [232, 232, 250, 250, 302], [304, 304, 320, 320, 447], [449, 449, 466, 466, 594], [596, 596, 614, 614, 741], [743, 743, 798, 798, 1260]], "test": "untested"}
{"id": "NstSWs", "name": "Foggy Mandelbulb", "author": "ThomasVallentin", "description": "Small test to experiment with ray marching", "tags": ["raymarching", "fractal", "color", "fog"], "likes": 2, "viewed": 214, "published": 3, "date": "1634167785", "time_retrieved": "2024-07-30T18:56:00.490640", "image_code": "#define PI 3.14159265\n#define MAX_STEPS 100\n#define HIT_DISTANCE 0.0001\n#define MAX_DIST 100.\n\n\nfloat distToMandelbub(vec3 pos, int iterations, float bailout, float power) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r;\n    \n\tfor (int i = 0; i < iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r > bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r) * power;\n\t\tfloat phi = atan(z.y,z.x) * power;\n\t\tdr =  pow( r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5 * log(r) * r / dr;\n}\n\n\nfloat signedDistToPlane(vec3 origin) {\n    return origin.y;\n}\n\n\nfloat signedDistToSphere(vec4 sphere, vec3 origin) {\n    return length(sphere.xyz - origin) - sphere.w;\n}\n\n\nvec2 smoothMin(float dstA, float dstB, float k, float power) {\n    float h = max(k - abs(dstA - dstB), 0.0) /k;\n    float m = pow(h, power) * 0.5;\n    float s = m * k / power;\n    \n    return (dstA < dstB) ? vec2(dstA - s, m) : vec2(dstB - s, 1.0 - m);\n}\n\n\nvec4 marchOnce(vec3 pos) {\n\n    vec3 mdbColor = vec3(1., 0, .15);\n    vec3 sphColor = vec3(0, 0.1, 1);\n\n    float mdbDist = distToMandelbub(pos, 15, 2.0, (cos(iTime  / 25. - PI) * 0.5 + 0.5) * 15. + 1.);\n    float sphDist = signedDistToSphere(vec4(0, 0, sin(iTime / 3.5) * 2., 0.2), pos);\n    \n    vec2 smin = smoothMin(mdbDist, sphDist, 0.3, 3.);\n\n    return vec4(mix(mdbColor, sphColor, smin.y), smin.x);\n}\n\n\nvec4 rayMarch(vec3 origin, vec3 direction) {\n    vec4 result = vec4(0);\n    for (int i=0 ; i < MAX_STEPS ; i++ ) {\n        vec3 p = origin + direction * result.w;\n        vec4 tempResult = marchOnce(p);\n    \n        result.w += tempResult.w;\n        result.xyz = tempResult.xyz;\n        if (result.w > MAX_DIST)\n            return vec4(0, 0, 0, 100000);\n            \n        if (tempResult.w < HIT_DISTANCE)\n            break;\n    }\n    \n    return result;\n}\n\n\nvec3 applyFog(vec3 rgb, float dist) {\n    vec3 fogColor = vec3(0.05, 0.1, 0.2);\n    float fogDensity = 1.;\n    float fogStartDist = 1.2;\n    \n    dist = dist - fogStartDist;\n\n    float fogAmount = 1.0 - exp( -dist * fogDensity);\n    return mix(rgb, fogColor, fogAmount);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    float time = iTime / 5.0; \n    float rotationRadius = 2.5;\n    \n\n    vec3 origin = vec3(sin(time) * rotationRadius, 0, -cos(time) * rotationRadius);\n    vec3 direction = normalize(vec3(uv.x, uv.y, 1));\n    mat3 spin = mat3(cos(time), 0,  sin(time),\n                    0, 1, 0,\n                    -sin(time), 0, cos(time));\n    direction = spin * direction;\n    \n    vec4 result = rayMarch(origin, direction);\n    \n    vec3 col = vec3(result.xyz);\n    col = applyFog(col, result.w);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 173, 173, 696], [699, 699, 737, 737, 760], [763, 763, 815, 815, 868], [871, 871, 933, 933, 1125], [1128, 1128, 1154, 1154, 1536], [1539, 1539, 1583, 1583, 1997], [2000, 2000, 2037, 2037, 2272], [2275, 2275, 2332, 2332, 2922]], "test": "untested"}
{"id": "fstSWs", "name": "Taste of Noise 6", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 16, "viewed": 461, "published": 3, "date": "1634167654", "time_retrieved": "2024-07-30T18:56:01.377269", "image_code": "// Fork of \"Taste of Noise 5\" by None. https://shadertoy.com/view/-1\n// 2021-10-13 23:04:34\n\n// taste of noise 6 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// licensed under hippie love conspiracy\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "// taste of noise 6 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time\n    float t = iTime*0.5 + rng*0.1;\n    \n    // rotation parameter\n    vec3 angle = vec3(.1,-.5,.1)+(t-length(p)*0.5);\n    \n    float size = sin(rng*3.14);\n    \n    // kif\n    const int count = 5;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        \n        // fold\n        p.xz = abs(p.xz)-1.*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-0.2*a*size;\n        \n        // material blending\n        material = mix(material, float(index), smoothing(shape, scene, 0.3*a));\n        \n        // add\n        scene = smin(scene, shape, 2.*a);\n        \n        // falloff\n        a /= 1.9;\n    }\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,-4.);\n    vec3 at = vec3(0,0,0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(vec3(z * 1. + uv.x * x + uv.y * y));\n    vec3 pos = eye + ray;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // raymarch\n    const int steps = 20;\n    for (int index = steps; index > 0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.001)\n        {\n            float shade = float(index)/float(steps);\n            \n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n            \n            // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n            //vec3 tint = vec3(.5)+vec3(.5)*cos(vec3(1,2,3)+material*.5+length(pos)*1.);\n            \n            // lighting\n            float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n            vec3 light = vec3(1.000,1.000,1.000) * pow(ld, 2.);\n            ld = dot(reflect(ray, normal), vec3(0,0,-1))*0.5+0.5;\n            light += vec3(0.122,0.749,0.859) * pow(ld, 0.5);\n            \n            // pixel color\n            fragColor.rgb = (light) * pow(shade, 1.);\n            \n            break;\n        }\n        \n        // dithering\n        dist *= 0.7 + .1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n\n    // temporal buffer\n    fragColor = max(fragColor, texture(iChannel0, gl_FragCoord.xy/iResolution.xy) - 0.01);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSWs.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[289, 327, 384, 384, 454]], "test": "untested"}
{"id": "NstXWl", "name": "Taste of Noise 5", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 28, "viewed": 782, "published": 3, "date": "1634165434", "time_retrieved": "2024-07-30T18:56:02.288832", "image_code": "// Fork of \"Taste of Noise 4\" by leon. https://shadertoy.com/view/7ddXWf\n// 2021-10-13 22:02:36\n\n// taste of noise 5 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// licensed under hippie love conspiracy\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, gl_FragCoord.xy/iResolution.xy);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "buffer_a_code": "// Fork of \"Taste of Noise 4\" by leon. https://shadertoy.com/view/7ddXWf\n// 2021-10-13 22:02:36\n\n// taste of noise 5 by leon denise 2021/10/14\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time\n    float t = iTime*0.1 + rng*0.1;\n    \n    // rotation parameter\n    vec3 angle = vec3(.1,-.1,.1)+(t*2.+p*0.3);\n    \n    float size = sin(rng*3.14);\n    \n    // kif\n    const int count = 8;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        \n        // fold\n        p.x = abs(p.x)-0.7*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-0.4*a*size;\n        \n        // material blending\n        material = mix(material, float(index), smoothing(shape, scene, 0.3*a));\n        \n        // add\n        scene = smin(scene, shape, 0.1*a);\n        \n        // falloff\n        a /= 1.3;\n    }\n    \n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,-4.);\n    vec3 at = vec3(0,0,0);\n    vec3 z = normalize(at-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(vec3(z * 2. + uv.x * x + uv.y * y));\n    vec3 pos = eye;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // raymarch\n    const int steps = 20;\n    for (int index = steps; index > 0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            float shade = float(index)/float(steps);\n            \n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n            \n            // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n            vec3 tint = vec3(.5)+vec3(.5)*cos(vec3(3,2,1)+material*.3+length(pos)*2.);\n            \n            // lighting\n            float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n            vec3 light = vec3(1.000,1.000,1.000) * pow(ld, 2.) * 0.5;\n            ld = dot(reflect(ray, normal), vec3(0,-1,0))*0.5+0.5;\n            light += vec3(0.859,0.122,0.455) * pow(ld, 0.5)*.5;\n            \n            // pixel color\n            fragColor.rgb = (tint + light) * shade;//pow(shade, 1.3);\n            \n            break;\n        }\n        \n        // dithering\n        dist *= 0.7 + .1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n\n    // temporal buffer\n    fragColor = max(fragColor, texture(iChannel0, gl_FragCoord.xy/iResolution.xy) - 0.01);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstXWl.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[293, 331, 388, 388, 458]], "test": "untested"}
{"id": "NdtXWl", "name": "Polynomial experimentations #2", "author": "ninofiliu", "description": "Playing around with broken implementations of the Newton's fractal", "tags": ["polynomial"], "likes": 2, "viewed": 236, "published": 3, "date": "1634162535", "time_retrieved": "2024-07-30T18:56:03.142550", "image_code": "const int deg = 3;\nvec2 roots[deg];\n    \nvec2 mul(vec2 a, vec2 b) {\n    return vec2(\n        a.x*b.x - a.y*b.y,\n        a.x*b.y + a.y*b.y\n    );\n}\n\nvec2 div(vec2 a, vec2 b) {\n    return mul(a, vec2(b.x, -b.y))/(b.x*b.x+b.y*b.y);\n}\n\nvec2 inv(vec2 a) {\n    return vec2(a.x, -a.y) / (a.x*a.x + a.y*a.y);\n}\n\nvec2 f(vec2 a) {\n    vec2 ret = vec2(1.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        ret = mul(ret, a-roots[i]);\n    }\n    return ret;\n}\n\nvec2 fp(vec2 a) {\n    vec2 sum = vec2(0.0, 0.0);\n    for (int i = 0; i < deg; i++) {\n        sum += inv(a-roots[i]);\n    }\n    return inv(sum);\n}\n\nvec4 col(vec2 a) {\n    return vec4(1.0/(1.0+0.1*abs(a.x)), 1.0/(1.0+0.21*abs(a.y)), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    roots[0] = vec2(cos(0.6*iTime), sin(0.3*iTime));\n    roots[1] = vec2(cos(0.4*iTime), sin(0.5*iTime));\n    roots[2] = vec2(cos(0.1*iTime), sin(0.1*iTime));\n    vec2 u = 2.0*(fragCoord-iResolution.xy/2.0)/min(iResolution.x, iResolution.y);\n    for(int i = 0; i < 3; i++) {\n        u -= div(f(u), fp(u));\n    }\n    fragColor = col(u);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 67, 67, 146], [148, 148, 174, 174, 230], [232, 232, 250, 250, 302], [304, 304, 320, 320, 447], [449, 449, 466, 466, 594], [596, 596, 614, 614, 692], [694, 694, 749, 749, 1087]], "test": "untested"}
{"id": "7ddXWf", "name": "Taste of Noise 4", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 20, "viewed": 637, "published": 3, "date": "1634162473", "time_retrieved": "2024-07-30T18:56:04.008235", "image_code": "// Fork of \"Taste of Noise 3\" by leon. https://shadertoy.com/view/fsdXWX\n// 2021-10-13 08:52:47\n\n\n// taste of noise 3 by leon denise 2021/10/12\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    vec3 pp = p;\n    \n    // time\n    float t = iTime;\n    \n    // rotation parameter\n    vec3 angle = vec3(4.,3.,1.+t*0.1+p.z*0.3);\n    \n    //angle.z += t*0.5;\n    //float loop = fract(t/10.)*6.28;\n    float wave = 0.2 * sin(length(p)*3.+2.);\n    \n    // kif\n    const int count = 5;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        \n        // fold\n        p.xz = abs(p.xz)-(.6+wave)*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);//+loop);\n        \n        // sphere\n        shape = length(p)-0.4*a;\n        //shape = sdBox(p, vec3(.3,0.1,.3)*a);\n        \n        // material blending\n        material = mix(material, float(index), smoothing(shape, scene, 0.3*a));\n        //material = shape < scene ? float(index) : material;\n        \n        // add\n        scene = smin(scene, shape, 0.2*a);\n        \n        // falloff\n        a /= 1.7;\n    }\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0,0,0,1);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,-4.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    eye.yz *= rot(0.5+mouse.x*3.);\n    eye.xy *= rot(0.5-mouse.y*3.);\n    vec3 z = normalize(-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(vec3(z * 1.5 + uv.x * x + uv.y * y));\n    vec3 pos = eye;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // raymarch\n    const int steps = 20;\n    for (int index = steps; index > 0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            float shade = float(index)/float(steps);\n            \n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n            \n            // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n            vec3 tint = vec3(.5)+vec3(.5)*cos(vec3(3,1,2)+material*.5+length(pos)*5.+iTime);\n            \n            // lighting\n            float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n            vec3 light = vec3(1.000,1.000,1.000) * pow(ld, 2.) * 0.5;\n            ld = dot(reflect(ray, normal), vec3(0,-1,0))*0.5+0.5;\n            light += vec3(0.859,0.122,0.455) * pow(ld, 0.5)*.5;\n            \n            // pixel color\n            fragColor.rgb = (tint + light) * shade;\n            \n            break;\n        }\n        \n        // dithering\n        dist *= 0.9 + 0.1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n}\n\n", "image_inputs": [], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddXWf.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[341, 348, 368, 368, 1407], [1409, 1447, 1504, 1523, 3352]], "test": "untested"}
{"id": "sscXDs", "name": "Asymmetric smooth-abs", "author": "athibaul", "description": "Smooth-min/smooth-max functions, but with independent controls for the smoothing radius of each element.", "tags": ["sdf", "smooth", "smin", "smax", "sabs"], "likes": 8, "viewed": 285, "published": 3, "date": "1634160002", "time_retrieved": "2024-07-30T18:56:04.896859", "image_code": "// By Alexis THIBAULT\n// Stemmed from a question by Fabrice Neyret: \n// https://www.facebook.com/groups/shadertoy/permalink/961319301115763/\n\nfloat sabs(float x, float a, float b){\n    // Asymmetric smooth-abs\n    \n    // For -b < x < a the graph is a tilted quarter of an ellipse\n    // Coincides with abs() for x < -b or x > a\n    \n    float d = x/2.;\n    float det = a*b + 2.*(a-b)*d - 2.*d*d;\n    \n    float mu = (x > -b && x<a) ?\n     2.*(a*a*(b+d) + b*b*(a-d) - sqrt(2.)*a*b*sqrt(det))/(a*a+b*b)\n     : abs(x);\n    \n    return mu;\n}\n\nfloat smin(float d1, float d2, float r1, float r2)\n{\n    // Asymmetric smooth-min\n    // The zero-set of perpendicular planes is an elliptic surface with radii (r1, r2)\n    \n    return 0.5*(d1+d2 - sabs(d1-d2, r1, r2));\n}\n\nfloat smax(float d1, float d2, float r1, float r2)\n{\n    // Asymmetric smooth-max\n    // The zero-set of perpendicular planes is an elliptic surface with radii (r1, r2)\n    \n    return 0.5*(d1+d2 + sabs(d1-d2, r1, r2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float r1 = 0.5 + 0.4*sin(iTime);\n    float r2 = 0.5 + 0.4*cos(1.62*iTime);\n    float d = smin(uv.x, uv.y, r1, r2) + 0.5;\n    \n    \n    \n    // coloring by iq : https://www.shadertoy.com/view/fd3SRf\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    //vec3 col = (d<0.0) ? vec3(0.5) : vec3(1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 180, 328, 538], [540, 540, 592, 708, 761], [763, 763, 815, 931, 984], [986, 986, 1043, 1043, 1618]], "test": "untested"}
{"id": "sscXWs", "name": "Polynomial experimentations #1", "author": "ninofiliu", "description": "Playing around with broken implementations of the Newton's fractal", "tags": ["polynomial"], "likes": 0, "viewed": 176, "published": 3, "date": "1634158759", "time_retrieved": "2024-07-30T18:56:05.769526", "image_code": "vec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 f(vec2 x) {\n    return mul(mul(x-vec2(1.0,1.0), x-vec2(1.0,-1.0)), x-vec2(-1.0,0.0));\n}\n\nvec2 fp(vec2 x) {\n    return mul(x, 3.0*x-5.0*sin(0.5*iTime));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 u = vec2(\n        fragCoord.x - iResolution.x / 2.0,\n        fragCoord.y - iResolution.y / 2.0\n    ) / min(iResolution.x, iResolution.y);\n    for (int i = 0; i < 7; i++) {\n        u = u - f(u)/fp(u);\n    }\n    fragColor = vec4(10.0/abs(u.x), 10.0/abs(u.y), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 81], [83, 83, 99, 99, 175], [177, 177, 194, 194, 241], [243, 243, 298, 298, 577]], "test": "untested"}
{"id": "7d3SDl", "name": "Interactive Fluid Clouds", "author": "intrakits", "description": "Click and drag to draw clouds which will move around in a fluid like motion.", "tags": ["interactive", "clouds", "fluid", "density", "navier", "stokes"], "likes": 0, "viewed": 363, "published": 3, "date": "1634147739", "time_retrieved": "2024-07-30T18:56:06.666129", "image_code": "//Navier-Stokes reference:      https://www.shadertoy.com/view/tt3yzn\n//3d cellular tiling reference: https://www.shadertoy.com/view/ld3Szs\n//cloud reference:              https://www.shadertoy.com/view/4sXGRM\n\n#define _StepSize 5.\n#define _VolDepth 1000.0\n#define _CloudScale 7.\n#define _CloudOffset 0.\n#define _DensityThreshold .1\n#define _DensityMultiplier .05\n\n\n#define _DarknessThreshold .3\n#define _LightAbsorbtion 100.\n#define _LightAbsorbtionTowardsSun 200.\n#define  _NumStepsLight 9\n#define _PhaseVal 100.\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\nvec2 cloudHeight = vec2(400,900);\n\nvec3 lightDir = normalize(vec3(0.1,.1,.5));\n\n\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.166));\n    \n}\n\nfloat cellTile(in vec3 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n\n    c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.);\n    \n}\n\n\nvec3 camera(float time)\n{\n    return vec3(sin(time*.5),0, time);\n}\nfloat getDensity(vec3 pos){\n    float n1 = smoothstep(.7,.1,cellTile(pos*.005));\n    float n2 = smoothstep(0.,.5,cellTile(pos*.001));\n   // float n3 = smoothstep(0.,.4,cellTile(pos*.00001));\n   // float n4 = smoothstep(0.,.4,cellTile(pos*.0002));\n    float alpha = smoothstep(0.5, 1.0,n1*n2);\n    alpha = max(0.,alpha-_DensityThreshold)*_DensityMultiplier;\n    return alpha;\n}\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n   // p*=.00025;\n    float f = 0.5000 * getDensity(p);\n    p = m * p;\n    f += 0.2500 * getDensity(p);\n    p = m * p;\n    f += 0.1666 * getDensity(p);\n    p = m * p;\n    f += 0.0834 * getDensity(p);\n    \n    return f;\n}\n// Fractional Brownian motion\nfloat getFlow(vec3 p){\n    p*=.0005;\n    float alpha =  texture(iChannel0, p.xy+vec2(.5,.5)).w;\n    alpha = max(0.,alpha-_DensityThreshold)*_DensityMultiplier;\n    alpha *= fbm(p/.0005+iTime*20.);\n    return alpha;\n}\n\nfloat lightmarch(vec3 pos){\n    vec3 dirToLight = lightDir;\n    float totalDensity = 0.;\n    for(float i = 0.; i < _VolDepth; i += _StepSize*200.){\n\n        pos += dirToLight *_StepSize;\n       \n        float alpha = getFlow(pos);//getDensity(pos);\n        \n        totalDensity += max(0.,alpha*_StepSize);\n    }\n    float transmittance = exp(-totalDensity * _LightAbsorbtionTowardsSun);\n    return _DarknessThreshold + transmittance * (1.-_DarknessThreshold);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    \n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + .1);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    vec3 lightE = vec3(0.);\n    float transmittance = 1.;\n    for (float depth = 0.0; depth < _VolDepth; depth += _StepSize)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudHeight.x < ray.z && ray.z < cloudHeight.y)\n        {\n            \n            float alpha =getFlow(ray);//getDensity(pos);\n            \n            alpha = (1.0 - sum.a) * alpha;\n            if(alpha >0.){\n                float lightTransmittance = lightmarch(ray);\n                lightE+=alpha*_StepSize*transmittance*lightTransmittance*_PhaseVal;\n                transmittance*= exp(-alpha*_StepSize*_LightAbsorbtion);\n                if(transmittance < 0.01){\n                  break;\n                }\n            }\n            sum += vec4(vec3(1) * alpha, alpha);\n        }\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb= lightE;\n    float sundot = clamp(dot(fragAt, lightDir), 0.0, 1.0);\n    vec3 col = 0.8 * (vec3(0,0,1));\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    col = mix(col, sum.rgb, 1.-transmittance);\n\n    //col=vec3(smoothstep(.0,.7,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.5,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.4,cellTile(vec3(uv.x*2.,uv.y*2.,0.))));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// advection & boundary & control\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);  \n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // advection\n    vec4 a = texture(iChannel0, (fragCoord-o.xy*dt)/iResolution.xy);\n    fragColor = a;\n    float coord = iResolution.x ;\n    \n    // interaction\n    if(sign(iMouse.z)==1.0f)\n    {\n        vec2 d = fragCoord-vec2(coord-iMouse.x,iMouse.y);\n        float r = length(d);\n        vec2 d2 = vec2(coord-iMouse.x,iMouse.y)-abs(iMouse.zw);\n        float r2 = length(d2);\n        if(r2>0.0f)\n        {\n            fragColor.xy += d2/r2*exp(-r*r*0.01f);\n            fragColor.w += 0.5f*exp(-r*r*0.01f);\n            fragColor.w = min(fragColor.w, .8f);\n        }\n    }\n    \n    // boundary condition\n    if(fragCoord.x == 0.5f)\n    {\n        fragColor.xy = -e.xy;\n        fragColor.z = e.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.y == 0.5f)\n    {\n        fragColor.xy = -n.xy;\n        fragColor.z = n.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.x == iResolution.x-0.5f)\n    {\n        fragColor.xy = -w.xy;\n        fragColor.z = w.z;\n        fragColor.w = 0.0f;\n    }\n    \n    if(fragCoord.y == iResolution.y-0.5f)\n    {\n        fragColor.xy = -s.xy;\n        fragColor.z = s.z;\n        fragColor.w = 0.0f;\n    }\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// pressure poisson\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // float divergence of the velocity\n    float div = (e.x - w.x + n.y - s.y) / (2.0f * dx * dx);\n    \n    // one jacobi iteration\n    float a = 1.0f / ( dx * dx);\n    float p = 1.0f / ( -4.0f * a ) * ( div - a * (n.z + e.z + s.z + w.z));\n\n    fragColor = vec4(o.xy, p, o.w);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// pressure poisson\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // float divergence of the velocity\n    float div = (e.x - w.x + n.y - s.y) / (2.0f * dx * dx);\n    \n    // one jacobi iteration\n    float a = 1.0f / ( dx * dx);\n    float p = 1.0f / ( -4.0f * a ) * ( div - a * (n.z + e.z + s.z + w.z));\n\n    fragColor = vec4(o.xy, p, o.w);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// projection\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 o = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0, 1), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 1, 0), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord) + ivec2( 0,-1), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(-1, 0), 0);\n    \n    // gradient of the pressure\n    vec2 grad = vec2( e.z - w.z, n.z - s.z ) / (2.0f * dx * dx);\n\n    // project\n    fragColor = vec4(o.xy - grad, o.zw);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float dt = 5.0f;\nconst float dx = 1.00f;\nconst float nu = 0.00001f;\n\n// The velocity field should be divergence free\n// Buffer B & C & D do their best to make sure it is\n// However, currently, they are only allowed 2 jacobi iterations to solve pressure poisson equation\n// This means the velocity field is not perfectly divergence free\n// This, in turn, means that the advection of the dye is poor: dye is lost :(.\n// This problem could be solved by taking smaller time steps, but that is boring of course.", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3SDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 671, 699, 699, 820], [822, 822, 848, 848, 1384], [1387, 1387, 1412, 1412, 1453], [1454, 1454, 1481, 1481, 1830], [1831, 1861, 1880, 1897, 2100], [2101, 2131, 2153, 2153, 2347], [2349, 2349, 2376, 2376, 2811], [2812, 2812, 2869, 2869, 4685]], "test": "untested"}
{"id": "7s3SWl", "name": "Physically based rod light", "author": "hyperknot", "description": "Physically based lightness calculation\nfor a rod light perpendicular to a\nmatte (Lambertian) ground plane, expanding up and down.\ndetails: https://hyperknot.com/blog/area_lights_in_shaders/", "tags": ["light", "physics", "arealight"], "likes": 4, "viewed": 521, "published": 3, "date": "1634145310", "time_retrieved": "2024-07-30T18:56:07.426097", "image_code": "// Physically based lightness calculation\n// for a rod light perpendicular to a\n// matte (Lambertian) ground plane, expanding up and down.\n// details: https://hyperknot.com/blog/area_lights_in_shaders/\n\nfloat rod_light_antideriv(vec2 uv, float i, float h) {\n  return i * uv.x / (dot(uv,uv) + h*h);\n}\n\nfloat rod_light(vec2 uv, float i, float h_top, float h_bottom) {\n  // h_top and h_bottom - the light's top and bottom above the ground\n  // i - light's intensity\n  return rod_light_antideriv(uv, i, h_top) - rod_light_antideriv(uv, i, h_bottom);\n}\n\n\nfloat lin_to_srgb ( float val ) {\n  if( val < 0.0031308 )\n    return val * 12.92;\n  else\n    return 1.055 * pow(val,1.0/2.4) - 0.055;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    float h = pow(sin(iTime/3.), 2.) * 0.1 + 0.002;\n    float v = rod_light(uv, 0.1, h, 0.001);\n    v = lin_to_srgb(v);\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3SWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 257, 257, 299], [301, 301, 365, 462, 547], [550, 550, 583, 583, 685], [687, 687, 743, 743, 954]], "test": "untested"}
{"id": "Ns3XWf", "name": "Spiraled Layers", "author": "Tater", "description": "I'm really enjoying using ray intersection to remove repetition artifacts, it opens up so many possibilities. \n\nIt also looks cool if you reverse time", "tags": ["3d", "raymarching", "sdf", "spiral", "roll", "rolling"], "likes": 261, "viewed": 10599, "published": 3, "date": "1634144285", "time_retrieved": "2024-07-30T18:56:08.200027", "image_code": "#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define STEPS 200\n#define MDIST 100.0\n\n//some neat animation\n//#define FUN_MODE\n\n//Reverse time\n//#define iTime -iTime\n\n//Change to 2.0 for AA\n#define AA 1.0\n\nvec3 rdg = vec3(0);\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\nfloat h11(float a) {\n    a+=0.65343;\n    return fract(fract(a*a*12.9898)*43758.5453123);\n}\nfloat diplane(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    return rc.z+0.01;\n}\nfloat lim(float p, float s, float lima, float limb){\n    return p-s*clamp(round(p/s),lima,limb);\n}\nfloat idlim(float p, float s, float lima, float limb){\n    return clamp(round(p/s),lima,limb);\n}\nfloat lim2(float p, float s,  float limb){\n    return p-s*min(round(p/s),limb);\n}\nfloat idlim2(float p, float s, float limb){\n    return min(round(p/s),limb);\n}\nfloat spiral(vec2 p, float t, float m, float scale, float size, float expand){\n    size-=expand-0.01;\n    //Offset Spiral To the left\n    t = max(t,0.);\n    \n    p.x+=pi*-t*(m+m*(-t-1.));\n    t-=0.25;\n    \n    vec2 po = p;\n    //Move Spiral Up\n    p.y+=-t*m-m*0.5;\n    \n    //Counter the rotation\n    p*=rot(t*pi*2.+pi/2.);\n    \n    //Polar Map\n    float theta = atan(p.y,p.x);\n    theta = clamp(theta,-pi,pi);\n    p = vec2(theta,length(p));\n    \n    //Create Spiral\n    p.y+=theta*scale*0.5;\n\n    //Duplicate Line outwards to fill spiral\n    float py = p.y;\n    float id = floor((p.y+m*0.5)/m);\n    p.y = lim(p.y,m,0.,floor(t));\n        \n    //Line SDF of the spiral\n    float a = abs(p.y)-size;\n    \n    //Calcuate moving outer spiral segment\n    p.y = py;\n    p.x -= pi;\n    p.y -= (floor(t)+1.5)*m-m*0.5;\n    float b = max(abs(p.y),abs(p.x)-(pi*2.)*fract(t)+size );\n    \n    //The unrolled Line SDF\n    a = min(a,b-size);\n    b = abs(po.y)-size;\n    b = max(po.x*30.,b);\n    \n    //Combine Them\n    a = min(a,b);\n\n    return a;\n}\nvec3 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(1);\n    float c = 0.;\n    float t = iTime; \n\n    float size = 0.062; //Thickness of spiral curls\n    float scale = size-0.01; //Space between spiral curls\n    \n    float expand = 0.04; //Corner Rounding Amount \n\n    float m2 = size*6.0; //Repetition Sizes\n    float m = pi*scale; //Repetition Sizes\n    \n    float ltime = 10.0; //How often the spirals rolls repeat\n    \n    p.y-=(t/ltime)*size*6.; //Move everything upwards so it stays in frame\n    \n    p.x-=3.;  //small offset for framing\n    \n    float width = 0.5; //Lane Width\n    float count = 6.0; //Number of spirals (x2)\n    \n    float modwidth = width*2.0+0.04+0.06;\n    \n    float id3 = idlim(p.z,modwidth,-count,count);\n    t+=h11(id3*0.76)*8.0; //it took like 15 minutes to find this seed\n    p.z = lim(p.z,modwidth,-count,count);\n    \n    #ifdef FUN_MODE\n        scale+=(sin(t)*0.5+0.5)*0.05;\n        m = pi*scale;\n    #endif\n    \n    float to = t;\n    vec3 po = p;\n\n    //Spiral 1\n    float stack = -floor(t/ltime);\n    float id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    a.x = spiral(p.xy,t,m,scale,size,expand);\n    c = a.x;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 2\n    p = po;\n    t = to;\n    p.y+=size*2.0;\n    t-=ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);\n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal\n    \n    //Spiral 3\n    p = po;\n    t = to;\n    p.y+=size*4.0;\n    t-=2.*ltime/3.0;\n    stack = -floor(t/ltime);\n    id2 = idlim2(p.y,m2,stack);    \n    t+=id2*ltime;\n    p.y = lim2(p.y,m2,stack);\n    b.x = spiral(p.xy,t,m,scale,size,expand);\n    c = min(c,b.x);\n    a=(a.x<b.x)?a:b;\n    \n    a.x = min(a.x,max(p.y+size*5.,p.x)); //Artifact Removal\n    \n    a.x = ext(po.yzx,a.x,width-expand*0.5+0.02)-expand;\n    //SDF without intersection boundries for AO\n    c = ext(po.yzx,c,width-expand*0.5+0.02)-expand; \n    \n    //Intersection distance to plane between each lane\n    b.x = diplane(po ,vec3(modwidth)*0.5, rdg); //Artifact Removal\n    b.y = 0.;\n\n    a=(a.x<b.x)?a:b; //Artifact Removal\n    \n    return vec3(a,c);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(5,1.8,-12)*1.2;\n    ro.zx*=rot(0.09);\n    \n    //Mouse control\n    if(iMouse.z>0.5){\n    ro.yz*=rot(0.5*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-0.5*(iMouse.x/iResolution.x-0.5));\n    }\n    //Camera Setup\n    vec3 lk = vec3(-2.5,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*2.0+uv.x*r+uv.y*cross(f,r));  \n    rdg = rd;\n\n    vec3 p = ro;\n    vec3 d;\n    float dO = 0.;\n    bool hit = false;\n    \n    //Raymarcher\n    for(int i = 0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.001||i==STEPS-1){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST;\n            break;\n        }\n    }\n    //Color Surface\n    if(hit&&d.y!=0.){\n        vec3 ld = normalize(vec3(0.5,0.4,0.9));\n        vec3 n = norm(p);\n        rdg = ld;\n        float shadow = 1.;\n        float h = 0.09;\n        for(int i = 0; i < 64; i++){\n            vec3 dd = map(p+ld*h+n*0.005);\n            if(dd.x<0.001&&dd.y==0.0){break;}\n            if(dd.x<0.001){shadow = 0.0; break;}\n            shadow = min(shadow,dd.z*30.0);\n            if(h>7.0) {break;}\n            h+=dd.x;\n        }\n        shadow = max(shadow,0.8);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.05,n,p)*AO(.1,n,p);\n        ao = max(ao,0.1);\n        n.xz*=rot(4.*pi/3.);\n        col = n*0.5+0.5;\n        col = col*shadow;\n        col*=ao;\n    }\n    //Color Background\n    else{\n        col = mix(vec3(0.355,0.129,0.894),vec3(0.278,0.953,1.000),clamp((rd.y+0.05)*2.0,-0.15,1.5));\n    }\n    //Gamma Approximation\n    col = sqrt(col);\n    fragColor = vec4(col,0.0);  \n}\n\n//External AA (check render function for usual code)\n#define ZERO min(0.0,iTime)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float px = 1.0/AA; vec4 col = vec4(0);\n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 290, 290, 372], [373, 373, 393, 393, 463], [464, 464, 501, 501, 581], [582, 582, 634, 634, 680], [681, 681, 735, 735, 777], [778, 778, 820, 820, 859], [860, 860, 903, 903, 938], [939, 939, 1017, 1017, 1972], [1973, 1973, 1990, 1990, 4283], [4284, 4284, 4302, 4302, 4429], [4430, 4430, 4481, 4481, 6281], [6364, 6364, 6418, 6418, 6818]], "test": "untested"}
{"id": "NscSWs", "name": "BRM Cellular Tiling Based Clouds", "author": "intrakits", "description": "This is my attempt at raymarching some clouds using cellular tiling rather than 3d noise. I added fractional brownian motion to make the clouds more fluffy.", "tags": ["clouds", "brownian", "motion", "cellular", "tiling", "density", "fractional"], "likes": 3, "viewed": 379, "published": 3, "date": "1634138845", "time_retrieved": "2024-07-30T18:56:08.988918", "image_code": "//3d cellular tiling reference: https://www.shadertoy.com/view/ld3Szs\n//cloud reference:              https://www.shadertoy.com/view/4sXGRM\n\n#define _StepSize 120.\n#define _VolDepth 80000.0\n#define _CloudScale 7.\n#define _CloudOffset 0.\n#define _DensityThreshold .1\n#define _DensityMultiplier .00005\n\n\n#define _DarknessThreshold .3\n#define _LightAbsorbtion 100.\n#define _LightAbsorbtionTowardsSun 100.\n#define  _NumStepsLight 6\n#define _PhaseVal 100.\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\nvec2 cloudHeight = vec2(-2000,2000);\n\nvec3 lightDir = normalize(vec3(0.1,.1,.5));\n\n\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.166));\n    \n}\n\nfloat cellTile(in vec3 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n\n    c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.);\n    \n}\n\n\nvec3 camera(float time)\n{\n    return vec3(0,5000.*sin(iTime), time*2000.);\n}\nfloat getDensity(vec3 pos){\n    float n1 = smoothstep(.7,.1,cellTile(pos*.00005));\n    float n2 = smoothstep(0.,.5,cellTile(pos*.0001));\n   // float n3 = smoothstep(0.,.4,cellTile(pos*.00001));\n   // float n4 = smoothstep(0.,.4,cellTile(pos*.0002));\n    float alpha = smoothstep(0.5, 1.0,n1*n2);\n    \n    alpha = max(0.,alpha-_DensityThreshold)*_DensityMultiplier;\n    return alpha;\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n   // p*=.00025;\n    float f = 0.5000 * getDensity(p);\n    p = m * p;\n    f += 0.2500 * getDensity(p);\n    p = m * p;\n    f += 0.1666 * getDensity(p);\n    p = m * p;\n    f += 0.0834 * getDensity(p);\n    \n    return f;\n}\n\nfloat lightmarch(vec3 pos){\n    vec3 dirToLight = lightDir;\n    float totalDensity = 0.;\n    for(float i = 0.; i < _VolDepth; i += _StepSize*200.){\n\n        pos += dirToLight *_StepSize;\n       \n        float alpha = fbm(pos);//getDensity(pos);\n        \n        totalDensity += max(0.,alpha*_StepSize);\n    }\n    float transmittance = exp(-totalDensity * _LightAbsorbtionTowardsSun);\n    return _DarknessThreshold + transmittance * (1.-_DarknessThreshold);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + .1);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    vec3 lightE = vec3(0.);\n    float transmittance = 1.;\n    for (float depth = 0.0; depth < _VolDepth; depth += _StepSize)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudHeight.x < ray.y && ray.y < cloudHeight.y)\n        {\n            \n            float alpha =fbm(ray);//getDensity(pos);\n            \n            alpha = (1.0 - sum.a) * alpha;\n            if(alpha >0.){\n                float lightTransmittance = lightmarch(ray);\n                lightE+=alpha*_StepSize*transmittance*lightTransmittance*_PhaseVal;\n                transmittance*= exp(-alpha*_StepSize*_LightAbsorbtion);\n                if(transmittance < 0.01){\n                  break;\n                }\n            }\n            sum += vec4(vec3(1) * alpha, alpha);\n        }\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb= lightE;\n    float sundot = clamp(dot(fragAt, lightDir), 0.0, 1.0);\n    vec3 col = 0.8 * (vec3(0,0,1));\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    col = mix(col, sum.rgb, 1.-transmittance);\n\n    //col=vec3(smoothstep(.0,.7,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.5,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.4,cellTile(vec3(uv.x*2.,uv.y*2.,0.))));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[610, 610, 638, 638, 759], [761, 761, 787, 787, 1323], [1326, 1326, 1351, 1351, 1402], [1403, 1403, 1430, 1430, 1787], [1789, 1819, 1838, 1855, 2058], [2060, 2060, 2087, 2087, 2518], [2519, 2519, 2576, 2576, 4383]], "test": "untested"}
{"id": "fs3SDl", "name": "Urechis unicinctus", "author": "klk", "description": "2D render of tentacled underwater creature, inspired by Urechis unicinctus (penis fish)", "tags": ["tentacles", "creature"], "likes": 34, "viewed": 666, "published": 3, "date": "1634133178", "time_retrieved": "2024-07-30T18:56:09.768833", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord-iResolution.xy/2.)/iResolution.yy)*10.;\n    vec3 col=vec3(0);\n    col=vec3(.1,.4+.05*uv.y,.5+.1*uv.y);\n    float t=iTime*3.;\n    vec2 ps[7];\n    for(int k=0;k<6;k++)\n    {\n        ps[k]=vec2(0);\n    }\n    \n    for(float f=0.;f<1.;f+=0.005)\n    {\n        for(int k=0;k<6;k++)\n        {\n            vec2 p=ps[k];\n            float j=float(k);\n            float r=sin(f*48.+sin(t+j*3.1));\n            r*=r;\n            float w=clamp((1.-length(uv-p*.03)*4.-f*.6-r*r*.1)*5.,0.,1.);\n            vec3 c=vec3(.6,.4,.2);\n            col=mix(col, (-r+2.)*c*(uv.y-p.y*.03+.05)*2.5*(1.+f)+vec3(.5,.3,.3), w);\n            float af=t*.1+j+sin(f*12.*(11.7+j*1.71)*.05-t*(26.3+j*1.87)*.02+j*3.1+117.)*f*5.;\n            ps[k]+=vec2(sin(af), cos(af))*1.7;\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 871]], "test": "untested"}
{"id": "Ns3XWl", "name": "Imperfect donut shader", "author": "portaloffreedom", "description": "Imperfect 2D donut shader", "tags": ["2d", "circle"], "likes": 1, "viewed": 193, "published": 3, "date": "1634132230", "time_retrieved": "2024-07-30T18:56:10.550742", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy *2.0 -1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec2 pixelSize = vec2(1.0/iResolution.x, 1.0/iResolution.y);\n    \n    float fade = pixelSize.x*5.0;\n    float thickness = iMouse.x / iResolution.x - fade;\n    \n    float distance = 1.0 - dot(uv,uv);\n    vec3 col = vec3(smoothstep(0.0, fade, distance));\n    col *= vec3(1.0 - smoothstep(thickness, thickness+fade, distance));\n    \n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 588]], "test": "untested"}
{"id": "sddSWf", "name": "#inktober2021 \"sour,stuck,roof\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\nLate, so 3 in 1 : Fab11,12,13   :-p\n( apparently \"sour\" also means \"spinning\" ).\nMouse controls camera", "tags": ["raymarching", "swirl", "water", "flood", "house", "short", "stuck", "roof", "inktober2021", "sour"], "likes": 15, "viewed": 334, "published": 3, "date": "1634117317", "time_retrieved": "2024-07-30T18:56:11.419420", "image_code": "\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                          // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,l, r, h;                                               // hit object id \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),                     // ray direction\n          p = 9./R, q, c, a,                                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(.3*iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                                       // rotations\n        q.xz *= rot(2.-6.*M.x), a = abs(q),\n        t = max(a.y, max(a.x,a.z)) - 1.,                              // house body\n        t = max( t, -( max(a.y+.5, max(a.x,a.z)) - .95) ),            // hollow\n        t = max( t, - ( max(a.z-2., max(a.x,a.y)-.3) ) ),             // door\n        t = max( t, - ( max(a.x-2., max(abs(a.z-.4)-.25,abs(q.y-.15)-.2)) ) ), // windows\n        t = max(t, r = -(-.7*abs(q.x)-1.4*q.y+2.3 - 1.) ),            // roof\n        t = min(t, max( max(abs(q.y-.8)-.3, max(a.x,abs(q.z+.8))-.1 ),// chimney\n                      - max(    a.y-2.,     max(a.x,abs(q.z+.8))-.08) )),\n        t = min(t, l = q.y),                                          // water\n        q -= vec3(.8,.55,.8),\n        h = length((q-vec3(-.08,.14,0))/vec3(1,2,1))-.05,             // character\n        h = min(h, length(q-vec3(-.08,.29,0))-.03 ),                  //    body, head\n        h = min(h,  length(vec3(-.7*q.x-1.4*q.y,.15*(1.4*q.x-.7*q.y),abs(abs(q.z)-.04)))-.02 ), // legs\n        c = q - vec3(-.08,.22,0),  c.z = abs(c.z), c.yz *= rot(.6),   //    arms\n        q += vec3(.8,.55,.8),\n        h = min(h, length(vec3(c.xy, .15*c.z)) -.02 ),\n        t = min(t, h),\n        \n        p += .5*t*D;                                                  // step forward = dist to obj\n        \n    // color scheme & textures\n      t==l ? O *= vec4(0,.5,1,1) * (.3+.7*(1.-texture(iChannel0,q.xz*rot(length(q.xz)-iTime)).r)) // water\n    : t==r ? O *= vec4(1,.4,0,1) * (.5+.5*abs(sin(35.*q.z)))          // root\n    : t==h ? O-=O\n    :        O *= .3+.7*texture(iChannel1, 1.5*(a.x<a.z?q.xy:q.zy));  // walls\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 2317]], "test": "untested"}
{"id": "sddXWf", "name": "Perlin Coaster Ride", "author": "42yeah", "description": "Free entry. Have fun!", "tags": ["procedural", "perlin", "headacheinducing"], "likes": 7, "viewed": 265, "published": 3, "date": "1634117286", "time_retrieved": "2024-07-30T18:56:12.405782", "image_code": "#define FAR 200.0\n#define EPSILON 1e-3\n#define ID(func, nid) dist = func(pos); if (dist < closest) { closest = dist; id = nid; }\n\nvec2 rand2d(vec2 uv) {\n    return fract(sin(vec2(dot(uv, vec2(12.34, 45.67)),\n        dot(uv, vec2(78.9, 3.14)))) * 12345.67) * 2.0 - 1.0;\n}\n\nfloat perlin(vec2 uv) {\n    vec2 u = floor(uv);\n    vec2 f = fract(uv);\n    vec2 s = smoothstep(0.0, 1.0, f);\n    \n    vec2 a = rand2d(u);\n    vec2 b = rand2d(u + vec2(1.0, 0.0));\n    vec2 c = rand2d(u + vec2(0.0, 1.0));\n    vec2 d = rand2d(u + vec2(1.0, 1.0));\n    \n    return mix(mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n        mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x), s.y);\n}\n\nfloat sol(vec3 pos) {\n    vec2 uv = pos.xz;\n    return pos.y - perlin(uv);\n}\n\nfloat ball(vec3 pos) {\n    return length(pos) - 0.5;\n}\n\nvec2 map(vec3 pos) {\n    float closest = 1000.0;\n    float id = -1.0;\n    float dist = 0.0;\n\n    ID(sol, 0.5);\n\n    return vec2(closest, id);\n}\n\nvec3 objectColor(vec3 pos, float id) {\n    if (id > 0.0 && id < 1.0) {\n        vec2 u = mod(floor(pos.xz), 2.0);\n        vec3 color = max(vec3(abs(u.x - u.y)), 0.8);\n        \n        return color;\n    }\n    if (id > 1.0 && id < 2.0) {\n        return vec3(0.5, 1.0, 0.0);\n    }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 800; i++) {\n        vec2 info = map(ro + depth * rd);\n        if (info.x < EPSILON) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n        if (depth > FAR) {\n            break;\n        }\n    }\n    return vec2(depth, id);\n}\n\nvec3 getNormal(vec3 pos) {\n    float mapped = map(pos).x;\n    \n    return normalize(vec3(\n        mapped - map(pos - vec3(EPSILON, 0.0, 0.0)).x,\n        mapped - map(pos - vec3(0.0, EPSILON, 0.0)).x,\n        mapped - map(pos - vec3(0.0, 0.0, EPSILON)).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec3 ro = vec3(0.0, perlin(vec2(0.0, iTime)) + 0.2, iTime);\n    vec3 center = ro + vec3(0.0, perlin(vec2(0.0, ro.z + 1.0)), 1.0);\n    vec3 worldUp = getNormal(vec3(ro.x, ro.y - 0.2, ro.z));\n//    vec3 center = vec3(0.0, 0.1, 0.0);\n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, worldUp));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0));\n    vec3 rd = vec3(lookAt * normalize(vec4(uv, 1.0, 1.0)));\n    \n    vec2 info = trace(ro, rd);\n    \n    vec3 sky = mix(vec3(0.78, 0.9, 1.0), vec3(1.0), 1.0 - uv.y);\n    \n    if (info.y > 0.0) {\n        vec3 pos = ro + info.x * rd;\n        vec3 color = objectColor(pos, info.y);\n        \n        // Lighting calculations\n        vec3 norm = getNormal(pos);\n        \n        // World lights\n        vec3 ambient = 0.1 * vec3(1.0);\n        vec3 skyColor = clamp(dot(norm, vec3(0.0, 1.0, 0.0)), 0.0, 1.0) * vec3(1.0);\n        // Light 1\n         \n        fragColor = vec4(\n            (ambient + skyColor) * color, \n            1.0);\n        \n        // Falloff begins at depth > 5 and goes all the way to 10.0\n        float falloff = min(max(info.x - 5.0, 0.0) / 5.0, 1.0);\n        fragColor = mix(fragColor, vec4(sky, 1.0), falloff);\n    } else {\n        fragColor = vec4(sky, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 152, 152, 270], [272, 272, 295, 295, 684], [686, 686, 707, 707, 762], [764, 764, 786, 786, 818], [820, 820, 840, 840, 963], [965, 965, 1003, 1003, 1275], [1277, 1277, 1307, 1307, 1632], [1634, 1634, 1660, 1660, 1892], [1894, 1894, 1949, 1949, 3480]], "test": "untested"}
{"id": "7dtXWf", "name": "Physically based tiny disc light", "author": "hyperknot", "description": "Physically based lightness calculation \nfor a \"tiny disc\" light perpendicular to a\nmatte (Lambertian) ground plane, moving up and down.\ndetails: https://hyperknot.com/blog/area_lights_in_shaders/", "tags": ["light", "physics", "arealight"], "likes": 4, "viewed": 519, "published": 3, "date": "1634114935", "time_retrieved": "2024-07-30T18:56:13.541745", "image_code": "// Physically based lightness calculation \n// for a \"tiny disc\" light perpendicular to a\n// matte (Lambertian) ground plane, moving up and down.\n// details: https://hyperknot.com/blog/area_lights_in_shaders/\n\nfloat disc_light(vec2 uv, float h, float i) {\n  // h - light's height over the ground\n  // i - light's intensity\n  if (uv.x > 0.) return 0.;\n  return i * h * -uv.x * pow(dot(uv,uv) + h*h, -2.);\n}\n\nfloat lin_to_srgb ( float val ) {\n  if( val < 0.0031308 )\n    return val * 12.92;\n  else\n    return 1.055 * pow(val,1.0/2.4) - 0.055;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    float h = pow(sin(iTime/3.), 2.) * 0.1 + 0.001;\n    float v = disc_light(uv, h, 0.0327);\n    v = lin_to_srgb(v);\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 254, 321, 404], [406, 406, 439, 439, 541], [543, 543, 599, 599, 807]], "test": "untested"}
{"id": "7stSWf", "name": "Falling Random Numbers", "author": "dr2", "description": "Use at your peril", "tags": ["repetition", "pseudorandom"], "likes": 15, "viewed": 357, "published": 3, "date": "1634112614", "time_retrieved": "2024-07-30T18:56:14.417404", "image_code": "// \"Falling Random Numbers\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Use at your peril\n\n// (Based on \"Panspermia Incoming\")\n\n#define AA  1  // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 qrHit, bGrid, cId, sunDir, obDisp, obRot;\nfloat dstFar, tCur, vSpd, rNum;\nbool cOcc;\nconst float pi = 3.1415927;\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.yz = Rot2D (p.yz, obRot.x);\n    p.xz = Rot2D (p.xz, obRot.y);\n    p.xy = Rot2D (p.xy, obRot.z);\n    d = PrRoundBoxDf (p, vec3 (0.5, 0.01, 0.3), 0.02);\n    qrHit = p;\n  }\n  return d;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  vRan = Hashv3f (dot (cId, vec3 (31.1, 41.1, 51.1)) + 99.);\n  cOcc = (vRan.x * step (2., length (cId.xz)) > 0.5);\n  if (cOcc) {\n    obDisp = bGrid * (cId + 0.5) + (0.2 + 0.1 * bGrid.x * vRan.x) *\n       vec3 (sin (0.6 * vRan.z * tCur + vRan.x) * vec2 (0.5 * pi, 0.), 0.).xzy;\n    obRot = (vRan - 0.5) * 0.5 * tCur;\n    rNum = Hashfv3 (vec3 (31.1, 41.1, 51.1) * cId + 99.);\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += vSpd * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((bGrid * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.4, 0.5, 0.7), vec3 (0.3, 0.45, 0.55), smoothstep (-0.02, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  } else {\n    col = vec3 (0.1, 0.5, 0.1);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, p;\n  float dstObj;\n  bGrid = vec3 (4.);\n  vSpd = 0.2;\n  bgCol = BgCol (ro, rd);\n  col = bgCol;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    p = ObjCell (ro);\n    ObjState ();\n    vn = ObjNf (p);\n    col = mix (vec3 (1., 1., 0.8), vec3 (0., 0., 1.), ShowIntPZ (vec2 (qrHit.x * sign (qrHit.y),\n       qrHit.z) - vec2 (0.3, -0.18), vec2 (0.6, 0.4), 5., 1. + floor ((1e5 - 1.) * rNum)));\n    col = mix (vec3 (0., 0., 1.), col, smoothstep (0., 0.02, PrRoundBox2Df (qrHit.xz -\n       vec2 (0., -0.25), vec2 (0.4, 0.005), 0.005)));\n    col *= 0.4 + 0.6 * max (dot (vn, sunDir), 0.);\n    col = mix (col, bgCol, smoothstep (0.5, 0.95, dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.085 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.085 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.5);\n  zmFac = 3.5;\n  dstFar = 40.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[824, 824, 846, 846, 1092], [1094, 1094, 1112, 1112, 1505], [1507, 1507, 1530, 1530, 1661], [1663, 1663, 1696, 1696, 2254], [2256, 2256, 2277, 2277, 2532], [2534, 2534, 2565, 2565, 3352], [3354, 3354, 3389, 3389, 4128], [4130, 4130, 4186, 4186, 5169], [5171, 5171, 5217, 5217, 5264], [5266, 5266, 5313, 5313, 5360], [5362, 5362, 5384, 5384, 5422], [5424, 5424, 5446, 5446, 5473], [5475, 5475, 5497, 5497, 5524], [5526, 5526, 5562, 5562, 5768], [5770, 5770, 5800, 5800, 5913], [5915, 5915, 5938, 5938, 6042], [6115, 6115, 6147, 6147, 6695], [6697, 6697, 6759, 6759, 7126], [7160, 7160, 7184, 7184, 7244], [7246, 7246, 7270, 7270, 7335], [7337, 7337, 7361, 7361, 7414], [7416, 7416, 7440, 7440, 7552], [7554, 7554, 7578, 7578, 7638], [7640, 7640, 7665, 7665, 7811], [7813, 7813, 7838, 7838, 8024], [8026, 8026, 8048, 8048, 8202], [8204, 8204, 8225, 8225, 8380]], "test": "untested"}
{"id": "fstSRX", "name": "Glowing balls", "author": "z0rg", "description": "Inspired by https://www.shadertoy.com/view/ss3SD8 for the DOF\nThanks for Ronja for https://www.ronja-tutorials.com/post/023-postprocessing-blur/ testing the two pass blur for the first time (might do the gaussian version on another shader)\n", "tags": ["dof", "balls", "glow"], "likes": 7, "viewed": 328, "published": 3, "date": "1634111351", "time_retrieved": "2024-07-30T18:56:15.317996", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_RAD;\n        col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_MULT*pow(col, vec3(GLOW_POW));\n\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a,vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    for (int i = 0; i < 16; ++i)\n    {\n        float fi = float(i);\n        vec3 q = p-vec3(sin(fi*15.+iTime*.5)*7.-.5*fi, cos(fi+iTime)*4., fi*15.);\n        q.z += (sin(iTime)*.5+.5)*35.;\n        acc = _min(acc, vec2(length(q)-3.+sin(float(i)+iTime*3.), i));\n    }\n\n    \n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.,0.,0.);\n    float dist = 5.;\n    vec3 ro = vec3(sin(iTime)*.5,0.,-5.);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    \n    vec2 off = 0.04*vec2(rand()-.5, rand()-.5);\n    ro.xy += off*5.;\n    rd.xy -= off*.1;\n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 refl = reflect(rd, n);\n        col = texture(iChannel1, refl*vec3(1.,-1.,1.)).xyz;\n        vec2 uvt = p.xy;\n        uvt *= r2d(iTime*sin(res.z));\n        float bands = mix((sin(uvt.y*3.)-.8), (sin(uvt.x*3.)-.8), mod(res.z,2.));\n        col = mix(col, 2.*vec3(sin(res.z*15.-iTime*5.)*.5+.5, .5+.3*sin(res.z),.5), sat(bands*400.));\n    }\n    else\n        col = texture(iChannel1, rd*vec3(1.,-1.,1.)).xyz;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    \n    vec3 col = rdr(uv);\n    vec3 prev = texture(iChannel2, fragCoord/iResolution.xy).xyz;\n    col = mix(col, prev, 1.-sat(0.5+length(prev)));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_RAD;\n        col += texture(iChannel0, uv+vec2(f*factor, 0.)).xyz/float(steps);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 40\n#define GLOW_POW 2.\n#define GLOW_MULT 1.1\n#define GLOW_RAD 0.03\n\n#define sat(a) clamp(a, 0., 1.)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// The bookofshaders\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSRX.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 886]], "test": "untested"}
{"id": "NstSWf", "name": "Common Color Effects", "author": "chenglou", "description": "15 common color effects. See code for the effects names.\n\n[b]Click & drag horizontally[/b] to manually adjust the percentage value used for some effect, from 0 to 1.\n\nMore info: [url]http://redqueengraphics.com/category/color-adjustments[/url]", "tags": ["color", "contrast", "saturation", "blend", "gamma", "brightness", "inversion", "exposure", "vibrance", "luminence"], "likes": 18, "viewed": 1948, "published": 3, "date": "1634106335", "time_retrieved": "2024-07-30T18:56:16.324306", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Divide the canvas into grids\n    vec2 gridCount = vec2(5., 3.);\n    vec2 uv = fragCoord / iResolution.xy * gridCount; // x: [0, 5[ and y: [0, 3[\n    vec2 gridID = floor(uv); // same as uv but integers\n    // Map the 2D grid ID from (0, 0) -> 1 to (4, 2) -> 15\n    int mappedID = int((gridCount.y - gridID.y - 1.) * gridCount.x + gridID.x) + 1;\n    \n    // Base and overlay texture for blending. Sometime we only use base (t1)\n    vec4 t1 = texture(iChannel0, uv);\n    vec4 t2 = texture(iChannel1, uv);\n    // Shadertoy's (non-noise) textures are in sRGB. Turn them into linear space for manipulation. Turn them back at the end\n    t1 = pow(t1, vec4(2.2));\n    t2 = pow(t2, vec4(2.2));\n    \n    // Used by certain effects. from 0 to 1\n    float percentSlider = sin(iTime) / 2. + .5;\n    // Click & drag horizontally to manually adjust the percentage\n    if (iMouse.z > 0.) percentSlider = iMouse.x / iResolution.x;\n    \n    // === Ok, start!\n    vec4 color;\n    switch (mappedID) {\n        case 1: // blend: dissolve\n            color = mix(t1, t2, percentSlider);\n            break;\n        case 2: // blend: lighten\n            color = max(t1, t2);\n            break;\n        case 3: // blend: darken\n            color = min(t1, t2);\n            break;\n        case 4: // blend: subtract\n            color = t1 - t2;\n            break;\n        case 5: // blend: multiply. Would require more calculations for non-1 alpha\n            color = t2 * t1;\n            break;\n        case 6: // blend: add. Would require more calculations for non-1 alpha\n            color = t1 + t2;\n            break;\n        case 7: // blend: divide. Would require more calculations for non-1 alpha\n            color = t1 / t2;\n            break;\n        case 8: // luminence\n            vec3 weights = vec3(0.2125, 0.7154, 0.0721); // sums to 1\n            float luminance = dot(t1.rgb, weights);\n            color = vec4(vec3(luminance), 1.);\n            break;\n        case 9: // brightness\n            color = t1 + percentSlider;\n            break;\n        case 10: // contrast\n            color = (t1 - .5) * percentSlider * 2. + .5; // 0 to 2 contrast\n            break;\n        case 11: // exposure\n            color = t1 * pow(2., percentSlider);\n            break;\n        case 12: // gamma\n            color = pow(t1, vec4(percentSlider) * 2.2); // 0 to 2.2, by convention\n            break;\n        case 13: // saturation\n            vec3 weights_ = vec3(0.2125, 0.7154, 0.0721); // sums to 1\n            float luminance_ = dot(t1.rgb, weights_);\n            color = mix(vec4(luminance_), t1, vec4(percentSlider) * 5.);\n            break;\n        case 14: // vibrance\n            float average = (t1.r + t1.g + t1.b) / 3.;\n            float mx = max(t1.r, max(t1.g, t1.b));\n            float amount = (mx - average) * percentSlider * 3. * 5.;\n            color = t1 - (mx - t1) * amount;\n            break;\n        case 15: // inversion\n            color = 1. - t1;\n            break;\n    }\n\n    fragColor = pow(color, vec4(1./2.2)); // gamma correct back\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 93, 3112]], "test": "untested"}
{"id": "NstXWf", "name": "Segment Simplex Grid #3", "author": "Yusef28", "description": "Kind of like a 2016 Shane shader or some sort of knock-off.", "tags": ["simplex"], "likes": 14, "viewed": 370, "published": 3, "date": "1634099498", "time_retrieved": "2024-07-30T18:56:17.485202", "image_code": "/*\n\nCode (or the logic) is a mess, \nhopefully only for now.\n\nfeatures of this shader:\n\n- Shane's Lighting\n\n- A slight tweak to the geometry on one of the 3\ninner triangles in each regular triangle based on\nbarycentric coordinates\n\n- pushing the geometry of the regular triangles out\nfrom the center based on the barycentric coordinates\n\n- tri planar texturing\n\n- accentuating the edges of the barycentric \ninner triangles based on some hacky logic.\n\n\n\n*/\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    //some sort of adhoch antialiasing based on\n    //an anisotrpic effect by:ulianlumia\n    //unstable universe - https://www.shadertoy.com/view/wtlfz8\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(0.);\n    float f = length(uv  - 0.6);\n    \n    fragColor.xyz += T(uv + f*0.002).xyz;\n    fragColor.xyz += T(uv -f*0.002).xyz;\n    fragColor.xyz += T(uv-f*0.003).xyz;\n    fragColor.xyz /= 3.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi acos(-1.)", "buffer_a_code": "#define FAR 30.\n\n/*\n\nCode (or the logic) is a mess, \nhopefully only for now.\n\nfeatures of this shader:\n\n- Shane's Lighting\n\n- A slight tweak to the geometry on one of the 3\ninner triangles in each regular triangle based on\nbarycentric coordinates\n\n- pushing the geometry of the regular triangles out\nfrom the center based on the barycentric coordinates\n\n- tri planar texturing\n\n- accentuating the edges of the barycentric \ninner triangles based on some hacky logic.\n\n\n\n*/\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    p/=1.9;\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n \n    return f*1.3;\n}\n\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 snoise3( in float x )\n{\n#if 1    \n    return -1.0 + 2.0*textureLod( iChannel2, vec2(x,4.5)/256.0, 0.0 ).xyz;\n#else    \n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return -1.0 + 2.0*mix( hash3(p+0.0), hash3(p+1.0), f );\n#endif    \n}\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat seggy( vec3 P, vec3 A, vec3 B){\n    \n    //dist auf line segment zu punkt\n    //nahrest dist auf line zu punkt\n    //P = A + t*(B-A);\n    //dot((P-P3),(B-A)) = 0\n    //(A+t*(B-A)-P3)*(B-A)) = 0;\n    //A*(B-A)+t*(B-A)*(B-A)-P3*(B-A) = 0\n    //A*(B-A) - P3*(B-A) + t*(B-A)*(B-A)\n    //(A-P3)*(B-A) + t*(B-A)*(B-A)\n    //t = dot((A-P3),(B-A)) / dot((B-A),(B-A));\n    vec3 AP = P-A;\n    vec3 BA = B-A;\n    \n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n                    \n    vec3 P3 = A + t*BA;                \n    float dist = length(P - P3) - 0.02;\n    return dist;\n}\n\n\nvec2 planeVonTri(vec3 p, vec3 A, vec3 B, vec3 C){\n    \n    vec3 BA = A - B;\n    vec3 CA = A - C;\n    vec3 n  = normalize(cross(BA,CA));\n    //where is the intersection of line and plane?\n    //plane = dot(n,P) = 0\n    //line = ro + rd*t = P\n    float t = dot(n,p-A);\n    \n    //dist from point to line AB, BC, and CA\n    float dAB = length(cross(p-A, B-A));\n    float dBC = length(cross(p-B,C-B));\n    float dCA = length(cross(p-C, A-C));\n\n    //I'm pretty certain there is an easier way to do this\n    //I'l have to experiment with it later\n    float edgeLines = min(\n        abs(dAB - dBC)/(1.-float(dCA < min(dAB,dBC))),\n    min(abs(dBC - dCA)/(1.-float(dAB < min(dBC,dCA))),\n        abs(dCA - dAB)/(1.-float(dBC < min(dCA,dAB)))\n        ));\n\n                      \n    float bumpLines = min(dAB,min(dBC,dCA));\n    \n    float oppLines = max(dAB,max(dBC,dCA));\n    float distCenter = bumpLines;\n    float planeHeight = t - distCenter/2.;\n    if(distCenter == dAB) planeHeight += sin(distCenter*100.)/400. ;\n \n return vec2(planeHeight, edgeLines*2.);\n \n}\n\n\nmat2 rot(float a){\n    float cs = cos(a),si = sin(a);\n    return mat2(cs, si, -si, cs);\n}\n\n\nfloat objectID = 0.;\nfloat glow = 0.;\n\n//FROM DAVE HOSKINS\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//FROM DAVE HOSKINS\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 objColGlobal = vec3(0.);\n\nfloat map(vec3 p){\n\n    p*= 0.9;\n    p.xz *= mat2(1.1547, 0., 1.1547*0.5,1.);\n    float sphere_radius = 0.35;\n    vec3 sp = p;\n    float alle = 100.;\n\n    \n    sp.xz = fract(p.xz)-0.5;\n    vec2 id = floor(p.xz);\n    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);\n    float t = 0.;//iTime;\n    \n    float gross = 1.3;\n    \n    float height = fbm4(id+t)*gross;\n    float heightL = fbm4((id + vec2(0.,1.))+t)*gross;\n    float heightR = fbm4((id + vec2(0.,-1.))+t)*gross;\n    float heightV = fbm4((id + vec2(-1.,0.))+t)*gross;\n    float heightH = fbm4((id + vec2(1.,0.))+t)*gross;\n    \n    \n    float k = seggy(sp, vec3(0.,height,0.), vec3(-1.,heightV,0.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0., heightL,1.0));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0.,heightR,-1.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(1.0,heightH,0.0));\n    alle = smin(alle, k, 0.);\n    \n\n    \n    vec3 st = p;\n    \n    //HERE:\n    //I create a new shifted coord system so that I can get \n    //that pesky diagonal segment\n    st.xz = fract(p.xz-0.5)-0.5;\n    vec2 id2 = floor(p.xz-0.5);\n    \n    \n    //for floor here, actually:\n    //the mid point is the + 0.5,0.5\n    //the bottom is 0,0 because that is the floor value, id\n    //and the top would have to be + 1.,1.\n    \n    float heightDB = fbm4(id2 +t)*gross;\n    float heightDT = fbm4(id2 + vec2(1.) +t)*gross;\n    \n    /////\n    float heightTLT = fbm4(id2 + vec2(0.,1.) +t)*gross;\n    float heightBRB = fbm4(id2 + vec2(1.,0.) +t)*gross;\n    \n    //float heightMD = fbm4(id2 - vec2(0.5))*gross;\n    \n    //THE DIAGONAL\n    k = seggy(st, vec3(-0.5, heightDB, -0.5), \n                  vec3( 0.5, heightDT,  0.5) );\n                  \n    alle = smin(alle, k, 0.);\n    \n    //check which side of the diagonal of the square we are on\n    //and make a plane with the three coordinates of that triangle\n    \n    vec2 pl = st.x < st.z \n    \n                         ?\n                        \n               planeVonTri(st,\n                     vec3( 0.5, heightDT,  0.5),\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3(-0.5, heightTLT, 0.5) )\n                     \n                         : \n                        \n               planeVonTri(st,\n                     //you need to have this exact order for A,B and C!\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3( 0.5, heightDT,  0.5),\n                     \n                     vec3( 0.5, heightBRB, -0.5) );\n    \n    //calculate colors\n    float colID = hash12(floor(p.xz - 0.5)*80. + sign(st.x-st.z)*80.)+0.2;\n    objColGlobal = vec3(colID*0.1,colID*0.4,colID)/1.;\n    objColGlobal = mix(objColGlobal, \n                   vec3(0.3,0.6,1.)*1., \n                   smoothstep(0.03,0.02,pl.y)*5.);\n    \n    //kind of a Shane x Nusan hybrid ID check\n    if(pl.x < 0.005){\n       // glow += 0.0001/pow(pl,0.2);\n        objectID = 1.;   \n    }\n   if(objColGlobal.x > 1. && objectID == 1.) objectID = 2.;//glow += 0.005/pow(pl.x,2.)*0.003;\n    alle = min(alle, pl.x );\n\n   //\n   //alle = min(alle, length(st)-0.15);\n    return alle;// min(alle, sp.y+0.7-fbm4(p.xz));\n    \n}\n\n//FROM SHANE\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.85;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n//FROM SHANE\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 14; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n//FROM SHANE?\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nvec3 triPlanar(vec3 p, vec3 n){\n\n    n = max(abs(n), 0.001);\n    float sum = n.x+n.y+n.z;\n    n = n/sum;\n    \n    vec3 tex = texture(iChannel1,p.xy).rgb * n.z +\n               texture(iChannel1,p.yz).rgb * n.x + \n               texture(iChannel1,p.xz).rgb * n.y ;\n                    \n    return tex;\n}\n\n//FROM SHANE!\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = objectID == 1.? \n    objColGlobal*triPlanar(sp,sn).x :\n    vec3(.3,0.18,0.04)*0.7;\n    if(objectID == 2.) objCol = vec3(0.3,0.6,1.)*.9;\n    //objCol = objectID == 2. ? vec3(1.) : \n      //    objCol;//getObjectColor(sp);\n   // if(objectID == 2.) objCol = vec3(1.);\n    \n    float specFact = objectID == 1. ? 8. : 2.;\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff*8. ) + vec3(.8, .5, .2)*spec*specFact) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, pow(t/FAR,5.));\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n   // sceneCol = glow*0.2;\n    sceneCol = mix(sceneCol, vec3(0.), fogF); \n\n   // sceneCol = mix(sceneCol, sceneCol, clamp(.2-fogF,0.,1.)); \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.yz *= rot(-0.5);\n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 4. + sin(iTime)*0.1, -4.5 + iTime*2.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 2., 3.5);\n    \n    vec3 sceneColor;\n    float t = trace(ro, rd);\n    //sceneColor = mix(sceneColor, vec3(0.3,0.051,0.), clamp(pow(t/FAR, 20.),0.,1.));\n    if(t < FAR){\n    ro += rd*t;\n    vec3 sn = getNormal(ro);\n    sceneColor = doColor(ro, rd, sn, lp, t);\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n    sceneColor *= sh;\n\n    }\n    else{\n    \n    sceneColor = vec3(0.);\n    }\n   \n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0;\n    \n    vig = pow(vig, 0.15);\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor*vig, 0., 1.)), 1);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[493, 493, 550, 550, 1021]], "test": "untested"}
{"id": "fddXDf", "name": "Image Healing", "author": "oneshade", "description": "One attempt at fixing holes in an image.", "tags": ["image", "heal", "patching", "imagehealing"], "likes": 11, "viewed": 200, "published": 3, "date": "1634092776", "time_retrieved": "2024-07-30T18:56:18.251154", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\n// I modified it to try avoiding some annoying symmetry hash13() appears to have on the xy plane.\nfloat noise(in vec3 p) {\n\tp = fract(p * 0.731 - p.x * 253.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mask = smoothstep(0.45, 0.55, fnoise(vec3(uv, 0.5), 10.0, 10.0) - 0.1);\n    fragColor = texture(iChannel0, uv, mask * 3.0);\n    if (iFrame < 20 || iMouse.z > 0.0) fragColor = texture(iChannel1, uv) * step(mask, 0.5);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "fddXWf", "name": "Cellular Tiling Based Clouds", "author": "intrakits", "description": "This is my attempt at making clouds using 3d cellular tiling rather than 3d noise. Cellular tiling is much faster than a 3d noise function, but can look repetitive.\n\n", "tags": ["raymarch", "clouds", "cellular", "tiling", "density"], "likes": 3, "viewed": 234, "published": 3, "date": "1634089846", "time_retrieved": "2024-07-30T18:56:19.156733", "image_code": "//3d cellular tiling reference: https://www.shadertoy.com/view/ld3Szs\n//cloud reference:              https://www.shadertoy.com/view/4sXGRM\n\n#define _StepSize 30.\n#define _VolDepth 40000.0\n#define _CloudScale 7.\n#define _CloudOffset 0.\n#define _DensityThreshold .2\n#define _DensityMultiplier .00005\n\n\n#define _DarknessThreshold .3\n#define _LightAbsorbtion 100.\n#define _LightAbsorbtionTowardsSun 100.\n#define  _NumStepsLight 10\n#define _PhaseVal 100.\n\n\nvec2 cloudHeight = vec2(0.0,10000);\n\nvec3 lightDir = normalize(vec3(0.1,.5,.5));\n\n\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    p = abs(fract(p)-.5);\n    return dot(p, vec3(.166));\n    \n}\n\nfloat cellTile(in vec3 p){\n    \n    float c = .25; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n\n    c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.);\n    \n}\n\nvec3 camera(float time)\n{\n    return vec3(0,5000.*sin(iTime), time*2000.);\n}\nfloat getDensity(vec3 pos){\n    float n1 = smoothstep(.7,.1,cellTile(pos*.00005));\n    float n2 = smoothstep(0.,.5,cellTile(pos*.0001));\n    float n3 = smoothstep(0.,.4,cellTile(pos*.00001));\n    float n4 = smoothstep(0.,.4,cellTile(pos*.0002));\n    float alpha = smoothstep(0.5, 1.0,n1*n2*n3*n4);\n    alpha = max(0.,alpha-_DensityThreshold)*_DensityMultiplier;\n    return alpha;\n}\nfloat lightmarch(vec3 pos){\n    vec3 dirToLight = lightDir;\n    float totalDensity = 0.;\n    for(float i = 0.; i < _VolDepth; i += _StepSize*200.){\n\n        pos += dirToLight *_StepSize;\n       \n        float alpha = getDensity(pos);\n        \n        totalDensity += max(0.,alpha*_StepSize);\n    }\n    float transmittance = exp(-totalDensity * _LightAbsorbtionTowardsSun);\n    return _DarknessThreshold + transmittance * (1.-_DarknessThreshold);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + .1);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    vec3 lightE = vec3(0.);\n    float transmittance = 1.;\n    for (float depth = 0.0; depth < _VolDepth; depth += _StepSize)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudHeight.x < ray.y && ray.y < cloudHeight.y)\n        {\n            \n            float alpha = getDensity(ray);\n            \n            alpha = (1.0 - sum.a) * alpha;\n            if(alpha >0.){\n                float lightTransmittance = lightmarch(ray);\n                lightE+=alpha*_StepSize*transmittance*lightTransmittance*_PhaseVal;\n                transmittance*= exp(-alpha*_StepSize*_LightAbsorbtion);\n                if(transmittance < 0.01){\n                  break;\n                }\n            }\n            sum += vec4(vec3(1) * alpha, alpha);\n        }\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb= lightE;\n    float sundot = clamp(dot(fragAt, lightDir), 0.0, 1.0);\n    vec3 col = 0.8 * (vec3(0,0,1));\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    col = mix(col, sum.rgb, 1.-transmittance);\n\n    //col=vec3(smoothstep(.0,.7,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.5,cellTile(vec3(uv.x,uv.y,0.)))*smoothstep(1.,.4,cellTile(vec3(uv.x*2.,uv.y*2.,0.))));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[536, 536, 564, 564, 685], [687, 687, 713, 713, 1249], [1251, 1251, 1276, 1276, 1327], [1328, 1328, 1355, 1355, 1709], [1710, 1710, 1737, 1737, 2157], [2158, 2158, 2215, 2215, 4012]], "test": "untested"}
{"id": "fddSWf", "name": "Testing line segment tangents", "author": "liamegan", "description": "Testing how to determine tangents to a line segment.", "tags": ["raymarching", "line", "tangents"], "likes": 1, "viewed": 223, "published": 3, "date": "1634083730", "time_retrieved": "2024-07-30T18:56:20.420354", "image_code": " \n#define PI 3.14159265359\n#define TAU 3.14159265359*2.\n\nconst vec3 a = vec3(1.4, .9, 1.);\nconst vec3 b = vec3(-.3, -.3, .2);\n\nvec2 mouse;\n\n/* Raymarching constants */\n/* --------------------- */\nconst float MAX_TRACE_DISTANCE = 5.;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;       // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 64;               // max number of trace steps\nconst float STEP_MULTIPLIER = 1.;                 // the step mutliplier - ie, how much further to progress on each step\n\n  \n/* Structures */\n/* ---------- */\nstruct Camera {\n    vec3 ro;\n    vec3 rd;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    float FOV;\n};\nstruct Surface {\n    float len;\n    vec3 position;\n    vec3 colour;\n    float id;\n    float steps;\n    float AO;\n};\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n\nvec2 getScreenSpace(vec2 from) {\n    vec2 uv = (from - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    return uv;\n}\n\nmat3 makeRotationDir(vec3 direction) {\n    vec3 up = vec3(0,1,0);\n    vec3 xaxis = cross(up, direction);\n    normalize(xaxis);\n\n    vec3 yaxis = cross(direction, xaxis);\n    normalize(yaxis);\n    \n    return mat3(\n      xaxis.x,\n      yaxis.x,\n      direction.x,\n      \n      xaxis.y,\n      yaxis.y,\n      direction.y,\n      \n      xaxis.z,\n      yaxis.z,\n      direction.z\n    );\n}\n\n//--------------------------------\n// Modelling\n//--------------------------------\n// Line segment code curtesy of IQ\nfloat sdfLine(vec3 p, vec3 a, vec3 b) {\n    float h = min(1.,\n                 max(0., \n                    dot(p-a, b-a) /\n                    dot(b-a, b-a)));\n    return length(p-a-(b-a)*h);\n}\n// Ugly modelling code, but it gets the point across\nModel model(vec3 p) {\n    \n    vec3 colour = vec3(1,0,0);\n    float d = length(p-a) - .03;\n    d = min(d, length(p-b) - .03);\n    float oldd = d;\n    d = min(d, sdfLine(p, a, b) - .01);\n    if(d < oldd) colour = vec3(0,.6,.8);\n    \n    float ds = clamp(mouse.y+.5, 0., 1.);\n    vec3 diff = a-b;\n    vec3 norm = normalize(diff);\n    vec3 ps = b + diff * ds;\n    oldd = d;\n    d = min(d, length(p-ps) - .05);\n    if(d < oldd) colour = vec3(0,1.,.4);\n    \n    mat3 rot = makeRotationDir(norm);\n    \n    oldd = d;\n    const float n = 10.;\n    for(float i = 0.; i < n; i++) {\n      float a = TAU / n * i;\n      vec3 op = normalize(vec3(cos(a), sin(a),0)) * rot;\n      d = min(d, length(p-ps+op * .2) - .02);\n      if(d < oldd) colour = vec3(1,1.,0);\n    }\n    \n    return Model(d, colour, 1.);\n}\nModel map( vec3 p ){\n    return model(p);\n}\n\nSurface calcIntersection( in Camera cam ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float rayDepth = 0.0;\n    float hitDepth = -1.0;\n    float id = -1.;\n    float steps = 0.;\n    float ao = 0.;\n    vec3 position;\n    vec3 colour;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ) {\n      if( abs(h) < INTERSECTION_PRECISION || rayDepth > MAX_TRACE_DISTANCE ) break;\n      position = cam.ro+cam.rd*rayDepth;\n      Model m = map( position );\n      h = m.dist;\n      rayDepth += h * STEP_MULTIPLIER;\n      id = m.id;\n      steps += 1.;\n      ao += max(h, 0.);\n      colour = m.colour;\n    }\n\n    if( rayDepth < MAX_TRACE_DISTANCE ) hitDepth = rayDepth;\n    if( rayDepth >= MAX_TRACE_DISTANCE ) id = -1.0;\n\n    return Surface( hitDepth, position, colour, id, steps, ao );\n}\nCamera getCamera(in vec2 uv, in vec3 pos, in vec3 target) {\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = normalize(cross(forward, right));\n    \n    float FOV = .6;\n    \n    return Camera(\n      pos,\n      normalize(forward + FOV * uv.x * right + FOV * uv.y * up),\n      forward,\n      right,\n      up,\n      FOV\n    );\n}\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n      map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n      map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n      map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getScreenSpace(gl_FragCoord.xy);\n    \n    mouse = getScreenSpace(iMouse.xy);\n    \n    vec3 diff = a-b;\n    vec3 norm = normalize(diff);\n    \n    vec3 ro = vec3(0,0,-1.8);\n    vec3 la = vec3(.25, .1, 0);\n    \n    // ro = b - norm * 1.;\n    // la = b;\n    \n    Camera cam = getCamera(uv, ro, la);\n    \n    Surface surface = calcIntersection(cam);\n    fragColor = vec4((calcNormal(surface.position)+.5) * step(1., surface.id), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[876, 876, 908, 908, 1007], [1009, 1009, 1047, 1047, 1391], [1393, 1511, 1550, 1550, 1705], [1706, 1759, 1780, 1780, 2549], [2550, 2550, 2570, 2570, 2593], [2595, 2595, 2637, 2637, 3369], [3370, 3370, 3429, 3429, 3764], [3766, 3766, 3797, 3797, 4048], [4052, 4052, 4109, 4109, 4554]], "test": "untested"}
{"id": "fdtSWf", "name": "Newton's Clock", "author": "been_jamming", "description": "An analog clock, where the ends of the hands are the roots of the cubic in a Newton fractal", "tags": ["2d", "fractal"], "likes": 11, "viewed": 324, "published": 3, "date": "1634081469", "time_retrieved": "2024-07-30T18:56:21.303991", "image_code": "//Newton's Clock\n//An analog clock, where the ends of the hands are the roots\n//of the cubic in a Newton fractal\n//\n//Ben Jones - 10/12/2021\n\n#define TOLERANCE 0.0001\n#define PI 3.1415927\n\n//Complex numbers are in the form (a, b) := a + bi\n\nvec2 complex_mult(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 complex_div(vec2 a, vec2 b){\n    return vec2(dot(a, b), a.y*b.x - a.x*b.y)/dot(b, b);\n}\n\n//Credit to @iq: https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(in vec2 p, in vec2 b){\n    float h = clamp(dot(p,b)/dot(b,b), 0.0, 1.0);\n    return length(p - b*h);\n}\n\n//Used to draw the hands on the clock\n//Anti-aliasing with sdfs is luckily pretty easy\nvec3 clock_hands(vec2 coord, vec2 root0, vec2 root1, vec2 root2){\n    float dist0;\n    float dist1;\n    float dist2;\n    vec3 color = vec3(0.0);\n    float i;\n    float weight;\n    \n    dist0 = sdSegment(coord, root0);\n    dist1 = sdSegment(coord, root1);\n    dist2 = sdSegment(coord, root2);\n    \n    color += vec3(1.0)*clamp(0.25*(0.05 - dist0)*min(iResolution.x, iResolution.y), 0.0, 1.0); \n    color += vec3(1.0)*clamp(0.25*(0.05 - dist2)*min(iResolution.x, iResolution.y), 0.0, 1.0);\n    \n    for(i = 0.0; i < 12.0; i++){\n        dist0 = length(vec2(cos(2.0*PI*i/12.0), sin(2.0*PI*i/12.0)) - coord);\n        color += vec3(1.0)*clamp(0.25*(0.025 - dist0)*min(iResolution.x, iResolution.y), 0.0, 1.0);\n    }\n    \n    weight = clamp(0.25*(0.025 - dist1)*min(iResolution.x, iResolution.y), 0.0, 1.0);\n    color = weight*vec3(1.0, 0.0, 0.0) + (1.0 - weight)*color;\n    \n    return clamp(color, vec3(0.0), vec3(1.0));\n}\n\n//Iterate Newton's method to produce the fractal\nvec3 newtons_iterations(vec2 coord, vec2 root0, vec2 root1, vec2 root2, int iters){\n    int i;\n    //These are the coefficients to the polynomial with the 3 roots\n    vec2 sum;\n    vec2 double_prod;\n    vec2 prod;\n    vec2 coord_cubed;\n    vec2 sum_coord;\n    vec2 val;\n    vec2 deriv;\n    vec3 color = vec3(0.0);\n    float dist0;\n    float dist1;\n    float dist2;\n    float factor;\n    \n    sum = root0 + root1 + root2;\n    double_prod = complex_mult(root0, root1) + complex_mult(root0, root2) + complex_mult(root1, root2);\n    prod = complex_mult(complex_mult(root0, root1), root2);\n    \n    //Here is where we do the actual iteration\n    for(i = 0; i < iters; i++){\n        sum_coord = complex_mult(sum, coord);\n        coord_cubed = complex_mult(coord, complex_mult(coord, coord));\n        val = coord_cubed - complex_mult(sum_coord, coord) + complex_mult(double_prod, coord) - prod;\n        deriv = 3.0*complex_mult(coord, coord) - 2.0*sum_coord + double_prod;\n        coord -= 1.0*complex_div(val, deriv);\n        dist0 = dot(coord - root0, coord - root0);\n        dist1 = dot(coord - root1, coord - root1);\n        dist2 = dot(coord - root2, coord - root2);\n        if(min(dist0, min(dist1, dist2)) < TOLERANCE){\n            break;\n        }\n    }\n    \n    factor = max(TOLERANCE - dist0, 0.0)/TOLERANCE;\n    color += dist0 < TOLERANCE ? vec3(1.0, 0.0, 0.0)*((float(iters - i - 2) + factor)/float(iters)) : vec3(0.0);\n    factor = max(TOLERANCE - dist1, 0.0)/TOLERANCE;\n    color += dist1 < TOLERANCE ? vec3(0.0, 1.0, 0.0)*((float(iters - i - 2) + factor)/float(iters)) : vec3(0.0);\n    factor = max(TOLERANCE - dist2, 0.0)/TOLERANCE;\n    color += dist2 < TOLERANCE ? vec3(0.0, 0.0, 1.0)*((float(iters - i - 2) + factor)/float(iters)) : vec3(0.0);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 coord;\n    vec3 color;\n    float sec_angle;\n    float min_angle;\n    float hr_angle;\n    vec2 root0;\n    vec2 root1;\n    vec2 root2;\n    float lighting;\n    \n    //Get the angle of the sec, min, and hr hands\n    sec_angle = PI/2.0 - mod(2.0*PI*iDate.w/60.0, 2.0*PI);\n    min_angle = PI/2.0 - mod(2.0*PI*iDate.w/3600.0, 2.0*PI);\n    hr_angle = PI/2.0 - mod(2.0*PI*iDate.w/43200.0, 2.0*PI);\n    \n    //Normalized coordinates, center (0, 0)\n    coord.x = fragCoord.x/iResolution.y - iResolution.x/(2.0*iResolution.y);\n    coord.y = fragCoord.y/iResolution.y - 0.5;\n    coord *= 3.0;\n    \n    root0 = 0.85*vec2(cos(min_angle), sin(min_angle));\n    root1 = 0.7*vec2(cos(sec_angle), sin(sec_angle));\n    root2 = 0.4*vec2(cos(hr_angle), sin(hr_angle));\n    \n    lighting = 0.3333/(1.0 + dot(coord - root0, coord - root0)) + 0.3333/(1.0 + dot(coord - root1, coord - root1)) + 0.3333/(1.0 + dot(coord - root2, coord - root2));\n    \n    color = (0.75*clock_hands(coord, root0, root1, root2) + newtons_iterations(coord, root0, root1, root2, 15))*lighting;\n    \n    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 275, 275, 332], [334, 334, 367, 367, 426], [428, 493, 531, 531, 611], [613, 700, 765, 765, 1617], [3449, 3449, 3503, 3503, 4615]], "test": "untested"}
{"id": "fsdXWX", "name": "Taste of Noise 3", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 40, "viewed": 1184, "published": 3, "date": "1634081404", "time_retrieved": "2024-07-30T18:56:22.182642", "image_code": "\n// taste of noise 3 by leon denise 2021/10/12\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\nfloat rng;\n\n// sdf\nfloat map (vec3 p)\n{\n    vec3 pp = p;\n    \n    // time\n    float t = iTime;\n    \n    // rotation parameter\n    vec3 angle = vec3(14.,13.,18.)+p*.5;\n    \n    angle.z += t*0.5;\n    //float loop = fract(t/10.)*6.28;\n    \n    // kif\n    const int count = 16;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        // fold\n        p.x = abs(p.x)-.6*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);//+loop);\n        \n        // sphere\n        shape = sdBox(p, vec3(.3,0.01,.3)*a);\n        \n        // material blending\n        material = shape < scene ? float(index) : material;\n        \n        // add\n        scene = min(scene, shape);\n        \n        // falloff\n        a /= 1.2;\n    }\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,-3.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    eye.xz *= rot(0.4+mouse.x*3.);\n    eye.xy *= rot(0.6-mouse.y*3.);\n    vec3 z = normalize(-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(vec3(z * 1. + uv.x * x + uv.y * y));\n    vec3 pos = eye + ray * .1;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    rng = hash13(seed);\n    \n    // raymarch\n    const int steps = 30;\n    for (int index = steps; index > 0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            float shade = float(index)/float(steps);\n            \n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n            \n            // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n            vec3 tint = vec3(.5)+vec3(0.5)*cos(vec3(1,2,3)+material*0.2+length(pos)*4.);\n            \n            // specular lighting\n            float ld = dot(reflect(ray, normal), vec3(0,1,0))*0.5+0.5;\n            vec3 light = vec3(0.196,0.925,0.914) * pow(ld, 2.) * 0.5;\n            \n            // pixel color\n            fragColor.rgb = (tint + light) * shade;\n            \n            break;\n        }\n        \n        // dithering\n        dist *= 0.5 + 0.1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdXWX.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[244, 251, 271, 271, 1116], [1118, 1156, 1213, 1232, 2940]], "test": "untested"}
{"id": "fstXWX", "name": "Dark land", "author": "akmaaars", "description": "trivial 3d perlin noise, one 2d slice for heightmap, another for lighting", "tags": ["noise", "perlin", "isoline"], "likes": 2, "viewed": 317, "published": 3, "date": "1634073783", "time_retrieved": "2024-07-30T18:56:23.032371", "image_code": "const float pi = 3.1415926535;\nfloat randf(int counter) // -> [0, 1]\n{\n    return fract(sin(float(counter)) * 43.7585453);\n}\nvec2 randf2(int counter)\n{\n    float phi = randf(counter) * 2. * pi;\n    return vec2(cos(phi), sin(phi));\n}\nvec3 randf3(int counter)\n{\n    float phi = randf(counter) * 2. * pi;\n    float cos_theta = 2. * randf(counter * 2) - 1.;\n    float sin_theta = sqrt(1. - cos_theta * cos_theta);\n    return vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);\n}\n\nfloat g(float t)\n{\n    return t * t * (3. - 2. * t);\n}\n\nfloat squareSize;\nfloat perlinNoise(vec3 P) // -> [0, 1]\n{\n    vec3 p = P / squareSize;\n    ivec3 i = ivec3(floor(p));\n    vec3 r = fract(p);\n\n    const int iL = 10;\n    const int iS = iL * iL;\n    int i00 = i.x + iL * i.y + iS * i.z;\n\n    float f000 = dot(r - vec3(0., 0., 0.), randf3(i00));\n    float f001 = dot(r - vec3(1., 0., 0.), randf3(i00 + 1));\n    float f010 = dot(r - vec3(0., 1., 0.), randf3(i00 + iL));\n    float f011 = dot(r - vec3(1., 1., 0.), randf3(i00 + iL + 1));\n    float f100 = dot(r - vec3(0., 0., 1.), randf3(i00 + iS));\n    float f101 = dot(r - vec3(1., 0., 1.), randf3(i00 + iS + 1));\n    float f110 = dot(r - vec3(0., 1., 1.), randf3(i00 + iS + iL));\n    float f111 = dot(r - vec3(1., 1., 1.), randf3(i00 + iS + iL + 1));\n    float f00 = f000 + (f001 - f000) * g(r.x);\n    float f01 = f010 + (f011 - f010) * g(r.x);\n    float f10 = f100 + (f101 - f100) * g(r.x);\n    float f11 = f110 + (f111 - f110) * g(r.x);\n    float f0 = f00 + (f01 - f00) * g(r.y);\n    float f1 = f10 + (f11 - f10) * g(r.y);\n    return f0 + (f1 - f0) * g(r.z) + 0.5;\n}\n\nfloat bell(float x, float s)\n{\n    return exp2(-x * x * s);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    squareSize = min(iResolution.x, iResolution.y) * 0.3;\n    float t = iTime * squareSize;\n    vec3 p = vec3(gl_FragCoord.xy, 0.02 * t);\n    float f = perlinNoise(p);\n\n    vec2 dF = vec2(dFdx(f), dFdy(f));\n    const float lineWidth = 0.6;\n    float s = 0.72134752 / (dot(dF, dF) * lineWidth * lineWidth);\n\n    float c = 0.;\n    c += 0.2 * bell(f - 0.1, s);\n    c += 0.4 * bell(f - 0.2, s);\n    c += 0.5 * bell(f - 0.3, s);\n    c += 0.6 * bell(f - 0.4, s);\n    c += 0.8 * bell(f - 0.5, s);\n    c += 0.6 * bell(f - 0.6, s);\n    c += 0.5 * bell(f - 0.7, s);\n    c += 0.4 * bell(f - 0.8, s);\n    c += 0.2 * bell(f - 0.9, s);\n\n    p.z = t * 0.2 + 100.;\n    float I = (perlinNoise(p) + 0.3) * 0.7;\n    c *= (I * I) * (I * I);\n\n    fragColor = vec4(vec3(0.0, 0.0, 0.0) + vec3(c), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 70, 70, 124], [125, 125, 151, 151, 232], [233, 233, 259, 259, 483], [485, 485, 503, 503, 539], [559, 559, 599, 599, 1606], [1608, 1608, 1638, 1638, 1669], [1670, 1670, 1727, 1727, 2508]], "test": "untested"}
{"id": "7scXWf", "name": "Lawless Fantasy", "author": "prishainabox", "description": "Learning from Inigo Quilez's videos and articles.\n\nFBM detail in SDFs\nhttps://iquilezles.org/articles/fbmsdf/fbmsdf.htm", "tags": ["raymarching"], "likes": 16, "viewed": 641, "published": 3, "date": "1634069943", "time_retrieved": "2024-07-30T18:56:23.904040", "image_code": "const float EPSILON = 0.001;\n\n//*******************************************************//\n\n// Light struct\nstruct Light {\n    vec3 clr;\n    vec3 dir;\n    float shadowSoftness;\n};\n\n// Material struct\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    vec3 ref;\n    float id;\n};\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n//*******************************************************//\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smoothmax\nfloat smoothmax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// Smooth min for distance and color\nvec4 smoothmin(in float a, in float b, in vec3 clr1, in vec3 clr2, in float k) {\n   float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n   float d = mix(b, a, h) - k*h*(1.0-h);\n   vec3 c = mix(clr2, clr1, h);\n   return vec4(c, d);\n}\n\n// return points for finite and infinite repetition\n\nvec3 infRep(in vec3 pt, in vec3 period) {\n    return mod(pt + 0.5 * period, period) - 0.5 * period;\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 minLim, in vec3 maxLim) {\n    return pt - period * clamp(round(pt/period), minLim, maxLim);\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 lim) {\n    return pt - period * clamp(round(pt/period), -lim, lim);\n}\n\n\n//*******************************************************//\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\nfloat fractalNoise(in vec3 uvw) {\n    float c = noise(uvw * 4.0);\n    c += 0.5 * noise(uvw * 8.0);\n    c += 0.25 * noise(uvw * 16.0);\n    c += 0.125 * noise(uvw * 32.0);\n    c += 0.0625 * noise(uvw * 64.0);\n    c /= 2.0;\n    return c;\n}\n\n//*******************************************************//\n\n// SDFs\n\nfloat sdfSphere(in vec3 pt, in float rad) {\n    return length(pt) - rad;\n}\n\nfloat sdfBox(vec3 pt, vec3 b) {\n\tvec3 q = abs(pt) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdfRandSphere(vec3 id, vec3 fid, vec3 t) {\n    // random radius \n    float r = 0.5*random(id+t);\n    // sphere signed distance\n    return length(fid - t) - r;\n}\n\n\n//*******************************************************//\n\n// SDF BASE\n\nfloat sdfBase(in vec3 pt) {\n\n    vec3 id = floor(pt);\n    vec3 fid = fract(pt);\n\n    // 8 corner spheres\n    float base = sdfRandSphere(id, fid, vec3(0, 0, 0));\n    base = min(base, sdfRandSphere(id, fid, vec3(0, 0, 1)));\n    base = min(base, sdfRandSphere(id, fid, vec3(0, 1, 0)));\n    base = min(base, sdfRandSphere(id, fid, vec3(0, 1, 1)));\n    base = min(base, sdfRandSphere(id, fid, vec3(1, 0, 0)));\n    base = min(base, sdfRandSphere(id, fid, vec3(1, 0, 1)));\n    base = min(base, sdfRandSphere(id, fid, vec3(1, 1, 0)));\n    base = min(base, sdfRandSphere(id, fid, vec3(1, 1, 1)));\n    \n    return base;\n\n}\n\n// SDF SCENE\n\nfloat sdfScene(in vec3 pt, out Material mat) {\n\n    // default material\n    mat.amb = 0.01;\n\n    // distance to closest object\n    float res;\n    \n    // water stuff\n    \n    float water = pt.y - 0.06;\n    Material waterMat;\n    {\n        waterMat.clr = vec3(0.05, 0.04, 0.15);\n        waterMat.dif = 0.1;\n        waterMat.spec = 1.0;\n        waterMat.shininess = 10.0;\n        waterMat.ref = vec3(0.3, 0.65, 0.75);\n        waterMat.id = 0.0;\n    }\n    \n    \n    // sphere and plane\n    float sphere = sdfSphere(pt - vec3(0, 0.2, 0), 3.3);\n    float terrain = pt.y+0.05;\n    \n    // fbm\n    {\n        vec3 p = pt;\n        // scale\n        float scl = 1.0;\n        // subtract\n        for (int i = 0; i < 12; i++) {\n            // eval noise base\n            float n = scl*sdfBase(p);\n            // subtract from sphere\n            if (i < 8) sphere = smoothmax(sphere, -n, scl*0.2);\n            // add to plane\n            n = smoothmax(n, terrain-0.1*scl, 0.3*scl);\n            terrain = smoothmin(n, terrain, 0.3*scl);\n            // rotate point (matrix from Inigo's article)\n            p = mat3(\n                 0.00, 1.60, 1.20,\n                -1.60, 0.72,-0.96,\n                -1.20,-0.96, 1.28\n            ) * p;\n            \n            // half amplitude\n            scl *= 0.5;\n        }\n    }\n    \n    // material\n    Material landMat;\n    {\n        landMat.id = 1.0;\n        landMat.ref = vec3(0.0);\n        if (terrain < sphere) {\n            landMat.clr = vec3(0.05, 0.03, 0.04);\n            landMat.dif = 0.4;\n            landMat.spec = 0.2;\n            landMat.shininess = 100.0;\n        } else {\n            landMat.clr = vec3(0.08, 0.08, 0.05) * 1.2;\n            landMat.dif = 1.0;\n            landMat.spec = 1.2;\n            landMat.shininess = 10.0;\n        }\n    }\n    \n    res = min(terrain, sphere);\n    \n    if (res < water) mat = landMat;\n    else mat = waterMat;\n    \n    res = min(res, water);\n    \n    return res;\n    \n}\n\n//*******************************************************//\n\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdfScene(pt + h.xyy, m) - sdfScene(pt - h.xyy, m),\n       sdfScene(pt + h.yxy, m) - sdfScene(pt - h.yxy, m),\n       sdfScene(pt + h.yyx, m) - sdfScene(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n    \n    // result\n    float res = -1.0;\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 230 && td < 10.0; i++) {\n        Material m;\n        float h = sdfScene(ro + td*rd, m);\n        // if distance is really close, break\n        if (h < EPSILON*td*2.5) {\n           res = td;\n           mat = m;\n           break;\n        }\n        // add to total distance\n        td += h;\n    }\n       \n    return res;\n    \n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        Material m;\n        float d = sdfScene(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection, no shadow -> 1.0\n    return res;\n}\n\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 4; i++) {\n        float h = 0.01 + 0.07 * float(i);\n        float d = sdfScene(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.97;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    return mix(clr, fogClr, 1.0 - exp(-0.005 * d * d * d)); // fog\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n    \n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow\n    float shadow = softShadow(pt, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in vec3 nor, in Material mat) {\n\n    vec3 pt = ro + rd * d;\n\n    // COLORS\n    vec3 skyClr = vec3(0.005, 0.005, 0.015) * 8.0;\n    \n    // SUN LIGHT\n    Light sun;\n    sun.clr = vec3(15, 9, 4) * 0.4;\n    sun.dir = normalize(vec3(0.5, 0.15, 0.5));\n    sun.shadowSoftness = 20.9;\n    \n    // back sun light\n    Light sun2;\n    sun2.clr = sun.clr * 4.0;\n    sun2.dir = normalize(vec3(0.3, 0.05, 1.5));\n    sun2.shadowSoftness = 10.9;\n    \n    // background color\n    vec3 clr = skyClr;\n    \n    // return background if too far\n    if (d < 0.0) {\n        // sun\n        clr = mix(skyClr, sun2.clr * 0.05, pow(max(dot(rd, sun2.dir), 0.0), 2.0));\n        clr = mix(clr, sun2.clr * 0.15, pow(max(dot(rd, sun2.dir), 0.0), 40.0));\n        return clr;\n    }\n    \n    clr = mat.clr;\n    \n    // bump map\n    if (mat.id == 0.0) {\n        nor += 0.2 * sin(20.0 * fractalNoise(pt * 5.0));\n    } else if (mat.id == 1.0) {\n        nor += 0.2 * fractalNoise(pt);\n    }\n    \n    // LIGHTS\n   \n    // CALCULATE COLOR\n    float occ = calcOcc(pt, nor);\n    vec3 light = vec3(mat.amb);\n    light += calcLighting(pt, rd, nor, sun, mat) * occ; // sun\n    light += calcLighting(pt, rd, nor, sun2, mat) * occ; // sun2\n    light += (uclamp(dot(nor, vec3(0, 1, 0))) * 0.5 + 0.5) * skyClr * occ; // sky diffuse\n\n    clr *= light;\n    \n    clr = applyFog(rd, d, clr, sun.clr * 0.1, sun.dir, skyClr);\n    \n    return clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n    Material mat;\n    \n    vec3 clr = vec3(0);\n    \n    vec3 fil = vec3(1.0);\n    for (int i = 0; i < 4; i++) {\n        // cast ray, return dist to closest object and material\n        float d = castRay(ro, rd, mat);\n        vec3 nor = calcNormal(ro + rd*d);\n        // add to color\n        clr += fil * calcClr(ro, rd, d, nor, mat);\n        fil *= mat.ref;\n        // break if we don't need to reflect\n        if (mat.ref.r == 0.0 && mat.ref.g == 0.0 && mat.ref.g == 0.0) break;\n        // update origin and reflect dir\n        ro += rd*d + nor*EPSILON*3.0;\n        if (i > 1) {\n            rd = reflect(rd, nor);\n        }\n    }\n    \n    clr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n    return clr;\n    \n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //float time = iTime;\n    //vec2 mouse = iMouse.xy;\n    vec2 res = iResolution.xy;\n\n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0, 0.0, 0);\n    // ray origin\n    vec3 ro = vec3(4.1, 0.5, -4.1);\n    \n    vec3 rd = setCamera(uv, ro, target);\n    \n    // calculate color based on distance, etc\n    vec3 clr = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 418, 443, 443, 478], [541, 573, 626, 626, 715], [717, 730, 776, 776, 848], [850, 887, 967, 967, 1111], [1166, 1166, 1207, 1207, 1267], [1269, 1269, 1342, 1342, 1410], [1412, 1412, 1466, 1466, 1529], [1614, 1614, 1640, 1640, 1693], [1695, 1695, 1720, 1720, 1796], [1798, 1798, 1823, 1823, 1908], [1910, 1910, 1936, 1936, 2620], [2622, 2622, 2655, 2655, 2858], [2930, 2930, 2973, 2973, 3004], [3006, 3006, 3037, 3037, 3127], [3129, 3129, 3177, 3199, 3295], [3372, 3372, 3399, 3399, 3984], [4000, 4000, 4046, 4071, 5952], [6015, 6015, 6044, 6044, 6369], [6432, 6432, 6489, 6508, 6934], [6936, 6936, 6990, 6990, 7403], [7405, 7405, 7445, 7445, 7751], [7814, 7814, 7914, 7914, 8062], [8064, 8064, 8153, 8173, 8569], [8571, 8571, 8651, 8651, 10012], [10075, 10075, 10112, 10112, 10832], [10895, 10895, 10951, 10951, 11206], [11208, 11208, 11265, 11322, 11747]], "test": "untested"}
{"id": "sdcSDX", "name": "Egg Yolks", "author": "SnoopethDuckDuck", "description": "This is the same code from Log Polar Test (forked), but without the log polar stuff - no idea how to make the right side not buggy, leaving it here to come back to later\n\nbetter starting point:\nhttps://www.shadertoy.com/view/NdsfWs", "tags": ["e"], "likes": 9, "viewed": 327, "published": 3, "date": "1634068235", "time_retrieved": "2024-07-30T18:56:24.962211", "image_code": "#define pi 3.14159\n\n// Code modified from here:\n// https://thebookofshaders.com/edit.php#09/marching_dots.frag\n// https://www.osar.fr/notes/logspherical/\n\n// used for generating random radii for each tile\nfloat h21 (float a, float b, float zoom) {\n    a = mod(a, zoom); b = mod(b, zoom);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\n// Determines how tiles move\n// (modified bookofshaders code, replaced if statements with step functions)\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    //_st.x = fract(2. * _st.x);\n    //_st.y = fract(2. * _st.y);\n    float time = iTime * _speed;\n    \n    // Change me for different patterns\n    float ft = fract(2. * abs(_st.x - 0.5) + 2. * abs(_st.y - 0.5) + time);\n    \n    // e.g.\n    // float ft = fract(2. * abs(_st.x) + 2. * abs(_st.y) + time);\n    // float ft = fract(2. * max(abs(_st.x - 0.5), abs(_st.y - 0.5)) + time);\n    // float ft = .5 + .5 * cos(length(_st-0.5) - 8. * time);\n    \n    _st *= _zoom;//sqrt(_zoom);\n    \n    float k = step(0.5, ft);\n    _st.x +=      k * sign(fract(_st.y * 0.5) - 0.5) * ft * 2.;\n    _st.y += (1.-k) * sign(fract(_st.x * 0.5) - 0.5) * ft * 2.;\n\t\n    // Multiply _st here to get more than 1 shape per tile\n    return fract(_st * 1.);\n}\n\n// Provides the shape in each tile\nfloat circle(vec2 uv, float r){\n    uv = uv - .5;\n    return smoothstep(1.0-r, 1.0-r+r*0.2, 1.-dot(uv,uv)*3.14);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    \n    float zoom = 16.;\n    \n    // Cut uv into smaller uvs\n    vec2 uv = fract(vec2(st.x * zoom, st.y * zoom));\n    vec2 ft = floor(st * zoom);\n    \n    // Generate values for each corner of uv, used for circle radii\n    float l  = h21(ft.x + 1., ft.y,      zoom);\n    float t  = h21(ft.x,      ft.y + 1., zoom);\n    float tl = h21(ft.x + 1., ft.y + 1., zoom);\n    float id = h21(ft.x,      ft.y,      zoom);\n\n    // Smooth the cut uvs so different uvs meet continuously on the edges\n    uv = uv * uv * (3. - 2. * uv);\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l * uv.x * (1.-uv.y)\n     \t    + t * (1.-uv.x) * uv.y\n     \t    + tl * uv.x * uv.y\n      \t    + id * (1.-uv.x) * (1.-uv.y);\n        \n    // Do the tile pattern\n    st = movingTiles(st, zoom, 0.2);\n\n    // Generate circle using radius we've obtained\n    vec3 color = vec3( circle(st, 0.7 * v) - circle(st, 0.2 * v) );\n    color += vec3(circle(st, 0.2 * v),circle(st, 0.18 * v),0.);\n\t\n    //color += (0.3 + .7 * h21(-10.*ft.x,ft.y)) * vec3(st.xy,1.);\n  \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcSDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 205, 247, 247, 366], [368, 474, 528, 594, 1262], [1264, 1299, 1330, 1330, 1413], [1415, 1415, 1472, 1472, 2665]], "test": "untested"}
{"id": "7d3SDf", "name": "Boxyduck", "author": "eimink", "description": "A simple walking duck. I asked rimina to do a duck during a stream, so I decided to do one myself as well!", "tags": ["sdf", "walking", "duck"], "likes": 6, "viewed": 262, "published": 3, "date": "1634063115", "time_retrieved": "2024-07-30T18:56:25.736141", "image_code": "// A very simple duck that's walking.\n// Shoutout to rimina! :)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat llength = .4;\nfloat lspread = .4;\nfloat wspeedmod = 4.;\nfloat wstridemod = .2;\n\nstruct MarchResult\n{\n    vec3 p;\n    float id;\n};\n\n\nvec2 sdf(vec3 p){\n   vec3 pp = p;\n\n   pp = pp - vec3(1.+sin(iTime*wspeedmod*2.)*.02,.7,.0);\n   float head = sdBox(pp,vec3(.5,.4,.5));\n   vec3 ppp = pp - vec3(.7,-.1,.0);\n   float beak = sdBox(ppp,vec3(.2,.08,.2));\n   pp.z = abs(pp.z);\n   pp = pp - vec3(.5,.2,.3);\n   float eyes = sdBox(pp,vec3(.1,.1,.1));\n   \n   vec2 h = opU(vec2(eyes,1.0),opU(vec2(beak,2.0),vec2(head,3.0)));\n\n   pp = p;\n   rot(pp.xz,-sin(iTime*wspeedmod)*.1);\n   float body = sdBox(pp,vec3(1.,.6,.8));\n   pp = pp - vec3(-1.1+sin(iTime*wspeedmod*2.)*.02,.7,.0);\n   rot(pp.xz,sin(iTime*wspeedmod)*.1);\n   float tail = sdBox(pp,vec3(.4,.1,.6));\n   body = min(tail,body); \n   vec2 b = opU(vec2(body,3.0),h);\n   \n   pp = p;\n   rot(pp.xy,sin(iTime*wspeedmod)*wstridemod);\n   pp = pp - vec3(0.,-1.,lspread);\n   float lleg = sdBox(pp,vec3(.1,llength,.2));\n   lleg = min(lleg,sdBox(pp-vec3(.2,-llength,.0),vec3(.4,.1,.2)));\n   \n   pp = p;\n   rot(pp.xy,-sin(iTime*wspeedmod)*wstridemod);\n   pp = pp - vec3(0.,-1.,-lspread);\n   float rleg = sdBox(pp,vec3(.1,llength,.2));\n   rleg = min(rleg,sdBox(pp-vec3(.2,-llength,.0),vec3(.4,.1,.2)));\n   float legs = min(lleg,rleg);\n   \n   return opU(vec2(legs,2.0),b);\n\n}\n\nMarchResult march(in vec3 ro, in vec3 rd, inout float t){\n\n    MarchResult m;\n    m.p = ro+rd;\n    for(int i = 0; i < 40; ++i){\n        vec2 d = sdf(m.p);\n        t += d.x;\n        m.p += rd*d.x;\n        m.id = d.y;\n        \n        if(d.x < 0.01 || t > 100.){\n            break;\n        }\n        \n    }\n    \n    return m;\n}\n\nvec3 color(in float id)\n{\n    if (id == 1.0)\n        return vec3(0.1);\n    else if (id == 2.0)\n        return vec3(.8,.3,.2);\n    else if (id == 3.0)\n        return vec3(.8,.7,.4);\n    else\n        return vec3(0);\n}\nvec3 calcNormal( in vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(sdf(pos+e.xyy).x-sdf(pos-e.xyy).x,\n                           sdf(pos+e.yxy).x-sdf(pos-e.yxy).x,\n                           sdf(pos+e.yyx).x-sdf(pos-e.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(3.,2.0,3.);\n    vec3 ct = vec3(0,0,0);\n    vec3 ld = vec3(-2.,0.5,2.);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t;\n    MarchResult m;\n    m.p = vec3(0.0);\n    m.id = 0.0;\n    m = march(cp,rd,t);\n    \n    vec3 col = vec3(0.0);\n    if(t < 100.){\n        col = color(m.id) + (clamp(dot(calcNormal(m.p), ld), 0.0, 1.0)*0.1);\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3SDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 96, 96, 183], [185, 185, 218, 218, 263], [265, 265, 293, 293, 331], [471, 471, 488, 488, 1640], [1642, 1642, 1699, 1699, 1967], [1969, 1969, 1994, 1994, 2184], [2185, 2185, 2217, 2217, 2442], [2444, 2444, 2501, 2501, 3208]], "test": "untested"}
{"id": "7s3SDf", "name": "quadmapSimple", "author": "Sergeindamix", "description": "Simplified remap", "tags": ["map", "projection", "quad", "mat3", "projective", "quadrilateral", "quadmap", "quad2quad", "quadtoquad", "mat3x3", "3x3matrix"], "likes": 3, "viewed": 260, "published": 3, "date": "1634061318", "time_retrieved": "2024-07-30T18:56:26.501096", "image_code": "\nmat3 basisToPoints(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n  mat3 m =\n    mat3\n    (\n      vec3(p0, 1.0),\n      vec3(p1, 1.0),\n      vec3(p2, 1.0)\n    );\n\n  vec3 v = inverse(m) * vec3(p3,1.0);\n\n  mat3 d =\n    mat3\n    (\n      vec3(v.x, 0.0, 0.0),\n      vec3(0.0, v.y, 0.0),\n      vec3(0.0, 0.0, v.z)\n    );\n\n  return m * d;\n}\n\nmat3 general2DProjection(\n  vec2 s0, vec2 d0,\n  vec2 s1, vec2 d1,\n  vec2 s2, vec2 d2,\n  vec2 s3, vec2 d3\n)\n{\n  mat3 s = basisToPoints(s0, s1, s2, s3);\n  mat3 d = basisToPoints(d0, d1, d2, d3);\n  return d * inverse(s);\n}\n\nvec2 project(mat3 m, float x, float y)\n{\n  vec3 v = m * vec3(x,y, 1.0);\n  return v.xy / v.z; // dehomogenize\n}\n\n// Just some code to visualize the quad\n\n#define PI 3.1415926\n#define TAU (2.0 * PI)\n\nfloat checker(vec2 p)\n{\n  return smoothstep(-0.05,+0.05, sin(p.x*TAU)*sin(p.y*TAU));\n}\n\nvec4 tunn(vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    \n    float t = iTime * .8;\n    float rng = .3;\n    vec2 offset = vec2(cos(t), sin(t)) * rng;//wave movement\n    uv += offset;\n    \n    \n    float a = atan(uv.y, uv.x) / 3.14 * 4.;\n    float l = length(uv);\n    \n    \n    // a = floor(a * 5.) / 5.;\n    vec2 texUv = vec2(a, 1. / l - iTime * .5);//backward movement\n\n    \n    float hole = min(1., pow(l, 2.));\n    vec3 col = textureGrad(iChannel0, texUv, dFdx(uv), dFdy(uv)).rgb * hole;\n\n    return vec4(col, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime / 5.0;\n    vec2 p0 = vec2(0.2, 0.2) + 0.1 * vec2(+cos(t),+sin(t));\n    vec2 p1 = vec2(0.8, 0.2) + 0.15 * vec2(-sin(t),+cos(t));\n    vec2 p2 = vec2(0.2, 0.8) + 0.2 * vec2(-cos(t),-sin(t));\n    vec2 p3 = vec2(0.8, 0.8) + 0.25 * vec2(+sin(t),-cos(t));\n\n    // NOTE: quads must be convex\n    mat3 m = general2DProjection\n    (\n      p0, vec2(0.0, 0.0),\n      p1, vec2(1.0, 0.0),\n      p3, vec2(1.0, 1.0),\n      p2, vec2(0.0, 1.0)\n    );\n\n    vec2 q = project(m, uv.x, uv.y);\n    fragColor = tunn(fragCoord);//texture(iChannel0, q);\n    //fragColor = vec4(checker(5.0 * q));\n\n    if(any(lessThan(q, vec2(0.0))) || any(greaterThan(q, vec2(1.0))))\n        fragColor = vec4(0.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3SDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 57, 57, 324], [326, 326, 434, 434, 545], [547, 547, 587, 587, 657], [745, 745, 768, 768, 831], [833, 833, 860, 860, 1420], [1423, 1423, 1480, 1480, 2215]], "test": "untested"}
{"id": "fscXDf", "name": "Taste of Noise 2", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 9, "viewed": 476, "published": 3, "date": "1634055277", "time_retrieved": "2024-07-30T18:56:27.274029", "image_code": "\n// taste of noise 2 by leon denise 2021/10/12\n// result of experimentation with organic patterns\n// using code from Inigo Quilez, David Hoskins and NuSan\n// licensed under hippie love conspiracy\n\n// global variable\nfloat material;\n\n// sdf\nfloat map (vec3 p)\n{\n    vec3 pp = p;\n    \n    // time\n    float t = iTime * 0.1;\n    \n    // travel\n    p.z += t;\n    \n    // rotation parameter\n    vec3 angle = vec3(4.,3.,8.) + p;\n    \n    // domain repeat\n    float grid = 1.5;\n    p = repeat(p, grid);\n    \n    // kif\n    const int count = 6;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        // fold\n        p = abs(p)-.4*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-.3*a;\n        \n        // material blending\n        material = mix(material, float(index), smoothing(shape, scene, 0.1*a));\n        \n        // add\n        scene = smin(scene, shape, 0.1 * a);\n        \n        // falloff\n        a /= 1.9;\n    }\n    \n    // cylinder hole\n    scene = smin(scene, length(pp.xy)-0.15, 0.1);\n    \n    // shell\n    scene = -(scene);\n    \n    // surface details\n    p = repeat(p, 0.03);\n    scene -= length(p)*.2;\n        \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,-0.2);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    eye.xz *= rot(0.4+mouse.x*3.);\n    eye.xy *= rot(0.6-mouse.y*3.);\n    vec3 z = normalize(-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(vec3(z * 0.5 + uv.x * x + uv.y * y));\n    vec3 pos = eye + ray * .1;\n    \n    // white noise\n    vec3 seed = vec3(gl_FragCoord.xy, iTime);\n    float rng = hash13(seed);\n    \n    // raymarch\n    const int steps = 30;\n    for (int index = steps; index > 0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.001)\n        {\n            float shade = float(index)/float(steps);\n            \n            // compute normal by NuSan (https://www.shadertoy.com/view/3sBGzV)\n            vec2 off=vec2(.001,0);\n            vec3 normal = normalize(map(pos)-vec3(map(pos-off.xyy), map(pos-off.yxy), map(pos-off.yyx)));\n            \n            // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n            vec3 tint = vec3(1.)+vec3(0.5)*cos(vec3(1,2,3)*material*0.2+pos.z);\n            \n            // specular lighting\n            float ld = dot(normal, -ray)*0.5+0.5;\n            vec3 light = vec3(0.196,0.925,0.914) * pow(ld, 10.) * 0.5;\n            \n            // pixel color\n            fragColor.rgb = (tint + light) *  shade;\n            \n            break;\n        }\n        \n        // dithering\n        dist *= 0.8 + 0.1 * rng;\n        \n        // raymarch\n        pos += ray * dist;\n    }\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat smoothing(float d1, float d2, float k) { return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); }\n    \n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n#define repeat(p,r) (mod(p,r)-r/2.)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXDf.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[233, 240, 260, 260, 1346], [1348, 1386, 1443, 1462, 3151]], "test": "untested"}
{"id": "ss3XWX", "name": "Log Polar Test", "author": "SnoopethDuckDuck", "description": "The centre looks a little off, I've changed this a few times now", "tags": ["e"], "likes": 17, "viewed": 445, "published": 3, "date": "1634051013", "time_retrieved": "2024-07-30T18:56:28.095833", "image_code": "#define pi 3.14159\n\n// Code modified from here:\n// https://thebookofshaders.com/edit.php#09/marching_dots.frag\n// https://www.osar.fr/notes/logspherical/\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    //_st.x = fract(2.*_st.x);\n    //_st.y = fract(2. * _st.y);\n    float time = iTime*_speed;\n    float ft = fract(2.*abs(_st.x-0.5) + 2.*abs(_st.y -0.5)  + time);\n    \n    _st *= _zoom;//sqrt(_zoom);\n    \n    float k = step(0.5, ft);\n    _st.x += k * sign(fract(_st.y * 0.5) - 0.5) *ft * 2.0;\n    _st.y += (1.-k) * sign(fract(_st.x * 0.5) - 0.5) * ft * 2.0;\n\t\n    // replace 3. for fun times\n    return fract(_st * 3.);\n}\n\nfloat circle(vec2 uv, float r){\n    uv = uv - .5;\n //  float a = atan(uv.y, uv.x);  \n //  return step(length(uv) * (1. + cos(20. * a + iTime)) * 0.4, r);\n   \n   return smoothstep(1.0-r,1.0-r+r*0.2,1.-dot(uv,uv)*3.14);\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord - .5 * iResolution.xy) /iResolution.y;\n    float time = iTime;\n    \n    // Apply the forward log-polar map\n    st = vec2(log(length(st)), atan(st.y, st.x));\n\n    // Scale everything so tiles will fit nicely in the ]-pi,pi] interval\n    st *= 0.5/pi;\n\n    // Convert pos to single-tile coordinates\n    st.x = fract(st.x - 0.05 * time) - 0.;\n    st.y = fract(st.y + 0.03 * time) - 0.;\n\n    // Do the actual pattern\n    float zoom = 17.;\n    \n    // Cut uv into smaller uvs\n    vec2 uv = fract(st * zoom);\n    vec2 ft = floor(st * zoom);\n    \n    // Generate values for each corner of uv\n    float l = h21(vec2(mod(ft.x+1., zoom), ft.y));\n    float t = h21(vec2(ft.x, mod(ft.y+1., zoom)));\n    float tl = h21(vec2(mod(ft.x+1.,zoom), mod(ft.y+1., zoom)));\n    float id = h21(vec2(ft.x, ft.y));\n\n    // Smooth edges of uvs so they meet nicely\n    uv = uv * uv * (3. - 2. * uv);\n    \n    // Box lerp between corner values\n    float v = l * uv.x * (1.-uv.y)\n     \t    + t * (1.-uv.x) * uv.y\n     \t    + tl * uv.x * uv.y\n      \t    + id * (1.-uv.x) * (1.-uv.y);\n        \n    // Generate tile pattern\n    st = movingTiles(st, zoom, 0.2);\n\n    // Scale circles weirdly ( set to 1. to see normal )\n    float sc = (1. + 0.5 * cos(time + 10.*cos(10. * v)));\n    vec3 color = vec3( circle(st, 0.8 * v * sc) - circle(st, 0.6 * v * sc) );\n\n    fragColor =  vec4(color, 1.);\n}\n\n\n//Copy paste this under the other shader\n#define AA 2.\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            //If the shader has global variables they need to be reset here\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3XWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 175, 175, 250], [252, 252, 306, 370, 730], [732, 732, 763, 763, 951], [953, 953, 1007, 1007, 2392], [2478, 2478, 2535, 2535, 3025]], "test": "untested"}
{"id": "sd3XWX", "name": "Master Roshi", "author": "the_last_willy", "description": "This is an assignment for a class on implicit modelling presented by Eric Galin.\n\nMore information in the code.\n\nI look forward for any feedback.", "tags": ["sdf", "color", "modelisation", "roshi"], "likes": 12, "viewed": 258, "published": 3, "date": "1634049221", "time_retrieved": "2024-07-30T18:56:29.229800", "image_code": "// MIT License Copyright (c) 2021 Willy Jacquet. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\nModeling by writing lines of code is not my forte.\nSo I made a buch of tools for providing an interactive editing interface.\nWorks quite well but it was way overkill for this assignement.\n\nThe tree code was automatically generated with these tools.\nIt's somewhere in there: https://github.com/the-last-willy/id3d\nDisclaimer: It's a big mess.\n\nI thought it would be smart to generate a tree that only computes the distance without the material.\nTurns out drivers actually optimize shaders, and no wonder they do.\nI'm going to leave both trees just as a reminder for the harsh lesson :)\n\nAnyway, the end result doesn't have any animation, texture or visual effect.\nThat's partly because the assignement was focused on modeling.\nAnd also because I spent too much time on utility stuff.\nI started making a background scene with the Kame House.\nUnfortunately, I couldn't finish it.\n\nBut still, I'm sort of happy about it.\n\nWhat I know I could improve:\n\n- Transforms are all over the place.\nThat's actually the reason I didn't bother with animation.\nI would have to clean them up first.\n\n- Non uniform scaling introduces a factor on the distance. Thats kills performance.\nI know I could get rid of most of them by integrating it to primitives,\nbut that's makes editing more difficult and some more work is required to do that.\n\n- I have everything required to make bounding volumes.\nThat could be a way to bound the bias introduced by non uniform scaling.\nI will definitely look into that.\n\n- Some operators could be flattened to get a logarithmic number of calls.\nThat's particularly the case of the union operator.\n\n- Magic constants everywhere.\nThe code is a bit ugly and could be made more readable.\nI apologize for that.\n\nConclusion:\nI had fun.\nI'm going to continue working on the tools I used to make this.\nAnd hopefully make some more cool stuff.\n*/\n\n// Common\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.8;\n  \n  ro=vec3(9.,0.,3.);\n  ro*=rotate_z(3.*3.14*m.x);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n}\n\n// Main\n\nconst int Steps=130;\nconst float Epsilon=.001;// Marching epsilon\n\nconst float rA=6.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=12.;\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  // Overstepping [Keinert2014].\n  float os_d = 1000.; // Overstepping distance.\n  float os_k = 0.2; // Overstepping coef.\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    \n    vec3 p=o+t*u;\n    float v=scene_sdf(p);\n    \n    \n    if(v < os_d) {\n        // Overstepped, go back and redo this iteration.\n        t -= os_d;\n        p=o+t*u;\n        v=scene_sdf(p);\n    }\n    \n\n    // Hit object\n    if(v<0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    \n    \n    // Move along ray and overstep.\n    t+=max(Epsilon, (1. + os_k) * abs(v));\n    // Compute overstepped distance.\n    os_d = os_k * abs(v);\n   \n    // Escape marched far away\n    if(t>(1. + os_k) * rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of samples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s = 0;\n    bool h = false;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.652,.451,.995),vec3(.552,.897,.995),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff=pow(.5*(1.+dot(n,l)),2.);\n  \n  bool h = false;\n  int s = 0;\n  float t=SphereTrace(p+.1*n,l,100.,h,s);\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n)\n{\n  vec3 c=.25+.25*background(n);\n  c+=.15*AmbientOcclusion(p+.1*n,n,0)*vec3(1.,1.,1.);\n  c+=.35*Light(p,n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./3.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro = vec3(0.), rd = vec3(0.);\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit = false;\n  int s = 0;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Position\n  vec3 pt=ro+t*rd;\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Compute normal\n    vec3 n=scene_normal(pt);\n\n    float lambertian = max(dot(-rd, n), 0.);\n    float brightness = .5 + lambertian * .5;\n    \n    // Shade object with light\n    rgb= brightness * scene_material(pt).color;\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n", "image_inputs": [], "common_code": "/*\n    In this file:\n    - Primitives and operators\n    - Sdf tree\n    - Material tree\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// Primitives and operators.\n// Credits to Inigo Quilez for most of it.\n\nstruct SdfAndMaterial {\n    vec3 color;\n    float distance;\n};\n\nfloat circle(float r, vec3 p) {\n    vec2 q = vec2(length(p.xz)-r,p.y);\n    return length(q);\n}\n\nfloat cone(in vec2 q, in vec3 p) {\n    vec2 w = vec2( length(p.xz), p.y );\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\n\nfloat corrected(float c, float d) {\n    return d * c;\n}\n\nSdfAndMaterial corrected(float c, SdfAndMaterial sam) {\n    return SdfAndMaterial(\n        sam.color,\n        corrected(c, sam.distance));\n}\n\nfloat cube(vec3 p) {\n    p = abs(p);\n    float exterior = length(max(p - vec3(.5), 0.));\n    float interior = min(max(p.x, max(p.y, p.z)) - .5, 0.);\n    return exterior + interior;\n}\n\nfloat difference(float d0, float d1) {\n    return max(d0, -d1);\n}\n\nSdfAndMaterial difference(in SdfAndMaterial sam0, in SdfAndMaterial sam1) {\n    return SdfAndMaterial(\n        sam0.color,\n        difference(sam0.distance, sam1.distance));\n}\n\nfloat dilated(float radius, float d) {\n    return d - radius;\n}\n\nSdfAndMaterial dilated(float radius, SdfAndMaterial sam) {\n    sam.distance = dilated(radius, sam.distance);\n    return sam;\n}\n\nfloat inverted(float d) {\n    return -d;\n}\n\nSdfAndMaterial inverted(in SdfAndMaterial sam) {\n    return SdfAndMaterial(\n        sam.color,\n        inverted(sam.distance));\n}\n\nfloat onion(in float f) {\n    return abs(f);\n}\n\nSdfAndMaterial onion(in SdfAndMaterial sam) {\n    return SdfAndMaterial(\n        sam.color,\n        onion(sam.distance));\n}\n\nfloat point(in vec3 position) {\n    return length(position);\n}\n\nvec3 reflected_x(vec3 p) {\n    return vec3(abs(p.x), p.yz);\n}\n\nvec3 reflected_y(in vec3 p) {\n    p.y = abs(p.y);\n    return p;\n}\n\nvec3 reflected_z(vec3 p) {\n    p.z = abs(p.z);\n    return p;\n}\n\nvec3 rotated_x(float a, vec3 p) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return vec3(\n        p.x,\n        ca * p.y - sa * p.z,\n        sa * p.y + ca * p.z);\n}\n\nvec3 rotated_y(float a, vec3 p) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotated_z(float a, vec3 p) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\nvec3 scaled(float s, vec3 position) {\n    return position / s;\n}\n\nvec3 scaled(vec3 s, vec3 position) {\n    return position / s;\n}\n\nfloat ellipsoid(in vec3 r, in vec3 p) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat intersection(in float d0, in float d1) {\n    return max(d0, d1);\n}\n\nSdfAndMaterial intersection(in SdfAndMaterial sam0, in SdfAndMaterial sam1) {\n    if(sam0.distance < sam1.distance) {\n        return sam1;\n    } else {\n        return sam0;\n    }\n}\n\nfloat line_segment(vec3 a, vec3 b, vec3 p) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat plane(vec3 position) {\n    return abs(position.x);\n}\n\nfloat unionn(in float d0, in float d1) {\n    return min(d0, d1);\n}\n\nSdfAndMaterial unionn(in SdfAndMaterial sam0, in SdfAndMaterial sam1) {\n    if(sam0.distance < sam1.distance) {\n        return sam0;\n    } else {\n        return sam1;\n    }\n}\n\nfloat smooth_union(float k, float d1, float d2) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nSdfAndMaterial smooth_union(float k, in SdfAndMaterial sam0, in SdfAndMaterial sam1) {\n    float d1 = sam0.distance;\n    float d2 = sam1.distance;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return SdfAndMaterial(\n        mix(sam1.color, sam0.color, h),\n        mix(d2, d1, h) - k*h*(1.0-h));\n}\n\nvec3 translated(vec3 translation, vec3 position) {\n    return position - translation;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n//  SDF tree.\n\nfloat roshi_rod_sdf(vec3 position) {\n  return smooth_union(0.2,\n    dilated(0.05,\n      corrected(0.23,\n        corrected(0.1,\n          cube(\n            scaled(vec3(0.1, 0.1, 0.1),\n              scaled(vec3(0.23, 0.24, 0.58),\n                rotated_z(-0.73,\n                  rotated_y(-0.21,\n                    rotated_x(-1.01,\n                      translated(vec3(0.33, 1.01, -0.5),\n                        position)))))))))),\n    smooth_union(0.2,\n      dilated(0.05,\n        corrected(1.59,\n          corrected(0.1,\n            cube(\n              scaled(vec3(0.1, 0.1, 0.1),\n                scaled(vec3(1.76, 1.59, 1.66),\n                  rotated_y(-0.46,\n                    rotated_x(-0.92,\n                      translated(vec3(0.33, 1.19, -0.5),\n                        position))))))))),\n      smooth_union(0.2,\n        dilated(0.05,\n          corrected(1.,\n            corrected(0.1,\n              cube(\n                scaled(vec3(0.1, 0.1, 0.1),\n                  scaled(vec3(1.11, 1, 1.55),\n                    rotated_z(-0.73,\n                      rotated_y(-0.21,\n                        rotated_x(-1.01,\n                          translated(vec3(0.33, 1.43, -0.5),\n                            position)))))))))),\n        corrected(1.,\n          dilated(0.05,\n            line_segment(vec3(0, -1, 0), vec3(0, 1, 0), scaled(vec3(1, 1.08, 1),\n              translated(vec3(0.36, -0.02, -0.46),\n                position))))))));\n}\n\nfloat roshi_shirt_sdf(vec3 position) {\n  return unionn(\n    intersection(\n      inverted(\n        translated(vec3(0.1, 0, 0),\n          position).x),\n      corrected(0.46,\n        intersection(\n          inverted(\n            scaled(vec3(1.14, 1.16, 0.46),\n              translated(vec3(-0.06, 0, 0),\n                position)).y),\n          ellipsoid(vec3(0.65, 2, 1),\n            scaled(vec3(1.14, 1.16, 0.46),\n              translated(vec3(-0.06, 0, 0),\n                position)))))),\n    unionn(\n      corrected(0.1,\n        unionn(\n          corrected(0.34,\n            dilated(1.,\n              point(scaled(vec3(0.86, 0.34, 0.94),\n                translated(vec3(6.2, 1.88, 0),\n                  scaled(vec3(0.1, 0.1, 0.1),\n                    position)))))),\n          unionn(\n            corrected(0.39,\n              dilated(1.,\n                point(scaled(vec3(0.62, 0.39, 1),\n                  translated(vec3(6.15, 4.54, 0),\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      position)))))),\n            unionn(\n              corrected(0.39,\n                dilated(1.,\n                  point(scaled(vec3(0.62, 0.39, 1),\n                    translated(vec3(5.95, 7.06, 0),\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        position)))))),\n              corrected(0.39,\n                dilated(1.,\n                  point(scaled(vec3(0.62, 0.39, 1),\n                    translated(vec3(5.73, 9.51, 0),\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        position)))))))))),\n      smooth_union(0.1,\n        corrected(0.4,\n          dilated(1.,\n            point(scaled(vec3(0.4, 0.4, 0.4),\n              translated(vec3(0, 1.16, 0.58),\n                reflected_z(\n                  position)))))),\n        intersection(\n          inverted(\n            position.y),\n          ellipsoid(vec3(0.65, 2, 1),\n            position)))));\n}\n\nfloat roshi_left_arm_sdf(vec3 position) {\n  return unionn(\n    dilated(0.1,\n      corrected(0.125,\n        cube(\n          scaled(vec3(0.125, 0.13, 0.15),\n            translated(vec3(0, 0.2, 0.92),\n              position))))),\n    unionn(\n      corrected(0.36,\n        dilated(0.2,\n          circle(1.,\n            scaled(vec3(0.38, 0.96, 0.36),\n              translated(vec3(0, 0.33, 0.86),\n                position))))),\n      unionn(\n        dilated(0.1,\n          corrected(0.125,\n            cube(\n              scaled(vec3(0.125, 0.13, 0.15),\n                translated(vec3(0, 0.2, 0.92),\n                  position))))),\n        intersection(\n          inverted(\n            translated(vec3(0, 0.2, 0),\n              position).y),\n          dilated(0.4,\n            line_segment(vec3(0, 1.16, 0.58), vec3(0, 0.27, 0.87), position))))));\n}\n\nfloat roshi_right_arm_sdf(vec3 position) {\n  return unionn(\n    corrected(0.36,\n      dilated(0.2,\n        circle(1.,\n          scaled(vec3(0.36, 1.26, 0.36),\n            rotated_z(-1.68,\n              translated(vec3(0.36, 0.62, -0.94),\n                position)))))),\n    unionn(\n      smooth_union(0.2,\n        dilated(0.1,\n          corrected(0.125,\n            cube(\n              scaled(vec3(0.125, 0.13, 0.15),\n                translated(vec3(0.73, 0.61, -0.9),\n                  position))))),\n        dilated(0.1,\n          line_segment(vec3(0, 0.65, -0.98), vec3(0.67, 0.63, -0.94), position))),\n      intersection(\n        corrected(1.,\n          scaled(vec3(1, 1, 1),\n            translated(vec3(0.47, 0, 0),\n              position)).x),\n        dilated(0.01,\n          onion(\n            unionn(\n              dilated(0.39,\n                line_segment(vec3(0, 0.65, -0.98), vec3(0.37, 0.63, -0.94), position)),\n              dilated(0.39,\n                line_segment(vec3(0, 1.16, -0.58), vec3(0, 0.65, -0.98), position))))))));\n}\n\nfloat roshi_head_sdf(vec3 position) {\n  return unionn(\n    corrected(0.4,\n      smooth_union(0.2,\n        corrected(0.1,\n          corrected(1.,\n            dilated(1.,\n              point(scaled(vec3(1, 1, 1),\n                translated(vec3(9.34, -4.26, 0.25),\n                  reflected_z(\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      scaled(vec3(0.4, 0.4, 0.4),\n                        translated(vec3(0.29, 1.92, 0),\n                          position)))))))))),\n        smooth_union(0.2,\n          corrected(0.1,\n            dilated(1.,\n              line_segment(vec3(10.07, 0.08, 0), vec3(10.59, -4.16, 0), scaled(vec3(0.1, 0.1, 0.1),\n                scaled(vec3(0.4, 0.4, 0.4),\n                  translated(vec3(0.29, 1.92, 0),\n                    position)))))),\n          smooth_union(0.2,\n            corrected(0.7,\n              dilated(0.2,\n                cube(\n                  scaled(vec3(1, 1.05, 0.7),\n                    translated(vec3(0.05, -0.49, 0),\n                      scaled(vec3(0.4, 0.4, 0.4),\n                        translated(vec3(0.29, 1.92, 0),\n                          position))))))),\n            smooth_union(0.2,\n              corrected(0.56,\n                dilated(0.2,\n                  cube(\n                    scaled(vec3(0.9, 0.56, 0.91),\n                      translated(vec3(0.06, -0.13, 0),\n                        scaled(vec3(0.4, 0.4, 0.4),\n                          translated(vec3(0.29, 1.92, 0),\n                            position))))))),\n              smooth_union(0.2,\n                corrected(0.3,\n                  ellipsoid(vec3(1, 1, 0.5),\n                    scaled(vec3(0.3, 0.3, 0.3),\n                      rotated_y(-0.93,\n                        translated(vec3(0, -0.21, 1.07),\n                          reflected_z(\n                            scaled(vec3(0.4, 0.4, 0.4),\n                              translated(vec3(0.29, 1.92, 0),\n                                position)))))))),\n                dilated(1.,\n                  point(scaled(vec3(0.4, 0.4, 0.4),\n                    translated(vec3(0.29, 1.92, 0),\n                      position)))))))))),\n    corrected(0.1,\n      dilated(0.1,\n        unionn(\n          difference(corrected(1.19,\n            dilated(1.,\n              point(scaled(vec3(1.19, 1.24, 1.21),\n                translated(vec3(5.52, 22.04, 1.29),\n                  reflected_z(\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      translated(vec3(0, -0.1, 0),\n                        position)))))))), corrected(1.78,\n            dilated(1.,\n              point(scaled(vec3(2.38, 4.93, 1.78),\n                translated(vec3(7.46, 20.27, 1.28),\n                  reflected_z(\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      translated(vec3(0, -0.1, 0),\n                        position))))))))),\n          unionn(\n            smooth_union(0.3,\n              corrected(0.71,\n                dilated(1.,\n                  point(scaled(vec3(0.71, 1.04, 1.55),\n                    translated(vec3(6.77, 17.21, 0),\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        translated(vec3(0, -0.1, 0),\n                          position))))))),\n              corrected(0.75,\n                cone(vec2(1., 1.),\n                  scaled(vec3(0.75, 3.51, 1.35),\n                    rotated_x(0.64,\n                      translated(vec3(6.81, 13.67, 2.86),\n                        reflected_z(\n                          scaled(vec3(0.1, 0.1, 0.1),\n                            translated(vec3(0, -0.1, 0),\n                              position))))))))),\n            corrected(0.83,\n              cone(vec2(1., 1.),\n                scaled(vec3(0.83, 5.2, 2),\n                  translated(vec3(6.46, 10.32, -0.14),\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      translated(vec3(0, -0.1, 0),\n                        position)))))))))));\n}\n\nfloat roshi_glasses_sdf(vec3 position) {\n  return unionn(\n    corrected(0.1,\n      corrected(0.24,\n        dilated(1.,\n          point(scaled(vec3(0.24, 0.97, 1.24),\n            translated(vec3(7.3, 19.17, 1.83),\n              reflected_z(\n                scaled(vec3(0.1, 0.1, 0.1),\n                  position)))))))),\n    corrected(0.1,\n      smooth_union(0.1,\n        dilated(0.2,\n          line_segment(vec3(2.34, 19.72, 4.31), vec3(7.08, 19.52, 3.26), reflected_z(\n            scaled(vec3(0.1, 0.1, 0.1),\n              position)))),\n        smooth_union(0.1,\n          corrected(0.58,\n            dilated(0.1,\n              line_segment(vec3(0, 0, -1), vec3(0, 0, 1), scaled(vec3(0.58, 2.3, 1.57),\n                translated(vec3(7.3, 19.75, 0),\n                  scaled(vec3(0.1, 0.1, 0.1),\n                    position)))))),\n          corrected(0.23,\n            dilated(1.,\n              point(scaled(vec3(0.23, 1.23, 1.57),\n                translated(vec3(7.18, 19.21, 1.87),\n                  reflected_z(\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      position)))))))))));\n}\n\n// Alright, I got lazy for that one.\nfloat roshi_lower_half_sdf(vec3 position) {\n  return smooth_union(0.2,\n    corrected(0.32,\n      dilated(1.,\n        point(scaled(vec3(0.331, 0.32, 0.36),\n          translated(vec3(-0.03, -0.26, -0.31),\n            position))))),\n    smooth_union(0.2,\n      corrected(0.31,\n        dilated(1.,\n          point(scaled(vec3(0.31, 0.32, 0.36),\n            translated(vec3(0.1, -0.11, 0.36),\n              position))))),\n      unionn(\n        corrected(0.24,\n          intersection(\n            inverted(\n              scaled(vec3(0.51, 0.26, 0.24),\n                rotated_y(0.37,\n                  translated(vec3(0.17, -1.25, 0.3),\n                    reflected_z(\n                      position)))).y),\n            unionn(\n              corrected(0.74,\n                dilated(1.,\n                  point(scaled(vec3(1.29, 0.74, 1.21),\n                    translated(vec3(-0.08, 0.12, 0),\n                      scaled(vec3(0.51, 0.26, 0.24),\n                        rotated_y(0.37,\n                          translated(vec3(0.17, -1.25, 0.3),\n                            reflected_z(\n                              position))))))))),\n              dilated(1.,\n                point(scaled(vec3(0.51, 0.26, 0.24),\n                  rotated_y(0.37,\n                    translated(vec3(0.17, -1.25, 0.3),\n                      reflected_z(\n                        position))))))))),\n        corrected(0.49,\n          dilated(0.2,\n            cone(vec2(1., 1.),\n              scaled(vec3(0.49, 0.94, 0.53),\n                translated(vec3(0.01, -0.88, 0.24),\n                  reflected_z(\n                    position)))))))));\n}\n\nfloat roshi_sdf(vec3 position) {\n  return unionn(\n    roshi_lower_half_sdf(\n      position),\n    unionn(\n      roshi_glasses_sdf(\n        position),\n      unionn(\n        roshi_head_sdf(\n          position),\n        unionn(\n          roshi_right_arm_sdf(\n            position),\n          unionn(\n            roshi_left_arm_sdf(\n              position),\n            unionn(\n              roshi_shirt_sdf(\n                position),\n              corrected(1.,\n                roshi_rod_sdf(\n                  scaled(vec3(1, 1.08, 1),\n                    translated(vec3(0.36, -0.02, -0.46),\n                      position))))))))));\n}\n\nfloat scene_sdf(vec3 position) {\n  return roshi_sdf(\n    vec3(position.y, position.z, -position.x));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// Material tree.\n\nSdfAndMaterial roshi_rod_material(vec3 position) {\n  return SdfAndMaterial(vec3(0.356863, 0.160784, 0.152941),\n    smooth_union(0.2,\n      dilated(0.05,\n        corrected(0.23,\n          corrected(0.1,\n            cube(\n              scaled(vec3(0.1, 0.1, 0.1),\n                scaled(vec3(0.23, 0.24, 0.58),\n                  rotated_z(-0.73,\n                    rotated_y(-0.21,\n                      rotated_x(-1.01,\n                        translated(vec3(0.33, 1.01, -0.5),\n                          position)))))))))),\n      smooth_union(0.2,\n        dilated(0.05,\n          corrected(1.59,\n            corrected(0.1,\n              cube(\n                scaled(vec3(0.1, 0.1, 0.1),\n                  scaled(vec3(1.76, 1.59, 1.66),\n                    rotated_y(-0.46,\n                      rotated_x(-0.92,\n                        translated(vec3(0.33, 1.19, -0.5),\n                          position))))))))),\n        smooth_union(0.2,\n          dilated(0.05,\n            corrected(1.,\n              corrected(0.1,\n                cube(\n                  scaled(vec3(0.1, 0.1, 0.1),\n                    scaled(vec3(1.11, 1, 1.55),\n                      rotated_z(-0.73,\n                        rotated_y(-0.21,\n                          rotated_x(-1.01,\n                            translated(vec3(0.33, 1.43, -0.5),\n                              position)))))))))),\n          corrected(1.,\n            dilated(0.05,\n              line_segment(vec3(0, -1, 0), vec3(0, 1, 0), scaled(vec3(1, 1.08, 1),\n                translated(vec3(0.36, -0.02, -0.46),\n                  position)))))))));\n}\n\nSdfAndMaterial roshi_shirt_material(vec3 position) {\n  return unionn(\n    SdfAndMaterial(vec3(0.870588, 0.780392, 0.780392),\n      intersection(\n        inverted(\n          translated(vec3(0.1, 0, 0),\n            position).x),\n        corrected(0.46,\n          intersection(\n            inverted(\n              scaled(vec3(1.14, 1.16, 0.46),\n                translated(vec3(-0.06, 0, 0),\n                  position)).y),\n            ellipsoid(vec3(0.65, 2, 1),\n              scaled(vec3(1.14, 1.16, 0.46),\n                translated(vec3(-0.06, 0, 0),\n                  position))))))),\n    unionn(\n      SdfAndMaterial(vec3(0.227451, 0.145098, 0.262745),\n        corrected(0.1,\n          unionn(\n            corrected(0.34,\n              dilated(1.,\n                point(scaled(vec3(0.86, 0.34, 0.94),\n                  translated(vec3(6.2, 1.88, 0),\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      position)))))),\n            unionn(\n              corrected(0.39,\n                dilated(1.,\n                  point(scaled(vec3(0.62, 0.39, 1),\n                    translated(vec3(6.15, 4.54, 0),\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        position)))))),\n              unionn(\n                corrected(0.39,\n                  dilated(1.,\n                    point(scaled(vec3(0.62, 0.39, 1),\n                      translated(vec3(5.95, 7.06, 0),\n                        scaled(vec3(0.1, 0.1, 0.1),\n                          position)))))),\n                corrected(0.39,\n                  dilated(1.,\n                    point(scaled(vec3(0.62, 0.39, 1),\n                      translated(vec3(5.73, 9.51, 0),\n                        scaled(vec3(0.1, 0.1, 0.1),\n                          position))))))))))),\n      SdfAndMaterial(vec3(0.8, 0.443137, 0.239216),\n        smooth_union(0.1,\n          corrected(0.4,\n            dilated(1.,\n              point(scaled(vec3(0.4, 0.4, 0.4),\n                translated(vec3(0, 1.16, 0.58),\n                  reflected_z(\n                    position)))))),\n          intersection(\n            inverted(\n              position.y),\n            ellipsoid(vec3(0.65, 2, 1),\n              position))))));\n}\n\nSdfAndMaterial roshi_left_arm_material(vec3 position) {\n  return unionn(\n    SdfAndMaterial(vec3(0.819608, 0.560784, 0.498039),\n      dilated(0.1,\n        corrected(0.125,\n          cube(\n            scaled(vec3(0.125, 0.13, 0.15),\n              translated(vec3(0, 0.2, 0.92),\n                position)))))),\n    unionn(\n      SdfAndMaterial(vec3(0.870588, 0.780392, 0.780392),\n        corrected(0.36,\n          dilated(0.2,\n            circle(1.,\n              scaled(vec3(0.38, 0.96, 0.36),\n                translated(vec3(0, 0.33, 0.86),\n                  position)))))),\n      unionn(\n        SdfAndMaterial(vec3(0.819608, 0.560784, 0.498039),\n          dilated(0.1,\n            corrected(0.125,\n              cube(\n                scaled(vec3(0.125, 0.13, 0.15),\n                  translated(vec3(0, 0.2, 0.92),\n                    position)))))),\n        SdfAndMaterial(vec3(0.8, 0.443137, 0.239216),\n          intersection(\n            inverted(\n              translated(vec3(0, 0.2, 0),\n                position).y),\n            dilated(0.4,\n              line_segment(vec3(0, 1.16, 0.58), vec3(0, 0.27, 0.87), position)))))));\n}\n\nSdfAndMaterial roshi_right_arm_material(vec3 position) {\n  return unionn(\n    SdfAndMaterial(vec3(0.870588, 0.780392, 0.780392),\n      corrected(0.36,\n        dilated(0.2,\n          circle(1.,\n            scaled(vec3(0.36, 1.26, 0.36),\n              rotated_z(-1.68,\n                translated(vec3(0.36, 0.62, -0.94),\n                  position))))))),\n    unionn(\n      SdfAndMaterial(vec3(0.819608, 0.560784, 0.498039),\n        smooth_union(0.2,\n          dilated(0.1,\n            corrected(0.125,\n              cube(\n                scaled(vec3(0.125, 0.13, 0.15),\n                  translated(vec3(0.73, 0.61, -0.9),\n                    position))))),\n          dilated(0.1,\n            line_segment(vec3(0, 0.65, -0.98), vec3(0.67, 0.63, -0.94), position)))),\n      SdfAndMaterial(vec3(0.8, 0.443137, 0.239216),\n        intersection(\n          corrected(1.,\n            scaled(vec3(1, 1, 1),\n              translated(vec3(0.47, 0, 0),\n                position)).x),\n          dilated(0.01,\n            onion(\n              unionn(\n                dilated(0.39,\n                  line_segment(vec3(0, 0.65, -0.98), vec3(0.37, 0.63, -0.94), position)),\n                dilated(0.39,\n                  line_segment(vec3(0, 1.16, -0.58), vec3(0, 0.65, -0.98), position)))))))));\n}\n\nSdfAndMaterial roshi_head_material(vec3 position) {\n  return unionn(\n    SdfAndMaterial(vec3(0.819608, 0.560784, 0.498039),\n      corrected(0.4,\n        smooth_union(0.2,\n          corrected(0.1,\n            corrected(1.,\n              dilated(1.,\n                point(scaled(vec3(1, 1, 1),\n                  translated(vec3(9.34, -4.26, 0.25),\n                    reflected_z(\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        scaled(vec3(0.4, 0.4, 0.4),\n                          translated(vec3(0.29, 1.92, 0),\n                            position)))))))))),\n          smooth_union(0.2,\n            corrected(0.1,\n              dilated(1.,\n                line_segment(vec3(10.07, 0.08, 0), vec3(10.59, -4.16, 0), scaled(vec3(0.1, 0.1, 0.1),\n                  scaled(vec3(0.4, 0.4, 0.4),\n                    translated(vec3(0.29, 1.92, 0),\n                      position)))))),\n            smooth_union(0.2,\n              corrected(0.7,\n                dilated(0.2,\n                  cube(\n                    scaled(vec3(1, 1.05, 0.7),\n                      translated(vec3(0.05, -0.49, 0),\n                        scaled(vec3(0.4, 0.4, 0.4),\n                          translated(vec3(0.29, 1.92, 0),\n                            position))))))),\n              smooth_union(0.2,\n                corrected(0.56,\n                  dilated(0.2,\n                    cube(\n                      scaled(vec3(0.9, 0.56, 0.91),\n                        translated(vec3(0.06, -0.13, 0),\n                          scaled(vec3(0.4, 0.4, 0.4),\n                            translated(vec3(0.29, 1.92, 0),\n                              position))))))),\n                smooth_union(0.2,\n                  corrected(0.3,\n                    ellipsoid(vec3(1, 1, 0.5),\n                      scaled(vec3(0.3, 0.3, 0.3),\n                        rotated_y(-0.93,\n                          translated(vec3(0, -0.21, 1.07),\n                            reflected_z(\n                              scaled(vec3(0.4, 0.4, 0.4),\n                                translated(vec3(0.29, 1.92, 0),\n                                  position)))))))),\n                  dilated(1.,\n                    point(scaled(vec3(0.4, 0.4, 0.4),\n                      translated(vec3(0.29, 1.92, 0),\n                        position))))))))))),\n    SdfAndMaterial(vec3(0.870588, 0.780392, 0.780392),\n      corrected(0.1,\n        dilated(0.1,\n          unionn(\n            difference(corrected(1.19,\n              dilated(1.,\n                point(scaled(vec3(1.19, 1.24, 1.21),\n                  translated(vec3(5.52, 22.04, 1.29),\n                    reflected_z(\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        translated(vec3(0, -0.1, 0),\n                          position)))))))), corrected(1.78,\n              dilated(1.,\n                point(scaled(vec3(2.38, 4.93, 1.78),\n                  translated(vec3(7.46, 20.27, 1.28),\n                    reflected_z(\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        translated(vec3(0, -0.1, 0),\n                          position))))))))),\n            unionn(\n              smooth_union(0.3,\n                corrected(0.71,\n                  dilated(1.,\n                    point(scaled(vec3(0.71, 1.04, 1.55),\n                      translated(vec3(6.77, 17.21, 0),\n                        scaled(vec3(0.1, 0.1, 0.1),\n                          translated(vec3(0, -0.1, 0),\n                            position))))))),\n                corrected(0.75,\n                  cone(vec2(1., 1.),\n                    scaled(vec3(0.75, 3.51, 1.35),\n                      rotated_x(0.64,\n                        translated(vec3(6.81, 13.67, 2.86),\n                          reflected_z(\n                            scaled(vec3(0.1, 0.1, 0.1),\n                              translated(vec3(0, -0.1, 0),\n                                position))))))))),\n              corrected(0.83,\n                cone(vec2(1., 1.),\n                  scaled(vec3(0.83, 5.2, 2),\n                    translated(vec3(6.46, 10.32, -0.14),\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        translated(vec3(0, -0.1, 0),\n                          position))))))))))));\n}\n\nSdfAndMaterial roshi_glasses_material(vec3 position) {\n  return unionn(\n    SdfAndMaterial(vec3(0.0470588, 0.2, 0.0666667),\n      corrected(0.1,\n        corrected(0.24,\n          dilated(1.,\n            point(scaled(vec3(0.24, 0.97, 1.24),\n              translated(vec3(7.3, 19.17, 1.83),\n                reflected_z(\n                  scaled(vec3(0.1, 0.1, 0.1),\n                    position))))))))),\n    SdfAndMaterial(vec3(0.490196, 0.12549, 0.0745098),\n      corrected(0.1,\n        smooth_union(0.1,\n          dilated(0.2,\n            line_segment(vec3(2.34, 19.72, 4.31), vec3(7.08, 19.52, 3.26), reflected_z(\n              scaled(vec3(0.1, 0.1, 0.1),\n                position)))),\n          smooth_union(0.1,\n            corrected(0.58,\n              dilated(0.1,\n                line_segment(vec3(0, 0, -1), vec3(0, 0, 1), scaled(vec3(0.58, 2.3, 1.57),\n                  translated(vec3(7.3, 19.75, 0),\n                    scaled(vec3(0.1, 0.1, 0.1),\n                      position)))))),\n            corrected(0.23,\n              dilated(1.,\n                point(scaled(vec3(0.23, 1.23, 1.57),\n                  translated(vec3(7.18, 19.21, 1.87),\n                    reflected_z(\n                      scaled(vec3(0.1, 0.1, 0.1),\n                        position))))))))))));\n}\n\nSdfAndMaterial roshi_lower_half_material(vec3 position) {\n  return smooth_union(0.2,\n    SdfAndMaterial(vec3(0.219608, 0.203922, 0.494118),\n      corrected(0.32,\n        dilated(1.,\n          point(scaled(vec3(0.331, 0.32, 0.36),\n            translated(vec3(-0.03, -0.26, -0.31),\n              position)))))),\n    smooth_union(0.2,\n      SdfAndMaterial(vec3(0.219608, 0.203922, 0.494118),\n        corrected(0.31,\n          dilated(1.,\n            point(scaled(vec3(0.31, 0.32, 0.36),\n              translated(vec3(0.1, -0.11, 0.36),\n                position)))))),\n      unionn(\n        corrected(0.24,\n          intersection(\n            SdfAndMaterial(vec3(0.819608, 0.560784, 0.498039),\n              inverted(\n                scaled(vec3(0.51, 0.26, 0.24),\n                  rotated_y(0.37,\n                    translated(vec3(0.17, -1.25, 0.3),\n                      reflected_z(\n                        position)))).y)),\n            unionn(\n              SdfAndMaterial(vec3(0.227451, 0.145098, 0.262745),\n                corrected(0.74,\n                  dilated(1.,\n                    point(scaled(vec3(1.29, 0.74, 1.21),\n                      translated(vec3(-0.08, 0.12, 0),\n                        scaled(vec3(0.51, 0.26, 0.24),\n                          rotated_y(0.37,\n                            translated(vec3(0.17, -1.25, 0.3),\n                              reflected_z(\n                                position)))))))))),\n              SdfAndMaterial(vec3(0.819608, 0.560784, 0.498039),\n                dilated(1.,\n                  point(scaled(vec3(0.51, 0.26, 0.24),\n                    rotated_y(0.37,\n                      translated(vec3(0.17, -1.25, 0.3),\n                        reflected_z(\n                          position)))))))))),\n        SdfAndMaterial(vec3(0.219608, 0.203922, 0.494118),\n          corrected(0.49,\n            dilated(0.2,\n              cone(vec2(1., 1.),\n                scaled(vec3(0.49, 0.94, 0.53),\n                  translated(vec3(0.01, -0.88, 0.24),\n                    reflected_z(\n                      position))))))))));\n}\n\nSdfAndMaterial roshi_material(vec3 position) {\n  return unionn(\n    roshi_lower_half_material(\n      position),\n    unionn(\n      roshi_glasses_material(\n        position),\n      unionn(\n        roshi_head_material(\n          position),\n        unionn(\n          roshi_right_arm_material(\n            position),\n          unionn(\n            roshi_left_arm_material(\n              position),\n            unionn(\n              roshi_shirt_material(\n                position),\n              corrected(1.,\n                roshi_rod_material(\n                  scaled(vec3(1, 1.08, 1),\n                    translated(vec3(0.36, -0.02, -0.46),\n                      position))))))))));\n}\n\nSdfAndMaterial scene_material(vec3 position) {\n  return roshi_material(\n    vec3(position.y, position.z, -position.x));\n}\n\nvec3 scene_normal( in vec3 p) {\n  float e = .01;\n  float v = scene_sdf(p);\n  return normalize(vec3(\n    scene_sdf(vec3(p.x + e, p.y, p.z)) - v,\n    scene_sdf(vec3(p.x, p.y + e, p.z)) - v,\n    scene_sdf(vec3(p.x, p.y, p.z + e)) - v));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3XWX.jpg", "access": "api", "license": "mit", "functions": [[2938, 2995, 3019, 3019, 3059], [3061, 3081, 3121, 3121, 3356], [3358, 3404, 3428, 3428, 3509], [3511, 3602, 3657, 3657, 3927], [4119, 4224, 4288, 4288, 5096], [5098, 5171, 5216, 5216, 5506], [5508, 5528, 5554, 5554, 5624], [5626, 5626, 5654, 5671, 5981], [5983, 5983, 6023, 6023, 6411], [6413, 6474, 6501, 6501, 6622], [6776, 6871, 6909, 6932, 7314], [7316, 7325, 7369, 7396, 8207]], "test": "untested"}
{"id": "7d3SWB", "name": "Water Bottle Shape", "author": "orangeflea215", "description": "Testing rendering equations/camera setup/sdf construction/etc", "tags": ["renderer"], "likes": 8, "viewed": 330, "published": 3, "date": "1634048629", "time_retrieved": "2024-07-30T18:56:30.174275", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n#define SAMPLES 1\n#define ZERO (min(iFrame,0))\n\nfloat PI = 3.14159;\nint maxSteps = 256;\nfloat minStepSize = 0.0001;\nfloat e = .0001;\n\nfloat shadowBias = .005;\n\n//Point light\n//Intensity at distance of 1 unit\nfloat lInt = 10.0;\nvec3 lCol = vec3(0.2, 1.0, 0.0);\nvec3 lPos = vec3(-2.0, 2.0, -2.0);\n\n//Point light 2\n//Intensity at distance of 1 unit\nfloat lInt2 = 10.0;\nvec3 lCol2 = vec3(1.0, 0.2, 0.0);\nvec3 lPos2 = vec3(2.0, 2.0, -2.0);\n\n//Ambient light\nvec3 ambCol = vec3(0.2,0.2,0.2);\n\n//Camera\nfloat fov = 50.0 * 2.0 * 3.14159/360.0;\nvec3 camPos = vec3(0.0, 3.0, -9.0);\nvec3 camTar = vec3(0.0, 1.0, 0.0);\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//SDFs\n\n//Sphere\n\nfloat sphereSDF(float d, float r){\n    return d - r;\n}\n\n//Plane\nfloat planeSDF(vec3 d, float l, float w){\n    return max(abs(d.x) - w/2.0,0.0) + max(abs(d.z) - l/2.0,0.0) + abs(d.y);\n}\n\nfloat roundedCylinderSDF (vec3 p, float ra, float rb, float h){\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat cylinderSDF (vec3 p, float ra, float h){\n    vec2 d = vec2( length(p.xz)-2.0*ra, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n//Map function\nvec3 map(vec3 pos){\n    vec3 result = vec3(10000000000.0,0.0,0.0);\n    float res = 0.0;\n    \n    //    //res = sphereSDF(length(pos - vec3(0.0,0.0,0.0)), 1.00);\n    res = roundedCylinderSDF(pos - vec3(0.0,-0.8,0.0), .3, .1, .05);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    //    //res = sphereSDF(length(pos - vec3(0.0,0.0,0.0)), 1.00);\n    res = roundedCylinderSDF(pos - vec3(0.0,-.5,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    //    //res = sphereSDF(length(pos - vec3(0.0,0.0,0.0)), 1.00);\n    res = roundedCylinderSDF(pos - vec3(0.0,-.2,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    res = roundedCylinderSDF(pos - vec3(0.0,.1,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = roundedCylinderSDF(pos - vec3(0.0,.4,0.0), .3, .1, .050);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = cylinderSDF(pos - vec3(0.0,1.0,0.0), .280, .550);\n    res = abs(res) - .01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n     \n   /* res = roundedCylinderSDF(pos - vec3(0.0,1.6,0.0), .3, .1, .050);\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 1.0;\n    }\n    */\n    res = sdRoundCone(pos - vec3(0.0,1.70,0.0), .6, .4, .45);\n    res = abs(res) -.01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = cylinderSDF(pos - vec3(0.0,2.55,0.0), .1250, .08);\n    res = abs(res) - .01;\n    result.x = min(result.x, res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    res = cylinderSDF(pos - vec3(0.0,2.55,0.0), .120, .175);\n    //res = abs(res) - .01;\n    result.x = max(result.x, -res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = planeSDF(pos - vec3(0.0,-1.0, 0.0), 5.0, 5.0);\n    result.x = min(res, result.x);\n    if(res <= e){\n        result.y = 2.0;\n    }\n    \n    res = cylinderSDF(pos - vec3(0.0,.5,0.0), .275, 1.3);\n   // res = abs(res) - .01;\n    result.x = max(result.x, -res);\n    if(res <= e){\n        \n        result.y = 3.0;\n    }\n    \n    return result;\n}\n\n//Normals\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.00001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//Raymarching function\n//Accepts ray origin and direction\n//Returns intersected position\nvec4 rayMarch(vec3 ro, vec3 rd, int steps){\n    if(steps == 0){\n        steps = maxSteps;\n    }\n    vec3 pos = ro;\n    float dist = (-1.0);\n    vec3 distRes = vec3(0.0,0.0,0.0);\n    for (int i = 0; i < steps; i++){\n        //run sdf\n        //step size is always half of distance\n        distRes = map(pos);\n        dist = distRes.x;\n\n        if(dist < e && dist > 0.0) {\n            pos = pos + rd * dist; \n            if(i < 5){\n            \n                distRes.y = 4.0;\n            \n            }\n            break;\n        }\n        else if(dist < 0.0){\n            \n        }\n        \n        if(dist < minStepSize){\n            dist = minStepSize;\n            \n        }\n        else{\n            dist = dist / 2.0;\n            \n            //return vec4(dist,0.0,0.0,0.0);\n        }\n        pos = pos + rd * dist;\n    }\n    \n    return vec4(pos, distRes.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    \n    float uvFocLen = 0.5 / tan(fov/2.0);\n    float scaleFac = 1.0/uvFocLen;\n    \n    vec2 uvFOV = (uv - vec2(0.5))*scaleFac;\n    \n    \n    vec3 camSpaceUVDir = normalize(vec3(uvFOV.x, uvFOV.y/aspect, 1.0));\n    \n    mat3 ca = setCamera(camPos, camTar, 0.0);\n    \n    vec3 rayDir = ca * camSpaceUVDir;\n    \n    vec4 res = rayMarch(camPos, rayDir, 0);\n    \n    vec3 col = vec3(0.0);\n    if(res.w > 0.0){\n    // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        \n        //Normal as color\n        vec3 normal = calcNormal(res.xyz, length(camPos - res.xyz));\n        col = normal;\n        \n        \n        \n        //Calculate light intensity given square falloff\n        float dist = length(lPos - res.xyz) ;\n        float pointInt = lInt / pow(max(dist, 1.0) , 2.0);\n        vec3 colInt = lCol * pointInt;\n        \n        \n        \n        //Shadow for light 1\n        vec3 shadRayDir = normalize(lPos - res.xyz);\n        vec4 shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n        \n        if(shadRes.w > 0.0){\n            colInt = vec3(0.0,0.0,0.0);\n        }\n        \n        //Calculate specular light intensity\n        //Reflected ray for specular\n        vec3 reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n        float reflInt = max(dot(reflRay, rayDir), 0.0);\n        \n        \n        //point light 2\n        float dist2 = length(lPos2 - res.xyz) ;\n        float pointInt2 = lInt2 / pow(max(dist2, 1.0) , 2.0);\n        vec3 colInt2 = lCol2 * pointInt2;\n        \n        //Shadow for light 2\n        shadRayDir = normalize(lPos2 - res.xyz);\n        shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n        if(shadRes.w > 0.0){\n            colInt2 = vec3(0.0,0.0,0.0);\n        }\n        \n         //Calculate specular light intensity\n        //Reflected ray for specular\n        reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n        float reflInt2 = max(dot(reflRay, rayDir),0.0);\n        \n       \n        vec3 surfCol = vec3(1.0,1.0,1.0);\n        \n        if(res.w == 4.0){\n            surfCol = vec3(0.0,1.0,0.0);\n        }\n        \n        if(res.w == 1.0){\n            \n            //Assume white sphere surface, for now\n            surfCol = vec3(1.0,1.0,1.0);\n        }\n        else if(res.w == 2.0){\n            //White ground plane\n            surfCol = vec3(1.0,1.0,1.0);\n        }\n        else if(res.w == 3.0){\n            //Compute Refraction\n            //Fraction of light reflected vs refracted given IOR -- lets try 1.45 for plastic bottle\n            //try 4 refractions\n            //loop -- have incident ray dir, normal, IOR -- don't worry about transparent shadows for now\n            //compute fraction of light reflected vs refracted\n            //compute specular light at each point, multiply by percent reflected\n            //for reflected light, multiply colInt and reflInt by amount reflected\n            //raymarch to next point, comput ray dir, normal, ior\n            //if ray count exceeded and no surface found, compute light at final point and exit\n           \n           surfCol = vec3(1.0,1.0,1.0);\n           vec3 calcCol = vec3(0.0,0.0,0.0);\n           float refrInd1 = 1.0;\n           float refrInd2 = 1.5;\n           \n           float reflFrac = 1.0;\n           float transFrac = 0.0;\n           \n           vec3 specRefInt = vec3(0.0);\n           \n           float cosAngle = dot(normal, -1.0 * rayDir);\n           float angle = acos(cosAngle);\n           \n           vec3 transDir = vec3(0.0,0.0,0.0);\n           float transPow = 1.0;\n           \n           vec4 resT = res;\n          \n           int numRefr = 6;\n           for (int j = 0; j < numRefr; j++){\n               \n               reflFrac = pow(abs( (refrInd1*cosAngle - refrInd2 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))/(refrInd1*cosAngle + refrInd2 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))), 2.0);\n               //reflFrac = 0.5 * (reflFrac + pow(abs( (-1.0*refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))/(refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))), 2.0));\n\n               //Use schlick instead\n              // float r0 = pow((refrInd1 - refrInd2)/(refrInd1 + refrInd2), 2.0);\n               //reflFrac = r0 + (1.0 - r0)*pow(1.0 - cosAngle, 5.0);\n              // reflFrac *= 1.0;\n               transFrac = 1.0 - reflFrac;\n               \n               specRefInt = surfCol * pow(reflInt, 5.0) * colInt * reflFrac;        \n               specRefInt += surfCol * pow(reflInt2,5.0) * colInt2 * reflFrac;\n               if(j == 0){\n                   specRefInt += surfCol * vec3(0.5,0.5,0.5) * reflFrac;\n               }\n               \n               calcCol += max(specRefInt * transPow, 0.0);\n               //calcCol = resT.xyz + vec3(0.0, 0.0,0.0);\n               //calcCol = transDir;\n              /* if(resT.w == 4.0){\n                   calcCol = vec3(1.0, 0.0,0.0);\n                   break;\n               }*/\n               \n               \n               \n               if(resT.w == 0.0){\n                  calcCol += transPow *  vec3(0.5,0.5,0.5);\n                 // calcCol = vec3(1.0);\n                  break;\n               }\n               \n               else if (resT.w == 2.0){\n                   //Compute diffuse\n                    vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - resT.xyz)), 0.0);\n                    difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - resT.xyz)), 0.0);\n                    calcCol += transPow * difReflInt;\n                    break;\n               }\n               \n               if(j == numRefr - 1){\n                   break;\n               }\n               transPow *= transFrac;\n               \n               //surfCol = surfCol * reflFrac;\n               transDir = normalize((refrInd1/refrInd2) * rayDir + ((refrInd1/refrInd2) * cosAngle - sqrt(1.0 - pow(refrInd1 / refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0)))) * normal);\n               //transDir = normalize(sqrt(1.0 - pow(refrInd1/refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0))) * normal + (refrInd1/refrInd2) * (rayDir - cosAngle * normal));\n              // transDir = (refrInd1/refrInd2) * (rayDir - cosAngle * normal)  + sqrt(1.0 - pow(length((refrInd1/refrInd2) * (rayDir - cosAngle * normal)), 2.0)) * normal;\n\n               vec3 oldPos = resT.xyz;\n               resT = rayMarch(resT.xyz + 80.0 * e * transDir, transDir,256);\n               \n               //Normal\n               normal = calcNormal(resT.xyz, length(camPos - resT.xyz));\n               //col = normal;\n\n                //Calculate light intensity given square falloff\n                dist = length(lPos - resT.xyz) ;\n                pointInt = lInt / pow(max(dist, 1.0) , 2.0);\n                colInt = lCol * pointInt;\n\n\n                //Calculate specular light intensity\n                //Reflected ray for specular\n                shadRayDir = normalize(lPos - resT.xyz);\n                reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                reflInt = max(dot(reflRay, transDir), 0.0);\n\n\n                //point light 2\n                dist2 = length(lPos2 - resT.xyz) ;\n                pointInt2 = lInt2 / pow(max(dist2, 1.0) , 2.0);\n                colInt2 = lCol2 * pointInt2;\n\n                 //Calculate specular light intensity\n                //Reflected ray for specular\n                shadRayDir = normalize(lPos2 - resT.xyz);\n                reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                reflInt2 = max(dot(reflRay, transDir),0.0);\n        \n                float temp = refrInd1;\n                refrInd1 = refrInd2;\n                refrInd2 = temp;\n                \n                float j_float = float(j);\n                normal *= 1.0 - 2.0 * mod(j_float + 1.0, 2.0);\n\n                cosAngle = dot(normal,-1.0 * transDir);\n                angle = acos(cosAngle);\n\n                rayDir = transDir;\n           }\n           \n           \n           col = calcCol * 1.0;\n           //col = vec3(1.0);\n           \n        }\n        \n        //BRDF\n        vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - res.xyz)), 0.0);\n        difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - res.xyz)), 0.0);\n        vec3 specRefInt = surfCol * pow(reflInt, 10.0) * colInt;        \n        specRefInt += surfCol * pow(reflInt2, 10.0) * colInt2;\n        if(res.w != 3.0){\n            col = surfCol * ambCol + 0.8 * difReflInt + 0.2 * specRefInt;\n            //col = vec3(1.0);\n        }\n        else{\n            //col += surfCol * ambCol;\n        }\n    }\n    else{\n        col = vec3(0.5,0.5,0.5);\n    }\n\n    //gamma\n    col = sqrt(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3SWB.jpg", "access": "api", "license": "mit", "functions": [[1753, 1753, 1805, 1805, 1982], [2002, 2002, 2036, 2036, 2056], [2058, 2066, 2107, 2107, 2186], [2188, 2188, 2251, 2251, 2372], [2374, 2374, 2420, 2420, 2533], [2535, 2535, 2593, 2593, 2857], [2859, 2874, 2893, 2893, 5377], [5390, 5436, 5478, 5478, 6036], [6038, 6127, 6170, 6170, 6997], [7001, 7001, 7058, 7108, 16151]], "test": "untested"}
{"id": "7dcSWX", "name": "入门之路-2", "author": "jialouluo", "description": "在入门一的基础上扩展了一部分。", "tags": [], "likes": 2, "viewed": 206, "published": 3, "date": "1634047442", "time_retrieved": "2024-07-30T18:56:31.124734", "image_code": "vec3 getcolor(float ang) {\n    //传入进来的是一个角度值 我们需要将他进行一定的运算来使得他成为我们需要的结果，这里可以根据自己喜好\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2));\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2)  + iTime );//有 iTime\n        //return .5 + .5 * cos(6.28 * (ang + vec3(0., .33, .67)));\n        return .5 + .5 * cos(6.28 * (ang/6.28 + vec3(0., .33, .67)));//6.28 约等于2Π\n    }\nvec2 getCir(float k,float ant,float dis){//注释掉颜色代码 记得将返回值改为float\n/**\n本人也才刚开始学 ，有不对的一些地方或者理解错误的地方，也希望路过的大佬不吝赐教QAQ\n*/\n    float ir = 2.0*fract((iTime*0.2 + k));//内环半径，将半径区间改变为0-2.0\n    float or = 2.2*fract((iTime*0.2 + k));//外环半径，将半径区间改变为0-2.2\n    //解释一下里面的一些数字的含义 2.0 ,2.2已经解释了\n    //0.2代表圆环的扩展速度 可以改变大小观察圆环的扩展速度\n    float c =0.0;\n    \n    if(max(dis,or)==or){\n        c = smoothstep(ant,-ant,dis-or);\n    }\n    if(max(dis,ir)==ir){\n        c = smoothstep(ant,-ant,abs(dis-ir) );\n    }\n     //return c;\n    //下面的代码是赋色代码，与生成环纹无关\n    float a =1.0;\n    if(max(dis,or)==or){//可以与上面的if块合并 这里分出来是为了区分\n        a = (dis-ir)/(or-ir);//这里分母是圆环有色的范围值，分子依靠着dis与内圈半径的差 差越大表示越不应该被隐藏，以此来实现向内圈虚化\n        //如果你有兴趣 不妨将ir改成or，这时会向外圈虚化\n    }\n    else{\n        a =1.0;\n    }\n    \n    return vec2(c,a*c);//返回值这次设置为一个vec2因为我们需要a的值，当然记得给a乘上c(c除开平滑部分值 只有0，1这可以代表着那些地方需要a的颜色)\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    //uv-=0.5;\n    //uv.x*=(iResolution.x/iResolution.y);//初始时x轴为0到2y轴为0到1,减去0.5计算之后为x轴-1到1 y轴为-0.5到0.5\n    //在查看其他大佬分享的案例中 有另外一种也可以使得长宽比例为1\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;//我们这次选用这种计算方式来使得uv.x处于-1-->1 uv.y也处于-1-->1\n    float dis = length(uv);\n    //今天我们来实现一种动态的圆环波，类似于往水中仍一块石头之后水面出现的那种波纹(当然目前是二维的 TAT~);\n    //首先让我们先写出生成圆环的代码（具体可以参考我的入门一）\n    //float ir =0.2;//内环半径\n    //float or =0.4;//外环半径\n    //这次我们将上次提到的抗锯齿代码加入进来\n    //float antialias = fwidth(dis);//这里内嵌了一个abs所以antialias是正数，偏导宽的具体定义可以先去搜搜，毕竟定义还是得官方说得更清楚详细\n    //float c =0.0;\n    //if(max(dis,or)==or){\n    //    c = smoothstep(antialias,-antialias,dis-or);\n    //}\n    //if(max(dis,ir)==ir){\n    //    c = smoothstep(antialias,-antialias,abs(dis-ir));\n    //}\n    //这次我改了一下，可以正确的调整内环和外环的半径了\n    //下面我们来尝试去实现环波\n    //初步我们可以看作内环和外环都同时被放大，然后新的圆环被生成然后新圆环的内外环又被放大，如此循环下去\n    //下面我们来尝试一下(需要使用到iTime)\n    //让我们来重写11-21行代码,为了后面的效果，这里我们不妨将他封装为一个函数；\n    //float antialias = fwidth(dis);//偏导宽作为参数传入，与之一起传入的还有距离\n    //float c = getCir(0.0,antialias,dis);//第一个参数类似于偏移量(作用是让圆环在生成时处在不同的位置)\n    //c+= getCir(0.4,antialias,dis);//这里为什么 c要加后面的每一个呢，因为我们fragColor里面依靠c来赋色\n    //c+= getCir(0.8,antialias,dis);//同时，如果当区域1(理解为圆环一)的返回值为1的话并且区域2的返回值1，如果不相加，仅取区域1的返回值\n    //c+= getCir(1.2,antialias,dis);//就会导致c的值仅取决于区域1的值 在区域1里的处在区域2返回值为1的区域会被赋值为0给c\n    //c+= getCir(1.6,antialias,dis);//所以我们需要将两个区域的值进行相加 可以理解为求交集 这样就会让我们每个区域的值被正确得赋值给c\n    //到这里我们已经生成了具有黑白颜色的环纹了，接下来我们需要给他赋色;\n    //让我们试试昨天的颜色代码，看看他会有什么效果，当然这些代码应该被写在函数里，或者根据个人需求作为一个参数传入;\n    //使用 atan(uv.y,uv.x)是常用的求uv角度的方法\n    //float angle  =atan(uv.y,uv.x);\n    //vec3 Color = getcolor(angle);\n    //Color = Color *c;\n    //观察效果 感觉似乎还不错(对于我这个萌新来说~);\n    //接下来 我们为什么不给他旋转起来呢;\n    //Color = Color * fract(angle/6.28 - iTime);\n    //看起来 似乎旋转过一统一了，让我们再给他加点偏移量，重写67行代码\n    //Color = Color * fract(angle/6.28 - iTime *0.1 + cos(dis)  );//这里的0.1控制颜色旋转的速度\n    //就先这样吧，我们来实现另外一种效果，代码在22行之后,并且重写63行之后的代码\n    float antialias = fwidth(dis);//偏导宽作为参数传入，与之一起传入的还有距离\n    vec2 c = getCir(0.0,antialias,dis);//第一个参数类似于偏移量(作用是让圆环在生成时处在不同的位置)\n    c+= getCir(0.4,antialias,dis);//这里为什么 c要加后面的每一个呢，因为我们fragColor里面依靠c来赋色\n    c+= getCir(0.8,antialias,dis);//同时，如果当区域1(理解为圆环一)的返回值为1的话并且区域2的返回值1，如果不相加，仅取区域1的返回值\n    c+= getCir(1.2,antialias,dis);//就会导致c的值仅取决于区域1的值 在区域1里的处在区域2返回值为1的区域会被赋值为0给c\n    c+= getCir(1.6,antialias,dis);//所以我们\n    vec3 Color = vec3(c[1]* 0.3,c[1]* 0.5,c[1] * 0.6)*c[1];\n    fragColor = vec4(Color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 380, 475], [476, 476, 517, 699, 1886], [1887, 1887, 1944, 2225, 6243]], "test": "untested"}
{"id": "Nd3SWX", "name": "Retro CRT Effect 2", "author": "lambmeow", "description": "experimenting with more retro effects", "tags": ["retro", "sdf", "effect", "crt", "glow"], "likes": 8, "viewed": 550, "published": 3, "date": "1634021580", "time_retrieved": "2024-07-30T18:56:32.107107", "image_code": "void mainImage( out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = f/r;\n    u.x += sin(iTime + u.y * r.y) * tan(iTime * u.y * 100.) * sin(u.y + iTime) * 0.007;\n    float rr = texture(iChannel0, u + vec2(sin(iTime + u.y * 200.) * length(u - 0.5) * 0.07 , 0.0)).r;\n    float gg = texture(iChannel0, u).g;\n    float bb = texture(iChannel0, u + vec2(sin(iTime + u.y * 200. ) * length(u - 0.5) * 0.05 , 0.0)).b;\n    \n    \n    c = vec4(rr,gg,bb,1.0) * 1.4;\n    \n    \n    \n\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = ((2.0 *f.xy - r))/r.y;\n    vec3 rd = normalize(vec3(u, 2.0));\n    vec3 ro = vec3(0,0,-10);\n   \n    float ll = 0.0;\n    float cl = 50.;\n    \n    for(int i = 0; i < 255; i++)\n    {\n        vec3 p = ro + rd * ll;\n        p.xz *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n        vec3 q = abs(p) - vec3(1,2,.001);\n        float dd = max(-clamp(sin(iTime + u.y *10.),0.,1.), length(max(q, 0.0)) - min(max(q.x, max(q.y, q.z)), 0.0));\n        \n        cl = min(dd, cl);\n\n        ll += dd;\n        \n        if(abs(dd) < .01 || ll > 50.)\n            break;       \n    }\n    \n    vec2 dd =vec2(ll,cl);\n   \n  // dd.y -= sin(dd.x+ iTime);\n   \n    float gg = 1./(1.+ dd.y);\n   // gg += abs(cos(iTime + u.y * dd.y)) * 0.1;\n    \n    vec3 col = vec3(1, 0, 1) * u.y + vec3(0.4, .2, 1) * (1.-u.y); \n    \n    c = vec4(col * gg, 1);\n    \n    c *= step(0.001, dd.x) * sin(iTime + u.y * r.y); \n   \n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3SWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 476]], "test": "untested"}
{"id": "sstSD2", "name": "Fork pentagonal tiling variation", "author": "alvarobyrne", "description": "Same as original: Click and drag to set vertex position. \n\nInspired by [url]https://twitter.com/cs_kaplan[/url]. See [url]https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling[/url] for details.", "tags": ["tiling", "pentagonal", "variations", "cairo"], "likes": 9, "viewed": 275, "published": 3, "date": "1634012917", "time_retrieved": "2024-07-30T18:56:32.963816", "image_code": "//////////////////////////////////////////////////////////////////////\n//original at https://www.shadertoy.com/view/fs3SWj\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//     https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//     https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//     https://www.shadertoy.com/view/ltBBzK\n//     (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 10.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    lcoord = vec2(-10.0);\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 10.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    //lpos=vec3(1.,0.0,-10.00);\n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );\n    hgrad = vec2(0.5/h);\n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color;\n    color = CELL_COLORS[cell];\n    color= vec3(1.);\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    //color = vec3(0.5);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R;\n    R=reflect(L, N);\n    R= vec3(1.0);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0., 10./iResolution.y, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSD2.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1128, 1164, 1183, 1183, 1213], [1215, 1268, 1300, 1300, 1355], [1357, 1410, 1444, 1444, 1499], [1501, 1540, 1576, 1576, 1742], [1744, 1763, 1807, 1807, 1887], [1889, 1910, 1960, 1960, 2049], [2051, 2120, 2142, 2197, 2549], [2551, 2597, 2623, 2623, 3018], [4274, 4301, 4325, 4354, 4973], [4975, 4993, 5050, 5088, 9594]], "test": "untested"}
{"id": "ssdSW2", "name": "danza", "author": "nictemeral", "description": "lenta danza de grillas que no encajan", "tags": ["light", "color", "blue", "luz", "azul"], "likes": 5, "viewed": 253, "published": 3, "date": "1634005747", "time_retrieved": "2024-07-30T18:56:33.829502", "image_code": "\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 map(vec2 value, vec2 min1, vec2 max1, vec2 min2, vec2 max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 map(vec2 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {\n  return min2 + ((value.s+value.t)/2.0 - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvec2 rotate2d(vec2 _st, float _angle){\n  _st -=0.5;\n  _st = mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    _st +=0.5;\nreturn _st;\n}\n\n#define PI 3.14159235669\n\n#define TAU PI*2\n\n\nvec2 latice_id(in vec2 st,float div){\n    vec2 uv=st;\n    uv*=div;\n    return floor(uv);\n}\nvec2 latice_map(in vec2 st,float div,vec2 min,vec2 max){\n    vec2 uv=st;\n    uv*=div;\n    return map(floor(uv),vec2(0.0),vec2(7.0),vec2(min),vec2(max));\n}\nfloat latice_f(in vec2 st,float div){\n    vec2 uv=st;\n    uv*=div;\n    uv=floor(uv);\n    return (uv.s+uv.t)/2.0;\n}\nfloat lf_map(in vec2 st,float div,float min,float max){\n    vec2 uv=st;\n    uv*=div;\n    uv= map(floor(uv),vec2(0.0),vec2(7.0),vec2(min),vec2(max));\n    return (uv.s+uv.t)/2.0;\n}\nfloat lf_cmap(in vec2 st,float div,float min,float max){\n    vec2 uv=st-vec2(.50);\n    uv*=div;\n    uv=abs(uv);\n    uv=floor(uv)/div;\n    uv= map(uv,vec2(0.0),vec2(1.0),vec2(min),vec2(max));\n    return (uv.s+uv.t);\n}\nfloat lf(in vec2 st,float div,float min,float max){\n    vec2 uv=st-vec2(.50);\n    uv*=div;\n    uv=abs(uv);\n    uv=floor(uv)/div;\n    return (uv.s+uv.t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n   vec2 uv=st;\n   vec2 st2=st;\n    st*=7.0;\n    st.s+=abs(sin(iTime*-0.1));\n    \n    vec2 ipos = floor(st);  // get the integer coords\n    vec2 fpos = fract(st);  // get the fractional coords\n\n    \n    //usando color\n    \n    ipos = map(ipos,vec2(0.0),vec2(7.0),vec2(0.350,0.410),vec2(0.610,0.710));\n    \n    vec3 color = vec3(ipos.s*ipos.t);\n    \n     ipos = map(ipos,vec2(0.0),vec2(7.0),vec2(0.570,0.620),vec2(0.690,0.780));\n\t\n    \n     color.r = vec3(ipos.s*ipos.t).r;\n    \n    ipos = map(ipos,vec2(0.0),vec2(7.0),vec2(0.260,0.370),vec2(0.980,0.900));\n\t\n    \n     color.g += vec3(ipos.s*ipos.t).g;\n    \n    ipos = map(ipos,vec2(0.0),vec2(7.0),vec2(0.220,0.590),vec2(0.680,0.900));\n\t\n     color.b += vec3(ipos.s*ipos.t).b;\n    \n    \n        st2*=12.0;\n        st2.s+=abs(sin(iTime*0.356));\n        st2.t+=abs(sin(iTime*0.164));\n\n     ipos = floor(st2);\n    ipos = map(ipos,vec2(0.0),vec2(9.0),vec2(0.330,0.510),vec2(0.830,0.630));\n\t\n    color += vec3(ipos.s*ipos.t);\n     color.b += vec3(ipos.s*ipos.t).b;\n\n\n\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 145], [147, 225, 251, 251, 631], [634, 634, 706, 706, 772], [774, 774, 840, 840, 906], [908, 908, 974, 974, 1056], [1059, 1059, 1097, 1097, 1212], [1259, 1259, 1296, 1296, 1349], [1350, 1350, 1406, 1406, 1504], [1505, 1505, 1542, 1542, 1619], [1620, 1620, 1675, 1675, 1798], [1799, 1799, 1855, 1855, 2015], [2016, 2016, 2067, 2067, 2170], [2171, 2171, 2228, 2278, 3361]], "test": "untested"}
{"id": "7ddSW2", "name": "luces", "author": "nictemeral", "description": "shader jugando con varias superposiciones de de color", "tags": ["light", "color", "fract", "id"], "likes": 4, "viewed": 218, "published": 3, "date": "1634005663", "time_retrieved": "2024-07-30T18:56:34.751038", "image_code": "\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 map(vec2 value, vec2 min1, vec2 max1, vec2 min2, vec2 max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 map(vec2 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {\n  return min2 + ((value.s+value.t)/2.0 - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvec2 rotate2d(vec2 _st, float _angle){\n  _st -=0.5;\n  _st = mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    _st +=0.5;\nreturn _st;\n}\n\n#define PI 3.14159235669\n\n#define TAU PI*2\n\n\nvec2 latice_id(in vec2 st,float div){\n    vec2 uv=st;\n    uv*=div;\n    return floor(uv);\n}\nvec2 latice_map(in vec2 st,float div,vec2 min,vec2 max){\n    vec2 uv=st;\n    uv*=div;\n    return map(floor(uv),vec2(0.0),vec2(7.0),vec2(min),vec2(max));\n}\nfloat latice_f(in vec2 st,float div){\n    vec2 uv=st;\n    uv*=div;\n    uv=floor(uv);\n    return (uv.s+uv.t)/2.0;\n}\nfloat lf_map(in vec2 st,float div,float min,float max){\n    vec2 uv=st;\n    uv*=div;\n    uv= map(floor(uv),vec2(0.0),vec2(7.0),vec2(min),vec2(max));\n    return (uv.s+uv.t)/2.0;\n}\nfloat lf_cmap(in vec2 st,float div,float min,float max){\n    vec2 uv=st-vec2(.50);\n    uv*=div;\n    uv=abs(uv);\n    uv=floor(uv)/div;\n    uv= map(uv,vec2(0.0),vec2(1.0),vec2(min),vec2(max));\n    return (uv.s+uv.t);\n}\nfloat lf(in vec2 st,float div,float min,float max){\n    vec2 uv=st-vec2(.50);\n    uv*=div;\n    uv=abs(uv);\n    uv=floor(uv)/div;\n    return (uv.s+uv.t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n  // st.x *= iResolution.x/iResolution.y;\n   vec2 uv=st;\n   vec2 st2=st;\n    st*=7.0;\n    st.s+=abs(sin(iTime*-0.1));\n    \n    vec2 ipos = floor(st);  // get the integer coords\n    vec2 fpos = fract(st);  // get the fractional coords\n\n    \n\n    st2=uv;\n   vec3  color = vec3(lf_cmap(vec2(st2.s,st2.t),50.,.25,0.75));\n    color.r+= lf_cmap(vec2(st2.s,-1.*st2.t+sin(iTime*.5)*01.5+01.5),15.,.0,0.5)/2.;\n    color.g+= lf_cmap(vec2(-1.*st2.s,st2.t+cos(iTime*.25+1.)*0.7+0.7),9.,.0,0.5)/3.;\n   color.b+= lf_cmap(vec2(st2.s,-1.*st2.t+sin(iTime*.5+sin(iTime*.5))*01.5+01.5),12.,.0,0.5)/2.;\n   // color.g+= lf_cmap(vec2(-1.*st2.s,st2.t+cos(u_time*.25+1.)*0.7+0.7),8.,.0,0.5)/3.;\n\n    \n    \n    //para recortar areas puede ser util\n   // color=clamp(color,vec3(0.675,0.675,0.675),vec3(0.450*abs(cos(u_time*0.01))+.90));\n     //color-=0.5;\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 145], [147, 225, 251, 251, 631], [634, 634, 706, 706, 772], [774, 774, 840, 840, 906], [908, 908, 974, 974, 1056], [1059, 1059, 1097, 1097, 1212], [1259, 1259, 1296, 1296, 1349], [1350, 1350, 1406, 1406, 1504], [1505, 1505, 1542, 1542, 1619], [1620, 1620, 1675, 1675, 1798], [1799, 1799, 1855, 1855, 2015], [2016, 2016, 2067, 2067, 2170], [2171, 2171, 2228, 2278, 3181]], "test": "untested"}
{"id": "sstSW2", "name": "worker -2d", "author": "jorge2017a2", "description": "worker -2d", "tags": ["worker2d"], "likes": 6, "viewed": 187, "published": 3, "date": "1634005076", "time_retrieved": "2024-07-30T18:56:35.626697", "image_code": "///worker 2d-JFP\n///por jorge2017a2...2021-oct-11\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n\nvec3 ojo(vec2 p, vec3 col)\n{\n    float posOjox=1.0;\n    float d1izq= sdUnevenCapsule( p-vec2(-posOjox,1.2), 0.7, 0.7, 0.7 );\n    float db1=sdBox(p-vec2(-1.0,0.2),vec2(0.9,1.0) );\n    float  d1ojoizqA= sdCircle( p-vec2(-0.7,1.2), 0.7 );\n    float  d1ojoizqB= sdCircle( p-vec2(-0.7,1.2), 0.3 );\n    \n    d1izq=differenceSDF(d1izq,db1);\n    d1ojoizqA=intersectSDF(d1ojoizqA,d1izq);\n    d1ojoizqB=intersectSDF(d1ojoizqB,d1izq);\n    \n    col=DrawFigBorde(vec3(1.0), col,d1izq );\n    col=DrawFig(vec3(0.4), col,d1ojoizqA );\n    col=DrawFig(vec3(1.0,0.9,0.2), col,d1ojoizqB );\n    return col;\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n\nvec3 sombrero(vec2 p, vec3 col)\n{   float dso1= sdUnevenCapsule( p, 3.25, 3.25, 2.0 );\n    float db1=sdBox(p-vec2(0.0,-1.0),vec2(3.4,3.0) );\n    float difso1=differenceSDF(dso1,db1);\n    float db0= sdBox(p-vec2(0.0,1.5),vec2(5.0,0.15) )-0.5;\n    col=DrawFigBorde(vec3(1.0,1.5,0.2), col,difso1 );\n    col=DrawFigBorde(vec3(0.3), col,db0 );\n    \n    float sr1=sdRoundedX(p-vec2(0.0,3.5), 1.5, 0.35 );\n    col=DrawFigBorde(vec3(1.0,0.0,0.3), col,sr1 );\n    return col;\n}\n\nvec3 boca(vec2 p, vec3 col)\n{  float anc=1.5;\n   float d1= sdUnevenCapsule( p, anc, anc, 1.0 );\n   float db0= sdBox(p-vec2(0.0,1.5),vec2(2.5,2.0) );\n   float d2=sdCircle(p-vec2(0.5,-1.5), 0.8 );\n    d1=differenceSDF(d1,db0);\n    d2=intersectSDF(d2,d1);\n    \n   col=DrawFigBorde(vec3(0.0), col,d1 );\n   col=DrawFigBorde(vec3(1.0,0.0,0.0), col,d2 );\n   return col;\n}\n\nvec3 rostro(vec2 p, vec3 col)\n{ float d1= sdUnevenCapsule( p, 3.0, 3.0, 2.0 );\n    col=DrawFigBorde(vec3(1.0,0.5,0.2), col,d1 );\n    float px=0.25*sin(iTime);\n    float py=0.25*cos(iTime);\n    \n    col= ojo(p-vec2(0.0+px,-1.5+py), col);\n    col= ojo(p-vec2(2.0+px,-1.5+py), col);\n    col= sombrero(p-vec2(0.0,0.2), col);\n    col=boca( p-vec2(0.0,-0.5), col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=8.0;\n    \n    vec2 uv1=uv;\n    float tt=iTime*5.0;\n    uv1.y=opRep1D(uv1.y-tt, 12.0 );\n    col= rostro(uv1,col);\n    \n    vec2 uv2=uv;\n    uv2.y=mod(uv2.y+tt,10.0);\n    uv2=abs(uv2*1.5-vec2(0.0,-2.0))-10.0;\n    col= rostro(uv2,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 275, 309, 309, 404], [406, 437, 473, 473, 518], [523, 567, 614, 614, 641], [642, 642, 685, 685, 712], [713, 713, 761, 761, 789], [795, 795, 857, 857, 1053], [1055, 1055, 1136, 1136, 1266], [1268, 1268, 1325, 1325, 1391], [1393, 1393, 1430, 1430, 1509], [1511, 1511, 1546, 1546, 1569], [1571, 1571, 1633, 1633, 1872], [1875, 1875, 1903, 1903, 2462], [2464, 2464, 2519, 2519, 2581], [2584, 2584, 2617, 2617, 3051], [3053, 3053, 3082, 3082, 3417], [3419, 3419, 3450, 3450, 3795], [3797, 3797, 3854, 3854, 4266]], "test": "untested"}
{"id": "fs3SWj", "name": "pentagonal tiling variations", "author": "mattz", "description": "Click and drag to set vertex position. \n\nInspired by [url]https://twitter.com/cs_kaplan[/url]. See [url]https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling[/url] for details.", "tags": ["tiling", "pentagonal", "variations", "cairo"], "likes": 68, "viewed": 1938, "published": 3, "date": "1633999926", "time_retrieved": "2024-07-30T18:56:36.512329", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// \"pentagonal tiling variations\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// Click and drag to set vertex position.\n//\n// Renders \"type 4\" Cairo pentagonal tilings. See\n// https://en.wikipedia.org/wiki/Cairo_pentagonal_tiling\n// for details.\n//\n// Inspired by https://twitter.com/cs_kaplan\n//\n// Related shaders:\n//\n//   - \"Cairo tiling\" by nimitz\n//      https://www.shadertoy.com/view/4ssSWf\n//\n//   - \"More Cairo Tiles\" by mla\n//      https://www.shadertoy.com/view/MlSfRd\n//\n//   - \"Extruded Pentagon Tiling\" by Shane\n//      https://www.shadertoy.com/view/3t2cDK\n//\n//   - \"15th Pentagonal tiling\" by tomkh\n//      https://www.shadertoy.com/view/4lBXRV\n//\n//   - \"pentagonal tiling\" by FabriceNeyret2\n//      https://www.shadertoy.com/view/ltBBzK\n//      (golfed at https://www.shadertoy.com/view/XljfRV)\n//\n// Noise function from iq's \"Noise - gradient - 2D\"\n// https://www.shadertoy.com/view/XdXGW8\n//\n//////////////////////////////////////////////////////////////////////\n\n// vector rotated by 90 degrees CCW\nvec2 perp(vec2 u) {\n    return vec2(-u.y, u.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 rotate(vec2 rvec, vec2 p) {\n    return p.x * rvec + p.y * vec2(-rvec.y, rvec.x);\n}\n\n// rotate vector by rotation vector (cos(t), sin(t))\nvec2 unrotate(vec2 rvec, vec2 p) {\n    return p.x * vec2(rvec.x, -rvec.y) + p.y * rvec.yx;\n}\n\n// distance from point to line segment\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float u = dot(pa, ba) / dot(ba, ba);\n    \n    u = clamp(u, 0.0, 1.0);\n    \n    return length(pa - u * ba);\n    \n}\n\n// half-plane test\nbool in_half_plane(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    return dot(pa, perp(ba)) > 0.0;\n}\n\n// point in triangle\nbool in_triangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return in_half_plane(p, a, b) && in_half_plane(p, b, c) && in_half_plane(p, c, a);\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nvec2 grad( ivec2 z ) {\n\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    \n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    \n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n           gr;\n           \n}\n\n// from https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p ) {\n\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n\n}\n\n\n// colors for each cell\nconst vec3 CELL_COLORS[4] = vec3[4](\n    vec3(0.9, 0.0, 0.05),\n    vec3(0.95, 0.85, 0.0),\n    vec3(0.1, 0.8, 0.05),\n    vec3(0.1, 0.5, 0.8)\n);\n\n// rotation vectors for theta = 0, pi/2, pi, 3*pi/2\nconst vec2 ROT_VECTORS[4] = vec2[4](\n    vec2(1, 0),\n    vec2(0, 1),\n    vec2(-1, 0),\n    vec2(0, -1)\n);\n\n// un-rotated cell geometry \n// \n//\n//           C\n//         _*_____\n//       _-       -----____\n//  D  _*------------------* B ---\n//   _- |                 ||\n//  *   |                 ||\n//  |   |                | |    \n//  |   |                | |    t\n//   |  |               |  |   \n//   |  |            A  |  |\n//    | |            __*   |   ---\n//    | |        __--   \\  |    \n//     ||    __--        \\ |    y\n//     ||__--             \\|    \n//    O *------------------* X ---\n//\n//      |       x      | s |\n// \n// notes:\n//\n//   square is 0.5 x 0.5\n//\n//   A = O + (x, y)\n//   B = O + (0.5, 0.5)\n//   C = B + (-t, s) = B + (y - 0.5, 0.5 - x)\n//   D = O + (-y, x)\n//   X = O + (0.5, 0)\n//\n//   segments OD and OA are congruent and perpendicular\n//   segments AB and BC are congruent and perpendicular\n//  \n//   there are four rotated copies of polygon OABCD around point O \n\n// polygon points\nvec2 O, A, B, C, D;\n\n// for bump-mapped shading\nvec2 heightmap(vec2 p) {\n\n    // get polygon distance\n    float dpoly = dseg(p, O, A);\n    dpoly = min(dpoly, dseg(p, A, B));\n    dpoly = min(dpoly, dseg(p, B, C));\n    dpoly = min(dpoly, dseg(p, C, D));\n    dpoly = min(dpoly, dseg(p, D, O));\n    \n    // offset from edge\n    float k = 0.08;\n    \n    // base height\n    float z = k + 0.01 * noise(5.*p);\n    \n    if (dpoly < k) {\n        // semicircular shoulder\n        float w = (dpoly/k - 1.0);\n        z *= sqrt(1.0 - w*w);\n    } else {\n        // depression inwards from edge\n        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));\n    }\n    \n    // return height and polygon distance\n    return vec2(z, dpoly);\n    \n}\n\n// do the things!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // global rotation by 45 degrees\n    vec2 global_rot = vec2(0.5*sqrt(2.0));\n    \n    // image should be six blocks high\n    float scl = 6.0 * global_rot.x / iResolution.y;\n    \n    // uv in [0,1] x [0, 1] holds vertex position\n    vec2 uv = vec2(0.7886751345948132, 0.21132486540518713);\n    \n    // light coords relative to center\n    vec2 lcoord = vec2(0);\n\n    if (iMouse.z > 0.) {\n    \n        // set vertex coords by dragging - light is fixed\n        \n        uv = clamp(iMouse.xy / iResolution.xy, 0.0, 1.0);\n        lcoord = vec2(-0.0, 0.5);\n        \n    } else {\n    \n        // set vertex coords varying over screen\n        // and move light\n        uv = (fragCoord.xy - 0.5 * iResolution.xy) / (max(iResolution.x, iResolution.y));\n        \n        const float repeat = 30.0; // seconds\n        const float wraps_per_repeat = 5.0;\n        \n        const float x_lobes = 3.0;\n        const float y_lobes = 2.0;\n        \n        const float two_pi = 6.283185307179586;\n        \n        float t = iTime * two_pi / repeat;\n        \n        float t_wrap = t * wraps_per_repeat;\n       \n        float c = cos(t_wrap);\n        float s = sin(t_wrap);\n        \n        uv = rotate(vec2(s, -c), uv);\n        \n        uv = clamp(uv + 0.5, 0.0, 1.0);\n        \n        lcoord = vec2(-sin(t * x_lobes), cos(t * y_lobes));\n \n    }\n    \n    // z coordinate of camera and light (tiles live at z=0)\n    const float cz = 3.5;\n    \n    // set light pos in 3D\n    vec3 lpos = vec3(lcoord * 0.5 * iResolution.xy * scl, cz);\n    \n    // camera pos in 3D\n    const vec3 cpos = vec3(0, 0, cz);\n\n    // map frag cords to scene coords (before global rotation)\n    vec2 porig = (fragCoord + vec2(0.13, 0.17) - 0.5*iResolution.xy) * scl;\n    \n    // apply global rotation\n    vec2 p = rotate(porig, global_rot);\n\n    // find starting origin of tile cluster -- note this could change below\n    O = floor(p + 0.5);\n            \n    // figure out which quadrant we are in relative to the origin\n    ivec2 qstep = ivec2(step(p, O));\n    int quadrant = (qstep.x ^ qstep.y) + 2*qstep.y;\n    \n    // each quadrant rotates by 90 degrees\n    vec2 rvec = ROT_VECTORS[quadrant];\n    \n    // form some critical points of the polygon in this cell\n    vec2 xy = 0.5*uv;\n    vec2 st = 0.5 - xy;\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n    vec2 X = O + rotate(rvec, vec2(0.5, 0));\n\n    // get distance from point to semgent AX\n    float dline = dseg(p, A, X);\n\n    // figure out whether we are in the main upper-left part of the\n    // cell or one of the two triangles\n    int cell = quadrant;\n    \n    if (in_triangle(p, X, B, A)) {\n        // in triangle XBA -- rotate polygon CCW by 90 degrees and translate it over by 1 cell\n        cell = (quadrant + 1) & 3;\n        O += rvec;\n        rvec = perp(rvec);\n    } else if (in_triangle(p, O, X, A)) {\n        // in trangle OXA -- rotate polygon CW by 90 degrees\n        cell = (quadrant + 3) & 3;\n        rvec = -perp(rvec);\n    } \n\n    // now we know which polygonal tile p is in, so get the distance to the\n    // polygon\n    \n    A = O + rotate(rvec, xy);\n    B = O + rotate(rvec, vec2(0.5));\n\n    C = B + rotate(rvec, perp(st));\n    D = O + rotate(rvec, perp(xy));\n    \n    vec2 hm = heightmap(p);\n    \n    const float h = 1e-3;\n    const vec2 eps = vec2(h, 0);\n    \n    vec2 hgrad = (0.5 / h) * vec2(\n        heightmap(p + eps.xy).x - heightmap(p - eps.xy).x,\n        heightmap(p + eps.yx).x - heightmap(p - eps.yx).x\n    );  \n    \n    hgrad = unrotate(global_rot, hgrad);\n    \n    float z = hm.x;\n        \n    dline = min(dline, hm.y);\n    \n    // bump-mapped surface normal\n    vec3 N = normalize(cross(vec3(1, 0, hgrad.x), vec3(0, 1, hgrad.y)));\n\n    // get color of this cell\n    vec3 color = CELL_COLORS[cell];\n    color *= color; // gamma un-correct\n    \n    // desaturate a bit\n    color = mix(color, vec3(0.5), 0.08);\n    \n    // get 3D point position\n    vec3 pos = vec3(porig, z);\n\n    // fake phong lighting\n    vec3 L = normalize(lpos - pos);\n    vec3 V = -normalize(cpos - pos);\n\n    vec3 R = reflect(L, N);\n    \n    color *= 0.1 + 0.9 * clamp(dot(N, L), 0.0, 1.0);\n    color += 0.3*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*vec3(1);\n\n    // darken by lines\n    color *= smoothstep(0.0, 0.0125, dline);\n    \n    // gamma \"correct\"\n    color = sqrt(color);\n\n    // done!\n    fragColor = vec4(color, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SWj.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1083, 1119, 1138, 1138, 1168], [1170, 1223, 1255, 1255, 1310], [1312, 1365, 1399, 1399, 1457], [1459, 1498, 1534, 1534, 1700], [1702, 1721, 1765, 1765, 1845], [1847, 1868, 1918, 1918, 2007], [2009, 2078, 2100, 2155, 2507], [2509, 2555, 2581, 2581, 2976], [4232, 4259, 4283, 4312, 4931], [4933, 4951, 5008, 5046, 9379]], "test": "untested"}
{"id": "sstSWj", "name": "Physically based point light", "author": "hyperknot", "description": "Physically based lightness calculation for a point light above a 100% matte (Lambertian) ground plane.\ndetails: https://hyperknot.com/blog/area_lights_in_shaders/", "tags": ["pointlight", "physics"], "likes": 1, "viewed": 693, "published": 3, "date": "1633992221", "time_retrieved": "2024-07-30T18:56:37.297230", "image_code": "// Physically based lightness calculation \n// for a point light above a 100% matte (Lambertian) ground plane,\n// moving up and down.\n// details: https://hyperknot.com/blog/area_lights_in_shaders/\n\nfloat point_light(vec2 uv, float h, float i) {\n  // h - light's height over the ground\n  // i - light's intensity\n  return i * h * pow(dot(uv,uv) + h*h, -1.5);\n}\n\nfloat lin_to_srgb ( float val ) {\n  if( val < 0.0031308 )\n    return val * 12.92;\n  else\n    return 1.055 * pow(val,1.0/2.4) - 0.055;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    float h = pow(sin(iTime/3.), 2.) * 0.1 + 0.001;\n    float v = point_light(uv, h, 0.005);\n    v = lin_to_srgb(v);\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 243, 310, 358], [360, 360, 393, 393, 495], [497, 497, 553, 553, 761]], "test": "untested"}
{"id": "NdtSD2", "name": "Taste of Noise", "author": "leon", "description": "Result of experimentation with organic patterns", "tags": ["weird"], "likes": 13, "viewed": 468, "published": 3, "date": "1633991972", "time_retrieved": "2024-07-30T18:56:38.331465", "image_code": "\n// taste of noise by leon denise 2021/10/12\n// result of experimentation with organic patterns\n// using code from Inigo Quilez\n// Licensed under hippie love conspiracy\n\n// rotation matrix\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// global variable\nfloat material;\n\n// sdf\nfloat map (vec3 p)\n{\n    // time\n    float t = iTime * 0.1;\n    \n    // rotation parameter\n    vec3 angle = vec3(78.,68.,78.) + t + p;\n    \n    // kif\n    const int count = 5;\n    float a = 1.0;\n    float scene = 1000.;\n    float shape = 1000.;\n    for (int index = 0; index < count; ++index)\n    {\n        // fold\n        p = abs(p)-.5*a;\n        \n        // rotate\n        p.xz *= rot(angle.y/a);\n        p.yz *= rot(angle.x/a);\n        p.yx *= rot(angle.z/a);\n        \n        // sphere\n        shape = length(p)-.6*a;\n        \n        // materialing\n        material = shape < scene ? float(index) : material;\n        \n        // add\n        scene = min(scene, shape);\n        \n        // falloff\n        a /= 1.89;\n    }\n    \n    // shell\n    scene = abs(scene);\n    \n    // surface details\n    float d = length(p);\n    float details = abs(sin(d*20.))*0.05;\n    scene -= details;\n    \n    return scene;\n}\n\n// return color from pixel coordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // reset color\n    fragColor = vec4(0);\n    material = 0.0;\n    \n    // camera coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 eye = vec3(0,0,-1);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    eye.xz *= rot(0.4+mouse.x);\n    eye.xy *= rot(0.6-mouse.y);\n    vec3 z = normalize(-eye);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(vec3(z * 0.5 + uv.x * x + uv.y * y));\n    vec3 pos = eye + ray * .5;\n    \n    // raymarch\n    const int steps = 20;\n    for (int index = steps; index > 0; --index)\n    {\n        // volume estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            // Inigo Quilez color palette (https://iquilezles.org/articles/palettes)\n            vec3 tint = vec3(0.2)+vec3(0.8)*cos(vec3(1,2,3)*material*0.2-length(pos)*2.);\n            \n            // pixel color\n            float shade = float(index)/float(steps);\n            fragColor.rgb = tint * shade;\n            \n            break;\n        }\n        \n        // raymarch\n        pos += ray * dist;\n    }\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSD2.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[170, 189, 208, 208, 253], [291, 298, 318, 330, 1207], [1209, 1247, 1304, 1323, 2426]], "test": "untested"}
{"id": "NdtXD2", "name": "Perfect Opensimplex Loop", "author": "Edwy", "description": "Loops 2D Opensimplex2s by rotating it through 3D space implementation. Since the canvas rotates through 3D space rather than 4D hyperspace, smaller values of r may cause a large disparity in speed of the movement on either horozontal edge of the canvas.", "tags": ["noise", "simplex", "loop", "opensimplex", "opensimplex2s"], "likes": 4, "viewed": 273, "published": 3, "date": "1633988102", "time_retrieved": "2024-07-30T18:56:39.201140", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y * 2.0;\n\n    //Period of rotation and radius of plane rotation through 3D space\n    float period = 50.0;\n    float r = 8.0;\n\n    //Polar point of noise sample in 3D space\n    vec3 pointInSpace = vec3((r - uv.x) * cos(iTime * 6.2832 / period), uv.y, (r - uv.x) * sin(iTime * 6.2832 / period));\n\n    //Value from K.jpg's OS2S Implementation\n    vec4 val = openSimplex2SDerivatives_Classical(pointInSpace);    \n\n    vec3 col = vec3(0.9, 0.7, 0.95) * step((val[3]), 0.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "/////////////// K.jpg's Re-oriented 8-Point BCC Noise (OpenSimplex2S) ////////////////\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2SDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 openSimplex2SDerivatives_Classical(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = openSimplex2SDerivativesPart(X) + openSimplex2SDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 596]], "test": "untested"}
{"id": "fdtXW2", "name": "OS2S Breathing Hexigons (Loop)", "author": "Edwy", "description": "Hexagons change their size based on perfectly looped simplex noise with a period of 50 seconds. Perfect loop noise implementation can be found in my published shaders.", "tags": ["template", "gammacorrection", "boilerplate", "msaa"], "likes": 15, "viewed": 419, "published": 3, "date": "1633983550", "time_retrieved": "2024-07-30T18:56:40.175535", "image_code": "vec2 hex(vec2 point){\n    return vec2( (point.x + 1.7321 * point.y) / 3.0, (point.x + 1.7321 * point.y) / 3.0 - 1.1547 * point.y);\n}\n\nvec2 point(vec2 hex){\n    return vec2(3.0 * (hex.x + hex.y), 1.7321 * (hex.x - hex.y)) / 2.0;\n}\n\nfloat inhex(vec2 p, vec2 c, float s){\n    return step(max(abs(c.y - p.y), dot(abs(p - c), normalize(vec2(1.7321, 1.0)))), s / 2.0);\n}\n\nvec2 gethex(vec2 p){\n    vec2 center = round(hex(p));\n    center.x += inhex(p, point(center + vec2(1, 0)), 1.7321) - inhex(p, point(center + vec2(-1, 0)), 1.7321);\n    center.y += inhex(p, point(center + vec2(0, 1)), 1.7321) - inhex(p, point(center + vec2(0, -1)), 1.7321);\n    return point(center);\n}\n\nvec3 Image(vec2 uv)\n{\n    float hscale = 50.0;\n    vec2 hex = gethex(hscale * uv);\n    vec2 hsample = hex / hscale;\n\n    float r = 5.0;\n    float period = 50.0;\n\n    vec3 pointInSpace = vec3((r - hsample.x) * cos(iTime * 6.2832 / period), uv.y, (r - hsample.x) * sin(iTime * 6.2832 / period));\n\n    vec4 val = openSimplex2SDerivatives_Classical(pointInSpace);\n\n    float s = 0.5 + 1.24 * (val[3]/2.0 + 0.5);\n\n    return vec3(1.0) * inhex(hscale * uv, hex, s);\n    //return (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4))) * (1.0 - inhex(hscale * uv, hex, s));\n}\n\nMAIN_FUNCTION(Image)", "image_inputs": [], "common_code": "/////////////// K.jpg's Re-oriented 8-Point BCC Noise (OpenSimplex2S) ////////////////\n////////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) //////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2SDerivativesPart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n        + mat4x3(g1, g2, g3, g4) * aaaa;\n    \n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n// Rotates domain, but preserve shape. Hides grid better in cardinal slices.\n// Good for texturing 3D objects with lots of flat parts along cardinal planes.\nvec4 openSimplex2SDerivatives_Classical(vec3 X) {\n    X = dot(X, vec3(2.0/3.0)) - X;\n    \n    vec4 result = openSimplex2SDerivativesPart(X) + openSimplex2SDerivativesPart(X + 144.5);\n    \n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\nconst int aa = 4;\nconst float aperture = 1.0;\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color*aperture-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \t\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    \\\n    /*Output to screen*/\\\n    fragColor = colorCorrect(total);\\\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 132], [134, 134, 155, 155, 229], [231, 231, 268, 268, 364], [366, 366, 386, 386, 667], [669, 669, 690, 690, 1223]], "test": "untested"}
{"id": "NstSW2", "name": "moonsurface", "author": "aliva", "description": "noise", "tags": ["noise"], "likes": 0, "viewed": 607, "published": 3, "date": "1633982712", "time_retrieved": "2024-07-30T18:56:41.004319", "image_code": "//Modified version from this shader https://www.shadertoy.com/view/7d3XD8\n\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define T(c)     texelFetch(c, ivec2(u) % textureSize(c,0).xy, 0).x \n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P = u/R;\n    u.x -= float(iFrame);\n    U = u / R;\n\n    float h =    P.y > 0.66 ? hash(U)\n               : P.y > 0.33 ? T(iChannel0) \n               :             T(iChannel1);\n    O = vec4 ( iMouse.z > 0.0 ? step(P.x,h)               // raw thresholding\n                             : R.x/64.* ( h - P.x) +0.5   // progressive appear\n             );             // 10.\n             \n    \n    \n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 257, 257, 684]], "test": "untested"}
{"id": "NdtXDj", "name": "Cable nest depth blur test", "author": "mrange", "description": "License CC0: Cable nest depth blur test\nNot really experimented with blur post processing before.\nThis is my first try to implement depth dependent blur.\n", "tags": ["raymarching"], "likes": 11, "viewed": 377, "published": 3, "date": "1633978697", "time_retrieved": "2024-07-30T18:56:41.777252", "image_code": "// License CC0: Cable nest depth blur test\n// Not really experimented with blur post processing before\n//  this is my first try to implement depth dependent blur.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n// Set to 0 for no blurring\n#define BLURN           3\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy;\n  vec4 t = texture(iChannel0, q);\n\n  const int c = BLURN;\n  \n  vec2 aa = vec2(1.25*smoothstep(0.0, 4.0, abs(t.w-4.0)))/RESOLUTION.xy;\n  vec2 start = q-float(c)*aa;\n  vec3 col = t.xyz;\n  for (int y = -c; y <= c; ++y) {\n    vec2 pp = start;\n    for (int x = -c; x <= c; ++x) {\n      vec4 ppcol = texture(iChannel0, pp);\n      col += ppcol.xyz;\n      pp.x += aa.x;\n    }\n    start.y += aa.y;\n  }\n  \n  col /= float((2*c+1)*(2*c+1)+1);\n\n\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// License CC0: Cable nest with depth of field\n\n#define TOLERANCE       0.0001\n#define NORMTOL         0.00125\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 90\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\nconst float cam_amp = 1.0;\n\nvec4 g_state = vec4(0.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://iquilezles.org/articles/spherefunctions\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 cam_path(float z) {\n  return vec3(cam_amp*sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\nfloat df(vec3 p3, out vec4 state) {\n  float cylr = 0.2;\n  vec2 p = p3.xy;\n  float t = p3.z;\n  \n  const float ss = 1.5;\n  mat2 pp = ss*ROT(1.0+0.5*p3.z);\n\n  p *= ROT(-0.2*TIME);\n  float s = 1.0;\n  \n  float d = 1E6;\n  float tt = 0.0;\n  for (int i = 0; i < 3; ++i) {\n    tt += sqrt(2.0)*float(1+i);\n    p *= pp;\n    vec2 sp = sign(p);\n    p = abs(p);\n    tt += dot(sp, vec2(0.25, 0.5))*s;\n    p -= 1.35*s;\n    s *= 1.0/ss;\n    \n    float dd = (length(p-vec2(0.0))-cylr)*s;\n    if (dd < d) {\n      d = dd;\n      state = vec4(p, t, hash(tt+123.4));\n    }\n    \n  }\n  \n  return d;\n}\n\nfloat df(vec3 p) {\n  // Found this world warping technique somewhere but forgot which shader :(\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n  vec4 state;\n  float d = df(p, state);\n  \n  g_state = state;\n  \n  return d; \n} \n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float distance = df(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(NORMTOL,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<25; ++i) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec4 render(vec3 ro, vec3 rd) {\n  vec3 lightPos0  = cam_path(TIME-0.5);\n  vec3 lightPos1  = cam_path(TIME+6.5);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n  vec4 state = g_state;\n\n  float tt = float(iter)/float(MAX_RAY_MARCHES);\n  float bs = 1.0-tt*tt*tt*tt;\n \n  vec3 pos = ro + t*rd;    \n  \n  float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*120.0/60.0));\n  vec3 bcol   = mix(1.5*vec3(2.25, 0.75, 0.5), 3.5*vec3(2.0, 1.0, 0.75), beat);\n  vec3 gcol   = lsd1*bcol;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return vec4(skyCol+gcol, MAX_RAY_LENGTH);\n  }\n  \n  vec3 nor    = normal(pos);\n\n  float sa    = atan(state.y, state.x)+4.0*state.z*(0.5+0.5*state.w);\n  float v     = 0.9*smoothstep(-0.1, 0.1, sin(4.0*sa));\n  vec3 color  = hsv2rgb(vec3(0.0+123.4*state.w, 0.66, 0.75*v));\n  \n  vec3 lv0    = lightPos0 - pos;\n  float ll20  = dot(lv0, lv0);\n  float ll0   = sqrt(ll20);\n  vec3 ld0    = lv0 / ll0;\n  float dm0   = 8.0/ll20;\n  float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);\n  float dif0  = max(dot(nor,ld0),0.0)*dm0;\n\n  vec3 lv1    = lightPos1 - pos;\n  float ll21  = dot(lv1, lv1);\n  float ll1   = sqrt(ll21);\n  vec3 ld1    = lv1 / ll1;\n  float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);\n\n  vec3 col = vec3(0.0);\n  col += dif0*sha0*color;\n  col += spe1*bcol*bs;\n  col += gcol;\n\n  return vec4(col, t);\n}\n\nvec4 effect3d(vec2 p) {\n  float tm = TIME;\n  vec3 cam  = cam_path(tm);\n  vec3 dcam = dcam_path(tm);\n  vec3 ddcam= ddcam_path(tm);\n\n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*-2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = (2.0+0.5*tanh_approx(length(p)));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec4 col = effect3d(p);\n\n  fragColor = vec4(col);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXDj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[285, 285, 328, 328, 580], [583, 583, 638, 638, 1155]], "test": "untested"}
{"id": "NdtSDj", "name": "Oleadas ", "author": "nictemeral", "description": "shader exploración de seno , inspirado por la web de solquemalhttps://curso.solquemal.com/clases/\n\n", "tags": ["waves", "sin", "color"], "likes": 1, "viewed": 193, "published": 3, "date": "1633974517", "time_retrieved": "2024-07-30T18:56:42.564148", "image_code": "//nictemeral\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n     vec3 color = vec3(0.960,0.113,0.003); \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 -01.; \n          \n    color.rb = fract(abs(uv*3.0));  \n    color.rb *= floor(abs(uv*7.0))/5.0; \n\n    uv.y+=0.120;\n    uv.x+=sin(sin(iTime)*sin(uv.x));\n  \n    color.rb = floor(abs(uv*sin(atan(uv.s,uv.t))*10.272))/10.200; \n\n     \n    fragColor = vec4(color,1.0);\n\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 69, 69, 437]], "test": "untested"}
{"id": "NddXWj", "name": "Lava-Lamp ", "author": "nictemeral", "description": "Lampara de lava, shader basado subdivisión del espacio por regiones o IDs ", "tags": ["noise", "time", "lava", "id", "idspace", "lampcolor"], "likes": 2, "viewed": 252, "published": 3, "date": "1633973771", "time_retrieved": "2024-07-30T18:56:43.425844", "image_code": "//\n//proximamente lo pasare en limpio\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 map(vec2 value, vec2 min1, vec2 max1, vec2 min2, vec2 max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 map(vec2 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {\n  return min2 + (vec3((value.s+value.t)/2.0 )- min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*1.516),\n                         _radius+(_radius*0.122),\n                         dot(dist,dist)*4.0);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nfloat div=4.;\n vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;//esto aca es medio inecesario\n\n    st*=div;\n\n    vec2 ipos = floor(st);  \n    vec2 f_st=fract(st);\n    vec2   d_time=(0.5-random2(ipos));\n\n    vec2 mpos = map(ipos,vec2(0.0),vec2(div),vec2(0.120,0.250),vec2(0.990,01.980));\n\tmpos*=4.9632;//esto esta demas y es mala practica pero lo odejo por que me gusto el color\n    \n\n    float c=step(0.348,circle(f_st,1.340)*noise(f_st*div+ipos*div+iTime*d_time));\n\n\n    vec3 color = c*vec3(mpos.s+mpos.t)*0.5*vec3(0.680,0.159,0.067);\n\n\n    fragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 111, 111, 177], [179, 179, 245, 245, 311], [313, 313, 379, 379, 467], [470, 470, 514, 514, 690], [692, 692, 716, 716, 823], [825, 825, 851, 929, 1264], [1266, 1266, 1288, 1288, 1427], [1429, 1429, 1486, 1486, 2088]], "test": "untested"}
{"id": "NsdSWj", "name": "Sombras", "author": "nictemeral", "description": "Pequeño shader alocado, jugando con funciones de distancia y un poco de noise para darle movimiento", "tags": ["noise", "shadows", "soft", "move", "sombras"], "likes": 5, "viewed": 268, "published": 3, "date": "1633972261", "time_retrieved": "2024-07-30T18:56:44.324442", "image_code": "//Author: nictemeral\n//Title: sombras\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n     st.x *=iResolution.x/iResolution.y;\n     st*=1.1;\n     st.x-=0.34;\n     // st.y+=0.1;\n\n    float e=  distance(st,vec2(0.260,0.740));\n\tfloat a=  distance(vec2(e),vec2(0.510,0.360));\n    float b=  distance(vec2(e),vec2(a));\n    float r=  distance(st,vec2(0.460,0.400));\n\tfloat f=  distance(st,vec2(0.990,0.220));\n    float j=  distance(vec2(r),vec2(f));    \n    float q=  distance(st,vec2(0.440,-0.130));\n    float z=  distance(vec2(q),vec2(j));\n\n\n    vec2 toCenter = st-vec2(noise(st-iTime) ,noise(st+iTime));\n    float pct = length(toCenter);\n  \ttoCenter = st-vec2(noise(st-iTime*0.25) ,noise(st+iTime*0.25));\n    pct *= length(toCenter)*3.;\n    \n    vec3 color = .7212-vec3(j*pct*b*z)*50.000;\n\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 112, 112, 228], [230, 308, 334, 334, 714], [716, 716, 773, 773, 1549]], "test": "untested"}
{"id": "7scXD2", "name": "Thewaytoentry-1", "author": "jialouluo", "description": "从如何创建一个圆 到创建一个圆环，到为圆环增添颜色，到色彩动效；", "tags": [], "likes": 3, "viewed": 496, "published": 3, "date": "1633968031", "time_retrieved": "2024-07-30T18:56:45.201097", "image_code": "vec3 getcolor(float ang) {\n    //传入进来的是一个角度值 我们需要将他进行一定的运算来使得他成为我们需要的结果，这里可以根据自己喜好\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2));\n        //return 0.6 + 0.4 * cos(ang + vec3(0.5,.7,.2)  + iTime );//有 iTime\n        //return .5 + .5 * cos(6.28 * (ang + vec3(0., .33, .67)));\n        return .5 + .5 * cos(6.28 * (ang/6.28 + vec3(0., .33, .67)));//6.28 约等于2Π\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //从如何创建一个圆 到创建一个圆环，到为圆环增添颜色，到色彩动效；\n    //本人也才刚开始学 ，有不对的一些地方或者理解错误的地方，也希望路过的大佬不吝赐教QAQ\n    vec2 uv = fragCoord/iResolution.xy;//将uv坐标转换到0-1\n    uv-=.5;//将uv移到中心(0,0)\n    uv.x *= (iResolution.x/iResolution.y);//别急着解开注释，uv.x更新\n    //下面创建一个圆\n    float dis = length(uv);//得到每个像素到原点(0，0)的长度\n    \n    //smoothstep(a,b,x); 当a>b时 ,x>a 那么y值(返回值)为0;x <b小返回值为1; b>a的情况这里用不到,具体可以看Api的解释\n    //若x大于b小于a为平滑过渡的值(0-1)\n    //基于这一点 我们可以实现一个圆\n    //我们屏幕的坐标范围为 -0.5=>0.5(注释掉uv.x更新的那行代码的范围)\n    //float r = 0.6;//这是半径,不受范围大小影响\n    //float c  = smoothstep(r,r-0.1,dis);//只要dis(像素的坐标距离原点的距离)大于r 那么 返回值就为0，\n    //小于r-0.1就为1，有0.1的平滑距离\n    //我们将目前的c值赋值给fragColor试试效果\n    //vec3 cir = vec3(c);\n    //fragColor = vec4(cir,1.0);\n    //会发现是一个椭圆\n    //可以发现 是由于长宽比例的问题 所以将 所有的uv的x值都乘以一个x/y的值\n    //需要在计算距离之前添加这句代码uv.x *= (iResolution.x/iResolution.y);\n    //这下我们解开上面的注释再试试\n    //运行之后我们发现 成功的绘制的一个圆\n    //利用smoothstep 我们想想 可不可以在圆的基础上制作一个空心的圆(圆环)\n    //我们知道 如果在a>b的基础上 若x大于a返回值为0 我们可以基于这一点来实现\n    //也就是 在距离原点位置越近 某个值越大 最后达到临界值会大于a 以此来实现返回0 \n    //这个值 我们可以用 value 同时我们也可以设置一个内圆的半径 ir\n    //接下来让我们重写第8 - 32行的代码;\n    float ir = 0.09;\n    float or = 0.4;\n    float value = abs(dis - or);//dis越近 value的值越大\n    float c = smoothstep(ir,ir-0.01,value);//这里可以不用0.01作为区间 ，可以用偏导宽来作为平滑区间,(偏导宽 + smoothstep 经常作为去锯齿的一种常用方法)\n    //vec3 cir = vec3(c);\n    //fragColor = vec4(cir,1.0);\n    //效果似乎还行，但是改变参数发现 似乎效果不如我们想得那样美好，\n    //原因是当我们改变内圆半径时 a，b的值也发生了改变,使得除开内圆范围判断的其他判断也发生了改变，\n    //但是已经不影响我们下面的使用了\n    //下面我们来对这个圆环进行着色\n    //我们需要知道每个uv坐标对应于中心点的角度，以此来进行不同uv位置的不同颜色赋值\n    //使用 atan(uv.y,uv.x)是常用的求uv角度的方法\n    float angle  =atan(uv.y,uv.x);\n    //我们这时来进行赋值操作,重写37 - 44行的代码\n    //vec3 cir = vec3(angle * c);\n    //fragColor = vec4(cir,1.0);\n    //会发现渐变的效果似乎出来了，当然因为rgb的参数是一样的所以呈黑白\n    //我们需要对他进行优化，我们需要一个方法来使得我们的角度值转变为一个具有不同rgb的一个vec3对象\n    //让我们为他创建一个函数\n    //让我们来重写47-50行代码\n    vec3 f_color = getcolor(angle) * c * fract(angle/6.28 - iTime);\n    //vec3 f_color = getcolor(angle) * c * fract(angle - iTime);//不除2Π\n    fragColor =vec4(f_color,1.0);\n    //到这已经创建一个具有自己特色颜色的圆环了，接下来我们需要为他添加一些动效\n    //我们需要用到 iTime 这个shadertoy内置变量 他代编运行时间 ，与他对应的还有一个 ItimeDelta 他表示每帧时长;\n    //将 iTime 写入到计算中，这里跳转到函数哪去\n    //我们可以为他添加一些彩虹头亮尾暗的效果\n    //至于除2Π的作用现目前无法用语言来形容 看看效果应该能大致清楚了\n    \n    //就先写到这里吧 我也是刚学的新人，借鉴了无数大佬的理解和代码 才勉强做到这里，以后一起加油吧\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 380, 475], [476, 476, 533, 762, 4709]], "test": "untested"}
{"id": "7scXW2", "name": "Terrain Explorer 2", "author": "dr2", "description": "Create watery landscapes; if control panel not visible click on ring; see source for details. ", "tags": ["fractal", "interactive", "water", "landscape"], "likes": 17, "viewed": 371, "published": 3, "date": "1633962893", "time_retrieved": "2024-07-30T18:56:46.149562", "image_code": "// \"Terrain Explorer 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Updated to include water and reflection.\n\n  Control panel appears when yellow ring (or a hidden control) clicked; panel fades\n  automatically; use mouse to look around.\n\n  Height functions based on the following (1-3 have additional spatial modulation):\n    1) Basic fBm.\n    2) Modified fBm in 'Elevated' by iq.\n    3) Inverted waves simplified from 'Seascape' by TDM.\n    4) Weird forms from 'Sirenian Dawn' by nimitz.\n\n  Sliders (from top):\n    Overall height scale.\n    Lacunarity - rate of fBm length scale change per iteration.\n    Persistence - rate of fBm amplitude change per iteration.\n    Variable spatial modulation (height functions 1 & 2), or feature sharpness (3 & 4).\n    Water height.\n    Flight speed.\n\n  Buttons (from left):\n    Height function choice (= 1-4).\n    Distance marching accuracy and range (may affect update rate) (= 1-3).\n    Shadows (= 1 off) and sun elevation (= 2-3).\n    Terrain reflection (= 1 off, = 2 on).\n\n  There is no end to the functionality that can be added...\n\n  (Based on \"Terrain Explorer\", with water from \"Scrolling Terrain\", and other mods)\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst float pi = 3.14159;\n\nvec3 sunDir;\nfloat tCur, dstFar, htWat, hFac, fWav, aWav, smFac, stepFac;\nint grType, qType, shType, refType, stepLim;\n\nfloat GrndHt1 (vec2 p)\n{\n  vec2 q;\n  float f, wAmp;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  f = 0.;\n  wAmp = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= aWav;\n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (0.033 * smFac * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt2 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, f;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += v.yz;\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= aWav;\n    q *= fWav * qRot;\n  }\n  return min (5. * Noisefv2 (0.033 * smFac * p) + 0.5, 4.) * f;\n}\n\nfloat GrndHt3 (vec2 p)\n{\n  vec2 q, t, ta, v;\n  float wAmp, pRough, f;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  wAmp = 0.3;\n  pRough = 1.;\n  f = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + sqrt (1. - ta * ta));\n    v = pow (1. - v, vec2 (pRough));\n    f += (v.x + v.y) * wAmp;\n    q *= fWav * qRot;\n    wAmp *= aWav;\n    pRough = smFac * pRough + 0.2;\n  }\n  return min (7. * Noisefv2 (0.033 * p) + 0.5, 5.) * f;\n}\n\nfloat GrndHt4 (vec2 p)\n{\n  vec3 v;\n  vec2 q, t;\n  float wAmp, b, f, waFac;\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.1 * p;\n  wAmp = 1.;\n  t = vec2 (0.);\n  f = 0.;\n  waFac = 1.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += pow (abs (v.yz), vec2 (5. - 0.5 * float (j))) - smoothstep (0., 1., v.yz);\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= - aWav * waFac;\n    q *= fWav * qRot;\n    waFac *= smFac;\n  }\n  b = 0.5 * (0.5 + clamp (f, -0.5, 1.5));\n  return 3. * f / (b * b * (3. - 2. * b) + 0.5) + 2.;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float ht;\n  if      (grType == 1) ht = GrndHt1 (p);\n  else if (grType == 2) ht = GrndHt2 (p);\n  else if (grType == 3) ht = GrndHt3 (p);\n  else if (grType == 4) ht = GrndHt4 (p);\n  return hFac * ht;\n}\n\nfloat GrndDf (vec3 p)\n{\n  return p.y - GrndHt (p.xz);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    h = GrndDf (ro + s * rd);\n    if (h < 0.) break;\n    sLo = s;\n    s += stepFac * (max (0.4, 0.6 * h) + 0.008 * s);\n    if (s > dstFar || j == stepLim) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (GrndDf (ro + s * rd) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat GrndDfN (vec3 p)\n{\n  return GrndDf (p) - 0.8 * Fbm2 (0.5 * p.xz);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDfN (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GrndSShadow (vec3 p, vec3 vs)\n{\n  vec3 q;\n  float sh, d;\n  sh = 1.;\n  d = 0.4;\n  for (int j = VAR_ZERO; j < 25; j ++) {\n    q = p + vs * d;\n    sh = min (sh, smoothstep (0., 0.02 * d, GrndDf (q)));\n    d += max (0.4, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.55) + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  ro.xz += 1.5 * tCur;\n  f = Fbm2 (0.1 * (ro + rd * (50. - ro.y) / rd.y).xz);\n  return mix (SkyBg (rd) + 0.35 * pow (max (dot (rd, sunDir), 0.), 16.),\n     vec3 (0.85), clamp (1.6 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colW, vn, vnw, rdo;\n  float dstGrnd, dstWat, f, spec, sh;\n  bool isRefl;\n  dstGrnd = GrndRay (ro, rd);\n  isRefl = false;\n  rdo = rd;\n  dstWat = (rd.y < 0.) ? - (ro.y - htWat) / rd.y : dstFar;\n  if (dstWat < min (dstGrnd, dstFar)) {\n    ro += dstWat * rd;\n    vnw = vec3 (0., 1., 0.);\n    vnw = VaryNf (2. * ro + vec3 (0.1, 0., 0.05) * tCur, vnw, 0.1 * (1. -\n       smoothstep (0.1, 0.4, dstWat / dstFar)));\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstGrnd = (refType > 1) ? GrndRay (ro, rd) : dstFar;\n    isRefl = true;\n    col = mix (vec3 (0.1, 0.3, 0.4), vec3 (0.1, 0.25, 0.5),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * ro.xz))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (dot (sunDir, rd), 0.), 32.)));\n    col = mix (col, SkyCol (ro, rd), 0.2 + 0.8 * pow (1. - abs (dot (rdo, vnw)), 2.));\n    colW = col;\n  }\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    f = 0.2 + 0.8 * smoothstep (0.35, 0.551, Fbm2 (1.7 * ro.xz));\n    col = mix (mix (vec3 (0.2, 0.35, 0.1), vec3 (0.1, 0.3, 0.15), f),\n       mix (vec3 (0.3, 0.25, 0.2), vec3 (0.35, 0.3, 0.3), f),\n       smoothstep (1., 3., ro.y));\n    col = mix (vec3 (0.4, 0.3, 0.2), col, smoothstep (0.2, 0.6, abs (vn.y)));\n    col = mix (col, vec3 (0.75, 0.7, 0.7), smoothstep (5., 8., ro.y - 0.5 * htWat));\n    col = mix (col, vec3 (0.9), smoothstep (7., 9., ro.y - 0.5 * htWat) *\n       smoothstep (0., 0.5, abs (vn.y)));\n    spec = mix (0.1, 0.5, smoothstep (8., 9., ro.y - 0.5 * htWat));\n    sh = (shType > 1) ? GrndSShadow (ro, sunDir) : 1.;\n    col *= 0.2 + 0.1 * vn.y + 0.8 * sh * max (0., max (dot (vn, sunDir), 0.)) +\n       spec * step (0.95, sh) * sh * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));\n    if (isRefl) col = mix (col, colW, pow (1. - abs (dot (rdo, vnw)), 5.));\n  } else if (! isRefl) col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec4 parmV1, vec4 parmV2, vec4 parmV3)\n{\n  vec4 wgBx[10];\n  vec3 col, cc;\n  vec2 ut, ust;\n  float vW[10], asp, s;\n  cc = vec3 (1., 0., 0.);\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < 6; k ++)\n     wgBx[k] = vec4 (0.36 * asp, 0.25 - 0.06 * float (k), 0.12 * asp, 0.018);\n  for (int k = 6; k < 10; k ++)\n     wgBx[k] = vec4 ((0.29 + 0.05 * float (k - 6)) * asp, -0.25, 0.024, 0.024);\n  vW[0] = parmV1.x;  vW[1] = parmV1.y;  vW[2] = parmV1.z;  vW[3] = parmV1.w;\n  vW[4] = parmV2.x;  vW[5] = parmV2.y;\n  vW[6] = parmV3.x;  vW[7] = parmV3.y;  vW[8] = parmV3.z;  vW[9] = parmV3.w;\n  col = vec3 (0.);\n  for (int k = 0; k < 6; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw;\n    if (Maxv2 (ust) < 0.) col = cc.xxx * ((Minv2 (abs (ust)) * canvas.y < 2.) ? 0.3 :\n       ((0.6 + 0.4 * smoothstep (0., 5., abs (mod (10. * ut.x / (2. * wgBx[k].z) + 0.5, 1.) -\n       0.5) * canvas.y - 20.)) * 0.6));\n    if (Maxv2 (ust) * canvas.y < 25.) {\n      ut.x -= (vW[k] - 0.5) * 2. * wgBx[k].z;\n      s = ShowInt (ut - vec2 (0.018, -0.01), 0.022 * vec2 (asp, 1.), 2.,\n         clamp (floor (100. * vW[k]), 0., 99.));\n      if (s > 0.) col = (k < 4) ? cc.yxy : ((k == 4) ? cc.yxx : cc.xyx);\n      ut = abs (ut) * vec2 (1., 1.2);\n      if (Maxv2 (abs (ut)) < 0.025 && Maxv2 (ut) > 0.02) col = cc.xxy;\n    }\n  }\n  for (int k = 6; k < 10; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw;\n    if (Maxv2 (ust) < 0.) {\n      col = cc.xxx * ((Minv2 (abs (ust)) * canvas.y < 2.) ? 0.3 : 0.6);\n      s = ShowInt (ut - vec2 (0.01, -0.01), 0.022 * vec2 (asp, 1.), 2., vW[k]);\n      if (s > 0.) col = (k == 6) ? cc.yxy : ((k == 7) ? cc : ((k == 8) ? cc.yyx : cc.xxy));\n    }\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvec3 TrkPos (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid FlyerPM (float t, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, acc, va, flVd, fpF, fpB;\n  vec2 cs;\n  float oRl, dt, vm;\n  dt = 0.5;\n  flPos = TrkPos (t);\n  fpF = TrkPos (t + dt);\n  fpB = TrkPos (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  vm = length (vel);\n  va = cross (acc, vel) / max (vm, 0.001);\n  flVd = (vm > 0.) ? vel / vm : vec3 (0.);\n  oRl = 2. * length (va) * sign (va.y);\n  oRl = smoothstep (0.02, 0.05, abs (oRl)) * oRl;\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 stDat, mPtr, wgBxC, parmV1, parmV2, parmV3, c4;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, hSum;\n  float el, az, asp, zmFac, sr, dt, tCur, tCurM, mvTot, h;\n  int wgSel, noInt;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  parmV1 = Loadv4 (0);\n  hFac = 1. + parmV1.x;\n  fWav = 1.5 + 0.7 * parmV1.y;\n  aWav = 0.1 + 0.5 * parmV1.z;\n  smFac = 0.3 + 0.7 * parmV1.w;\n  parmV2 = Loadv4 (1);\n  htWat = 8. * parmV2.x;\n  parmV3 = Loadv4 (2);\n  grType = int (parmV3.x);\n  qType = int (parmV3.y);\n  shType = int (parmV3.z);\n  refType = int (parmV3.w);\n  stDat = Loadv4 (3);\n  el = stDat.x;\n  az = stDat.y;\n  tCur = stDat.z;\n  tCurM = stDat.w;\n  stDat = Loadv4 (4);\n  mvTot = stDat.x;\n  noInt = int (stDat.y);\n  stDat = Loadv4 (5);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  if (qType == 1) {\n    dstFar = 170.;\n    stepLim = 100;\n    stepFac = 1.;\n  } else if (qType == 2) {\n    dstFar = 220.;\n    stepLim = 200;\n    stepFac = 0.5;\n  } else if (qType >= 3) {\n    dstFar = 300.;\n    stepLim = 300;\n    stepFac = 0.33;\n  }\n  if (shType == 1) sunDir = normalize (vec3 (1., 2., -1.));\n  else if (shType == 2) sunDir = normalize (vec3 (1., 1.5, -1.));\n  else if (shType == 3) sunDir = normalize (vec3 (1., 1., -1.));\n  FlyerPM (mvTot, ro, flMat);\n  dt = 0.3;\n  hSum = vec2 (0.);\n  for (float k = -2.; k < 8.; k ++)\n     hSum += vec2 (GrndHt (TrkPos (mvTot + k * dt).xz), 1);\n  ro.y = max (4. * hFac + hSum.x / hSum.y, htWat + 6.);\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.5;\n  if (abs (uv.y) < 0.9) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif\n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      uvv /= zmFac;\n      rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n      rd = (vuMat * rd) * flMat;\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = vec3 (0.05);\n  if (noInt > 0 || tCur - tCurM < 6.) {\n    c4 = ShowWg (uv, canvas, parmV1, parmV2, parmV3);\n    c4 = vec4 (mix (col, c4.rgb, c4.a),\n       ((noInt > 0) ? 0.3 : 0.2 + 0.8 * smoothstep (5., 6., tCur - tCurM)));\n  } else {\n    wgBxC = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n    c4 = vec4 (0.7, 0.7, 0., 0.3 + 0.7 * smoothstep (1., 2.,\n       abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y));\n  }\n  col = mix (c4.rgb, col, c4.a);\n  if (mPtr.z > 0. && wgSel < 0) {\n    if (Maxv2 (abs (uv)) < 0.05 && Minv2 (abs (uv)) < 0.005)\n       col = mix (col, vec3 (1., 1., 0.1), 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, vec2 (1., 57.)));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Terrain Explorer 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.1415927;\nconst float txRow = 32.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[10], wgBxC, mPtr, mPtrP, stDat, parmV1, parmV2, parmV3;\n  vec2 iFrag, canvas, ust;\n  float tCur, tCurP, tCurM, vW, asp, el, az, flyVel, mvTot;\n  int pxId, wgSel, wgReg, kSel, grType, qType, shType, refType, noInt;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 6) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  if (iFrame <= 2) {\n    parmV1 = vec4 (0.6, 0.6, 0.8, 0.6);\n    parmV2 = vec4 (0.2, 0.3, 0., 0.);\n    parmV3 = vec4 (1., 2., 2., 1.);\n    el = -0.05 * pi;\n    az = 0.;\n    mvTot = 0.;\n    mPtrP = mPtr;\n    tCurP = tCur;\n    tCurM = tCur;\n    noInt = 1;\n  } else {\n    parmV1 = Loadv4 (0);\n    parmV2 = Loadv4 (1);\n    flyVel = parmV2.y;\n    parmV3 = Loadv4 (2);\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    tCurP = stDat.z;\n    tCurM = stDat.w;\n    stDat = Loadv4 (4);\n    mvTot = stDat.x;\n    noInt = int (stDat.y);\n    mvTot += 8. * flyVel * (tCur - tCurP);\n    if (mvTot > 4000.) mvTot = 0.;\n    stDat = Loadv4 (5);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 6; k ++)\n       wgBx[k] = vec4 (0.36 * asp, 0.25 - 0.06 * float (k), 0.12 * asp, 0.018);\n    for (int k = 6; k < 10; k ++)\n       wgBx[k] = vec4 ((0.29 + 0.05 * float (k - 6)) * asp, -0.25, 0.024, 0.024);\n    wgBxC = vec4 (0.47 * asp, -0.4, 0.022, 0.);\n    for (int k = 0; k < 10; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    ust = mPtr.xy * vec2 (asp, 1.) - wgBxC.xy;\n    if (length (ust) < wgBxC.z) wgReg = 10;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    if (wgSel >= 0 || noInt > 0) tCurM = tCur;\n    noInt = 0;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x;\n      el = -0.05 * pi + 0.8 * pi * mPtr.y;\n    } else {\n      el = mix (el, -0.05 * pi, 0.02);\n      az = mix (az, 0., 0.02);\n    }\n  } else {\n    if (wgSel < 6) {\n      for (int k = 0; k < 6; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.x * asp - wgBx[k].x) / wgBx[k].z, 0., 0.99);\n          break;\n        }\n      }\n      if      (kSel == 0) parmV1.x = vW;\n      else if (kSel == 1) parmV1.y = vW;\n      else if (kSel == 2) parmV1.z = vW;\n      else if (kSel == 3) parmV1.w = vW;\n      else if (kSel == 4) parmV2.x = vW;\n      else if (kSel == 5) parmV2.y = vW;\n    } else if (mPtrP.z <= 0.) {\n      if (wgSel == 6) {\n        grType = int (parmV3.x);\n        if (++ grType > 4) grType = 1;\n        parmV3.x = float (grType);\n      } else if (wgSel == 7) {\n        qType = int (parmV3.y);\n        if (++ qType > 3) qType = 1;\n        parmV3.y = float (qType);\n      } else if (wgSel == 8) {\n        shType = int (parmV3.z);\n        if (++ shType > 3) shType = 1;\n        parmV3.z = float (shType);\n      } else if (wgSel == 9) {\n        refType = int (parmV3.w);\n        if (++ refType > 2) refType = 1;\n        parmV3.w = float (refType);\n      }\n    }\n  }\n  if      (pxId == 0) stDat = parmV1;\n  else if (pxId == 1) stDat = parmV2;\n  else if (pxId == 2) stDat = parmV3;\n  else if (pxId == 3) stDat = vec4 (el, az, tCur, tCurM);\n  else if (pxId == 4) stDat = vec4 (mvTot, float (noInt), 0., 0.);\n  else if (pxId == 5) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1802, 1802, 1826, 1826, 2106], [2108, 2108, 2132, 2132, 2491], [2493, 2493, 2517, 2517, 3002], [3004, 3004, 3028, 3028, 3542], [3544, 3544, 3567, 3567, 3769], [3771, 3771, 3794, 3794, 3826], [3828, 3828, 3862, 3862, 4348], [4350, 4350, 4374, 4374, 4423], [4425, 4425, 4447, 4447, 4702], [4704, 4704, 4741, 4741, 4993], [4995, 4995, 5017, 5017, 5090], [5092, 5092, 5124, 5124, 5345], [5347, 5347, 5382, 5382, 7357], [7359, 7359, 7434, 7434, 9145], [9147, 9147, 9170, 9170, 9283], [9285, 9285, 9341, 9341, 9942], [9944, 9944, 10000, 10000, 12780], [12782, 12782, 12805, 12805, 12909], [12982, 12982, 13014, 13014, 13562], [13564, 13564, 13624, 13624, 14166], [14168, 14168, 14190, 14190, 14217], [14219, 14219, 14241, 14241, 14268], [14270, 14270, 14300, 14300, 14413], [14415, 14415, 14451, 14451, 14657], [14691, 14691, 14715, 14715, 14827], [14829, 14829, 14853, 14853, 14916], [14918, 14918, 14943, 14943, 15127], [15129, 15129, 15150, 15150, 15305], [15307, 15307, 15332, 15332, 15676], [15678, 15678, 15707, 15707, 15919], [15921, 15921, 15960, 15960, 16212], [16305, 16305, 16330, 16330, 16453]], "test": "untested"}
{"id": "sd3XW2", "name": "Alien Embryo 2", "author": "xenn", "description": "Wouldn't be out of place in her ship", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 2, "viewed": 203, "published": 3, "date": "1633961032", "time_retrieved": "2024-07-30T18:56:47.287520", "image_code": "\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = min(col,col2);\n                      color += max(col2,col);\n                      col2 = mix(col2,color,0.05);\n                     col2 = max(col,color);\n                      \n                       \n   //   color = max(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (max(col,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,0.005);\n     vec4 blendy = min(col2,col);\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n   //    blend = min(blend,blendy);\n       blend = mix(blend,blendo,0.5);\n       blend = min(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col + col2)  * (blendo - blendy);\n  fragColor=blend,(fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Margins 0.\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst float iFeedbackZoomRate         = .003;\nconst float iFeedbackFadeRate         = .99;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .006;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 1.25;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .15;\nconst float iBlob1PowFactor           = 40.;\nconst float iBlob1ColorPulseSpeed     = .13;\nconst float iBlob2Radius              = .2;\nconst float iBlob2PowFactor           = 40.;\nconst float iBlob2ColorPulseSpeed     = .2;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = 2.7;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    vec2 iFeedbackZoomCenter = vec2(sin(iTime * .6), cos(iTime * .7)) * .2;\n    vec2 iDrawCenter = iFeedbackZoomCenter;\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.) \n    ) * vec3(.9, .6, 1.);\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    ) * vec3(.9, .6, 1.);\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel1,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.br - .5) * iFeedbackColorShiftImpact * vec2(sin(iTime * .2), cos(iTime * .3));\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ================================================================================================\n//\n// MAGIC LOADER ANIMATION\n// original: https://www.shadertoy.com/view/td3czf\n// modified by Krischan\n//\n// ================================================================================================\n\nfloat SCALE = 0.5;\nfloat SPEED = 0.25;\nfloat INTENSITY = 20.0;\nfloat LENGTH = 0.5;\nfloat RADIUS = 0.020;\nfloat FADING = 0.125;\nfloat GLOW = 2.0;\n\n#define M_2_PI 6.28318530\n\n// optimized 2d version of https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 circle(float t){\n    float x = SCALE * sin(t);\n    float y = SCALE * cos(t);\n    return vec2(x, y);\n}\n\nvec2 leminiscate(float t){\n    float x = (SCALE * (cos(t) / (1.0 + sin(t) * sin(t))));\n    float y = (SCALE * (sin(t) * cos(t) / (1.0 + sin(t) * sin(t))));\n    return vec2(x, y);\n}\n\n// inspired by https://www.shadertoy.com/view/wdy3DD\nfloat mapinfinite(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = leminiscate(t * M_2_PI);\n    vec2 p2 = leminiscate((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = leminiscate((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nfloat mapcircle(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = circle(t * M_2_PI);\n    vec2 p2 = circle((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = circle((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    float dist1 = mapcircle(uv.yx*vec2(1.0,0.66),1.0);\n\tfloat dist2 = mapinfinite(uv.xy*vec2(0.66,1.0),2.0);\n\tfloat dist3 = mapcircle(uv.xy*vec2(1.0,0.88),4.0);\n    \n    vec3 col1 = vec3(1.0, 0.55, 0.25) * pow(RADIUS/dist1, GLOW);\n\tvec3 col2 = vec3(0.55, 1.00, 0.25) * pow(RADIUS/dist2, GLOW);\n\tvec3 col3 = vec3(0.25, 0.55, 1.00) * pow(RADIUS/dist3, GLOW);\n\t\n\tvec3 col=(col1+col2+col3)*(2.*GLOW);\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,0.005);\n     vec4 blendy = mix(col2,col,0.9);\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n   //    blend = min(blend,blendy);\n       blend = min(blend,blendo);\n       blend = min(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col * col2)  + blend * col;\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3XW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 139, 139, 218], [220, 220, 243, 243, 398], [400, 400, 457, 457, 1807]], "test": "untested"}
{"id": "sstSWS", "name": "black&white heart", "author": "Kornelius", "description": "2d heart.", "tags": ["gradient", "heart", "blackwhite"], "likes": 1, "viewed": 208, "published": 3, "date": "1633959509", "time_retrieved": "2024-07-30T18:56:48.184122", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\n\n float heart( in vec2 p, in float r ) \n{\n    vec2 s = vec2(1.0, 0.0);\n    \n    p = p-s.xy;\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(.25,.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (3.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n\tfloat d = heart(p,.5);\n    \n\t// coloring\n    vec3 col = vec3(.1) - sign(d)*sin(iTime+p.y+vec3(0,0,0));\n     \n    col *= 1.0 - exp(-9.0*abs(d));\n\t\n\n   \n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [47, 47, 86, 86, 353], [357, 357, 414, 414, 663]], "test": "untested"}
{"id": "7d3XRX", "name": "Ghost Shader ver 01", "author": "byt3_m3chanic", "description": "Ghost Shader ver 01 - Mouseable - I have some ideas but need to experiment more - however thought this was cute..", "tags": ["raymarching", "refraction", "ghost", "isometric", "glitter"], "likes": 17, "viewed": 396, "published": 3, "date": "1633958592", "time_retrieved": "2024-07-30T18:56:49.144554", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Ghostsssss\n    10/09/21 @byt3_m3chanic\n    \n    Again we're just moving one domain / then loops\n    but I'm making the ID's advace using floor(T*.1)\n    which matching the timing for the loop movement.\n\n    I started doing this to prevent artifacts that \n    seem to distort the more you move a scene with time\n    / distance or large values.\n    \n    Just playing - like the ghost from a previous\n    shader / anisiotropic effects for glitter and\n    some transparency / refraction.\n    \n    thanks @blackle / @iq / @tachyonflux\n\n*/\n\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MAX_DIST    100.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq sdf shapes\t\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cap( vec3 p, float r,float h ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat vcap( vec3 p, float h, float r ){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sunion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// globals\nvec3 hit,hitPoint;\nvec2 gid,sid;\nmat2 r45,rn45,r25,turn;\nfloat tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,glow=0.;\n\nfloat eyes(vec3 p) {\n    float res = 1e5;\n    vec3 q = p-vec3(0,.5,0);\n    vec3 e1 = vec3(abs(q.x),q.yz);\n\n    float eye = length(e1-vec3(.57,.65,.8))-.15;\n    if(eye<res) {\n        res = eye;\n    } \n    glow += smoothstep(.1,.25,.003/(.0145+eye*eye)); \n    return res;\n}\n\nfloat ghost(vec3 p, float hs) {\n    float res = 1e5;\n    vec3 q = p-vec3(0,-1.25,0);\n    \n    vec3 q2=q-vec3(0,1.5,.25);\n    vec3 q3=vec3(abs(q.x),q.yz)-vec3(.5,2.72,1.25);\n    vec3 q4 = q-vec3(0,2.72,1.65);\n    q4.x=abs(q4.x);q4.xz*=r25;\n    \n    float ghst = vcap(q,2.75,1.6);\n    float eyes = length(q3)-.45;\n    float lids = torus(q4-vec3(.53,0,0),vec2(.4,.05));\n    float chst = vcap(q,2.7,1.25);\n\n    float a = atan(q.z,q.x);\n    float tw = .2*sin(a*6.);\n    tw *=pow(length(q.xz),1.);\n    \n    float cuting = cap(q+vec3(0,1.,0),1.-tw,1.65)*.75;\n    \n    ghst = max(ghst,-cuting);\n    ghst = max(ghst,-eyes);\n    ghst = sunion(lids,ghst,.08);\n    ghst = max(ghst,-chst);\n    \n    if(ghst<res ) {\n        res = ghst;\n    }\n\n    return res;\n}\n\nconst float size = 6.;\nconst float hlf = size/2.;\nconst float blx = hlf*.95;\nconst float hlx = hlf*.825;\nconst float dbb = size*4.;\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n    \n    //prevent scene from moving\n    //just having ID's change\n    if(ga4>0.) q.z+=ga4*dbb;\n    vec3 tq = q;\n    tq.z+=floor(T*.1)*dbb;\n    \n    vec2 id = floor((tq.xz+hlf)/size);\n\n    q.xz=mod(q.xz+hlf,size)-hlf;\n    float hs = hash21(id+floor(T*.1));\n\n    float th = .7;\n    float ofs = ga2*10.;\n    vec3 q4 = q+vec3(0,6.85,0);\n\n    float tile = box(q4,vec3(blx,5.1,blx))-.125;\n    if(ga1>0.&&hs>th) {\n        tile=max(tile,-(length(q4.xz)-(hlx*(ga1-ga3))) );\n    }\n    \n    if(tile<res.x) {\n        res = vec2(tile,2.);\n        hitPoint=q4;\n        gid=id;\n    } \n\n    float mof = hs*3.+T*hs;\n    q.xz*=rot(hs*36.);\n    float hp = .6*sin(T*3.+mof);\n    \n    vec3 q2=q-vec3(.1*sin(q.x+T*3.5),-7.7+ofs+hp,.6+.15*cos(q.x+T*2.5));\n    vec3 q1=q-vec3(0,-8.+ofs+hp,0);\n\n    float ghst = hs>th?ghost(q1,hs):1.;\n    if(ghst<res.x && (p.y>-3.75)) {\n        res = vec2(ghst,1.);\n        hitPoint=q1;\n    }  \n\n    float brain = hs>th?eyes(q2):1.;\n    if(brain<res.x && (p.y>-3.75)) {\n        res = vec2(brain,4.);\n        hitPoint=q2;\n    } \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n// cheap hash noise\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), .001);\n    n /= dot(n, vec3(1));\n\tfloat tx = hash21(floor(p.xy));\n    float ty = hash21(floor(p.zx));\n    float tz = hash21(floor(p.yz));\n    return vec3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n// glintz adapted and redux - original @tachyonflux\n// https://www.shadertoy.com/view/ll2fzt\nvec3 glintz( vec3 lcol, vec3 hitPoint, vec3 n, vec3 rd, vec3 lpos) {\n    vec3 mate;\n    vec3 pos = hitPoint;\n    \n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    \n    for(int i = 0; i < 2;i++) {\n        float pw = i==0?.20*R.x:.10*R.x;\n        vec3 tcoord = i==0?coord:coord2;\n        vec3 aniso = vec3(vor3D(2.-tcoord*pw,n).yy, vor3D(3.-tcoord.zyx*pw,n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n        float anisotropy = i==0?.55:.6;\n        float ah = abs(dot(h,aniso));\n        float q = exp2(((i==0?1.15:.1)-anisotropy)*1.5);\n        nh = pow( nh, q*(i==0?4.:.4) );\n        nh *= pow( 1.-ah*anisotropy, i==0?10.:150. );\n        glints += \n        (lcol*nh*exp2(((i==0?1.2:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n\n    float fresnel = pow(1.0 + dot(n,rd), 2.0);\n    fresnel = mix( 0.0, 0.95, fresnel );\n\n    vec3 reflection = vec3(0);\n    return \n        mix(light*vec3(0.3), reflection, fresnel) +\n        glints +\n        reflection*0.015*(clamp(nl,0.,1.))+ reflection*0.05 +\n        lcol * .3;\n}\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 c = vec3(0.953,0.929,0.886),\n         d = vec3(0.553,0.227,0.949);\n    return vec3(.35) + vec3(.25)*cos( PI*(c*t+d) ); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.001);\n    float csx = 17.*sin(T*.35);\n    vec3 lpos = vec3(0,25,0);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.5);\n    fresnel = mix(.01, .7, fresnel);\n\n    vec3 h = vec3(.5);\n\n    if(m==1.) h=glintz(hue(55.323+hash21(sid+2.))*.5, hit*.075, n, rd, l);\n    if(m==2.) {\n        float chk = mod(sid.y+sid.x,2.)*2.-1.;\n        vec3 clr = chk>.5?vec3(0.282,0.082,0.337):hue(sid.y+sid.y);\n        clr=mix(clr,vec3(.1),hit.y<4.55?clamp(.5-(hit.y-3.55)*.5,0.,1.):0.);\n        h=glintz(clr, hit*.075, n, rd, l);\n    }\n\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) { \n\n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    // precal all your vars!\n    r25=rot(-.28);\n    float time = T;\n    \n    tmod = mod(time, 10.);\n    float t1 = lsp(0.5, 1.0, tmod);\n    float t2 = lsp(7.5, 8.0, tmod);\n    \n    float t3 = lsp(1.0, 1.5, tmod);\n    float t4 = lsp(6.5, 7.5, tmod);\n    \n    float t5 = lsp(1.5, 2.5, tmod);\n    float t6 = lsp(5.5, 6.5, tmod);\n    \n    float t7 = lsp(8.0,10., tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n    \n    ga2 = eoc(t3-t4);\n    ga2 = ga2*ga2*ga2;\n    \n    ga3 = eoc(t5-t6);\n    ga3 = ga3*ga3*ga3;\n    \n    ga4 = eoc(t7);\n    ga4 = ga4*ga4*ga4;\n\n    //zoom slice per uv.x\n    float dz = .38+.18*sin(uv.y*2.3+T);\n    //zoom levels\n    float zoom = 14.;\n    if(uv.x> dz) zoom=21.;\n    if(uv.x<-dz) zoom=42.;\n    \n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0,0,1.);\n    \n    // mouse\n    float y = M.xy == vec2(0) ? 0. :  (M.x/R.x * 2. - 1. ) * PI;\n\n    mat2 rx =rot(.485);\n    mat2 ry =rot(-2.45+y-T*.125);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n    \n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    float k = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<200;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = ray.x * .7;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-8) {\n            hit=hitPoint;\n            sid=gid;\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m==2.) break;\n            \n            atten *= .65;\n            p += rd*.1;\n            k = sign(map(p).x)*.9;\n            \n            fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n            fresnel = mix(.0, .9, fresnel);\n\n            vec3 rr = refract(rd,n,.8);\n            rd=mix(rr,rd,.5-fresnel);\n  \n        }  \n        if(distance(p,rd)>80.) { break; }\n    }\n    \n    float glowMask = clamp(glow,.0,1.);\n    C = mix(C,vec3(0.145,0.659,0.914)*glow,glowMask);\n    float px = fwidth(uv.x);\n    if(uv.x<px-dz&& uv.x>-(dz+px)) C = vec3(1);\n    if(uv.x>(dz-px)&& uv.x<(dz+px)) C = vec3(1);\n    C=clamp(C,vec3(0),vec3(1));\n    \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n//end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[806, 806, 826, 826, 871], [872, 872, 896, 896, 954], [955, 955, 999, 999, 1054], [1055, 1055, 1075, 1075, 1113], [1115, 1133, 1161, 1161, 1248], [1250, 1250, 1287, 1287, 1398], [1400, 1400, 1430, 1430, 1495], [1497, 1497, 1536, 1536, 1599], [1601, 1601, 1646, 1646, 1745], [1874, 1874, 1894, 1894, 2145], [2147, 2147, 2178, 2178, 2893], [3028, 3028, 3045, 3045, 4147], [4149, 4218, 4263, 4263, 4489], [4491, 4511, 4545, 4545, 4745], [4747, 4840, 4908, 4908, 6101], [6103, 6150, 6168, 6168, 6300], [6302, 6302, 6363, 6363, 6996], [6998, 6998, 7039, 7039, 9288]], "test": "untested"}
{"id": "sscXDj", "name": "U-he Hive 2 Izmo Knob", "author": "Lastminute", "description": "https://u-he.com/products/hive/", "tags": ["knob"], "likes": 12, "viewed": 511, "published": 3, "date": "1633957137", "time_retrieved": "2024-07-30T18:56:50.171808", "image_code": "precision lowp float;\n\n#define PI 3.1415926\n\nvec4 overlay(vec4 a, vec4 b)\n{\n\tfloat f = a.a + b.a * (1.0 - a.a);\n\treturn vec4((a.rgb * a.a + b.rgb * b.a * (1.0 - a.a)) / f, f);\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nmat2 rotate2d(float angle){\n\treturn mat2(-cos(angle), sin(angle), -sin(angle), -cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * 1.25;\n\n\tfloat av =  0.2 * PI + (iMouse.x / iResolution.x) * 2.0 * PI * 0.8;\n    float aa = 1.0 / ((iResolution.x + iResolution.y) / 2.0);\n\tfloat a = atan(uv.x, uv.y) - av;\n\tfloat l = length(uv);\n\n\tvec4 c1 = vec4(0.224, 0.224, 0.224, 1.0);\n\tvec4 l1 = vec4(0.733, 0.733, 0.733, 1.0);\n\n\tfloat cap_df = cos(a * 7.0) / 50.0 + l;\n\tfloat line_df = line(uv * rotate2d(av), vec2(0.0, 0.15), vec2(0.0, 0.3));\n\tfloat border_f = smoothstep(cap_df - aa, cap_df + aa, 0.375) * smoothstep(l + 0.1, l, 0.375) * 0.025;\n\n\tvec2 s_off = vec2(-0.15, 0.15);\n\t\n\tvec4 bg = vec4(0.737, 0.737, 0.737, 1.0);\n\tvec4 bottom = vec4(c1.rgb, smoothstep(l - aa, l + aa, 0.5));\n\tvec4 shadow = vec4(vec3(0.0), smoothstep(length(uv + s_off) - 0.2, length(uv + s_off) + 0.2, 0.4) * 0.4);\n\tvec4 cap_s = vec4(vec3(0.0), smoothstep(cap_df - 0.05, cap_df + 0.05, 0.375) * 0.4);\n\tvec4 cap = vec4(c1.rgb, smoothstep(cap_df - aa, cap_df + aa, 0.375));\n\tvec4 border = vec4(vec3(1.0), border_f);\n\tvec4 light = vec4(vec3(1.0), smoothstep(cap_df + aa, cap_df - aa, 0.36) * smoothstep(cap_df - aa, cap_df + aa, 0.375) * pow((uv.y - 0.5 * uv.x) / 2.0 + 0.5, 5.0) * 0.75);\n\tvec4 line = vec4(l1.rgb, smoothstep(line_df - aa, line_df + aa, 0.04));\n\n\tvec4 colour = vec4(0.0);\n\n\tcolour = overlay(bg, colour);\n\tcolour = overlay(bottom, colour);\n\tcolour = overlay(shadow, colour);\n\tcolour = overlay(cap_s, colour);\n\tcolour = overlay(cap, colour);\n\tcolour = overlay(border, colour);\n\tcolour = overlay(light, colour);\n\tcolour = overlay(line, colour);\n\n\tfragColor =  colour;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 75, 75, 177], [179, 179, 226, 226, 351], [353, 353, 380, 380, 447], [449, 449, 504, 504, 2090]], "test": "untested"}
{"id": "sd3XDj", "name": "Alien Embryo", "author": "xenn", "description": "Wouldn't be out of place in her ship", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 7, "viewed": 283, "published": 3, "date": "1633954300", "time_retrieved": "2024-07-30T18:56:51.681770", "image_code": "// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      col = min(col,col2);\n                      color += max(col2,col);\n                      col2 = mix(col2,color,0.05);\n                     col2 = min(col,color);\n                      \n                       \n      color = max(col,color);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (min(col,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,0.005);\n     vec4 blendy = min(col2,col);\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n   //    blend = min(blend,blendy);\n       blend = mix(blend,blendo,0.5);\n       blend = min(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col + col2)  * (blendo - blendy);\n  fragColor=blend,(fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Margins 0.\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst float iFeedbackZoomRate         = .003;\nconst float iFeedbackFadeRate         = .99;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .006;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 1.25;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .15;\nconst float iBlob1PowFactor           = 60.;\nconst float iBlob1ColorPulseSpeed     = .13;\nconst float iBlob2Radius              = .2;\nconst float iBlob2PowFactor           = 60.;\nconst float iBlob2ColorPulseSpeed     = .2;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = 1.7;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    vec2 iFeedbackZoomCenter = vec2(sin(iTime * .6), cos(iTime * .7)) * .2;\n    vec2 iDrawCenter = iFeedbackZoomCenter;\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.) \n    ) * vec3(.9, .6, 1.);\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    ) * vec3(.9, .6, 1.);\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel1,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.rg - .5) * iFeedbackColorShiftImpact * vec2(sin(iTime * .2), cos(iTime * .3));\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ================================================================================================\n//\n// MAGIC LOADER ANIMATION\n// original: https://www.shadertoy.com/view/td3czf\n// modified by Krischan\n//\n// ================================================================================================\n\nfloat SCALE = 0.5;\nfloat SPEED = 0.25;\nfloat INTENSITY = 20.0;\nfloat LENGTH = 0.5;\nfloat RADIUS = 0.020;\nfloat FADING = 0.125;\nfloat GLOW = 2.0;\n\n#define M_2_PI 6.28318530\n\n// optimized 2d version of https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 circle(float t){\n    float x = SCALE * sin(t);\n    float y = SCALE * cos(t);\n    return vec2(x, y);\n}\n\nvec2 leminiscate(float t){\n    float x = (SCALE * (cos(t) / (1.0 + sin(t) * sin(t))));\n    float y = (SCALE * (sin(t) * cos(t) / (1.0 + sin(t) * sin(t))));\n    return vec2(x, y);\n}\n\n// inspired by https://www.shadertoy.com/view/wdy3DD\nfloat mapinfinite(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = leminiscate(t * M_2_PI);\n    vec2 p2 = leminiscate((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = leminiscate((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nfloat mapcircle(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = circle(t * M_2_PI);\n    vec2 p2 = circle((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = circle((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    float dist1 = mapcircle(uv.yx*vec2(1.0,0.66),1.0);\n\tfloat dist2 = mapinfinite(uv.xy*vec2(0.66,1.0),2.0);\n\tfloat dist3 = mapcircle(uv.xy*vec2(1.0,0.88),4.0);\n    \n    vec3 col1 = vec3(1.0, 0.55, 0.25) * pow(RADIUS/dist1, GLOW);\n\tvec3 col2 = vec3(0.55, 1.00, 0.25) * pow(RADIUS/dist2, GLOW);\n\tvec3 col3 = vec3(0.25, 0.55, 1.00) * pow(RADIUS/dist3, GLOW);\n\t\n\tvec3 col=(col1+col2+col3)*(2.*GLOW);\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[3]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n//  vec4 blend = mix(col,col2,0.05);\n   vec4 blend = mix(col,col2,0.005);\n     vec4 blendy = mix(col2,col,0.9);\n     vec4 blendo = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n   //    blend = min(blend,blendy);\n       blend = min(blend,blendo);\n       blend = min(blend,blendy);\n// blend = blendo*blendy ;\n//  blend = (col * col2)  + blend * col;\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3XDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 138, 138, 217], [219, 219, 242, 242, 397], [399, 399, 456, 456, 1804]], "test": "untested"}
{"id": "fd3XD2", "name": "SDFPainting", "author": "Del", "description": "Playing around with blending and painting primitives smoothly - mouse to look around", "tags": ["sdf", "color", "blend", "paint", "smin", "smax"], "likes": 5, "viewed": 306, "published": 3, "date": "1633944958", "time_retrieved": "2024-07-30T18:56:52.454705", "image_code": "// a simple (smooth) union / subtraction / paint CSG test with some color blend tightness control for some voxel stuff - 10/10/2021\n\n#define AA 1\t// make this 2 if you are feeling cold...\n\nvec3 _basecol = vec3(0.0);\t// pure filth\n\n// prims\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nfloat sminCol( float a, float b, float k, vec3 col1,float coltightness)\n{\n    if (k<=0.0)\n    {\n        // no smooth...\n        if (a>b)\n        {\n            _basecol = col1;\n            return b;\n        }\n        return a;\n    }\n    // smoothed...\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smaxCol( float a, float b, float k, vec3 col1, float coltightness)\n{\n    if (k<=0.0)\n    {\n        if (a<=-b)\n        {\n            _basecol = col1;\n            return -b;\n        }\n        return a;\n    }\n    //return smin(a, -b, -k);// subtract\n    //return smin(a, b, -k); // intersection\n    b=-b;\n    k=-k;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// same as smaxCol but without the distance blend (so, just paint a shape)\nvoid PaintSmooth(float a,float b, float k, vec3 col1,  float coltightness)\n{\n    if (k<=0.0)\n    {\n        // no smooth...\n        if (a<=-b)\n            _basecol = col1;\n        return;\n    }\n    // smoothed...\n    b=-b;\n    k=-k;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);\n}\n\n\n\n\nfloat map( in vec3 pos )\n{\n    float dist_cylinder = sdCylinder(pos+vec3(2.0,1.0,0.0),vec2(1.2,2.5));\n    float dist_sphere1 = sdSphere(pos+vec3(0.0,0.0,0.0),1.8);\n    float dist_sphere2 = sdSphere(pos+vec3(2.0,-1.0,0.0),1.8);\n    float dist_box = sdBox(pos+vec3(-.5,0.0,0.0),vec3(2.1,0.4,0.4));\n\n    // paint shapes\n    float dist_box2 = sdBox(pos+vec3(2.0,0.5,0.0),vec3(0.2,0.5,0.2));\n    float dist_cylinder2 = sdCylinder(pos+vec3(2.0,1.8,0.0),vec2(2.0,0.3));\n\n\n   float _basedist = 1000.0f;\n    _basecol = vec3(0.0);\n    vec3 redcol = vec3(1.0,0.1,0.1);\n    vec3 greencol = vec3(0.1,1.0,0.1);\n    vec3 bluecol = vec3(0.1,0.1,1.0);\n    vec3 yellowcol = vec3(1.0,1.0,0.1);\n    vec3 whitecol = vec3(1.0,1.0,1.0);\n     \n    float _coltightness = 0.5+sin(iTime)*0.5;//0=tight, 1=loose\n     \n    _basedist = sminCol(_basedist, dist_cylinder, 0.0, redcol, _coltightness);  // +red cylinder\n    PaintSmooth(_basedist, dist_cylinder2, 0.5, whitecol, _coltightness);// PAINT white cylinder (band)\n    _basedist = sminCol(_basedist, dist_sphere1, 0.5, greencol, _coltightness); // +green sphere\n    _basedist = smaxCol(_basedist, dist_box, 0.5, bluecol, _coltightness);      // -blue box\n    _basedist = smaxCol(_basedist, dist_sphere2, 0.5, yellowcol, _coltightness);// -yellow sphere\n    PaintSmooth(_basedist, dist_box2, 0.5,whitecol, _coltightness); // PAINT white cube (square)\n    return _basedist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.01;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n        float an = radians(-120.0);\n        float yoff = 3.0f;\n        if (iMouse.z>0.5)\n        {\n         an = an+(iMouse.x/iResolution.x)*6.28;\n         yoff = yoff+(5.0-((iMouse.y/iResolution.y)*15.0));\n        }\n\n    vec3 ro = vec3( 7.0*cos(an), yoff, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<200; i++ )// overkill\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 mycol = _basecol;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rd, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 64.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            col =  mycol*dif;\n            col+=spec;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3XD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 240, 276, 276, 375], [376, 376, 409, 409, 435], [436, 436, 467, 467, 554], [556, 578, 619, 619, 708], [709, 709, 748, 748, 777], [779, 779, 852, 852, 1238], [1240, 1240, 1314, 1314, 1766], [1768, 1843, 1919, 1919, 2245], [2250, 2250, 2276, 2276, 3649], [3651, 3651, 3683, 3683, 3929]], "test": "untested"}
{"id": "fd3SW2", "name": "Basic axis-aligned foveation", "author": "sctanf", "description": "Based off https://www.shadertoy.com/view/WddGz8# and https://www.shadertoy.com/view/3l2GRR\n\nClick to see source image\nPress \"U\" to see unsharpened image\nPress \"C\" to see compressed image", "tags": ["vr", "foveated", "foveation"], "likes": 0, "viewed": 258, "published": 3, "date": "1633940804", "time_retrieved": "2024-07-30T18:56:53.376240", "image_code": "// Composition and interaction\n\n#define key_c 67\n#define key_down(key) (texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sourceUV = fragCoord / iChannelResolution[0].xy;\n    \n    if (key_down(key_c)) {\n        fragColor = texture(iChannel1, fragCoord / iChannelResolution[1].xy);\n    } else if (!(iMouse.z > 0.)) {\n        fragColor = texture(iChannel2, fragCoord / iChannelResolution[1].xy);\n   \t} else if (sourceUV.x < 1. && sourceUV.y < 1.) {\n        fragColor = texture(iChannel0, sourceUV);\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SOURCE_RESOLUTION iChannelResolution[0].xy\n#define COMPRESSED_TO_SOURCE (k+(1.-k)/j)\n#define j vec2(hj,vj)\n//Pixel alignment\n#define l (vec2(ivec2((ual*(SOURCE_RESOLUTION-k*SOURCE_RESOLUTION))/(j*2.)))*(j*2.)/(SOURCE_RESOLUTION-k*SOURCE_RESOLUTION))\n#define ual vec2(hl,vl)\n//Pixel alignment\n#define k (1.-vec2(ivec2((SOURCE_RESOLUTION-uak*SOURCE_RESOLUTION)/(j*2.)))*(j*2.)/SOURCE_RESOLUTION)\n#define uak vec2(hk,vk)\n\n//Horizontal control\n//Center shift (-1.0 - 1.0)\n#define hl 0.4\n//Edge pixel compression ratio (>= 1)\n#define hj 2.\n//Center size (0.0 - 1.0)\n#define hk 0.5\n\n//Vertical control\n//Center shift (-1.0 - 1.0)\n#define vl 0.1\n//Edge pixel compression ratio (>= 1)\n#define vj 2.\n//Center size (0.0 - 1.0)\n#define vk 0.4\n\n#define SHARPEN_STRENGTH 0.5", "buffer_a_code": "// Compressed image\n\n#define sourceSampler iChannel0\n#define uv clamp(fragCoord / iChannelResolution[0].xy / COMPRESSED_TO_SOURCE, 0., 1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 alignedUV = uv;\n    \n    vec2 loBound = (1.-k)/2.*(l+1.)/((j-1.)*k+1.);\n    vec2 hiBound = (1.-k)/2.*(l-1.)/((j-1.)*k+1.)+1.;\n    vec2 underBound = vec2(alignedUV.x<loBound.x,alignedUV.y<loBound.y);\n    vec2 inBound = vec2(loBound.x<alignedUV.x&&alignedUV.x<hiBound.x,loBound.y<alignedUV.y&&alignedUV.y<hiBound.y);\n    vec2 overBound = vec2(alignedUV.x>hiBound.x,alignedUV.y>hiBound.y);\n    \n    vec2 center = alignedUV*((j-1.)*k+1.)/j+((1.-k)/(2.*j))*(j-1.)*(l+1.);\n    vec2 leftEdge = alignedUV*(j-(j-1.)*(1.-k));\n    vec2 rightEdge = (alignedUV-1.)*(j-(j-1.)*(1.-k))+1.;\n    \n    vec2 curveUV = underBound*leftEdge+inBound*center+overBound*rightEdge;\n    \n    fragColor = texture(sourceSampler, curveUV);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Uncompressed + sharpened image\n\n#define compressedSampler iChannel1\n#define blurredSampler iChannel1\n#define uv clamp(fragCoord / iChannelResolution[0].xy, 0., 1.)\n\n#define demo_convert_uv(uv) ((uv) * COMPRESSED_TO_SOURCE * iChannelResolution[0].xy / iResolution.xy)\n\n#define key_u 85\n#define key_down(key) (texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 alignedUV = uv;\n    \n    vec2 loBound = (1.-k)/2.*(l+1.);\n    vec2 hiBound = (1.-k)/2.*(l-1.)+1.;\n    vec2 underBound = vec2(alignedUV.x<loBound.x,alignedUV.y<loBound.y);\n    vec2 inBound = vec2(loBound.x<alignedUV.x&&alignedUV.x<hiBound.x,loBound.y<alignedUV.y&&alignedUV.y<hiBound.y);\n    vec2 overBound = vec2(alignedUV.x>hiBound.x,alignedUV.y>hiBound.y);\n    \n    vec2 center = j*(alignedUV+((1.-k)/(2.*j))*(1.-j)*(l+1.))/((j-1.)*k+1.);\n    vec2 leftEdge = alignedUV/((j-1.)*k+1.);\n    vec2 rightEdge = (alignedUV-1.)/((j-1.)*k+1.)+1.;\n    \n    vec2 curveUV = underBound*leftEdge+inBound*center+overBound*rightEdge;\n    curveUV = demo_convert_uv(curveUV);\n    \n    vec2 sharpenWeight = underBound+overBound;\n    \n    vec2 delta = 1./iChannelResolution[0].xy * sharpenWeight * SHARPEN_STRENGTH;\n    \n    vec3 currentColor = texture(blurredSampler, curveUV).rgb;\n    vec3 leftColor = texture(blurredSampler, curveUV - vec2(delta.x, 0.)).rgb;\n    vec3 rightColor = texture(blurredSampler, curveUV + vec2(delta.x, 0.)).rgb;\n    vec3 downColor = texture(blurredSampler, curveUV - vec2(0., delta.y)).rgb;\n    vec3 upColor = texture(blurredSampler, curveUV + vec2(0., delta.y)).rgb;\n    \n    vec3 finalColor = 5. * currentColor + -1. * (leftColor + rightColor + downColor + upColor);\n    \n    if (key_down(key_u)) {\n        fragColor = texture(compressedSampler, curveUV);\n    } else {\n        fragColor = vec4(finalColor,0.);\n    }\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 178, 178, 570]], "test": "untested"}
{"id": "NdcSDj", "name": "Segment Simplex Grid", "author": "Yusef28", "description": "simplex grid\nI had a look at the shader by flyguy: [url]https://www.shadertoy.com/view/ltfXWr[/url] \njust to make sure I was on the right track.\nMost of the lighting code is from Shane!\n ", "tags": ["simplex"], "likes": 20, "viewed": 415, "published": 3, "date": "1633938640", "time_retrieved": "2024-07-30T18:56:54.489264", "image_code": "#define FAR 50.\n\n/*\n\n//I found this pretty tricky.\n\n//First imagine just a regular grid and I want to make segments\n//from each center point out in for directions to the four neighboring\n//center points\n\n//but each cell ends half way out in all directions so ofcours\n//if I just extend the segments out from one cell, they will\n//touch the segments coming from the neighbouring cells so that's good\n//and it worked.\n\n//but for a simplex grid and for this aesthetic with segments, I need\n//a segment on the diagonal.\n\n//So I basically had to start a new grid shifted 0.5 on x and z\n//to get a new cell that allowed for segments on the diagonal \n//without getting cut off. BECAUSE for some reason, along the diagonal\n//if theyu get cut they don't just touch the neighbors. Instead\n//there are tons of artifacts.\n\n//so I'm using two coordinate systems and calculating the height\n//for 6 points (4 for the first system and 2 for the second)\n\n//and I'd honestly love to have small spheres or gems or something\n//at each vertex but the skewing skews the spheres so they look off.\n\n//I might come back and experiment more later though.\n\n*/\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    p/=1.9;\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    //f += 0.1250*noise( p ); p = m*p*2.01;\n    //f += 0.0625*noise( p ); \n    return f*1.3;\n}\n\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 snoise3( in float x )\n{\n#if 1    \n    return -1.0 + 2.0*textureLod( iChannel2, vec2(x,4.5)/256.0, 0.0 ).xyz;\n#else    \n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return -1.0 + 2.0*mix( hash3(p+0.0), hash3(p+1.0), f );\n#endif    \n}\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nfloat planeVonTri(vec3 p, vec3 A, vec3 B, vec3 C){\n    \n    vec3 BA = A - B;\n    vec3 CA = A - C;\n    vec3 n  = normalize(cross(BA,CA));\n    //where is the intersection of line and plane?\n    //plane = dot(n,P) = 0\n    //line = ro + rd*t = P\n    float t = dot(n,p-A);\n    \n return t;   \n}\nfloat seggy( vec3 P, vec3 A, vec3 B){\n    \n    //dist auf line segment zu punkt\n    //nahrest dist auf line zu punkt\n    //P = A + t*(B-A);\n    //dot((P-P3),(B-A)) = 0\n    //(A+t*(B-A)-P3)*(B-A)) = 0;\n    //A*(B-A)+t*(B-A)*(B-A)-P3*(B-A) = 0\n    //A*(B-A) - P3*(B-A) + t*(B-A)*(B-A)\n    //(A-P3)*(B-A) + t*(B-A)*(B-A)\n    //t = dot((A-P3),(B-A)) / dot((B-A),(B-A));\n    vec3 AP = P-A;\n    vec3 BA = B-A;\n    \n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n                    \n    vec3 P3 = A + t*BA;                \n    float dist = length(P - P3) - 0.03;\n    return dist;\n}\n\nmat2 rot(float a){\n    float cs = cos(a),si = sin(a);\n    return mat2(cs, si, -si, cs);\n}\n\n\nfloat objectID = 0.;\nfloat glow = 0.;\n\n//FROM DAVE HOSKINS\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n\nfloat map(vec3 p){\n    /*\n    float PosX, PosY;\n    PosX = 1.0 - iMouse.x/iResolution.x*4. + 0.5;//0.2*2.*(rechts - links);\n    PosY = 1.0 - iMouse.y/iResolution.y*4. + 1.5;\n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n\t//p*=0.9;*/\n    \n    p.xz *= mat2(1.1547, 0., 1.1547*0.5,1.);\n    float sphere_radius = 0.35;\n    vec3 sp = p;\n   // sp.y -= 0.23;\n    //float k = length(sp) - sphere_radius;\n    float alle = 100.;\n    //sp = p;\n    \n\n    //sp.y += 0.5;\n    //sp.xz *= rot(sp.y*3.);\n    \n    \n    \n    \n    sp.xz = fract(p.xz)-0.5;\n    vec2 id = floor(p.xz);\n    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);\n    float t = iTime;\n    \n    float gross = 1.3;\n    \n    float height = fbm4(id+t)*gross;\n    float heightL = fbm4((id + vec2(0.,1.))+t)*gross;\n    float heightR = fbm4((id + vec2(0.,-1.))+t)*gross;\n    float heightV = fbm4((id + vec2(-1.,0.))+t)*gross;\n    float heightH = fbm4((id + vec2(1.,0.))+t)*gross;\n    \n    \n    float k = seggy(sp, vec3(0.,height,0.), vec3(-1.,heightV,0.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0., heightL,1.0));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0.,heightR,-1.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(1.0,heightH,0.0));\n    alle = smin(alle, k, 0.);\n    \n    //k = length(sp - vec3(0.,height,0.))-0.03-ball_gross*0.037;\n    //alle = smin(alle, k, 0.);\n    \n    //k = seggy(sp - vec3(id.x, height, id.y), vec3(id.x, height, id.y), \n    //                   vec3(0.0,0.,0.0));\n    //alle = smin(alle, k, 0.);\n    \n    vec3 st = p;\n    \n    //this screwed me up for a (h)while\n   // st.y += 0.5;\n    \n    //HERE:\n    //I create a new shifted coord system so that I can get \n    //that pesky diagonal segment\n    st.xz = fract(p.xz-0.5)-0.5;\n    vec2 id2 = floor(p.xz-0.5);\n    \n    \n    //for floor here, actually:\n    //the mid point is the + 0.5,0.5\n    //the bottom is 0,0 because that is the floor value, id\n    //and the top would have to be + 1.,1.\n    \n    float heightDB = fbm4(id2 +t)*gross;\n    float heightDT = fbm4(id2 + vec2(1.) +t)*gross;\n    \n    /////\n    float heightTLT = fbm4(id2 + vec2(0.,1.) +t)*gross;\n    float heightBRB = fbm4(id2 + vec2(1.,0.) +t)*gross;\n    \n    //float heightMD = fbm4(id2 - vec2(0.5))*gross;\n    \n    //THE DIAGONAL!!\n    k = seggy(st, vec3(-0.5, heightDB, -0.5), \n                  vec3( 0.5, heightDT,  0.5) );\n                  \n    alle = smin(alle, k, 0.);\n    \n    //check which side of the diagonal of the square we are on\n    //and make a plane with the three coordinates of that triangle\n    float pl = st.x < st.z \n    \n                         ?\n                        \n               planeVonTri(st,\n                     vec3( 0.5, heightDT,  0.5),\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3(-0.5, heightTLT, 0.5) )\n                     \n                         : \n                        \n               planeVonTri(st,\n                     //you need to have this exact order for A,B and C!\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3( 0.5, heightDT,  0.5),\n                     \n                     vec3( 0.5, heightBRB, -0.5) );\n    \n    \n    //kind of a Shane x Nusan hybrid ID check\n    if(pl < 0.005){\n       // glow += 0.0001/pow(pl,0.2);\n        objectID = 1.;   \n    }\n    alle = min(alle, pl);\n\n   //\n   //alle = min(alle, length(st)-0.15);\n    return alle;// min(alle, sp.y+0.7-fbm4(p.xz));\n    \n}\n\n//FROM SHANE\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.95;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n//FROM SHANE\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n//FROM SHANE?\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n//FROM SHANE!\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = objectID == 1. ? vec3(.08,0.,0.) :vec3(.3,0.18,0.04)*0.7;//getObjectColor(sp);\n   // if(objectID == 2.) objCol = vec3(1.);\n    \n    float specFact = objectID == 1. ? 6. : 20.;\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff*8. + .15) + vec3(.8, .5, .2)*spec*specFact) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, pow(t/FAR,5.));\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0.3,0.051,0.), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    //rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    //rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 2. + sin(iTime)*0.1, -4.5 + iTime*4.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 2., 3.5);\n    \n    vec3 sceneColor;\n    float t = trace(ro, rd);\n    //sceneColor = mix(sceneColor, vec3(0.3,0.051,0.), clamp(pow(t/FAR, 20.),0.,1.));\n    if(t < FAR){\n    ro += rd*t;\n    vec3 sn = getNormal(ro);\n    sceneColor = doColor(ro, rd, sn, lp, t);\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n    \n   \n    \n\n   // sceneColor += texture(iChannel1,rd).xyz*0.01;\n    \n    sceneColor *= sh;\n    sceneColor += glow;\n    }\n    else{\n    \n    sceneColor = vec3(0.);//texture(iChannel1,rd).xyz*0.51;\n    //sceneColor += ;\n    \n    //sky gradient\n    sceneColor = mix(sceneColor, vec3(0.3,0.051,0.), pow(1.-uv.y,5.)*0.24);\n    \n    //stars\n    sceneColor = mix(sceneColor, \n                    vec3(0.9), \n                    pow(texture(iChannel2 ,uv).r, (80.)));\n                    \n    /*sceneColor = mix(sceneColor, vec3(0.,0.0,0.), \n                 1.-smoothstep(0.12,0.26,\n                 length(uv-vec2(0.0))-0.25));\n       */          \n                 //1.-smoothstep(0.18,0.2,length(uv)-0.25));\n    sceneColor = mix(sceneColor, vec3(0.9,0.5,0.1), \n                    clamp(pow(1.-(length(uv)-0.2),4.)*0.04, 0., 1.));\n                  \n    sceneColor = mix(sceneColor, vec3(0.9,0.5,0.1), \n                    clamp(pow(1.-(length(uv)-0.52),8.)*0.01, 0., 1.));\n      \n    sceneColor = mix(sceneColor, vec3(1.,0.75,0.5), \n                    clamp(pow(1.-(length(uv)-0.34),300.)*0.1, 0., 1.));\n      \n    \n    //sceneColor = mix(sceneColor, vec3(1.),  pow(1.-(length(uv)-0.4),60.));\n    \n    }\n   \n    \n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi acos(-1.)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1186, 1186, 1212, 1212, 1241], [1243, 1243, 1265, 1265, 1475], [1478, 1478, 1501, 1501, 1595], [1597, 1597, 1625, 1625, 1866], [1867, 1867, 1918, 1918, 2025], [2026, 2026, 2066, 2066, 2173], [2174, 2174, 2214, 2214, 2321], [2323, 2323, 2373, 2373, 2611], [2612, 2612, 2649, 2977, 3234], [3236, 3236, 3254, 3254, 3325], [3367, 3387, 3409, 3409, 3534], [3538, 3538, 3556, 3921, 7191], [7193, 7206, 7236, 7236, 7486], [7488, 7501, 7545, 7662, 8959], [8961, 8975, 9002, 9002, 9159], [9161, 9175, 9245, 9245, 10613], [10614, 10614, 10670, 10698, 13128]], "test": "untested"}
{"id": "fd3XWj", "name": "Retro Scan Effect", "author": "lambmeow", "description": "a really basic scan line effect for a school project", "tags": ["postprocessing", "retro", "effect", "crt", "scanline"], "likes": 5, "viewed": 511, "published": 3, "date": "1633918629", "time_retrieved": "2024-07-30T18:56:55.469643", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 suv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(1.5 * sin(suv.y * iResolution.y/3. + iTime * 20.));\n    fragColor = 1.- floor(abs(fragColor));\n    fragColor *= vec4(sin(suv.y), 0, cos( 1. - suv.y * 2.) , 1);\n    fragColor *= texture(iChannel0, suv);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3XWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 374]], "test": "untested"}
{"id": "sdtXDB", "name": "Jumping blobs", "author": "ninofiliu", "description": "The scene consists in one plane, one sphere at the center, and 5 spheres orbiting around it. The distance from a point to the scene is pretty easy to compute, but I added the twist of smoothing the min function so that objects blur one into another.", "tags": ["3d", "raymarching", "smoothmin", "smoothmax", "directionallight"], "likes": 3, "viewed": 314, "published": 3, "date": "1633905330", "time_retrieved": "2024-07-30T18:56:56.370234", "image_code": "const int MAX_STEPS = 100;\nconst float MIN_DISTANCE = 0.0001;\nconst float MAX_DISTANCE = 50.0;\nconst float EPSILON_NORMAL = 0.01;\n    \nvec3 getRay(vec2 fragCoord, vec3 camera, vec3 lookAt) {\n    const float zoom = 1.5;\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.y;\n    vec3 c = normalize(lookAt - camera);\n    vec3 u = vec3(c.y, -c.x, 0.0);\n    vec3 v = normalize(vec3(c.z*c.x, c.z*c.y, c.x*c.x+c.y*c.y));\n    return normalize(c + (uv.x * u + uv.y * v) / zoom);\n}\n\nbool isInSphere(vec3 camera, vec3 ray, vec3 center, float radius) {\n    float d = distance(camera, center);\n    float dp = dot(ray, center-camera);\n    return dp*dp > d*d-radius*radius;\n}\n\nfloat getDS(vec3 marcher) {\n    const int len = 7;\n    const float a = 3.0;\n    \n    float mins[len];\n    \n    mins[0] = marcher.z;\n    mins[1] = distance(marcher, vec3(0.0, 0.0, 0.7)) - 1.0;\n    int nb = len - 2;\n    for (int i = 0; i < len-2; i++) {\n        float angle = radians(270.0 * float(i) / float(nb));\n        vec3 center = vec3(cos(angle), sin(angle), 0.5+1.0*sin(3.0*iTime+float(i)));\n        mins[2+i] = distance(marcher, center) - 0.7;\n    }\n    \n    float sa = 0.0;\n    float sb = 0.0;\n    for (int i = 0; i < len; i++) {\n        sa += mins[i] * exp(-a * mins[i]);\n        sb += exp(-a * mins[i]);\n    }\n    \n    return sa / sb;\n}\n\nvec3 march(vec3 camera, vec3 ray) {\n    vec3 marcher = camera;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float ds = getDS(marcher);\n        if (ds < MIN_DISTANCE || ds > MAX_DISTANCE) { break; }\n        marcher += ds * ray;\n    }\n    return marcher;\n}\n\nvec3 getNormal(vec3 camera, vec3 ray) {\n    vec3 surface = march(camera, ray);\n    float dx = getDS(surface+vec3(EPSILON_NORMAL, 0.0, 0.0));\n    float dy = getDS(surface+vec3(0.0, EPSILON_NORMAL, 0.0));\n    float dz = getDS(surface+vec3(0.0, 0.0, EPSILON_NORMAL));\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat getLight(vec3 camera, vec3 ray) {\n    vec3 source = vec3(4.0, 0.0, 5.0);\n    vec3 surface = march(camera, ray);\n    vec3 normal = getNormal(camera, ray);\n    return -dot(normal, normalize(surface-source));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float speed = 0.7;\n    vec3 camera = vec3(5.0 * vec2(cos(speed*iTime), sin(speed*iTime)), 1.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.5);\n    vec3 ray = getRay(fragCoord, camera, lookAt);\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n    fragColor.rgb += 0.5+0.5*getLight(camera, ray);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 190, 190, 485], [487, 487, 554, 554, 674], [676, 676, 703, 703, 1322], [1324, 1324, 1359, 1359, 1583], [1585, 1585, 1624, 1624, 1891], [1893, 1893, 1932, 1932, 2106], [2108, 2108, 2163, 2163, 2449]], "test": "untested"}
{"id": "7stSDB", "name": "How to Win at Tic-Tac-Toe", "author": "oneshade", "description": "Most games I play end in ties :D", "tags": ["game", "animation", "tictactoe"], "likes": 12, "viewed": 202, "published": 3, "date": "1633903322", "time_retrieved": "2024-07-30T18:56:57.143168", "image_code": "#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\n\n// Utilities\n// https://www.shadertoy.com/view/4djSRW\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 fbm(in float x, in int oct) {\n    vec2 pos = vec2(0.0);\n    float amp = 1.0;\n    float total = 0.0;\n    for (int o=0; o < oct; o++) {\n        pos += mix(Hash12(floor(x)), Hash12(ceil(x)), smoothstep(0.0, 1.0, fract(x))) * amp;\n        total += amp;\n        amp *= 0.5;\n        x *= 2.0;\n    }\n\n    return pos / total;\n}\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, -si, si, co);\n}\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\nfloat sdArc(in vec2 p, in vec2 ax, in vec2 ap, in float r, in float t) {\n    p = vec2(dot(p, ax), abs(p.y * ax.x - p.x * ax.y));\n    return (p.y * ap.x < p.x * ap.y ? abs(length(p) - r) : length(p - ap * r)) - t;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedX(in vec2 p, in float w, in float r) {\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\n// https://www.shadertoy.com/view/Xlt3R4\nfloat sdQuestionMark(in vec2 p, in vec2 s, in float t) {\n    p += vec2(9.0, 10.0) * s;\n    float res = sdLine(p, vec2(3.0, 16.0) * s, vec2(3.0, 17.0) * s, t);\n    res = min(res, sdLine(p, vec2(3.0, 17.0) * s, vec2(4.0, 19.0) * s, t));\n    res = min(res, sdLine(p, vec2(4.0, 19.0) * s, vec2(5.0, 20.0) * s, t));\n    res = min(res, sdLine(p, vec2(5.0, 20.0) * s, vec2(7.0, 21.0) * s, t));\n    res = min(res, sdLine(p, vec2(7.0, 21.0) * s, vec2(11.0, 21.0) * s, t));\n    res = min(res, sdLine(p, vec2(11.0, 21.0) * s, vec2(13.0, 20.0) * s, t));\n    res = min(res, sdLine(p, vec2(13.0, 20.0) * s, vec2(14.0, 19.0) * s, t));\n    res = min(res, sdLine(p, vec2(14.0, 19.0) * s, vec2(15.0, 17.0) * s, t));\n    res = min(res, sdLine(p, vec2(15.0, 17.0) * s, vec2(15.0, 15.0) * s, t));\n    res = min(res, sdLine(p, vec2(15.0, 15.0) * s, vec2(14.0, 13.0) * s, t));\n    res = min(res, sdLine(p, vec2(14.0, 13.0) * s, vec2(13.0, 12.0) * s, t));\n    res = min(res, sdLine(p, vec2(13.0, 12.0) * s, vec2(9.0, 10.0) * s, t));\n    res = min(res, sdLine(p, vec2(9.0, 10.0) * s, vec2(9.0, 7.0) * s, t));\n    res = min(res, sdLine(p, vec2(9.0, 2.0) * s, vec2(8.0, 1.0) * s, t));\n    res = min(res, sdLine(p, vec2(8.0, 1.0) * s, vec2(9.0, 0.0) * s, t));\n    res = min(res, sdLine(p, vec2(9.0, 0.0) * s, vec2(10.0, 1.0) * s, t));\n    res = min(res, sdLine(p, vec2(10.0, 1.0) * s, vec2(9.0, 2.0) * s, t));\n    return res;\n}\n\n// Convert board indices to screen coordinates\nvec2 board2screen(in vec2 index) {\n    return index * 0.35 - 0.35;\n}\n\n// Animate placing pieces\nvoid placeX(in vec2 coords, in float startTime, in vec2 uv, in float unit, inout vec3 color) {\n    float transition = clamp((iTime - startTime) / 2.0, 0.0, 1.0);\n    float leftEdge = -0.5 * iResolution.x / iResolution.y * 1.1 - 0.2;\n    coords = mix(vec2(leftEdge, 0.0), board2screen(coords), transition);\n    float spin = 2.0 * 6.28 * transition;\n    drawSDF(sdRoundedX((uv - coords) * Rotate2D(spin), 0.175, 0.005), vec4(1.0, 0.0, 0.0, 1.0));\n}\n\nvoid placeO(in vec2 coords, in float startTime, in vec2 uv, in float unit, inout vec3 color) {\n    float rightEdge = 0.5 * iResolution.x / iResolution.y * 1.1 + 0.2;\n    coords = mix(vec2(rightEdge, 0.0), board2screen(coords), clamp((iTime - startTime) / 2.0, 0.0, 1.0));\n    drawSDF(sdRing(uv, coords, 0.1, 0.005), vec4(0.0, 0.0, 1.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 1.1;\n    float unit = 2.2 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Shake up\n    uv -= (0.5 * fbm(10.0 * iTime, 10) - 0.25) * smoothstep(35.0, 36.0, iTime);\n\n    // Tic-tac-toe board\n    drawSDF(sdLine(uv, vec2(-0.5, 0.175), vec2(0.5, 0.175), 0.005), vec4(1.0));\n    drawSDF(sdLine(uv, vec2(-0.5, -0.175), vec2(0.5, -0.175), 0.005), vec4(1.0));\n    drawSDF(sdLine(uv, vec2(0.175, -0.5), vec2(0.175, 0.5), 0.005), vec4(1.0));\n    drawSDF(sdLine(uv, vec2(-0.175, -0.5), vec2(-0.175, 0.5), 0.005), vec4(1.0));\n\n    // Place Xs and Os (note to self: 3s transitions)\n    placeO(vec2(1.0, 1.0), 0.0, uv, unit, color);\n    placeX(vec2(1.0, 0.0), 3.0, uv, unit, color);\n    placeO(vec2(0.0, 1.0), 6.0, uv, unit, color);\n    placeX(vec2(2.0, 1.0), 9.0, uv, unit, color);\n    placeO(vec2(0.0, 0.0), 12.0, uv, unit, color);\n\n    // Which one to stop?!?!\n    float pulse = 0.5 - 0.5 * cos(5.0 * clamp(iTime - 15.0, 0.0, 5.0));\n    drawSDF(sdQuestionMark(uv - board2screen(vec2(0.0, 2.0)), vec2(0.01), 0.005), vec4(1.0, 0.0, 0.0, pulse));\n    drawSDF(sdQuestionMark(uv - board2screen(vec2(2.0, 2.0)), vec2(0.01), 0.005), vec4(1.0, 0.0, 0.0, pulse));\n\n    // Fade out, then in\n    float fade = smoothstep(0.0, 1.0, 5.0 * abs(iTime - 22.5) - 11.5);\n    float invFade = 1.0 - fade;\n    color *= fade;\n\n    // Face\n    drawSDF(sdRing(uv, vec2(0.0), 0.45, 0.005), vec4(1.0, 1.0, 1.0, invFade));\n    drawSDF(sdArc(vec2(abs(uv.x) - 0.175, abs(uv.y - 0.075) + 0.066), vec2(0.0, 1.0), vec2(cos(1.0), sin(1.0)), 0.125, 0.005), vec4(1.0, 1.0, 1.0, invFade));\n    drawSDF(sdArc(uv + vec2(0.0, 0.4), vec2(0.0, 1.0), vec2(cos(1.0), sin(1.0)), 0.25, 0.005), vec4(1.0, 1.0, 1.0, invFade));\n\n    // Toggle eye direction\n    uv.x *= sign(cos(2.5 * clamp(iTime - 20.0, 0.0, 5.0)));\n\n    // Pupils\n    drawSDF(sdDisk(uv, vec2(-0.135, 0.075), 0.025), vec4(1.0, 1.0, 1.0, invFade));\n    drawSDF(sdDisk(uv, vec2(0.215, 0.075), 0.025), vec4(1.0, 1.0, 1.0, invFade));\n\n    // Final moves\n    placeX(vec2(2.0, 2.0), 26.0, uv, unit, color);\n    placeO(vec2(0.0, 2.0), 29.0, uv, unit, color);\n\n    // Os win! Tic-tac-toe, three in a row!\n    float transition = clamp((iTime - 32.0) / 2.0, 0.0, 1.0);\n    drawSDF(sdLine(uv, vec2(-0.35, 0.5 - transition), vec2(-0.35, 0.5), 0.005), vec4(0.0, 1.0, 0.0, transition));\n\n    // Fade out (shake up happens before this, see top of mainImage)\n    color *= 1.0 - smoothstep(36.0, 40.0, iTime);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 147, 172, 172, 300], [302, 302, 336, 336, 626], [628, 628, 655, 655, 727], [729, 737, 785, 785, 817], [819, 819, 878, 878, 990], [992, 992, 1052, 1052, 1093], [1095, 1095, 1167, 1167, 1309], [1311, 1362, 1415, 1415, 1485], [1487, 1528, 1584, 1584, 2927], [2929, 2976, 3010, 3010, 3044], [3046, 3072, 3166, 3166, 3518], [3520, 3520, 3614, 3614, 3864], [3866, 3866, 3921, 3921, 6429]], "test": "untested"}
{"id": "7ddSWB", "name": "Byte Patten 2", "author": "foxic", "description": "Byte Patten 2", "tags": ["bytepatten2"], "likes": 0, "viewed": 144, "published": 3, "date": "1633897498", "time_retrieved": "2024-07-30T18:56:58.005862", "image_code": "#define TileSize 8.\n\nvec2 rotate2D(vec2 _st,float _angle){\n    //_st-=.5;\n    _st=mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    //_st+=.5;\n    return _st;\n}\n\nfloat random(in float x){\n    return fract(sin(x)*43758.5453);\n}\n\n\nbool patten(in vec2 uv){\n    ivec2 uvs = ivec2(uv*TileSize);\n    uvs.x = (uvs.x+10000)%3;\n    \n    int byte = int( random(float(uvs.y))*7. );\n    return ((byte >> uvs.x)&1) == 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    vec2 uv = ((2.0*fragCoord-iResolution.xy)/iResolution.y);\n\n    uv.y +=1.;\n    //uv = vec2( atan(uv.x ,uv.y)*0.159, length(uv)*0.25 );\n    uv.y += iTime*0.1;\n    \n    uv = rotate2D(uv,-0.7853);\n    float b = float(patten(uv));\n    b = max( b, float(!patten(uv+0.05))*0.0625 );\n    b = mix( b, 0.5,0.2);\n    \n    vec2 q = fragCoord / iResolution.xy;\n    \n    b *= b+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.5)*3.;\n    b = clamp(b,0.,1.);\n    fragColor = vec4(vec3(b),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 58, 73, 179], [181, 181, 206, 206, 245], [248, 248, 272, 272, 428], [430, 430, 486, 486, 968]], "test": "untested"}
{"id": "7sdSDS", "name": "hex segment digital display", "author": "remaindeer", "description": "Implement a seven-segment-ish digital display for a hexagonal grid where each character is bit-encoded.", "tags": ["grid", "text", "hexagon", "segment", "encoding", "bits", "digitaldisplay"], "likes": 4, "viewed": 346, "published": 3, "date": "1633893524", "time_retrieved": "2024-07-30T18:56:58.771814", "image_code": "#define N   9.0\n#define ON  0.75\n#define OFF 0.25\n#define COS30 cos(radians(30.0))\n#define WIDTH 0.125\n\nfloat hex_codes[49] = float[] (\n    16127.0, 12735.0, 09087.0, 10681.0, 16313.0, 11263.0, 19199.0, 14719.0, 16063.0, 14527.0,\n    12289.0, 16145.0, 14015.0, 08511.0, 15549.0, 14521.0, 14777.0, 03839.0, 16071.0, 18617.0,\n    13287.0, 10687.0, 14649.0, 16191.0, 14617.0, 23709.0, 14007.0, 16263.0, 10227.0, 16255.0,\n    15873.0, 12283.0, 16363.0, 16015.0, 15343.0, 15359.0, 15939.0, 16383.0, 16079.0, 08481.0,\n    18569.0, 16425.0, 11777.0, 20219.0, 08193.0, 16391.0, 17927.0, 16767.0, 16193.0\n);\n\nfloat cross2(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\nbool intri(vec2 uv, vec2 v1, vec2 v2, vec2 v3)\n{\n    // https://mathworld.wolfram.com/TriangleInterior.html\n    // http://www.sunshine2k.de/coding/java/pointInTriangle/pointInTriangle.html\n    vec2 w1 = v2 - v1;\n    vec2 w2 = v3 - v1;\n    float d = determinant(mat2(w1, w2));\n    // check for d ≈ 0.0 ?\n    float s = determinant(mat2(uv - v1, w2)) / d;\n    float t = determinant(mat2(w1, uv - v2)) / d;\n    return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;\n}\n\nbool inreg(vec2 uv, vec2 c, float n, float R, float theta)\n{\n    // break-up regular polygon into triangles\n    float dt = radians(360.0 / n);\n    for (float i = 0.0, j = 1.0; i < n; i++, j++)\n    {\n        vec2 a = R * vec2(cos(dt * i + theta), sin(dt * i + theta)) + c;\n        vec2 b = R * vec2(cos(dt * j + theta), sin(dt * j + theta)) + c;\n        if (intri(uv, a, b, c))\n            return true;\n    }\n    return false;\n}\n\nvec2 uv_to_hex(vec2 uv, float R) {\n    // get central hex coordinate\n    float r = R * COS30;\n    float theta = radians(30.0);\n    vec2 hvec = vec2(2.0 * r, 0.0);\n    vec2 kvec = vec2(r, 1.5 * R);\n    mat2 b = mat2(hvec, kvec);\n    vec2 cell = b * round(inverse(b) * uv);\n    bool inhex = inreg(uv, cell, 6.0, R, radians(theta));\n    // adjust hex coordinate due to overlap\n    if (!inhex)\n        if (cross2(vec2(r, 0.5 * R), cell - uv) < 0.)\n            cell += (uv.x > cell.x) ? kvec : -hvec;\n        else\n            cell += (uv.x > cell.x) ? hvec : -kvec;\n    return cell;\n}\n\nvec3 hex_display(vec2 uv, vec2 pos, float chr, float R, float B, vec3 col) {\n    // uv  the uv\n    // pos the centreal display position\n    // chr the character code to display\n    // R   the hexagon circumradius\n    // B   the border width\n    // col the default color\n    //\n    //     0    5    8  -\n    //    1         9    |\n    //   2    6    A      > display bit mapping\n    //  3         B      |\n    // 4    7    C      -\n    //\n    // A a 16127          n 14521        0 16255  _ 08481\n    // b   12735          o 14777        1 15873  - 18569\n    // C c 09087 10681  P   03839        2 12283  : 16425\n    //   d 16313          q 16071        3 16363  ! 11777\n    // E   11263          r 18617        4 16015  ? 20219\n    // F   19199        S   13287        5 15343  . 08193\n    // G g 14719          t 10687        6 15359  ' 16391\n    // H h 16063 14527  U u 16191 14649  7 15939  \" 17927\n    //   i 12289        V   14617        8 16383  [ 16767\n    // J   16145          w 23709        9 16079  ] 16193\n    // K   14015        X   14007\n    // L   8511           y 16263\n    // M   15549        Z   10227\n    \n    float r = R * COS30;\n    float theta = radians(30.0);\n    float n = chr;\n    // set display according to bit index\n    for (int i = 0; i < 13; i++) {\n        float q = floor(n / 2.0);\n        if (mod(q, 2.0) == 1.0) {\n            float ir = 0.0;\n            float ic = 0.0;\n            switch (i) {\n                case  0:\n                case  5:\n                case  8:\n                    ir = +2.0;\n                    break;\n                case  1:\n                case  9:\n                    ir = +1.0;\n                    break;\n                case  3:\n                case 11:\n                    ir = -1.0;;\n                    break;\n                case  4:\n                case  7:\n                case 12:\n                    ir = -2.0;\n                    break;\n            }\n            /**/ if (i <= 4) ic = -1.0;\n            else if (i >= 8) ic = +1.0;\n            float dx = ic * 2.0 * r + ir * r;\n            float dy = ir * 1.5 * R;\n            if (inreg(uv, pos + vec2(dx, dy), 6.0, R - B, theta)) {\n                col = vec3(ON);\n                break;\n            }\n        }\n        n = q;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    float R = 1.0 / N;\n    float r = R * COS30;\n    float B = R * WIDTH;\n\n    vec2 hex = uv_to_hex(vec2(iResolution.x / iResolution.y / 2.0, 0.5), R);\n\n    vec3 col = (\n        inreg(uv, uv_to_hex(uv, R), 6.0, R - B, radians(30.0)) ? \n        vec3(OFF) : \n        0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4))\n    );\n    float code = hex_codes[int(mod(float(iFrame / 30), float(hex_codes.length())))];\n    col = hex_display(uv, hex, code, R, B, col);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[600, 600, 630, 630, 666], [668, 668, 716, 856, 1125], [1127, 1127, 1187, 1234, 1554], [1556, 1556, 1590, 1624, 2135], [2137, 2137, 2213, 3256, 4410], [4412, 4412, 4469, 4469, 5003]], "test": "untested"}
{"id": "NstSDB", "name": "CSGColBlend", "author": "Del", "description": " a simple union / subtraction CSG test with some color blend tightness control for some voxel stuff", "tags": ["color", "csg", "blend", "smoothmin"], "likes": 7, "viewed": 257, "published": 3, "date": "1633881400", "time_retrieved": "2024-07-30T18:56:59.634507", "image_code": "// a simple union / subtraction CSG test with some color blend tightness control for some voxel stuff - 10/10/2021\n\n#define AA 1\t// make this 2 if you are feeling cold...\n\nvec3 _basecol = vec3(0.0);\t// pure filth\n\n// prims\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nfloat sminCol( float a, float b, float k, vec3 col1,float coltightness)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);//-  k*h*(1.0-h);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smaxCol( float a, float b, float k, vec3 col1, float coltightness)\n{\n    //return smin(a, -b, -k);// subtract\n    //return smin(a, b, -k); // intersection\n    b=-b;\n    k=-k;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    float colblend = clamp( 0.5 + 0.5*(b-a)/(k*(coltightness)), 0.0, 1.0 );\n    _basecol = mix(col1,_basecol,colblend);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 pos )\n{\n    float dist_cylinder = sdCylinder(pos+vec3(2.0,0.0,0.0),vec2(1.2,2.5));\n    float dist_sphere1 = sdSphere(pos+vec3(-.5,0.0,0.0),1.8);\n    float dist_sphere2 = sdSphere(pos+vec3(2.0,-1.0,0.0),1.8);\n    float dist_box = sdBox(pos+vec3(-.5,0.0,0.0),vec3(2.5,0.4,0.4));\n\n\n   float _basedist = 1000.0f;\n    _basecol = vec3(0.0);\n    vec3 redcol = vec3(1.0,0.05,0.05);\n    vec3 greencol = vec3(0.2,1.0,0.2);\n    vec3 bluecol = vec3(0.2,0.2,1.0);\n    vec3 yellowcol = vec3(1.0,1.0,0.2);\n\n\n    float _coltightness = 0.25;\n    _basedist = sminCol(_basedist, dist_cylinder, 2.0, redcol, _coltightness);  // +red cylinder\n    _basedist = sminCol(_basedist, dist_sphere1, 2.0, greencol, _coltightness); // +green sphere\n    _basedist = smaxCol(_basedist, dist_box, 0.5, bluecol, _coltightness);      // -blue box\n    _basedist = smaxCol(_basedist, dist_sphere2, 0.5, yellowcol, _coltightness);// -yellow sphere\n    return _basedist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.01;\t//0.0005\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n        float an = radians(90.0);\n        float yoff = 3.0f;\n        if (iMouse.z>0.5)\n        {\n         an = an+(iMouse.x/iResolution.x)*6.28;\n         yoff = yoff+(5.0-((iMouse.y/iResolution.y)*15.0));\n        }\n        else\n        {\n            an = sin(iTime*.75)*3.14;\n        }\n\n    vec3 ro = vec3( 7.0*cos(an), yoff, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<200; i++ )// overkill\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 dir = normalize(vec3(1.0,0.7,0.0));\n\t        vec3 ref = reflect(rd, nor);\n\t        float spe = max(dot(ref, dir), 0.0);\n\t        vec3 spec = vec3(1.0) * pow(spe, 64.);\n            float dif = clamp( dot(nor,dir), 0.05, 1.0 );\n            col =  _basecol*dif;\n            col+=spec;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 223, 259, 259, 358], [359, 359, 392, 392, 418], [419, 419, 450, 450, 537], [539, 561, 602, 602, 691], [692, 692, 731, 731, 760], [762, 762, 835, 835, 1061], [1063, 1063, 1137, 1223, 1452], [1454, 1454, 1480, 1480, 2406], [2408, 2408, 2440, 2440, 2686]], "test": "untested"}
{"id": "7dcXDB", "name": "Hyperbolic tilings: intro", "author": "neozhaoliang", "description": "This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.", "tags": ["2d", "tiling", "hyperbolic", "poincare"], "likes": 24, "viewed": 994, "published": 3, "date": "1633863097", "time_retrieved": "2024-07-30T18:57:00.402454", "image_code": "/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.0\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, 3, 7);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the total number of reflections\nfloat count;\n\n// compute cos(PI / x) using Vinberg's convention for inf.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n  \n    fold(p, count);\n    \n    float lw = 0.002;\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, lw));    \n    ln = min(ln, lBox(p, vec2(0), m0, lw));\n    ln = min(ln, length(p-C.xy) - C.z - lw);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, lw));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1051, 1110, 1135, 1135, 1174], [1176, 1176, 1198, 1198, 1256], [1259, 1259, 1272, 1272, 1911], [1914, 1914, 1978, 1978, 2110], [2113, 2113, 2177, 2177, 2392], [2395, 2395, 2439, 2439, 2606], [2609, 2609, 2643, 2643, 2726], [2729, 2729, 2775, 2775, 2933], [2936, 2936, 2965, 2965, 3297], [3300, 3300, 3357, 3357, 5896]], "test": "untested"}
{"id": "fdcSWH", "name": "Tic-tac-toe cheat sheet", "author": "NLIBS", "description": "The board is subdivided to store each possible move X can make along with the corresponding \"best\" response for O.\n\nZoom in by clicking with your mouse\n", "tags": ["recursive", "glow", "tictactoe", "storage"], "likes": 10, "viewed": 506, "published": 3, "date": "1633839954", "time_retrieved": "2024-07-30T18:57:01.212288", "image_code": "#define AA 2\n\nconst int data1 = 193684000;\nconst int data2[5] = int[](73513917,45929,244974619,32811,92120642);\nconst int data3[45] = int[](\n    0,288970497,334209321,95790699,6024960,288616743,239299803,87289101,32836977,\n    288970497,0,258279597,129134258,1243676,128667698,340122167,263010734,32583791,\n    334209321,258279597,0,258273845,4786622,1,340009315,219964087,15962943,\n    95790699,129134258,258273845,0,4783520,128609450,340116399,263057462,32569233,\n    6024960,87337604,143669892,91939844,0,288041568,47889532,87276368,5374332\n);\nint data4[405];\nconst int indices[186] = int[](\n    15,239653647,10,220015845,4,340050069,8,3015873,1,5201415,1,28698354,\n    2,5846355,1,24092037,1,1241973,8,339644007,8,339644007,6,220015845,\n    14,119979,8,239653647,20,15967287,9,32812053,1,4610196,2,258758550,\n    1,2,2,1062884,1,177155,2,1185111,9,32461647,9,133085,9,119801,\n    1,30650805,2,15967287,1,32812053,1,1185111,1,32461647,1,133085,\n    1,119801,9,220015845,10,15967287,18,32457327,1,5201415,1,129618387,\n    2,4782977,2,38263832,2,3653,1,14352579,1,32468931,16,3,2,220015845,\n    1,133869915,2,220010093,1,3653,1,1,1,1,2,19713,4,32457327,8,340050069,\n    15,32812053,9,32457327,10,28698354,1,2,1,4782977,4,124357266,\n    1,488,1,10629369,9,29229315,9,65709,9,131645,1,9684135,1,32812053,\n    1,32457327,2,10629369,1,29229315,1,65709,1,131645,3,3015144,1,14531157,\n    1,4783095,2,29761236,1,4842063,1,1182924,2,4610196,2,129618387,\n    1,87156812,2,259343700,1,129320963,2,1775601,4,47829761,6,38264472,\n    1,87156812,1,47829761,4,81310545,1,87156812,1,5314554,16,47829754,\n    4,129320963,10,129320958,8,1775601\n);\n\nint npow[9] = int[](1,9,81,729,6561,59049,531441,4782969,43046721);\n\n#define won(g) (g&86016)==86016 || (g&1344)==1344 || (g&21)==21 || (g&4161)==4161 || (g&16644)==16644 || (g&66576)==66576 || (g&4368)==4368 || (g&65793)==65793\n\nvoid mainImage(out vec4 O,vec2 U) {\n    int n = 0;\n    for (int i = 0; i<93; i++) data4[n += indices[i*2]] = indices[i*2+1];\n    \n    for (int aa = 0; aa<AA*AA; aa++) {\n        vec2 r = iResolution.xy,\n             uv = (2.*(U + vec2(aa%AA,aa/AA)/float(AA))-1.-r)/r.y;\n             \n        if (iMouse.z>0.)\n            uv =uv*.3+iMouse.xy/r*1.4-.7;\n        vec2 p = uv;\n        \n        int i=0,n=0,g=0,v,h=-1,pt=0,n0,n1;\n        float c,c2,x,l=0.,d=.05;\n        vec2 p2 = max(abs(p)-.6,0.);\n        vec3 bg = vec3(0,.03,.06)/(dot(p2,p2)+vec3(0,.3,1));\n        for (; i<5; i++) {        \n            n*=9;\n            if ((v&3)>0&&i>1 || length(max(abs(p)-.9,0.))>.05 || won(g)) break;\n            bg += vec3(.02,.04,.06)*sqrt(float(i));\n            uv = p*1.6+1.5;\n            \n            if (i==0) uv = mix(uv,3.-uv,step(.95/3.,p));\n            \n            p = fract(uv)*2.-1.;\n            n += int(uv.x)+int(uv.y)*3;\n\n            if (i>0) {\n                n0 = (n/9)%9;\n                n1 = (pt+n0)/9;             \n                h = i<3 ? (i==1 ? data1 : data2[n1]) : (i==3 ? data3[n1] : data4[n1]);\n                h = (h/npow[(pt+n0)%9])%9;\n                g |= (2<<n0*2) | (1<<h*2);\n                pt = (pt+n0)*9;\n            }\n\n            v = g>>(n%9)*2;            \n            c = min(.035/sqrt(abs(length(p)-.8)-d*.8),1.) * float(v&1);\n            c2 = c*float(n%9==h);\n            \n            vec2 px = abs(p.y+vec2(p.x,-p.x)); px = (px.y>px.x) ? px.yx : px.xy;\n            x = min(.035/sqrt(length(max(px-vec2(1.6,0),0.))-1.4*d),1.) * float(v/2&1);\n                    \n            d += .02;\n        }\n        O += vec4( (1.-x-c)*bg/(bg.r+.6)+max(c2-l,0.)*vec3(.9,.7+float(i-2)*.1,.2),0)/float(AA*AA);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1864, 1864, 1899, 1899, 3594]], "test": "untested"}
{"id": "7d3SDS", "name": "Simplex Skew Experiment", "author": "Yusef28", "description": "Based on the simplex grid introduced here: https://thebookofshaders.com/11/\nThe math is slightly better explained here: https://www.youtube.com/watch?v=dz6fg-Z0JKk&ab_channel=WannesMalfait\nand barryCentric Coordinates are used for the inner triangles", "tags": ["grid", "simplex", "skew"], "likes": 6, "viewed": 455, "published": 3, "date": "1633835793", "time_retrieved": "2024-07-30T18:57:02.086950", "image_code": "\n\nvec2 baryCentric(vec2 A, vec2 B, vec2 C, vec2 P){\n    \n    //no needto normalize because equalateral triangles\n    vec2 AB = B-A;\n    vec2 BC = C-B;\n    vec2 CA = A-C;\n    \n    float areaA = length(cross(vec3(AB,0.),vec3(P-A,0.)));\n    float areaB = length(cross(vec3(BC,0.),vec3(P-B,0.)));\n    float areaC = length(cross(vec3(CA,0.),vec3(P-C,0.)));\n    \n    float ret = 0.;\n    \n    \n    float abSplit = abs(areaA-areaB);\n    float bcSplit = abs(areaC-areaB);\n    float caSplit = abs(areaA-areaC);\n    float thick = 0.03;\n    \n    \n    if(areaA < areaB && areaA < areaC) return vec2(1.,\n                                        smoothstep(thick,thick+0.01,caSplit) *\n                                        smoothstep(thick,thick+0.01,abSplit) );\n    if(areaB < areaA && areaB < areaC) return vec2(2.,\n                                        smoothstep(thick,thick+0.01,bcSplit) *\n                                        smoothstep(thick,thick+0.01,abSplit) );\n    \n    if(areaC < areaA && areaC < areaB) return vec2(3.,\n                                        smoothstep(thick,thick+0.01,caSplit) *\n                                        smoothstep(thick,thick+0.01,bcSplit) );\n    \n    \n    \n    \n    \n    //float linesAB = ret != 1. ? smoothstep(0.1,0.2,abSplit)\n       //                       : 0.;\n                 //(smoothstep(0.03,0.08, bcSplit)) *\n                 //(smoothstep(0.03,0.08, caSplit)) ;\n                 \n    //return linesAB;// * (smoothstep(0.03,0.08, bcSplit));\n    //if( abSplit < 0.05 && ret != 3.) return 4.;\n    //if( cbSplit < 0.05 && ret != 1.) return 4.;\n    //if( acSplit < 0.05 && ret != 2.) return 4.;\n\n}\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\nmat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    uv.x += iTime/4.;\n    uv *= skew;\n  \n    uv *= 6.;\n    \n    float f = 1.-smoothstep(0.47,0.49, abs(fract(uv.x)-0.5) );\n    float g = 1.-smoothstep(0.47,0.49, abs(fract(uv.y)-0.5) );\n    float h = smoothstep(0.02,0.025,abs(fract(uv.y)-fract(uv.x)) );\n    \n    vec2 ff = fract(uv);\n    vec2 id = floor(uv);\n    \n    float side = sign(ff.x-ff.y);\n    float ii = badHash(id + side);\n    \n    \n    vec2 tri = side < 0. ? baryCentric(vec2(0.),vec2(1.),vec2(0.,1.),ff)\n                          : baryCentric(vec2(0.),vec2(1.,0.),vec2(1.,1.),ff);\n    ff = ff*2.-1.;\n    //float ac = abs(length(abs(ff*mat2(0.707,-0.707,0.707,0.707))-0.7)-0.1);\n    //ac = smoothstep(0.05,0.1,ac);\n    // Time varying pixel color\n    vec3 col = vec3( ii - 0.1*(length(ff-vec2(side*0.35,-side*0.35))-0.05) );\n    \n    \n    //col *= ac;\n    if(side < 0.){\n        col = mix(col, vec3(.3,0.1,0.7), step(.5,tri.x));\n        col = mix(col, vec3(.4,0.7,.9), step(1.5,tri.x));\n        col = mix(col, vec3(0.5,0.6,.3), step(2.5,tri.x));\n        col *= tri.y;//= mix(col, vec3(0.), tri);\n        }\n        \n    if(side > 0.){\n        col = mix(col, vec3(.1,0.,0.).xzy, step(.5,tri.x));\n        col = mix(col, vec3(.4,0.,.1).xzy, step(1.5,tri.x));\n        col = mix(col, vec3(0.8,0.,.3).xzy, step(2.5,tri.x));\n        col *= tri.y;//= mix(col, vec3(0.), tri);\n        }\n      col *=g*f*h; \n      col *= 1.2;\n    //col *= ac;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3SDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 51, 112, 1645], [1646, 1646, 1668, 1668, 1727], [1773, 1773, 1830, 1880, 3391]], "test": "untested"}
{"id": "NscXRl", "name": "Amiga Boing Ball Hires", "author": "Krischan", "description": "As if my A500 had 4K resolution :-D The famous Amiga Boing ball demo in Hires. Found at https://glslsandbox.com/e#69071.0 and adjusted a little bit.", "tags": ["retro", "amiga", "boing", "ball", "hires"], "likes": 7, "viewed": 348, "published": 3, "date": "1633831761", "time_retrieved": "2024-07-30T18:57:02.867862", "image_code": "float tri(float x) { return min(fract(x), 1. - fract(x)) * 4. - 1.; }\n\nbool grid(vec2 p, float l, float h)\n{\n    return (fract(p.x * 10.) < .1 || fract(p.y * 10.) < .1) && abs(p.x - .025) < 1.25 && p.y > l && p.y < h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (2. * fragCoord.xy - iResolution.xy ) / min(iResolution.x, iResolution.y) + vec2(.0, .4);\n    vec4 col = vec4(.5);\n    float x = tri(iTime * .1) * 2.6;\n    vec2 s = 2. * pos - vec2(x, 1.5 * abs(sin(iTime * 1.7)));\n    \n    if (length(s) < .85)\n    {\n        col = vec4(1.0, .0, 0., .0);\n        s = s * mat2(.96, -.28, .28, .96) / sin(1.85 - length(s.xy)*1.4) + vec2(1. * x, 0.);\n        if (fract(s.x * 1.2) < .5 ^^ fract(s.y * 1.2) < 0.5) col += 1.1;\n    }\n    else\n    {\n        if (grid(pos, -.3, 1.205)) col.g = 0.;\n        pos = vec2(pos.x, 1.) / pos.y * -.3;\n        if (grid(pos, .7, 1.)) col.g = 0.;\n        if (length(s - vec2(.4, .1)) < .85) col /= 2.;\n    }\n    \n\tfragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 69], [71, 71, 108, 108, 219]], "test": "untested"}
{"id": "fs3XDB", "name": "shader-web-background JS lib 2", "author": "morisil", "description": "Check mouse!  I tweaked a bit this older shader of mine\n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 18, "viewed": 383, "published": 3, "date": "1633817854", "time_retrieved": "2024-07-30T18:57:03.717590", "image_code": "// Fork of \"shader-web-background JS lib\" by morisil. https://shadertoy.com/view/wlKyR1\n// 2021-10-09 22:16:29\n\n/*\n  This shader is here to spread the news about JavaScript library:\n  \n  https://xemantic.github.io/shader-web-background/\n \n  It is designed to be compatible with Shadertoy while adding more\n  integration options and saving many once-per-frame computations.\n  Even complex shaders should work on almost any hardware. I wanted\n  to build a base, which would let me use shaders as part of my\n  regular web development process, to transform my future website\n  into more immersive experiences. Check the project on mobile and\n  how it is reacting to device orientation, parallax scrolling, etc.\n  \n  Note: Mouse movement will make feedback follow the cursor.  \n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, gl_FragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst float iFeedbackZoomRate         = .003;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .006;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = 1.25;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .15;\nconst float iBlob1PowFactor           = 60.;\nconst float iBlob1ColorPulseSpeed     = .13;\nconst float iBlob2Radius              = .2;\nconst float iBlob2PowFactor           = 60.;\nconst float iBlob2ColorPulseSpeed     = .2;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = 1.7;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    vec2 iFeedbackZoomCenter = vec2(sin(iTime * .6), cos(iTime * .7)) * .2;\n    vec2 iDrawCenter = iFeedbackZoomCenter;\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.) \n    ) * vec3(.9, .6, 1.);\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    ) * vec3(.9, .6, 1.);\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.rg - .5) * iFeedbackColorShiftImpact * vec2(sin(iTime * .2), cos(iTime * .3));\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel0, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3XDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[778, 778, 833, 833, 905]], "test": "untested"}
{"id": "7sdXzs", "name": "2d basic blocks", "author": "jorge2017a2", "description": "2d basic blocks", "tags": ["2dbasicblocks"], "likes": 5, "viewed": 203, "published": 3, "date": "1633812095", "time_retrieved": "2024-07-30T18:57:04.524433", "image_code": "///2d basic blocks-JFP\n///por jorge2017a2...2021-oct-09\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBoxRound( in vec2 p,vec2 b, in float r )\n{  return sdBox(p,b) - r; }\n\nvec2 hash( vec2 p ) // replace this by something better\n{   p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{   const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// -----------------------------------------------\nvec3 nube(vec2 p, vec3 col)\n{\n    float d1= sdCircle(p,1.0 );\n    float d2= sdCircle(p-vec2(0.5,0.5),1.0 );\n    float d3= sdCircle(p-vec2(-0.5,0.5),1.0 );\n    float d4= sdCircle(p-vec2(0.5,1.5),1.0 );\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d1);\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d2);\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d3);\n    col= DrawFig(vec3(1.0)-p.y*0.25,col,d4);\n    \n    return col;\n}\n\nvec3 bloque1(vec2 p, vec3 col, float esca)\n{\n    float d1=sdBoxRound(p,vec2(1.5,4.),0.25 );\n    float d2=sdBoxRound(p,vec2(0.8,3.5),0.25 );\n    d2=d2+ noise( p*0.8-0.5);\n    \n    col= DrawFigBordeCol(vec3(0.6)*esca, col, d1, vec3(0.5) );\n    col= DrawFigBordeCol(vec3(0.3)*esca, col, d2, vec3(0.4) );\n    return col;\n}\n\nvec3 grupoBloques(vec2 uv, vec3 col, float esca)\n{   col= bloque1(uv-vec2(-12.0,-4.0), col, esca);\n    col= bloque1(uv-vec2(-8.5,-5.0), col, esca);\n    col= bloque1(uv-vec2(-5.0,-5.0), col, esca);\n    col= bloque1(uv-vec2(-5.0,-5.0), col, esca);\n    col= bloque1(uv-vec2(-1.5,-6.0), col, esca);\n    col= bloque1(uv-vec2( 2.0,-6.0), col, esca);\n    col= bloque1(uv-vec2( 5.5,-8.0), col, esca);\n    col= bloque1(uv-vec2( 9.0,-8.0), col, esca);\n    col= bloque1(uv-vec2( 7.5,-9.0), col, esca);\n    col= bloque1(uv-vec2( 12.5,-6.0), col, esca);\n \n   return col;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.25;\n    uv*=8.0;\n    \n    vec2 uv2=uv;\n    uv2.x+=iTime*5.0;\n    uv2.x=mod(uv2.x,15.0);\n    \n    uv.x+=iTime*4.0;\n    \n    uv.x=mod(uv.x, 14.0);\n    \n    col= grupoBloques(uv-vec2(2.0,6.5), col,0.25);\n    col= grupoBloques(uv-vec2(3.0,4.0), col,0.5);\n    col= grupoBloques(uv, col,1.0);\n    \n    col= nube(uv2-vec2(1.5,1.0), col);\n    col= nube(uv2-vec2(4.0,5.0), col);\n    col= nube(uv2-vec2(8.0,3.0), col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 315, 315, 410], [412, 443, 479, 479, 524], [529, 573, 620, 620, 647], [648, 648, 691, 691, 718], [719, 719, 767, 767, 795], [801, 801, 863, 863, 1059], [1061, 1061, 1142, 1142, 1272], [1274, 1274, 1331, 1331, 1397], [1399, 1399, 1436, 1436, 1516], [1518, 1518, 1553, 1553, 1581], [1583, 1583, 1633, 1633, 1659], [1661, 1661, 1718, 1718, 1834], [1836, 1836, 1862, 1862, 2339], [2341, 2392, 2421, 2421, 2795], [2797, 2797, 2841, 2841, 3115], [3117, 3117, 3167, 3167, 3676], [3682, 3682, 3739, 3739, 4344]], "test": "untested"}
{"id": "fstSRl", "name": "Quadratic Isosurfaces", "author": "silentsiege", "description": "Isosurfaces of random quadratic polynomials, clipped by another isosurface. Inspired by some of the Windows 11 wallpapers (at least Microsoft's artists are still competent). I might try this again with cubics to get more complicated shapes.", "tags": ["3d", "raytracing"], "likes": 3, "viewed": 300, "published": 3, "date": "1633807911", "time_retrieved": "2024-07-30T18:57:05.377153", "image_code": "const uint antiA = 3u; //raise or lower this\n\nconst mat4x3 bgPal = mat4x3(0.5,0.5,0.5,0.5,0.5,0.5,1.0,1.0,1.0,0.0,0.33,0.67);\nconst mat4x3 sfPal = mat4x3(0.5,0.5,0.5,0.5,0.5,0.5,1.0,1.0,1.0,0.0,0.10,0.20);\n\nconst float err = 1e10;\nmat3  fA, cA;\nvec3  fB, cB;\nfloat fC, cC;\n\nvec3 bgCol;\nvec3 sfCol;\n\n\nvec3 hash3(uint n) \n{\n    //https://www.shadertoy.com/view/llGSzw\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nmat2x3 boxM(uint n) {\n    vec3 U = hash3(n), V = hash3(n + 2568758767u);\n    U = sqrt(-2.*log(U));\n    V *= 2.*3.14159265;\n    return mat2x3(U*cos(V), U*sin(V));\n}\n\nvec3 pal(float t, mat4x3 a) {\n    //https://www.shadertoy.com/view/ll2GD3\n    return a[0] + a[1]*cos(2.*3.14159265*(a[2]*t+a[3]));\n}\n\nvoid set(uint n) {\n    n *= 100u;\n    for (uint i = 0u; i < 3u; ++i) {\n        mat2x3 tmp = boxM(n++);\n        fA[i] = tmp[0];\n        cA[i] = tmp[1];\n        fA[i][i] /= sqrt(2.);\n        cA[i][i] /= sqrt(2.);\n    }\n\n    fB = 2.*(hash3(n++) - 1.);\n    cB = 2.*(hash3(n++) - 1.);\n    fA *= .3;\n    \n    cB *= .3;\n    cA *= .2;\n    cC = 0.;\n    fC = 0.;\n    \n    bgCol = pow(pal(hash3(n++).x, bgPal), vec3(.35));\n    sfCol = pow(pal(hash3(n++).x, sfPal), vec3(1.));\n    \n}\n\nfloat eval(vec3 x, mat3 A, vec3 B, float C) {\n    return dot(x, A*x) + dot(B, x) + C;\n}\n\nvec3 grad(vec3 x, mat3 A, vec3 B) {\n    return B + A*x + x*A;\n}\n\nvec3 param(vec3 x, vec3 d, mat3 A, vec3 B, float C) {\n    return vec3(eval(x,A,B,C), dot(grad(x,A,B), d), dot(d, A*d));\n}\n\nfloat func(vec3 x) {\n    return eval(x, fA, fB, fC);\n}\n\nfloat cond(vec3 x) { \n    return eval(x, cA, cB, cC);\n}\n\nvec3 funcGrad(vec3 x) {\n    return grad(x, fA, fB);\n}\n\nvec3 condGrad(vec3 x) {\n   return grad(x, cA, cB);\n}\n\nvec2 solve(vec3 p) {\n    float a = p.z, b = p.y, c = p.x;\n    float disc = b*b - 4.*a*c;\n\n    if (disc < 0.) return vec2(err);\n    \n    vec2 tmp;\n    \n    if (false && abs(a) < 1e-6 )\n        tmp = vec2(-c/b, err);\n    else if (false && abs(c) < 1e-6)\n        tmp = vec2(0., -a/b);\n    else {\n        tmp.x = (-b - sign(b)*sqrt(disc))/2./a;\n        tmp.y = c/a/tmp.x;\n    }\n    if (tmp.y < tmp.x) tmp = tmp.yx;\n    if (tmp.x < 0.)    tmp = vec2(tmp.y, err);\n    if (tmp.x < 0.)    tmp = vec2(err);\n    return tmp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float duration = 3., speed = 1.;\n    set(uint(iTime/duration) + 0u);\n    fC -= iTime * speed;\n    \n    const float delta = 1.5, focal = 1.3;\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float pixel = 1./iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 4.);\n    \n    vec3 colTot = vec3(0.);\n    \n    for (uint nAA = 0u; nAA < antiA*antiA; ++nAA) {\n        const float aaStep = 1./float(antiA);\n        vec2 uv1 = vec2(nAA/antiA, nAA%antiA)*aaStep + .5*aaStep;\n        uv1 = (uv1 - .5) * 2.*pixel;\n        vec3 rd = normalize(vec3(uv+uv1, -focal));\n        \n        vec3 fPar = param(ro, rd, fA, fB, fC);\n        vec3 cPar = param(ro, rd, cA, cB, cC);\n        vec2 cIsect = solve(cPar);\n        \n        vec3 col;\n        \n        if (cIsect.x < err) {\n            float hit = func(ro+rd*cIsect.x);\n            vec2 pot = delta * (floor(hit / delta) + vec2(0., 1.));\n            vec4 fIsect = vec4(solve(fPar-vec3(pot.x,0.,0.)), solve(fPar-vec3(pot.y,0.,0.)));\n\n            float t = err;\n            for (int i = 0; i < 4; ++i) {\n                if (fIsect[i] < min(t, cIsect.y) && fIsect[i] > cIsect.x)\n                    t = fIsect[i];\n            }\n\n            vec3 pos = ro + t*rd;\n            vec3 fGrad = funcGrad(pos)/delta;\n            vec3 cGrad = condGrad(pos)/abs(cond(pos));\n            \n            float occ = length(fGrad) / length(cGrad);\n            occ = sqrt(occ);\n            occ = 1. - occ/sqrt(1. + occ*occ);\n            occ = sqrt(occ);\n            \n            col = t < err ? sfCol * occ : bgCol;\n            col = mix(col, sfCol, smoothstep(-2.*pixel, -pixel, -1./cIsect.x));\n        }\n        else\n            col = bgCol;\n        colTot += col;\n    }\n    colTot /= float(antiA*antiA);\n\n    colTot = pow(colTot, vec3(1./2.2));\n    fragColor = vec4(colTot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 321, 365, 548], [550, 550, 571, 571, 713], [715, 715, 744, 788, 847], [849, 849, 867, 867, 1320], [1322, 1322, 1367, 1367, 1409], [1411, 1411, 1446, 1446, 1474], [1476, 1476, 1529, 1529, 1597], [1599, 1599, 1619, 1619, 1653], [1655, 1655, 1675, 1675, 1710], [1712, 1712, 1735, 1735, 1765], [1767, 1767, 1790, 1790, 1819], [1821, 1821, 1841, 1841, 2336], [2338, 2338, 2393, 2393, 4219]], "test": "untested"}
{"id": "fscXWB", "name": "Brushed Metal Scales", "author": "oneshade", "description": "Trying to model a brushed metal texture.", "tags": ["scales", "metallic", "glint", "brushedmetal"], "likes": 14, "viewed": 227, "published": 3, "date": "1633807047", "time_retrieved": "2024-07-30T18:57:06.202945", "image_code": "#define hash(x) fract(485.375 * cos(375.843 * x + 881.482))\nvoid brushedDisk(in vec2 uv, inout vec3 color) {\n    float r = length(uv), a = atan(uv.y, uv.x);\n    bool mask = r < 0.5;\n    r *= 1.5 * iResolution.y;\n    float bands = mix(hash(floor(r)), hash(ceil(r)), smoothstep(0.0, 1.0, fract(r)));\n    float glint = 0.65 + 0.35 * sin(4.0 * a);\n    if (mask) color = vec3(bands * glint);\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + 0.1 * iTime;\n    uv = fract(uv * 2.0) - 0.5;\n    vec3 color = vec3(0.0);\n\n    brushedDisk(uv - vec2(0.5, -0.5), color);\n    brushedDisk(uv + 0.5, color);\n    brushedDisk(uv, color);\n    brushedDisk(uv - 0.5, color);\n    brushedDisk(uv - vec2(-0.5, 0.5), color);\n\n    fragColor.rgb += color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord + vec2(0.000, 0.000));\n    render(fragColor, fragCoord + vec2(0.333, 0.000));\n    render(fragColor, fragCoord + vec2(0.666, 0.000));\n    render(fragColor, fragCoord + vec2(0.000, 0.333));\n    render(fragColor, fragCoord + vec2(0.333, 0.333));\n    render(fragColor, fragCoord + vec2(0.666, 0.333));\n    render(fragColor, fragCoord + vec2(0.000, 0.666));\n    render(fragColor, fragCoord + vec2(0.333, 0.666));\n    render(fragColor, fragCoord + vec2(0.666, 0.666));\n    fragColor /= 9.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 108, 108, 388], [390, 390, 444, 444, 804], [806, 806, 861, 861, 1407]], "test": "untested"}
{"id": "NdcXDS", "name": "concrete tunnel", "author": "yasuo", "description": "concrete tunnel", "tags": ["concrete"], "likes": 13, "viewed": 321, "published": 3, "date": "1633797838", "time_retrieved": "2024-07-30T18:57:07.200278", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 80\n#define MAX_DIST 32.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL0 0\n#define SPEED 2.0\n#define ZERO (min(iFrame,0))\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\n// https://iquilezles.org/articles/fbmsdf\n// https://www.shadertoy.com/view/3dGSWR\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.8*w*w;\n    // distance to sphere at grid vertex i+c\n    return B3D((f-c),vec3(r));\n}\n\n// https://iquilezles.org/articles/fbmsdf\nfloat sdBase( in vec3 p)\n{\n    float t = iTime*0.5;\n    p.y-=t;\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .6, cos(z * .5), z);\n    return p;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.xy -= path(p.z).xy;\n    \n    p.z += iTime*SPEED;\n    \n    float d = -length(p.xy) + 1.5;\n    \n    float d2 = sdBase(p);\n    \n    return vec2(max(-d2,d),MATERIAL0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(p.x,p.y,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.7)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL0){\n        col = diffuseMaterial(n,rd,p,vec3(1.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*SPEED;\n    vec3 ro = path(t+1.5);\n \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.0001*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);   \n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcXDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 274, 274, 328], [330, 413, 450, 591, 808], [810, 852, 878, 878, 1330], [1332, 1332, 1352, 1352, 1416], [1418, 1418, 1440, 1440, 1637], [1639, 1639, 1697, 1697, 1968], [1970, 1970, 1994, 1994, 2195], [2197, 2197, 2239, 2239, 2434], [2436, 2477, 2526, 2526, 2817], [2819, 2819, 2876, 2876, 3409], [3411, 3411, 3470, 3470, 3569], [3571, 3571, 3628, 3628, 4230]], "test": "untested"}
{"id": "Ns3XDS", "name": "Spirally Spirals", "author": "SnoopethDuckDuck", "description": "Just messing about, neat code", "tags": ["cool"], "likes": 2, "viewed": 203, "published": 3, "date": "1633797159", "time_retrieved": "2024-07-30T18:57:08.217559", "image_code": "float h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n   \n    // uncomment me\n    // r = length(uv) * (1. + min(abs(1./uv.x), abs(1./uv.y)));\n    // r *= r;\n    \n          uv = vec2(cos(1. * r + a + iTime), sin(2. * r + a - iTime));\n    vec2 uv2 = vec2(cos(2. * r + a - iTime), sin(4. * r + a + iTime));\n \n    float b = .5 + .5 * cos(0.8 * iTime);   \n    uv = mix(uv, uv2, b);\n    \n    float val = smoothstep(.26, .34, (.3 + .05 * cos(iTime)) * length(cos(2. * uv)));\n    val *= 0.95 + h21(uv);\n    \n    fragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 95], [97, 97, 154, 154, 752]], "test": "untested"}
{"id": "fdcXWS", "name": " Fab10 #inktober2021 \"pick\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nSee reference image at bottom.", "tags": ["2d", "music", "instrument", "short", "strings", "reproduction", "pick", "inktober2021", "guitare"], "likes": 22, "viewed": 504, "published": 3, "date": "1633796947", "time_retrieved": "2024-07-30T18:57:09.094214", "image_code": "#define S(v)  smoothstep(4./R.y, 0., v ) \n#define R(a)  mat2(cos( a + vec4(0,11,33,0) ) )\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y * R(.15), // guitare tilted frame\n          V = (U +vec2(.1,.07)) * R(.3);  // pick overtilted frame\n   \n   O = texture(iChannel0, .5*U) * ( 1.3- .7*(.3-U.y) );          // neck\n   O *=  1. + R.y/2e2 * dFdy(O.r);   // with some bump\n   float  m = S(U.y-.3),                                         // m = neck mask\n          x = fract(U.x)-.5; // p = 2.;\n   O = mix(O, vec4(1.5-sin(1.57*x/.03))/3., S(abs(x)-.03 ) );    // frets\n   \n#define D(x,y) O = mix(O, vec4(.7), S(length(U-vec2(x,-y))-.1)); // marks\n   D( 1, .06)\n   D( 1,1.15)\n   D(-1, .6 )\n   \n   O *= m; // clamp neck & frets to border\n   \n//#define pow(a,b) pow(max(a,0.),b)                              // pick \n//   x = pow( pow(V.y+.3,p) + pow(2.*V.x-V.y,p) + pow(-2.*V.x-V.y,p) , 1./p);\n#define E(v) max(0.,v) * max(0.,v)\n   x = sqrt( E(V.y+.3) + E(2.*V.x-V.y) + E(-2.*V.x-V.y) ); // simplif for p = 2.\n   O *=  .5+.5* smoothstep(0.,.4, x-.8 );                        // shadow\n#define P  O = mix(O, vec4(1,.8,0,1), S( x -.8 ) );\n   P\n   \n   U.y -= .15;                                                   // strings\n#define C(w,s) O = mix(O, vec4(1,.6,.4,0)*(1.+U.y/.01/w)*abs(cos(s U.x*2e2/w)), S(abs(U.y)-.01*w) );\\\n               O *= .5+.5* smoothstep(0.,.1, abs(U.y+.05) ) ;    /* shadow */ \\\n               U.y += .3; \n   C(1.,)\n   C(.8,)\n   C(.6,)\n   C(.3,.7+0.*)\n   C(.2,.7+0.*)\n   U.y -= 1.5;\n   \n   O += (1.-m) *.6* (1.-.4*length(U));                           // background\n   \n   if ( min( -U.y, abs(U.y+.6) ) < .15 )  P                      // pick above strings 1,3\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcXWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdtXzs", "name": "Burning inferno", "author": "guil", "description": "Nearly the same as my previous shader.", "tags": ["inferno"], "likes": 15, "viewed": 580, "published": 3, "date": "1633786733", "time_retrieved": "2024-07-30T18:57:10.245137", "image_code": "mat2 R(float a){\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n\nvoid mainImage( out vec4 C, vec2 FC )\n{\n    float o,i=0.,e,f,s, g=4., t=iTime, k=.1;\n    vec3 p,q, r=iResolution, l=vec3(2.);\n    C = vec4(0);\n    \n    for(;i++<1e2;g+=min(f,max(e,.4))*k){\n        s=2.;\n        p=vec3((FC.xy-r.xy/s)/r.y*g,g-5.);\n        k*=1.015;\n        p.yz*=R(-.7);\n        p.z+=t;\n        for(e=f=p.y;s<4e2;s/=.6)\n            p.xz*=R(s),\n            q=p,\n            q.x+=t*.2*log(s),\n            e+=abs(dot(sin(q.xz*s*.1)/s,l.xz*2.)),\n            f+=abs(dot(sin(p*s*.15)/s,l));\n         o=1.+(f>1e-3?(e>.01?f*e:-exp(-e*e)):-1.);\n         \n         C *= .96;\n         C.rgb += .1*max(o,.5)*(exp(-f)*vec3(.5,.3,.2)/4.+exp(-e)*vec3(.2,.1,.0));\n         }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 68], [71, 71, 110, 110, 751]], "test": "untested"}
{"id": "sdtSzs", "name": "Shake Dat Mouse", "author": "zovox", "description": "Good morning. Just made a small update so that this now responds to the mouse. Have fun ;p", "tags": ["mouse", "shake", "dat"], "likes": 1, "viewed": 251, "published": 3, "date": "1633782830", "time_retrieved": "2024-07-30T18:57:11.098855", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define time ((saw(float(__LINE__)/GR)+1.0)*(iTime/E/PI/GR+1234.4321)/E+(sin(iMouse.x/iResolution.x+float(__LINE__)/GR)+sin(iMouse.x/iResolution.x+float(__LINE__)/GR))*PI*GR*E)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\n\nfloat smooth_floor(float x)\n{\n\treturn floor(x)+smoothstep(.75, 1., fract(x));\n}\n\nvec2 tree(vec2 uv)\n{\n    \n    vec2 p = uv*2.-1.;\n    \n\t\n        float angle = smooth_floor((time))*PI/12.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 1./MAX_DIM);\n        \n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(smooth_floor(time/PI)/500., 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n    return p;\n}\n\nvec2 flower(vec2 p)\n{\n\tp *= rotate(time);\n\tfloat rots = smooth_floor(3.+6.*saw(time/E))+1./MAX_DIM;\n\tfloat angle = atan(-p.y, -p.x);\n\tfloat radius = length(p);\n\tangle = floor(((angle/PI)*.5+.5)*rots);\n\n\n\tvec2 a = vec2(1., 0.);\n\tvec2 b = vec2(1., 1./MAX_DIM);\n\tvec2 c = vec2(0., 1./MAX_DIM);\n\tvec2 d = vec2(0., -1./MAX_DIM);\n\t\n\tb *= rotate(angle/rots*2.*PI);\n\tangle += 1.;\n\ta *= rotate(angle/rots*2.*PI);\n\t\n\treturn (invBilinear( p, a, b, c, d ));\n}\n\n\nfloat square(vec2 uv, vec2 uv0)\n{\n    uv = (uv*2.-1.)*GR;\n    return abs(saw(uv.y+uv0.x-uv0.y+time)-uv.x);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float r = log(length(uv)+1.)/2.;\n    float theta = atan(uv.y, uv.x)/PI-r*sin(time/E/PI/GR)/PI;\n    return vec2(saw(r+time/E/E),\n                saw(theta+time/GR/E))*2.-1.;\n}\n\nvec3 phase(float map)\n{\n    return vec3(sin(map),\n                sin(4.0*PI/3.0+map),\n                sin(2.0*PI/3.0+map))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = uv.xy*2.-1.;\n    uv0.x *= max(iResolution.x/iResolution.y, 1.);\n    uv0.y *= max(iResolution.y/iResolution.x, 1.);\n\tuv0 = uv0*.5+.5;\n    float map = 0.0;\n    \n    float lambda = 4.0;\n\tconst int max_iterations = 12;\n\n    float scale = 3.0*PI+(time*PI*GR*E);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv.x *= max(iResolution.x/iResolution.y, 1.);\n    uv.y *= max(iResolution.y/iResolution.x, 1.);\n    uv.xy += vec2(cos(time*.234),\n                  sin(time*.345))*scale/2.;\n\tfloat m = smoothstep(0.45, .55, saw(time/E/PI));\n    uv.xy = spiral(uv.xy*scale)*m+(1.-m)*(uv0);;\n    \n\tfloat nature = smoothstep(.45, .55, saw(time/GR/E))*(1.-m);\n\tuv =  uv*(1.-nature)+flower(uv0*2.-1.)*nature;\n\t\n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = (float(i)/(float(max_iterations) ));\n        uv.xy = saw(tree(uv.xy));\n\t\t\tmap += square(uv.xy, uv0);\n\t\tuv0 = uv;\n    }\n    \n    float w = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    float b = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    fragColor.rgb = (flux(map))*\n        \t\t\t\n        \t\t\tclamp(map, 0.0, 1.0);\n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 433, 433, 461], [463, 463, 483, 483, 588], [589, 589, 607, 607, 646], [648, 648, 666, 666, 715], [716, 716, 791, 791, 1763], [1766, 1766, 1788, 1788, 1836], [1839, 1839, 1868, 1868, 1918], [1920, 1920, 1940, 1940, 2913], [2915, 2915, 2936, 2936, 3362], [3365, 3365, 3398, 3398, 3473], [3476, 3476, 3498, 3498, 3677], [3679, 3679, 3702, 3702, 3811]], "test": "untested"}
{"id": "ssdXRs", "name": "Linear transformation", "author": "trinketMage", "description": "Linear transformation testing from 3Blue1Brown on YT\n", "tags": ["lineartransformation", "cineshader", "matrix2"], "likes": 2, "viewed": 4620, "published": 3, "date": "1633781406", "time_retrieved": "2024-07-30T18:57:11.977505", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv -= 0.5;\n    float count = 16.;\n    \n    mat2 transformation = mat2(\n        cos(iTime), -sin(iTime),\n        sin(iTime), cos(iTime)\n    );\n    vec2 mvUv = transformation * uv;\n\n    vec2 cell = fract(mvUv * count);\n    \n    fragColor = vec4(cell.x * cell.y);\n    fragColor.a *= 0.25;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Linear transformation\",\n\t\"description\": \"Linear transformation and matrices\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 388]], "test": "untested"}
{"id": "sdtSRs", "name": " Fab9b #inktober2021 \"pressure\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nnote that it also works as Fab17b \"collide\" ;-)", "tags": ["2d", "simulation", "physics", "short", "gas", "pressure", "inktober2021"], "likes": 14, "viewed": 439, "published": 3, "date": "1633774213", "time_retrieved": "2024-07-30T18:57:12.853165", "image_code": "#define A(V) max(abs(V).x,abs(V).y)\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  U = 1.2*( u+u - R ) / R.y, P, M, B;\n    \n    float d, m = 9., t=.99;\n    int i,k=0;\n    for (; k <64; k++)                      // draw particles\n        P = T(vec2(k%8,k/8)).xy,\n        d = length(P-U),\n        d < m ? m = d, i = k, M = P : P;\n    \n    O = vec4( S(m-.01) );                   // red if colliding borders\n    if ( A(M) > t ) O.gb *= 0.;\n    \n    P = U-M, B= -T(vec2(i%8,i/8)).zw*20.;   // motion blur trace\n    d = clamp(dot(P, B) / dot(B,B), 0., 1.);\n    O += .6*(1.-d) * S( length(P - B * d) -.01 );     \n       \n    O += .5*S(  abs(A(U)-1.02) -.01 );      // draw box\n\n#define B(s,x) if ( s M.x > t && s U.x > t )  O.gb *= 0.;\n    B(-,x) B(-,y) B(,x) B(,y)\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 O, vec2 U)\n{\n    if (max(U.x,U.y)>8.) return;  // only 64 partics\n    \n    if (iFrame==0) { O = vec4( H(U), .01*H(U+.1) ); return; } // init\n                                      // normalize() // more physical but less pretty\n    O = T(U);\n    \n    vec2 A = abs( O.xy += O.zw ); // move particle\n    \n    if (A.x>1.) O.z = -O.z;       // bounce\n    if (A.y>1.) O.w = -O.w;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define S(v)  smoothstep(5./R.y,0., v ) \n#define H(p) (2.*fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)-1.)\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7stXzl", "name": " Fab9 #inktober2021 \"pressure\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]", "tags": ["2d", "short", "inktober2021", "peerpressure"], "likes": 4, "viewed": 224, "published": 3, "date": "1633771681", "time_retrieved": "2024-07-30T18:57:13.773704", "image_code": "#define S(v)  smoothstep(3./R.y,0., v ) \n#define H(p)  fract(sin((p)*vec2(12.9898, 78.233)) * 43758.5453)\n#define C(c)  O = mix(O, vec4(c-c*S(abs(d)-.01)), S(d) );\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y, A=U,\n          C = sin(40.*U); C*=C.yx;\n          \n    O = vec4( .9+.1*clamp(C.x/fwidth(C.x),0.,1.));          // background\n    A.x = abs(A.x);\n    \n    float a=0., d;\n    for ( ; a < 5.; a ++ )                                  // 9 buddies\n        d = length(A - vec2(.7,.5)*sin(.67*a+vec2(0,33))*(1.+.05*sin(2.*iTime))) - .25,\n        C(.5);                                                     // +6.3*H(a) // asynch variant\n        \n    \n    d = length(U+=.01*H(iTime)-.005)-.25;                   // poor guy\n    C(1.);\n    \n    a = .1+.01*sin(3.*iTime); U.y += a-.1;\n    d = abs(U.x+.1)- ( U.y>0. ? a/3.*smoothstep(a,0.,U.y)   // tear\n                              : a/.3*sqrt(.01-U.y*U.y*9.) );\n    O = abs(U.y) < a ? mix(O, vec4(0,.8,1,1),  S(d) ) : O;\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stXzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 200, 200, 1031]], "test": "untested"}
{"id": "NddSzs", "name": "Typewriter", "author": "davidar", "description": "A simple typewriter effect", "tags": ["text", "word", "fonts", "type", "characters"], "likes": 15, "viewed": 523, "published": 3, "date": "1633761110", "time_retrieved": "2024-07-30T18:57:14.825890", "image_code": "#define TEXT_ROWS 2\n\nvec4 char(vec2 p, int c) {\n    if (p.x < 0. || p.x > 1. || p.y < 0.|| p.y > 1.) return vec4(0,0,0,1);\n    return texture(iChannel0, p/16. + fract(vec2(c, 15-c/16)/16.));\n}\n\n#define A(c) text = min(text, char(uv * float(TEXT_ROWS) + vec2(-0.5 * cursor.x, cursor.y) + 0.02 * (hash22(cursor) - 0.5), c).w); cursor.x++;\n#define CRLF cursor.x = 0.; cursor.y++;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.y;\n    float text = 1.;\n    vec2 cursor = vec2(0, 1 - TEXT_ROWS);\n\n    A(0x48) A(0x65) A(0x6c) A(0x6c) A(0x6f) A(0x2c) CRLF // Hello,\\n\n    A(0x57) A(0x6f) A(0x72) A(0x6c) A(0x64) A(0x21)      // World!\n\n    text += 0.02 * (FBM(20. * uv.xyy) - 0.5);\n    text += 0.01 * (FBM(100. * uv.xyy) - 0.5);\n    float ink = smoothstep(0.5, 0.49, text);\n    ink -= smoothstep(0.65, 0.75, FBM(25. * uv.xyy));\n    fragColor = vec4(0.9, 0.85, 0.8, 1);\n    fragColor = mix(fragColor, vec4(0.8, 0.75, 0.7, 1), smoothstep(0.55, 0.49, text));\n    fragColor = mix(fragColor, vec4(0), clamp(ink, 0., 1.));\n    fragColor += 0.05 * FBM(300. * uv.xyy);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.0-2.0*f);\n\n    return mix(\n\t\tmix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n\t\t\tmix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n\t\t\tf.y),\n\t\tmix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n\t\t\tmix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p )\n{\n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p;\n\tf += 0.2500 * Noise(p); p = m*p;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 47, 47, 192]], "test": "untested"}
{"id": "fd3Szl", "name": "Dots Loader", "author": "Krischan", "description": "A small and very nice loading animation with 8 glowing dots. Found at https://glslsandbox.com/e#69806.1 - Author unknown, customized a little.", "tags": ["glow", "dots", "spinning", "loader", "ps2"], "likes": 23, "viewed": 1736, "published": 3, "date": "1633728755", "time_retrieved": "2024-07-30T18:57:15.655671", "image_code": "const float DOTS = 8.0;\nconst vec3 COLOR = vec3(0.3, 0.6, 1.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float f = 0.0;\n    \n    for(float i = 1.0; i <= DOTS; i++)\n    {\n        float s = sin(0.7 * iTime + (i * 0.5) * iTime) * 0.2;\n        float c = cos(0.2 * iTime + (i * 0.5) * iTime) * 0.2 ;\n        f += 0.01 / abs(length(p*0.5 + vec2(c, s)));\n    }\n    \n\tfragColor = vec4(COLOR*f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3Szl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 120, 120, 502]], "test": "untested"}
{"id": "NdtSRs", "name": "Mountains at dawn 3", "author": "jarble", "description": "Mountains at dawn\nUsing Yonatan clouds/mountains combined field", "tags": ["clouds", "mountains"], "likes": 17, "viewed": 476, "published": 3, "date": "1633728450", "time_retrieved": "2024-07-30T18:57:16.458524", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 l = vec3(1.);\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n    vec2 p2;\n\t\n\tfor(e=f=p.y;s<8.;s*=-1.45)\n            p2 = sin((p.xz+vec2(p2.y,p2.x+s))*s*.5)/s,\n            //p.xz*=rot(s),\n            e+=abs(dot((sin((p-vec3(0,0,iTime))*s)/s),.4*l)),\n            f+=abs(dot(p2,l.xz)),\n            p.xz += p2;\n\to = 1.+ (f>.001?e:-exp(-f*f));\n    return vec2(max(o,0.),min(f,max(e,.07)));\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 2.5;\n    float dt = .035;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.03;\n        col = .95*col+ .09*vec3(c*c*c, c*c, c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.5); \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSRs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [210, 252, 275, 275, 622], [625, 625, 662, 662, 954], [957, 957, 1014, 1014, 1669]], "test": "untested"}
{"id": "fddSzl", "name": "Mountains at dawn 2", "author": "guil", "description": "Mountains at dawn\nUsing Yonatan clouds/mountains combined field", "tags": ["clouds", "mountains"], "likes": 29, "viewed": 1010, "published": 3, "date": "1633723649", "time_retrieved": "2024-07-30T18:57:17.245421", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 l = vec3(1.);\n\n//Yonatan clouds/mountains combined field\nvec2 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o;\n\t\n\tfor(e=f=p.y;s<8e2;s*=1.6)\n            p.xz*=rot(s),\n            e+=abs(dot(sin(p*s)/s,.4*l)),\n            f+=abs(dot(sin(p.xz*s*.5)/s,l.xz));\n\to = 1.+ (f>.001?e:-exp(-f*f));\n    return vec2(max(o,0.),min(f,max(e,.07)));\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 2.5;\n    float dt = .035;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{                \n        vec2 v = field(ro+t*rd);  \n        float c=v.x, f=v.y;\n        t+=dt*f;\n        dt *= 1.03;\n        col = .95*col+ .09*vec3(c*c*c, c*c, c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.5); \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddSzl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [210, 252, 275, 275, 521], [524, 524, 561, 561, 853], [856, 856, 913, 913, 1568]], "test": "untested"}
{"id": "fdtSRl", "name": "resolution change buffer", "author": "ollj", "description": "iMouse to paint some dumb dots.\n\niChannel0 only once sets the texture of most pixels.\nbottom left pixels store previous resolutions.\nit notices changes in resolution and remaps uv to the size of the previous backbuffer.\nbut it crops too soon.", "tags": ["branchless", "tonemap", "isinside", "remap", "caseless"], "likes": 5, "viewed": 1806, "published": 3, "date": "1633716493", "time_retrieved": "2024-07-30T18:57:18.102130", "image_code": "\nvoid frameSort(inout vec2 a,inout vec2 b//bottomLeft,topRight (as they SHOULD become)\n){vec2 c=vec2(min(a.x,b.x),min(a.y,b.y))\n      ;b=vec2(max(a.x,b.x),max(a.y,b.y));a=c;}\n\n\nfloat dither(vec2 u){return mod(u.x+u.y,2.);}\n\nvoid mainImage( out vec4 o,vec2 u \n){\n //;if (length(iMouse.xy/iR.xy-u/iR.xy)<.2)   o=vec4(0)\n //;else o=vec4(1)\n o=texture(iChannel0,u/iResolution.xy)\n ;}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iM iMouse\n#define iR iResolution\n\n#define vec1 float\n\nfloat ma(vec2 u){return max(u.x,u.y);}\n\n//vec2 i12v1(ivec2 a){return vec2(intBitsToFloat(a));}\n\n//code of this shader merges map()==remap() and tonemap() by calling a shared subroutine mapu()\n//without using or showing ANY of that.\n//the remap() function is not used by this shader.\n//the toemap() function is not used by this shader.\n//i just wanted to store this memo-code in a tiny unrelated shader to load fast.\n//\n//map() use case:\n//whenever a shader buffers screenspace coords\n//, and you want to translate between different resolutions\n//, you may need map()=remap()\n//\n//this shader shows more in terms of simplicity\n\n/*\n//for example:\n//Ýou buffer [previous] resolution=get(BufferAddressOfPreviousResolution)\n//You want to rescale to a current iResolution.xy (for incremental Averaging (within TemporalReprojection))\n//And You want to rescale from and to a normalized Uv coord.\n//\n//for example, you want to pixelate the resolution of your scene by any percentage, by remapping to a lower resolution.\n\n//We have 3  different domains, and a var with the same RELATIVE point in them.\nfragCoordNow___domain=[    vec2( 0),iResolution.xy]\nfragCoordPrev__domain=[    vec2( 0),   previous.xy] previous.xy=iResolution.xy, but buffered in prefious frame, and read 1 frame later.\n       uv______domain=[-aspectRatio,aspectRatio.xy] aspectRatio.xy=vec2(1,iResolution.y/iResolution.x) (or was it its inverse?)\n\n//\n//We can use map() translate between these 3 domains:\nvec2 uv           =map(fragCoordNow  ,        vec2( 0),iResolution.xy , -aspectRatio.xy,aspectRatio.xy) //==frame(uvNow)\nvec2 uv           =map(fragCoordPrev ,        vec2( 0),    revious.xy , -aspectRatio.xy,aspectRatio.xy)\n//\nvec2 fragCoordNow =map(fragCoordPrev ,        vec2( 0),   previous.xy , vec2(0),iResolution.xy)\nvec2 fragCoordNow =map(uv            , -aspectRatio.xy,aspectRatio.xy , vec2(0),iResolution.xy)\n//\nvec2 fragCoordPrev=map(uv            , -aspectRatio.xy,aspectRatio.xy , vec2(0),previous.xy)\nvec2 fragCoordPrev=map(fragCoordNow  ,        vec2( 0),iResolution.xy , vec2(0),previous.xy)\n*/\n\n//defines are used to do vec2 vec3 vec4 inputs in parallel (and also, because a special case is a subroutine here (kinda strange))\n//(unholy core) union of tonemap() and remap() \n#define mapu(a,b,c,d,e) (a)*(b)/(c+(d)*(e))\n//return [x] of domain[a,b] remap()ped to domain [c,d], as if a=c && b=d;transform [a,b]->[c,d]\n#define map(x,a,b,c,d) mapu(x,1.,0.,a+d-(b)-(c),1.)+(c)\n\n//common special vases of the above general cases are:\n\n//common quadratic gamma correction tonemap:\nvec3 tonemap(vec3 x){return mapu(x,2.51*x+.06,.14,x,.59+2.43*x);}\n\n//common special case remap() \n//return [x] of domain[a,b] remap()ped to domain [0,1], as if a=0 && b=1;transform [a,b]->[0,1] == remap(x,a,b,0.,1.) \n//as in smoothstep(a,b,x) https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\n#define maps(x,a,b) (x-(a))/(b-(a))\n//#define map(x,a,b,c,d) (maps(x,a,b)*(d-(c))+c) //convoluted alternative\n\n//map(), but [ d == -c ] \n//to translate from Min&&maxBoundaries to Center&&width\n#define mapm(x,a,b,d) (maps(x,a,b)*(d+d)-(d))\n//map(), but [ b == -a ] \n//to translate from Center&&width to Min&&maxBoundaries\n#define mapc(x,b,c,d) mapu(x,1.,0.,a+a+d-(c))+(c)\n\n\n//remap u.x and u.y (==fragCoord.xy) to [-1,1]*s (also unsquashing aspectRatio)\nvec2 frame(vec2 u,vec2 r,vec2  s){s*=vec2(r.x/r.y,1);return mapm(u,vec2(0),r,s);}\nvec2 frame(vec2 u,vec2 r,float s){return frame(u,r,vec2(s));} // [0,iR.xy] -> [-1,1]\nvec2 frame(vec2 u,vec2 r        ){return frame(u,r,1.);}//default zoom is 1.\n//frame(u) is identical to: {u=u/iR.xy;u=u*2.-1.;u.x*=iR.x/iR.y;return u;}\n\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec4 a){return min(mi(a.xy),mi(a.zw));}\n//#define ma(a) (-(mi(-(a))))\n\n//float box(vec2 u,vec2 w,vec2 v){return ma(abs(u-w)-v);}\n//i can use box() within outsideOpen(), but its too convoluted and only half as precise.\n/*\nfloat box(vec2 u,vec2 w){return ma(abs(u-w));}\n//extended box function, to use within outsideOpen()\nfloat outsideOpen  (vec2 u,vec4 l){\n ;vec2 w=((l.zw-l.xy)*.5)//halfWidth\n ;return -sign(min(box(l.xy+w,u,w),0.))\n ;return ceil(mi((l-u.xyxy)*S.xxzz))//this line is identical to all of ther above\n ;}\n */\n\nconst vec4 S=vec4(-1,0,1,2);\n//isInside  is a  CLOSED interval 2d box\n//isOutside is an OPEN   interval 2d box\nfloat outsideOpen  (vec2 u,vec4 l){return ceil( mi((l-u.xyxy)*S.xxzz));}\nfloat  insideClosed(vec2 u,vec4 l){return ceil(-mi((l-u.xyxy)*S.xxzz));}\nfloat outsideOpen  (vec2 u,vec2 bl,vec2 tr){return  outsideOpen(u,vec4(bl,tr));}\nfloat  insideClosed(vec2 u,vec2 bl,vec2 tr){return insideClosed(u,vec4(bl,tr));}\n", "buffer_a_code": "void mainImage(out vec4 o,in vec2 u\n){o-=o\n ;if (ma(u)<2.) o=vec4(iR.xy,0,1)//backbuffer of previous iR\n ;else{\n  ;if (iFrame<10){o=texture(iChannel1,frame(u,iR.xy,1./4.));return//set image once\n  ;}else{\n   ;vec2 iRp=texture(iChannel0,vec2(0)).xy\n  ;if (iR.xy!=iRp.xy\n  )o=texture(  iChannel0,\n  vec2(u.x/iR.x*iRp.x/iR.x\n      ,u.y/iR.y*iRp.y/iR.y) )       //remap u to old resolution.\n  ;else o=texture(iChannel0,u/iR.xy)//no resolution change.\n  ;if(iMouse.z>0.){//paint mode\n   ;float l=length(iMouse.xy/iR.xy-u/iR.xy)\n   ;if (l<.05)   o=vec4(sin(l*31.*4.)*.5+.5);\n  }\n  ;}\n ;}}", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 89, 89, 174], [177, 177, 198, 198, 222], [224, 224, 261, 336, 379]], "test": "untested"}
{"id": "7stSzf", "name": "Grass Scene #1 [Griar]", "author": "Yusef28", "description": "Based on the virtual meadow tutorial by Nusan: https://www.youtube.com/watch?v=vpwukN_FUa8&t=4924s&ab_channel=AntoineZanuttini\nThis looks really bad on firefox... [Fixed]\n30 fps AVG Secure Browser | 5 fps google chrome", "tags": ["terrain", "grass", "glow", "moon", "night", "snow", "scene"], "likes": 44, "viewed": 1449, "published": 3, "date": "1633714239", "time_retrieved": "2024-07-30T18:57:19.040622", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 08-10-2021                                  //\n// Status: On Going                                        //\n// Topic: Grass / Scene Creation                           //\n// Sources: Nusan Tutorial                                 //\n//          https://www.youtube.com/watch?v=vpwukN_FUa8    //\n// Listening to: Fallen - Night Lovell Type Beat \"GREY FIRE\"                                          //\n// License: Creative Commons NonCommercial license (CC NC) //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n//If anyone has tips on how to deal with the aliasing around the \n//pillars, without things getting too slow, I'd appreciate it.\n\n/*\nmusic that goes well with this:\n\nAbandoned pools - The remedy\nCelldweller - Afraid this time\nFallen - Night Lovell Type Beat \"GREY FIRE\"\n*/\n\n// I named this Griar based on grey + fire and I guess grass + briar\n\n      ////////////////////////////////////////////\n      //                                       //\n////////      CONSTANTS                      //\n      //                                   //\n      /////////////////////////////////////\n      \n#define far 110.\n#define pi acos(-1.)\n#define BLADE_NUM 5.\n#define BLADE_HEIGHT 3.\n#define BLADE_VAR_HEIGHT 1.\n#define TRACE_MAX 100.\n#define TRACE_ADD_AMOUNT 0.55\n#define TERRAIN_HEIGHT 10.\n#define WIND_SPEED 4. //2\n#define PILLAR_ROW_DEPTH -2.\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n      ////////////////////////////////////////////\n      //                                       //\n////////     ANIMATED TIME FUNCTIONS         //\n      //                                   //\n      /////////////////////////////////////\n      \n#define ats 4.\n//first create stairs \n#define stairs floor(iTime*atScale)*4.\n//or modstairs\n#define modStairs mod(iTime, 4.);\n//then create a swoop for each stair \n#define swoop pow(fract(iTime*atScale),8.)\n//or a smoothstep\n#define smooth smoothstep(3.5,4.,fract(iTime*atScale)*4.)\n//animation time constant?\n#define at iTime*0.9\n//or a sinwave\n#define sn iTime*8. + sin(iTime*2.)*2.+2.\n//then add the swooping stairs to time\n//or instead just do the right thing\n#define rightThing floor( at/4. )*ats + pow( fract( at/4. ) , 20. )*ats + at/4.\n#define animatedTime rightThing\n//mix(stairs,stairs+4.,fract(iTime*atScale)*4.+sin(iTime*atScale)*4.)\n//+ smoothstep(2.,4.,( 1.-abs( sin(iTime/4.) ))*20.)\n\nfloat noise(vec2 uv){\n\n    vec3 p3  = fract(vec3(uv.xyx) * .1831);\n    p3 += dot(p3, p3.yzx + 339.33);\n    return fract((p3.x + p3.y) * p3.z);\n  //return fract(sin(dot(uv,  vec2(23.,9341.)))*35342.);\n}\n\nfloat hash11(float x){\n    return fract(sin(x*43.)*21340.);\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat noise1d(float x){\n    float init = hash11(floor(x));\n    float next = hash11(floor(x) + 1.);\n    float f = smoothstep(0.,1.,fract(x));\n    return mix(init, next, f);\n    \n}\nfloat noise2d(vec2 uv){\n  return texture(iChannel0,uv/64.).x;\n  \n  //This was fine at home but compile time\n  //on shadertoy doesn't like it\n  /*\n  vec2 id2d = floor(uv);\n  vec2 f2d = fract(uv);\n  \n  float a = noise(id2d);\n  float b = noise(id2d + vec2(1.,0.));\n  float c = noise(id2d + vec2(0.,1.));\n  float d = noise(id2d + vec2(1.,1.));\n  \n  vec2 smoothFract2d = smoothstep(0.,1.,f2d);\n  \n  float ab = mix(a,b,smoothFract2d.x);\n  float cd = mix(c,d,smoothFract2d.x);\n  return mix(ab,cd,smoothFract2d.y);*/\n  \n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\nfloat fbm(vec2 p){\n  float s = 0.5;\n    float f = s*noise2d(p); s/=2.; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.; \n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.;\n  f += s*noise2d(p); s/=2.; p*=rot45; p *= 2.; \n    return f;\n}\n\n//ended up being just noise\nfloat fbm1(vec2 p){\n  float s = 0.5;\n    float f = s*noise2d(p); s/=2.; p *= 2.;\n\n    return f;\n}\n//ended up being just an fmb\nfloat warpedfbm(vec2 p){\n    \n  return  fbm(p/4.);\n\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat cube(vec3 p, vec3 d){\n      p = abs(p) - d;\n  return length(max(vec3(0.),p)) + min(0.,max(p.x,max(p.y, p.z)));\n}\n\nfloat cylinder(vec3 p, float r, float h){\n    return max(length(p.xz) - r, -(h-abs(p.y)) );\n}\n\n//plane height\nfloat planeHohe = 0.4;\nfloat plane(vec3 p){\n    return p.y + planeHohe;\n}\n\nfloat id = 0.;\nfloat glow = 0.;\n\n\n\n      ////////////////////////////////////////////\n      //                                       //\n////////             MODELLING               //\n      //                                   //\n      /////////////////////////////////////\n      \n//make the snow/wisps\n  \nfloat wisps(vec3 p, float f){\n    vec3 sp = p;\n  sp.y += animatedTime*80.;\n  float scale = 24.;\n  vec3 wID = hash33(floor(sp/scale))*2.-1.;\n  vec3 wispOff = wID*(scale/4.9);\n  sp = mod(sp, vec3(scale)) - scale/2.;\n  float wispy = length(sp - wispOff) - 0.03;\n  f = min(f, wispy);\n  if(wispy == f) glow += 0.01/pow(wispy,2.);\n  return f;\n}\n\n//the grass field function, I use three of these\n//shited a bit each time \n//to get a more random grass pattern. I could have also rotated\n//but it worked out\n      \nfloat feld( vec3 p , float FID){\n  \n  vec3 wind = vec3(\n                  vec2(\n                        sin( animatedTime*WIND_SPEED + p.xz / 6. - cos( animatedTime*1. - p.xz / 14. )) * 0.2 ), 0. ).xzy\n                      * step( 0. , p.y + 0.4 ) * ( 3. * p.y);\n  p += wind;\n  vec2 id = floor(p.xz/4.);\n  float rndID = noise(id);\n  float rndID14 = floor(rndID*3.999)+1.;\n  float piTeil = 2.*pi/rndID14;\n  p.xz = mod(p.xz,4.)-2.;\n  p.xz*= rot(piTeil+0.);\n\n  //I can have the initial height as high as I want with\n  //zero issue.\n  //grass height\n  float grassHohe = BLADE_HEIGHT+FID*0.5;\n  //artifacts when hoheVar is higher, \n  //it's something probably to do with what blackle\n  //made a video on but I'm not doing instancing so \n  //it's weird. I just make random numbers in a for\n  //loop so why can't they be bigger allowing for more\n  //height?\n  float hoheVar = BLADE_VAR_HEIGHT;\n  float th = 0.075;\n  float f = 9999.;\n  float bladeNum = BLADE_NUM;//5 min\n  vec3 pos;\n  float waveAmount = 0.0 ;\n  float spread = 1.5;\n  \n  for(float i = 1.; i < bladeNum+1.; i++){\n    \n    float bladeNum01 = i/bladeNum;\n    float xn11 = bladeNum01*2.-1.;\n    \n    //I definitly can't have an id based\n    //on the instance id p.xz above the loop.\n    //that is the instancing Sin and it's \n    //unforgivable.\n    //th = max(0.1,pow(sin(th + i + FID)*0.1+0.1,1.3));\n    \n    float y = noise(vec2(i+FID,i+45.9));\n    float zn11 = y*2.-1.;\n    float endHohe = grassHohe+y*hoheVar*2.;\n    th = 0.2 - p.y/endHohe/5.;\n    pos = vec3(xn11*spread + cos(p.y+i)*waveAmount,\n                0.,\n               zn11*spread-sin(p.y+i*8.)*waveAmount);\n    f = min(f,cube( p - pos, vec3( th,endHohe,th) ));\n    //f = min(f, length(p - pos - vec3(0.,endHohe,0.))-0.2);\n  }\n  \n \n  return f;\n  \n}\n\n//pillar function makes the rows of pillars and\n//two oddly placed pillars\n//pillats are just cyliners here, defored by a polar\n//map of the xz axis through sin so it's an atan(z,x) thing\n//plus boxes on top and bottom\n\nfloat pillar(vec3 p){\n  \n  //rows of pillars\n  p.xz *= rot(1.+pi/2.);\n  vec3 pp = p + vec3(0., PILLAR_ROW_DEPTH,0.);\n  //pp.z += 70.;\n  pp.z = abs(pp.z)-70.;\n  pp.x = mod(pp.x,8.)-4.;\n  float cyl = cylinder(pp,2.5+abs(sin(atan(pp.x,pp.z)*10.))*0.1, 8.);\n  //top and bottoms of pillars\n  float cap = cube(vec3(pp.x,abs(pp.y)-8.,pp.z),\n                   vec3(2.8,1.,2.8)) - 0.3;\n  cyl = min(cyl,cap);    \n\n\n//position of single pillar 1 behind  \n  pp = p + vec3(45., 3.9, 13.);\n  //pp*=2.;\n  pp.yz *= rot(.8);\n  cyl = min(cyl, cylinder(pp,2.5+abs(sin(atan(pp.x,pp.z)*10.))*0.1, 8.));\n  cyl = min(cyl,cube(vec3(pp.x,abs(pp.y)-8.,pp.z),\n                   vec3(2.8,1.,2.8)) - 0.3);\n  \n  \n  //position of single pillar 2\n  pp = p + vec3(25., 3.5, -33.);\n  //pp*=2.;\n  pp.yz *= rot(pi/2.);\n  cyl = min(cyl, cylinder(pp,2.5+abs(sin(atan(pp.x,pp.z)*10.))*0.1, 8.));\n  cyl = min(cyl,cube(vec3(pp.x,abs(pp.y)-8.,pp.z),\n                   vec3(2.8,1.,2.8)) - 0.3);\n\n  //cube to subtract from one of the row pillars\n  pp = p + vec3(20., -12.5-PILLAR_ROW_DEPTH, 70.);\n  pp.yz *= rot(0.9);\n  cyl = max(cyl, -cube(pp,vec3(5.,20.,5.)) - 0.3);\n  \n  //float bridge = cube(p-vec3(0.,5.,0.), vec3(1000.,1.,5.))-0.2;\n // cyl = min(cyl, bridge);\n  return cyl;\n}\n\n//distance field where we put it all together\n\nfloat map( vec3 p ){\n  \n  //I get a few artifacts with this probably because it's\n  //adjusting the height of everything in the scene\n  //before instancing. So it's kind of like the unforgivable sin.\n   vec3 terrainHohe = vec3(0.,warpedfbm(p.xz/4.)*\n                              TERRAIN_HEIGHT,0.);\n  \n   //field id for moe randomness between feilds\n   float feldID = 0.;\n   //first field\n   float f =  feld(p + terrainHohe, feldID);\n   f = min( f, plane( p + terrainHohe ) );\n   \n   //shift p.xz\n   vec3 shift = vec3( 1.9, 0., 1.9 );\n   //increment field id\n   feldID++;\n   f = min( f, feld(  p + terrainHohe + shift, feldID));\n   //one more time\n   shift = vec3( -1.9, 0., 3.9 );\n   feldID++;\n   f = min( f, feld(  p + terrainHohe + shift, feldID));\n\n //add pillars\n  f = min(f,pillar(p) );\n  //add wisps\n  f = wisps(p,f);\n  \n   return f;\n   \n  }\n  \n  \n      ////////////////////////////////////////////\n      //                                       //\n////////   IMPORTANT TRACE/LIGHT FUNCTIONS   //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n/*\nvec3 normal(vec3 p){\n   vec2 eps = vec2(0.001,0.);\n   return normalize(\n           vec3(\n           map(p-eps.xyy) - map(p+eps.xyy), \n           map(p-eps.yxy) - map(p+eps.yxy),\n           map(p-eps.yyx) - map(p+eps.yyx))\n           );\n}\n*/\n\n//fast normal\nvec3 normal(vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e);\n    }\n    return normalize(n);\n    }\n    \nfloat sss(vec3 p, vec3 ldir, float distToTravel){\n  \n  //Here is my basic understanding:\n  //step out form the hit point a bit in the direction of the sun\n  //find dist from map\n  //whne map dist is equal to step dist w have a/b = 1.\n  //when map dist is smaller we have a/b < 1.\n\n\n  return smoothstep(0.,1.,map(p + ldir*distToTravel)/distToTravel);\n  \n}\nfloat trace( vec3 ro, vec3 rd){\n    float t = 0., d;\n\n  \n  for(float i = 0.; i < TRACE_MAX; ++i){\n    \n    d = map(ro+rd*t);\n    \n    if( abs(d) < 0.001 ||  t > far) break;\n    \n    t += d * TRACE_ADD_AMOUNT;\n  }\n    return t;\n  }\n\n//create a ray based on ray origin and view target (ta)\nvec3 ray(vec2 uv, vec3 ro, vec3 ta){\n  \n    vec3 fwd = normalize(ta - ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(fwd,ri));\n  \n    \n    return normalize(uv.x*ri + uv.y*up + fwd*0.9);\n}\n\n\n\n      ////////////////////////////////////////////\n      //                                       //\n////////              MAIN                   //\n      //                                   //\n      /////////////////////////////////////\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n  vec2 uv = vec2(fragCoord.x / iResolution.x,      \n                 fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  //the black bars at the end\n  //and it adusts the focal length! A happy accident I almost\n  //didn't realize I was doing.\n  //it adjusts the focal length because calculating rd \n  //a bit further down will depend on uv\n  \n  uv *= (sin(animatedTime)*0.3+1.01);\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////          CAMERA WORK                //\n      //                                   //\n      /////////////////////////////////////\n      \n  vec3 ro = vec3(cos(animatedTime*.05)*20.5, 10., -10.);\n  //ro = vec3(cos(iTime*0.3)*20., 10. + 1.*sin(iTime), - 20.+sin(iTime*0.3)*20.);\n  \n  //ro.xz *= rot(.9 +iTime*0.3);\n  //ro+=4;\n  //ro.yz *= rot(iTime*0.71);\n  vec3 ta = ro + vec3(0., -.05, 1.);\n  vec3 rd = ray(uv, ro, ta);\n  rd.xz *= rot(5.45 + sign(sin(iTime/6.))*(animatedTime*.2)*.5);// sin(iTime*0.1)*.5);//iTime*0.13);//sin(iTime*0.3)*1.4);\n  vec3 col = vec3(0.);\n  \n      ////////////////////////////////////////////\n      //                                       //\n////////      TRACE AND LIGHT CALCS          //\n      //                                   //\n      /////////////////////////////////////\n      \n  vec3 lightDir = normalize(vec3(1.,.1,1.));\n  \n  float t = trace(ro, rd);\n  vec3 p = ro + rd*t;\n  vec3 n = normal(p);\n  \n  \n  \n  if(t < far){\n    \n      float steps = 5.;\n      float ss = 0.;\n      for(float i = 1.; i <= steps; i++){\n      //this sss shadow function comes from nusan and it\n      //ended up being very important for this shader\n      //because it does lighting ans shadow at the same time\n          ss += sss(p,normalize(vec3(1.,1.,1.)),i*8./steps);\n      }\n        \n        //*max(0.5,dot(lightDir,n))*diff);//+spec*1.;\n        // mix(col, vec3(1.), );\n      //col = (vec3(0.5,0.,0.) + (n*0.2+0.2) ) + max((p.y+4.)/4.,2.);//+spec*1.;\n     //col = (vec3(0.5,0.,0.) + (n*0.2+0.2) ) * max((p.y+4.)/2.,1.);//+spec*1.;\n        \n      \n      float diff = max(0.,dot(lightDir,n));\n        float spec = pow(max(dot(reflect(-lightDir,n),-rd),0.),4.);\n        \n        //original baseColor was:\n        //vec3(0.7,0.,0.) + (n*0.2+0.);\n        //but the faster normal function washes it out so I \n        //hacked it a bit to get the richness back\n      vec3 baseColor = vec3(0.8,0.,0.) + (n*0.2-0.1);\n      //baseColor.xz *= rot(-0.1);\n      \n      //call pillars one more time and if hit point is close\n      //enough to them, color with their material\n      if(pillar(p) < 0.005){\n        baseColor = vec3(0.1);// + n*0.1+0.1;\n        col = baseColor + diff*0.6 + spec*0.2;\n      }\n      //otherwise color based on grass (and wisps will also be\n      //initially coloed based on grass but it wont matter because\n      //the glow is all that matters. Glow is all that ever matters.\n      else{\n      //all the colors\n      //baseColor.xz *= rot(-.3);\n      col = mix( baseColor, vec3(1.,1.2,1.5), min(pow(max(p.y+.4,1.),3.)/40., 1.)*2.);\n      }\n      ss/=(steps/2.);\n      \n      //This first line is critical to the\n      //color of the scene. Everything is\n      //being shaded based on accumulated \n      //distances ffrm hit point light direction\n      //it's from Nusan's tutorial on youtube\n      col *= clamp(ss,0.,1.);\n      col += clamp(ss*0.1,0.,1.)*2.5;\n      //this is where th magic happends\n      col += pow(clamp(ss*0.1,0.,1.)*9.,8.)*(0.5+0.5*max(0.,dot(lightDir,rd)));\n  }\n  float ende = t;\n\n\n      ////////////////////////////////////////////\n      //                                       //\n////////      SKY SKY SKY SKY SKY            //\n      //                                   //\n      /////////////////////////////////////\n      \n  //col = vec3(pow(1.-abs(fbm(uv*8.)*2.-1.),8.));\n  //col = vec3(warpedfbm(uv*20.));\n  vec3 sky = vec3(0.);\n  float moonTextureCut = smoothstep(0.999,0.9995,dot(lightDir,rd));\n  float moonTexture = pow(fbm(rd.xy*70.+4.),4.)*1.5;\n  moonTexture *= moonTextureCut;\n  \n  //fbm(rd.xy*100.);\n // moonTexture = step(pow(max(0.,dot(lightDir,rd)),2000.),moonTexture);\n  //;\n  //moone\n  //moonlight calc \n  float moonValue = max(0.,dot(lightDir,rd));\n  float moonCircle = pow(moonValue,2000.)*5.;\n  moonCircle = clamp(moonCircle,0.,1.);\n  moonCircle -= moonTexture;\n  sky = mix(sky, vec3(0.95,0.95,1.),moonCircle); \n  //light\n  sky = mix(sky, vec3(0.2,0.95,1.), pow(moonValue,100.)*0.1);\n  //less light\n  sky = mix(sky, vec3(0.5,0.5,1.), pow(moonValue,20.)*0.1);\n  \n  //horizon under moon\n // sky = mix(sky, vec3(0.95,0.3,.2)*0.3, max(0.,pow(0.5-uv.y,2.5))*4.*0.);\n  sky = mix(sky, vec3(0.2,0.6,.8), max(0.,pow(0.5-rd.y+0.,3.5)));\n  \n  sky = mix(sky, vec3(0.6,0.2,.2), pow(max(0.,dot(-lightDir-vec3(0.,.4,0.),rd)),20.)*0.3*step(0.,rd.y+0.13));\n  \n  sky = mix(sky, vec3(0.2,0.6,1.), smoothstep(0.,1.,pow(max(0.,rd.y-0.1),30.))*0.5);\n  \n  /*\n   vec2 st = rd.xy;\n  //st.x += x;\n  st.y = mod( st.y + iTime*0.1 , 1. );\n  st.y += sin(iTime*0.1)*.3;\n  float comet = length((st.xy-vec2(0.0,0.03))*100.)-0.4;\n \n  st.y-=0.1;\n  float tail = max(abs(st.x*200)-0.1,abs(st.y*12.)-0.3+st.y*3.);\n  tail = smoothstep(0.,1.,tail);\n  comet = min(comet,max(tail,0.));\n  comet = 1.-smoothstep(0.2,1.,comet);\n  sky = mix(sky, vec3(1.), comet*step(0.,rd.z));\n  */\n  //float noiseforMoonAndStars = noise2d(rd.xy*350.);\n  //rotating the rd vector around xz to get away from\n  //the screen stretching that happsens to either side\n  //of x\n  vec2 rrdxy = vec2((rd.xz *rot(1.5)).x,rd.y);\n  vec2 starCoord = mod(rd.xy*500.,20.)-10.;\n  float starID = noise(floor(rd.xy*500.));\n  float stars = length(starCoord+starID*100.)-0.01;\n  sky = mix(sky, vec3(1.), max(0.,1.0-stars)*smoothstep(0.0,0.3,rd.y));\n  \n  starCoord = mod(rrdxy*200.,20.)-10.;\n  starID = noise(floor(rrdxy*200.));\n  stars = length(starCoord+starID*100.+5.)-0.1;\n  //sky = mix(sky, vec3(1.), max(0.,1.0-stars)*smoothstep(0.0,.3,rd.y));\n  //sky = mix(sky, vec3(1.), pow(noiseforMoonAndStars,200.)*4.);\n  sky = mix(sky, vec3(0.2,0.6,1.), \n        pow(\n        max(0.,\n        fbm( rd.xy*vec2(3.,8.)))*moonValue*1.6,12.)*0.2\n        *smoothstep(0.95,0.,abs(rd.x)));\n        \n   \n  sky = mix(sky, vec3(0.2,0.6,1.), \n        pow(max(0.,\n        fbm( (rrdxy)*4.))-0.2,2.)*0.2\n        *smoothstep(0.95,0.,abs(rrdxy.x)));\n  \n  float fog = pow(clamp((t)/(far-0.),0.,1.),7.);\n  col = mix(col, sky, fog);\n  //col = mix(col, vec3(0.2,0.8,1.), \n  //      pow(max(0.,\n  //      fog*fbm( vec2(atan(rd.x,rd.z)*pi*2.,rd.y*8.) + vec2(iTime,0.)))-0.2,2.));\n  \n  \n      ////////////////////////////////////////////\n      //                                       //\n////////      POST PROCESS AND GLOW          //\n      //                                   //\n      /////////////////////////////////////\n      \n  col = pow(col,vec3(0.79));\n  col += glow;\n  //col = vec3(moonTexture);\n  col *= smoothstep(0.001,0.0,abs(uv.y)-0.4);\n  fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSzf.jpg", "access": "api", "license": "proprietary-license", "functions": [[1626, 1626, 1648, 1648, 1773], [2721, 2721, 2742, 2742, 2922], [2924, 2924, 2946, 2946, 2985], [2986, 2986, 3005, 3005, 3074], [3076, 3076, 3099, 3099, 3254], [3255, 3255, 3278, 3278, 3768], [3815, 3815, 3833, 3833, 4147], [4149, 4177, 4196, 4196, 4274], [4275, 4304, 4328, 4328, 4357], [4359, 4359, 4389, 4389, 4415], [4417, 4417, 4444, 4444, 4535], [4537, 4537, 4578, 4578, 4630], [4670, 4670, 4690, 4690, 4720], [5028, 5028, 5057, 5057, 5366], [5534, 5534, 5566, 5566, 7304], [7526, 7526, 7547, 7570, 8766], [8815, 8815, 8835, 9014, 9664], [10169, 10183, 10204, 10204, 10416], [10422, 10422, 10471, 10701, 10776], [10777, 10777, 10808, 10808, 11007], [11009, 11065, 11101, 11101, 11310], [11560, 11560, 11617, 11617, 18599]], "test": "untested"}
{"id": "7s3Szs", "name": "Point light test", "author": "hyperknot", "description": "Point light test", "tags": ["pointlight"], "likes": 1, "viewed": 252, "published": 3, "date": "1633707931", "time_retrieved": "2024-07-30T18:57:19.876387", "image_code": "float area_light_small(vec2 uv) {\n  // dot(uv, uv) is the same as (uv.x*uv.x + uv.y*uv.y)\n  return 1. / dot(uv, uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    float v = area_light_small(uv) / 1200.;\n    v = pow(v, 1./2.2); // gamma mapping\n\t\n \tfragColor=vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3Szs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 89, 118], [121, 121, 177, 177, 353]], "test": "untested"}
{"id": "flX3W8", "name": "Hilbert Curves 3D", "author": "mla", "description": "Hilbert Curves in 3d using the Skilling algorithm", "tags": ["3d", "curve", "hilbert", "skilling"], "likes": 22, "viewed": 396, "published": 3, "date": "1633704051", "time_retrieved": "2024-07-30T18:57:20.818866", "image_code": "////////////////////////////////////////////////////////////////\n//\n// 3D Hilbert curves, raymarched. mla, 2021\n//\n// Uses algorithm of John Skilling, you can find his code at:\n// http://inference.org.uk/bayesys/test/hilbert.c\n// \n// The curve coordinates are computed in Buffer A, see there\n// for further details.\n//\n// Mouse/<up>/<down> moves viewpoint\n// keys 1-5 control the different recursion levels\n// 'a': turn on AA\n// 'r': autorotation\n//\n////////////////////////////////////////////////////////////////\n\nint lline;\n\nvec3 axestopoint(vec3 p, float s) {\n  p += 0.5;\n  p /= s;\n  return p;\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nivec4 getdata(int aindex) {\n  ivec2 uv = ivec2(aindex/int(iResolution.x),aindex%int(iResolution.x)).yx;\n  ivec4 data = floatBitsToInt(texelFetch(iChannel0,uv,0));\n  //ivec4 data = ivec4(texelFetch(iChannel0,uv,0));\n  return data;\n}\n\nfloat hdistance(vec3 z, int level) {\n  float lradius = 0.05*pow(0.45,float(level-1));\n  // z is in ±1 box, so change to [0,1]\n  z = 0.5*(z+1.0);\n  float s = float (1<<level);\n  vec3 z1 = z*s-0.5;\n  z1 = clamp(z1,0.0,s-1.0);\n  // Find the nearest vertex in \"axes\" coordinates\n  vec3 axes = round(z1);\n  // Look up next and previous vertex on the curve\n  ivec4 data = getdata(fromvec(axes));\n  int line = data.y; // Segment index on curve\n  if (level == 5) lline = line;\n  int maxline = (1<<(3*level))-1;\n  // Don't need to check for line == 0, have done that in buffer.\n  // Get \"axes\" coordinates of next and previous points\n  vec3 axes1 = tovec(data.z);\n  vec3 axes2 = line == maxline ? axes : tovec(data.w);\n\n  // Convert three points to real coordinates\n  vec3 p = axestopoint(axes,s);\n  vec3 p1 = axestopoint(axes1,s);\n  vec3 p2 = axestopoint(axes2,s);\n  float d = 1e8;\n  // And check the distances to the two segments\n  d = min(d,segment(z,p,p1)-lradius);\n  d = min(d,segment(z,p,p2)-lradius);\n  return 2.0*d; // Double distance as we halved z\n}\n\nfloat de(vec3 z, out int type) {\n  float d = 1e8;\n  type = 0;\n  int maxlevel = BITS;\n  //maxlevel = min(int(ceil(mod(iTime,8.0))),maxlevel);\n#if 0\n  d = hdistance(z,maxlevel);\n  type = maxlevel-1;\n#else\n  for (int i = 1; i <= maxlevel; i++) {\n    if (key(CHAR_0+i)) continue;\n    float d1 = hdistance(z,i);\n    if (d1 < d) {\n      type = i-1;\n      d = d1;\n    }\n  }\n#endif\n  float k = max(abs(z.x),max(abs(z.y),abs(z.z)));\n  return max(d,k-1.0);\n}\n\nfloat de(vec3 z) {\n  int type;\n  return de(z,type);\n}\n\nfloat eyedist = 1.8;//1.0/(1.0+iTime);     // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-4;      // Raymarching precision\nbool dorotate = true;\n\n\nvec3 getbackground(vec3 r) {\n  if (key(CHAR_B)) return vec3(0);\n  return pow(texture(iChannel1,r).xyz,vec3(2.2));\n  //return r; // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nvec3 getbasecolor(int type) {\n  if (key(CHAR_B)) {\n    //if (type == 4 && (lline-iFrame)%16 == 0) return vec3(1,0,0);\n    return vec3((float(BITS-type)-0.75)/float(3*BITS));\n  }\n  if (type == 0) return vec3(0.2);\n  if (type == 1) return vec3(1,0,0);\n  if (type == 2) return vec3(1,1,0);\n  if (type == 3) return vec3(0,1,0);\n  if (type == 4) return vec3(0.8);\n  if (type == 5) return vec3(0,0,1);\n  return vec3(1,0,1);\n}\n\nfloat march(vec3 q, vec3 r) {\n  float t = 0.01; // Total distance so far.\n  float maxdist = eyedist + 1.0;\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 50);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t;\n    // Reduce distance estimate when further away to avoid overstepping\n    t += d;\n    // We might go backwards!\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal0(vec3 p, float t) {\n  float eps = 1e-4;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-4;\n  vec2 e = vec2(eps,0);\n  float k = de(p);\n  return normalize(vec3(de(p + e.xyy) - k,\n                        de(p + e.yxy) - k,\n                        de(p + e.yyx) - k));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n      float t = iTime;\n      p.yz = rotate(p.yz,-t*0.05);\n      p.zx = rotate(p.zx,-t*0.05);\n  }\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  vec3 bg = getbackground(r);\n  float t = march(q,r);\n  if (t < 0.0) return bg;\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type = 0;\n  de(p,type);\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n    if (!key(CHAR_S)) {\n    float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),4.0);\n    color += specular;\n  }\n  //if (key(CHAR_F)) color = mix(color,getbackground(r),clamp(t/(2.0+eyedist),0.0,1.0));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  int AA = key(CHAR_A) ? 2 : 1;\n  dorotate = !key(CHAR_R);\n  eyedist += (0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////////////////////////////////////////////////////////////\n// Code from John Skilling, I've left his comments in for reference.\n// http://inference.org.uk/bayesys/test/hilbert.c\n// I (mla) have changed code to use a plain integer for the \"line number\"\n// & made a few stylistic changes. Since we just use this to populate\n// BufferA, it's not especially time-critical & is fairly performant anyway.\n////////////////////////////////////////////////////////////////////////////////\n\n// Original header, copyright etc.\n//\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Filename:  hilbert.c\n// \n// Purpose:   Hilbert and Linked-list utility procedures for BayeSys3.\n// \n// History:   TreeSys.c   17 Apr 1996 - 31 Dec 2002\n//            Peano.c     10 Apr 2001 - 11 Jan 2003\n//            merged       1 Feb 2003\n//            Arith debug 28 Aug 2003\n//            Hilbert.c   14 Oct 2003\n//                         2 Dec 2003\n//-----------------------------------------------------------------------------\n/*\n    Copyright (c) 1996-2003 Maximum Entropy Data Consultants Ltd,\n                            114c Milton Road, Cambridge CB4 1XE, England\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n#include \"license.txt\"\n*/\n\nvoid   LinetoTranspose(out ivec3, int, int);\nint    TransposetoLine(const ivec3, int);\nvoid   TransposetoAxes(inout ivec3, int);\nvoid   AxestoTranspose(inout ivec3, int);\n\n//=============================================================================\n//              Hilbert-curve (a space-filling Peano curve) library\n//=============================================================================\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: LinetoAxes\n//            AxestoLine\n//\n// Purpose:   Serial Hilbert length  <---->   multidimensional Axes position.\n//\n//   Space  = n-dimensional hypercube of side R = 2^b\n//            Number of cells = N = R^n = 2^(n*b)\n//\n//   Line   = serial number of cell along Hilbert curve through hypercube\n//          = extended integer of n*b bits ranging from 0 to N-1,\n//            stored as vector of n unsigned b-bit integers with [0] high.\n//\n//   Axes   = Geometrical position of cell\n//          = n b-bit integers representing coordinates.\n//\n// Example:   side R = 16, dimension n = 2, number of cells = N = 256.\n//            Line = 9, stored in base-16 words as\n//                   Line[0] = 0 (high),   Line[1] = 9 (low),\n//            corresponds to position (2,3) as in diagram, stored as\n//                   Axes[0] = 2,   Axes[1] = 3.\n// \n//        |\n//     15 |    @---@   @---@   @---@   @---@   @---@   @---@   @---@   @---@\n//        |    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n//        |    @   @---@   @   @   @---@   @   @   @---@   @   @   @---@   @\n//        |    |           |   |           |   |           |   |           |\n//        |    @---@   @---@   @---@   @---@   @---@   @---@   @---@   @---@\n//        |        |   |           |   |           |   |           |   |    \n//        |    @---@   @---@---@---@   @---@   @---@   @---@---@---@   @---@\n//        |    |                           |   |                           |\n//        |    @   @---@---@   @---@---@   @   @   @---@---@   @---@---@   @\n//        |    |   |       |   |       |   |   |   |       |   |       |   |\n// Axes[1]|    @---@   @---@   @---@   @---@   @---@   @---@   @---@   @---@\n//        |            |           |                   |           |        \n//        |    @---@   @---@   @---@   @---@   @---@   @---@   @---@   @---@\n//        |    |   |       |   |       |   |   |   |       |   |       |   |\n//        |    @   @---@---@   @---@---@   @---@   @---@---@   @---@---@   @\n//        |    |                                                           |\n//        |    @---@   @---@---@   @---@---@   @---@---@   @---@---@   @---@\n//        |        |   |       |   |       |   |       |   |       |   |    \n//        |    @---@   @---@   @---@   @---@   @---@   @---@   @---@   @---@\n//        |    |           |           |           |           |           |\n//        |    @   @---@   @   @---@   @---@   @---@   @---@   @   @---@   @\n//        |    |   |   |   |   |   |       |   |       |   |   |   |   |   |\n//        |    @---@   @---@   @   @---@---@   @---@---@   @   @---@   @---@\n//        |                    |                           |                \n//      3 |    5---6   9---@   @   @---@---@   @---@---@   @   @---@   @---@\n//        |    |   |   |   |   |   |       |   |       |   |   |   |   |   |\n//      2 |    4   7---8   @   @---@   @---@   @---@   @---@   @   @---@   @\n//        |    |           |           |           |           |           |\n//      1 |    3---2   @---@   @---@   @---@   @---@   @---@   @---@   @---@\n//        |        |   |       |   |       |   |       |   |       |   |    \n//      0 |    0---1   @---@---@   @---@---@   @---@---@   @---@---@   @--255\n//        |\n//         -------------------------------------------------------------------\n//             0   1   2   3          ---> Axes[0]                         15\n//\n// Notes: (1) Unit change in Line yields single unit change in Axes position:\n//            the Hilbert curve is maximally local.\n//        (2) CPU proportional to total number of bits, = b * n.\n//\n// History:   John Skilling  20 Apr 2001, 11 Jan 2003, 3 Sep 2003\n//-----------------------------------------------------------------------------\n//\n\nivec3 LinetoAxes(int n,    // I    linear serial number, stored as     [n] \n                 int b)    // I    # bits used in each word\n{\n  ivec3 Axes;\n  LinetoTranspose(Axes, n, b);\n  TransposetoAxes(Axes,       b);\n  return Axes;\n}\n\nint AxestoLine(const ivec3 Axes,  // I    multidimensional geometrical axes   [n]\n               int b)             // I    # bits used in each word\n{\n  ivec3 tmp = Axes, Line;\n  AxestoTranspose(      tmp, b);\n  return TransposetoLine(tmp, b);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: LinetoTranspose\n//            TransposetoLine\n//\n// Purpose:   Recover Hilbert integer by bit-transposition\n//\n// Example:   b=5 bits for each of n=3 coordinates\n//               15-bit Hilbert integer = A B C D E a b c d e 1 2 3 4 5\n//                                        X[0]..... X[1]..... X[2].....\n//            transposed to\n//               X[0](high) = A D b e 3\n//               X[1]       = B E c 1 4\n//               X[2](low)  = C a d 2 5\n//                            high  low\n//\n// History:   John Skilling  20 Apr 2001, 3 Sep 2003, 14 Oct 2003\n//-----------------------------------------------------------------------------\n//\n// A B C D E\n// a b c d e\n// 1 2 3 4 5\n//\n// A D b e 3\n// B E c 1 4\n// C a d 2 5\n\nvoid LinetoTranspose(out ivec3 X,   //   O  Transpose        [n]\n                     int n,         // I    Hilbert integer  [n] \n                     int b)         // I    # bits\n{\n  X = ivec3(0);\n  int p = 1 << (b-1);\n  for(int k = b; k > 0; k--) {\n    int t = 1<<(3*k-1);\n    if( (n & t) != 0 ) X[0] |= p;\n    if( (n & (t>>1)) != 0 ) X[1] |= p;\n    if( (n & (t>>2)) != 0 ) X[2] |= p;\n    p >>= 1;\n  }\n}\n\nint TransposetoLine(const ivec3 X, // I    Transpose        [n]\n                    int b)         // I    # bits\n{\n  int p = 1 << (b-1);\n  int n = 0;\n  for(int k = b; k > 0; k--) {\n    int t = 1<<(3*k-1);\n    if( (X[0] & p) != 0 ) n |= t;\n    if( (X[1] & p) != 0 ) n |= (t>>1);\n    if( (X[2] & p) != 0 ) n |= (t>>2);\n    p >>= 1;\n  }\n  return n;\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: TransposetoAxes\n//            AxestoTranspose\n//\n// Purpose:   Transform between Hilbert transpose and geometrical axes\n//\n// Example:   b=5 bits for each of n=3 coordinates\n//            Hilbert transpose\n//             X[0] = A D b e 3                  X[1]|  \n//             X[1] = B E c 1 4    <------->         |  /X[2]\n//             X[2] = C a d 2 5                axes  | /\n//                    high  low                      |/______\n//                                                         X[0]\n//            Axes are stored conventially as b-bit integers.\n//         \n// History:   John Skilling  20 Apr 2001, 3 Sep 2003, 14 Oct 2003\n//-----------------------------------------------------------------------------\n//\n\nvoid TransposetoAxes(inout ivec3 X,        // I O  position   [n]\n                     int      b)           // I    # bits\n{\n  // Gray decode by  H ^ (H/2)\n  int t = X[N-1] >> 1;\n  for(int i = N-1; i != 0; i-- ) X[i] ^= X[i-1];\n  X[0] ^= t;\n\n  // Undo excess work\n  for (int k = 1; k < b; k++) {\n    int Q = 1 << k;\n    for(int i = N-1; i != 0; i-- ) {\n      t = Q-1;\n      if ( (X[i] & Q) == 0 ) {\n        t &= X[0] ^ X[i];\n        X[i] ^= t;\n      }\n      X[0] ^= t;\n    }\n    if( (X[0] & Q) != 0 ) X[0] ^= Q-1;                                  // invert\n  }\n} \n\nvoid AxestoTranspose(inout ivec3 X,      // I O  position   [n]\n                     int      b)         // I    # bits\n{\n  // Inverse undo\n  for(int k = b-1; k > 0; k--) {\n    int Q = 1 << k;\n    if( (X[0] & Q) != 0 ) X[0] ^= Q-1;                                  // invert\n    for( int i = 1; i < N; i++ ) {\n      int t = Q-1;\n      if ( (X[i] & Q) == 0 ) {\n        t &= X[0] ^ X[i];\n        X[i] ^= t;\n      }\n      X[0] ^= t;\n    }\n  }\n  int t;\n  // Gray encode (inverse of decode)\n  for(int i = 1; i < N; i++ ) X[i] ^= X[i-1];\n  t = X[N-1];\n  for(int i = 1; i < b; i <<= 1 ) X[N-1] ^= X[N-1] >> i;\n  t ^= X[N-1];\n  for(int i = N-2; i >= 0; i-- ) X[i] ^= t;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// End of John Skilling code\n////////////////////////////////////////////////////////////////////////////////\n\nivec4 getdata(int n) {\n  assert(n <= MAXLINE);\n  ivec3 axes = toivec(n);\n  int line = AxestoLine(axes,BITS);\n  // Get the previous and next vertices on the curve. If we are at\n  // an end of the curve, just use the vertex itself.\n  ivec3 axes1 = line == 0 ? axes : LinetoAxes(line-1,BITS);\n  ivec3 axes2 = line == MAXLINE ? axes : LinetoAxes(line+1,BITS);\n  return ivec4(n,line,fromivec(axes1),fromivec(axes2));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  // Just compute curve on first frame - doesn't speed\n  // things up much in fact, so didn't use.\n  //fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  //if (iFrame != 0) return;\n  fragCoord = floor(fragCoord);\n  // Linear index of location\n  int n = int(fragCoord.y*iResolution.x + fragCoord.x);\n  if (n > MAXLINE) return;\n  fragColor = intBitsToFloat(getdata(n));\n  //fragColor = vec4(getdata(n));\n  }\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.1415927;\n\nconst int N = 3; // Number of dimensions\nconst int BITS = 5; // Max number of bits\nconst int MAXLINE = (1<<(3*BITS))-1;\n\n// Convert to and from packed representation\nivec3 toivec(int n) {\n  int b = BITS, s = 1<<b;\n  return ivec3(n>>(2*b),(n>>b)&(s-1),n&(s-1));\n}\n\nvec3 tovec(int n) {\n  int b = BITS, s = 1<<b;\n  return vec3(n>>(2*b),(n>>b)&(s-1),n&(s-1));\n}\n\nint fromivec(ivec3 line) {\n  int b = BITS;\n  return (line[0]<<(2*b))|(line[1]<<b)|line[2];\n}\n\nint fromvec(vec3 line) {\n  return fromivec(ivec3(line));\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "buffer_d_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  } else if (i == 1) {\n    if (j == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (j == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  }\n}\n", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[528, 528, 563, 563, 599], [601, 601, 640, 640, 781], [783, 783, 810, 810, 1014], [1016, 1016, 1052, 1052, 2067], [2069, 2069, 2101, 2101, 2517], [2519, 2519, 2537, 2537, 2572], [2823, 2823, 2851, 2851, 3019], [3442, 3442, 3471, 3471, 3859], [3861, 3906, 3940, 3940, 4153], [4155, 4200, 4233, 4233, 4429], [4431, 4462, 4492, 4492, 4537], [4539, 4577, 4606, 4606, 5019], [5021, 5056, 5087, 5087, 5659], [5661, 5661, 5712, 5712, 6325]], "test": "untested"}
{"id": "7s3Xzl", "name": "Atlas – FM-84", "author": "raphaelameaume", "description": "Inspired by the cover of the \"Atlas\" album by FM-84", "tags": ["sunset"], "likes": 5, "viewed": 623, "published": 3, "date": "1633703936", "time_retrieved": "2024-07-30T18:57:21.665602", "image_code": "float aastep(float threshold, float value) {\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nfloat circle(vec2 st, float radius) {\n    return aastep(radius, length(st - vec2(0.5)));\n}\n\nfloat mapRange(float value, float low1, float high1, float low2, float high2) {\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nconst float sunRadius = 0.35;\nconst float sunLightRadius = sunRadius * 0.95;\nconst float sunLightSpread = 0.15;\n\nconst float seaLimit = 0.2;\nconst float seaSpread = 0.1;\nconst float seaRadius = 0.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 circleUv = vec2(\n        uv.x * iResolution.x / iResolution.y - ((iResolution.x - iResolution.y) * 0.5) / iResolution.y,\n        uv.y\n    );\n\n    \n    vec3 backgroundColor = vec3(0.172, 0.129, 0.254);\n    vec3 color = backgroundColor;\n    \n    // stars\n    float stars = 1. - clamp(rand(uv) * 1000., 0., 1.);\n    stars = mix(0., stars, 1. - step(uv.y, seaLimit));\n    color = mix(color, vec3(0.631, 0.603, 0.745), stars);\n    \n    // sun\n    float sunLight = 1. - smoothstep(sunLightRadius - sunLightSpread, sunLightRadius + sunLightSpread, length(circleUv - vec2(0.5)));\n    color = mix(color, vec3(1., 0.145, 0.729), sunLight * 0.9);\n    vec3 sunColor = mix(vec3(0.996, 0.984, 0.227), vec3(1., 0.008, 0.729), 1. - uv.y);\n    float sunCut = step(1. - uv.y, 0.75);\n    float sun = (1. - circle(circleUv, sunRadius)) * sunCut;\n    color = mix(color, sunColor, sun);\n    \n    // sea\n    float y = mapRange(uv.y, 0., seaLimit, 0., 1.) - 0.04;\n    float seaStrips = step(fract(y * 13.), 0.5);\n    seaStrips = mix(seaStrips, 1., step(1. - uv.y, 1. - seaLimit));\n\n    float seaGradient = mapRange(uv.y, 0., seaLimit, 0., 1.);\n    float seaFade = smoothstep(seaRadius - seaSpread, seaRadius + seaSpread, length(uv - vec2(0.5, 0.35)));\n    vec3 seaColor = mix(vec3(0.212, 0.263, 0.467), vec3(0.208, 0.376, 0.761), seaGradient);\n    seaColor = mix(seaColor, backgroundColor, seaFade);\n    \n    float seaStripsFade = 1. - smoothstep(0.32 - seaSpread * 2., 0.32 + seaSpread * 2., length(circleUv - vec2(0.5, 0.45)));;\n    seaStrips *= seaStripsFade;\n    vec3 seaReflectColor = mix(vec3(1., 0.588, 0.357), vec3(1., 0.106, 0.729), 1. - mapRange(uv.y, seaLimit * 0.5, seaLimit, 0., 1.));\n    seaColor = mix(seaColor, seaReflectColor, seaStrips);\n    color = mix(color, seaColor, step(uv.y, seaLimit));\n    \n    // noise\n    float noise = rand(uv * 10.);\n    color = mix(color, vec3(noise), .1);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3Xzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 196], [198, 198, 235, 235, 288], [290, 290, 369, 369, 439], [441, 441, 461, 461, 531], [733, 733, 790, 790, 2789]], "test": "untested"}
{"id": "fdcSzs", "name": "oct", "author": "Kornelius", "description": "my first shader.", "tags": ["octahedron"], "likes": 2, "viewed": 205, "published": 3, "date": "1633696292", "time_retrieved": "2024-07-30T18:57:22.512338", "image_code": "\nfloat plane(vec3 pos) {\nreturn pos.y;\n}\n\n\n\nfloat romb(vec3 p) \n{\n\nvec4 oct = vec4(2.5, .7, 0.0, 0.45);\n\n\n  p = abs(p-oct.xyz);\n     \n  \n  float m = p.x+p.y+p.z-oct.w*0.5554;\n  vec3 q;\n       if(-100.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( -3.5*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n     q.xyz -= clamp(sin(iTime)/2.0, 0.0, .19);\n\n  float k = clamp(0.5*(q.z-q.y+oct.w),0.0,oct.w); \n  return length(vec3(q.x,q.y-oct.w+k,q.z-k)*p*4.0);\n  }\n\n\nfloat octahedron(vec3 p)\n{\n\n\nvec4 s= vec4(2.5, 0.35*2.0 - sin(iTime*2.0)/55.0, 0.0, 0.25);\n\n  p = abs(p - s.xyz);\n  vec3 q = p-1.0*clamp(round(p/1.0),-1.0,.3);\n  return (q.x+q.y+q.z-s.w)*0.57735027;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec2 map(vec3 pos) {\n\n\nvec2 res = vec2(1e10, -1.0);\n\nvec2 romb = vec2(romb(pos), 1.0);\nvec2 plane = vec2(plane(pos), 2.0);\nvec2 octahedron= vec2(octahedron(pos), 3.0);\n\n\nif(romb.x < res.x) {res = romb;}\nif(octahedron.x < res.x) {res = octahedron;}\nif(plane.x < res.x) {res = plane;}\n\n\n\n\nreturn res; \n\n\n}\n\nvec2 raycast(vec3 ro, vec3 rd) {\nfloat epsilon = 0.01; \n\nvec2 res;\n\nfloat t = 0.0; \nfor(int i = 0; i < 180; ++i) \n{\nvec2 res = map(ro+rd*t);\nif(res.x < epsilon)\n{\nreturn vec2(t, res.y);\n}\nt += res.x;\n} \nreturn res;\n\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n\n   const float h = 0.001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 light = normalize(vec3(0.2, -1.0, .2942342));\n    vec3 ro = vec3(6, 0.75, 0.0);\n    vec3 rd = vec3(-1, (fragCoord.y-iResolution.y/2.0)/iResolution.x, -fragCoord.x/iResolution.x+0.5);\n    rd = normalize(rd); \n    \n    vec2 res = raycast(ro, rd); \n    float t = res.x;\n    float m = res.y;\n    \n    vec3 col = vec3(0.0, 0, 0);\n    \n   if(m != -1.0){\n    vec3 pos = ro + rd * t; \n    if(m == 1.0) {//robm\n    \n    col = 0.5 + 2.5*cos(iTime+rd.xyx+vec3(6,0,4));\n    }\n    else if(m==2.0) {// plane\n    col = vec3(0., .0, .0);\n    \n    float ao = clamp(length(pos.xyz - vec3(1.5, 0.25, .04)), 0.0, 1.0); \n    col = col * 0.25 + ao * +.5 * col;\n    }\n    else if(m==3.0) {// octahedron\n    col = 0.5 + 0.5*cos(iTime+rd.xyx+vec3(3,0,4));\n    \n    }\n \n   \n    vec3 nor = calcNormal(pos);\n    float dif = clamp(dot(nor, -light), 0.0, 1.0); \n    \n    col = 0.55 * col +.75*dif * col;\n\n   \n    fragColor = vec4(col, 1.0);\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 40], [44, 44, 65, 65, 478], [481, 481, 507, 507, 682], [698, 698, 718, 718, 1001], [1003, 1003, 1035, 1035, 1220], [1223, 1223, 1248, 1248, 1553], [1555, 1555, 1612, 1612, 2537]], "test": "untested"}
{"id": "NstXRX", "name": "Reef and waves", "author": "guil", "description": "Cheap reef and waves effect", "tags": ["waves", "reef"], "likes": 14, "viewed": 460, "published": 3, "date": "1633687146", "time_retrieved": "2024-07-30T18:57:23.260338", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n//reef/waves combined field\nvec3 field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o=1.;\n    vec3 q=p;\n\tvec2 l = vec2(2.);\n\tfor(e=f=p.y;s<4e2;s*=1.6)\n            p.xz*=rot(s),\n            q=p,\n            q.x+=iTime,\n            e+=abs(dot(sin(q.xz*s*.1)/s,.8*l)),\n            f+=.2+.5*(dot(sin(p.xz*s*.5)/s,l));\n\to+=(f>.001 ? (e<0.01 ? -exp(-e*e):f*e):-exp(-f*f));\n    return vec3(max(o,0.),e,f);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 3.5, dt = .15,c,d,e,f;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{        \n        vec3 v = field(ro+t*rd); \n        c=v.x; e=v.y; f=v.z; d=min(min(e,2.*e*f),f);\n        t+=dt*d;\n        dt *= 1.015;\n        e=exp(-e);f=exp(-f);\n        col = .95*col+ .5*c*(f*vec3(.5,.3, .2)+e*vec3(.1, .4, .7));        \n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.5);\n    \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -= t*.4;\n    rd.xy*=rot(sin(t)*.1);\n    rd.xz*=rot(sin(t*1.3)*.1);\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstXRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [191, 219, 242, 242, 577], [580, 580, 617, 617, 978], [981, 981, 1038, 1038, 1752]], "test": "untested"}
{"id": "fd3XRl", "name": " Fab8 #inktober2021 \"watch\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nbetter seen at 640x360\nclassical or modern watch shaders have already be made 10.000 times. so... :-p", "tags": ["2d", "clock", "hair", "watch", "short", "tan", "arm", "inktober2021", "slin"], "likes": 7, "viewed": 262, "published": 3, "date": "1633684423", "time_retrieved": "2024-07-30T18:57:24.046237", "image_code": "#define H(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define D(x) clamp(30. - 12.*length(P+H - U-vec2(x+1.,0) ) , 0.,1.) // AA disk\n#define S(U) pow( pow(U.x,4.)+pow(U.y,4.) , 1./4. )         // rounded square\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy, P,H,\n          U = 14.*( 2.*u - R ) / R.y;\n          \n    O = mix( vec4(.7,.4,.3,1),                              // tanned color\n             vec4(1 ,.6,.5,1),                              // raw color\n             smoothstep(.5,-.5,min(S(abs(U-vec2(6,1)))-5.5, // watch body\n                                    abs(U.x-6.3+U.y*U.y/150.)-2.5)) );// brace\n\n    float x = U.y*.1*(1.+U.x/2e2); // d = 9.;               // arm\n    O *= sqrt(1.-x*x);\n    for( int k=0; k<9; k++)                                 // hairs\n        P = floor(U) + vec2(k%3,k/3)-1.,\n        H = H(P)-.5,\n    //  d = min(d, length(P+H - U ) ),                      // random dot\n        O -= max(0., D() - D(.01) );                        // random moon\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3XRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 269, 269, 1028]], "test": "untested"}
{"id": "7sdXRS", "name": "weird world, blue snake", "author": "elenzil", "description": "I wanted to try out [url=https://www.shadertoy.com/view/Wt3fzB]TinyTexel's Panini Projection[/url] and ended up here.\nThe panini thing works like a charm!\nMouse Y to adjust Panini Factor, Mouse X for FOV.", "tags": ["panini"], "likes": 6, "viewed": 293, "published": 3, "date": "1633673536", "time_retrieved": "2024-07-30T18:57:24.808200", "image_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 UP  = vec3(0.0, 1.0, 0.0);\nconst vec3 ONE = vec3(1.0, 1.0, 1.0);\nconst float Pi = 3.14159265359;\n\nfloat gTime    = 0.0;\nvec3  gPosCam  = vec3(0.0, 4.0, -2.0);\nvec3  gPosSph1 = UP;\nfloat gSizSph1 = 1.0;\n\nconst float gZoom = 0.8;\n\nfloat Pow2(float x) {return x*x;}\n\nvec3 posSph1(float time, float noiseAmt) {\n    \n    vec3 noise = texture(iChannel1, vec2(time * 0.051, time * 0.05), 0.0).rgb;\n    \n    return vec3(cos(time * 1.3), 0.0, sin(time * 0.7)) * 9.0 + UP + noise * noiseAmt;\n}\n\nvoid composeScene(float time) {\n    gTime    = time;\n    gPosSph1 = posSph1(gTime, 0.0);\n    \n    gPosCam  = posSph1(gTime + 0.0, 0.0);\n    gPosCam.xz  += normalize(gPosCam).xz * 6.0;\n    gPosCam  *= 1.0;\n    gPosCam  += UP * 3.0;\n}\n\nvec3 sky(in vec3 rd) {\n    vec3 ret = rd * 0.5 + 0.5;\n    ret.rg *= sin(rd.y * 20.0) * 0.2 + 0.8;\n    ret.gb *= sin(atan(rd.z, rd.x) * 10.0) * 0.3 + 0.7;\n    ret  = ONE * length(ret);\n    return ret;\n}\n\nvec3 shootRay(in vec3 ro, in vec3 rd) {\n    if (rd.y > -0.001) {\n        return sky(rd);\n    }\n    \n    vec2 planePt2  = -vec2(rd.xz * ro.y / rd.y) + ro.xz;\n    vec3 planePt   = vec3(planePt2.x, 0.0, planePt2.y);\n    float planeDst = length(planePt.xz);\n    float planeAng = atan(planePt.z, planePt.x);\n    float camDist  = length(planePt2 - ro.xz);\n    float blur     = smoothstep(0.0, 80.0, camDist);\n\n    const float txLim = 8.8;\n    float pa = planeAng;\n    float pd = planeDst;\n    if (pd < txLim) {\n        pa += Pow2((pd - txLim) * 0.2);\n    }\n    float planeCol = smoothstep(-blur, blur, sin(pa * 10.0) * sin(log(pd) * 4.0)) * (0.4 * (1.7 - blur)) + 0.6;\n    \n    \n    planeCol *= smoothstep(3.0, 5.0, camDist) * 0.4 + 0.6;\n    \n    vec3 ret = vec3(planeCol);\n    \n    ret = mix(ret, sky(rd), smoothstep(20.0, 1160.0, planeDst));\n    \n    vec2 planePt3  = -vec2(rd.xz * (ro.y - 1.0) / rd.y) + ro.xz;\n    \n    float shadwSum = 0.0;\n    float snakeSum = 0.0;\n    for (float dt = -6.0; dt < 1.0; dt += 0.02) {\n        float f = smoothstep(-6.0, 0.0, dt);\n        vec2 pos = posSph1(gTime + dt, 1.0 - f).xz;\n        float rad = f * gSizSph1;\n        rad *= sin(rad * 40.0 + gTime) * 0.1 + 0.9;\n        snakeSum += smoothstep(0.5, 0.1, abs(length(planePt3 - pos) - rad));\n        shadwSum += smoothstep(rad, 0.0, abs(length(planePt2 - pos) - rad * 0.5));\n    }\n    \n    ret *= 0.7 + 0.3 * smoothstep(3.0, 0.0, shadwSum);\n    ret = mix(ret, vec3(0.0, 0.0, 0.3), 0.9 * smoothstep(0.0, 11.0, snakeSum));\n    \n    return ret;\n}\n\n\n\n// From TinyTexel\n// https://www.shadertoy.com/user/TinyTexel\n// https://www.shadertoy.com/view/Wt3fzB\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi / 2.0 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    composeScene(iTime * 0.6);\n\n    float pixelSize = 1.0 / MINRES / gZoom;\n    vec2  xy        = (XY - (RES * 0.5)) * pixelSize * 2.0;\n    \n    vec3 camPt      = gPosCam;\n    vec3 lukPt      = gPosSph1;\n    vec3 cam2luk    = lukPt - camPt;\n    vec3 camFw      = normalize(cam2luk);\n    vec3 camRt      = normalize(cross(camFw, UP));\n    vec3 camUp      = normalize(cross(camRt, camFw));\n    mat3 wldFrmCam  = mat3(camRt, camUp, camFw);\n    \n    // Ray direction in camera space\n    vec2 ms = vec2(0.5);\n    if (length(iMouse.xy) > 50.0) {\n        ms = iMouse.xy / RES;\n    }\n    float paniniFOV = mix(0.2, Pi/4.0, ms.x);\n    float paniniD   = mix(0.0, 2.0, ms.y);\n    vec3 rayDirCam  = PaniniProjection(xy, paniniFOV, paniniD);\n    \n    // Ray direction in world space\n    vec3 rayDir     = wldFrmCam * rayDirCam;\n    \n    vec3 rgb        = shootRay(camPt, rayDir);\n        \n    RGBA = vec4(rgb, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 329, 329, 341], [343, 343, 385, 385, 562], [564, 564, 595, 595, 796], [798, 798, 820, 820, 999], [1001, 1001, 1040, 1040, 2527], [2531, 2685, 2737, 2737, 3541], [3543, 3543, 3586, 3586, 4491]], "test": "untested"}
{"id": "sdtXRf", "name": "ray/sphere intersection", "author": "aeva", "description": "A ray/sphere intersection function.", "tags": ["ray", "sphere", "intersection"], "likes": 5, "viewed": 795, "published": 3, "date": "1633666257", "time_retrieved": "2024-07-30T18:57:25.662915", "image_code": "//\n// Written in 2021 by Aeva Palecek\n//\n// To the extent possible under law, the author has dedicated all copyright\n// and related and neighboring rights to this software to the public domain\n// worldwide.  This software is distributed without any warranty.\n//\n// See http://creativecommons.org/publicdomain/zero/1.0/ for more information.\n//\n\n//\n// The TraceSphere function below was produced by substituting the parametric\n// ray equation into the implicit sphere equation on an ancient calculator,\n// and then solving for t like so:\n//\n//         solve((ox+t*dx)^2+(oy+t*dy)^2+(oz+t*dz)^2-r^2=0, t)\n//\n// ...and then waiting several minutes for it to finish thinking before\n// translating the result into GLSL and cleaning it up a little.\n//\n\n\n#define DOT2(V) dot(V, V)\n\n\n// The Origin and Dir parameters describe the ray.\n// The sphere is assumed to be centered at (0, 0, 0).\nfloat TraceSphere(vec3 Origin, vec3 Dir, float Radius)\n{\n    float VoV = DOT2(Dir);\n    \n    float Acc = VoV * Radius * Radius;\n    Acc += 2.0 * Origin.x * dot(Origin.yz, Dir.yz) * Dir.x;\n    Acc += 2.0 * Origin.y * Origin.z * Dir.y * Dir.z;\n    Acc -= dot(Origin * Origin, vec3(DOT2(Dir.yz), DOT2(Dir.xz), DOT2(Dir.xy)));\n    \n    if (Acc < 0.0)\n    {\n        return -1.0;\n    }\n    \n    Acc = sqrt(Acc);\n    \n    float Dist1 = (Acc - dot(Origin, Dir)) / VoV;\n    float Dist2 = -(Acc + dot(Origin, Dir)) / VoV;\n\n    if (Dist1 >= 0.0 && Dist2 >= 0.0)\n    {\n        return min(Dist1, Dist2);\n    }\n    else\n    {\n        return max(Dist1, Dist2);\n    }\n}\n\n\nvec3 GetRayDir(vec2 FragCoord, vec2 Resolution, float FOV)\n{\n    float Aspect = Resolution.y / Resolution.x;\n    vec2 NDC = FragCoord / Resolution.xy * 2.0 - 1.0;\n    vec2 Angle = NDC * vec2(FOV, FOV * Aspect) * 0.5;\n    vec3 RayDir = vec3(sin(radians(Angle)), 0.0).xzy;\n    RayDir.y = sqrt(1.0 - (RayDir.x * RayDir.x) - (RayDir.z * RayDir.z));\n    return RayDir;\n}\n\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec3 Origin = vec3(0.0, -10.0, 0.0);\n    vec3 Dir = GetRayDir(FragCoord.xy, iResolution.xy, 45.0);\n    float T = TraceSphere(Origin, Dir, 2.0);\n    if (T >= 0.0)\n    {\n        vec3 Hit = Dir * T + Origin;\n        FragColor = vec4(normalize(Hit) * 0.5 + 0.5, 1.0);\n    }\n    else\n    {\n        FragColor = vec4(vec3(0.6), 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXRf.jpg", "access": "api", "license": "cc0-1.0", "functions": [[776, 881, 937, 937, 1534], [1537, 1537, 1597, 1597, 1902], [1905, 1905, 1962, 1962, 2301]], "test": "untested"}
{"id": "7stSRf", "name": "Scanning pattern", "author": "lllcz", "description": "The effect of a scan", "tags": ["2d"], "likes": 3, "viewed": 231, "published": 3, "date": "1633657063", "time_retrieved": "2024-07-30T18:57:26.550541", "image_code": "#define blue vec3(0.34, 0.78, 0.33)\n#define MOV(a,b,c,d,e) (vec2(a*cos(t)+b*cos(0.1*t)), c*sin(t)+d*cos(0.1*(t))))\n#define SMOOTH(r,R) 1.0 - smoothstep(0.0, 1.0, r)\n#define M_PI 3.1415926535897932384626433832795\nfloat _cross(vec2 uv, vec2 center, float radius){\n\n    vec2 d = uv - center;\n    //强制转换类型\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt(dot(d,d));\n    if((r<radius)&&((x==y)||(x==-y)||(x==0)||(y==0)))\n    {\n       return 1.0;\n    }\n    return 0.0;\n}\n\n\nfloat movingLine(vec2 uv, vec2 c, float l){\n    //速度\n    float theta0 = 20.0*iTime;\n    \n    vec2 d = uv - c;\n    \n    float r = sqrt(dot(d,d));\n\n    if(r < l){\n    //计算到line(240)的距离确定线的宽度\n    \n        //颜色点坐标\n        vec2 p = l * vec2(cos(theta0 * M_PI/180.0), -sin(theta0 * M_PI/180.0));\n        //line颜色为设置颜色本身(l2 = 0)\n        float l2 = length(d - p*(length(d)/length(p)));\n        //d = normalize(d);\n        //度数转化\n        float theta = mod(180.0 * atan(d.y, d.x)/M_PI+theta0, 360.0);\n        float gradient = clamp(1.0 - theta/90.0, 0.0, 1.0);\n        return SMOOTH(l2, 1.0) + 0.5*gradient;\n    }\n    \n    return 0.0;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\n    vec2 c = iResolution.xy/2.0;\n    \n    vec3 finalColor = vec3(_cross(uv, c, 240.0));\n\n\n    finalColor += movingLine(uv, c, 240.0) * blue;\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 261, 261, 490], [493, 493, 536, 549, 1184], [1186, 1186, 1243, 1243, 1474]], "test": "untested"}
{"id": "sdtSzX", "name": "Harry Potter Wizard Duel", "author": "Zi7ar21", "description": "Supposed to look like the scene from Harry Potter when the streams from Harry and Voldemort's wands are pushing against each other and creating all the splatters and stuff", "tags": ["simulation", "fluid", "simulate"], "likes": 2, "viewed": 81, "published": 3, "date": "1633653851", "time_retrieved": "2024-07-30T18:57:27.664564", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 texel0 = texture(iChannel0, uv);\n\n    vec3 color = mix(vec3(texel0.xy, 0.0), vec3( length(texel0.xy) ), 0.5);\n    //vec3 color = vec3( length(texel0.xy) );\n\n    fragColor = vec4(tanh(0.1*color), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### Preprocessor #####\n\n/*\n// Compile Performance\n#pragma debug(on)\n#pragma optimize(off)\n*/\n\n/*\n// Runtime Performance\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n// ##### Parameters #####\n\n#define timestep 0.1\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.141592653589793\n\n// ##### Random Number Generator #####\n\n// Random Number Generator Seed\nuint ns;\n\n// Initialize Random Number Generator\n#define INIT_RNG ns = uint(iFrame)*uint(iResolution.x*iResolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*iResolution.x)+1U\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17U;\n    x *= 0xED5AD4BBU;\n    x ^= x >> 11U;\n    x *= 0xAC4C1B51U;\n    x ^= x >> 15U;\n    x *= 0x31848BABU;\n    x ^= x >> 14U;\n    return x;\n}\n\n// Random Value Between 0.0 and 1.0\nfloat rand()\n{\n    ns = triple32(ns);\n    return float(ns)/float(0xFFFFFFFFU);\n}\n\n// Uniform Random Vectors\nvec2 rand2(){return vec2(rand (), rand());}\nvec3 rand3(){return vec3(rand2(), rand());}\nvec4 rand4(){return vec4(rand3(), rand());}\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n/*\nvec2 nrand2(float sigma, vec2 mean)\n{\n    vec2 z = rand2();\n    return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));\n}\n*/\n\n// Random Uniform Direction\nvec2 udir2()\n{\n    float z = rand();\n    float r = 2.0*pi*z;\n    float s = sin(r), c = cos(r);\n    return vec2(s, c);\n}\n\nvec3 udir3()\n{\n    vec2 z = rand2();\n    vec2 r = vec2(2.0*pi*z.x, acos(2.0*z.y-1.0));\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}", "buffer_a_code": "// ##### Buffer A #####\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT_RNG;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    /*\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 velocity = texture(iChannel3, uv).xy;\n    velocity = texture(iChannel3, ( fragCoord-(timestep*velocity) )/iResolution.xy).xy;\n    */\n\n    // https://www.shadertoy.com/view/slXXRS\n    vec2 uv = fragCoord;\n    float h = timestep;\n    vec2 k1 = texture(iChannel3, (fragCoord)                /iResolution.xy).xy;\n    vec2 k2 = texture(iChannel3, (fragCoord - 0.5 * h * k1) /iResolution.xy).xy;\n    vec2 k3 = texture(iChannel3, (fragCoord - 0.5 * h * k2) /iResolution.xy).xy;\n    vec2 k4 = texture(iChannel3, (fragCoord - h * k3)       /iResolution.xy).xy;\n    uv -= h * (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0;\n    uv /= iResolution.xy;\n\n    vec2 velocity = texture(iChannel3, uv).xy;\n\n    if(iFrame < 1)\n    {\n        velocity = vec2(0.0);\n    }\n\n    uv = fragCoord/iResolution.xy;\n\n    // Border\n    if(uv.x < 0.01 || uv.x > 0.99 || uv.y < 0.01 || uv.y > 0.99)\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        return;\n    }\n\n    //if(uv.x < 0.015 && uv.y > 0.49 && uv.y < 0.51)\n    if(uv.x < 0.1 && uv.y > 0.49 && uv.y < 0.51)\n    {\n        velocity = vec2( 100.0*(0.1*rand()+0.9), 0.0);\n        fragColor = vec4(velocity, 0.0, 0.0);\n        return;\n    }\n    //if(uv.x > 0.985 && uv.y > 0.49 && uv.y < 0.51)\n    if(uv.x > 0.9 && uv.y > 0.49 && uv.y < 0.51)\n    {\n        velocity = vec2(-100.0*(0.1*rand()+0.9), 0.0);\n        fragColor = vec4(velocity, 0.0, 0.0);\n        return;\n    }\n\n    // Border\n    if(uv.x < 0.09 || uv.x > 0.91 || uv.y < 0.02 || uv.y > 0.98)\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        return;\n    }\n\n\n    /*\n    if(length(vec2(0.5, 1.0)*(uv-0.5)) < 0.02)\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        return;\n    }\n    */\n\n    fragColor = vec4(velocity+( 0.1*min(dot(velocity, velocity), 150.0)*udir2()*rand()*rand() ), 0.0, 0.0);\n    //fragColor = vec4(velocity, 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### Buffer B #####\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(texture(iChannel0, uv).z > 0.0)\n    {\n        return;\n    }\n\n    float x0 = texture(iChannel0, (vec2(-1.0,  0.0)+fragCoord)/iResolution.xy).x;\n    float x1 = texture(iChannel0, (vec2( 1.0,  0.0)+fragCoord)/iResolution.xy).x;\n    float y0 = texture(iChannel0, (vec2( 0.0, -1.0)+fragCoord)/iResolution.xy).y;\n    float y1 = texture(iChannel0, (vec2( 0.0,  1.0)+fragCoord)/iResolution.xy).y;\n\n    float divergence = 0.5*( (x1-x0)+(y1-y0) );\n\n    fragColor = vec4(divergence, 0.0, 0.0, 0.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ##### Buffer C #####\nfloat samplePressure(vec2 p)\n{\n    if(texture(iChannel0, p).z > 0.5)\n    {\n        return 0.0;\n    }\n\n    if(p.x < 0.01 || p.x > 0.99 || p.y < 0.01 || p.y > 0.99)\n    {\n        return 0.0;\n    }\n\n    return texture(iChannel2, p).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float divergence = texture(iChannel1, uv).x;\n\n    float x0 = samplePressure( (vec2(-1.0,  0.0)+fragCoord)/iResolution.xy );\n    float x1 = samplePressure( (vec2( 1.0,  0.0)+fragCoord)/iResolution.xy );\n    float y0 = samplePressure( (vec2( 0.0, -1.0)+fragCoord)/iResolution.xy );\n    float y1 = samplePressure( (vec2( 0.0,  1.0)+fragCoord)/iResolution.xy );\n\n    fragColor = vec4(0.25*( (x0+x1+y0+y1)-divergence ), 0.0, 0.0, 0.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ##### Buffer D #####\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x0 = texture(iChannel2, (vec2(-1.0,  0.0)+fragCoord)/iResolution.xy).x;\n    float x1 = texture(iChannel2, (vec2( 1.0,  0.0)+fragCoord)/iResolution.xy).x;\n    float y0 = texture(iChannel2, (vec2( 0.0, -1.0)+fragCoord)/iResolution.xy).x;\n    float y1 = texture(iChannel2, (vec2( 0.0,  1.0)+fragCoord)/iResolution.xy).x;\n\n    vec2 pressureGradient = 0.5*( vec2(x1, y1)-vec2(x0, y0) );\n\n    vec2 velocity = texture(iChannel0, uv).xy;\n\n    fragColor = vec4(velocity-pressureGradient, 0.0, 0.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 310]], "test": "untested"}
{"id": "7dtXzX", "name": "land pac-JFP", "author": "jorge2017a2", "description": "land pac-JFP", "tags": ["ealandpacjfp"], "likes": 5, "viewed": 209, "published": 3, "date": "1633653648", "time_retrieved": "2024-07-30T18:57:28.425528", "image_code": "///earth pac-JFP\n///por jorge2017a2...2021-oct-07\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nvec3 ondamar(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y-= 0.5;\n    q.y -= 0.8*sin(q.x*0.8);\n    col=DrawFig(vec3(0.0,0.8,0.0), col, abs(q.y)-4.0 );\n return col;\n}    \n\nvec3 Suelo0(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y+= 2.5;\n    col=DrawFig(vec3(0.85,0.58,0.0), col, abs(q.y)-4.5 );\n return col;\n}\n\nvec3 Suelo1(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y-= 0.5;\n    col=DrawFig(vec3(0.75,0.35,0.2)-p.y*0.15, col, abs(q.y)-1.5 );\n return col;\n}\n\nvec3 Suelo2(vec2 p, vec3 col)\n{   vec2 q=p;\n    q.y-= 0.5;\n    col=DrawFig(vec3(0.85,0.45,0.2), col, abs(q.y)-1.5 );\n return col;\n}  \n\nvec3 ramas(vec2 p, vec3 col, float escal)\n{\n   float d1= sdCircle(p- vec2(0.0,2.5), 1.5 );\n   float d2= sdCircle(p- vec2(2.0,3.5), 1.5 );\n   float d3= sdCircle(p- vec2(-2.0,4.0), 1.5 );\n   float d4= sdCircle(p- vec2(0.0,5.0), 1.5 );   \n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d1 );\n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d2 );\n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d3 );\n   col=DrawFig(vec3(0.0,0.7,0.0)*escal, col, d4 );\n   \n   return col;\n}\n\nvec3 Arbol(vec2 pp , vec3 col, float escal)\n{    vec2 p=pp;\n     float d1= sdBox(p, vec2(0.5,2.0) );\n     float d2=sdOrientedBox(p-vec2(0.0,-2.5), vec2(0.0), vec2(0.0,1.0), 0.5 );\n     p.x=abs(p.x)+0.2;\n     float d3=sdOrientedBox(p-vec2(0.0,-1.5), vec2(0.0,0.0), vec2(1.0,-0.8), 0.5 );\n     \n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d1);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d2);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d3);\n     p=pp;\n     col= ramas(p, col,escal);\n return col;\n}  \n\nvec3 Tronco(vec2 pp , vec3 col, float escal)\n{    vec2 p=pp;\n     float d1= sdBox(p, vec2(0.5,2.0) );\n     float d2=sdOrientedBox(p-vec2(0.0,-2.5), vec2(0.0), vec2(0.0,1.0), 0.5 );\n     p.x=abs(p.x)+0.2;\n     float d3=sdOrientedBox(p-vec2(0.0,-1.5), vec2(0.0,0.0), vec2(1.0,-0.8), 0.5 );\n\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d1);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d2);\n     col=DrawFig(vec3(0.45,0.15,0.0)*escal, col, d3);\n return col;\n}  \n\nvec3 pac(vec2 pp, vec3 col)\n{    vec2 p=pp;\n    float d1cabeza= sdCircle(p, 2.0 );\n    float posOjoX=0.6;\n    float posOjoy=0.3;\n    float d1ojo1A= sdCircle(p-vec2(0.0-posOjoX,0.0+posOjoy), 0.6 );\n    float d1ojo1B= sdCircle(p-vec2(-0.2-posOjoX,-0.1+posOjoy), 0.7 );\n    float difOjo1= differenceSDF(d1ojo1A,d1ojo1B);\n\n    float d1ojo2A= sdCircle(p-vec2(0.0+posOjoX,0.0+posOjoy), 0.6 );\n    float d1ojo2B= sdCircle(p-vec2(-0.2+posOjoX,-0.1+posOjoy), 0.7 );\n    float difOjo2= differenceSDF(d1ojo2A,d1ojo2B);\n    \n    float pyo=0.3*sin(iTime);\n    float dojo1= sdVesica(p-vec2(-0.5,0.3+pyo), 0.4, 0.25);\n    float dojo2= sdVesica(p-vec2(0.7,0.3+pyo), 0.4, 0.25);\n    \n    float boca1A= sdCircle(p-vec2(0.0,0.0-1.1), 0.7 );\n    float boca1B= sdCircle(p-vec2(0.0,-0.3-1.1), 0.8 );\n    float difBoca= differenceSDF(boca1A,boca1B);\n    //pata\n    float pata1= sdOrientedBox( p-vec2(-1.0,-3.0), vec2(0.0,0.0),vec2(0.5,2.0), 0.25 );\n    float pata2= sdOrientedBox( p-vec2(1.0,-3.0), vec2(0.0,0.0),vec2(-0.5,2.0), 0.25 );\n    float zapato1= sdVesica(p.yx-vec2(-3.0,-1.0), 1.2, 1.0);\n    float zapato2= sdVesica(p.yx-vec2(-3.0,1.0), 1.2, 1.0);\n    float d1gorroA= sdCircle(p-vec2(0.0,1.5), 1.1 );\n    float d1gorroB= sdVesica(p.yx-vec2(2.0,1.0), 1.2, 1.0);\n    float dmano1= sdBox(p-vec2(-2.5,0.0),vec2(1.0,0.15) );\n    float dmano2= sdBox(p-vec2( 2.5,0.0),vec2(1.0,0.15) );    \n    col=DrawFig(vec3(0.0,0.0,0.0), col, pata1);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, pata2);\n    col=DrawFig(vec3(1.0,0.0,0.0), col, d1gorroA);\n    col=DrawFig(vec3(.0,0.0,0.0), col, d1gorroB);\n    col=DrawFigBorde(vec3(0.0), col, dmano1);\n    col=DrawFigBorde(vec3(0.0), col, dmano2);\n    col=DrawFigBorde(vec3(1.0,1.0,0.0), col, d1cabeza);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, difOjo1);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, difOjo2);\n    \n    col=DrawFig(vec3(0.0,0.0,0.0), col, dojo1);\n    col=DrawFig(vec3(0.0,0.0,0.0), col, dojo2);\n    \n    col=DrawFig(vec3(0.0,0.0,0.0), col, difBoca);\n    col=DrawFigBorde(vec3(1.0), col, zapato1);\n    col=DrawFigBorde(vec3(1.0), col, zapato2);\n return col;\n}  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3  col=vec3(0.25,0.7,1.2)-uv.y*0.3;\n         uv*=6.0+sin(iTime);\n   \n   vec2 uv2=uv*6.0;\n   float t=iTime*2.0;\n   t=mod(t,20.0);\n   uv.x+=t;\n  uv2.x+=t;\n   \n   col=ondamar (uv-vec2(0.0,-3.0), col);\n   col=Suelo0(uv-vec2(0.0,-1.25), col);\n   \n   col=Suelo1(uv-vec2(0.0,-1.25), col);\n   col=Suelo2(uv-vec2(0.0,-3.5), col);\n   // atras  //arbol chico\n   col=Arbol(uv*2.0-vec2(6.0,1.5),col,0.8);\n   col=Arbol(uv*2.0-vec2(16.0,1.5),col,0.8);\n   col=Arbol(uv*2.0-vec2(25.0,1.5),col,0.8);\n   col=Arbol(uv*2.0-vec2(30.0,1.5),col,0.8);\n   \n   col=Arbol(uv-vec2(0.0,1.5),col,1.0);\n   col=Arbol(uv-vec2(6.0,1.5),col,1.0);\n   col=ramas(uv-vec2(10.0,1.5),col,1.0);\n   col=Arbol(uv-vec2(16.0,1.5),col,1.0);\n   col=ramas(uv-vec2(20.0,1.9),col,1.0);\n   \n   //troncos chicos\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(12.0,-8.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(15.0,-7.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(30.0,-8.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(35.0,-7.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(60.0,-8.5),col,1.0);\n  col=Tronco(uv*vec2(3.0,4.0)-vec2(65.0,-7.5),col,1.0);\n  col= pac(uv, col);\n  col= pac(uv-vec2(25.0,0.0), col);\n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 275, 309, 309, 404], [406, 437, 473, 473, 518], [523, 567, 614, 614, 641], [642, 642, 685, 685, 712], [713, 713, 761, 761, 789], [795, 795, 857, 857, 1053], [1055, 1055, 1112, 1112, 1178], [1180, 1180, 1217, 1217, 1297], [1299, 1299, 1334, 1334, 1362], [1364, 1364, 1430, 1430, 1647], [1649, 1649, 1691, 1691, 1848], [1850, 1850, 1882, 1882, 2009], [2015, 2015, 2046, 2046, 2146], [2148, 2148, 2179, 2179, 2288], [2290, 2290, 2321, 2321, 2421], [2425, 2425, 2468, 2468, 2885], [2887, 2887, 2932, 2932, 3398], [3402, 3402, 3448, 3448, 3867], [3871, 3871, 3900, 3900, 5950], [5954, 5954, 6011, 6011, 7326]], "test": "untested"}
{"id": "NstXRf", "name": " Fab7 #inktober2021 \"fan\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nMouse.y tunes speed  ( better, since auto-demo suffers interférences between the 2 times )", "tags": ["2d", "motionblur", "motionblur", "antialiasing", "short", "fan", "inktober2021", "analyticintegration"], "likes": 18, "viewed": 311, "published": 3, "date": "1633639327", "time_retrieved": "2024-07-30T18:57:29.288222", "image_code": "#define S(v)        smoothstep(4./R.y, 0., v)                  //\n#define F(U,a,n)  ( mod( a + atan(U.y,U.x), 6.28/n ) -3.14/n ) // angular n-folding\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy,\n          U = 1.2*( 2.*u - R ) / R.y;\n    \n    float s = 20.*( length(iMouse.xy)<10. ? .5+.5*sin(iTime) : iMouse.y/R.y ),// speed\n          a = F(U, -s*iTime, 3.),                              // angle dist to wing axe (3-folds sym)\n          L = length(U), l = 2.*L-1., da = s/60.*6.28,         // angle covered per frame\n          e = atan(.3*sqrt(1.-l*l)/L),                         // angle range of ellipse wing at height L\n          h = max( 0., min(a+da/2.,e) - max(-e,a-da/2.) );     // wing motion blur coverage of pixel angle a\n\n    U = L * cos( F(U,,6.) + vec2(0,11) );                      // grid: 6-folds sym\n    O = vec4( mix( l<1. ? h / max(fwidth(h),da): 0.,           // motion blured wings\n                   .5,                                         // grid color\n                   L < 1.11 ?   S( abs( fract(L*15.)-.5)/15. ) // grid mask\n                               + S( abs(U.y) ) : 0.\n            )    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ss3Xzj", "name": "ZX Spectrum SCREEN$", "author": "P_Malin", "description": "Another Sinclair ZX Spectrum Filter!\nProbably a lot slower than others as this does a more exhaustive search to find which attributes to use for each character cell. Also has some hacky CRT effects.\nTry changing the iChannel0 input in Buffer A.", "tags": ["retro", "spectrum", "zx", "8bit", "sinclair"], "likes": 62, "viewed": 4006, "published": 3, "date": "1633636036", "time_retrieved": "2024-07-30T18:57:30.654568", "image_code": "// ZX Spectrum SCREEN$\n// by @P_Malin\n//\n// https://www.shadertoy.com/view/ss3Xzj\n// \n// See the webcam / Memix version here:\n//   https://www.shadertoy.com/view/7scXRX\n//\n// Another Sinclair ZX Spectrum Filter!\n// Probably a lot slower than others as this does a more exhaustive search to find which attributes to use for each character cell. Also has some hacky CRT effects.\n// Try changing the iChannel0 input in Buffer A.\n\n// There is a slightly cheaper version of the colour selection code if you `#define SLOW_SEARCH 0` in the Common tab\n\n\n// \"CRT\" Effects\n#define APPLY_BLUR 1\n#define APPLY_INTERFERENCE 1\n#define APPLY_SCANLINES 1\n\nvec4 hash41(float p)\n{\n    // From: Hash without Sine by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \n}\n\nvec4 InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    vec4 h0 = hash41( f0 );\n    vec4 h1 = hash41( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nvec4 InterferenceNoise( vec2 uv )\n{\n    float scanLine = floor(uv.y * resolution.y); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n\nvec3 SampleImage( vec2 uv, int loadingByteIndex )\n{\n    vec2 pixelCoord = uv * resolution;\n\n    vec3 col = vec3(1);\n\n    col = texelFetch( iChannel0, ivec2(pixelCoord), 0).rgb;    \n    //col = texture( iChannel0, (pixelCoord) / iChannelResolution[0].xy).rgb;\n\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0)\n    {\n        //col = vec3(intensity0);\n        //col = vec3(0,1,1) * intensity0;\n        //col = intensity0 * mix( vec3(0,1,1), vec3(1,0,0), step(sin(iTime * 1.0),0.0));\n        //col = intensity0 * mix( vec3(0,1,1), vec3(1,0,0), step(sin(uv.x /10.0+uv.y*60.0+iTime * 10.0),0.0));\n        \n        col = vec3(intensity0) * vec3(0,1,1);\n            \n        int loadingByteEnd = (192*256/8+(32*24) + 64);\n            \n        if ( loadingByteIndex < loadingByteEnd )\n        {\n            float t =(uv.y*300.0+uv.x)* 0.4+iTime * 3000.0;\n            float raster = t / 150.0;\n            \n            float barSize = 64.0;\n            float scrollSpeed = 1.0;\n            float blend = step(fract(raster * barSize + iTime * scrollSpeed + sin(iTime * 20.0 + raster * 16.0)), 0.5);            \n            col = mix( vec3(0,0,1), vec3(1,1,0), blend ) * intensity0;\n        }        \n                \n        col = RGBtoYUV( col );\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor.rgb = YUVtoRGB(texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb); return;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1);\n    \n    uv = uv - 0.5;\n    \n    float outputAspect = iResolution.x / iResolution.y;\n    float screenAspect = (resolution.x / resolution.y);\n    float aspectAdjust = outputAspect / screenAspect;\n    \n    if ( aspectAdjust > 1.0 )\n    {\n        uv.x *= aspectAdjust;\n    }\n    else\n    {\n        uv.y /= aspectAdjust;\n    }\n    \n    uv *= 1.1;\n    uv = uv + 0.5;\n    \n#if APPLY_INTERFERENCE    \n    vec4 noise = InterferenceNoise( uv );\n    uv.x += noise.w * 0.0015;\n#endif    \n\n    int loadingByteIndex = iFrame * loadSpeed - startDelay;\n    \n    col = SampleImage( uv, loadingByteIndex );\n    \n#if APPLY_BLUR    \n    {\n        float weight = 1.0f;\n        float blurSeparation = 1.5;\n\n        int taps = 6;\n        for( int i=1; i<taps; i++)\n        {\n            float t = float(i) / float(taps-1);\n            float blurWeight = (1.0 - t);\n            blurWeight *= 0.7;\n            col.r += SampleImage( uv + vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).r * blurWeight;\n            col.r += SampleImage( uv - vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).r * blurWeight;\n\n            weight += blurWeight * 2.0;\n        }\n        col.r /= weight;\n    }\n\n    {\n        float weight = 1.0f;\n        float blurSeparation = 2.5;\n\n        int taps = 6;\n        for( int i=1; i<taps; i++)\n        {\n            float t = float(i) / float(taps-1);\n            float blurWeight = (1.0 - t);\n            blurWeight *= 0.7;\n            col.gb += SampleImage( uv + vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).gb * blurWeight;\n            col.gb += SampleImage( uv - vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).gb * blurWeight;\n\n            weight += blurWeight * 2.0;\n        }\n        col.gb /= weight;\n    }\n\n#endif    \n\n#if APPLY_INTERFERENCE    \n    col += (noise.xyz * 1.0 - 0.5) * 0.05;\n#endif    \n\n    col = YUVtoRGB( col );    \n\n#if APPLY_SCANLINES\n    float scanline = 1.0;\n    /*{\n        float a = resolution.y * 3.14 * 2.0;\n        float b = - 3.14 * 0.5;\n        float x = uv.y;\n        scanline = sin(x * a + b);\n    }*/\n    {\n        float a = resolution.y * 3.14 * 2.0;\n        float b = - 3.14 * 0.5;\n        float x = uv.y;\n\n        float delta = length(vec2(dFdx(x),dFdy(x)));\n        float v1 = -cos(a*(x-delta)+b)/a;\n        float v2 = -cos(a*(x+delta)+b)/a;\n        scanline = (v2 - v1) / delta;\n    }\n    \n    scanline = scanline * 0.5 + 0.5;\n    float scanlineIntensity = 0.4;\n    scanline = mix( 1.0, scanline, scanlineIntensity );\n    col = col * col;\n    float ambient = 0.01;\n    col = mix(col, vec3(1.0), ambient);\n    col = col * scanline;        \n    col = sqrt(col);\n#endif    \n    \n    fragColor = vec4(col,1.0);\n        \n    /*\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1);\n    \n    uv = uv - 0.5;\n    \n    float outputAspect = iResolution.x / iResolution.y;\n    float screenAspect = (resolution.x / resolution.y);\n    float aspectAdjust = outputAspect / screenAspect;\n    \n    if ( aspectAdjust > 1.0 )\n    {\n        uv.x *= aspectAdjust;\n    }\n    else\n    {\n        uv.y /= aspectAdjust;\n    }\n    \n    uv *= 1.1;\n    uv = uv + 0.5;\n    \n    vec2 pixelCoord = floor(uv * resolution);\n\n    BlockColours blockColours = GetBlockColours( pixelCoord );\n\n    col = GetPixelColour( blockColours, pixelCoord );\n\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0)\n    {\n        col = vec3(intensity0) * vec3(0,1,1);\n    }\n\n    float scanline = (sin(uv.y * resolution.y * 3.14 * 2.0) * 0.5 + 0.5);\n    scanline = scanline * 0.5 + 0.5;\n    col = col * scanline;\n\n    //if ( uv.x > 0.5 ) col = currPixelColour;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    */\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    //col = col * 0.5;\n    //col = col + 0.1;\n    //col = pow(col, vec3(2.));\n    if ( iMouse.z > 0.0)\n    {\n        col = col * 2.0 * iMouse.x / iResolution.x;\n        col = pow(col, 0.5+ vec3(iMouse.y / iResolution.y));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Slower search producing slightly different colours\n#define SLOW_SEARCH 1\n\n\n\nvec2 resolution=vec2(256, 192);\nvec2 blockSize=vec2(8,8);\n\nfloat intensity0 = 0.85;\nfloat intensity1 = 1.0;\n\nconst int loadSpeed = 31; //7;\nint startDelay = 0; //4000;\n\nstruct BlockColours\n{\n    vec3 colourA;\n    vec3 colourB;\n};\n\n\n\nmat4 bayerMatrix = mat4(\n    vec4( 0.0/16.0, 12.0/16.0,  3.0/16.0, 15.0/16.0),\n    vec4( 8.0/16.0,  4.0/16.0, 11.0/16.0,  7.0/16.0),\n    vec4( 2.0/16.0, 14.0/16.0,  1.0/16.0, 13.0/16.0),\n    vec4(10.0/16.0, 06.0/16.0,  9.0/16.0,  5.0/16.0));\n\nfloat GetBayer( vec2 pixelCoord )\n{\n    return bayerMatrix[int(pixelCoord.x)%4][int(pixelCoord.y)%4];\n}\n\n\nfloat Dist2( vec3 a, vec3 b )\n{\n    vec3 ab = b-a;\n    return dot(ab,ab);\n}\n\n\nvec3 RGBtoYUV(vec3 rgb)\n{\n    float y = dot(rgb, vec3(0.255, 0.587, 0.114));\n    float u = 0.492 * (rgb.b - y);\n    float v = 0.877 * (rgb.r - y);\n    return vec3(y,u,v);\n}\n\nvec3 YUVtoRGB(vec3 yuv)\n{\n    float y = yuv.x;\n    float u = yuv.y;\n    float v = yuv.z;\n    float r = y + 1.14 * v;\n    float g = y - 0.395 * u - 0.581 * v;\n    float b = y + 2.033 * u;\n    return vec3(r,g,b);\n}\n\n\nvec3 SamplePixel( vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution )\n{\n    vec2 uv = pixelCoord / resolution;\n        \n    float sourceAspect = srcResolution.x / srcResolution.y;\n    float dstAspect = resolution.x / resolution.y;\n    \n    float aspectAdjust = dstAspect / sourceAspect;\n    \n    if ( aspectAdjust > 0.0 )\n    {\n        uv.x -= 0.5;\n        uv.x *= aspectAdjust;\n        uv.x += 0.5;\n    }\n    else\n    {\n        uv.y -= 0.5;\n        uv.y /= aspectAdjust;\n        uv.y += 0.5;    \n    }\n    \n    if ( uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0 )\n    {\n        return vec3(intensity0);\n    }\n       \n    \n    return texture(srcImage, uv).rgb;\n}\n\nfloat GetDitherIntensity()\n{\n    float dither = 0.3;\n    \n    //dither = iMouse.x / iResolution.x;\n\n    return dither;\n}\n\nvec3 ApplyDither( vec3 col, float value )\n{\n    float intensity = GetDitherIntensity();\n    \n    //col =  col * (1.0 - intensity) + intensity * value;\n    col =  col + intensity * value - intensity * 0.5;\n    \n    col = clamp( col, vec3(0), vec3(1) );\n    \n    return col;\n}\n\n\n#if SLOW_SEARCH\n\nBlockColours GetBlockColours( vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution )\n{\n    BlockColours result;\n    \n    float testIntensity = (intensity0 + intensity1) * 0.5;\n\n    vec2 blockOrigin = floor( pixelCoord / blockSize ) * blockSize;\n        \n    float error[8*8];\n    for(int i=0; i<8; i++)\n    {\n        for(int j=0; j<8; j++)\n        {\n            if (i>j)\n            {\n                int index = i+j*8;\n                error[index] = 0.0;\n            }\n        }\n    }\n        \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            vec3 pixelColour = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            float hash = GetBayer( samplePixelCoord );\n            pixelColour = ApplyDither(pixelColour, hash);\n                        \n            for(int i=0; i<8; i++)\n            {\n                vec3 testColA = vec3(0);\n                if ( (i & 1) != 0 ) testColA.r = testIntensity;\n                if ( (i & 2) != 0 ) testColA.g = testIntensity;\n                if ( (i & 4) != 0 ) testColA.b = testIntensity; \n                                \n                for(int j=0; j<8; j++)\n                {\n                    if (i>j) \n                    {\n                        vec3 testColB = vec3(0);\n\n                        if ( (j & 1) != 0 ) testColB.r = testIntensity;\n                        if ( (j & 2) != 0 ) testColB.g = testIntensity;\n                        if ( (j & 4) != 0 ) testColB.b = testIntensity;\n\n                        float dist = 0.0;\n                        int bright = 0;\n\n                        float dist1 = Dist2( testColA, pixelColour );\n                        dist = dist1;\n                        \n                        float dist2 = Dist2( testColB, pixelColour );\n                        if ( dist2 < dist1 )\n                        {\n                            dist = dist2;\n                        }\n\n                        error[i+j*8] += dist;\n                    }\n                }\n            }\n        }\n    }        \n\n    float smallestError = 999999.0;\n    int smallestErrorIndex = 0;\n    for(int i=0; i<8; i++)\n    {\n        for(int j=0; j<8; j++)\n        {\n            if (i>j)\n            {\n                int index = i+j*8;\n                if ( error[index] < smallestError )\n                {\n                    smallestError = error[index];\n                    smallestErrorIndex = index;\n                }\n            }\n        }\n    }\n        \n    result.colourA = vec3(0);    \n    if ( (smallestErrorIndex & 1) != 0 ) result.colourA.r = 1.0;\n    if ( (smallestErrorIndex & 2) != 0 ) result.colourA.g = 1.0;\n    if ( (smallestErrorIndex & 4) != 0 ) result.colourA.b = 1.0;\n\n\n    result.colourB = vec3(0);\n    if ( (smallestErrorIndex & 8) != 0 ) result.colourB.r = 1.0;\n    if ( (smallestErrorIndex & 16) != 0 ) result.colourB.g = 1.0;\n    if ( (smallestErrorIndex & 32) != 0 ) result.colourB.b = 1.0;\n    \n    // determine if we should use \"bright\" attribute\n    float scoreA = 0.0;\n    float scoreB = 0.0;\n    \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            vec3 samp = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            float d1 = Dist2(result.colourA * intensity0, samp);\n            float d2 = Dist2(result.colourB * intensity0, samp);\n            if (d1 < d2) scoreA += d1; else scoreA += d2;\n            \n            float d3 = Dist2(result.colourA * intensity1, samp);\n            float d4 = Dist2(result.colourB * intensity1, samp);\n            if (d3 < d4) scoreB += d3; else scoreB += d4;            \n        }\n    }        \n    \n    float intensity = intensity0;\n    if (scoreA>scoreB) intensity = intensity1; \n    \n    result.colourA *= intensity;\n    result.colourB *= intensity;\n\n    return result;    \n}\n\n#else \n\n// faster but lower quality\nBlockColours GetBlockColours( vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution )\n{\n    BlockColours result;\n    \n    float intensity0 = 0.85;\n    float intensity1 = 1.0;\n    \n    float testIntensity = (intensity0 + intensity1) * 0.5;\n    \n    vec2 blockOrigin = floor( pixelCoord / blockSize ) * blockSize;\n    \n    float freq[8];\n    for(int i=0; i<8; i++)\n        freq[i] = 0.0;\n        \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            float hash = GetBayer( samplePixelCoord );\n            vec3 pixelColour = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n                        \n            pixelColour = ApplyDither( pixelColour, hash);\n            \n            \n            int closestIndex = 0;\n            float closestDist = 999.0;\n            \n            for(int i=0; i<8; i++)\n            {\n                vec3 testCol = vec3(0);\n                \n                if ( (i & 1) != 0 ) testCol.r = testIntensity;\n                if ( (i & 2) != 0 ) testCol.g = testIntensity;\n                if ( (i & 4) != 0 ) testCol.b = testIntensity;                \n                \n                float dist = Dist2( testCol, pixelColour );\n                \n                if ( dist < closestDist )\n                {\n                    closestIndex = i;\n                    closestDist = dist;\n                }\n            }\n            \n            freq[closestIndex] += 1.0;\n        }\n    }\n    \n    float highestFreq = -1.0;\n    int highestIndex = 0;\n    \n    for( int i=0; i<8; i++ )\n    {\n        if ( freq[i] > highestFreq )\n        {\n            highestFreq = freq[i];\n            highestIndex = i;\n            \n        }\n    }\n\n    for(int i=0; i<8; i++)\n        freq[i] = 0.0;\n        \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            float hash = GetBayer( samplePixelCoord );\n            vec3 pixelColour = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            pixelColour = ApplyDither(pixelColour, hash);\n            \n            int closestIndex = 0;\n            float closestDist = 999.0;\n            \n            for(int i=0; i<8; i++)\n            {\n                {\n                    vec3 testCol = vec3(0);\n\n                    if ( (i & 1) != 0 ) testCol.r = testIntensity;\n                    if ( (i & 2) != 0 ) testCol.g = testIntensity;\n                    if ( (i & 4) != 0 ) testCol.b = testIntensity;                \n\n                    float dist = length( testCol - pixelColour );\n\n                    if ( dist < closestDist )\n                    {\n                        closestIndex = i;\n                        closestDist = dist;\n                    }\n                }\n            }\n\n            // ignore pixels that will map to highestIndex\n            if( closestIndex != highestIndex )\n            {            \n                freq[closestIndex] += 1.0;\n            }\n        }\n    }\n    \n    float highestFreq2 = -1.0;\n    int highestIndex2 = 7;\n    \n    for( int i=0; i<8; i++ )\n    {\n        if ( i != highestIndex )\n        {\n            if ( freq[i] > highestFreq2 )\n            {\n                highestFreq2 = freq[i];\n                highestIndex2 = i;\n\n            }\n        }\n    }\n    \n    result.colourA = vec3(0);    \n    if ( (highestIndex & 1) != 0 ) result.colourA.r = 1.0;\n    if ( (highestIndex & 2) != 0 ) result.colourA.g = 1.0;\n    if ( (highestIndex & 4) != 0 ) result.colourA.b = 1.0;\n\n    result.colourB = vec3(0);\n    if ( (highestIndex2 & 1) != 0 ) result.colourB.r = 1.0;\n    if ( (highestIndex2 & 2) != 0 ) result.colourB.g = 1.0;\n    if ( (highestIndex2 & 4) != 0 ) result.colourB.b = 1.0;    \n\n\n    // determine if we should use \"bright\" attribute\n    float scoreA = 0.0;\n    float scoreB = 0.0;\n    \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            vec3 samp = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            float d1 = length(result.colourA * intensity0 - samp);\n            float d2 = length(result.colourB * intensity0 - samp);\n            if (d1 < d2) scoreA += d1; else scoreA += d2;\n            \n            float d3 = length(result.colourA * intensity1 - samp);\n            float d4 = length(result.colourB * intensity1 - samp);\n            if (d3 < d4) scoreB += d3; else scoreB += d4;            \n        }\n    }    \n\n    float intensity = intensity0;\n    if (scoreB < scoreA) intensity = intensity1;\n\n    \n    result.colourA *= intensity;\n    result.colourB *= intensity;\n    \n    return result;\n}\n\n#endif\n\n\nvec3 GetPixelColour( BlockColours blockColours, vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution, int loadingByteIndex )\n{        \n    vec3 pixelColour = SamplePixel(pixelCoord, srcImage, srcResolution );\n    float hash = GetBayer( pixelCoord );\n    pixelColour = ApplyDither( pixelColour, hash );    \n\n    vec3 colA = blockColours.colourA;\n    vec3 colB = blockColours.colourB;\n\n    int attributeByteIndex = (256 * 192/8) + int( floor(pixelCoord.x / 8.) + (24.-floor(pixelCoord.y / 8.)) * (resolution.x / 8.) );\n    \n    if ( attributeByteIndex > loadingByteIndex )\n    {\n        colA = vec3(0);\n        colB = vec3(1) * intensity0;\n    }\n    \n    int pixelY = int(resolution.y) - 1 - int(pixelCoord.y);\n    int pixelYBlock = pixelY / (8*8);\n    int pixelYChar = (pixelY & (8*8-1)) / 8;\n    int pixelYCharRow = (pixelY & (8*8-1)) % 8;\n    int pixelYIndex = pixelYChar + pixelYCharRow * 8 + pixelYBlock * 8*8;\n    \n    int pixelByteIndex = int(pixelCoord.x) / 8 + pixelYIndex * int(resolution.x)/8;\n\n    if (pixelByteIndex > loadingByteIndex)\n    {\n        pixelColour = vec3(1);\n    }\n\n    float dist1 = Dist2( colA, pixelColour );\n    float dist2 = Dist2( colB, pixelColour );\n    if ( dist1 < dist2 )\n    {\n        return colA;\n    }\n    else\n    {                   \n        return colB;\n    }                        \n}\n", "buffer_b_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/resolution.xy;\n    \n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0)\n    {\n        discard;\n    }\n    \n    vec3 col = vec3(1);\n\n    vec2 pixelCoord = floor(uv * resolution);\n\n    BlockColours blockColours = GetBlockColours( pixelCoord, iChannel0, iChannelResolution[0].xy );\n\n    int loadingByteIndex = iFrame * loadSpeed - startDelay;\n\n    col = GetPixelColour( blockColours, pixelCoord, iChannel0, iChannelResolution[0].xy, loadingByteIndex );\n    col = RGBtoYUV( col );\n\n    fragColor = vec4(col,1.0);     \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3Xzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[640, 640, 662, 754, 902], [904, 904, 947, 947, 1101], [1104, 1104, 1139, 1139, 1354], [1356, 1356, 1407, 1407, 2636], [2638, 2638, 2695, 2786, 6541]], "test": "untested"}
{"id": "NddSRX", "name": "heat diffusion", "author": "elamolo", "description": "you must input a normal distribution texture in buffer A iChannel1, and a jet-colourmap texture in buffer A ichannel2.", "tags": ["heat"], "likes": 2, "viewed": 325, "published": 3, "date": "1633623264", "time_retrieved": "2024-07-30T18:57:31.480360", "image_code": "// Conway's Game of Life\n// https://iquilezles.org/articles/gameoflife\n//\n// State based simulation. Buffer A contains the simulated world,\n// and it reads and writes to itself to perform the simulation.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyzw );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// I implemented three variants of the algorithm with different\n// interpretations:\n//\n// VARIANT = 0: traditional\n// VARIANT = 1: box fiter\n// VARIANT = 2: high pass filter\n#define VARIANT 0\n\nfloat Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? texelFetch(iChannel0, p, 0 ).w : texelFetch(iChannel0, p, 0 ).w;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n#if VARIANT==0\n    float d0 = 0.5;\n    float d1 = 0.125;\n    float d2 = 0.0;\n\n\t\n    float k = 0.0;\n    float x = 0.0;\n    int n = 5;\n    \n    for(int i=-n;i<=n;i++){\n        for(int j=-n;j<=n;j++){\n            x = x+texture(iChannel1, vec2(float(i+n)+0.5,float(j+n)+0.5)/float(2*n+1)).x;\n            }\n        }\n    \n    for(int i=-n;i<=n;i++){\n        for(int j=-n;j<=n;j++){\n            k = k + Cell(px+ivec2(int(i),int(j)))*(1.0/x)*texture(iChannel1, vec2(float(i+n)+0.5,float(j+n)+0.5)/float(2*n+1)).x;        \n            }\n        }\n        \n    /*    \n    float k =    d2*Cell(px+ivec2(-5,-5)) + d1*Cell(px+ivec2(0,-5)) + d2*Cell(px+ivec2(5,-5))\n        +  d1*Cell(px+ivec2(-5, 0))+ d0*Cell(px)               +  d1*Cell(px+ivec2(5, 0))\n        + d2*Cell(px+ivec2(-5, 5)) +  d1*Cell(px+ivec2(0, 5)) + d2*Cell(px+ivec2(5, 5));\n          */  \n    float e = Cell(px);\n    float f = k;\n    \n#endif\n    \n\n    if( iFrame==0 ) f = 100.0*step(0.99, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)));\n    \n    float fx = fragCoord.x-iMouse.x;\n    float fy = fragCoord.y-iMouse.y;\n    vec4 m = iMouse;\n    if (sign(m.z)>0.0){\n    f = f + 10.0*(1.0-step(10.0, (fx*fx+fy*fy)));\n    }\n\t\n\tfragColor = vec4( texture(iChannel2,vec2(f/4.0,0.5)).xyz, f );\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 262, 262, 339]], "test": "untested"}
{"id": "7s3Szf", "name": "Night city road", "author": "avin", "description": "Original version was made for https://t.me/webgl_ru community competition\n\nInspired by:\nhttps://www.shadertoy.com/view/MtXSRj\n\nDOF Based on http://tuxedolabs.blogspot.fr/2018/05/bokeh-depth-of-field-in-single-pass.html", "tags": ["dof", "road", "city"], "likes": 8, "viewed": 438, "published": 3, "date": "1633617669", "time_retrieved": "2024-07-30T18:57:32.436803", "image_code": "// DOF Based on http://tuxedolabs.blogspot.fr/2018/05/bokeh-depth-of-field-in-single-pass.html\n#define DISPLAY_GAMMA 1.5\n\n#define GOLDEN_ANGLE 2.39996323\n#define MAX_BLUR_SIZE 20.0\n#define RAD_SCALE 0.5\n\n#define uFar 10.0\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n{\n    vec4 Input = texture(iChannel0, texCoord).rgba;\n    float centerDepth = Input.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = Input.rgb;\n    float tot = 1.0;\n    \n    vec2 texelSize = 1.0 / iResolution.xy;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.0; radius < MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)\n    {\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * texelSize * radius;\n        \n        vec4 sampleInput = texture(iChannel0, tc).rgba;\n\n        vec3 sampleColor = sampleInput.rgb;\n        float sampleDepth = sampleInput.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        \n        if (sampleDepth > centerDepth)\n        {\n        \tsampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n    }\n    \n    return color /= tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    \n    vec4 color = texture(iChannel0, uv).rgba;\n    \n    float focusPoint = 88.0;\n    float focusScale = iResolution.y/15.;\n    \n    color.rgb = depthOfField(uv, focusPoint, focusScale);\n\n    //tone mapping\n    color.rgb = vec3(1.7, 1.8, 1.9) * color.rgb / (1.0 + color.rgb);\n    \n    \n    vec3 col = color.rgb;\n    \n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------    \n\n    // Color control\n    col = 0.5 * col + 0.5 * col * col * (3.0 - 2.0 * col);\n\n    // Border dark\n    col *= 0.2 + 0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.3);\n\n    // Fade in\n    col *= smoothstep(0.0, 1.0, iTime);    \n    \n    color.rgb = col;\n    \n    // -----------------------------------------------------\n    \n    //inverse gamma correction\n\tfragColor = vec4(pow(color.rgb, vec3(1.0 / DISPLAY_GAMMA)), 1.0);\n    \n    // Debug depth\n    //fragColor.rgb = vec3(color.a)*0.015;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ROAD_COL vec3(.1, .1, .1)\n#define ROAD_SEP_COL vec3(1., 1., 1.)\n#define BUILDING_COL vec3(1., 0., 0.)\n#define GROUND_COL vec3(0.250, .250, 0.250)\n\nconst float tau = 6.283185;\n\n//------------------------------\n\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;    \n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n//------------------------------\n\n// vec3 opRep(vec3 p, vec3 c) {\n//    return mod(p,c)-0.5*c;\n// }\n\nvec3 opRep(vec3 p, vec3 c) {\n    vec3 res = p;\n\n    if(c.x != 0.) res.x = mod(p.x,c.x)-0.5*c.x;    \n    if(c.y != 0.) res.y = mod(p.y,c.y)-0.5*c.y;   \n    if(c.z != 0.) res.z = mod(p.z,c.z)-0.5*c.z;\n        \n    return res;    \n}\n\nvec4 opU( vec4 d1, vec4 d2 ) {    \n    return d1.a<d2.a ? d1 : d2;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 rotation(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvec3 getBuildingColor(vec3 p){\n    vec3 block = floor(p.xyz + vec3(.25, 0., 0.));   \n    float fill = smoothstep(.1, .9, fract(p.y*1.)) * step(.1, fract(p.z*1.)) * step(.1, fract(p.x*2. + 0.5));\n    \n    float lightForce = Hash3d(block);\n    float isLightning = step(.5, Hash3d(block + vec3(52.12, 17.3, 7.5)));\n    \n    return vec3(fill)*(Hash3d(block) * isLightning + .01);        \n}\n\nvec3 getRoadColor(vec3 p){\n    float lineFill = step(fract(p.x*.25) + .05, .1) * step(.5, fract(p.z*.2));\n    float texture = step(fract(p.x*.25) + .05, .1) * step(.5, fract(p.z*.2));\n    \n    vec3 roadColor = vec3(noise2d(p.xz*4.));\n           \n    return mix(vec3(0.1, 0.1, 0.11) + roadColor*.05, vec3(1.), lineFill);\n}\n\nvec4 map(vec3 p) {   \n    \n    \n    vec4 res = vec4(getBuildingColor(p), sdBox(opRep(p, vec3(15.0, 0.0, 15.0)), vec3(3.0, 15., 3.0)));\n    res = opU(res, vec4(getRoadColor(p),sdBox(opRep(p, vec3(0.0, 0.0, 1.0)), vec3(3.0, .25, 5.0))));    \n    \n    // vec3 lp = p + (p.x > 0. ? vec3(0., 0., 2.5) : vec3(0.));\n    vec3 lp = p;\n    lp = lp + (abs(lp.x) > 10. ? vec3(0., -100., 0.): vec3(0.));\n    float lh = 0.5;\n    res = opU(res, vec4(vec3(1., 0., 0.),sdBox(opRep(lp + vec3(0., -lh, 0.), vec3(7.5, 0.0, 5.0)), vec3(.05, .20, .05))));    \n    res = opU(res, vec4(vec3(0.5, .5, .5),sdBox(opRep(lp, vec3(7.5, 0.0, 5.0)), vec3(.05, lh, .05))));           \n    \n    res = opU(res, vec4(GROUND_COL,p.y));\n    \n\treturn res;\n}\n\n\nvec4 trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    vec3 col = vec3(0.);\n    for (int i = 0; i < 100; i++) {\n    \tvec3 p = o + r * t;\n        vec4 result = map(p);\n        float d = result.a;\n        \n        if (d < 0.001) break;\n         \n        col = result.rgb;\n        t += d;\n    }\n    return vec4(col,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \n    \n    vec2 m = vec2(0.00, 0.);\n    if (iMouse.z > 0.0) {\n        m = iMouse.xy / iResolution.xy - vec2(.5, 0.);\n    }\n        \n    m *= tau * vec2(1.0, 0.25);\n   \n   \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime*.525 * 1.1;\n    \n    time = mod(time, 100.);\n    \n    vec3 r = normalize(vec3(uv, 0.75 ));\n    \n    r.yz *= rotation(0.15 - m.y);\n    r.xy *= rotation(sin(time + 10.0) * 0.5);\n    \n    r.xz *= rotation(-m.x);\n    \n    float altitude = sin(time * 0.5) * 0.5 + 2.5;\n    vec3 o = vec3(sin(time * 0.5) * 1.17, altitude*.5 + 1., time * 32.0);        \n    \n    vec4 t = trace(o, r);\n    float tDepth = t.a;\n    vec3 tCol = t.xyz;\n    float fog = 1.0 / (1.0 + tDepth * tDepth * 0.01);  \n    vec3 col = mix(vec3(0.0), tCol, fog);\n    // vec3 fc = vec3(fog);\n\n       \n    \n\t// gamma\t\n\tcol = pow( clamp(col,.0,1.0), vec3(0.95) );\n\n\t// vignetting\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.21 );\n    \n\tfragColor = vec4(col ,tDepth);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3Szf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 291, 291, 406], [408, 408, 478, 478, 1501], [1503, 1503, 1560, 1560, 2579]], "test": "untested"}
{"id": "7d3XRf", "name": "pseudo 3d fluid", "author": "flockaroo", "description": "on twigl.app: [url]https://t.co/olT3fPa2Z6[/url]  < 280 chars also possible on shadertoy? - hmm, not sure...", "tags": ["simulation", "fluid", "cfd"], "likes": 32, "viewed": 929, "published": 3, "date": "1633615068", "time_retrieved": "2024-07-30T18:57:33.356345", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// twigl.app - https://t.co/olT3fPa2Z6\n\n// based on https://www.shadertoy.com/view/MsGSRd\n// or on the 2 tweet version - https://www.shadertoy.com/view/4dBfDW\n\nvoid mainImage( out vec4 c, vec2 f )\n{\n    c=vec4(texture(iChannel0,f/iResolution.xy).w);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// twigl.app - https://t.co/olT3fPa2Z6\n\n// based on https://www.shadertoy.com/view/MsGSRd\n// or on the 2 tweet version - https://www.shadertoy.com/view/4dBfDW\n\n// twigl.app doesnt use float buffers, so its faster there, and has a slightly different look (more coarse)\n  \nvoid mainImage( out vec4 o, vec2 F )\n{\n#define C(x)texture(iChannel0,(x+F)/iResolution.xy)\n#define L(z)for(vec2 a=S;a.x>1.;z=sin(a--))\nvec2 S=vec2(27,-28),d,v,q,p=q=d=S-S;\nL(p)L(q)v=C((p+q)*75.).xy,d-=dot(p,v)*q-dot(p,q)*v;\no.xy=C(d).xy*.998+.01/F;\nv=clamp(fwidth(o.xy)*40.,0.,1.);\no.w=C(-1.+1.002*).w*(.95-v.y)+v.y;\n\n// emulating non-float behaviour of twigl.app (more coarse look - of course this cant speed it up here ;-)\no=clamp(floor(o*256.+.5)/256.,0.,1.);\n\n//if(iFrame==0) o1=vec4(0);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XRf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[296, 296, 334, 334, 387]], "test": "untested"}
{"id": "sdcSRf", "name": "falling blocks", "author": "elamolo", "description": "falling blocks", "tags": ["buffer"], "likes": 1, "viewed": 211, "published": 3, "date": "1633614034", "time_retrieved": "2024-07-30T18:57:34.208067", "image_code": "// Conway's Game of Life\n// https://iquilezles.org/articles/gameoflife\n//\n// State based simulation. Buffer A contains the simulated world,\n// and it reads and writes to itself to perform the simulation.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nint Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n\n    int k1 = Cell(px+ivec2(0,1));\n    int k2 = Cell(px+ivec2(0,-1)); \n\n    int e = Cell(px);\n\n\n    float f = ((k2 == 0&&e==1||k1==0&&e==0||px.y == 449) && (px.y!=0))?0.0:1.0;\n    \n\n    \n\n    if( iFrame==0 ) f = step(0.7, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)));\n    \n    float fx = fragCoord.x-iMouse.x;\n    float fy = fragCoord.y-iMouse.y;\n \n            \n    if( iMouse.z>0.5){  \n    f = f + (1.0-step(100.0, (fx*fx+fy*fy)))*\n    step(0.99, hash1(iTime*fragCoord.x*13.0+hash1(iTime*fragCoord.y*71.1)));\n    }\n\t\n\tfragColor = vec4( f, 0.0, 0.0, 0.0 );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 262, 262, 343]], "test": "untested"}
{"id": "7s3SzX", "name": "Fork EuclideanRythm", "author": "ollj", "description": "Simplifying and testing;\nUsing the euclidean rhythms formula to generate some programmatic melodies.see: \nhttps://www.youtube.com/watch?v=vwigqSwYNaQ\nhttps://www.youtube.com/watch?v=vwigqSwYNaQ\nhttps://twitter.com/boggodan/status/1277738002270298112", "tags": ["sound", "music", "euclideanbeats", "generativemusic", "euclideanrythm"], "likes": 7, "viewed": 426, "published": 3, "date": "1633610777", "time_retrieved": "2024-07-30T18:57:35.033860", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n   ;vec3 col =vec3(0.7,0.34,0.49) //default\n   ;float on = iTime              //default\n\n   ;float steps=floor(iResolution.x/3.)//this may not be the way to ensure uniform line widths\n   ;float stp = floor(uv.x*steps);\n\n   ;if(uv.y<0.33            ){on+=16.33;col=vec3(.2,.5,.9)\n   ;}if(uv.y>0.66){on+=25.50;col=vec3(0.5,0.9,0.3)\n   ;}//if(uv.y<=0.66           ){          col=vec3(0.7,0.34,0.49);}\n   ;on = euclidean(stp, getWangSteps(on)*steps/16.,steps); //full overwrite changes meaning of [on]\n\n    float playhead = mod(iTime*tempo_mult,steps)/steps;\n    float muchness = 1.0 - clamp((playhead*steps-stp),0.0,1.0);\n    \n    if(playhead*16.0>stp)\n        col = mix(col,vec3(1.0),muchness);\n        \n    fragColor = vec4(col,1.0)*on;\n    \n    if(abs(uv.x - playhead)<0.001)\n       fragColor += vec4(1.0);\n    \n    fragColor += vec4(0.1,0.11,0.09,1.0);\n}", "image_inputs": [], "sound_code": "float ftom(float note)\n{\n    return 440.0 * pow(2.0,((note-12.0)/12.0));\n}\n\n//lol, there has to be a nice shadery solution\nfloat mapPenta(int note)\n{\n//return  floor(float(note-1))*5./12.)*12.; //or something like that, seems less efficient.\n    switch(note)\n    {\n        case 0: return 0.0;\n        case 1: return 2.0;\n        case 2: return 5.0;\n        case 3: return 7.0;\n        case 4: return 10.0;\n        case 5: return 12.0;\n        default: return 0.0;\n    }\n}\n\nvec2 boop(float time, float freq, float ph)\n{\n    return vec2( sin(6.2831*freq*mod(time,16.0))*exp(-3.0*ph) );\n}\n\nfloat getEuclideanSine(float time, float beats, float steps)\n{\n    float stp = floor(mod((time*tempo_mult),steps));\n    float on = euclidean(stp,beats,steps);\n    \n    float freq = ftom(mapPenta(int(beats)%6));\n    float octave = mod(getWangSteps(beats)-1.0,3.0); //haxor\n    octave = pow(2.0,octave);\n    return on*float(boop(time, freq*octave, mod(time*tempo_mult,1.0f)))*0.15;\n}\n\nfloat getSines(float time)\n{\n    return \n    getEuclideanSine(time, getWangSteps(time),16.0f) +\n    getEuclideanSine(time, getWangSteps(time+25.5),16.0f) +\n    getEuclideanSine(time, getWangSteps(time+16.33),16.0f);\n}\n\nconst int DELAY_TAPS = 4;\n\n//sound + sound from a while ago x DELAY_TAPS\nvec2 getWithFX(float time)\n{\n    vec2 outp = vec2(0.0);\n    for(int i =0; i<DELAY_TAPS; i++)\n    {\n        //stereo delay by simulating entire output back DELAY_TAPS times lol\n        outp += \n        vec2(getSines(time - 2.5f * float(i))/float(i*3+1),\n        getSines(time - 3.0f * float(i))/float(i*3+1));\n    }\n    \n    return outp;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    return getWithFX(time);\n}", "sound_inputs": [], "common_code": "const float tempo_mult = 5.0;\n\n//euclidean beats formula, from\n//https://twitter.com/mmalex/status/1177617079119286272\n\n#define unequal(a,b,c)   mix(a,b,step(floor(u*l/r),0.)+step(0.,c)-1.)//(c!=0)?a:b\n  \nfloat euclidean(float u, float l, float r){//uv,lines/intervalRes\n  //;float c=floor(u*l/r)-floor((u-1.)*l/r) ;//return unequal(c,0.,1.) //fails terribly.\n //;if (c!=1.) return .25;return .5;//matte test 1 to prove thew precision of the below\n //;if (c!=0.) return .5;return .25;//matte test 2 to prove thew precision of the below\n //\n ;return     floor(u*l/r)-floor((u-1.)*l/r) //surprisingly, this is precise and sufficient!\n //;if (floor(u*l/r)-floor((u-1.)*l/r)!=0.) return 1.; return 0.;//identical\n //;if (floor(u*l/r)!=floor((u-1.)*l/r)   ) return 1.; return 0.;//identical\n //;return floor(u*l/r)!=floor((u-1.)*l/r)?1.0:0.0               //source\n ;}\n\nfloat wang(uint u)\n{\n    uint seed = (u*1664525u);\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return mod(value,1.0);\n}\n\nfloat getWangSteps(float iTime)\n{\n    return floor(wang(uint(iTime*0.25))*10.0)+2.0;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3SzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 955]], "test": "untested"}
{"id": "WtcfDX", "name": "julia sets", "author": "shanesimmsart", "description": "playing", "tags": ["fractal"], "likes": 0, "viewed": 197, "published": 3, "date": "1633610574", "time_retrieved": "2024-07-30T18:57:36.026207", "image_code": "//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec3 slerp(vec3 start, vec3 end, float percent)\n{\n     // Dot product - the cosine of the angle between 2 vectors.\n     float dot = dot(start, end);     \n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec3 RelativeVec = normalize(end - start*dot); // Orthonormal basis\n     // The final result.\n     return ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 c = fragCoord/iResolution.xy;\n    c = (c * 2.0) - vec2(1.0);\n    c.y *= iResolution.y / iResolution.x;\n    c *= 2.0;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    m = (m * 2.0) - vec2(1.0);\n    m.y *= iResolution.y / iResolution.x;\n    m *= 2.0;\n    \n    vec2 z = c;\n    \n    int maxIterations = 64;\n    int numIterations = 0;\n    \n    while (numIterations < maxIterations && z.x*z.x + z.y*z.y < 4.0) {\n        numIterations += 1;\n\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + m;\n        // z = vec2(z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y) + d;\n        // z = vec2(z.x*z.x*z.x*z.x - 6.0*z.x*z.x*z.y*z.y + z.y*z.y*z.y*z.y, 4.0*z.x*z.x*z.x*z.y - 4.0*z.x*z.y*z.y*z.y) + d;\n    }\n    \n    vec3 colA = vec3(0.18, 0.09, 0.18);\n    vec3 colB = vec3(1.0, 1.0, 0.09);\n \n    // Time varying pixel color\n    vec3 col = slerp(colA, colB, float(numIterations)/float(maxIterations));\n    \n    numIterations = 0;\n    z = vec2(0.);\n    for (int i = 0; i < maxIterations; i ++)\n    {\n        // Must multiply with z as though it's a complex number\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        numIterations++;\n        if (dot(z,z) > 2.)\n        {\n            // We can make white or have falloff of iterations\n            // col = vec3(1.0);\n            col.z = float(numIterations)/float(maxIterations);\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 174, 223, 288, 864], [866, 866, 923, 973, 2410]], "test": "untested"}
{"id": "7dcSRX", "name": "Swirling Balls", "author": "dr2", "description": "Balls arranged in multiple rotating shells with 60-fold symmetry", "tags": ["symmetry", "pentakis"], "likes": 18, "viewed": 378, "published": 3, "date": "1633601929", "time_retrieved": "2024-07-30T18:57:36.790164", "image_code": "// \"Swirling Balls\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Balls arranged in multiple rotating shells with 60-fold symmetry\n// (see \"Pentakis Dodecahedron\" and \"Pentakis Reflections\");\n// only one ball drawn per shell, the (maximal) 60x factor is free.\n\nfloat PrSphDf (vec3 p, float r);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r;\n  dMin = dstFar;\n  p.y += 1.2 * sin (0.1 * pi * tCur);\n  p.xz += Rot2D (vec2 (1., 0.), 0.1 * pi * tCur); \n  p.xz = Rot2D (p.xz, 0.05 * pi * tCur);\n  r = 3.3;\n  d = PrSphDf (p, r + 0.2);\n  if (d < 0.1) {\n    for (int k = VAR_ZERO; k < 16; k ++) {\n      r *= 0.92;\n      p.xz = Rot2D (p.xz, 0.43 * pi);\n      p.xy = Rot2D (p.xy, 0.05 * pi * tCur);\n      q = DodecSym (p);\n      q.yz -= vec2 (0.365, -1.) * r;\n      d = PrSphDf (q, 0.05 * sqrt (r));\n      DMIN (1 + k);\n    }\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl) \n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = HsvToRgb (vec3 (mod (float (idObj) / 16. + 0.03 * tCur, 1.), 0.5, 1.));\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col *= exp (-0.3 * (dstObj - 17.) / 6.);\n  } else col = StarPat (rd, 12.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.005 * pi * tCur;\n    el -= 0.1 * pi * sin (0.003 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 4.;\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[721, 721, 745, 745, 1296], [1298, 1298, 1320, 1320, 1859], [1861, 1861, 1894, 1894, 2077], [2079, 2079, 2100, 2100, 2355], [2357, 2357, 2393, 2393, 2846], [2848, 2848, 2883, 2883, 3328], [3372, 3372, 3428, 3428, 4472], [4474, 4474, 4507, 4507, 4534], [4536, 4536, 4558, 4558, 4596], [4598, 4598, 4634, 4634, 4840], [4842, 4842, 4872, 4872, 4985], [4987, 4987, 5018, 5018, 5082], [5084, 5084, 5108, 5108, 5225], [5259, 5259, 5283, 5283, 5395], [5397, 5397, 5422, 5422, 5608], [5610, 5610, 5631, 5631, 5786]], "test": "untested"}
{"id": "sdtSz2", "name": "Mountains at dawn", "author": "guil", "description": "Mountains at dawn\nUsing Yonatan clouds/mountains combined field", "tags": ["clouds", "mountains"], "likes": 13, "viewed": 431, "published": 3, "date": "1633595421", "time_retrieved": "2024-07-30T18:57:37.550132", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2021\n \n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec3 l = vec3(1.);\n\n//Yonatan clouds/mountains combined field\nfloat field(in vec3 p) {\n\t\n\tfloat s=2.,e,f,o=1.;\n\t\n\tfor(e=f=p.y;s<1e2;s*=1.6)\n            p.xz*=rot(s),\n            e+=abs(dot(sin(p*s)/s,.4*l)),\n            f+=abs(dot(sin(p.xz*s*.5)/s,l.xz));\n\to+=(f>.001?e:-exp(-f*f));\n    return max(o,0.);\n}\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 3.5;\n    float dt = .0018;\n    vec3 col= vec3(0.);\n    for( int i=0; i<100; i++ )\n\t{        \n        float c = field(ro+t*rd);               \n        t+=dt*(c*c*2.5);\n        dt *= 1.025;\n        col = .95*col+ .08*vec3(c*c*c, c*c, c);\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n\n    // camera\n\n    vec3 ro = vec3(2.);\n   \n    ro.yz*=rot(-1.2); \n    ro.y +=3.;\n    ro.xz*=rot(0.1*t);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    ro.x -=t*.4;\n\n\t// raymarch \n    \n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSz2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[122, 122, 141, 141, 188], [210, 252, 276, 276, 496], [499, 499, 536, 536, 816], [819, 819, 876, 876, 1531]], "test": "untested"}
{"id": "fd3SRf", "name": "Hexagon -  distance 2D", "author": "iq", "description": "Distance to a hexagon", "tags": ["2d", "distancefield", "sdf", "hexagon", "distance"], "likes": 30, "viewed": 1892, "published": 3, "date": "1633577568", "time_retrieved": "2024-07-30T18:57:38.310100", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and an hexagon.\n\n// List of other 2D distances:\n//   https://iquilezles.org/articles/distfunctions2d\n// and\n//   https://www.shadertoy.com/playlist/MXdSRf\n\nfloat sdHexagon( vec2 p, float s, float r ) \n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*s, k.z*s), s);\n    return length(p)*sign(p.y) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // size\n\tfloat si = 0.3 + 0.2*cos( iTime );\n    // corner radius\n    float ra = 0.3*si;\n\n\tfloat d = sdHexagon(p,si,ra);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n    //vec3 col = (d<0.0) ? vec3(0.5) : vec3(1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdHexagon(m,si,ra);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SRf.jpg", "access": "api", "license": "mit", "functions": [[1253, 1253, 1299, 1299, 1493], [1495, 1495, 1552, 1588, 2374]], "test": "untested"}
{"id": "fdcSzX", "name": "fish-pescado", "author": "jorge2017a2", "description": "fish", "tags": ["fish"], "likes": 3, "viewed": 209, "published": 3, "date": "1633570097", "time_retrieved": "2024-07-30T18:57:39.235625", "image_code": "//----por jorge2017a2----jorge2017a1 :)\n// 6-oct-2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdVesica(vec2 p, float r, float d)\n{   p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b)): length(p-vec2(-d,0.0))-r;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    p.x= opRep1D(p.x, 30.0 ); \n    p.y=p.y-8.0*sin(iTime);\n    vec3 pp=p;\n    \n    float t1=mod(iTime, 2.0);\n    float t2=mod(iTime, 3.0);\n    \n    if(t2<t1)\n    res =opU3(res, vec3(planeDist1,-1.0,11.0));\n    else\n    res =opU3(res, vec3(planeDist1,-1.0,12.0));\n    \n    \n    \n    p.y=p.y-8.0;\n    p= rotate_z(p, radians(90.0));\n    \n    float dv1= sdVesica(p.xy, 6.0, 3.0);\n    float dt1=sdTriangleIsosceles(p.xy-vec2(0.0,4.0), vec2(3.0,2.0) );\n    float db1=sdRoundBox( p, vec3(10.,10.,2.0) , 0.5);\n    float dcy1=sdCylinderXY(p-vec3(-1.5,-1.5,0.0),vec2(0.35,3.5) );\n    float dcy2=sdCylinderXY(p-vec3(-1.5,-1.5,0.0),vec2(0.35,2.0) );\n    float intdcy2= intersectSDF(dcy2,dv1);\n    dv1=differenceSDF(dv1, dcy1);\n    \n    \n    p=pp;\n    //boca\n    float db2a=sdBox(p-vec3(-3.8,8.4,0.0), vec3(1.5,0.25,2.5) );\n    float db2b=sdBox(p-vec3(-3.8,7.8,0.0), vec3(1.4,0.45,2.5) );\n    float db2c=sdBox(p-vec3(-3.8,7.4,0.0), vec3(1.5,0.25,2.5) );\n    float disint1= intersectSDF(dv1, db1);\n    \n    disint1=differenceSDF(disint1,dcy1);\n    float disint2= intersectSDF(db1,dt1);\n    res =opU3(res, vec3(disint1,2.0,-1.0));\n    res =opU3(res, vec3(disint2,2.0,-1.0));\n    \n    res =opU3(res, vec3(db2b,0.0,-1.0)); //2do centro\n    res =opU3(res, vec3(db2a,1.0,-1.0)); //1ero\n    res =opU3(res, vec3(db2c,1.0,-1.0)); //3ero\n    res =opU3(res, vec3(intdcy2,4.0,-1.0));\n   \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n         vec3 r = reflect(rd, norm);\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh+=occlusion(hit,r);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}    \n    \n        \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nfloat zigzagv2(vec2 p, float d)\n{  // triangle wave\n    vec2 q=p;\n    q.y-= 0.5;\n    q.y -= asin(sin(q.x));\n    return min(d, abs(q.y)-0.3) ;\n}   \n\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n        \n    if (id_material==11.0)\n    { \n     vec2 q=p.xy;\n    q.y-= 0.5;\n    q.y -= asin(sin(q.x));\n        //return mix(vec3(0.0,0.0,1.0),vec3(0.0,0.0,0.0),abs(q.y)-0.3  );\n        return mix(vec3(1.0),vec3(0.0,0.0,0.0),abs(q.y)-0.3  );\n    }\n        \n    if (id_material==12.0)\n    { \n        vec2 uv=p.xz;\n        float d=9999.9;\n         for( int i=-20; i<40;i++)\n          d= zigzagv2(uv-vec2(0.0,float(i*3)) , d);\n          \n       return mix(vec3(1.0),vec3(0.0),d  );\n    }\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*6.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(20.0, 20.0, 10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -20.0, 30.0, -30.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0+t,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n    light_pos1+=ro;\n    light_pos2-=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};   \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[514, 514, 550, 550, 571], [572, 572, 604, 604, 688], [689, 689, 735, 735, 822], [823, 823, 862, 862, 957], [958, 958, 997, 997, 1092], [1093, 1093, 1132, 1132, 1227], [1229, 1273, 1320, 1320, 1347], [1348, 1348, 1391, 1391, 1418], [1419, 1419, 1467, 1467, 1495], [1496, 1534, 1570, 1570, 1615], [1616, 1616, 1655, 1655, 1699], [1700, 1700, 1739, 1739, 1783], [1784, 1784, 1816, 1816, 1841], [1842, 1907, 1941, 1941, 2037], [2038, 2038, 2072, 2072, 2163], [2164, 2164, 2198, 2198, 2289], [2290, 2290, 2324, 2324, 2419], [2422, 2422, 2464, 2464, 2589], [2591, 2591, 2642, 2642, 2948], [2950, 2950, 2975, 2975, 4434], [4436, 4436, 4460, 4460, 4622], [4624, 4624, 4673, 4673, 5340], [5343, 5343, 5379, 5379, 5624], [5626, 5626, 5653, 5653, 5670], [5672, 5672, 5708, 5708, 5800], [5801, 5801, 5847, 5847, 5972], [5974, 5974, 6011, 6011, 6287], [6289, 6289, 6356, 6356, 6633], [6635, 6635, 6718, 6718, 7722], [7726, 7726, 7819, 7819, 7949], [7951, 7951, 7983, 7983, 8180], [8183, 8183, 8216, 8234, 8326], [8332, 8332, 8379, 8379, 8914], [8916, 8916, 9009, 9009, 9355], [9357, 9357, 9388, 9388, 9987], [9989, 9989, 10015, 10015, 10125], [10127, 10127, 10185, 10185, 10237], [10239, 10239, 10296, 10296, 10841]], "test": "untested"}
{"id": "7sdXz2", "name": "Rounded Square - distance 2D", "author": "iq", "description": "SIGNED distance to a rounded square.", "tags": ["2d", "distance", "signed"], "likes": 32, "viewed": 1810, "published": 3, "date": "1633564185", "time_retrieved": "2024-07-30T18:57:40.055433", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Signed distance to a 2D rounded square.\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n// and iquilezles.org/articles/distfunctions2d\n\n\n\n// s = side length\n// r = corner radius\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel and moust coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate the square\n\tfloat si = 0.7;\n    float ra = si*(0.5 - 0.5*cos(3.1*iTime+4.0));\n\n    // draw the square \n\tfloat d = sdRoundSquare( p, si, ra );\n\n    // apply colors to it\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundSquare( m, si, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXz2.jpg", "access": "api", "license": "mit", "functions": [[1319, 1359, 1418, 1418, 1504], [1508, 1508, 1565, 1600, 2408]], "test": "untested"}
{"id": "7ddSR2", "name": "spinning in circles", "author": "python273", "description": " ", "tags": ["circle", "spinning"], "likes": 5, "viewed": 244, "published": 3, "date": "1633553754", "time_retrieved": "2024-07-30T18:57:40.923113", "image_code": "#define PI 3.141592653\n\nfloat bR = 3.;\nfloat sR = 1.;\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c) * v;\n}\n\nvec3 circle(vec2 uv, vec2 pos, float r, float angle) {\n    vec2 b = rotate(vec2(pos - uv) / r / 2., angle + PI/4.-0.1);\n\n    vec3 c = texture(iChannel0, b).rgb;\n    return c * (1.0 - smoothstep(r - 0.02, r + 0.02, distance(uv, pos)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= 11.0;\n    if (mod(iTime, PI*4.)>PI*2.) {\n        uv = rotate(uv, iTime);\n    }\n\n    vec3 col = vec3(0.);\n\n    col += circle(uv, vec2(0.0), bR, PI);\n    col += circle(\n        uv,\n        vec2(sin(iTime), cos(iTime)) * (bR+sR),\n        sR,\n        -iTime * (bR/sR+1.)\n    );\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 86, 86, 157], [159, 159, 213, 213, 395], [397, 397, 452, 452, 850]], "test": "untested"}
{"id": "sdtXzj", "name": "Gaz Remix Fractal", "author": "MacroMachines", "description": "Gaz is killin it", "tags": ["fractalgaz"], "likes": 15, "viewed": 388, "published": 3, "date": "1633549822", "time_retrieved": "2024-07-30T18:57:41.680089", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s;\n    for(;i++<99.;)\n    {\n        p=g*d-vec3(.0025*(iTime*.5),0.0,2.13);//+(cos(iTime)+0.50)*0.01+1.2);\n        p=R(p,normalize(vec3(1,-2,2)),iTime*.005);\n        s=2.;\n        vec4 q=vec4(p,cos(iTime*100.4)*0.0095+(cos(iTime*2.0)*0.051)-(cos(iTime*0.50)*0.51)); \n\t\tfor(int j=0;j++<6;)\n        {\n            q=abs(q);\n            q=q.x<q.y?q.zwxy:q.zwyx;\n            s*=e=2.3/clamp(dot(q,q),.2,1.5);\n            q=q*e-vec4(1,4,2,1);\n        }\n        g+=e=min(\n                length(q.w)/s,\n                length(cross(q.xyw,vec3(.577)))/s-.3e-4\n            )+.001;\n        O.rgb+=mix(r/r,H(log(s)*2.),.3)*.015*exp(-.03*i*i*e);\n    }\n    O*=O*O*O;\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 140, 140, 900]], "test": "untested"}
{"id": "ssG3D1", "name": " [ConcoursJFIG2021] JellyFish", "author": "PlathC", "description": "My participation in the JFIG 2021 render contest.", "tags": ["raymarching", "spheretracing", "jellyfish", "outline", "concoursjfig2021"], "likes": 1, "viewed": 412, "published": 3, "date": "1633545982", "time_retrieved": "2024-07-30T18:57:42.638527", "image_code": "const float OutlineSize = 3.;\n\n// Blur by mAlk\n// Reference: https://www.shadertoy.com/view/Ms2Xz3\nvec4 blur (in vec2 Coord, in sampler2D Tex, in float MipBias)\n{\n\tvec2 TexelSize = MipBias/iChannelResolution[0].xy;\n    \n    vec4  Color = texture(Tex, Coord, MipBias);\n    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias);    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias);    \n\n    return Color/9.0;\n}\n\n// Bloom effect by mAlk\n// https://www.shadertoy.com/view/Ms2Xz3    \nvec4 bloom(in vec4 color, in vec2 uv, in sampler2D tex) {\n    const float BlurSize  = 3.;\n    const float Threshold = .5; \n    const float Intensity = .5;\n    vec4 highlight = clamp(blur(uv, iChannel0, BlurSize) - Threshold, 0., 1.) * 1. / (1. - Threshold);    \n    return 1. - (1. - color) * (1. - highlight * Intensity); //Screen Blend Mode\n}\n\n// Outline computation based on background encoding done in Buffer A background function\nfloat outline(vec2 fragCoord) {\n    vec2 uv = fragCoord;\n            \n    float wStep = 1. / iResolution.x;\n    float hStep = 1. / iResolution.y;\n    \n    float finalValue = 0.;\n    vec4 originalColor = texture(iChannel0, uv);\n\n    if (originalColor.a != BackgroundEncodedValue)\n        return 0.f;\n        \n    for(float i = -OutlineSize; i <= OutlineSize; i++) {\n     \tfor(float j = -OutlineSize; j <= OutlineSize; j++) {\n            vec2 newTextureCoordinates = vec2(uv.x + (i * wStep), uv.y + (j * hStep));\n            vec4 otherPixel = texture(iChannel0, newTextureCoordinates);\n            finalValue = max(finalValue, mix(1., 0., float(otherPixel.a == BackgroundEncodedValue)));\n            \n            if(finalValue > 0.) \n                break;\n        }\n    }\n    \n    float vignet = (0.4 - length(uv - 0.5));\n    return finalValue * vignet;\n}\n\nvec4 combineOutline(vec4 color, float outline) {\n    return clamp( outline * (color + vec4(0.3, 0., 0.7, 0.))  + color * (1. - outline), 0., 1.);\n}\n\nvec3 gammaCorrection(vec3 color, float gamma) {\n    return pow(color, vec3(1. / gamma));\n}\n\nvoid mainImage0( out vec4 fragmentColor, in vec2 fragmentCoordinates ) {\n    vec2 uv = fragmentCoordinates/iResolution.xy;\n    \n    float outlineValue = outline(uv);\n    vec4 color = combineOutline(texture(iChannel0, uv), outlineValue);\n    \n    color = bloom(color, uv, iChannel0);\n    \n    float vignet = (1. - length(uv - 0.5));\n    fragmentColor = vignet * color;\n}\n\n// Anti-aliasing By Fabrice Neyret\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n    O = vec4(gammaCorrection(O.rgb, 2.2), 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Pi                     = 3.1415926;\nconst float MaxDistance            = 10.;\nconst float MaxDistanceInVolume    = 6.;\nconst float StepSize               = 2e-2;\nconst float Threshold              = 1e-3;\nconst float StartingT              = 2.;\nconst float MaxSteps               = 60.;\nconst float BackgroundEncodedValue = 0.123;\n\n// Reference: https://stackoverflow.com/a/61262594\nconst float MaxFloat = intBitsToFloat(0x7F800000);\n\n#define DEG2RAD(deg) ((deg) * Pi / 180.)\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayClosestObjectInformation {\n    float d;\n    int matId;\n    bool inVolume;\n};\n\nstruct PhongMaterial {\n    vec3 ambient;\n    vec3 specular;\n    vec3 diffuse;\n    float shininess;\n};\n\nstruct VolumeMaterial {\n    float coefficient;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n\nmat3 xRotationMatrix(float angle) {\n    return mat3(1., 0.,          0.,\n                0., cos(angle), -sin(angle),\n                0., sin(angle),  cos(angle));\n}\n\nmat3 yRotationMatrix(float angle) {\n    return mat3( cos(angle), 0., sin(angle),\n                 0.,         1., 0.,\n                -sin(angle), 0., cos(angle));\n}\n\n// Beer-Lambert's law\n// Reference: https://www.scratchapixel.com/lessons/advanced-rendering/volume-rendering-for-artists\nfloat beerLambert(float volumeCoefficient, float lightDistanceInVolume) {\n    return exp(-lightDistanceInVolume * volumeCoefficient);\n}\n\n// Signed distance function defining 3D primitives and operations by Inigo Quilez\n// Reference: https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 point, vec3 spherePosition, float sphereRadius) {\n    return length(point - spherePosition) - sphereRadius;\n}\n\nfloat sdEllipsoid( in vec3 point, in vec3 center, in vec3 radius ) {\n    vec3 p = point - center;\n    float k0 = length(p / radius);\n    float k1 = length(p / (radius * radius));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l) {\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// Smooth mininum by Inigo Quilez\n// Reference: https://iquilezles.org/articles/smin\nfloat sminCubic(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Bézier signed distance by Inigo Quilez\n// Reference: https://www.shadertoy.com/view/ld3Gz2\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) {\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier(vec3 p, vec3 a, vec3 b, vec3 c) {\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n// Blobby Cross SDF by Inigo Quilez\n// Reference: https://www.shadertoy.com/view/NssXWM\nfloat sdBlobbyCross( in vec2 pos)\n{\n    const float he = 1.;\n    const float ra = 0.5;\n\n    pos *= 2.;\n    pos = abs(pos);\n    pos = vec2(abs(pos.x - pos.y), 1.0 - pos.x - pos.y) / sqrt(2.0);\n\n    float p = (he - pos.y - 0.25 / he) / (6.0 * he);\n    float q = pos.x / (he * he * 16.0);\n    float h = q * q - p * p * p;\n    \n    float x;\n    if( h > 0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else          { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x, sqrt(2.0) / 2.0);\n    \n    vec2 z = vec2(x, he * (1.0 - 2.0 * x * x)) - pos;\n    return abs(length(z) * sign(z.y) - ra) < 0.1 ? 1. : 0.;\n}\n\n\n// JFIG texture by haqreu\n// https://www.shadertoy.com/view/wsXyD8\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u);\nbool jfigTexture(vec2 pos) {\n    pos = pos * vec2(JFIGW, JFIGH);\n    uint id = uint(pos.x) + (JFIGH-1u-uint(pos.y))*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n", "buffer_a_code": "Light light = Light(vec3(0., 1.5, 0.), vec3(0.6, 0.3, 0.6), 2.);\n\nVolumeMaterial BellVolumeMaterial = VolumeMaterial(0.2);\nconst float BellTextureDepth = Threshold * 50.F;\n\nconst int bellMatId = 0; \nconst int tentacleMatId = bellMatId + 1;\nconst int subBellMatId = tentacleMatId + 1;\n\nPhongMaterial bellMat     = PhongMaterial(vec3(.4, 1., 1.), vec3(1.), vec3(1.), 100.);\nPhongMaterial tentacleMat = PhongMaterial(vec3(.4, .4, .8), vec3(1.), vec3(1.), 100.);\nPhongMaterial subBellMat  = PhongMaterial(vec3(.9, .3, 1.), vec3(0., .9, .9), vec3(0., 1., 1.), 225.);\n\nRayClosestObjectInformation jellyFish(vec3 point) {\n    RayClosestObjectInformation outInfo;\n    \n    // Bell\n    float xBellSize   = smoothstep(0.f, 1.f, (sin(iTime * 3.) + 1.) * 0.5) * 0.25 + 1.;\n    float yBellSize   = smoothstep(0.f, 1.f, (cos(iTime * 3.) + 1.) * 0.5) * 0.25 + 1.;\n    vec3 bellSize     = vec3(xBellSize, yBellSize, xBellSize);\n    vec3 bellPosition = vec3(0.f, 0.5 * -sin(iTime * 2.5) + 0.3, 0.);\n    \n    float bell = MaxFloat;\n    if( point.y > bellPosition.y - 0.4) {\n        bell  = sdEllipsoid(point, bellPosition - vec3(0., 0.4, 0.),  bellSize);\n        bell += sin(point.x * 5.f) * sin(point.y * 5.) * sin(point.z * 5.) * 0.005;\n    }\n    \n    outInfo.d = bell;\n    outInfo.matId = bellMatId;\n    \n    // Start ray marching to avoid artifacts\n    outInfo.inVolume = (bell < Threshold * 3.);\n\n    // Bell content\n    float subBell = point.y < bellPosition.y - 0.35 ? \n        MaxFloat : \n        sdEllipsoid(point, bellPosition - vec3(0., 0.4, 0.),  bellSize / vec3(1.1, 2., 1.1));\n    \n    subBell -= 0.1 * sin(point.x * 3.) * sin(point.y * 10.)  * sin(point.z * 3.);\n    if((outInfo.inVolume && subBell < Threshold) || subBell < outInfo.d) {\n        outInfo.d = subBell;\n        outInfo.matId = subBellMatId;\n    }\n    \n    if(!outInfo.inVolume){\n        // Small arms\n        const float tentacleNumber = 13.;\n        vec3 tentaclePoint = point - bellPosition;\n\n        float bellRadius = bellSize.x - 0.3;\n        tentaclePoint = point - bellPosition;\n        for (float i = 0.; i < tentacleNumber; i++) {\n            vec3 currentTentacle = vec3(0.);\n            currentTentacle.x += bellRadius * cos((2. * Pi / tentacleNumber) * i);\n            currentTentacle.y -= 0.5;\n            currentTentacle.z += bellRadius * sin((2. * Pi / tentacleNumber) * i);\n\n            vec3 invBellDirection = normalize(tentaclePoint - bellPosition);\n\n            vec3 startingPoint = currentTentacle + vec3(0., 0.1, 0.);\n            vec3 middlePoint   = currentTentacle - vec3(0., 0.1, 0.);\n            vec3 finalPoint    = currentTentacle + 0.3 * vec3(invBellDirection.x, 0.6 * sin(iTime * 2.5) - 0.5, invBellDirection.z);\n            \n            // Based on Inigo Quilez's snail\n            vec4 tentacleBit = sdBezier(tentaclePoint, startingPoint, middlePoint, finalPoint);\n            float d3 = tentacleBit.x;\n            d3 -= 0.04 - 0.01*(tentacleBit.y);\n            float tentacle = d3;\n\n            tentacle = sminCubic(tentacle, sdSphere(tentaclePoint, finalPoint, 0.03), 0.1 );\n\n            if(tentacle < outInfo.d) {\n                outInfo.d = tentacle;\n                outInfo.matId = tentacleMatId;\n            }\n        }\n    }\n    \n    return outInfo;\n}\n\nRayClosestObjectInformation distanceFromScene(vec3 point){\n    return jellyFish(opRepLim(point, 4., vec3(1., 0., 1.)));\n}\n\n// Normal estimation by Inigo Quilez\n// Reference: https://iquilezles.org/articles/normalsSDF\nvec3 estimateNormal(vec3 p ) {\n    const float eps = 0.00001; // or some other value\n    const vec2 h = vec2(eps, 0.);\n    return normalize( vec3(distanceFromScene(p+h.xyy).d - distanceFromScene(p-h.xyy).d,\n                           distanceFromScene(p+h.yxy).d - distanceFromScene(p-h.yxy).d,\n                           distanceFromScene(p+h.yyx).d - distanceFromScene(p-h.yyx).d ) );\n}\n\nvec4 background(vec3 dir) {\n    vec3 topColor    = vec3(0., .1, .5);\n    vec3 bottomColor = vec3(0., 0., .2);\n    vec3 finalColor  = mix(bottomColor, topColor, vec3(dir.y) * 2. );\n    \n    // Encode background hit to perform outline computation\n    return vec4(finalColor, BackgroundEncodedValue);\n}\n\n// Phong shading\nvec4 illuminate(vec3 rayOrigin, vec3 point, vec3 normal, vec4 backgroundColor, PhongMaterial material) {\n    vec3 lightDirection = normalize(light.position - point);\n    vec3 viewerDirection = normalize(rayOrigin - point);\n\n    vec3 halfWay = normalize(viewerDirection + lightDirection);\n    float lightDotNormal = max(dot(lightDirection, normal), 0.);\n    \n    vec3 diffuse = light.color * material.diffuse * lightDotNormal;\n    float specularAngle = max(dot(normal, halfWay), 0.);\n    float scaledSpecular = pow(abs(specularAngle), material.shininess);\n    vec3 specular = light.color * material.specular * scaledSpecular;\n    return vec4(light.intensity * (light.color * material.ambient + diffuse + specular), 1.);\n}\n\nvec4 volumeRender(vec3 rayOrigin, vec3 point, vec3 normal, float distanceInVolume, vec4 backgroundColor, bool onSurface) {\n    vec3 lightDirection = light.position - point;\n    float lightDistance = length(lightDirection); \n    lightDirection = normalize(lightDirection);\n    \n    // Compute light path within the volume at the current point\n    RayClosestObjectInformation handler;\n    handler.inVolume = true;\n    float lightDistanceInVolume = 0.;\n    for(; lightDistanceInVolume < lightDistance && handler.inVolume; lightDistanceInVolume += StepSize) {\n        handler = distanceFromScene(lightDistanceInVolume * lightDirection + point);\n    }\n    \n    float surfaceWeight = max(1., float(onSurface) * 5.);\n    float transmittance = beerLambert(BellVolumeMaterial.coefficient, max(lightDistanceInVolume - distanceInVolume, 0.));\n    \n    vec3 volumeColor = transmittance * light.color * light.intensity * max(dot(lightDirection, normal), 0.);\n    vec3 opaqueColor = surfaceWeight * (1. - transmittance) * illuminate(rayOrigin, point, normal, backgroundColor, bellMat).rgb;\n    return vec4(volumeColor + opaqueColor, 1.);\n}\n\nfloat applyTexture(vec3 normal) {\n    float finalTexturevalue = 0.;\n    vec3 scaledNormal = normal * 1.6;\n    finalTexturevalue += sdBlobbyCross( scaledNormal.xz ) * 0.5;\n\n    const float TextureNumber = 3.;\n    for(float i = 0.; i < TextureNumber; i++) {\n        mat3 yRotation = yRotationMatrix(DEG2RAD(cos(iTime) * 190. + (360. / TextureNumber * i)));\n        scaledNormal = normal * yRotation;\n        if(scaledNormal.z + sin(iTime) * .3 < -.9) {\n            vec2 uv = ((scaledNormal * 1.8 + 1.) / 2.).xy;\n            finalTexturevalue += jfigTexture(uv) ? 1. : 0.;\n        }\n    }\n    \n    return finalTexturevalue;\n}\n\nvec4 shade(vec3 position, Ray ray, RayClosestObjectInformation objInfo, vec4 backgroundColor) {\n    vec3 normal = normalize(estimateNormal(position));\n    vec4 outputColor = backgroundColor;\n    \n    // Volume rendering\n    if(objInfo.matId == bellMatId) {\n        vec3 currentPosition = position;\n        float stepNumber = 0.;\n        bool refracted = false;\n        \n        for(float t = 0.; t < MaxDistanceInVolume && stepNumber++ < MaxSteps * 2.; ) {\n            currentPosition = position + t * ray.direction;\n            objInfo = distanceFromScene(currentPosition);\n            \n            if (objInfo.inVolume) {\n                if(!refracted) {\n                    ray.direction = normalize(refract(ray.direction, normal, 1.05));\n                    refracted = true;\n                }\n                \n                normal = normalize(estimateNormal(currentPosition));\n                \n                if(objInfo.matId == bellMatId) {\n                    float pointWeight = 0.035;\n                    \n                    bool onSurface = abs(objInfo.d) < 0.1;\n                    // Bell texturing\n                    if(abs(objInfo.d) < 0.06) {\n                        outputColor += applyTexture(normal);\n                        pointWeight *= 2.;\n                    }\n                    \n                    vec4 currentColor = volumeRender(ray.origin, currentPosition, normal, t, outputColor, onSurface);\n\n                    outputColor += pointWeight * currentColor;\n                    t += StepSize;\n                } \n                else {\n                    return 0.5 * outputColor + 0.5 * illuminate(ray.origin, currentPosition, normal, outputColor, subBellMat);\n                }\n            }\n            else {\n                t += objInfo.d;\n            }\n        }\n        return outputColor;\n        \n    }\n    else {\n        PhongMaterial material;\n        \n        if(objInfo.matId == tentacleMatId)\n            material = tentacleMat;\n        else if(objInfo.matId == bellMatId)\n            material = bellMat;\n        else if(objInfo.matId == subBellMatId)\n            material = subBellMat;\n            \n        // Opaque rendering\n        vec3 ro = position;\n        vec3 rd = normalize(position - light.position);\n\n        outputColor = (mix(outputColor, illuminate(ray.origin, position, normal, outputColor, material), 1. / length(ray.origin - position)));\n\n        return outputColor;\n    }\n}\n\nRay computeRay(vec2 fragmentCoordinates) {\n\tvec2 uv = (2. * ((fragmentCoordinates.xy) / iResolution.xy) - 1.);\n\n    // Pinhole model\n    vec3 pixelCamera = vec3(\n        uv.x * tan(DEG2RAD(90. / 2.)),\n        uv.y * tan((iResolution.y / iResolution.x) * DEG2RAD(90.) / 2.),\n        1.\n    );\n\n    vec3 target  = vec3(0.);\n    float xAngle = sin(iTime) * (20.);\n    float yAngle = cos(iTime) * (180.);\n    if( iMouse.z > 0.01) {\n        xAngle = iMouse.y;\n        yAngle = iMouse.x;\n    }\n    \n    Ray ray = Ray(vec3(0., .25, -4.), normalize(pixelCamera - target));\n\n    mat3 camRotation  = yRotationMatrix(DEG2RAD(yAngle));\n    camRotation      *= xRotationMatrix(DEG2RAD(xAngle));\n    ray.origin       *= camRotation;\n    ray.direction    *= camRotation;\n    \n    return ray;\n}\n\nvec4 render(vec2 fragmentCoordinates) {\n    Ray ray = computeRay(fragmentCoordinates);\n    \n    vec3 currentPosition = ray.origin;\n    float t              = StartingT;\n    float maxDistance    = StartingT + MaxDistance;\n    \n    bool  hit        = false;\n    float stepNumber = 0.;\n    float radius     = 0.;\n        \n    vec4 backgroundColor = background(ray.direction);\n    vec4 outputColor     = backgroundColor;\n    \n    RayClosestObjectInformation objInfo = RayClosestObjectInformation(MaxFloat, -1, false);\n    while (t < maxDistance && stepNumber++ < MaxSteps) {\n        currentPosition = ray.origin + t * ray.direction;\n        objInfo = distanceFromScene(currentPosition);\n        radius = abs(objInfo.d);\n        if(radius <= Threshold * t || objInfo.inVolume) {\n            hit = true;\n            break;\n        }\n        \n        t += radius;\n    }\n    \n    // Avoid to compute the shade function within the \n    if(hit) outputColor = shade(currentPosition, ray, objInfo, outputColor);\n    \n    // Based on https://www.shadertoy.com/view/MlXGzr\n    return vec4(mix(outputColor.xyz * 1.5, backgroundColor.xyz + .025, 1. - beerLambert(t * t, .08)), outputColor.w);\n}\n\nvoid mainImage( out vec4 fragmentColor, in vec2 fragmentCoordinates ) {\n    fragmentColor = render(fragmentCoordinates);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssG3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 99, 162, 162, 905], [907, 976, 1033, 1033, 1320], [1322, 1411, 1442, 1442, 2265], [2267, 2267, 2315, 2315, 2414], [2416, 2416, 2463, 2463, 2506], [2508, 2508, 2580, 2580, 2877], [2879, 3117, 3153, 3153, 3540]], "test": "untested"}
{"id": "fsdXzj", "name": "Sunrise and sunset in the clouds", "author": "lllcz", "description": "A simple sunrise and sunset animation that will be updated later", "tags": ["2d"], "likes": 1, "viewed": 254, "published": 3, "date": "1633534177", "time_retrieved": "2024-07-30T18:57:43.477284", "image_code": "vec2 g_random(vec2 ip){\n\treturn fract(sin(\n\t\tvec2(dot(ip,vec2(127.1,311.7)), dot(ip,vec2(269.5,183.3)))\n\t)* 44753.976967) *2. - 1.;\n}\n\nfloat g_noise(vec2 st){\n\tvec2 ip = floor(st);\n\tvec2 fp = fract(st);\n\n\tvec2 u = fp*fp*fp*(fp*(fp*6.-15.)+10.);//使用三次多项式进行插值\n\treturn mix(\n\t\tmix(dot(g_random(ip) , fp-vec2(0.,0.)) , dot(g_random(ip+vec2(1.,0.)) , fp-vec2(1.,0.)) ,u.x),\n\t\tmix(dot(g_random(ip+vec2(0.,1.)) , fp-vec2(0.,1.)) , dot(g_random(ip+vec2(1.,1.)) ,fp-vec2(1.,1.)) , u.x),\n\t\tu.y\n\t);\n}\n\n\nfloat circle(vec2 st, vec2 center){\n    return distance(st, center);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 beforeColor = vec4(1.0);\n  \n    uv.x -= abs(sin(iTime/4.0));\n    uv.y -= abs(sin(iTime/2.0))/1.5;\n    if(circle(uv, vec2(0,0)) <=0.15){\n        \n        beforeColor = vec4(1.000,smoothstep(0.566, 0.98, circle(uv, vec2(0,0))+0.69),0.3, 1.0);\n    } \n    uv -= 0.5;\n    \n \n    //To prevent clouds and the sun from moving together, they need a separate coordinate system\n    vec2 copy = fragCoord/iResolution.xy;\n    copy -= 0.5;\n    copy *= vec2(4.,4.);\n    copy += g_noise(copy*3.);\n    copy.x = sin(iTime/2.0);\n\n    \n    beforeColor += (g_noise(copy) -.5)*.19;\n    // Output to screen\n    fragColor = beforeColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 133], [135, 135, 158, 158, 510], [513, 513, 548, 548, 583], [586, 586, 643, 643, 1312]], "test": "untested"}
{"id": "sscXz2", "name": " Fab6 #inktober2021 \"spirit\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]", "tags": ["2d", "liquid", "short", "bottle", "spirit", "inktober2021"], "likes": 18, "viewed": 362, "published": 3, "date": "1633532021", "time_retrieved": "2024-07-30T18:57:44.695030", "image_code": "// bottle profile\n#define B(h) (  h > 1.02 ? -99. : h > 1. ? .1*R((h-1.)/.02) : h > .6 ? .1 \\\n              : h > .4 ? .1+.3*H(1.-(h-.4)/.2) : h > -.4 ? .4             \\\n              : h > -.5 ? .4*R((h+.4)/.1)  : -99.                         \\\n             )                                                           //\n#define H(x) ( (x)*(x)* ( 3. - 2.*(x) )  )                               //\n#define R(x)  sqrt(1.-(x)*(x))                                           //\n#define S smoothstep\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;\n    U.y += .3;\n    float x = abs(U.x), y = U.y,\n          p =  B(y), v = p - x,                              // dist to profile\n          w = B(y-.1) - x;                                   // offset version for bottom\n          v /= fwidth(v), w /= fwidth(w);                    // for AA\n    O = mix( S( -1.,1.,v )                                   // profile\n             * (   y > .8 ? vec4(.4,0,.2,1)                  // cork\n                 : y > .5 ? vec4(.9,.97,1,1)                 // air\n                 : pow( vec4(1,.5,.1,0), vec4(.7*R(x/p)) )   // juice\n               ),\n             vec4(.4,0,.2,1),                                // label\n             step(x,.3) *S(2./R.y,0.,abs(y-.05+.04*R(x/.3))-.17) \n           )\n       * (.5+.5*min(S( 0.,3.,abs(v-1.) ),S(-1.,1.,w+.4)) );  // thick glass\n    v = .5*p + U.x;  v /= fwidth(v);\n    if ( y > -.45 && y < 1.01) O += .8*S( 5.,0.,abs(v-1.) ); // reflect\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[495, 495, 531, 531, 1517]], "test": "untested"}
{"id": "sdcSz2", "name": "Single-pass Canny edge detection", "author": "iY0Yi", "description": "Canny edge detection.\nMouse for min/max thresholds.", "tags": ["sobel", "edge", "canny"], "likes": 27, "viewed": 1164, "published": 3, "date": "1633528889", "time_retrieved": "2024-07-30T18:57:45.628532", "image_code": "// ref: (in japanese)\n// https://imagingsolution.net/imaging/canny-edge-detector/\n#define tickness 4.\n\nfloat getAve(vec2 uv){\n    vec3 rgb = texture(iChannel0, uv).rgb;\n    vec3 lum = vec3(0.299, 0.587, 0.114);\n    return dot(lum, rgb);\n}\n\n// Detect edge.\nvec4 sobel(vec2 fragCoord, vec2 dir){\n    vec4 mous = iMouse/iResolution.xyxy*.1;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1./iResolution.xy;\n    float np = getAve(uv + (vec2(-1,+1) + dir ) * texel * tickness);\n    float zp = getAve(uv + (vec2( 0,+1) + dir ) * texel * tickness);\n    float pp = getAve(uv + (vec2(+1,+1) + dir ) * texel * tickness);\n    \n    float nz = getAve(uv + (vec2(-1, 0) + dir ) * texel * tickness);\n    // zz = 0\n    float pz = getAve(uv + (vec2(+1, 0) + dir ) * texel * tickness);\n    \n    float nn = getAve(uv + (vec2(-1,-1) + dir ) * texel * tickness);\n    float zn = getAve(uv + (vec2( 0,-1) + dir ) * texel * tickness);\n    float pn = getAve(uv + (vec2(+1,-1) + dir ) * texel * tickness);\n    \n    // np zp pp\n    // nz zz pz\n    // nn zn pn\n    \n    #if 0\n    float gx = (np*-1. + nz*-2. + nn*-1. + pp*1. + pz*2. + pn*1.);\n    float gy = (np*-1. + zp*-2. + pp*-1. + nn*1. + zn*2. + pn*1.);\n    #else\n    // https://www.shadertoy.com/view/Wds3Rl\n    float gx = (np*-3. + nz*-10. + nn*-3. + pp*3. + pz*10. + pn*3.);\n    float gy = (np*-3. + zp*-10. + pp*-3. + nn*3. + zn*10. + pn*3.);\n    #endif\n    \n    vec2 G = vec2(gx,gy);\n    \n    float grad = length(G);\n    \n    float angle = atan(G.y, G.x);\n    \n    return vec4(G, grad, angle);\n}\n\n// Make edge thinner.\nvec2 hysteresisThr(vec2 fragCoord, float mn, float mx){\n\n    vec4 edge = sobel(fragCoord, vec2(0));\n\n    vec2 dir = vec2(cos(edge.w), sin(edge.w));\n    dir *= vec2(-1,1); // rotate 90 degrees.\n    \n    vec4 edgep = sobel(fragCoord, dir);\n    vec4 edgen = sobel(fragCoord, -dir);\n\n    if(edge.z < edgep.z || edge.z < edgen.z ) edge.z = 0.;\n    \n    return vec2(\n        (edge.z > mn) ? edge.z : 0.,\n        (edge.z > mx) ? edge.z : 0.\n    );\n}\n\nfloat cannyEdge(vec2 fragCoord, float mn, float mx){\n\n    vec2 np = hysteresisThr(fragCoord + vec2(-1,+1), mn, mx);\n    vec2 zp = hysteresisThr(fragCoord + vec2( 0,+1), mn, mx);\n    vec2 pp = hysteresisThr(fragCoord + vec2(+1,+1), mn, mx);\n    \n    vec2 nz = hysteresisThr(fragCoord + vec2(-1, 0), mn, mx);\n    vec2 zz = hysteresisThr(fragCoord + vec2( 0, 0), mn, mx);\n    vec2 pz = hysteresisThr(fragCoord + vec2(+1, 0), mn, mx);\n    \n    vec2 nn = hysteresisThr(fragCoord + vec2(-1,-1), mn, mx);\n    vec2 zn = hysteresisThr(fragCoord + vec2( 0,-1), mn, mx);\n    vec2 pn = hysteresisThr(fragCoord + vec2(+1,-1), mn, mx);\n    \n    // np zp pp\n    // nz zz pz\n    // nn zn pn\n    //return min(1., step(1e-3, zz.x) * (zp.y + nz.y + pz.y + zn.y)*8.);\n    //return min(1., step(1e-3, zz.x) * (np.y + pp.y + nn.y + pn.y)*8.);\n    return min(1., step(1e-2, zz.x*8.) * smoothstep(.0, .3, np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y)*8.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 mous = iMouse/iResolution.xyxy*.1;\n    float edge = cannyEdge(fragCoord, mous.x*5., mous.y*30.);\n    \n    vec3 col = mix(vec3(0.875,0.835,0.749), vec3(0.145,0.118,0.055), 1.-edge);    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 125, 125, 238], [240, 256, 293, 293, 1538], [1540, 1562, 1617, 1617, 2004], [2006, 2006, 2058, 2058, 2948], [2950, 2950, 3006, 3006, 3233]], "test": "untested"}
{"id": "sscXRj", "name": "Facebook Time", "author": "dr2", "description": "Days not on Facebook", "tags": ["clock", "health", "freedom"], "likes": 9, "viewed": 308, "published": 3, "date": "1633510936", "time_retrieved": "2024-07-30T18:57:46.688698", "image_code": "// \"Facebook Time\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Days not on Facebook\n\n/*\n  Based on \"Corona Time\"\n\n  From original: Clock includes days since WHO declared Global Public Health\n  Emergency (hope the [local] day counter never overflows). \n\n  No less applicable here.\n*/\n\n#define txFnt iChannel0\n\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 HsvToRgb (vec3 c);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvoid DTimeSet (vec4 d);\nint GetTxChar (int _nc);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, vnCylIn;\nvec2 fntSize, qnFnt, qnTxt;\nfloat dstFar, tCur, rngBlk, bCylRad, bCylHt, dCylIn, dCylOut;\nint idTxt;\nconst float pi = 3.1415927;\n\nvoid CylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  vnCylIn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.) s = ro + dCylIn * rd;\n    else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylIn.xz = s.xz / bCylRad;\n    else if (srdy * ro.y < - bCylHt) {\n      dCylIn = - (srdy * ro.y + bCylHt) / abs (rd.y);\n      if (length (ro.xz + dCylIn * rd.xz) < bCylRad) vnCylIn.y = - srdy;\n      else dCylIn = dstFar;\n    } else dCylIn = dstFar;\n    if (dCylIn < dstFar) {\n      if (a > 0.) s = ro + dCylOut * rd;\n      else s.y = bCylHt;\n      if (abs (s.y) > bCylHt && srdy * ro.y < bCylHt)\n         dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n    }\n  }\n}\n\nfloat FontTexDf (vec2 p)\n{\n  vec3 tx;\n  ivec2 ip;\n  float d;\n  int ic;\n  ic = 0;\n  ip = ivec2 (floor (p));\n  if (ip.x == 0 && ip.y == 0) ic = GetTxChar (idTxt);\n  if (ic != 0) {\n    tx = texture (txFnt, mod ((vec2 (mod (float (ic), 16.),\n       15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n    qnFnt = vec2 (tx.r, - tx.g);\n    d = tx.b + 1. / 256.;\n  } else d = 1.;\n  return d;\n}\n\nvec3 RdNZero (vec3 rd)\n{\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  return rd;\n}\n\nfloat ObjRayT (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 srd, h;\n  float dHit, dLim, d;\n  RdNZero (rd);\n  srd = - sign (rd.xy);\n  rdi = 1. / abs (rd.xyz);\n  dHit = 0.;\n  dLim = rngBlk;\n  ro.xy /= fntSize.x;\n  rd.xy /= fntSize.x;\n  ro.xy += 0.5;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    h = rdi.xy * fract (srd * p.xy);\n    d = max (min (fntSize.x, 1.) * FontTexDf (p.xy), abs (p.z) - 0.5 * fntSize.y);\n    dHit += min (d, 0.01 + fntSize.x * min (h.x, h.y));\n    if (d < 0.0001 || dHit > dLim) break;\n  }\n  if (d >= 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  RdNZero (rd);\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    rngBlk = df - dn;\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float cRad;\n  cRad = 0.04;\n  q = p;\n  q.y = abs (q.y) - bCylHt + cRad;\n  return PrTorusDf (q.xzy, cRad, bCylRad - cRad);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n     Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 10. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return StarPat (rd, 12.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, qtTxt, tro, trd, trdd, q, qt, ds;\n  float dstTxt, dstBlk, dstObj, db, d, ang, angTxt, angRot, aTw, rad;\n  int idT;\n  fntSize = vec2 (1.7, 0.6);\n  dstTxt = dstFar;\n  tro = ro;\n  trd = rd;\n  rad = 6.;\n  bCylRad = rad + 0.4 * fntSize.x;\n  bCylHt = 1.4 * fntSize.y;\n  dstObj = ObjRay (ro, rd);\n  CylHit (ro, rd);\n  if (dCylIn < dstFar) {\n    angRot = 0.05 * pi * tCur;\n    aTw = angRot;\n    tro.xz = Rot2D (tro.xz, angRot);\n    trd.xz = Rot2D (trd.xz, angRot);\n    for (float k = 0.; k < 44.; k ++) {\n      idTxt = int (k);\n      ang = 2. * pi * (1. - k / 44.);\n      qt = - rad * vec3 (sin (ang + vec2 (0., 0.5 * pi)), 0.).xzy;\n      q = tro - qt;\n      q.xz = Rot2D (q.xz, ang);\n      q.yz = Rot2D (q.yz, ang + aTw);\n      trdd = trd;\n      trdd.xz = Rot2D (trdd.xz, ang);\n      trdd.yz = Rot2D (trdd.yz, ang + aTw);\n      db = BlkHit (q, trdd, fntSize.xxy * vec3 (0.5, 0.55, 0.55));\n      if (db < dstFar) {\n        d = db + ObjRayT (q + db * trdd, trdd);\n        if (d < dstTxt) {\n          dstTxt = d;\n          qtTxt = qt;\n          angTxt = ang;\n          qnTxt = qnFnt;\n          idT = idTxt;\n        }\n      }\n    }\n  }\n  if (min (dstTxt, dstObj) < dstFar) {\n    if (dstTxt < dstObj) {\n      tro += dstTxt * trd;\n      ds = tro - qtTxt;\n      ds.xz = Rot2D (ds.xz, angTxt);\n      ds.yz = Rot2D (ds.yz, angTxt + aTw);\n      col = HsvToRgb (vec3 (mod (0.05 * tCur + ((idT > 25) ? 0.5 : 0.), 1.), 1., 1.));\n      if (abs (ds.z) < 0.49 * fntSize.y) {\n        vn = normalize (vec3 (qnTxt, 0.00001));\n        col = mix (col, vec3 (1.), 0.7);\n      } else {\n        vn = vec3 (0., 0., sign (ds.z));\n      }\n      vn.yz = Rot2D (vn.yz, - angTxt - aTw);\n      vn.xz = Rot2D (vn.xz, - angRot - angTxt);\n      col = col * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      col = mix (col, BgCol (reflect (rd, vn)), 0.7 - 0.5 * abs (dot (rd, vn)));\n    } else if (dstObj < dstFar) {\n      vn = ObjNf (ro + dstObj * rd);\n      col = vec3 (0.5, 0.5, 0.6) * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n  } else col = BgCol (rd);\n  if (dCylIn < dstFar) {\n    col = mix (col,  vec3 (1.) * (0.2 + 0.8 * max (dot (ltDir, vnCylIn), 0.) +\n       0.5 * pow (max (dot (normalize (ltDir - rd), vnCylIn), 0.), 32.)), 0.2);\n    col = mix (col, BgCol (reflect (rd, vnCylIn)), 0.8 * pow (1. - abs (dot (rd, vnCylIn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.06 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., -0.3, -15.);\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n  dstFar = 100.;\n  DTimeSet (dateCur);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define C(c) c\n\n#define _SP    C(0x20)\n#define _EXCL  C(0x21)\n#define _QUOT  C(0x22)\n#define _NUM   C(0x23)\n#define _DOLLR C(0x24)\n#define _PCENT C(0x25)\n#define _AMP   C(0x26)\n#define _SQUOT C(0x27)\n#define _LPAR  C(0x28)\n#define _RPAR  C(0x29)\n#define _AST   C(0x2A)\n#define _PLUS  C(0x2B)\n#define _COMMA C(0x2C)\n#define _MINUS C(0x2D)\n#define _PER   C(0x2E)\n#define _SLASH C(0x2F)\n#define _0     C(0x30)\n#define _1     C(0x31)\n#define _2     C(0x32)\n#define _3     C(0x33)\n#define _4     C(0x34)\n#define _5     C(0x35)\n#define _6     C(0x36)\n#define _7     C(0x37)\n#define _8     C(0x38)\n#define _9     C(0x39)\n#define _COLON C(0x3A)\n#define _SEMI  C(0x3B)\n#define _LT    C(0x3C)\n#define _EQUAL C(0x3D)\n#define _GT    C(0x3E)\n#define _QUEST C(0x3F)\n#define _AT    C(0x40)\n#define _A     C(0x41)\n#define _B     C(0x42)\n#define _C     C(0x43)\n#define _D     C(0x44)\n#define _E     C(0x45)\n#define _F     C(0x46)\n#define _G     C(0x47)\n#define _H     C(0x48)\n#define _I     C(0x49)\n#define _J     C(0x4A)\n#define _K     C(0x4B)\n#define _L     C(0x4C)\n#define _M     C(0x4D)\n#define _N     C(0x4E)\n#define _O     C(0x4F)\n#define _P     C(0x50)\n#define _Q     C(0x51)\n#define _R     C(0x52)\n#define _S     C(0x53)\n#define _T     C(0x54)\n#define _U     C(0x55)\n#define _V     C(0x56)\n#define _W     C(0x57)\n#define _X     C(0x58)\n#define _Y     C(0x59)\n#define _Z     C(0x5A)\n#define _LSQB  C(0x5B)\n#define _BSLSH C(0x5C)\n#define _RSQB  C(0x5D)\n#define _CARET C(0x5E)\n#define _USCOR C(0x5F)\n#define _GRAVE C(0x60)\n#define _a     C(0x61)\n#define _b     C(0x62)\n#define _c     C(0x63)\n#define _d     C(0x64)\n#define _e     C(0x65)\n#define _f     C(0x66)\n#define _g     C(0x67)\n#define _h     C(0x68)\n#define _i     C(0x69)\n#define _j     C(0x6A)\n#define _k     C(0x6B)\n#define _l     C(0x6C)\n#define _m     C(0x6D)\n#define _n     C(0x6E)\n#define _o     C(0x6F)\n#define _p     C(0x70)\n#define _q     C(0x71)\n#define _r     C(0x72)\n#define _s     C(0x73)\n#define _t     C(0x74)\n#define _u     C(0x75)\n#define _v     C(0x76)\n#define _w     C(0x77)\n#define _x     C(0x78)\n#define _y     C(0x79)\n#define _z     C(0x7A)\n#define _LBRC  C(0x7B)\n#define _VBAR  C(0x7C)\n#define _RBRC  C(0x7D)\n#define _TILDE C(0x7E)\n\nivec3 MName (int i)\n{\n  ivec3 m;\n  if      (i == 0)  m = ivec3 (_J, _a, _n);\n  else if (i == 1)  m = ivec3 (_F, _e, _b);\n  else if (i == 2)  m = ivec3 (_M, _a, _r);\n  else if (i == 3)  m = ivec3 (_A, _p, _r);\n  else if (i == 4)  m = ivec3 (_M, _a, _y);\n  else if (i == 5)  m = ivec3 (_J, _u, _n);\n  else if (i == 6)  m = ivec3 (_J, _u, _l);\n  else if (i == 7)  m = ivec3 (_A, _u, _g);\n  else if (i == 8)  m = ivec3 (_S, _e, _p);\n  else if (i == 9)  m = ivec3 (_O, _c, _t);\n  else if (i == 10) m = ivec3 (_N, _o, _v);\n  else if (i == 11) m = ivec3 (_D, _e, _c);\n  return m;\n}\n\nivec3 DName (int i)\n{\n  ivec3 d;\n  if      (i == 0)  d = ivec3 (_S, _u, _n);\n  else if (i == 1)  d = ivec3 (_M, _o, _n);\n  else if (i == 2)  d = ivec3 (_T, _u, _e);\n  else if (i == 3)  d = ivec3 (_W, _e, _d);\n  else if (i == 4)  d = ivec3 (_T, _h, _u);\n  else if (i == 5)  d = ivec3 (_F, _r, _i);\n  else if (i == 6)  d = ivec3 (_S, _a, _t);\n  return d;\n}\n\nint DWk (ivec3 ymd) // \"Zeller's congruence\"\n{\n  ivec2 cy;\n  int s;\n  ymd.y += 1;\n  if (ymd.y <= 2) {\n    ymd.x -= 1;\n    ymd.y += 12;\n  }\n  cy.x = ymd.x / 100;\n  cy.y = ymd.x - 100 * cy.x;\n  s = ymd.z + 13 * (ymd.y + 1) / 5 + cy.y + cy.y / 4 + cy.x / 4 + 5 * cy.x;\n  s -= 7 * (s / 7) - 6;\n  s -= 7 * (s / 7);\n  return s;\n}\n\nint DElaps (ivec3 ymd) // Days from 1970-01-01 (http://howardhinnant.github.io/date_algorithms.html)\n{\n  int era, yoe, doy, doe;\n  if (ymd.y <= 2) -- ymd.x;\n  era = (ymd.x >= 0 ? ymd.x : ymd.x - 399) / 400;\n  yoe = (ymd.x - era * 400);\n  doy = (153 * (ymd.y + ((ymd.y > 2) ? -3 : 9)) + 2) / 5 + ymd.z - 1;  // [0-365]\n  doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;  // [0-146096]\n  return era * 146097 - 719468 + doe;\n}\n\n#define DIG2(v) _0 + ivec2 (vec2 (floor ((v) / 10.), mod ((v), 10.)))\n#define T(c) _ic = (_nc -- == 0) ? (c) : _ic;\n#define T2(v) T(v.x) T(v.y)\n#define T3(v) T(v.x) T(v.y) T(v.z)\n\nivec3 inm[2];\nivec2 idt[6], icn[2];\n\nvoid DTimeSet (vec4 d)\n{\n  float nd;\n  int yr, mo, da;\n  idt[0] = DIG2 (floor (d.x / 100.));\n  idt[1] = DIG2 (mod (d.x, 100.));\n  idt[2] = DIG2 (d.z);\n  idt[3] = DIG2 (floor (d.w / 3600.));\n  idt[4] = DIG2 (floor (mod (d.w, 3600.) / 60.));\n  idt[5] = DIG2 (floor (mod (d.w, 60.)));\n  inm[0] = MName (int (d.y));\n  inm[1] = DName (DWk (ivec3 (d.xyz)));\n  nd = mod (float (DElaps (ivec3 (d.x, d.y + 1., d.z)) - DElaps (ivec3 (2004, 2, 4))), 1e4);\n  icn[0] = DIG2 (mod (floor (nd / 100.), 100.));\n  icn[1] = DIG2 (mod (nd, 100.));\n}\n\nint GetTxChar (int _nc)\n{\n  int _ic;\n  _ic = 0;\n  T(_SP) T3(inm[1]) T(_SP) T2(idt[2]) T(_MINUS) T3(inm[0]) T(_MINUS)\n  T2(idt[0]) T2(idt[1]) T(_SP) T2(idt[3]) T(_COLON) T2(idt[4]) T(_COLON) T2(idt[5])\n  T(_SP) T(_F) T(_a) T(_c) T(_e) T(_b) T(_o)  T(_o) T(_k) T(_SP) T(_D) T(_a) T(_y) T(_COLON)\n  T2(icn[0]) T2(icn[1]) T(_SP)\n  return _ic;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[772, 772, 804, 804, 1744], [1746, 1746, 1772, 1772, 2155], [2157, 2157, 2181, 2181, 2292], [2294, 2294, 2328, 2328, 2870], [2872, 2872, 2917, 2917, 3180], [3182, 3182, 3204, 3204, 3339], [3341, 3341, 3374, 3374, 3550], [3552, 3552, 3573, 3573, 3823], [3825, 3825, 3860, 3860, 4313], [4315, 4315, 4337, 4337, 4367], [4369, 4369, 4404, 4404, 6898], [6900, 6900, 6956, 6956, 7580], [7582, 7582, 7628, 7628, 7685], [7687, 7687, 7711, 7711, 7828], [7830, 7830, 7852, 7852, 7890], [7892, 7892, 7914, 7914, 7952], [7954, 7954, 7990, 7990, 8196], [8198, 8198, 8228, 8228, 8341], [10545, 10545, 10566, 10566, 11119], [11121, 11121, 11142, 11142, 11475], [11477, 11477, 11523, 11523, 11800], [11802, 11802, 11904, 11904, 12221], [12440, 12440, 12464, 12464, 12969], [13345, 13345, 13369, 13369, 13481], [13483, 13483, 13508, 13508, 13694], [13696, 13696, 13717, 13717, 13872]], "test": "untested"}
{"id": "7dcXRj", "name": "Lazy edge detection", "author": "iY0Yi", "description": "I want Canny, but I've been lazy.\nThere is no correct algorithm here.", "tags": ["edge", "sobebe"], "likes": 9, "viewed": 454, "published": 3, "date": "1633510367", "time_retrieved": "2024-07-30T18:57:47.688026", "image_code": "float thre = .025;\n\nfloat sobebe(vec2 fragCoord, vec2 xoff, vec2 yoff){\n    float gxn = texture(iChannel0, (fragCoord+xoff)/iResolution.xy).r;\n    float gxp = texture(iChannel0, (fragCoord-xoff)/iResolution.xy).r;\n    float gyn = texture(iChannel0, (fragCoord+yoff)/iResolution.xy).r;\n    float gyp = texture(iChannel0, (fragCoord-yoff)/iResolution.xy).r;\n    float gx = gxn-gxp;\n    float gy = gyn-gyp;\n    float grad = sqrt(gx*gx + gy*gy);\n    return grad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float edge = sobebe(fragCoord, vec2(1,0), vec2(0,1));\n    float a = sobebe(fragCoord, vec2(1,1), vec2(-1,1));\n\n    if(edge<a) edge *= 0.6;\n    if(edge<thre) edge = .0;\n    edge = smoothstep(.0, .1, edge);\n    \n    vec3 col = mix(vec3(0.875,0.835,0.749), vec3(0.102,0.082,0.039), 1.-edge);    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 71, 71, 460], [462, 462, 519, 519, 890]], "test": "untested"}
{"id": "NscSzB", "name": "Radiant Ember Orb", "author": "Tater", "description": "My first experiments with refraction. pretty pleased with how it turned out. \n\nuse mouse to zoom out", "tags": ["raymarching", "waves", "refraction", "particles", "orb"], "likes": 31, "viewed": 768, "published": 3, "date": "1633500478", "time_retrieved": "2024-07-30T18:57:48.446997", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n#define elon(p,h) (p-clamp(p,-h,h))\n\n//Enable exit ray\n#define refraction2\n\n\n//iq octohedron\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat torus (vec3 p, vec2 b){\n  vec2 d = vec2(length(p.yz)-b.x,p.x);\n  return length(d)-b.y;\n}\nfloat torus2 (vec3 p, vec2 b){\n  vec2 d = vec2(length(p.yx)-b.x,p.z);\n  return length(d)-b.y;\n}\nfloat glow = 0.;\nfloat glow2 = 0.;\n\nbool inside = false;\nvec2 map(vec3 p){\n    float t= iTime;\n    vec3 po2 = p;\n    vec2 a = vec2(1.);\n    vec2 b = vec2(2.);\n    //Swing\n    p.y-=7.0;\n    p.xy*=rot(sin(t*2.0*pi/3.)*0.28);\n    p.y+=7.0;\n    vec3 po = p;\n    //Glass Displacment\n    p+=t*0.2;\n    float dis = sin(p.x*5.)*sin(p.y*5.)*sin(p.z*5.)*0.02;\n    p = po;\n    //Glass ball\n    a.x = length(p)-1.0+dis;\n    glow2+=0.5/(0.5+a.x*a.x);\n    a.x*=0.85;\n    if(inside){\n        //Octohedron\n        p.xz*=rot(t*0.8);\n        b.x = oct(p,0.3)-0.02;\n        \n        //Mini Octohedron\n        float s = sign(p.x*p.y*p.z);\n        p = abs(p)-0.25+sin(t)*0.05;\n        p.xz*=rot(-t*s*2.0);\n        b.x = min(b.x, oct(p,0.05)-0.01);\n\n        p = po;\n        //Particles\n        p.xz*=rot(t);\n        p.y-=t;\n        float m = 0.5;\n        vec3 id = floor(p/m)-0.5;\n        p.y+=sin(id.x*id.z)*4.0;\n\n        p = pmod(p,vec3(m));\n        b.x*=0.9;\n        b.x = min(b.x,length(p));\n\n        b.x = max(a.x,b.x);\n        glow+=0.005/(0.001+b.x);\n\n        a.x = max(a.x,-b.x);\n\n        a=(abs(a.x)<abs(b.x))?a:b;\n    }\n    //chain\n    b.y = 3.0;\n    float scl = 0.6;\n    float m2 = 1.5*scl;\n    po.y-=7.5*scl;\n    po.xz*=rot(t*0.8);\n    p = po;\n\n    p.y = pmod(max(p.y,-m2*4.),m2);\n    p.y = elon(p.y,0.3*scl);\n    b.x = torus(p,vec2(0.2,0.1)*scl);\n    \n    p = po;\n    p.y+=0.75*scl;\n    p.y = pmod(max(p.y,-m2*4.),m2);\n    p.y = elon(p.y,0.3*scl);\n    b.x = min(b.x,torus2(p,vec2(0.2,0.1)*scl));\n    \n    a=(abs(a.x)<abs(b.x))?a:b;\n    \n    if(!inside){\n        //Background\n        b.y = 4.0;\n        p = po2;\n        //technique idea taken from yonatan\n        for(float s = 1.; s<10.; s/=.55){\n            p.xz*=rot(s);\n            p.y+=abs(dot(sin(p.xz*s+t*0.8)/s,vec2(0.15)));\n            p.y+=(dot(sin(p.xz*s+t*0.4+pi/2.)/s,vec2(0.15)));\n        }\n        b.x = p.y+1.3;\n        b.x*=0.7;\n\n        b.x = max(b.x,(length(p)-9.0));\n        a=(a.x<b.x)?a:b;\n    }\n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.001,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n#define MDIST 50.0\nvec2 march(vec3 ro, vec3 rd, int steps){\n    float dO = 0.;\n    for(int i = 0; i<steps; i++){\n        vec3 p = ro+rd*dO;\n        vec2 d = map(p);\n        dO+=abs(d.x);\n        if(dO>MDIST){\n            return vec2(dO,-1.);\n        }\n        if(abs(d.x)<0.0001||i==steps-1){\n            return vec2(dO,d.y);\n        }\n    }\n}\n\nvec3 colorI(vec3 ro, vec3 rd, float dO, float mat){\n    vec3 col = vec3(0);\n    vec3 p = ro+rd*dO;\n    vec3 n = norm(p);\n \n    \n    vec3 ld = normalize(vec3(1));\n    vec3 h = normalize(ld-rd);\n    float ndotl = abs(dot( -rd, n ));\n    float rim = pow(1.0-ndotl, 5.0);\n    float spec = pow(max(dot(n,h),0.0),5.0);\n    \n    \n    vec3 bg = vec3(0.3);\n    if(mat==1.0) col = bg;\n    \n    col+=rim;\n    \n    float dens = 0.1;\n    vec3 gemCol = vec3(0.310,0.004,0.396);\n    vec3 coloredDens = (1.-log(gemCol))*dens;\n    vec3 optDist = exp(-dO*coloredDens);\n    \n    //float optDist = exp(-dO*dens);\n    col = mix(gemCol,col,optDist);\n\n    col = col*optDist*gemCol;\n    \n    if(mat==2.0)glow*=rim;\n    col+=clamp(glow*0.5,0.,2.0)*vec3(0.886,0.376,0.129);\n    \n    \n    return col;\n}\nbool refracted = false;\nvec3 colorO(vec3 ro, vec3 rd, float dO, float mat){\n    vec3 col = vec3(0);\n    vec3 p = ro+rd*dO;\n    vec3 n = norm(p);\n    vec3 ld = normalize(vec3(1));\n    vec3 h = normalize(ld-rd);\n    vec3 r = reflect(rd,n);\n    float ndotl = abs(dot( -rd, n ));\n    float rim = pow(1.0-ndotl, 3.0);\n    float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    \n    vec3 bg = vec3(0.);\n    col = mix(col,bg,1.0);\n    //col+=clamp(glow*0.3,0.,0.8)*vec3(0.886,0.376,0.129);\n    if(dO<MDIST&&mat!=4.0){\n        col+=pow(spec,4.0)*3.0*vec3(1,0,0);\n        col+=rim*5.0;\n    }\n    \n    col+=clamp(glow2*0.03,0.,2.0)*vec3(0.886,0.376,0.129);\n    if(refracted) col=glow2*rim*vec3(0.886,0.376,0.129)*0.1;\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0);\n    m.y+=0.1;\n    vec3 ro = vec3(0,0.5+m.y*5.0,-4.0-m.y*10.0);\n    \n    //ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    \n    vec3 lk = vec3(0,0.3,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.99+uv.x*r+uv.y*cross(f,r));\n    vec2 dO = vec2(0);\n    vec3 rdo = rd;\n    //Index of Refraction\n    float ior = 1.4;\n    \n    dO = march(ro,rd,170);\n    vec3 p = ro+rd*dO.x;\n    //Yeah this lighting setup is janky but it looks better than how I intended it\n    //so I'm keeping it \n    col = colorO(ro,rd,dO.x,dO.y); //Color the outside\n    \n    //If hit the glass then march into it and color the inside\n    if(dO.y==1.0||dO.y==3.0){\n        inside = true; //optimize which geometry to check\n        glow = 0.;\n        ro = p;\n        vec3 n = norm(p);\n        ro-=n*0.05;\n        rd = refract(rd,n,1./ior);\n        if(dO.y==1.0)dO = march(ro,rd,90);\n        col = mix(col,colorI(ro,rd,dO.x,dO.y),0.9);\n        \n        //attempted reflection on the surface, might re-visit\n        /* \n        inside = false; //optimize which geometry to check\n        glow = 0.;\n        glow2 = 0.;\n        vec2 dO2 = vec2(0);\n        dO2 = march(p+n*0.05,reflect(rd,n),90);\n        refracted = true;\n        vec3 col2 = colorO(ro,rd,dO2.x,dO2.y);\n        float fres = pow(1.0-abs(dot(-rdo, n)),1.0);\n        col+=col2*fres;\n        */\n\n    #ifdef refraction2\n        if(dO.y==1.0){\n            inside = false; //optimize which geometry to check\n            refracted = true; //janky fix to make the background more defined\n            p =ro+rd*dO.x;\n            glow = 0.;\n            glow2 = 0.;\n            ro = p;\n            n = norm(p);\n            ro += n*0.05;\n            vec3 ref = refract(rd,-n,ior);\n            if(ref == vec3(0)) rd = reflect(rd,-n);\n            else rd = ref;\n            \n            //not accurate but maybe more visually apealing ray direction\n            //rd = rdo; \n            \n            dO = march(ro,rd,40);\n            \n            col = mix(col,colorO(ro,rd,dO.x,dO.y),0.1);    \n        }\n    #endif     \n\n    }\n\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 205, 234, 234, 514], [516, 516, 542, 542, 601], [603, 603, 632, 632, 697], [698, 698, 728, 728, 793], [851, 851, 868, 868, 2767], [2769, 2769, 2787, 2787, 2915], [2935, 2935, 2975, 2975, 3259], [3261, 3261, 3312, 3312, 4036], [4061, 4061, 4112, 4112, 4758], [4759, 4759, 4814, 4814, 7083]], "test": "untested"}
{"id": "NscSzj", "name": "Diffusion Interpolation", "author": "paniq", "description": "interpolating values using the inverse square law", "tags": ["diffusion", "interpolation"], "likes": 12, "viewed": 392, "published": 3, "date": "1633476279", "time_retrieved": "2024-07-30T18:57:49.467269", "image_code": "const float tau = 6.283185;\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLine(in vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa-h*ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    const int N = 3;\n    vec3 result = vec3(0.0);\n    float weight = 0.0;\n    for (int i = 0; i < N; ++i) {\n        float x = float(i)/float(N);\n        vec3 c = hue(x - 0.1);\n        float a = x * tau * 0.5;\n        vec2 q = vec2(cos(a),sin(a))*0.8;\n        float d = sdLine(uv, -q, q);\n        float w = 1.0 / (pow(d, 2.0));\n        result += c * w;\n        weight += w;\n    }\n\n    fragColor = vec4(pow(result / weight,vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscSzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 50, 50, 157], [159, 208, 249, 249, 370], [372, 372, 429, 479, 1017]], "test": "untested"}
{"id": "sdtXzS", "name": "pohl's fractals", "author": "pohl", "description": "It's pretty simple for the moment, but I'll improve on it soon enough, I want to add a few more fractals, and controls with the mouse.", "tags": ["fractal", "mandelbrot", "zoom", "dynamic"], "likes": 6, "viewed": 337, "published": 3, "date": "1633458015", "time_retrieved": "2024-07-30T18:57:50.618192", "image_code": "vec3 hsv_to_rgb( in float hue, in float sat, in float val )\n{\n    float chroma = val * sat;\n    float mini = val - chroma;\n    float tmp = chroma * (1.0 - abs(mod(hue / 60.0, 2.0) - 1.0));\n    \n    if (hue >= 0.0 && hue < 60.0)\n        return vec3(chroma + mini, tmp + mini, mini);\n    else if (hue >= 60.0 && hue < 120.0)\n\t\treturn vec3(tmp + mini, chroma + mini, mini);\n\telse if (hue >= 120.0 && hue < 180.0)\n\t\treturn vec3(mini, chroma + mini, tmp + mini);\n\telse if (hue >= 180.0 && hue < 240.0)\n\t\treturn vec3(mini, tmp + mini, chroma + mini);\n\telse if (hue >= 240.0 && hue < 300.0)\n\t\treturn vec3(tmp + mini, mini, chroma + mini);\n\telse if (hue >= 300.0 && hue < 360.0)\n\t\treturn vec3(chroma + mini, mini, tmp + mini);\n\telse\n\t\treturn vec3(mini, mini, mini);\n}\n\n\nvec2 get_world_coord(in vec2 pixel_coord, in vec2 screen_coord, in vec2 screen_size)\n{\n    vec2 result;\n    \n    result.x = screen_coord.x + (pixel_coord.x * screen_size.x) - screen_size.x / 2.0;\n    result.y = screen_coord.y + (pixel_coord.y * screen_size.y) - screen_size.y / 2.0;\n    return result;\n}\n\nfloat get_percentage(vec2 world_coord, float max_iterations)\n{\n    vec2 z = world_coord;\n    vec2 tmp;\n    int  current_count = 0;\n    \n    while (z.x * z.x + z.y * z.y <= 4.0 && current_count < int(max_iterations))\n    {\n        z = glynn_run(z, vec2(-0.2, 0.0));\n        current_count++;\n    }\n    if (current_count == int(max_iterations))\n        return (-1.0);\n    return (float(current_count) / max_iterations);\n}\n\n/*float get_percentage(vec2 world_coord, float max_iterations)\n{\n    vec2 z = vec2(0);\n    vec2 tmp;\n    int  current_count = 0;\n    \n    while (z.x * z.x + z.y * z.y <= 4.0 && current_count < int(max_iterations))\n    {\n        tmp.x = z.x * z.x - z.y * z.y + world_coord.x;\n        tmp.y = z.x * z.y * 2.0 + world_coord.y;\n        z = tmp;\n        current_count++;\n    }\n    if (current_count == int(max_iterations))\n        return (-1.0);\n    return (float(current_count) / max_iterations);\n}*/\n\nvec3 get_color(in float percentage, in float saturation, in float value)\n{\n    if (percentage == -1.0)\n        return vec3(0);\n    return hsv_to_rgb(percentage * 360.0, saturation, value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time_percent = cos(iTime / 4.0) / 2.0 + 0.5;\n    float init_iterations = 10.0;\n    float goal_iterations = 200.0;\n    float curr_iterations = mix(goal_iterations, init_iterations, time_percent);;\n    float init_screen_width = 3.8;\n    float goal_screen_width = 0.5;\n    float curr_screen_width = mix(goal_screen_width, init_screen_width, time_percent);\n    vec2  init_screen_coord = vec2(.25, 0.0);\n    vec2  goal_screen_coord = vec2(.25, .5);\n    vec2  curr_screen_coord = mix(goal_screen_coord, init_screen_coord, time_percent);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pixel_coord = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.y / iResolution.x;\n    \n    vec2 screen_width = vec2(curr_screen_width, curr_screen_width * aspect_ratio);\n    \n    vec2 world_coord = get_world_coord(pixel_coord, curr_screen_coord, screen_width);\n\n    float percentage = get_percentage(world_coord, curr_iterations);\n    \n    vec3 color = get_color(percentage, 1.0, 1.0);\n    \n    // Time varying pixel color\n    //vec3 col = vec3(0.5 + 0.5 * cos(iTime), .5, 0);\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "/* complex math functions */\n\nvec2 cx_sqrt(vec2 a) {\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nfloat cx_mag(in vec2 c) {\n    return sqrt(c.x * c.x + c.y * c.y);\n}\n\nvec2 cx_mul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 cx_pow(in vec2 c, int p) {\n    vec2 tmp = vec2(1.0,0.0) ;\n    for (int i = 0; i < p; ++i) {\n        c = cx_mul(tmp, c);\n    }\n    return c;\n}\n\nvec2 glynn_run(in vec2 old_z, in vec2 julia)\n{\n    vec2 new_z = cx_mul(old_z, cx_sqrt(old_z)) + julia;\n    return new_z;\n}\n\nvec2 julia_run(in vec2 old_z, in vec2 julia)\n{\n    vec2 new_z = cx_pow(old_z, 2) + julia;\n    return new_z;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 759], [762, 762, 848, 848, 1065], [1985, 1985, 2059, 2059, 2175], [2177, 2177, 2234, 2234, 3390]], "test": "untested"}
{"id": "7dtXRS", "name": "Image switching effects", "author": "lllcz", "description": "Some pictures toggle effects and color transformations", "tags": ["2l"], "likes": 2, "viewed": 213, "published": 3, "date": "1633455048", "time_retrieved": "2024-07-30T18:57:51.381152", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv);\n    uv -= 0.5;\n    uv.y = sin(iTime);\n    vec4 oneVec = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 zeroVec = vec4(0.0);\n    \n    vec4 fragColor2 = color;\n\n        \n    vec4 a = color*(1.0 - mod(length(uv),1.0));\n    fragColor = vec4(a[1]*sin(uv.x)+0.3, a[0]*sin(uv.x)+0.2, a[2]*(1.0 - sin(iTime)), a[3]);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 437]], "test": "untested"}
{"id": "sdcXzB", "name": "multicamera view", "author": "FabriceNeyret2", "description": "interpolating between several cameras depending of the screen location.\nIn this example, just changing the camera height with U.y while looking at (0,0,0).\nMouse.x : range of camera change\nMouse.y : distance\ntry commented variants ;-)", "tags": ["raymarching", "camera", "distorsion", "short", "falseperspective"], "likes": 13, "viewed": 407, "published": 3, "date": "1633449966", "time_retrieved": "2024-07-30T18:57:52.130149", "image_code": "#define rot(a)        mat2(cos(a),sin(a),-sin(a),cos(a))  // rotation                  \n//#define fwidth(v)   sqrt( dFdx(v)*dFdx(v) + dFdy(v)*dFdy(v) )                 \n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R =  iResolution.xy, \n          U = ( 2.*u - R ) / R.y,\n          M = iMouse.xy!=vec2(0) ? 2.*iMouse.xy/R - 1. : vec2(sin(iTime),0);\n    vec3  V,\n          D = normalize(vec3(U, 1)),             // ray direction\n          p = vec3(0,1,-1),                      // ray start \n          L = vec3(0);                           // lookat\n          \n // p.x += M.x*U.x; p.xz /=length(p.xz);         // Xcam changes with U.x\n // p.x += M.x*U.y;                              // Xcam changes with U.y\n    p.y += M.x*U.y;                              // Ycam changes with U.y\n // p.xz*= rot(M.x*(.5+.5*U.y));                 // XZcam rotate with U.y\n // p.y += M.x*U.x;                              // Ycam changes with U.x\n    p *= 1.+M.y;                                 // Zoom\n    \n    V = L - p;                                   // D from Lookat\n    float phi = atan( V.y, length(V.xz) ),\n          theta = atan(V.x,V.z);   \n    D.yz *= rot(phi); D.xz *= rot(theta); \n        \n    \n    float d = -p.y/D.y;                          // intersect plane\n    if (d<0.) { O-=O; return; }\n    p += d* D;\n    \n    O = 6.28*vec4(1,2,4,0);                      // color scheme (checker texture with AA )\n    O = sin(O*p.x) * sin(O*p.z);\n    O = .5 + .5* O/fwidth(O)  * smoothstep(1.,0.,length(fwidth(p.xz)));\n                              // * smoothstep(0.,-5.,log2(fwidth(p.z))); // AA at horizon\n    p = abs(p); if (min(p.x,p.z)>.5) O = O.rrrr; // B&W out of [-1,1]²\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 206, 206, 1676]], "test": "untested"}
{"id": "sd3XzS", "name": "Chiptune-LSD", "author": "klk", "description": "Something vertiginous", "tags": ["sound"], "likes": 9, "viewed": 491, "published": 3, "date": "1633435823", "time_retrieved": "2024-07-30T18:57:52.915051", "image_code": "// Fork of \"Chiptune-118366712\" by klk. https://shadertoy.com/view/3sjcWm\n// 2021-10-05 12:09:12\n\n// Fork of \"Waterdrops song\" by None. https://shadertoy.com/view/-1\n// 2020-04-13 11:07:43\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n\n    float beat=(1024./SND_HZ)/4./.68;\n    float time=trunc(iTime/beat)*beat+uv.x/64.;\n    \n    float vol=0.;\n    vec2 music=tune(time);\n    \n    col+=vec3(.2,.5,1)*\n        clamp\n        (1.0-\n         abs(iResolution.y/2.0-fragCoord.y)+abs(music.x)*iResolution.y/2.0\n         ,0.0,1.0);\n    col+=vec3(1,.8,0)*\n        clamp\n        (1.0-\n         abs(iResolution.y/2.0-fragCoord.y)+abs(music.y)*iResolution.y/2.0\n         ,0.0,1.0);\n\t\n    col=clamp(col,vec3(0.),vec3(1.));\n\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define M_PI 3.141592\n#define SND_HZ 48000.\n\nfloat s(float t)\n{\n    //return 0.;\n    //return t<.5?-.25:.25;\n    return abs(fract(t-.25)-.5)-.25;\n\t//return sin(t*2.*M_PI)*.25;\n}\n\nfloat s1(float t)\n{\n\tif(t<.2)\n    {\n        t/=.2;\n        //return t<.5?-.25:.25;\n        return abs(fract(t-.25)-.5)-.25;\n        return sin(t*2.*M_PI)*.25;\n    }\n\treturn 0.;\n}\n\nint l1a[16]=int[16](0,8,6,7,6,0,4,3,5,6,6,0,2,1,2,1);\nint l1b[16]=int[16](0,1,2,0,4,2,1,0,1,2,0,3,4,2,0,0);\nint l2a[16]=int[16](0,1,0,2,0,3,0,1,0,2,0,3,0,1,2,0);\nint l2b[16]=int[16](2,4,3,2,1,4,2,3,2,4,1,2,3,3,2,6);\n\nfloat sndVal(float ft, float f)\n{\n//    original oneliners\n//\tint i1=(t*(\"0867604356602121\"[(t>>12)&15]-'0')*(\"0120421012034200\"[(t>>16)&15]-'0'));\n//\tint i2=(t*(\"0102030102030120\"[(t>>12)&15]-'0')*(\"2432142624123326\"[(t>>17)&15]-'0'));\n    int idx1=int(ft/4096. )&15;\n    int idx2=int(ft/65536.)&15;\n    int idx3=int(ft/65536./2.)&15;\n\n    float i1=ft*float(l1a[idx1]*l1b[idx2])*f;\n\tfloat i2=ft*float(l2a[idx1]*l2b[idx3]*4)*f;\n    float w=(1.-fract(ft/4096.));\n\n    return (\n        s(mod(i1,128.)/128.)*w*w\n        +s(mod(i1,256.)/256.)*(1.-w)*w*2.\n        +s1(mod(i2,2048.)/2048.)*.5*w\n    )\n    \n    ;\n}\n\nvec2 tune00(float time,float f)\n{\n    vec2 val=vec2(0);\n    float vib=time*M_PI/2.;\n    val.x=sndVal((time*SND_HZ+sin(vib)*250.),f);\n    val.y=sndVal((time*SND_HZ-sin(vib)*250.),f);\n    return val;\n}\n\n\nconst float delay=1024.*8./SND_HZ/4.;\n\nvec2 tune0(float time)\n{\n    vec2 val=vec2(0.);\n\n    for(float ex=0.;ex<=4.1;ex+=1.)\n    {\n        val+=pow(.9,ex)*tune00(time-ex*delay*4.,pow(.5,ex/4.));\n    }\n    return val;\n}\n\nvec2 tune(float time)\n{\n    time*=.68*.5;\n    // synchronize echo with beats\n    float echomin=0.75;\n    vec2 val=tune0(time);\n    //val=vec2(0.);\n    //if(false)\n    for(float ex=1.;ex<=8.1;ex+=1.)\n    {\n        val+=0.25*pow(echomin,ex)*tune0(time-ex*delay);\n    }\n    //if(false)\n    return val;\n}", "sound_code": "vec2 mainSound( in int samp, float time )\n{\n\treturn tune(time);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3XzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 247, 247, 827]], "test": "untested"}
{"id": "sstSW7", "name": "The little grid that could", "author": "krh", "description": "WIP", "tags": ["grid"], "likes": 3, "viewed": 247, "published": 3, "date": "1633424377", "time_retrieved": "2024-07-30T18:57:53.674021", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.y = iResolution.y - fragCoord.y;\n    vec2 size = vec2(64.0, 80.0);    \n    vec2 cell = floor(fragCoord / size);\n    vec2 s = fragCoord /size - cell;\n    fragCoord = cell * size;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col.rgb += s.xxx * s.yyy;\n    \n    s = floor(s * size);\n    if (s.x == 0.0  || s.y == 0.0)\n        col.rgb = vec3(0.0);\n    else if (s.x == 10.0 || s.y == 10.0)\n        col.rgb = vec3(0.0);\n    else if (s.x < 10.0 || s.y < 10.0)\n        col.rgb = vec3(0.5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstSW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 725]], "test": "untested"}
{"id": "fscXzS", "name": "rotating 2d area lights lines", "author": "ohanegby", "description": "rotating 2d area lights by Ori Hanegby,\ninspired by the thread here: https://www.facebook.com/groups/shadertoy/posts/954364335144593\n", "tags": ["lighting", "arealights"], "likes": 30, "viewed": 679, "published": 3, "date": "1633416357", "time_retrieved": "2024-07-30T18:57:54.591568", "image_code": "// Rotating Area Lights Lines\n// By Ori Hanegby\n// Inspired by this thread: \n// https://www.facebook.com/groups/shadertoy/posts/954364335144593\n// Line segment code from iq's tutorials: https://iquilezles.org/articles/distfunctions2d\n// Tone mapping code from here: https://www.shadertoy.com/view/7scXD4\n\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n\n// In order to calculate the area light I'm treating the line area as continous line of infinite directional light sources\n// To calculate how much light each point (uv) receives I'm using two factors: the distance from the line to the point and the integration of \n// all the sin(angle) between the point and the light sources on the line. The integral between angles b and a on the line segment have an easy solution\n// -cos(b)+cos(a) \n// cos(b) and cos(a) are given by the dot products between the two edges on of the line that are stored in l1 and l2\n// the integral result is multiplied by hh which gives control of the light intensity relative to the distance from the line\n// In order to know which side of the line the point resides on I'm using cross product where the sign of the z component indicates the direction\nvec2 area_light_intensity(vec2 p, vec2 v1, vec2 v2, float diffusePower, float shinePower)\n{  \n    vec2 areaLine = normalize(v2-v1);\n    float l1 = dot(normalize(p-v1),areaLine);\n    float l2 = dot(normalize(p-v2),areaLine);\n    vec3 crs=cross(vec3(p-v1,0.),vec3(areaLine,0.));\n    float d = line_segment(p,v1,v2);\n    float hh=max(0.,pow(max(0.01,shinePower-d),4.5));\n    float c=(-l2 + l1)*hh;\n    return vec2(pow(c,diffusePower),crs.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=6.;\n    float t=0.;\n    float c=0.;\n    vec3 col=vec3(0.);\n    for (int i=0; i<3; i++){\n        t+=1.;\n        float angle = iTime/10. + t*5.;\n\n        vec2 line = vec2(sin(angle),cos(angle));\n        float s=1.6;    \n        vec2 v1 = -line*s;\n        vec2 v2 = line*s;  \n        vec2 disp = vec2(sin(t*2.1),cos(t*2.1))*2.;\n        v1 += disp;\n        v2 += disp;\n        vec2 intes_w_sign=area_light_intensity(uv, v1, v2, 1., 5.);\n        float intens=intes_w_sign.x/pow(2.,7.);\n        vec3 tCol = intes_w_sign.y>0.?vec3(1.0,0.25,0.05) * intens:\n        vec3(1.0,0.12,0.02) * intens/5.;        \n        col += tCol;\n    }\n\n    \n    col = col / (1. + col); // Tone mapping\n    col = sqrt(col); // Gamma\n    \n    fragColor = vec4(col, 1);       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 359, 359, 479], [482, 1308, 1399, 1399, 1748], [1750, 1750, 1807, 1857, 2674]], "test": "untested"}
{"id": "fd3XRS", "name": "Ancient Building", "author": "prishainabox", "description": "Sources for learning: Inigo Quilez's videos and articles.\nHeavily inspired by IQ's livestream on the Greek Temple.\n\nMy coding timelapse on this: https://www.youtube.com/watch?v=_2hb0vOE3PM", "tags": ["raymarching"], "likes": 8, "viewed": 412, "published": 3, "date": "1633397623", "time_retrieved": "2024-07-30T18:57:55.717558", "image_code": "const float EPSILON = 0.001;\n\n//*******************************************************//\n\n// Light struct\nstruct Light {\n    vec3 clr;\n    vec3 dir;\n    float shadowSoftness;\n};\n\n// Material struct\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    float id;\n};\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n//*******************************************************//\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smoothmax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// smooth min for distance and color\nvec4 smoothmin(in float a, in float b, in vec3 clr1, in vec3 clr2, in float k) {\n   float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n   float d = mix(b, a, h) - k*h*(1.0-h);\n   vec3 c = mix(clr2, clr1, h);\n   return vec4(c, d);\n}\n\n// return points for finite and infinite repetition\n\nvec3 infRep(in vec3 pt, in vec3 period) {\n    return mod(pt + 0.5 * period, period) - 0.5 * period;\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 minLim, in vec3 maxLim) {\n    return pt - period * clamp(round(pt/period), minLim, maxLim);\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 lim) {\n    return pt - period * clamp(round(pt/period), -lim, lim);\n}\n\n\n//*******************************************************//\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\nfloat fractalNoise(in vec3 uvw) {\n    float c = noise(uvw * 4.0);\n    c += 0.5 * noise(uvw * 8.0);\n    c += 0.25 * noise(uvw * 16.0);\n    c += 0.125 * noise(uvw * 32.0);\n    c += 0.0625 * noise(uvw * 64.0);\n    c /= 2.0;\n    return c;\n}\n\n//*******************************************************//\n\n// SDFs\n\nfloat sdfSphere(in vec3 pt, in float rad) {\n    return length(pt) - rad;\n}\n\nfloat sdfEllipsoid(in vec3 pt, in vec3 rad) {\n    float k0 = length(pt/rad);\n    float k1 = length(pt/(rad*rad));\n    return k0 * (k0-1.0)/k1;\n}\n\nfloat sdfCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n    vec3 apt = pt - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n    return length( apt - ab * t ) - r;\n}\n\nfloat sdfBox(vec3 pt, vec3 b) {\n\tvec3 q = abs(pt) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//*******************************************************//\n\n// SDF TEMPLE\n\nfloat sdfTemple(in vec3 pt) {\n\n    float res;\n    \n    //if (sdfBox(pt, vec3(10.0)) > 0.0) return 1000.0;\n    \n    {\n        // columns\n        vec3 p =  pt - vec3(0.0, 1.00, 0.0);\n        float b = sdfBox(p - vec3(0, 1, 0), vec3(2.9, 1.8, 1.2)); // remove center columns\n        p = finRep(p, vec3(2.0, 1.0, 1.6), vec3(2, 0, 1));\n        // bottom base\n        res = sdfBox(p - vec3(0, 0.05, 0), vec3(0.37, 0.05, 0.37)) + p.y * 0.5;\n        res = smoothmin(res, sdfBox(p - vec3(0, 0.15, 0), vec3(0.26, 0.027, 0.26)), 0.1) - 0.03;\n        // top of column\n        res = min(res, sdfBox(p - vec3(0, 2.1, 0), vec3(0.25, 0.05, 0.25))) - 0.01;\n        res = smoothmin(res, sdfBox(p - vec3(0, 2.25, 0), vec3(0.39, 0.03, 0.39)), 0.2) - 0.01;\n        // columns\n        float col = sdfBox(p - vec3(0, 1.15, 0), vec3(0.24, 1.0, 0.24));\n        // bring out top of column\n        col = smoothmin(col, sdfBox(p - vec3(0, 1.9, 0), vec3(0.18, 0.001, 0.18))-0.15, 0.1);\n        // distortion\n        col += 0.015 * sin(10.0 * atan(p.z, p.x));\n        col += 0.05 * p.y;\n        res = smoothmin(res, col, 0.1);\n        //d -= noise(vec3(pt.x * 2.0, pt.y * 0.5, pt.z * 2.0) * 20.0) * 0.01; // noise\n        //d -= fractalNoise(pt) * 0.1;\n        res = max(-b, res); // remove center columns\n    \n        // steps / floor\n        vec3 s = p - vec3(0, -0.2, 0);\n        float steps = sdfBox(s, vec3(0.95, 0.1, 0.75)) - 0.03;\n        s = finRep(pt - vec3(0, 0.5, 0.0), vec3(1.6, 0.2, 1.3), vec3(3, 0.0, 2.0));\n        steps = min(steps, sdfBox(s, vec3(0.74, 0.15, 0.60)) - 0.03);// - fractalNoise(pt) * 0.05;\n        res = smoothmin(res, steps, 0.05);\n    }\n    \n    // roof\n    {\n        vec3 q = pt - vec3(0, 3.4, 0);\n        vec3 r = finRep(q, vec3(1.05, 0.2, 0.65), vec3(4, 0, 3));\n        // ceiling\n        float c = sdfBox(r, vec3(0.4, 0.08, 0.28)) - 0.02;\n        // trngle prism\n        q.y -= 0.4;\n        q.x = abs(q.x) - 4.25;\n        vec3 triPrism = vec3(0.25, 0.25, 0.9 - q.y * 3.5);\n        float roof = sdfBox(q, triPrism) - 0.06;\n        triPrism.y *= 0.7;\n        triPrism.z = - q.y * 4.7;\n        roof = smoothmax(roof, -sdfBox(q - vec3(0.4, -0.2, 0), triPrism) - 0.02, 0.2);\n        roof = min(c, roof);\n        res = min(roof, res);\n    }\n    \n    return res;\n\n}\n\n// SDF SCENE\n\nfloat sdfScene(in vec3 pt, out Material mat) {\n\n    // distance to closest object\n    float res;\n    \n    Material templeMat;\n    float temple = sdfTemple(pt - vec3(2, -0.45, 3.0));\n    {\n        float n = fractalNoise(pt*1.7);\n        temple -= n * 0.03;\n        templeMat.clr = vec3(0.1, 0.06, 0.02) + 1.5 * n * vec3(0.05, 0.01, 0.02);\n        templeMat.dif = 1.0;\n        templeMat.spec = 0.9;\n        templeMat.shininess = 20.0;\n        templeMat.amb = 0.05;\n        templeMat.id = 1.0;\n    }\n    \n    // ground\n    float ground;\n    Material groundMat;\n    {\n        float n = fractalNoise(pt * 0.3);\n        ground = pt.y - 0.12 * sin(pt.x * 0.9) * sin(pt.z * 0.8);\n        \n        // hills\n        float hill = sdfEllipsoid(pt - vec3(-5, 0, -22), vec3(8.0, 6.0, 5.0));\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(-11, 0, -19), vec3(5, 3.0, 5)), 2.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(-3, 0, -15), vec3(5, 3.0, 5)), 3.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(2, 0, -18), vec3(8, 5.0, 3)), 2.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(7, 0, -15), vec3(7, 4.0, 5)), 2.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(15, 0, -11), vec3(10, 3, 10)), 3.0);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(18, 0, -1), vec3(5, 3, 3)), 3.0);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(27, 0, 3), vec3(5, 3, 5)), 3.0);\n        hill -= 0.6 * sin(pt.x * 1.1) * sin(pt.z * 0.2) + n*0.8;\n        ground = smoothmin(ground - 0.15*n, hill, 2.8);\n        \n        // ground clr\n        groundMat.clr = vec3(0.075, 0.075, 0.09);\n        groundMat.dif = 1.0;\n        groundMat.spec = 0.7;\n        groundMat.shininess = 50.0;\n        groundMat.amb = 0.01;\n        groundMat.id = 0.0;\n    }\n    \n    // material and res\n    \n    if (ground < temple) {\n        res = ground;\n        mat = groundMat;\n    } else {\n        res = temple;\n        mat = templeMat;\n    }\n\n    return res;\n    \n}\n\n//*******************************************************//\n\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdfScene(pt + h.xyy, m) - sdfScene(pt - h.xyy, m),\n       sdfScene(pt + h.yxy, m) - sdfScene(pt - h.yxy, m),\n       sdfScene(pt + h.yyx, m) - sdfScene(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n    \n    // result\n    float res = -1.0;\n    // total distance traveled\n    float td = 0.00;\n    \n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        Material m;\n        float h = sdfScene(ro + td*rd, m);\n        // if distance is really close, break\n        if (abs(h) < (0.001*td)) {\n           res = td;\n           mat = m;\n           break;\n        }\n        // add to total distance\n        td += h;\n    }\n       \n    return res;\n    \n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        Material m;\n        float d = sdfScene(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection, no shadow -> 1.0\n    return res;\n}\n\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 4; i++) {\n        float h = 0.01 + 0.07 * float(i);\n        float d = sdfScene(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.97;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 8.0) );\n    return mix(clr, fogClr, 1.0 - exp(-0.0001 * d * d * d)); // fog\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n    \n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow\n    float shadow = softShadow(pt + nor*0.001, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in Material mat) {\n\n    vec3 pt = ro + rd * d;\n    \n    // KEY LIGHT\n    Light sun;\n    sun.clr = vec3(12.9, 6.0, 4.7),\n    sun.dir = normalize(vec3(0.85, 0.2, 0.8));\n    sun.shadowSoftness = 30.9;\n    \n    // COLORS\n    vec3 skyClr = vec3(0.8, 0.5, 0.8) - 0.9 * rd.y;\n    // overexposure effect\n    vec3 shine = 0.35 * sun.clr * pow(uclamp(dot(sun.dir,rd)), 5.0);\n    \n    // background color\n    vec3 clr = skyClr;\n    \n    // return background if too far\n    if (d < 0.0) {\n        // sun\n        return clr + shine;\n    }\n    \n    vec3 nor = calcNormal(pt);\n    \n    // MATERIAL COLOR\n    \n    clr = mat.clr;\n    \n    // hills\n    if (mat.id == 0.0) {\n        clr += vec3(0.1 * max(pt.y, 0.0))  * 0.7 * uclamp(dot(nor, vec3(0, 1, 0)));\n    }\n    \n    // LIGHTS AND COLOR\n    \n    float occ = calcOcc(pt, nor);\n    \n    vec3 light = vec3(mat.amb);\n    light += calcLighting(pt, rd, nor, sun, mat); // sun\n    light += (uclamp(dot(nor, vec3(0, 1, 0))) * 0.5 + 0.5) * skyClr * occ; // sky diffuse\n\n    clr *= light;\n    \n    clr = applyFog(rd, d, clr, sun.clr * 0.2, sun.dir, skyClr);\n    \n    clr += shine;\n    \n    return clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\n    // cast ray, return dist to closest object and material\n    Material mat;\n    float d = castRay(ro, rd, mat);\n    \n    vec3 clr = calcClr(ro, rd, d, mat);\n    \n    clr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n    return clr;\n    \n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    if (iFrame != 0) discard;\n\n    // Normalized pixel coordinates\n    vec2 res = iResolution.xy;\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0.7, -0.2, -2.2);\n    // ray origin\n    vec3 ro = target + vec3(-6.7,  2.5, 7.7);\n    \n    vec3 rd = setCamera(uv, ro, target);\n    \n    // calculate color based on distance, etc\n    vec3 clr = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3XRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 404, 429, 429, 464], [527, 559, 612, 612, 701], [703, 717, 763, 763, 835], [837, 874, 954, 954, 1098], [1153, 1153, 1194, 1194, 1254], [1256, 1256, 1329, 1329, 1397], [1399, 1399, 1453, 1453, 1516], [1601, 1601, 1627, 1627, 1680], [1682, 1682, 1707, 1707, 1783], [1785, 1785, 1810, 1810, 1895], [1897, 1897, 1923, 1923, 2607], [2609, 2609, 2642, 2642, 2845], [2917, 2917, 2960, 2960, 2991], [2993, 2993, 3038, 3038, 3137], [3139, 3139, 3203, 3203, 3347], [3349, 3349, 3380, 3380, 3470], [3548, 3548, 3577, 3577, 5813], [5829, 5829, 5875, 5910, 7793], [7856, 7856, 7885, 7885, 8210], [8273, 8273, 8330, 8349, 8777], [8779, 8779, 8833, 8833, 9246], [9248, 9248, 9288, 9288, 9594], [9657, 9657, 9757, 9757, 9905], [9907, 9907, 9996, 10016, 10424], [10426, 10426, 10493, 10493, 11607], [11670, 11670, 11707, 11768, 11952], [12015, 12015, 12071, 12071, 12326], [12328, 12328, 12385, 12385, 12857]], "test": "untested"}
{"id": "fs3SRS", "name": "Reflecty Tubes", "author": "SnoopethDuckDuck", "description": "forked from artofcode's thngy", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 349, "published": 3, "date": "1633394798", "time_retrieved": "2024-07-30T18:57:56.467552", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    //float b = .5 + .5 * cos(0.3 * iTime);\n    p *= (1. + 0.2 * cos(5.6 * length(p) -0.1 * iTime));\n    float bd = sdBox(p, vec3(0.88)) -0.2;\n    float sd = length(p) - 1.18;// + 0.1 * cos(0.7 * iTime);\n    return 0.5 * abs(bd- sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = 0.999 * GetDist(p);\n    vec2 e = vec2(0.001,0.);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(3.5 * cos(0.5 * iTime),3. * sin(0.4 * iTime), 3.5 * sin(0.5 * iTime));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1. + 0.2 * cos(0.3 * iTime));\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    float depth = 2.; //1.5 + cos(iTime);\n    \n    // comment / uncomment me\n    d = RayMarch(ro + rd * (1. + depth) * d, -0.5 * depth * rd);\n    //d = mix(d, cos(d), .5 + .5 * cos(iTime));\n    //d = d * tanh((.6 + .5 * cos(5. * iTime)) * d);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(1.5*rd, n);\n        \n        float spec = pow(max(0., -r.y),32.);\n        spec = .5 + .5 * cos(0.00001*spec); // <-- absolute fudge but works alright\n       \n       float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       float a = atan(p.x,p.z);\n      // dif =mix(dif, 16. * dif * dif * (1.-dif) * (1.-dif),0.2);\n       \n       col = 0.45 * vec3(dif) + 1.5 * cos(2. * a) * Bg(r);        \n       col *= (1. + spec);\n       \n       // comment / uncomment me\n       //col = vec3(dif);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    //col = vec3(col.x + col.z, col.y + col.x, col.z + col.y) * 0.5;\n    //col = cos(4. * col * cos(0.1 * d));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SRS.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1671, 1671, 1694, 1738, 1930], [1932, 1932, 1966, 1966, 2177], [2179, 2179, 2203, 2203, 2402], [2404, 2404, 2454, 2454, 2645], [2647, 2647, 2665, 2665, 2763], [2765, 2765, 2822, 2822, 4276]], "test": "untested"}
{"id": "7ddSD7", "name": "Desperate Distraction", "author": "spolsh", "description": "04.10.2021 - the day shadertoy was up and facebook was down", "tags": ["2d", "sdf", "fb"], "likes": 63, "viewed": 2628, "published": 3, "date": "1633386597", "time_retrieved": "2024-07-30T18:57:57.398064", "image_code": "#define R iResolution\n#define F gl_FragCoord\n#define T iTime\n#define PI 3.1415\n\n#define DBG vec3(1.0, 0.0, 0.0)\n#define BG  vec3(0.2)\n#define PH0 vec3(0.0)\n#define PH1 vec3(0.1)\n#define FB0 vec3(0.6)\n#define FB1 vec3(0.25, 0.25, 0.5)\n#define FB2 vec3(0.7, 0.7, 0.9)\n#define FB3 vec3(0.2)\n#define FB4 vec3(1.0)\n#define FB5 vec3(0.75)\n\n#define ROUND0 0.01\n#define ROUND1 0.004\n\nfloat sdBox2( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat2 rot(float a)\n{ \n    float s = sin(a);\n    float c = cos(a);\n    return mat2( c, -s , s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = F.xy/R.xy;\n\tvec2 p = 2.0*(q-0.5);\n    p.x *= R.x/R.y;\n    \n    float bounce = sin(fract(2.0*0.35*T-0.5)*2.0*PI);\n    float rotAnim = 2.0*(-0.5+ smoothstep(-0.6, 0.6, bounce) );\n    mat2 r = rot(0.25*0.0174*rotAnim);\n    p *= r;\n    \n    float yAnim = 0.5+0.5*cos(fract(2.0*0.35*T-0.5)*2.0*PI); // synced with feed scroll anim\n    vec3 tiltTex = texture(iChannel0, vec3(0.0, 0.0, 0.125*0.35*T)).rgb;\n    vec2 tiltAnim = vec2(0.1, 0.1) * (2.0*(smoothstep(0.0, 2.0, tiltTex.xy)-0.5));\n    tiltAnim.y += 0.2*yAnim;    \n    p *= mix( 0.95, 1.0, tiltTex.b);\n    p += tiltAnim;\n        \n    float s0 = abs(p.x) - 0.9; // phone body\n    float s01 = sdBox2(p +vec2(0.0, -0.95), vec2(0.2, 0.005)); // phone body speaker\n    float s10 = sdBox2(p +vec2(0.0, 0.1), vec2(0.8, 0.9)); // phone top bar\n    float s11 = sdBox2(p +vec2(-0.74, -0.72), vec2(0.01, 0.005)); // phone top bar battery\n    float s12 = sdBox2(p +vec2(-0.69, -0.72), vec2(0.04, 0.02)); // phone top bar battery\n    float s13 = sdBox2(p +vec2(-0.70, -0.72), vec2(0.035, 0.025)); // phone top bar battery\n    float s14 = sdBox2(p +vec2( 0.75, -0.700), vec2(0.002, 0.005)); // phone top bar signal\n    float s15 = sdBox2(p +vec2( 0.72, -0.710), vec2(0.002, 0.015)); // phone top bar signal\n    float s16 = sdBox2(p +vec2( 0.69, -0.720), vec2(0.002, 0.025)); // phone top bar signal\n    float s17 = sdBox2(p +vec2( 0.66, -0.728), vec2(0.002, 0.035)); // phone top bar signal\n    \n    float s2 = sdBox2(p +vec2(0.0, 0.25), vec2(0.8, 0.9)); // app body bg\n    float s3 = sdBox2(p -vec2(0.0, 0.55), vec2(0.8, 0.11)); // app top bar\n    \n    float s40 = sdBox2(p +vec2(-0.68, -0.55), vec2(0.07)); // app top bar icon placeholder\n    float s41 = max(  sdBox2(p +vec2( 0.69, -0.57), vec2(0.06)), // app top bar icon placeholder    \n                      texture(iChannel1, p*0.35 - vec2(0.36, 0.60)).x );\n    float s42 = sdBox2(p +vec2(-0.3, -0.55), vec2(0.07)); // app top bar icon placeholder\n    float s43 = sdBox2(p +vec2( 0.0, -0.55), vec2(0.07)); // app top bar icon placeholder    \n    float s44 = sdBox2(p +vec2( 0.3, -0.55), vec2(0.07)); // app top bar icon placeholder\n    \n    float s50 = sdBox2(p  -vec2(0.0, 0.3), vec2(0.8, 0.13)); // app lower bar placeholder\n    float s51 = sdBox2(p +vec2( 0.0, -0.16), vec2(0.80, 0.0001)); // app lower bar separator line\n    float s52 = sdBox2(p +vec2( 0.27, -0.3), vec2(0.0001, 0.132)); // app lower bar button separator line\n    float s53 = sdBox2(p +vec2(-0.27, -0.3), vec2(0.0001, 0.132)); // app lower bar button separator line\n    float s54 = sdBox2(p +vec2(-0.39, -0.3), vec2(0.07, 0.05)); // app lower bar button\n    float s55 = sdBox2(p +vec2( 0.15, -0.3), vec2(0.07, 0.05)); // app lower bar button\n    float s56 = sdBox2(p +vec2( 0.67, -0.3), vec2(0.07, 0.05)); // app lower bar button\n        \n    vec2 animP = p + vec2(0.0, -0.2 + smoothstep(0.5, 1.0, fract(2.0*0.35*T)) + floor(2.0*0.35*T) );\n    animP.y = fract(animP.y)-0.5;\n    \n    float s60 = sdBox2(animP +vec2(0.0, 0.1), vec2(0.75, 0.5)); // app post top placeholder\n    float s61 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.0,   0.47), vec2(0.75 +2.0*ROUND0, 0.001)); // app post separator line\n    float s62 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.5,  -0.02), vec2(0.2, 0.2)); // app post top avatar\n    float s63 = sdBox2(animP +vec2(0.0, -0.14) +vec2(-0.23, -0.12), vec2(0.42, 0.03)); // app post top name\n    float s64 = sdBox2(animP +vec2(0.0, -0.14) +vec2(-0.16, -0.02), vec2(0.35, 0.02)); // app post top timestamp\n    float s65 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.1,   0.27), vec2(0.6, 0.02)); // app post text\n    float s66 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.14,  0.37), vec2(0.56, 0.02)); // app post text\n    \n    float s7 = sdBox2(animP +vec2(0.0, 0.0), vec2(0.1, 0.1)); // anim test\n    \n    float fadeAnim0 = smoothstep(-0.5, 0.5, sin(5.0*(p.x + 0.5)  + 3.0*T));\n    float fadeAnim1 = smoothstep(-0.5, 0.5, sin(5.0*(p.x + 0.23) + 3.0*T));\n    float fadeAnim2 = smoothstep(-0.5, 0.5, sin(5.0*(p.x + 0.1)  + 3.0*T));\n    \n    vec3 c = mix(PH0, BG, smoothstep(0.0, 0.01, s0 ));\n      \n    c = mix(PH1, c, smoothstep(0.0, 0.01, s01 ));\n    c = mix(PH1, c, smoothstep(0.0, 0.01, s10 ));    \n    c = mix(FB0, c, smoothstep(0.0, 0.01, s2 ));\n    \n    c = mix(FB4, c, smoothstep(0.0, 0.01, max(s2, s60 -ROUND0) ));\n    c = mix(FB0, c, smoothstep(0.0, 0.01, max(s2, s61) ));\n    c = mix(mix(FB0, FB5, fadeAnim0), c, smoothstep(0.0, 0.01, max(s2, s62 -ROUND0) ));\n    c = mix(mix(FB0, FB5, fadeAnim1), c, smoothstep(0.0, 0.01, max(s2, s64) ));\n    c = mix(mix(FB0, FB5, fadeAnim2), c, smoothstep(0.0, 0.01, max(s2, min( min(s63, s65), s66) ) ));\n    // c = mix(DBG, c, smoothstep(0.0, 0.01, s7 ));\n\n    c = mix(FB1, c, smoothstep(0.0, 0.01, s3 ));    \n    c = mix(FB2, c, smoothstep(0.0, 0.01, s41 -ROUND0 ));\n    c = mix(FB3, c, 0.5+0.5*smoothstep(0.0, 0.01, min( min(s42, s43), s44) -ROUND0 ));    \n    c = mix(FB4, c, smoothstep(0.0, 0.01, s50 ));\n    \n    c = mix(FB0, c, smoothstep(0.0, 0.01, min( min( s51, s52 ), s53) ));\n    c = mix(FB0, c, smoothstep(0.0, 0.01, min( min( s54, s55 ), s56) -ROUND0 ));\n    \n    c = mix(FB0, c, smoothstep(0.0, 0.01, max( -s13 +ROUND1, min(s11 -ROUND1, s12 -ROUND1)) ));\n    float signalAnim = smoothstep(0.3, 0.31, fract(0.35*T));\n    c = mix(FB3, c, smoothstep(0.0, 0.01, min( min(s15, s16), s17) -ROUND1 ));\n    c = mix(mix(FB0, FB3, vec3(signalAnim) ), c, smoothstep(0.0, 0.01, s14 -ROUND1 ));    \n    \n    float glowTex = texture(iChannel0, vec3(0.05*p, 2.0*T)).r;\n    float glowAnim = mix(0.9, 1.0, glowTex);\n    c += 0.1*smoothstep(1.0, 0.0, s2) * glowAnim; // display glow\n    \n    c = smoothstep(0.1*glowAnim, 1.0, c);\n    c *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );    \n    \n    float grainTex = texture(iChannel0, vec3(20.0*q, T)).r;\n    c *= mix(0.92, 1.0, grainTex);\n    \n    c = pow(c, vec3(0.4545));\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 376, 408, 408, 486], [488, 488, 507, 507, 586], [588, 588, 645, 645, 6556]], "test": "untested"}
{"id": "fdtXW7", "name": "MandelBrot Shader", "author": "Remming_Senegal", "description": "Mandelbrot with anti-aliasing!", "tags": ["fractal", "postprocessing"], "likes": 2, "viewed": 445, "published": 3, "date": "1633383626", "time_retrieved": "2024-07-30T18:57:58.293670", "image_code": "/*\n    Here's what I'm learning with this shader:\n    How to properly implement proper UV distortion\n    https://en.wikipedia.org/wiki/Mandelbrot_set\n    \n    Cartesan mandelbrot set courtesy of Code Parade\n    https://www.youtube.com/watch?v=GiAj9WW1OfQ\n    \n    HSV to RGB math courtesy of Wikipedia\n    https://en.wikipedia.org/wiki/HSL_and_HSV#To_RGB\n    \n    Luminance numbers:\n    https://en.wikipedia.org/wiki/Relative_luminance\n    \n    FXAA algorithm thanks to: \n    https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\n    \n    TODO:\n        -Implement FXAA antialiasing\n        -Make the camera move around the edges of the mandelbrot set\n*/\n\n/*\n    BufferA renders the mandelbrot set\n    main image will apply post-processing effects\n*/\n\nfloat PIXELX;\nfloat PIXELY;\n\nfloat sampleLuminance(sampler2D channel, vec2 uv, float xoffset, float yoffset) {\n    vec3 col = texture(channel, uv + vec2(xoffset, yoffset)).rgb;\n    return (0.2126*col.r + 0.7152*col.g + 0.0722*col.b);\n}\n\nstruct kernel {\n    float m, n, s, w, e;\n    float ne, nw, se, sw;\n    float highest, lowest, contrast;\n};\n\nstruct edge {\n    //true = ishorizontal, false = isvertical\n    bool isHorizontal;\n    float pixelstepx;\n    float pixelstepy;\n\n};\n\nfloat blendFactor(kernel l) {\n    //adds everything and then averages it\n    float f = 2.0 * (l.n + l.s + l.e + l.w);\n    f += l.ne + l.nw + l.se + l.sw;\n    f /= 12.0;\n    f = abs(f - l.m);\n    f = clamp(0.0,1.0,f/l.contrast);\n    f = smoothstep(0.0f,1.0f,f);\n    return f*f;\n}\n\nedge detectEdges(kernel l) {\n    edge e;\n    \n    float horizontal = \n        2.0 * abs(l.n + l.s - 2.0 * l.m) +\n        abs(l.ne + l.se - 2.0 * l.e) +\n        abs(l.nw + l.sw - 2.0 * l.w);\n        \n    float vertical = \n        2.0 * abs(l.e + l.w - 2.0 * l.m) +\n        abs(l.ne + l.nw - 2.0 * l.n) +\n        abs(l.se + l.sw - 2.0 * l.s);\n    \n    e.isHorizontal = horizontal >= vertical;\n    \n    float positiveblur = e.isHorizontal ? l.n : l.e;\n    float negativeblur = e.isHorizontal ? l.s : l.e;\n    \n    float positivegradient = abs(positiveblur - l.m);\n    float negativegradient = abs(negativeblur - l.m);\n    \n    e.pixelstepx = PIXELX;\n    e.pixelstepy = PIXELY;\n    \n    if(positivegradient < negativegradient) {\n        e.pixelstepx *= -1.0;\n        e.pixelstepy *= -1.0;\n    }\n    \n    return e;\n\n}\n\n//samples pixels around the current pixel\n//returns local contrast\nfloat contrast(sampler2D channel, vec2 uv,out kernel l) {\n    //kernel l;\n    \n    l.m = sampleLuminance(channel, uv,0.0,0.0);\n    l.n = sampleLuminance(channel, uv,0.0,PIXELY);\n    l.s = sampleLuminance(channel, uv,0.0,-PIXELY);\n    l.w = sampleLuminance(channel, uv,PIXELX,0.0);\n    l.e = sampleLuminance(channel, uv,-PIXELX,0.0);\n    \n    l.ne = sampleLuminance(channel, uv, PIXELX, -PIXELY);\n    l.nw = sampleLuminance(channel, uv, PIXELX, PIXELY);\n    l.se = sampleLuminance(channel, uv, -PIXELX, -PIXELY);\n    l.sw = sampleLuminance(channel, uv, -PIXELX, PIXELY);\n    \n    l.highest = max(l.m,max(l.n,max(l.s,max(l.w,l.e))));\n    l.lowest = min(l.m,min(l.n,min(l.s,min(l.w,l.e))));\n    l.contrast = l.highest - l.lowest;\n    \n    return l.contrast;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    \n    PIXELX = uv.x/iResolution.x;\n    PIXELY = uv.y/iResolution.y;\n    \n    //Anti-Alias the image with FXAA\n    kernel l;\n    float localcontrast = contrast(iChannel0, uv, l);\n    \n    //removing low-contrast areas\n    if(localcontrast < 0.0312) {\n        localcontrast = 0.0f;\n    }\n    \n    //removing areas within relative threshold\n    if(localcontrast < 0.063 * l.highest) {\n        localcontrast = 0.0f;\n    }\n    \n    l.contrast = localcontrast;\n    \n    //calculating blend factor\n    float blur = blendFactor(l);\n    \n    //detecting edges\n    edge e = detectEdges(l);\n    \n    col = texture(iChannel0, uv).rgb;\n    \n    //blending uv\n    if(e.isHorizontal)\n        uv.y += e.pixelstepy * blur;\n    else\n        uv.x += e.pixelstepx * blur;\n   \n    col = texture(iChannel0, uv).rgb;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    This buffer is responsible for renderingthe mandelbrot set\n\n*/\n\n#define ANTIALIAS 4\n#define STEPS 50\n#define SPEED 60.0\n\nvec2 MandelBrotUV(vec2 uv, int steps) {\n    \n    vec2 olduv = vec2(0,0);\n    vec2 mbuv;\n    \n    for(int i = 0; i < steps; i++) {\n        mbuv.x = pow(olduv.x,2.0f) - pow(olduv.y,2.0f) + uv.x;\n        mbuv.y = (2.0f*olduv.x*olduv.y) + uv.y;\n        \n        olduv = mbuv;\n    }\n \n    return mbuv;\n}\n\n//HSV to RGB\nvec3 rgb(vec3 hsv) {\n    vec3 rgb;\n    \n    float chroma = hsv.y * hsv.z;\n    \n    hsv.x = mod(hsv.x,360.0);\n    hsv.x /= 60.0;\n    float x = chroma * (1.0 - abs(mod(hsv.x,2.0)-1.0));\n    \n    if(0.0 <= hsv.x && hsv.x < 1.0) {\n    \n        rgb = vec3(chroma,x,0.0);\n        \n    } else if(1.0 <= hsv.x && hsv.x < 2.0) {\n    \n        rgb = vec3(x,chroma,0.0);\n        \n    } else if(2.0 <= hsv.x && hsv.x < 3.0) {\n    \n        rgb = vec3(0.0,chroma,x);\n        \n    } else if(3.0 <= hsv.x && hsv.x < 4.0) {\n    \n        rgb = vec3(0.0,x,chroma);\n        \n    } else if(4.0 <= hsv.x && hsv.x < 5.0) {\n    \n        rgb = vec3(x,0.0,chroma); \n        \n    } else if(5.0 <= hsv.x && hsv.x < 6.0) {\n    \n        rgb = vec3(chroma,0.0,x);\n        \n    }\n    \n    return rgb;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Normalize pizel coords (-1 to 1)\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    //Maintain aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    //At about uv *= 0.000001 precision starts to get lost.\n    uv *= 1.2;\n    uv -= vec2(.6,-0.024);\n\n    vec3 col = rgb(vec3(iTime*SPEED,1.0,1.0));\n    vec2 mbuv;\n    \n    for(int i = 1; i < STEPS; i++) {\n        mbuv = MandelBrotUV(uv,i);\n        vec3 stepcol;\n        //Lowers color range from 0-infinity to 0-1\n        float l = length(mbuv); \n        l = (log(l+0.01)/20.0f) + .2f;\n        if(l > 1.0) stepcol = vec3(1.0,1.0,1.0);\n        \n        if(l > .2) stepcol = vec3(0.0,0.0,0.0);\n        \n        //if(l <= .2) stepcol = vec3(1.0/float(STEPS));\n        //col += stepcol;\n        \n        if(l <= .2) stepcol = rgb(vec3(360.0*(float(i)/float(STEPS))+(iTime*SPEED),1.0,1.0));\n        if(l <= .2) col = stepcol;\n        \n        \n        //Final step. Inside Shading\n        if(i >= STEPS-2 && l  <=.2) {\n            //col = rgb(vec3(iTime*SPEED + 180.0,1.0,1.0));\n            col = vec3(0.0);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[793, 793, 874, 874, 999], [1241, 1241, 1270, 1313, 1519], [1521, 1521, 1549, 1549, 2333], [2335, 2402, 2459, 2475, 3158], [3160, 3160, 3217, 3268, 4186]], "test": "untested"}
{"id": "sdcSWn", "name": "Box Node Connections", "author": "byt3_m3chanic", "description": "Something started over the break - and just playing around in the updated shadertoy.. ", "tags": ["raymarching", "fractal", "reflection", "refraction", "transparent"], "likes": 16, "viewed": 344, "published": 3, "date": "1633379926", "time_retrieved": "2024-07-30T18:57:59.188278", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Box Node Connections\n    10/3/21 @byt3_m3chanic\n    \n    Just playing with a simple fold/mirror formula / simple box and tube with\n    a little refraction.\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n// updaetd with some AA - reduce to 1.0 if too slow\n#define AA 2.0\n\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq thanks for the sdf's!\n\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n//globals\nmat2 rx, ry;\nfloat tmod=0.,ga2=0.,ga4=0.,ga5=0.;\nvec3 hit,hitPoint;\n\n//fold\nvoid octa(inout vec4 p, float k1, float k2, float k3, float k4)  \n{\n    p.y = abs(p.y);\n    if (p.x + p.y<0.0) p.xy = -p.yx;\n    if (p.x + p.z<0.0) p.xz = -p.zx;\n    if (p.x - p.y<0.0) p.xy = p.yx;\n    if (p.x - p.z<0.0) p.xz = p.zx;\n    p.xyz = p.xyz*k1 - (k1 - 1.0);\n}\n\nconst float zoom = 23.5;\nconst float cell = 24.;\nconst float hlf = cell/2.;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n\n    vec3 pp = p;\n    \n    if(ga4>0.) p.xz*=rot(ga4*PI/2.);\n    if(ga5>0.) p.y+=ga5*cell;\n    \n    p.y=mod(p.y+hlf,cell)-hlf;\n  \n    vec4 P = vec4(p.xyz, 1.0);\n    float spc = 6.;\n    \n    for(int j=0;j<2;j++) { \n        octa(P, 1.,1.,1.,1.); \n        P.xyz = abs(P.zxy)-spc;\n    }\n    vec3 q = P.xyz;\n\n    q.x = abs(q.x)-spc;\n    q.z = abs(q.z)-spc;\n\n    vec3 fq = q;\n    fq.x=abs(fq.x)-1.6;\n    fq.y=abs(abs(fq.y)-.4)-.2;\n    float mainbox = sdbox(q,vec3(1.25));\n    float cutbox =  sdbox(vec3(q.xy,abs(q.z))-vec3(0,0 ,1.35),vec3(.65,.65,3.75 ));\n    float frame = sdbox(fq,vec3(.1,.1,.75));\n\n    mainbox = min(mainbox, frame);\n    mainbox = max(mainbox, -cutbox);\n    if(mainbox<res.x) res = vec2(mainbox/P.w,2.);\n\n    float frame2 = sdframe(q,vec3(1.475),.225)-.0125;\n    if(frame2<res.x) res = vec2(frame2/P.w,4.);\n\n    float dv = .45+.25*sin(q.z*.75);\n    float beams = length(q.xy)-dv;\n\n    if(beams<res.x) {\n        res = vec2(beams/P.w,3.);\n        hit=pp+vec3(0,ga2*cell,0);\n    }\n    \n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\n//iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d,1.);\n    vec3 lpos =  vec3(18,18,18);\n    lpos.xz*=ry;\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .9, fresnel);\n\n    vec3 h = vec3(.1);\n    if(m==3.) h = hsv2rgb(vec3(p.x*.003+hitPoint.y*.0125,.8,.5));\n    if(m==4.) h=vec3(.4);\n \n    return diff*h;\n}\n\nvoid image( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n\n    tmod = mod(time, 10.);\n    float t7 = lsp(0.0, 5.0, tmod);\n    float t9 = lsp(4.0, 10.0, tmod);\n\n    ga4 = eoc(t7);\n    ga4 = ga4*ga4*ga4;\n    ga4 = ga4+floor(time*.1);\n    \n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga2 = t9+floor(time*.1);\n    ga5 = (t9);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0, 0, zoom);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1.  - .5) * PI;\n\n    rx = rot(x+.18); ry = rot(y-.58);\n\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(.0015);\n    vec3 p = ro + rd;\n    \n    float atten = .95;\n    float k = 1., d = 0.;\n    \n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x*.75;\n        p += rd * d *k;\n        \n        float fresnel=0.;\n        if (d*d < 1e-7) {\n            hitPoint=hit;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n  \n            atten *= .55;\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            if(m==4.||m==1.) {\n                rd=reflect(-rd,n);\n                p+=n*.025;\n            } else {\n                vec3 rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>50.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.5 ? C+.005 : C;\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\nvoid mainImage(out vec4 O, in vec2 F){\n    vec4 C = vec4(0);\n    float px=.25;\n    if(AA==1.0) {image(C,F); O=C; return;}\n   \n    vec4 C2;\n    \n    image(C2,F.xy+vec2(px,-px));\n    C.rgb+=C2.rgb;\n    image(C2,F.xy+vec2(-px,px));\n    C.rgb+=C2.rgb;\n    \n    C/=AA;\n    \n    O = vec4(C);\n}\n\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcSWn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[440, 440, 460, 460, 505], [506, 506, 530, 530, 588], [589, 589, 633, 633, 688], [689, 689, 709, 709, 747], [778, 778, 809, 809, 896], [898, 898, 940, 940, 1222], [1303, 1310, 1377, 1377, 1580], [1659, 1659, 1677, 1677, 2719], [2721, 2790, 2835, 2835, 3106], [3108, 3124, 3151, 3151, 3280], [3282, 3282, 3374, 3374, 3753], [3755, 3755, 3792, 3806, 5348], [5350, 5350, 5388, 5388, 5637]], "test": "untested"}
{"id": "sdtXDM", "name": "The magic of light", "author": "lllcz", "description": "Made by imitation", "tags": ["2l"], "likes": 2, "viewed": 261, "published": 3, "date": "1633374162", "time_retrieved": "2024-07-30T18:58:00.414998", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec3 c;\n    \n    float t;\n    \n    float l,z;\n    \n    for(int i = 0;i < 3;i ++){\n    \n       vec2 uv = fragCoord/iResolution.xy;\n    \n       uv -= 0.5;\n    \n       uv.x *= iResolution.x/iResolution.y;\n       \n       z += iTime;\n        \n       l = length(uv);\n       \n       uv = uv/l * abs(sin(l*9. - z)) * sin(z); \n       \n       c[i] = 0.1/length(abs(mod(uv, 1.0) - 0.5));\n    }\n\n\n    // Output to screen\n    fragColor = vec4(c, sin(iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 561]], "test": "untested"}
{"id": "NstSD7", "name": " Fab5 #inktober2021 \"raven\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nThe ugliest of all my shaders !  :-)\nInspiration: viking rune raven  https://www.google.com/search?q=rune+raven&tbm=isch", "tags": ["2d", "short", "raven", "inktober2021", "rune", "viking"], "likes": 10, "viewed": 290, "published": 3, "date": "1633373981", "time_retrieved": "2024-07-30T18:58:01.209879", "image_code": "\n#define fwidth(v)   sqrt( dFdx(v)*dFdx(v) + dFdy(v)*dFdy(v) )                 \n#define F           atan(x)*sin(3.*x) - y \n#define D           O -=  x < 1.7 ? c* clamp( 4.*R.y/288. - abs(v)/fwidth(v) ,0.,1.): 0.;\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.); \n    return length(p - b * h);                      \n}\n\n\nvoid mainImage(out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, d,\n          U = 1.2*( u+u - R ) / R.y;\n    U *=  mat2(cos(.7+vec4(0,11,33,0)));\n    O = vec4(1);\n    float x = U.x,y,c=1., \n    v = length(U)-1.06; D                              // disk\n    v -= .1;                           D\n    \n    y = U.y -= .5; v = length(U) -.15;\n    if (x+.2*y > .05 )                 D               // head\n    v += .1;                           D\n    v = line(U, vec2(-.12,-.25),vec2(-.12, .25)); D\n    v = line(U, vec2( .13,-.25),vec2( .10,-.1 )); D\n    v = line(U, vec2(-.12,-.15),vec2( .11,-.15)); D\n    v = line(U, vec2(-.12,-.22),vec2( .11,-.22)); D\n    v = line(U, vec2(-.03, .05),vec2(-.12, .25)); D\n    U -= d = vec2(-.22,.12); if(x+1.5*y>.21) v = length(U) -.25, D // beak\n    U += d;\n    d -= vec2(.09,.03);\n    U -= d; if(x+1.5*y>.08) v = length(U) -.25, D\n    U += d;\n    \n    U.y += 1.3;                                        // body\n    float r = length(U), a = abs(atan(U.x,U.y)); y = r-1.;\n    \n    x = 1.3*a,  v = .5*F;              D\n    x = 1.4*a,  v = .5*F - .1;         D\n // if ( abs(v)/fwidth(v) > 6.*R.y/288. ) {\n    c = clamp( abs(v)/fwidth(v) / ( 2.*R.y/288.)-2.5,0.,1.); {\n        x = 1.6*a,  v = .3*F - .1;     D\n        x = 1.7*a,  v = .3*F - .2;     D\n        x = 1.9*a,  v = .3*F - .3;     D\n    } c=1.;\n    x = abs(U.x), y = U.y-.3; r = sqrt(x*x+y*y);       // tail\n    if ( r < .5) { \n        v = .2/x - y -1.; D\n        v = .1/x - y -1.; D\n    }\n    if ( y < -.33 ) v = r -.47,        D\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 249, 249, 377]], "test": "untested"}
{"id": "fdtSWM", "name": "HOLHO Fish", "author": "shau", "description": "HOLHO holographic renderer with a fish. See HOLHO viewers https://holhocollection.com", "tags": ["fish", "holho"], "likes": 5, "viewed": 331, "published": 3, "date": "1633363001", "time_retrieved": "2024-07-30T18:58:02.494438", "image_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n * Simple animation of fish for a HOLHO viewer \n * Official HOLHO 4 viewer used to test this animation\n * https://holhocollection.com/#group_4177-1\n * Tested on official iPhone Shadertoy App using High Quality settings\n * Adjust BOXWIDTH,BOXHEIGHT and CENTERBOX (offset) to suite your device\n * Make your own HOLHO viewer \n * https://www.youtube.com/watch?v=Xhu-XjXa4p4\n */\n\n//THIS BUFFER TRANSLATES OUTPUT OF BUFFERS TO 4 VIEWS\n//Most examples I have seen use a single scene projected onto 4 faces of viewer\n//Set below to 1 to use individual (front,right,rear,left) projected views \n//onto each face of viewer\n#define USE_PROJECTIONS 1\n\nvec3 renderBox(sampler2D tx, ivec2 iU, vec2 uv, ivec2 u)\n{\n    if (uv.y>0.0 && abs(uv.x)<uv.y)\n    {\n        return texelFetch(tx,u,0).xyz; \n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0);\n    ivec2 iU = ivec2(U),\n          imageBox = imageDimensions(R);\n    vec2 uv = (U - R*.5) / R.y;\n    \n    //TOP BOX\n    ivec4 box = ivec4(int(R.x)/2-imageBox.x/2,\n                      int(R.x)/2+imageBox.x/2, \n                      int(R.y)/2+CENTERBOX/2,\n                      int(R.y)/2+CENTERBOX/2+imageBox.y);\n    #if USE_PROJECTIONS==1 \n    //projected rear view\n    col += renderBox(iChannel2,\n                     iU,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     iU,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #endif\n    \n    //RIGHT BOX\n    box = ivec4(int(R.x)/2+CENTERBOX/2,\n                int(R.x)/2+CENTERBOX/2+imageBox.y, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected right view\n    col += renderBox(iChannel1,\n                     iU,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     iU,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #endif\n    \n    //BOTTOM BOX\n    box = ivec4(int(R.x)/2-imageBox.x/2,\n                int(R.x)/2+imageBox.x/2, \n                int(R.y)/2-CENTERBOX/2-imageBox.y,\n                int(R.y)/2-CENTERBOX/2);\n    //default front view - also default projection\n    col += renderBox(iChannel0,\n                     iU,\n                     vec2(uv.x,-uv.y),\n                     ivec2(box.y-iU.x,\n                           box.w-iU.y));\n    \n    //LEFT BOX                        \n    box = ivec4(int(R.x)/2-CENTERBOX/2-imageBox.y,\n                int(R.x)/2-CENTERBOX/2, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected left view\n    col += renderBox(iChannel3,\n                     iU,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     iU,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #endif\n\n    C = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-------\n\n#define PI 3.141592\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 100.0\n#define FL 2.6\n\n//WIDTH OF RENDERING\n#define BOXWIDTH 1250\n//SIZE OF CENTER OFFSET IN X AND Y\n#define CENTERBOX 100\n\n//RAYMARCHING AND SHADER IN COMMON TO HANDLE CASES THAT NEED\n//MULTIPLE CAMERA ANGLES (ALSO MULTIPLE BUFFERS)\n\n/* MODEL START */\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//SDF functions IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.y, max(abs(p.z)-le,0.0), p.x );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    float s = step(a.x,b.x);\n    return s*a + (1.0-s)*b;\n}\n\n//fishy\nvec2 map(vec3 p, float T) \n{\n    p.z += sin(p.x*0.5+T*1.7)*0.5;\n    vec3 q = p;\n    float nz = n3D(p*7.0)*0.03*\n               smoothstep(1.3,0.0,abs(p.y))*\n               smoothstep(2.4,0.0,abs(p.x+2.0));\n    float body = max(sdEllipsoid(p,vec3(4.8,1.2,0.6+nz)),p.x);\n    body = min(body,sdEllipsoid(p,vec3(2.2,1.2,0.6+nz)));\n    //mouth\n    body = smin(body,sdLink(p-vec3(2.18,-0.1,0.0),0.08,0.14,0.1),0.1);    \n    //vertical fins\n    //top bottom fins\n    q.z += sin(q.y*3.0+T*3.0)*0.1*smoothstep(0.8,2.0,abs(q.y));\n    float fins = max(sdCappedCylinder(q.xzy-vec3(-1.8,0.0,0.0),2.2,0.02),\n                    -sdCappedCylinder(q.xzy-vec3(-4.6,0.0,0.0),3.4,0.1)); \n    //tail\n    fins = min(fins,sdCappedCylinder(q.xzy-vec3(-6.0,0.0,0.0),1.6,0.02));\n    fins = max(fins,-sdCappedCylinder(q.xzy-vec3(-7.8,0.0,0.0),2.8,0.2)); \n    q = p;\n    q.z = abs(q.z); \n    //gills\n    body = smax(body,-sdEllipsoid(q-vec3(0.4,0.0,0.4),vec3(0.5,0.7,0.26)),0.1);\n    body = smin(body,sdEllipsoid(q-vec3(0.6,0.0,0.38),vec3(0.6,0.8,0.26)),0.1);\n    //eyes\n    //bulge\n    vec2 xy = vec2(1.2,0.4);\n    body = smin(body,sdSphere(q-vec3(xy,0.0),0.6),0.3);\n    //cutout\n    body = smax(body,-length(p.xy-xy)+0.26,0.04);\n    //eyeball\n    float eye = sdSphere(q-vec3(xy,0.4),0.3);\n    float iris = sdSphere(q-vec3(xy,0.5),0.22);\n    //horizontal fins\n    q.yz *= rot(0.5);\n    q.y += sin(q.z*3.0+T*2.0)*0.1*smoothstep(0.6,1.6,abs(q.z));\n    float hFins = max(sdCappedCylinder(q-vec3(-3.0,0.0,0.0),1.6,0.02),\n                     -sdCappedCylinder(q-vec3(-5.6,0.0,0.0),3.0,0.1));\n    vec2 nr = near(vec2(body,1.0),vec2(fins,2.0));\n    nr = near(nr,vec2(hFins,3.0));\n    nr = near(nr,vec2(eye,4.0));\n    nr = near(nr,vec2(iris,5.0));\n    return nr;\n}\n\n/* MODEL END */\n\n/* COMMON RENDERING FOR ALL BUFFERS */\n\nvec3 normal(vec3 p, float T) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=0; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz,T).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n, float T) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=0; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d,T).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//IQ\n//https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( vec3 ro, vec3 rd, float mint, float tmax, int technique, float T )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, T ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec2 march(vec3 ro, vec3 rd, float T)\n{\n    float t = 0.0, id = 0.0;\n    for (int i=0; i<100; i++)\n    {\n        vec2 ns = map(ro+rd*t,T);\n        if (abs(ns.x)<EPS)\n        {\n            id = ns.y;\n            break;\n        }\n        t += ns.x;\n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    return vec2(t,id);\n}\n\n//colour me in\nvec3 render(vec3 ro, vec3 rd, float T)\n{\n    vec3 col = vec3(0),\n         lp = vec3(4.0,5.0,-3.0);\n    \n    vec2 ns = march(ro,rd,T);\n    if (ns.x>0.0)\n    {\n        vec3 p = ro+rd*ns.x; \n        vec3 n = normal(p,T);\n        vec3 ld = normalize(lp-p);\n        \n        vec3 sc = vec3(0.0);\n        if (ns.y==1.0)\n        {\n            //body\n            float m = (smoothstep(1.4,0.4,length(p-vec3(-1.4,0.0,0.0)))+\n                       smoothstep(1.0,0.0,abs(p.y))) *\n                       smoothstep(3.0,0.0,abs(p.x+1.6));\n            m += n3D(p*4.0)*0.2;\n                      \n            sc = mix(vec3(0.5,0.1,0.0),vec3(0.8,0.6,0.2),m);\n        }\n        if (ns.y==2.0)\n        {\n            //vfins\n            float m = smoothstep(1.3,0.0,length(p.xy-vec2(-5.4,0.0))); \n            m += smoothstep(2.2,0.0,length(p.xy-vec2(-1.8,0.0)));\n            m += n3D(p*4.0)*0.2;\n            sc = mix(vec3(0.5,0.1,0.0),vec3(0.8,0.6,0.2),m);\n        }\n        if (ns.y==3.0)\n        {\n            //hfins\n            float m = n3D(p*4.0)*0.2;\n            sc = mix(vec3(0.5,0.1,0.0),vec3(0.8,0.6,0.2),m);\n        }\n        if (ns.y==4.0)\n        {\n            sc = vec3(1.0,0.8,0.6);\n        }\n        \n        float ao = AO(p,n,T);\n        float sh = calcSoftshadow(p+n*EPS,ld,EPS,FAR,1,T);\n        float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),8.0);\n\n        col = sc * max(0.0,dot(ld,n));\n        col += vec3(0.7,0.9,1.0)*0.4*spec;\n        col *= ao*sh;\n        col += vec3(0.0,0.1,0.3)*0.04*max(0.0,-n.y);\n    }\n    return pow(col,vec3(0.3545));\n}\n\nivec2 imageDimensions(vec2 r)\n{\n    int a = min(BOXWIDTH,min(int(r.x),int(r.y)));\n    return ivec2(a,a/2);\n}\n\nvec3 camera(vec2 U, vec2 r, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - r*.5) / r.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}", "buffer_a_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER FRONT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER RIGHT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2+PI*0.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}", "buffer_b_inputs": [], "buffer_c_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER REAR VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2+PI);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}", "buffer_c_inputs": [], "buffer_d_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER LEFT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         la = vec3(0.0),\n         ro = vec3(0.0,0.0,-6.5);\n    ro.xz *= rot(iTime*-0.2+PI*1.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = render(ro,camera(U,vec2(imageBox),ro,la,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtSWM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[812, 812, 870, 870, 982], [984, 984, 1022, 1022, 3558]], "test": "untested"}
{"id": "fddXW7", "name": "inktober 02 - suit", "author": "pali6", "description": "♥♣l", "tags": ["sdf", "heart", "cards", "suits"], "likes": 5, "viewed": 273, "published": 3, "date": "1633361628", "time_retrieved": "2024-07-30T18:58:03.351147", "image_code": "// Inktober 2021 - 02 - suit\n// by pali\n\n#define PI 3.141592\n#define A 0.4\n#define DEPTH 5\n#define XREP 8.\n\n#define ndot(x, y) normalize(dot(x, y))\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat triangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat rhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat heart(vec2 pos)\n{\n    pos -= vec2(0.1, 0.);\n    pos.x /= 0.9;\n    pos.y *= 0.9;\n    float r = 1e10;\n    r = min(r, distance(pos, vec2(0.25, 0.6)) - 0.2);\n    r = opSmoothUnion(r, distance(pos, vec2(0.75, 0.6)) - 0.2, 0.05);\n    r = opSmoothUnion(r, triangleIsosceles(pos - vec2(0.5, 0.), vec2(0.4, 0.65)), 0.4);\n    return r;\n}\n\nfloat spade(vec2 pos)\n{\n    float r = heart(vec2(pos.x, 1.1 - pos.y / 0.9));\n    pos -= vec2(0.1, 0.);\n    pos.x /= 0.9;\n    pos.y *= 0.9;\n    r = opSmoothUnion(r, triangleIsosceles(pos + vec2(-0.5, -0.25), vec2(0.2, -0.25)), 0.02);\n    return r;\n}\n\nfloat diamond(vec2 pos)\n{\n    return rhombus(pos - vec2(0.5, 0.5), vec2(0.4, 0.5));\n}\n\nfloat club(vec2 pos)\n{\n    float r = 1e10;\n    r = opSmoothUnion(r, distance(pos, vec2(0.5, 0.75)) - 0.22, 0.1);\n    r = opSmoothUnion(r, distance(pos, vec2(0.21, 0.38)) - 0.22, 0.05);\n    r = opSmoothUnion(r, distance(pos, vec2(0.79, 0.38)) - 0.22, 0.05);\n    r = opSmoothUnion(r, distance(pos, vec2(0.5, 0.5)) - 0.15, 0.05);\n    r = opSmoothUnion(r, triangleIsosceles(pos + vec2(-0.5, -0.4), vec2(0.15, -0.4)), 0.05);\n    return r;\n}\n\nvec2 nHeart(vec2 pos)\n{\n    float base = heart(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        heart(pos + vec2(d, 0)) - base,\n        heart(pos + vec2(0, d)) - base\n    ));\n}\n\nvec2 nSpade(vec2 pos)\n{\n    float base = spade(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        spade(pos + vec2(d, 0)) - base,\n        spade(pos + vec2(0, d)) - base\n    ));\n}\n\nvec2 nDiamond(vec2 pos)\n{\n    float base = diamond(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        diamond(pos + vec2(d, 0)) - base,\n        diamond(pos + vec2(0, d)) - base\n    ));\n}\n\nvec2 nClub(vec2 pos)\n{\n    float base = club(pos);\n    float d = 0.001;\n    return normalize(vec2(\n        club(pos + vec2(d, 0)) - base,\n        club(pos + vec2(0, d)) - base\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = 2. * (uv - vec2(0.5));\n    pos.x /= iResolution.y / iResolution.x;\n    pos.x += 0.1;\n    pos /= 0.9;\n    pos = pos / 2. + vec2(0.5);\n    \n    float v = heart(pos);\n    vec2 norm = nHeart(pos);\n    bool col = false;\n    \n    for(int i = 0; i < DEPTH; i++)\n    {\n        if(v < 0.)\n        {\n            if(col)\n                fragColor = vec4(0, 0, 0, 1);\n            else\n                fragColor = vec4(1, 0, 0, 1);\n            return;\n        }\n        if(v > 2. * A)\n            break;\n        float y = v / A;\n        float ang = atan(norm.y, norm.x) + iTime * 0.1;\n        float bigx = XREP * ang / (2. * PI);\n        float x = fract(bigx);\n        x = x / 0.5 - 0.25;\n        int xPart = int(bigx);\n        if(xPart % 2 == 0)\n            col = !col;\n        int asd = (xPart / 2) % 2;\n        pos = vec2(x, y);\n        pos = vec2(0.5, 0.5) + (pos - vec2(0.5, 0.5));\n        if(col)\n        {\n            if(asd == 0)\n            {\n            v = spade(pos);\n            norm = nSpade(pos);\n            }\n            else\n            {\n                v = club(pos);\n                norm = nClub(pos);\n            }\n        }\n        else\n        {\n            if(asd == 0)\n            {\n                v = heart(pos);\n                norm = nHeart(pos);\n            }\n            else\n            {\n                v = diamond(pos);\n                norm = nDiamond(pos);\n            }\n        }\n    }\n    \n    fragColor = vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 201, 201, 300], [302, 302, 351, 351, 659], [661, 661, 701, 701, 896], [898, 898, 921, 921, 1231], [1233, 1233, 1256, 1256, 1481], [1483, 1483, 1508, 1508, 1568], [1570, 1570, 1592, 1592, 2005], [2007, 2007, 2030, 2030, 2196], [2198, 2198, 2221, 2221, 2387], [2389, 2389, 2414, 2414, 2586], [2588, 2588, 2610, 2610, 2773], [2775, 2775, 2832, 2832, 4332]], "test": "untested"}
{"id": "NdtXDM", "name": "Limit of Flux Phases", "author": "zovox", "description": "Limit of Flux Phases\n\nThe definition for 3-phase flux is given at the top of the code.\n\nThis just does it for other phase numbers.", "tags": ["limitoffluxphase"], "likes": 1, "viewed": 233, "published": 3, "date": "1633352234", "time_retrieved": "2024-07-30T18:58:04.110118", "image_code": "#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy*2.0-1.0)*GR;\n    \n    const float max_phases = 16.;\n    const float min_phases = 1.;\n    float phases = (max_phases-min_phases)*(saw(iTime/PI/GR/E))+min_phases;\n    uv.x /= phases;\n    vec3 color = vec3(0.);\n    for(float phase = 0.; phase < max_phases; phase += 1.)\n    {\n        if(phase > phases)\n            break;\n        vec2 p2 = vec2(uv.x, cos(uv.x*phases*PI+phase*PI/phases*2.));\n        float line = 1.-smoothstep(0., 1./PI/GR/E, length(uv-p2));\n        color += flux(line+phase+uv.x)*line;\n    }\n    color += 1.-smoothstep(0., 1./PI/GR/E, saw(uv.x*phases*2.));\n    color = cos((vec3(1.-smoothstep(0., 1./PI/GR/E, saw(uv.y*2.)))+color)/2.*PI)*.5+.5;\n    fragColor.rgb = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 167, 167, 272], [274, 274, 292, 292, 327], [328, 328, 346, 346, 391], [392, 392, 410, 410, 465], [467, 467, 524, 524, 1253]], "test": "untested"}
{"id": "sd3XD7", "name": "Monte carlo double slit", "author": "copperbotte", "description": "importance samples a pair of slits using huygens principle", "tags": ["physics"], "likes": 2, "viewed": 284, "published": 3, "date": "1633332480", "time_retrieved": "2024-07-30T18:58:04.861110", "image_code": "\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        hsv.yz /= hsv.z;\n    \n    return hsv2rgb(hsv);\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n// importance sample the rectangle\n// xy is the center of the rectangle, wh is the dimensions\nvec2 iSample_rect(vec2 ap_xy, vec2 wh)\n{\n    vec2 xi = vec2(rnd(), rnd());\n    vec2 uv = xi - 0.5;\n    return ap_xy + wh*uv;\n}\n\n// importance sample a circle\nvec2 iSample_circle(vec2 xy, float radius)\n{\n    vec2 xi = vec2(rnd(), rnd());\n    float r = radius*sqrt(xi[0]);\n    float t = 2.0 * 3.141592 * xi[1];\n    return xy + r*vec2(cos(t), sin(t));\n}\n\nfloat iSample_rect_amp(vec2 xy, vec3 dir, vec2 ap_xy, vec2 wh, float dist, float c, float lambda)\n{\n    // find a random sample in the slit\n    vec2 uv = iSample_rect(ap_xy, wh);\n\n    // find the distance between the destination point xy and the source point uv\n    float radius = length(vec3(xy, dist) - vec3(uv, 0.0));\n    float k = 2.0 * 3.141592 * (c / lambda);\n    \n    // find the positional phase difference\n    float phase = dot(dir.xy, uv);\n    \n    // find the wave amplitude at this point\n    float amp = cos(k * (radius + phase)) / (radius * radius);\n    return amp;\n}\n\nfloat iSample_circle_amp(vec2 xy, vec3 dir, vec2 ap_xy, float r, float dist, float c, float lambda)\n{\n    // find a random sample in the slit\n    vec2 uv = iSample_circle(ap_xy, r);\n\n    // find the distance between the destination point xy and the source point uv\n    float radius = length(vec3(xy, dist) - vec3(uv, 0.0));\n    float k = 2.0 * 3.141592 * (c / lambda);\n    \n    // find the positional phase difference\n    float phase = dot(dir.xy, uv);\n    \n    // find the wave amplitude at this point\n    float amp = cos(k * (radius + phase)) / (radius * radius);\n    return amp;\n}\n\n// find a random amplitude for this destination point\nfloat amplitude(vec2 xy)\n{\n    float dist = 0.05;\n    float dx = sin(iTime / 5.0);\n    \n    vec3 dir = normalize(vec3(0.0,0.0,1.0));\n    \n    float c = 1.0;\n    float lambda = 0.1;\n    \n    float Out = 0.0;\n    const int samples = 1280;\n    const float fsamples = float(samples);\n    for(int i=0; i<samples; ++i)\n    {\n        vec2 wh = vec2(0.0001,1.0);\n        float radius = 0.001;\n        Out += iSample_rect_amp(xy, dir, vec2(-dx/2.0,0.0), wh, dist, c, lambda);\n        //Out += iSample_circle_amp(xy, dir, vec2(-dx/2.0,0.0), radius, dist, c, lambda);\n        \n        Out += iSample_rect_amp(xy, dir, vec2(dx/2.0,0.0), wh, dist, c, lambda);\n        //Out += iSample_circle_amp(xy, dir, vec2(dx/2.0,0.0), radius, dist, c, lambda);\n        \n        //Out += iSample_circle_amp(xy, dir, vec2(0.0,dx/2.0), radius, dist, c, lambda);\n        //Out += iSample_circle_amp(xy, dir, vec2(0.0,-dx/2.0), radius, dist, c, lambda);\n    }\n    \n    return Out / (fsamples * 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Correct for aspect ratio, convert so 0 is the center\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    // Generate random seed\n    seed = fract(iTime) + iResolution.y * uv.x + uv.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = srgb2lsrgb(texture(iChannel0, xy).xyz);\n    float amp = amplitude(xy);\n    col *= amp*amp;\n\n    // Output to screen\n    fragColor = vec4(lsrgb2srgb(saturationClip(col)),1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3XD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 35, 35, 162], [164, 164, 196, 196, 276], [278, 278, 311, 311, 431], [433, 433, 464, 464, 541], [543, 621, 648, 648, 999], [1001, 1001, 1028, 1028, 1204], [1206, 1206, 1240, 1240, 1351], [1353, 1445, 1458, 1458, 1501], [1503, 1597, 1637, 1637, 1723], [1725, 1755, 1799, 1799, 1947], [1949, 1949, 2048, 2088, 2529], [2531, 2531, 2632, 2672, 3114], [3116, 3170, 3196, 3196, 4141], [4143, 4143, 4200, 4250, 4791]], "test": "untested"}
{"id": "sdcSW7", "name": "basic path tracer", "author": "icantcomeupwithausername", "description": "basic monte carlo path tracer", "tags": ["reflection", "refraction", "pathtracer", "srgb", "multipass"], "likes": 29, "viewed": 609, "published": 3, "date": "1633322862", "time_retrieved": "2024-07-30T18:58:05.725798", "image_code": "vec4 tosRGB(vec4 rgb){\n    bvec4 c = lessThan(rgb, vec4(0.0031308));\n    vec4 h = vec4(1.055)*pow(rgb, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 l = rgb * vec4(12.92);\n    return mix(h,l,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = tosRGB(texture(iChannel0,uv));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define clearColor vec3(0.051)\n#define bounces 32\n#define samples 4\n#define far 9e20\n#define pi acos(-1.0)\n#define tau pi*2.0\n#define MATERIALTYPE_DIFFUSE 1\n#define MATERIALTYPE_GLASS 2\n#define GLASS_IOR 2.5\n\nfloat seed;\n\n/*\n * structs\n */\n\nstruct Ray{\n    vec3 origin, direction;\n};\n\nstruct Material{\n    int type;\n    float roughness, reflectance;\n    vec3 color, emmision;\n};\n\nstruct Raycastresult{\n    bool hit;\n    vec3 normal, position;\n    Material material;\n};\n\nstruct Box{\n    vec3 position, size, rotation;\n    Material material;\n};\n\nstruct Sphere{\n    float diameter;\n    vec3 position;\n    Material material;\n};\n\n//for point moving\nvec3 mp(Ray ray,float d){\n\treturn ray.origin+ray.direction*d;\n}\n\n/*\n * fresnel approximation\n */\n \nfloat fresnel(float na,float nb,vec3 incidence,vec3 normal,float min,float max){\n    float r = pow((na-nb)/(na+nb),2.0);\n    float cx = -dot(normal,incidence);\n\t\t\t\t\n    if(na>nb){\n        float q = na/nb;\n        float s2 = pow(q,2.0)*(1.0-pow(cx,2.0));\n        if(s2>1.0) return max;\n        cx = sqrt(1.0-s2);\n    }\n\t\t\t\t\n\tfloat x = 1.0-cx;\n\tfloat ret = r+(1.0-r)*pow(x,5.0);\n\treturn mix(min,max,ret);\n}\n\n/*\n * rotation matrix functions\n */\n\nmat4 rotateY(float rotation){\n    rotation = radians(rotation);\n\tfloat ys = sin(rotation);\n\tfloat yc = cos(rotation);\n\tfloat yoc = 1.0-yc;\n\treturn mat4(yc,0.0,ys,0.0,\n\t\t\t\t0.0,yoc+yc,0.0,0.0,\n\t\t\t\t-ys,0.0,yc,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\nmat4 rotateX(float rotation){\n    rotation = radians(rotation);\n\tfloat xs = sin(rotation);\n\tfloat xc = cos(rotation);\n\tfloat xoc = 1.0-xc;\n\treturn mat4(xoc+xc,0.0,0.0,0.0,\n\t\t\t    0.0,xc,-xs,0.0,\n\t\t\t\t0.0,xs,xc,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\nmat4 rotateZ(float rotation){\n    rotation = radians(rotation);\n    float zs = sin(rotation);\n    float zc = cos(rotation);\n    float zoc = 1.0-zc;\n\treturn mat4(zc,zs,0.0,0.0,\n\t\t\t    -zs,zc,0.0,0.0,\n\t\t\t\t0.0,0.0,zoc+zc,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\n/*\n * intersection functions\n * https://iquilezles.org/articles/intersectors\n */\n \nvec4 box(Ray ray,Box box) {\n    mat4 translate = mat4(1.0,0.0,0.0,0.0,\n                          0.0,1.0,0.0,0.0,\n                          0.0,0.0,1.0,0.0,\n                          box.position,1.0)*rotateX(box.rotation.x)*rotateY(box.rotation.y)*rotateZ(box.rotation.z);\n\n    vec3 q = (inverse(translate)*vec4(ray.origin,1.0)).xyz;\n    vec3 m = 1.0/(inverse(translate)*vec4(ray.direction,0.0)).xyz; \n    vec3 n = m*q;  \n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tn = max(max(t1.x,t1.y),t1.z);\n    float tf = min(min(t2.x,t2.y),t2.z);\n    if(tn>tf||tf<0.0) return vec4(-1.0); //ray missed\n    vec3 normal = sign(q)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec4(normal,tn);\n}\n\nfloat sphere(Ray ray,Sphere sphere){\n\tvec3 rc = ray.origin-(sphere.position/2.0);\n\tfloat b = dot(rc,ray.direction);\n\tfloat c = dot(rc,rc)-pow(sphere.diameter/2.0,2.0);\n\tfloat t = pow(b,2.0)-c;\n\tif(t>0.0) return -b-sqrt(t);\n\treturn t;\n}\n\n/*\n * hashes\n */\n \nvec3 h3() {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n \nvec2 h2(){\n\treturn fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\t\t\t\nfloat h(){\n\treturn fract(sin(seed+=0.1)*43758.5453123);\n}\n\n/*\n * sampling \n */\n \nvec3 cosineWeightedSample(vec3 normal){\n\tvec2 random = h2();\n\tvec3 u = normalize(cross(normal,vec3(1.0,1.0,1.0)));\n\tvec3 v = cross(u,normal);\n\tfloat a = sqrt(random.y);\n\tfloat x = a*cos(tau*random.x); \n\tfloat y = a*sin(tau*random.x);\n\tfloat z = sqrt(1.0-random.y);\n\treturn normalize(vec3(x*u+y*v+z*normal));\n}\n\n//crude ray offset\nvec3 offset(vec3 direction,vec3 multiplier){\n    vec3 random = h3()*multiplier-multiplier/2.0;\n    return normalize(direction+random);\n}\n\n/*\n * scene definition of objects\n */\n \n                                  //material: type, roughness, reflectance, color, emmision\nSphere balls[5] = Sphere[5](\n    Sphere(1.68748,vec3(1.8502,1.68748,-0.10162),Material(MATERIALTYPE_DIFFUSE,0.0,40.0,vec3(0.8),vec3(0.0))),\n    Sphere(1.0,vec3(-0.95827,1.0,-2.8441),Material(MATERIALTYPE_DIFFUSE,0.0,0.0,vec3(0.8),vec3(0.0))),\n    Sphere(0.6,vec3(-1.7301,0.6,0.0),Material(MATERIALTYPE_DIFFUSE,0.4,40.0,vec3(0.051,0.296,1.0),vec3(0.0))),\n    Sphere(0.680,vec3(0.0,0.680,1.3341),Material(MATERIALTYPE_GLASS,0.0,0.0,vec3(0.8),vec3(0.0))),\n    Sphere(0.616,vec3(2.1417,0.616,2.9726),Material(MATERIALTYPE_DIFFUSE,0.4,40.0,vec3(1.0,1.0,0.0),vec3(0.0)))\n);\n\n        //box: position, size, rotation, material\nBox boxes[3] = Box[3](\n    Box(vec3(0.0),vec3(3.5,0.0,3.0),vec3(0.0,0.0,0.0),Material(MATERIALTYPE_DIFFUSE,0.0,0.0,vec3(0.8),vec3(0.0))),\n    Box(vec3(0.0,2.1,-3.0),vec3(3.5,2.1,0.0),vec3(0.0,0.0,0.0),Material(MATERIALTYPE_DIFFUSE,0.0,0.0,vec3(0.8),vec3(0.0))),\n    Box(vec3(-4.171,2.15,0.0),vec3(1.874,0.0,1.874),vec3(0.0,0.0,79.2),Material(MATERIALTYPE_DIFFUSE,0.0,0.0,vec3(1.0),vec3(4.1)))\n);\n\n/*\n * raycast function to test intersection with each object\n */\n\nRaycastresult raycast(Ray ray){\n    //will be used for depth testing\n    float depth = far;\n    Raycastresult hit;\n    \n    //test spheres\n    for(int i=0;i<balls.length();i++){\n\t\tSphere ball = balls[i];\n\t\tfloat bd = sphere(ray,ball);\n\t\tif(bd>0.0&&bd<depth){\n\t\t\tdepth = bd;\n\t\t\tvec3 position = mp(ray,bd);\n\t\t\tvec3 normal = normalize(position-(ball.position/2.0));\n\t\t\thit = Raycastresult(true,normal,position,ball.material);\n\t\t}\n\t}\n    \n    //test boxes\n    for(int i=0;i<boxes.length();i++){\n\t\tBox block = boxes[i];\n\t\tvec4 bd = box(ray,block);\n\t\tif(bd.w>0.0&&bd.w<depth){\n\t\t\tdepth = bd.w;\n\t\t\tvec3 position = mp(ray,bd.w);\n\t\t\tvec3 normal = bd.xyz;\n\t\t\thit = Raycastresult(true,normal,position,block.material);\n\t\t}\n\t}\n    \n    //if ray missed then return a empty raycast result\n    if(depth==far){\n        hit = Raycastresult(false,vec3(0.0),vec3(0.0),Material(MATERIALTYPE_DIFFUSE,0.0,0.0,vec3(0.0),clearColor));\n    }\n    \n    return hit;\n}\n\n/*\n * main pathtracing function\n */\n \nvec3 trace(Ray ray){\n    vec3 accumulator;\n    vec3 mask = vec3(1.0);\n    \n    //pathtracing loop\n    for(int i=0;i<bounces;i++){\n        //raycast\n        Raycastresult result = raycast(ray);\n        \n        //accumulate color\n        accumulator+=mask*result.material.emmision;\n\t\tmask*=result.material.color;\n        \n        //if ray hit a light or missed then stop\n        if(result.hit==false||length(result.material.emmision)>0.0) break;\n        \n        //create ray direction based on material\n        switch(result.material.type){\n            case MATERIALTYPE_DIFFUSE:\n                //randomly reflect if material has any reflectance value\n                if(fresnel(1.0,GLASS_IOR,ray.direction,result.normal,0.0,1.0)*result.material.reflectance>h()){\n                    ray.origin = result.position+result.normal*1e-4;\n                    ray.direction = reflect(ray.direction,result.normal);\n                    \n                    //offset ray direction based on roughness\n                    ray.direction = offset(ray.direction,vec3(result.material.roughness));\n                }else{\n                    ray.origin = result.position+result.normal*1e-4;\n\t\t\t\t\tray.direction = cosineWeightedSample(result.normal);\n                }\n            break;\n            case MATERIALTYPE_GLASS:\n                //randomly reflect for fresnel\n                if(fresnel(1.0,GLASS_IOR,ray.direction,result.normal,0.0,1.0)-0.07>h()){\n                    ray.origin = result.position+result.normal*1e-4;\n                    ray.direction = reflect(ray.direction,result.normal);\n                }else{\n                    ray.origin = result.position+ray.direction*1e-4;\n                    ray.direction = refract(ray.direction,result.normal,1.0/GLASS_IOR);\t\n                }\n\t\t\tbreak;\n        }\n    }\n    \n    return accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //variable to store color\n    vec3 col;\n    \n    //start seed\n    seed = uv.x+uv.y*3.43121412313+fract(1.12345314312*iTime);\n    \n    vec3 cpos = vec3(0.0,1.3,14.0);\n    \n    //accumulate samples\n    for(int i=0;i<samples;i++){\n        //jitter ray for anti ailiasing\n        vec3 rdir = normalize(vec3(uv,-5.8)+vec3(h2()*2.0/iResolution.y,h2()*2.0/iResolution.x));\n    \n        Ray ray = Ray(cpos,rdir);\n        \n        //trace\n        col += trace(ray);\n        \n        seed = mod(seed*1.1234567893490423,13.0);\n    }\n    \n    //get color average\n    col/=float(samples);\n    \n    if(iMouse.z<0.5){\n        vec3 pcol = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n        fragColor = vec4(mix(pcol,col,1.0/float(iFrame+1)),1.0);\n    }else{\n        fragColor = vec4(col,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcSW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 189], [191, 191, 245, 245, 334]], "test": "untested"}
{"id": "fs3XDM", "name": "Fluidic Boids", "author": "davidar", "description": "Combining boids with [url=https://michaelmoroz.github.io/Reintegration-Tracking/]reintegration tracking[/url]. Parameters cycle over time by default, edit defines in common shader to vary.", "tags": ["simulation", "fluid", "mipmap", "predator", "boids", "prey", "ecology"], "likes": 72, "viewed": 1757, "published": 3, "date": "1633321680", "time_retrieved": "2024-07-30T18:58:06.673265", "image_code": "//#define DEBUG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0,0,0,1);\n    vec2 uv = fragCoord / iResolution.xy;\n\n#ifdef DEBUG\n    if (uv.x < 0.25) {\n        vec4 data = textureLod(iChannel0, floor(fragCoord/16.)*16. / iResolution.xy, 4.);\n        vec2 vel = data.zw;\n\n        fragColor.rgb = .6 + .6 * cos(atan(vel.y,vel.x) + vec3(0,23,21));\n        \n        data = textureLod(iChannel1, fragCoord / iResolution.xy, 4.);\n    \tfragColor.rgb += 60. * length(data.zw);\n        return;\n    }\n#endif\n\n    vec4 data = texture(iChannel0, fragCoord / iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n    vec2 vel = P.V;\n\n    fragColor.rgb = .6 + .6 * cos(atan(vel.y,vel.x) + vec3(0,23,21));\n    fragColor.rgb *= sqrt(clamp(P.M, 0., 1.));\n\n#ifdef DEBUG\n    data = texture(iChannel1, fragCoord / iResolution.xy);\n    for(int i = -2; i <= 2; i++) {\n        for(int j = -2; j <= 2; j++) {\n            vec4 data = texture(iChannel1, (fragCoord + vec2(i,j)) / iResolution.xy);\n            if(data.x > 0.001) {\n                fragColor.rgb += 0.4 * exp(-pow(distance(data.xy, fragCoord), 2.) / 2.);\n                return;\n            }\n        }\n    }\n#endif\n    if (0.00 < uv.y && uv.y < 0.01 && 5.*uv.x < ALIGNMENT)  fragColor += 0.5;\n    if (0.01 < uv.y && uv.y < 0.02 && 5.*uv.x < SEPARATION) fragColor += 0.5;\n    if (0.02 < uv.y && uv.y < 0.03 && 5.*uv.x < COHESION)   fragColor += 0.5;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Prey (boids with fluidic characteristics)\n\n#define MAX_SPEED 0.9\n#define MAX_FORCE 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    if(iFrame < 10) {\n        float q = 2.*PI * hash12(1. + fragCoord);\n        particle P;\n        P.X = fragCoord;\n        P.V = MAX_SPEED * vec2(cos(q), sin(q));\n        P.M = 1.;\n        fragColor = saveParticle(P, fragCoord);\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    particle P = getParticle(data, fragCoord);\n\n    if(P.M < 0.01) {\n        P.X = fragCoord;\n        P.V = vec2(0);\n        P.M = 0.05;\n    }\n    \n    vec2 pos = P.X;\n    vec2 vel = P.V;\n\n    float nCount = 0.;\n\n    vec2 alignment = vec2(0);\n    vec2 cohesion = vec2(0);\n    vec2 separation = vec2(0);\n\n    for(int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++) {\n        for(int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++) {\n            vec2 ij = vec2(i,j);\n            if(ij == vec2(0) || length(ij) > float(NEIGHBOR_DIST)) continue;\n\n            vec4 data2 = texture(iChannel0, fract((fragCoord + ij) / iResolution.xy));\n            particle P2 = getParticle(data2, fragCoord + ij);\n            vec2 pos2 = P2.X;\n            vec2 vel2 = P2.V;\n            float m = P2.M;\n\n            separation += m * normalize(pos - pos2) / distance(pos, pos2);\n\n            alignment += m * vel2;\n            cohesion += m * pos2;\n            nCount += m;\n\n            // nearby predators\n            data2 = textureLod(iChannel1, fract((fragCoord + ij) / iResolution.xy), 0.);\n            if(data2.x > 0.001) separation += normalize(pos - data2.xy);\n\n            // distant predators\n            vec2 coord = fragCoord + 16. * ij;\n            data2 = textureLod(iChannel1, fract(coord / iResolution.xy), 4.);\n            vel2 = data2.zw;\n            separation += normalize(pos - coord) * length(vel2);\n        }\n    }\n    \n    if (nCount > 0.) cohesion = cohesion / float(nCount) - pos;\n\n    if(cohesion != vec2(0)) cohesion = clamp_length(\n        MAX_SPEED * normalize(cohesion) - vel, MAX_FORCE);\n    if(alignment != vec2(0)) alignment = clamp_length(\n        MAX_SPEED * normalize(alignment) - vel, MAX_FORCE);\n    if(separation != vec2(0)) separation = clamp_length(\n        MAX_SPEED * normalize(separation) - vel, MAX_FORCE);\n\n    vel += alignment * ALIGNMENT;\n    vel += separation * SEPARATION;\n    vel += cohesion * COHESION;\n    vel -= 0.1 * textureLod(iChannel0, fragCoord / iResolution.xy, 7.).zw; // zero out average velocity of swarm\n    P.V = clamp_length(vel, MAX_SPEED);\n    fragColor = saveParticle(P, fragCoord);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// reintegration tracking code from https://www.shadertoy.com/view/ttBcWm\n#define Bi(p) ivec2(mod(p,iResolution.xy))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, DIFFUSION);\n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n        P.V /= P.M;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    particle P;\n    Reintegration(iChannel0, P, fragCoord);\n    fragColor = saveParticle(P, fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Predators (classic boids)\n\n#define MAX_SPEED 1.2\n#define MAX_FORCE 0.1\n#define DESIRED_SEPARATION 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    if(iFrame < 10) {\n        if(hash12(fragCoord) < 0.001) {\n            float q = 2.*PI * hash12(1. + fragCoord);\n            fragColor = vec4(fragCoord.xy, cos(q), sin(q));\n        }\n        return;\n    }\n    \n    vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n\n    if(data == vec4(0)) {\n        if (length(hash33(vec3(fragCoord, iFrame))) < 0.015) {\n            data = vec4(fragCoord, 0, 0);\n        } else {\n            return;\n        }\n    }\n    \n    vec2 pos = data.xy;\n    vec2 vel = data.zw;\n\n    vec2 separation = vec2(0);\n\n    for(int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++) {\n        for(int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++) {\n            vec2 ij = vec2(i,j);\n            if(ij == vec2(0) || length(ij) > float(NEIGHBOR_DIST)) continue;\n\n            vec4 data2 = textureLod(iChannel0, fract((fragCoord + ij) / iResolution.xy), 0.);\n            if(data2.x > 0.001 && distance(pos, data2.xy) < float(DESIRED_SEPARATION))\n                separation += normalize(pos - data2.xy) / distance(pos, data2.xy);\n\n            // nearby prey\n            data2 = texture(iChannel1, fract((fragCoord + ij) / iResolution.xy));\n            particle P2 = getParticle(data2, fragCoord + ij);\n            separation -= P2.M * normalize(pos - P2.X);\n\n            // distant prey\n            vec2 coord = fragCoord + 16. * ij;\n            data2 = textureLod(iChannel1, fract(coord / iResolution.xy), 4.);\n            //vec2 vel2 = data2.zw;\n            //separation -= normalize(pos - coord) * length(vel2);\n            float m = data2.y;\n            separation -= normalize(pos - coord) * m;\n        }\n    }\n\n    vel = MAX_SPEED * normalize(vel + MAX_FORCE * normalize(separation));\n    pos = mod(pos + vel, iResolution.xy);\n    fragColor = vec4(pos, vel);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0);\n    for(int i = -2; i <= 2; i++) {\n        for(int j = -2; j <= 2; j++) {\n            vec4 data = texture(iChannel0, fract((fragCoord + vec2(i,j)) / iResolution.xy));\n            if(abs(data.x - fragCoord.x) < 0.5 && abs(data.y - fragCoord.y) < 0.5) {\n                fragColor = data;\n                return;\n            }\n        }\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NEIGHBOR_DIST 6\n#define DIFFUSION     1.12\n#define ALIGNMENT     (0.7 + 0.3 * cos(PI * iTime/5.))\n#define SEPARATION    (0.7 + 0.3 * cos(PI * iTime/6.))\n#define COHESION      (0.7 + 0.3 * cos(PI * iTime/7.))\n\n///\n\n#define PI 3.14159265359\n\nvec2 clamp_length(vec2 v, float r) {\n    if(length(v) > r) return r * normalize(v);\n    return v;\n}\n\nuint pack(vec2 x)\n{\n    x = 65535.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65535.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P;\n    if (data == vec4(0)) return P;\n    P.X = decode(data.x) + pos;\n    P.M = data.y;\n    P.V = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    vec2 x = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(x), P.M, P.V);\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3XDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 1432]], "test": "untested"}
{"id": "7dcSW7", "name": "fork fractal", "author": "jorge2017a2", "description": "fork fractal", "tags": ["forkfractal"], "likes": 25, "viewed": 460, "published": 3, "date": "1633311898", "time_retrieved": "2024-07-30T18:58:07.629708", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//modificado por jorge flores!!! :)\n//referencia\n//https://www.shadertoy.com/view/wllSR4\n//Created by joeedh in 2019-07-05\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat fractal(vec3 co)\n{\n  vec3 center = vec3(1.0);\n    vec3 co2 = co;\n    int i;\n    float f;\n    #define DSCALE 2.5 //2.5//scale per fractal level\n    \n    float th=0.0, thscale = 1.3, dscale = DSCALE;\n    float k = 0.0, fi=0.0;\n\n    float s =sdSphere(co2, 0.5);\n    #define IFSSTEPS 4\n    \n    float scale = dscale;\n    vec3 color;\n    \n    for (i=0; i<IFSSTEPS; i++) \n    {   co2 = floor(co*scale + 0.5)/scale;\n        scale *= dscale;\n        co2 = (co - co2);\n        float s2= sdBox( co2, vec3(1.0/scale));\n        s=differenceSDF(s, s2);\n    }\n    return s;\n}\n\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n   p.y=p.y-5.0;\n    \n    float f1= fractal(p);\n    res =opU3(res, vec3(f1,1.0,-1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}     \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d)*light_color1;\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d)*light_color2;\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 );light_color2 =vec3(0.0,0.0,1.0 ); \n   \n   vec3 ro=vec3(0.0,5.0,-0.1);\n   ro.y+=0.125*cos(iTime*0.25);\n   ro.x+=0.0065*sin(iTime*0.000165);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, iTime);\n   \n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};   \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.0,1.0,1.0), //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 620, 620, 641], [642, 642, 674, 674, 758], [759, 803, 850, 850, 877], [878, 878, 921, 921, 948], [949, 949, 997, 997, 1025], [1026, 1091, 1125, 1125, 1221], [1222, 1222, 1256, 1256, 1347], [1348, 1348, 1382, 1382, 1473], [1474, 1474, 1508, 1508, 1603], [1606, 1606, 1630, 1630, 2173], [2176, 2176, 2201, 2201, 2444], [2446, 2446, 2470, 2470, 2632], [2634, 2634, 2683, 2683, 3350], [3352, 3352, 3388, 3388, 3633], [3635, 3635, 3662, 3662, 3679], [3681, 3681, 3717, 3717, 3809], [3810, 3810, 3856, 3856, 3981], [3983, 3983, 4020, 4020, 4289], [4291, 4291, 4358, 4358, 4635], [4637, 4637, 4720, 4720, 5639], [5641, 5641, 5734, 5734, 5864], [5866, 5866, 5898, 5898, 6095], [6097, 6145, 6173, 6173, 6361], [6363, 6363, 6410, 6410, 6641], [6643, 6643, 6736, 6736, 7077], [7079, 7079, 7110, 7110, 7735], [7737, 7737, 7763, 7763, 7873], [7875, 7875, 7933, 7933, 7985], [7987, 7987, 8044, 8044, 8647]], "test": "untested"}
{"id": "ss3SW7", "name": "Fast Raymarching w/ Reflections", "author": "N8Shader", "description": "A decent raymarcher with some tradeoffs for performance.", "tags": ["3d", "reflection", "primitives", "raymarcher"], "likes": 4, "viewed": 532, "published": 3, "date": "1633307779", "time_retrieved": "2024-07-30T18:58:08.503372", "image_code": "\n float sdSphere(vec3 p, vec3 c, float r) {\n        return length(p - c) - r;\n    }\n    float sdDiamond(vec3 p, vec3 c, float r) {\n        vec3 cVector = abs(p - c);\n        return (cVector.x + cVector.y + cVector.z) - r;\n    }\n    float sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}  \nfloat sdTorus( vec3 p, vec3 c, vec2 t )\n{\n  p = p - c;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 c, vec3 b )\n{\n  p = p - c;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( vec3 p, vec3 center, vec2 c, float h )\n{\n    p = p - center;\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nfloat sdBoxFrame( vec3 p, vec3 c, vec3 b, float e )\n{\n    p = p - c;\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat random(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    \n    float lb = random(i + vec2(0., 0.));\n    float rb = random(i + vec2(1., 0.));\n    float lt = random(i + vec2(0., 1.));\n    float rt = random(i + vec2(1., 1.));\n    \n    return mix(mix(lb, rb, f.x), \n               mix(lt, rt, f.x), f.y);\n}\n\n#define OCTAVES 8\nfloat fbm(vec2 uv)\n{\n    float value = 0.;\n    float amplitude = .5;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        value += noise(uv) * amplitude;\n        \n        amplitude *= .5;\n        \n        uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Sky(vec3 ro, vec3 rd)\n{\n    const float SC = 1e5;\n\n \t// Calculate sky plane\n    float dist = (SC - ro.y) / rd.y; \n    vec2 p = (ro + dist * rd).xz;\n    p *= 1.2 / SC;\n    \n    // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n    \n    vec3 cloudCol = vec3(1.);\n    //vec3 skyCol = vec3(.6, .71, .85) - rd.y * .2 * vec3(1., .5, 1.) + .15 * .5;\n    vec3 skyCol = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n    skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n    \n    // sun\n    vec3 sun = 0.25 * vec3(1.0,0.7,0.4) * pow( sundot,5.0 );\n    sun += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot,64.0 );\n    sun += 0.2 * vec3(1.0,0.8,0.6) * pow( sundot,512.0 );\n    skyCol += sun;\n    \n    // clouds\n    float t = iTime * 0.1;\n    float den = fbm(vec2(p.x - t, p.y - t));\n    skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n    \n    // horizon\n    skyCol = mix( skyCol,  vec3(0.45, 0.55, 0.75), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n    \n    return skyCol;\n}\nstruct Shifter {\n    vec3 position;\n    vec3 color;\n    float timeOffset;\n};\nShifter[9] shifters = Shifter[9](\n    Shifter(vec3(0.0, 0.0, 0.0), vec3(1.25, 0.0, 0.0), 0.0),\n    Shifter(vec3(5.0, 0.0, 0.0), vec3(0.0, 0.0, 1.25), 3.0),\n    Shifter(vec3(-5.0, 0.0, 0.0), vec3(0.0, 1.25, 0.0), 6.0),\n    Shifter(vec3(0.0, 0.0, -5.0), vec3(1.25, 1.25, 0.0), 1.0),\n    Shifter(vec3(5.0, 0.0, -5.0), vec3(0.0, 1.25, 1.25), 2.0),\n    Shifter(vec3(-5.0, 0.0, -5.0), vec3(1.25, 0.0, 1.25), 4.0),\n    Shifter(vec3(0.0, 0.0, 5.0), vec3(1.25, 0.65, 0.0), 5.0),\n    Shifter(vec3(5.0, 0.0, 5.0), vec3(0.0, 0.65, 1.25), 2.5),\n    Shifter(vec3(-5.0, 0.0, 5.0), vec3(0.0, 1.25, 0.65), 3.5)\n);\n    vec4 scene_dist(vec3 p) {\n        float obj_dist = 10000.0;\n        vec3 obj_color = vec3(1.0);\n        int s = 0;\n        float minDist = 10000.0;\n        for(int r= 0; r < shifters.length(); r++) {\n            float dist = length(p - shifters[r].position); \n            if (dist < minDist) {\n                s = r;\n                minDist = dist;\n            }\n        }\n        //for(int s = 0; s <= shifters.length(); s++) {\n        float s_dist = 0.0;\n        /*if (length(p - shifters[s].position) > 5.0) {\n            continue;\n        }*/\n        //float boxDist = length(shifters[s].position - p); //sdBox(p, shifters[s].position, vec3(1.0, 1.0, 1.0));\n        //if (boxDist > obj_dist) {\n            //continue;\n        //}\n       /*if (sdDiamond(p, shifters[s].position, 2.5) > obj_dist) {\n            continue;\n        }*/\n        /*if (time_period < 3.14 * 2.0) {\n            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdTorus(p, vec3(0.0, (sin(time / 1000.0)), 0.0) + 0.05, vec2(1.0, 0.1)), (sin(time / 1000.0) + 1.0) / 2.0);\n        } else if (time_period < 3.14 * 4.0) {\n            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdSphere(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), 1.0), (sin(time / 1000.0) + 1.0) / 2.0);\n        }*/\n        float time_period = mod(iTime + shifters[s].timeOffset, 5.0);\n        if (time_period <= 1.0) {\n            s_dist = mix(sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), time_period);\n        } else if (time_period <= 2.0) {\n            s_dist = mix(sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), sdSphere(p, shifters[s].position, 1.0), time_period - 1.0);\n        } else if (time_period <= 3.0) {\n            s_dist = mix(sdSphere(p, shifters[s].position, 1.0), sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0), time_period - 2.0);\n        } else if (time_period <= 4.0) {\n            s_dist = mix(sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0),  sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)), time_period - 3.0);\n        } else if (time_period <= 5.0) {\n            s_dist = mix(sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)),sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), time_period - 4.0);\n        }\n       //s_dist = sdSphere(p, shifters[s].position, 1.0);\n            obj_dist = s_dist;\n            obj_color =  shifters[s].color;\n    //}\n        float ground_dist = sdBox(p, vec3(0.0, -1.0, 0.0), vec3(9.5, 0.0, 9.5));\n        vec3 color;\n        if (ground_dist < obj_dist) {\n            color = vec3(0.75);\n            if (mod(round(p.x), 2.0) == mod(round(p.z), 2.0)) {\n                color = vec3(0.1);\n            }\n        } else {\n            color = obj_color;\n        }\n        return vec4(min(ground_dist, obj_dist), color);\n    }\n    vec3 calculate_normal(vec3 p) {\n        const vec3 step = vec3(0.001, 0.0, 0.0);\n        float gradX = scene_dist(p + step.xyy).x - scene_dist(p - step.xyy).x;\n        float gradY = scene_dist(p + step.yxy).x - scene_dist(p - step.yxy).x;\n        float gradZ = scene_dist(p + step.yyx).x - scene_dist(p - step.yyx).x;\n        return normalize(vec3(gradX, gradY, gradZ));\n    }\n    bool ray_march_hit(vec3 rayOrigin, vec3 rayDir) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 32;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n            vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n            float sceneDist = scene_dist(currPos).x;\n            if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                return true;\n            }\n            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                break;\n            }\n            distanceTravelled += sceneDist;\n        }\n        return false;\n    }\n    vec3 ray_march_diffuse(vec3 rayOrigin, vec3 rayDir, vec3 diffuse) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 64;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        const int BOUNCE_AMOUNTS = 3;\n        vec3 finalDiffuse = diffuse;\n        bool done = false;\n        for(int r = 0; r < BOUNCE_AMOUNTS; r++) {\n            if (done) {\n                break;\n            }\n            for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n                vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n                vec4 sceneData = scene_dist(currPos);\n                float sceneDist = sceneData.x;\n                vec3 sceneDiffuse = sceneData.yzw;\n                if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                    float addWeight = pow(0.5, float(r + 1));\n                    finalDiffuse = (1.0 - addWeight) * finalDiffuse + addWeight * sceneDiffuse;\n                    vec3 normal = calculate_normal(currPos);\n                    rayOrigin = currPos;\n                    rayDir = reflect(rayDir, normal);\n                    break;\n                }\n                if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                    done = true;\n                    break;\n                }\n                distanceTravelled += sceneDist;\n            }\n        }\n        finalDiffuse = 0.6 * Sky(rayOrigin, rayDir) + 0.4 * finalDiffuse;\n        return finalDiffuse;\n    }\n    vec3 ray_march(vec3 rayOrigin, vec3 rayDir) {\n        float distanceTravelled = 0.0;\n        const int NUMBER_OF_STEPS = 2048;\n        const float MINIMUM_HIT_DISTANCE = 0.001;\n        const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n        for(int i = 0; i < NUMBER_OF_STEPS; i++) {\n            vec3 currPos = rayOrigin + distanceTravelled * rayDir;\n            vec4 sceneData = scene_dist(currPos);\n            float sceneDist = sceneData.x;\n            vec3 sceneDiffuse = sceneData.yzw;\n            if (sceneDist < MINIMUM_HIT_DISTANCE) {\n                vec3 normal = calculate_normal(currPos);\n                vec3 lightPos = vec3(200.0, -500.0, 150.0);\n                vec3 dirToLight = normalize(currPos - lightPos);\n                float lightIntensity = max(0.2, dot(normal, dirToLight));\n                vec3 reflectDir = reflect(rayDir, normal);\n                sceneDiffuse = ray_march_diffuse(currPos + reflectDir * 0.002, reflectDir, sceneDiffuse);\n                if (ray_march_hit(currPos + dirToLight * 0.01, dirToLight)) {\n                    lightIntensity = 0.15;\n                }\n                return ((sceneDiffuse) / 2.0) * lightIntensity + 0.2 * vec3(1.0, 1.0, 1.0);\n            }\n            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {\n                break;\n            }\n            distanceTravelled += sceneDist;\n        }\n        return Sky(rayOrigin, rayDir);\n        \n    }\n    mat4 makeViewMatrix(vec3 eye, vec3 center, vec3 up) {\n        vec3 f = normalize(center - eye);\n        vec3 s = normalize(cross(f, up));\n        vec3 u = cross(s, f);\n        return mat4(\n            vec4(s, 0.0),\n            vec4(u, 0.0),\n            vec4(-f, 0.0),\n            vec4(0.0, 0.0, 0.0, 1)\n        );\n    }\n    vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n        vec2 xy = fragCoord - size / 2.0;\n        float z = size.y / tan(radians(fieldOfView) / 2.0);\n        return normalize(vec3(xy, -z));\n    }\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        vec3 viewDir = rayDirection(75.0, iResolution.xy, gl_FragCoord.xy);\n    vec3 eye =vec3(15.0 * sin(iTime), 7.5 + cos(iTime) * 5.0, 15.0 * cos(iTime));\n    \n    mat4 viewToWorld = makeViewMatrix(vec3(15.0 * sin(iTime), 7.5 + cos(iTime) * 5.0, 15.0 * cos(iTime)), vec3(0.0), vec3(0.0, 1.0, 0.0));\n   \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz; \n    vec3 shaded_color = ray_march(eye, worldDir);\n        fragColor = vec4(shaded_color, 1.0);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3SW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 43, 43, 83], [88, 88, 130, 130, 227], [232, 232, 265, 291, 322], [325, 325, 366, 366, 444], [445, 445, 484, 484, 584], [586, 586, 640, 640, 732], [733, 733, 786, 786, 1083], [1084, 1084, 1106, 1106, 1173], [1175, 1175, 1197, 1197, 1525], [1545, 1545, 1565, 1565, 1794], [1796, 1796, 1824, 1824, 2902], [3581, 3581, 3606, 3606, 6513], [6518, 6518, 6549, 6549, 6894], [6899, 6899, 6948, 6948, 7569], [7574, 7574, 7641, 7641, 9046], [9051, 9051, 9096, 9096, 10455], [10460, 10460, 10513, 10513, 10779], [10784, 10784, 10849, 10849, 10997], [11002, 11002, 11057, 11057, 11525]], "test": "untested"}
{"id": "7s3XDM", "name": "twisting log spiral disco", "author": "morisil", "description": "I generalized some previous sketches", "tags": ["spiral", "polar"], "likes": 7, "viewed": 308, "published": 3, "date": "1633297924", "time_retrieved": "2024-07-30T18:58:09.350108", "image_code": "// Fork of \"twisting log spiral\" by morisil. https://shadertoy.com/view/slSGDV\n// 2021-10-03 21:51:24\n\nconst float LOG_SCALE_MAX = 50.;\nconst float LOG_SCALE_PERIOD = .4;\nconst float ANGLE_SCALE = 4.;\nconst float ROTATION_SPEED = 10.;\n\n#define wave(x) (sin(x) + 1.) / 2.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    float dist = length(st);\n    float angle = atan(st.x, st.y);\n    float logDist = log(dist);\n    float logScale = sin(iTime * LOG_SCALE_PERIOD) * LOG_SCALE_MAX;\n    float luma = wave(\n        logDist * logScale + angle * ANGLE_SCALE - iTime * ROTATION_SPEED + sin(dist * 40.) + cos(angle * 40.)\n    );\n    fragColor = vec4(vec3(luma), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3XDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 327, 327, 772]], "test": "untested"}
{"id": "sscXWM", "name": "move light", "author": "jorge2017a2", "description": "move light", "tags": ["movelight"], "likes": 2, "viewed": 227, "published": 3, "date": "1633291199", "time_retrieved": "2024-07-30T18:58:10.291591", "image_code": "//por jorge2017a1\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0); \n    vec3 pp=p;\n    \n    float sds1=sdSphere(p-light_pos1+vec3(0.0,-5.0,0.0), 0.5 ) ;\n    float sds2=sdSphere(p-light_pos2+vec3(0.0,-5.0,0.0), 0.5 ) ;\n    res =opU3(res, vec3(sds1, 1.0,-1.0));\n    res =opU3(res, vec3(sds2, 1.0,-1.0));\n    \n    p.z= opRep1D(p.z, 6.0) ;\n     \n    p.y=p.y-10.0;\n    float dis=9999.0;\n    int i;\n    \n    float d=9999.9;\n    vec2 d2=vec2(999.99,-1.0);\n    float tz=mod(p.z,6.0);\n    if (tz==0.0)\n        p= rotate_x(p, radians(180.0));\n    else\n      p= rotate_x(p, radians(90.0));\n    \n    for (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = 1.0 * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n        float dx=mix(0.5, 1.0, fract(fi * 412.531 + 0.2124));\n        float dy=mix(0.1, 1.0, fract(fi * 512.531 + 0.2124));\n        float dz=mix(0.5, 2.0, fract(fi * 712.531 + 0.4124));\n        vec3 ppos= sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(5.0, 2.0, 1.0);\n\t\td = sdRoundBox(p + ppos+vec3(dx,dy,dz), vec3(dx,dy,dz+2.0) ,0.5);\n        d2=opU(d2,vec2(d, i));\n\t}\n    \n    res =opU3(res, vec3(d2.x, d2.y,-1.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}     \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    \n    vec3 col2=LightShading(norm,l,v,col);\n    color=(color+col2)/2.0;\n    return color*sh+ color*atten * occ;\n}\n\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=-4.0+mod(iTime*6.0,60.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0+t ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0+t ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(-2.0,15.0,-10.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(20.0));\n   \n    vec3 col= Render( ro,  rd);\n   col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//----------common\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};   \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 478, 514, 514, 535], [536, 536, 582, 582, 669], [671, 715, 762, 762, 789], [790, 790, 833, 833, 860], [861, 861, 909, 909, 937], [938, 976, 1012, 1012, 1057], [1058, 1123, 1157, 1157, 1253], [1254, 1254, 1288, 1288, 1379], [1380, 1380, 1414, 1414, 1505], [1506, 1506, 1540, 1540, 1635], [1637, 1637, 1658, 1658, 1730], [1732, 1732, 1757, 1757, 2881], [2883, 2883, 2907, 2907, 3069], [3071, 3071, 3120, 3120, 3787], [3788, 3788, 3824, 3824, 4069], [4071, 4071, 4098, 4098, 4115], [4117, 4117, 4153, 4153, 4245], [4246, 4246, 4292, 4292, 4417], [4419, 4419, 4456, 4456, 4732], [4734, 4734, 4801, 4801, 5078], [5080, 5080, 5163, 5163, 6082], [6085, 6085, 6178, 6178, 6308], [6310, 6310, 6342, 6342, 6539], [6541, 6589, 6617, 6617, 6805], [6808, 6808, 6901, 6901, 7072], [7074, 7074, 7105, 7105, 7704], [7706, 7706, 7732, 7732, 7842], [7844, 7844, 7902, 7902, 7954], [7956, 7956, 8013, 8013, 8561]], "test": "untested"}
{"id": "NdtXW8", "name": "Tumble", "author": "ruojake", "description": "A noisy ball of fur for your enjoyment", "tags": ["raymarching", "fur"], "likes": 10, "viewed": 404, "published": 3, "date": "1633287447", "time_retrieved": "2024-07-30T18:58:11.119377", "image_code": "// Tumble by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define sat(x) (clamp((x), 0., 1.))\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(1.433, 1.512))) * 4313.441);\n}\n\nfloat hash13(vec3 p)\n{\n\treturn fract(sin(dot(p, vec3(1.433, 1.512, 2.421))) * 4313.441);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(mix(hash12(i),hash12(i+o),f.x),\n               mix(hash12(i+o.yx),hash12(i+1.),f.x),\n               f.y);\n}\n\nfloat noise3(vec3 p)\n{\n\tvec3 i = floor(p);\n    vec3 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(\n               mix(mix(hash13(i),hash13(i+o.xyy),f.x),\n                   mix(hash13(i+o.yxy),hash13(i+o.xxy),f.x),\n                   f.y),\n               mix(mix(hash13(i+o.yyx),hash13(i+o.xyx),f.x),\n                   mix(hash13(i+o.yxx),hash13(i+1.),f.x),\n                   f.y),\n               f.z);\n}\n\nfloat noiseBiplanar(vec3 n, float scale)\n{\n    vec2 uv0, uv1;\n    if(n.z < n.x && n.z < n.y)\n    {\n        n = n.zxy;\n    }\n    else if (n.y < n.x && n.y < n.z)\n    {\n        n = n.yxz;\n    }\n    uv0 = n.xz;\n    uv1 = n.xy;\n    float t = smoothstep(.025, .975, n.z / (n.z + n.y));\n    return mix(noise(uv0 * scale + scale * 2.), noise(uv1 * scale + scale * 2.), t);\n}\n\nfloat fur(vec3 p)\n{\n    float len = length(p);\n    p = normalize(p);\n    float thickness = noiseBiplanar(p, 140.);\n    return len - 2. + (thickness * len) * .25;\n}\n\nvec3 spin(vec3 p, float d)\n{\n    float t = iTime * .5 - d * d * .125;\n    p.xz *= rot(sin(t * 2.));\n    p.zy *= rot(sin(t * 1.5));\n    return p;\n}\n\nfloat scene(vec3 p)\n{\n    float d = length(p);\n    if(d <= 2.)\n    {\n        return fur(spin(p, d));\n    }\n    return d;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec2 e = vec2(.0001, 0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30 && t < maxDist; ++i)\n    {\n        d = scene(ro + rd * t);\n        t += d;\n    \tif(abs(d) < .00001)\n            return 0.;\n    }\n    return 1.;\n}\n\nvec3 color(vec3 p)\n{\n    float d = length(p);\n    p = normalize(p);\n    \n    float a = noiseBiplanar(spin(p, d).xyz, 20.);\n    vec3 c = vec3(1., .01, .8) * (a * .8 + .2);\n    return erot(c, normalize(vec3(1)), fract(a * 11.) * 2. - 1.);\n}\n\nvoid img( inout vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy * .5)/iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 ro = vec3(0, 0, -4);\n    vec3 p;\n    \n    float d, t = 2.;\n    float i = 0.;\n    // shorten the raymarching step at grazing angles\n    float tangentBias = 1. / (1. + smoothstep(.25, .5, length(uv)) * .75);\n    for(; i < 1. && t < 6.; i += 1./32.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        t += d * tangentBias * sat(length(p) * .5);\n        if(abs(d) < .0001)\n            break;\n    }\n    \n    vec3 col = vec3(.025, .025, .035);\n    if (t < 6.)\n    {\n        \n        vec3 n = normal(p, d);\n        vec3 dirL = normalize(vec3(1, 1, -2));\n        n.xz *= rot(iTime * .4);\n        float l = dot(max(n, 0.), vec3(.4,.5,.3));\n        l *= shadow(p + n * .01, vec3(0,1,0), 10.);\n        col = color(p);\n        float lum = dot(col, vec3(.2,.7,.1));\n        col = mix(col * l + vec3(0.,.001,.002), vec3(1., .98, .95) * l, l*l*(.5 + lum));\n        float ao = (1. - max(i - l*l, 0.) * .8);\n        col *= ao;\n    }\n\n    fragColor += vec4(col,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0);\n    img(fragColor, fragCoord);\n    vec2 o = vec2(.03125, .015625);\n    for(float i = 0.; i < 4.; i++)\n    {\n        img(fragColor, fragCoord + o);\n        o = vec2(o.y,-o.x);\n    }\n    fragColor /= 5.;\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n    float vignette = length((fragCoord - iResolution.xy * .5) / iResolution.xy) * 2.;\n    fragColor.rgb *= 1. - vignette * vignette * vignette * .15;\n    fragColor.rgb += noise3(vec3(fragCoord, iFrame)) * .01 - .005;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXW8.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[144, 144, 166, 166, 227], [229, 229, 251, 251, 319], [321, 321, 340, 340, 416], [418, 418, 456, 456, 521], [523, 523, 544, 544, 760], [762, 762, 784, 784, 1201], [1203, 1203, 1245, 1245, 1570], [1572, 1572, 1591, 1591, 1735], [1737, 1737, 1765, 1765, 1883], [1885, 1885, 1906, 1906, 2007], [2009, 2009, 2039, 2039, 2181], [2183, 2183, 2230, 2230, 2459], [2461, 2461, 2481, 2481, 2699], [2701, 2701, 2754, 2754, 3826], [3828, 3828, 3883, 3883, 4384]], "test": "untested"}
{"id": "fdcXD7", "name": "basic fan", "author": "jorge2017a2", "description": "basic fan", "tags": ["basicfan"], "likes": 3, "viewed": 212, "published": 3, "date": "1633278784", "time_retrieved": "2024-07-30T18:58:12.114717", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0));\n   p.y=p.y-10.0;\n   \n    vec3 pp=p;\n    pp=rotate_y(pp, radians(iTime*36.0));\n    p=pp;\n    float sdsp1=sdSphere(p-vec3(0.0,11.0,.0),3.0 );\n    float sdcy1=sdCylinderXZ(p, vec2(3.0,9.0) );\n    float sdr1= sdRoundBox(p-vec3(0.0,-1.0,0.0), vec3(12.0,7.0,0.5), 0.5 );\n    float sdr2= sdRoundBox(p-vec3(0.0,-1.0,0.0), vec3(0.5,7.0,12.0), 0.5 );\n    \n    \n    p.x=abs(p.x)-12.0;\n    p.y+=2.0;\n    float sdsp2=sdSphere(p-vec3(0.0,11.0,.0),3.0 );\n    float sdcy2=sdCylinderXZ(p-vec3(0.0, 0.0,.0), vec2(3.0,9.0) );\n    \n    p=pp;\n    p.z=abs(p.z)-12.0;\n    p.y+=2.0;\n    float sdsp3=sdSphere(p-vec3(0.0,11.0,.0),3.0 );\n    float sdcy3=sdCylinderXZ(p-vec3(0.0, 0.0,.0), vec2(3.0,9.0) );\n    \n    res =opU3(res, vec3(sdcy1,2.0,-1.0));\n    res =opU3(res, vec3(sdsp1,3.0,-1.0));\n    \n    res =opU3(res, vec3(sdr1,4.0,-1.0));\n    res =opU3(res, vec3(sdr2,8.0,-1.0));\n    \n    res =opU3(res, vec3(sdcy2,2.0,-1.0));\n    res =opU3(res, vec3(sdsp2,7.0,-1.0));\n    \n    res =opU3(res, vec3(sdcy3,2.0,-1.0));\n    res =opU3(res, vec3(sdsp3,7.0,-1.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = GetDist(nor * hr + pos).x;\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)\n{\n    vec3 toReflectedLight=reflect(-toLight, Normal);\n    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;\n    float specularf=max(dot(toReflectedLight, toEye),0.0);\n    specularf=pow(specularf, 100.0);\n    vec3 specular =specularf*vec3(1.0);\n    return diffuse + specular;\n}\n\nvec3 colorV2(in vec3 p)\n{\n    float height = 0.01;\n\tvec3 top = vec3(0.3, 0.4, 0.5);\n\tvec3 ring = vec3(0.6, 0.04, 0.0);\n\tvec3 bottom = vec3(0.3, 0.3, 0.3);\n\tbottom = mix(vec3(0.0), bottom, min(1.0, -1.0/(p.y*20.0-1.0)));\n\tvec3 side = mix(bottom, ring, smoothstep(-height-0.001, -height, p.y));\n\treturn mix(side, top, smoothstep(-0.01, 0.0, p.y));\n}\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) \n{   vec3 lightPos=lp;\n    vec3 hit = ro + rd * t;\n    vec3 norm = GetNormal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n     float sh;\n    \n    if (mObj.blnShadow==true)\n        {\n        sh=GetShadow(p,lp);\n        sh+= occlusion(hit, lp);\n        sh/=2.0;\n        }\n    else\n        {sh=0.5;}\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    float amb = 0.5 + 0.5*dot(norm,vec3(0.0,1.0,0.0));\n    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    vec3 l = normalize( p-lightPos);\n    vec3 v = normalize( p-ro);\n    vec3 col2=LightShading(norm,l,v,col);\n    \n    color=(color+col2)/2.0;\n    return color*sh+ col2*atten * occ;\n    \n}\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, float tdist)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj, tdist);\n    return result;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n        {return pattern( p.xz );}\n    if (id_material==8.0)\n        {return pattern( p.xy );}\n    if (id_material==9.0)\n        {return pattern( p.zy );}\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1,d);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2,d);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, 10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(1.0,35.0,-15.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd,radians(55.0));\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//----------common\n///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[460, 460, 496, 496, 517], [518, 518, 564, 564, 651], [652, 652, 691, 691, 786], [788, 832, 879, 879, 906], [907, 907, 950, 950, 977], [978, 978, 1026, 1026, 1054], [1055, 1120, 1154, 1154, 1250], [1251, 1251, 1285, 1285, 1376], [1377, 1377, 1411, 1411, 1502], [1503, 1503, 1537, 1537, 1632], [1634, 1634, 1659, 1659, 2839], [2841, 2841, 2865, 2865, 3027], [3029, 3029, 3078, 3078, 3745], [3747, 3747, 3783, 3783, 4028], [4030, 4030, 4057, 4057, 4074], [4076, 4076, 4112, 4112, 4204], [4205, 4205, 4251, 4251, 4376], [4378, 4378, 4415, 4415, 4691], [4694, 4694, 4761, 4761, 5038], [5040, 5040, 5065, 5065, 5387], [5388, 5388, 5471, 5471, 6420], [6422, 6422, 6515, 6515, 6645], [6647, 6647, 6679, 6679, 6876], [6878, 6926, 6954, 6954, 7142], [7144, 7144, 7191, 7191, 7427], [7429, 7429, 7522, 7522, 7863], [7865, 7865, 7896, 7896, 8495], [8497, 8497, 8523, 8523, 8633], [8635, 8635, 8693, 8693, 8745], [8747, 8747, 8804, 8804, 9377]], "test": "untested"}
{"id": "fs3SD7", "name": "cellular automata hexagonal life", "author": "remaindeer", "description": "This is a two-state cellular automata based on a hexagonal neighborhood and the B2/S34 rulestring that shows how to reference the previous frame of the same buffer to maintain state across generations.", "tags": ["hexagonal", "gameoflife", "cellularautomata", "rulestring"], "likes": 4, "viewed": 369, "published": 3, "date": "1633276530", "time_retrieved": "2024-07-30T18:58:12.878674", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // output Buffer A\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N   100.0\n#define P   0.45\n#define ON  0.75\n#define OFF 0.25\n\n#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n\n#define width 0.125\n\nfloat cross2(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\nbool intri(vec2 uv, vec2 v1, vec2 v2, vec2 v3)\n{\n    // https://mathworld.wolfram.com/TriangleInterior.html\n    // http://www.sunshine2k.de/coding/java/pointInTriangle/pointInTriangle.html\n    vec2 w1 = v2 - v1;\n    vec2 w2 = v3 - v1;\n    float d = determinant(mat2(w1, w2));\n    // check for d ≈ 0.0 ?\n    float s = determinant(mat2(uv - v1, w2)) / d;\n    float t = determinant(mat2(w1, uv - v2)) / d;\n    return s >= 0.0 && t >= 0.0 && (s + t) <= 1.0;\n}\n\nbool inreg(vec2 uv, vec2 c, float n, float R, float theta)\n{\n    // break-up regular polygon into triangles\n    float dt = radians(360.0 / n);\n    for (float i = 0.0, j = 1.0; i < n; i++, j++)\n    {\n        vec2 a = R * vec2(cos(dt * i + theta), sin(dt * i + theta)) + c;\n        vec2 b = R * vec2(cos(dt * j + theta), sin(dt * j + theta)) + c;\n        if (intri(uv, a, b, c))\n            return true;\n    }\n    return false;\n}\n\nfloat random (vec2 st)\n{\n    // https://thebookofshaders.com/10/\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // default to time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    // compute circular cell radius\n    float R = 1.0 / N;\n    float r = R * cos30;\n    // calculate central cell coordinate\n    //// hexagonal grid basis\n    vec2 hvec = vec2(2.0 * r, 0.0);\n    vec2 kvec = vec2(r, 1.5 * R);\n    float theta = 30.0;\n    mat2 b = mat2(hvec, kvec);\n    vec2 cell = b * round(inverse(b) * uv);\n    //// substract some radius to add width\n    R -= R * width;\n    bool inhex = inreg(uv, cell, 6.0, R, radians(theta));\n    //// adjust hex coordinate due to overlap\n    if (!inhex)\n        if (cross2(vec2(r, 0.5 * R), cell - uv) < 0.)\n            cell += (uv.x > cell.x) ? kvec : -hvec;\n        else\n            cell += (uv.x > cell.x) ? hvec : -kvec;\n    // update cell state if it contains the uv\n    if (inhex || inreg(uv, cell, 6.0, R, radians(theta))) {\n        if (iFrame < 60) {\n            // set random initial state\n            col = vec3(fract(random(iTime + cell * iTime)) <= P ? ON : OFF);\n        } else {\n            // get ON/OFF state of hexagonal neighborhood\n            int nw = int(texture(iChannel0, cell + vec2(-(1.0 * r), +(1.5 * R))).rgb == vec3(ON));\n            int ne = int(texture(iChannel0, cell + vec2(+(1.0 * r), +(1.5 * R))).rgb == vec3(ON));\n            int wc = int(texture(iChannel0, cell + vec2(-(2.0 * r), (0.000000))).rgb == vec3(ON));\n            int cc = int(texture(iChannel0, cell + vec2((0.000000), (0.000000))).rgb == vec3(ON));\n            int ec = int(texture(iChannel0, cell + vec2(+(2.0 * r), (0.000000))).rgb == vec3(ON));\n            int sw = int(texture(iChannel0, cell + vec2(-(1.0 * r), -(1.5 * R))).rgb == vec3(ON));\n            int se = int(texture(iChannel0, cell + vec2(+(1.0 * r), -(1.5 * R))).rgb == vec3(ON));\n            int n = nw + ne + wc + ec + sw + se;\n            // update state of current central cell\n            // https://www.conwaylife.com/wiki/Rulestring\n            // rule B2/S34\n            if (cc == 1) col = vec3((n == 3 || n == 4) ? ON : OFF);\n            else /*****/ col = vec3((n == 2) ? ON : OFF);\n        }\n    }\n    // output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 80, 164]], "test": "untested"}
{"id": "7stXDN", "name": "costas || random point grad", "author": "ollj", "description": "point distribution gradient, rather than pixel noise gradient as in https://shadertoy.com/view/fscSWH\nclick to see tiles.\ncompeting with 2xiterated-costasArray-noise of a 4th line", "tags": ["gradient", "poisson", "poisson", "hash", "dithering", "bluenoise", "whitenoise", "galois", "pointdistribution"], "likes": 3, "viewed": 335, "published": 3, "date": "1633193530", "time_retrieved": "2024-07-30T18:58:13.834119", "image_code": "//i never did a gradient of a costas array.\n//may as well use this canvas.\n\n//code almost entirely from forked https://www.shadertoy.com/view/fdcXWH\n//adding a costas-line\n//costas-noise itterates 2 times over a costas array to get a cheap 2d-pseuo-costas.\n//this mixes 7 X2 costas arrqays of prime lengths: 241,239,281,269,19,17,13 \n//a costas array is pattern free (within its length==period)\n//because every difference (over every derivative down to its length) is unique.\n//not too many longer costas arrays are known (barely any longer than 1000)\n//this mises 7 shorter lists of prime lengths to use a shorter buffer.\n\n//code of forked source\n// Lagrangian variant of https://shadertoy.com/view/fscSWH\n\n#define hash(p)  fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(c)     texelFetch(c, ivec2(U) % textureSize(c,0).xy, 0).xy \n\nvoid mainImage( out vec4 O, vec2 u\n){\n    vec2 R = iResolution.xy, U, P = u/R, T,D,H;\n    u.x += float(iFrame);\n    T = u / 16.;\n    O-=O;\n    float d = 99.;\n    \n    if (P.y<.25){ \n    //weighted mix of 7 costas arrays of prime-periods:\n    //241,239,281,269,19,17,13 \n    //each costas array is tapped 2x recurrsively to turn a list into a 2d plane.\n    //this recursion sometimes causes a strong meta.pattern.\n    //costas arrays are chosen where that pattern is weakest for the used itteration function.\n    vec2 p = u/iResolution.xy;\n    //animated, diminished high frequencies:\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,iFrame,iTime,vec4(1)));\n    //static, diminished high frequencies:\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,1,1.,vec4(1.)));\n    //static, high and low frewuences equally mixed:\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,1,1.,vec4(0,1,0,1)));\n    \n    //the vec4 is made for an iMouse canvas:\n    O.xyz=2.*vec3(wrap(p*iResolution.y*4.,1,1.,vec4(abs(iMouse.zw),abs(iMouse.zw))/iResolution.xyxy));\n    \n    //with animation, it  shows the high freqencies too much\n    //O.xyz=vec3(wrap(p*iResolution.y*4.,iFrame,1.,vec4(abs(iMouse.zw),abs(iMouse.zw))/iResolution.xyxy));\n    \n    \n    //O.xyz=sat(O.xyz*O.xyz);   \n    //O.xyz=sqrt(O.xyz)*sqrt(1.-P.x);     //sqrt() falloff\n    O.xyz=O.xyz*(1.-P.x);             //linear falloff\n    //O.xyz=sqrt(O.xyz)\n    \n    ;}else{ //forked source shader, unchanged, b3esides adding +1 line\n    \n    for ( float i=0.; i < 256.*(1.-P.x); i++ ){\n        U = floor(T) + i*13.7;        \n        H =   P.y > .75 ? hash(U)\n            : P.y > .50 ? T(iChannel0)\n            : P.y > .25 ? T(iChannel1)\n            :             vec2(0) ; //should really be outside the loop\n        D = fract(T) - H;\n        d = min(d, dot(D,D));\n     // O = max(O, 1.3 - 16.*sqrt(d) );\n      O += (1.-O) * clamp( 1.3 - 16.*sqrt(d) , 0.,1.);\n    }\n    //O = vec4( 1.3 - 16.*sqrt(d) );   // draw closest point\n    }\n        \n    if (fract(iTime/4.)<.5){ //alternate greyxcale monochrome over time\n    if(O.x>.5)O.xyz=vec3(1);//optionally to monochrome\n    else O=vec4(0.)\n    ;}\n \n    \n    //below like is VERY hacky to turn 3 separators into 4.\n   if ( int(u.y*4./3.-1.)*3 % int(R.y) == 0 ) O = vec4(1,0,0,1); // horizontal separator\n    u = fract((u-.5)/16.);\n    if ( iMouse.z>0. && u.x*u.y==0.) O = vec4(0,0,1,1);  // if click, draw grid\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//code copied from the shader [Costas7]*\n\n#define v0 float\n#define v2 vec3 \n#define pi acos(-1.)\n\n#define sat(a) clamp(a,0.,1.)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.) \n#define ab012(a,b)(a+b*v2(0,1,2))  //desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n\nvec3 blackbodyLike(float T){\n ;vec3 c=rainbow(((((2.-T)/pi)*pi)-.5)/2.+1./6.,1./6.)\n //;c=c/max(c.r,max(c.g,c.b))*u5(((c.g)/(c.r+c.b)))//optional norm\n ;return c;\n}\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n//#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.5)*2.)\n\nconst float globalScale = 1.;\n\n//end of signal inspector (global parameters)\n//\n//start of costas array:\n\n/*\n//the idea, cycle multiple pallettes of multiple tiled costas arrays, each of them a prime in size.\n//and then do a weighted mix\n//the result should be a weightable noise/dither, with very large period (depending on LUT sizes)\n\n//this can come close to a VERY large animarteable 2d bluenoise, that is generated on runtime, and hashable.\n\n//currently in experimental stage.\n//the diagonal banding is a bit diasssapointing.\n//this is due to, where ever mod(x,n)=mod(y,n) for quite similar N\n//gets the same inputs for small tiles (which are stronger in blue noise)\n    \n//lets just try larger primes&tiles\n//and hope that prime-gaps being less repetitie will remove the banding.\n\n//added NAIVE detection of both diagonal mirrorings\n\n//todo, with this i am very close to ANIMATED blue noise\n\n\nmixed prime base animated bluenoise\nthe idea is, to have a number, where each digit has a different base\n, and each base is a prime\n, and the 0th digit has the largest prime (like 13) \n, and the Nth digit has the smallest prime == 3\nthis way, small primes auromatically have an exponential effect\non the generated cumulative number\n(this may not be worth its calculation though, but i will solve for it once)\n\neach prime is a tiled layer, animated with a different offset, over time, set by \na pqfm, primal quadratic field matrix.\nso that 2 space domains, and 1 dtime domain, bith have period as long as possible.\n\ni also have a bias for costasArrays (of prime-size), that are \n- diagonally mirror symmetric\n- animate NICELY, when tiled and pallette shifted.\n/**/\n\n#define arrLen 7\n    \n#define animatePaletteSpeed .9\n\n/*  //simpler idea outdated\nfloat mixArrayFloat[](int a[7],int b[7],float c,int l){\n    for(i=0;i<l;i++)\n      a[i]=mix(a[i],b[i],c);\n    }return a;}\n*/      \n\n//gpo() returns sizes of used tiles (of costas arrays in them) by index a.\n//this is also a list of used frequencies in terms of how blue your noise is.\n//values share no prime factors to maximize the permuted period\nint gpo(int a){int b[arrLen]=int[7](241,239,281,269,19,17,13);return b[a];}\n\n//costas arrays of tile sizes\nint getCostasOf(int a,int p){//return costas at Position of Array#\n bool r=false;\n if(a<4){\n  if(a<2){\n   if(a==0){\n          int c[]=int[241](1,38,3,156,46,114,231,141,9,155,15,226,55,39,138,205,60,100,161,203,209,186,160,181,66,8,27,71,233,223,170,169,45,25,184,194,78,173,165,196,120,117,102,57,172,69,159,131,76,108,180,236,145,58,163,157,241,73,179,125,127,214,143,225,175,74,28,140,238,166,201,59,204,232,198,124,49,24,6,17,81,52,77,213,99,149,215,62,22,185,218,89,26,146,34,23,106,240,135,105,123,75,90,136,68,122,2,98,33,182,234,210,116,35,30,202,11,70,10,104,121,37,118,111,227,109,112,50,64,91,48,171,197,195,32,85,206,207,94,12,235,150,113,151,192,42,228,31,86,82,144,44,56,29,115,224,107,154,193,101,63,174,96,47,5,13,20,229,134,164,239,137,142,219,40,19,53,36,129,133,221,152,139,208,67,158,97,167,187,211,88,191,92,80,41,126,162,222,200,148,84,93,237,178,16,65,230,4,199,14,190,176,119,132,21,177,168,216,128,87,43,212,103,217,110,188,54,130,79,183,147,220,7,72,95,153,18,61,83,51,189\t);if(r)return c[(241-p)%241];return c[p%241];\t//\t76\t\tgood very\n       ;}else{\n      int c[]=int[239](4,151,89,144,236,156,6,229,193,21,65,56,227,101,226,28,201,105,207,154,125,17,185,167,7,100,11,96,106,163,121,122,135,130,64,18,221,90,198,40,73,199,37,212,83,149,141,19,98,146,202,132,107,23,60,172,42,208,225,215,219,119,131,171,168,214,45,150,170,230,138,145,234,61,134,33,210,186,159,213,237,161,27,43,51,114,142,81,239,22,41,224,129,118,194,116,197,157,5,26,232,231,216,110,162,189,36,3,53,203,191,47,72,86,180,209,160,55,178,10,147,233,67,85,25,140,95,39,152,133,192,111,113,235,177,94,169,153,123,126,74,195,204,92,139,32,12,76,102,52,238,49,79,20,166,127,80,183,228,173,88,84,77,109,179,75,217,97,59,120,29,218,82,220,143,115,44,1,70,35,14,206,9,108,205,137,190,184,223,136,57,187,38,15,158,16,50,181,24,200,87,188,48,54,69,104,78,34,2,13,165,124,8,66,182,71,58,99,176,174,196,63,128,164,91,175,30,68,46,211,112,117,103,222,31,148,62,93,155\t);if(r)return c[(239-p)%239];return c[p%239];\t//\t47\t\tgood very\n  ;}}else{\n   if(a==2){\n           int c[]=int[281](108,277,20,24,177,157,241,58,204,270,106,59,30,265,127,84,208,140,86,143,130,128,193,203,161,111,38,5,87,252,125,149,218,98,36,70,97,210,75,76,185,180,201,226,121,279,238,14,219,207,31,91,122,105,233,35,244,102,189,50,181,27,221,142,21,133,172,178,266,236,79,229,165,264,18,89,187,115,191,268,171,69,271,215,54,51,7,22,242,167,199,8,131,237,188,224,186,6,196,247,146,174,113,256,278,129,19,198,182,136,216,163,46,28,47,137,42,158,67,53,225,12,1,217,272,41,49,72,32,200,117,126,258,213,119,61,248,255,169,134,281,173,4,261,257,104,124,40,223,77,11,175,222,251,16,154,197,73,141,195,138,151,153,88,78,120,170,243,276,194,29,156,132,63,183,245,211,184,71,206,205,96,101,80,55,160,2,43,267,62,74,250,190,159,176,48,246,37,179,92,231,100,254,60,139,260,148,109,103,15,45,202,52,116,17,263,192,94,166,90,13,110,212,10,66,227,230,274,259,39,114,82,273,150,44,93,57,95,275,85,34,135,107,168,25,3,152,262,83,99,145,65,118,235,253,234,144,239,123,214,228,56,269,280,64,9,240,232,209,249,81,164,155,23,68,162,220,33,26,112,147\t);if(r)return c[(281-p)%281];return c[p%281];\t//\t1121\te\tgood, very good\n           ;}else{\n          int c[]=int[269](77,170,158,48,161,199,10,258,227,75,209,203,165,187,151,11,207,94,79,110,175,255,248,3,98,17,109,67,12,253,40,27,212,154,193,141,223,167,168,159,69,18,192,174,225,127,190,237,123,264,13,80,202,90,222,172,246,83,82,143,213,72,140,112,107,121,208,39,247,37,198,33,183,21,244,53,96,131,144,14,134,15,1,118,245,243,197,130,201,108,8,200,76,19,25,230,250,259,180,229,97,218,221,265,220,228,89,62,241,171,66,78,215,236,269,135,191,188,84,267,142,211,256,59,145,74,57,38,232,239,92,20,224,266,182,93,148,41,210,184,4,177,23,137,35,46,70,122,150,102,16,217,47,88,49,113,189,149,234,166,63,251,105,71,160,32,85,179,155,114,162,68,156,233,125,216,100,51,226,153,73,99,263,136,235,205,185,26,242,219,176,260,52,106,124,268,257,204,196,132,169,58,54,64,147,249,104,133,101,128,164,262,252,5,152,117,56,31,61,139,95,36,86,120,45,91,206,129,7,194,30,126,9,24,173,231,116,28,138,178,34,186,55,60,238,240,42,146,163,195,261,103,43,214,181,44,119,254,87,50,29,157,6,22,81,65,2,111,115\t);if(r)return c[(269-p)%269];return c[p%269];\t//\t678\t\tgood very\n ;}}}else{\n   if(a==4){int c[]=int[19](1,12,16,18,19,10,15,8,14,17,9,5,3,2,11,6,13,7,4);if(r)return c[(19-p)%19];return c[p%197];}//is too symmetrical\n   if(a==5){\n       int c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n    }else {int c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n//more best ofs (alternative arrays)\n/*\tint c[]=int[17](2,11,8,6,16,17,12,3,14,10,13,15,5,4,9,1,7);if(r)return c[(17-p)%17];return c[p%17];\t//\t11\t\tgood\n/*\tint c[]=int[11](0,4,10,7,8,2,1,9,5,3,6);if(r)return c[(11-p)%11];return c[p%11];\t//\t57\t\tgood very\n/*\tint c[]=int[13](0,6,8,4,5,9,12,2,7,1,11,10,3);if(r)return c[(13-p)%13];return c[p%13];\t//\t144\n/*\tint c[]=int[ 7](1,4,5,3,0,6,2);if(r)return c[(7-p)%7];return c[p%7];\t//\t22\t\tgood very\n/*\tint c[]=int[ 5](1,2,4,0,3);if(r)return c[(5-p)%5];return c[p%5];\t//\t4 good\n/**/\n;}}}\n\n\n//cs() does 2 iterations over getCostasOf()\n//a 1d costas array (==list) is usually shown as square of binary tiles.\n//but i need a 2d heightmap and not a 1d heightmap.\n//but a 2d costasArray (for a 2d heightmap) is useless here\n//(because it has elements that are NaN (==mod(a,0) )\n//because 3d costas arrays are MUCH trickier to calculate (and usually kept secret)\n//we instead do 2 iterations over a 1d costasArray, to get a PSEUDO-2d-costasArray\nint Cs(ivec2 u,int a,int iFrame){\n ;int r=0\n ;int per=gpo(a)\n ;u=u%per //integer modulo (tile to positive infinity)\n ;//if(max(u.x,u.y)>per-1)return 0; //only show one tile\n ;int c=getCostasOf(a,per-u.y)\n ;//if(c+1==u.x)return per;return 0;//monochrome (makes nice starfields)\n ;r=c-u.x\n ;if(r<0)r+=per\n ;r=getCostasOf(a,per-r)  //we reverse the second pass, (habbitually, there may be a better approach)\n ;//r+=getCostasOf(a,per)//optional for a better match with simpler mode \n ;//r=r%per;\n ;r=(r+iFrame/4)%(per);\n ;return r;}\n\n\n//biased mixing of multiple modulo tiles (that are set by Cs(parameter) )\nvec4 CostasNoise(ivec2 u,int iFrame,vec4 m){\n ;u/=2\n ;float r=0.;\n //last 3 entries are better set to 0, they are very small and too symmetrical costas arrays (cause diagonal bands)\n //;float f[]=float[7](1.,0.,0.,0.,0.,0.,0.)//singleton    \n ;float f[]=float[7](1.,1.,1.,1.,1.,1.,1.)//flat (strong banding)\n //;float f[]=float[7](4.,3.,2.,1.,0.,0.,0.)//valley\n;float blue[]=float[7](1.,2.,4.,8.,16.,32.,0.)//blue (most banding?)\n //;float f[]=float[7](1.,2.,2.,1.,0.,0.,0.)//windowed \n ;float yellow[]=float[7](64.,32.,16.,8.,4.,2.,0.)//anti-blue /least banding)\n     //dissappointingly, even small prime tiles as small as 19*19 salready have too stron giagonal banding\n     //so i guess, i just need larger tiles and larger primes.\n     //i take a bet that it is a bad idea to repeat prime-gaps (espoecially short ones), which may result in the banding\n ;m=clamp(m,0.,1.)\n \n ;for(int i=0;i<7;i++){\n      blue[i]=mix(blue[i],yellow[i],m.x);\n }    \n;for(int i=0;i<7;i++){\n      f[i]=mix(blue[i],f[i],m.y);//mix to flat\n }\n ;r+=float(Cs(u,0,iFrame))/float(gpo(0))*f[0];\n ;r+=float(Cs(u,2,iFrame))/float(gpo(2))*f[2];\n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,1,iFrame))/float(gpo(1))*f[1];\n ;r+=float(Cs(u,3,iFrame))/float(gpo(3))*f[3];\n //large above, small below\n ;r+=float(Cs(u,4,iFrame))/float(gpo(4))*f[4];    \n ;u=u.yx//addition, to make half of the arrays diagonally flipped\n ;r+=float(Cs(u,5,iFrame))/float(gpo(5))*f[5];\n ;r+=float(Cs(u,6,iFrame))/float(gpo(6))*f[6]; \n    \n ;float a=r/(f[0]+f[1]+f[2]+f[3]+f[4]+f[5]+f[6])//divide by sum of weights\n ;return vec4(a,a,a,1);\n}\n\n\nfloat wrap(vec2 u,int iFrame,float iTime,vec4 m){//O=getCostasOfFloat(u);\n ;if(m.z<=0.){m.y=0.;m.x=cos(iTime*.3)*.5+.5;}\n ;//u*=2.2\n ;u.x*=2.5   //note, this likely is TERRIBLE uv scaling.\n ;float g=(sqrt(5.)*.5+.5)\n ;float speed=.00003*iTime\n ;vec2 s= (vec2(cos(speed),sin(speed*g))*.5+.5)*10000000. \n     //i am pleased that this noise still has a strong pattern to make scrolling easily noticable.\n     //thile its color palette cycles.\n ;ivec2 scroll=ivec2(0);\n ;//ivec2 scroll=ivec2(s);\n ;//u.x+=u.y*(sqrt(5.)*.5+.5) //optionally skew diagonal banding by goldenRatio (sucks)\n ;//u.x+=u.y*u.y*g\n ;return CostasNoise(ivec2(u)+scroll,iFrame,m).x;}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[858, 858, 895, 895, 3234]], "test": "untested"}
{"id": "7ddXD4", "name": "cellular automata moore life", "author": "remaindeer", "description": "This is a two-state cellular automata based on a Moore neighborhood and Conway's Game of Life rules thats shows how to reference the previous frame of the same buffer to maintain state across generations.", "tags": ["conway", "gameoflife", "cellularautomata", "mooreneighborhood"], "likes": 1, "viewed": 274, "published": 3, "date": "1633191836", "time_retrieved": "2024-07-30T18:58:14.635975", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // output Buffer A\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N   100.0\n#define P   0.65\n#define ON  0.75\n#define OFF 0.25\n\nvec2 uv_to_cell(vec2 uv)\n{\n    mat2 b = mat2(1.0 / N, 0.0, 0.0, 1.0 / N);\n    return b * round(inverse(b) * uv);\n}\n\nfloat random (vec2 st)\n{\n    // https://thebookofshaders.com/10/\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // default to time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    // compute circular cell radius\n    float r = 1.0 / N / 2.0;\n    // calculate central cell coordinate\n    vec2 cell = uv_to_cell(uv);\n    // update cell state if it contains the uv\n    if (distance(uv, cell) < r) {\n        if (iFrame < 60) {\n            // set random initial state\n            col = vec3(fract(random(iTime + cell * iTime)) <= P ? ON : OFF);\n        } else {\n            // get ON/OFF state of Moore neighborhood\n            // https://en.wikipedia.org/wiki/Moore_neighborhood\n            float dx = 2.0 * r;\n            float dy = 2.0 * r;\n            int nw = int(texture(iChannel0, cell + vec2(-dx, +dy)).rgb == vec3(ON));\n            int nc = int(texture(iChannel0, cell + vec2(0.0, +dy)).rgb == vec3(ON));\n            int ne = int(texture(iChannel0, cell + vec2(+dx, +dy)).rgb == vec3(ON));\n            int wc = int(texture(iChannel0, cell + vec2(-dx, 0.0)).rgb == vec3(ON));\n            int cc = int(texture(iChannel0, cell + vec2(0.0, 0.0)).rgb == vec3(ON));\n            int ec = int(texture(iChannel0, cell + vec2(+dx, 0.0)).rgb == vec3(ON));\n            int sw = int(texture(iChannel0, cell + vec2(-dx, -dy)).rgb == vec3(ON));\n            int sc = int(texture(iChannel0, cell + vec2(0.0, -dy)).rgb == vec3(ON));\n            int se = int(texture(iChannel0, cell + vec2(+dx, -dy)).rgb == vec3(ON));\n            int n = nw + nc + ne + wc + ec + sw + sc + se;\n            // update state of current central cell\n            // https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Rules\n            // Any live cell with two or three live neighbours survives.\n            // All other live cells die in the next generation.\n            // Any dead cell with three live neighbours becomes a live cell.\n            // Similarly, all other dead cells stay dead.\n            if (cc == 1) col = vec3((n == 2 || n == 3) ? ON : OFF);\n            else /*****/ col = vec3((n == 3) ? ON : OFF);\n        }\n    }\n    // output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 80, 164]], "test": "untested"}
{"id": "NdtXDN", "name": "Cheap Ocean", "author": "Krischan", "description": "A wet alteration of https://www.shadertoy.com/view/fddXWH\nHas some visual artifacts that are mostly covered by movement :D", "tags": ["clouds", "water", "ocean"], "likes": 16, "viewed": 1277, "published": 3, "date": "1633189224", "time_retrieved": "2024-07-30T18:58:15.468749", "image_code": "precision mediump float;\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i,e,f,s,g,k=.01;    \n    float o;    \n    o++;    \n    for(int i=0;i<100;i++)\n    {\n      s=2.;      \n      g+=min(f,max(.03,e))*.3;      \n      vec3 p=vec3((fragCoord.xy-iResolution.xy/s)/iResolution.y*g,g-s);\n      p.yz*=rotate2D(-.8);\n      p.y*=2.5;\n      p.z+=iTime*1.3;\n      e=p.y;\n      f=p.y;\n      for(;s<50.;)\n      {\n        s/=.66;\n        p.xz*=rotate2D(s);\n        e+=abs(dot(sin(p*s)/s,p-p+0.6));\n        f+=abs(dot(sin(p.xz*s*.33+(iTime*0.5))/s,iResolution.xy/iResolution.xy));\n      }\n\n      if(f>k*k)\n        o+=e*o*k;\n      else\n        o+=-exp(-f*f)*o*k;\n\n\n    }\n    fragColor = vec4(o*vec4(0.33,0.7,0.85,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 49, 49, 101], [103, 103, 160, 160, 805]], "test": "untested"}
{"id": "fddXWN", "name": " Fab4 #inktober2021 \"knot\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse control camera", "tags": ["raymarching", "string", "knot", "trefoil", "short", "rope", "inktober2021"], "likes": 14, "viewed": 326, "published": 3, "date": "1633186848", "time_retrieved": "2024-07-30T18:58:16.232706", "image_code": "\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                // rotation                  \n#define T       d = vec2(length(q.xz)-1.,q.y),                         \\\n                d -= threads(q, atan(d.y,d.x), 20. ),                  \\\n                t = min(t, length(d -.4* vec2(cos(a),1.7*sin(a)) ) -.6 )            \n#define threads(q,d,r) .03*abs(cos(r*(d+atan(q.z,q.x))))    // sub-threads\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,a; vec2 d;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),           // ray direction\n          p = 9./R, q,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p.yxz,\n        q.yz *= rot(.5-6.*M.y),                             // rotations\n        q.xz *= rot(2.-6.*M.x), \n        a = .6667*atan(q.z,q.x), T,                         // trefoil       \n        a += 2.094, T,\n        a += 2.094, T,  \n        a = threads(q, 2.*q.y, 10.),                        // main wire\n        t = min(t, length(q.xz)+a-.57 ),\n        p += .3*t*D;                                        // step forward = dist to obj\n    O *= vec4(1,.6,0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[398, 398, 434, 434, 1298]], "test": "untested"}
{"id": "NstSWN", "name": " Fab3 #inktober2021 \"vessel\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera", "tags": ["raymarching", "short", "origami", "vessel", "paperfolding", "inktober2021"], "likes": 11, "viewed": 294, "published": 3, "date": "1633182028", "time_retrieved": "2024-07-30T18:58:17.085426", "image_code": "#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                // rotation                  \n                       \nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,h,c,k; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 12./R, q,d,                                     // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x), q.y++,\n        t = min(t, h = q.y), q.y++,                           // water\n        q.xz = abs(q.xz),                                     // 2 symmetries\n        \n        d = q, d.y-=3.,                                       // sails\n        d.yz *= rot(-.3),\n        d.xz *= rot(-.3),\n        t = min(t, max( abs(d.z),- 1.55-d.y ) ),\n \n        d = q, d.y-=1.1,d.yz *= rot(.8), c= d.z,              // body, front+rear\n        d = q,\n        d.yz *= rot(.4),\n        d.xz *= rot(-.3),\n        t = min(t, max( max(abs(k=d.z),c), d.y-2.04) ),\n        d = q, d.y-=1.07,d.yz *= rot(.8),                     // body, center\n        t = min(t, max(abs(d.z),k) ),\n       \n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O *=   t==h ? vec4(.0,.5,1,1)   // water                  // color scheme\n         :        vec4(1);          // boat\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 152, 152, 1551]], "test": "untested"}
{"id": "fsdSD4", "name": " Fab2 #inktober2021 \"suit\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera", "tags": ["raymarching", "moon", "short", "reproduction", "inktober2021", "tintin", "spacesuit"], "likes": 9, "viewed": 274, "published": 3, "date": "1633179339", "time_retrieved": "2024-07-30T18:58:18.103704", "image_code": "#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                // rotation                  \n                       \nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,h,a,l,b,g,m=t; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,d,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x), \n        t = min(t, h = length(q-vec3(0,1,0)) - .9),                        // head\n        t = min(t, g = min( length(vec2(length(q.xz)-.85,q.y-.6)) - .03,   // top seal\n                            length(vec2(length(q.xz)-1.,q.y+1.7)) - .03)), // bottom seal\n        t = min(t, ( q.y < 0. ? max(abs(length(q.xz)-.95)-.05, -q.y-1.7) : length(q) - 1. )), // trunck\n        t = min( t, l = length(q-vec3(.9,0,0))-.2 ),                       // lamp\n        m = min(m,l),                                                      // for glow\n        d=q, d.z=mod(d.z-.2,.4)-.2, \n        t = min( t, b= max( length(d-vec3(.95,-1.2,0))-.1 , abs(q.z)-.5)), // buttons\n     // m = min(m,b),                                                      // for glow\n        q.z = abs(q.z)-.8, q.zy *= rot(-.7), q.xz*=rot(-.5),\n        t = min(t, max( length(q.yx) -.4 , abs(q.z)-.8 ) ),                // arms\n        q.z-=.6, q.y+=1., a = atan(q.z,q.y),\n        q.y = length(q.yz)-1.,\n        t = min(t, max( length(vec2(length(q.xy)-.4+.1*a, mod(a,.2)-.1)) -.1   , abs(a-.3)-.5 ) ),\n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O *=   t==h ? vec4(.8,.9,1,1)   // head                   // color scheme\n         : t==l ? vec4( 1,1,.8,1)   // lamp\n         : t==b ? vec4( 0,.5,0,1)   // buttons\n         : t==g ? vec4(.6)          // seals\n         :        vec4( 1,.5,0,1);  // trunck and arms\n    O += .5*exp2(-m) * vec4(.7,.9,1,1);                       // glow\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 152, 152, 2173]], "test": "untested"}
{"id": "NstSD4", "name": " Fab1 #inktober2021 \"crystal\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2021 themes: [img]https://i.imgur.com/QjhAdpd.png[/img]\n\nmouse controls camera", "tags": ["raymarching", "short", "fantasy", "crystal", "inktober2021"], "likes": 10, "viewed": 291, "published": 3, "date": "1633173704", "time_retrieved": "2024-07-30T18:58:18.898578", "image_code": "#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                // rotation                  \n#define penta(q)  length(q.xz)*cos( mod( atan(q.z,q.x)-.628 , 6.28/5. ) -.628 +vec2(0,11) ) // 5-fold symmetry\n                                                              // crown of crystals\n#define crown(q,a,l,r)  d = q, d.xz = penta(d),                     \\\n                        d.xy *= rot(-a), d.y -= l,                  \\\n                        t = min(t, penta(d).x + max(0.,.4*d.y) - r ) // one crystal\n                       \nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,s,m=t; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,d,                                      // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,2,0)/1e2*cos(.2*iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // rotations\n        q.xz *= rot(2.-6.*M.x),\n        q.y++,\n        t = min(t, s = q.y),                                  // floor\n        t = min(t, penta(q).x + max(0.,.4*q.y-.4) - .15 ),    // central peak\n        crown(q, .5,1.,.1),                                   // top crown \n        q.xz *= rot(.63), crown(q, .8,.8,.1),                 // bottom crown\n        m = min(m,t),                                         // for glow\n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O *= t==s ? vec4(.4) : vec4(.7,.9,1,1);                   // color scheme\n    O += exp2(-m) * vec4(.7,.9,1,1) *(1.+sin(3.*iTime))/4.;   // glow\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[534, 534, 570, 570, 1723]], "test": "untested"}
{"id": "tscBRM", "name": "colors_001", "author": "catafest", "description": "test normalize", "tags": ["normalize"], "likes": 2, "viewed": 170, "published": 3, "date": "1633168271", "time_retrieved": "2024-07-30T18:58:19.782216", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat add_Plane( vec3 p )\n{\n\treturn p.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = ((fragCoord)-iResolution.xy)/iResolution.y+1.0;\n    vec3 col =  normalize( vec3(p,cos(iTime)));\n    float a = add_Plane(col);\n    // Time varying pixel color\n    vec3 col2 = normalize(vec3(a*cos(iTime)/iTime*a-col));\n    vec3 col3 = normalize(vec3(col*a/cos(iTime+col2)));\n    // Output to screen\n    fragColor = vec4(col3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 94, 94, 109], [111, 111, 168, 218, 602]], "test": "untested"}
{"id": "tdVBRw", "name": "test_december", "author": "catafest", "description": "testing ", "tags": ["pow"], "likes": 0, "viewed": 155, "published": 3, "date": "1633168239", "time_retrieved": "2024-07-30T18:58:20.698765", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // set uv into the center of screen\n    uv = fragCoord/iResolution.y - vec2(0.5*(iResolution.x/iResolution.y), 0.5);\n\n\t// set a dark blue color    \n    vec3 col = vec3(0.01,0.1,0.4);\n    \n    \n    // create a vignette effect with pow \n    col /= pow(0.76+length(uv), 1.40);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 504]], "test": "untested"}
{"id": "NsdSW4", "name": "Planet shader", "author": "pancakespeople", "description": "A shader of an earth-like planet\n\nUpdate 2021-10-9: Switched to side view perspective and added the sun", "tags": ["planet"], "likes": 4, "viewed": 261, "published": 3, "date": "1633154690", "time_retrieved": "2024-07-30T18:58:21.545501", "image_code": "#define NUM_OCTAVES 5\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(mix(dot(random2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n\t\tdot(random2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n\t\tmix(dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n\t\t\tdot(random2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x * 4.0;\n    vec3 sph = vec3(uv.x, uv.y, cos(length(uv)));\n\n    float r = length(uv);\n\tfloat f = (1.0 - sqrt(1.0 - r)) / r;\n    vec3 sunPos = vec3(cos(iTime / 4.0), 0.0, sin(iTime / 4.0));\n    float light = dot(sph, sunPos);\n    float reflectivity = 1.0;\n\n    float noiseVal = fbm((uv * f * 5.0) + 500.0) + 0.5;\n    float cloudNoise = fbm((uv * f * 2.0 + vec2(-iTime / 8.0, 0.0)) + 1000.0) + 0.5;\n    //cloudNoise *= rotate(iTime);\n    vec3 col = vec3(0.0);\n    \n    if (r < 1.0) {\n        if (noiseVal < 0.5) {\n            col = vec3(0.0, 0.0, 1.0);\n        }\n        else if (noiseVal > 0.65) {\n            col = vec3(1.0, 1.0, 1.0) * noiseVal;\n        }\n        else {\n            col = vec3(0.5, noiseVal, 0.0);\n        }\n        reflectivity = noiseVal * 2.0;\n        col += smoothstep(0.55, 0.6, cloudNoise);\n    }\n    else {\n        col = vec3(0.5, 0.8, 1.0) * smoothstep(1.1, 1.0, r);\n        reflectivity = 0.5;\n    }\n    \n    col *= light;\n    col += smoothstep(1.1, 1.0, r) * light * reflectivity;\n    \n    vec2 suv = uv - sunPos.xy * 3.0;\n    col += 0.1 / length(suv) * smoothstep(0.99, 1.0, r) * smoothstep(0.5, 0.8, -sunPos.z);\n    \n    float flareCol = 0.0;\n    vec2 fuv = suv;\n    float angle = atan(fuv.y, fuv.x) + 3.14159 / 8.0;\n    flareCol += 0.1/abs(sin(angle*4.0)*cos(angle*4.0)) * smoothstep(0.6, 0.0, length(fuv));\n    flareCol *= 0.1/abs(sin(angle*2.0)*cos(angle*2.0)) * smoothstep(0.6, 0.0, length(fuv));\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 4.0;\n    //fuv *= rotate(3.14159 / 4.0);\n    //flareCol += 0.01 / abs(fuv.x*fuv.y) * smoothstep(1.0, 0.5, length(fuv)) / 16.0;\n\n    flareCol *= smoothstep(0.7, 0.8, -sunPos.z);\n    flareCol *= smoothstep(0.99, 1.0, length(uv-suv));\n    //flareCol *= smoothstep(0.99, 1.0, r);\n    if (light < 0.01 && r < 1.0) col = vec3(0.0);\n    col += flareCol;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 182], [184, 269, 291, 291, 633], [635, 635, 654, 654, 922], [924, 924, 950, 950, 1034], [1036, 1036, 1093, 1143, 3120]], "test": "untested"}
{"id": "ss3XWN", "name": "Breaking raymarching", "author": "SnoopethDuckDuck", "description": "messing around trying to break things", "tags": ["raymarching", "template", "artofcode"], "likes": 0, "viewed": 257, "published": 3, "date": "1633135025", "time_retrieved": "2024-07-30T18:58:22.403208", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 50\n#define MAX_DIST 5.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float a = atan(p.z, p.x);\n   // float b = .5 + .5 * cos(0.3 * iTime);\n    p = vec3(p.x,p.y +0.1 *  length(p.xz) * cos(6. * a + 4. * iTime),p.z);\n    float bd = sdBox(p, vec3(0.8)) - .2;\n    float sd = length(p) * length(p) - 1.2;// + 0.4 * cos(0.7 * iTime);\n    //return  0.2 * (0.8 + sin(16.* (0.2 * min(bd,sd) + (1. - abs(min(sd/(bd),bd/(sd)))))));\n    return  -0. * min(bd,sd) + 0.05 * (2. + sin(0.5 * iTime + 1. * (0.6 - abs(min(sd/(bd),bd/(sd))))));\n   \n   \n   //return bd;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    //  vec3 col = mix(vec3(.5,0.,0.),vec3(0.),16. * k * (1.-k) * k * (1.-k));\n   // vec3 col = vec3(10.,0.,0.);\n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),16. * k * (1.-k) * k * (1.-k));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = 0.35 * iTime;\n    vec3 ro = 2.5 * vec3(cos(t), cos(t + (2./3.) * 3.1415), cos(t + (4./3.) * 3.1415));\n   // vec3 ro = vec3(3.5 * cos(0.2 * iTime),2. * sin(0.5 * iTime), 3.5 * sin(0.2 * iTime));\n    // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    float depth = 2.; //1.5 + cos(iTime);\n    \n    // comment / uncomment me\n    //d = RayMarch(ro + rd * (1. + depth) * d, -0.5 * depth * rd);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(1.5*rd, n);\n        \n        float spec = pow(max(0., -r.y),32.);\n        spec = .5 + .5 * cos(0.00001*spec); // <-- absolute fudge but works alright\n       \n       float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       float a = atan(p.x,p.z);\n       // dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n       \n       col = 0.4 * vec3(dif) + 1.5 * cos(2. * a) * Bg(r);        \n       col *= (1. + spec);\n       \n       // comment / uncomment me\n       //col = vec3(dif);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    //col *= 100000.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3XWN.jpg", "access": "api", "license": "mit", "functions": [[1472, 1472, 1491, 1491, 1553], [1555, 1555, 1584, 1584, 1665], [1668, 1668, 1691, 1691, 2176], [2178, 2178, 2212, 2212, 2423], [2425, 2425, 2449, 2449, 2639], [2641, 2641, 2691, 2691, 2882], [2884, 2884, 2902, 2902, 3136], [3138, 3138, 3195, 3195, 4541]], "test": "untested"}
{"id": "sd3SWN", "name": "Another torus thingy", "author": "SnoopethDuckDuck", "description": "forked from artofcode's thingy", "tags": ["raymarching", "template", "artofcode"], "likes": 4, "viewed": 292, "published": 3, "date": "1633124454", "time_retrieved": "2024-07-30T18:58:23.172152", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    p.y *= 0.8;\n    float a = atan(p.z,p.x);\n    float r1 = 1.;\n    float r2 = 0.5;\n    float d = length(p.xz) - r1;\n    d *= (0.95-0.5 * d);\n    float td = length(vec2(cos(5. * min(abs(p.x),abs(p.z))) + p.y + cos(5.* p.y+2.*a+ 2.*iTime),4. * d)) - r2;\n    \n    return td * 0.18;\n  \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float a = atan(rd.z, rd.x);\n    float k = mix(rd.y , cos(a), .5 + .5 * cos(2. * iTime)) * .5 + .5;\n    vec3 col = mix(vec3(.5,0.05,0.02),vec3(0.),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    //vec3 ro = vec3(3.5, 2., 3.5);\n    vec3 ro = vec3(2.5 * cos(0.1 * iTime ),2. * sin(0.5 * iTime), 2.5 * sin(0.1 * iTime));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    float depth = 0.6; //1.5 + cos(iTime);\n    \n    // comment / uncomment me\n    d = RayMarch(ro + rd * (1. + depth) * d, -0.5 * depth * rd);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(1.5*rd, n);\n        \n        float spec = pow(max(0., -r.y),32.);\n        spec = .5 + .5 * cos(0.00001*spec); // <-- absolute fudge but works alright\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        float a = atan(p.x,p.z);\n        // dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n       \n        col = 0.4 * vec3(dif) + 1.5 * cos(2. * a) * Bg(r);        \n        col *= (1. + spec);\n       \n        // comment / uncomment me\n        //col = vec3(dif);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3SWN.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1671, 1671, 1694, 1694, 1979], [1981, 1981, 2015, 2015, 2226], [2228, 2228, 2252, 2252, 2442], [2444, 2444, 2494, 2494, 2685], [2687, 2687, 2705, 2705, 2877], [2879, 2879, 2936, 2936, 4177]], "test": "untested"}
{"id": "7stXWH", "name": "inktober 1 - crystal", "author": "pali6", "description": "A naive attempt at path tracing, doesn't really work as I want it to. 😭", "tags": ["sdf", "pathtracing"], "likes": 5, "viewed": 291, "published": 3, "date": "1633113574", "time_retrieved": "2024-07-30T18:58:23.961043", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 p = texture(iChannel0, uv);\n    fragColor = vec4(p.rgb / p.a, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 rotation(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n\t);\n}\n\n#define PI 3.14159\n\nvec3 camPos = vec3(0, 0, 0.5);\nvec3 camDir = vec3(0, 0, -1);\nvec3 camUp = vec3(0, 450. / 800., 0);\nfloat camF = 0.3;\nconst int maxSteps = 32;\n\nvec3 rayDir(vec2 uv)\n{\n    vec3 camRight = normalize(cross(camDir, camUp));\n    float xs = rand(vec2(iTime * 0.01 + uv.x, uv.y)) / iResolution.x;\n    float ys = rand(vec2(iTime * 0.01 + uv.x, uv.y + 0.3)) / iResolution.y;\n    return normalize(camDir * camF + (uv.y + ys - 0.5) * 2. * camUp + (uv.x + xs - 0.5) * 2. * camRight);\n}\n\nfloat prism(vec3 pos, int n, float rot, float pointy)\n{\n    float result = 0.;\n    for(int i = 0; i < n; i++)\n    {\n        float angle = float(i) / float(n) * 2. * PI + rot;\n        result = max(result, dot(pos, vec3(cos(angle), 0, sin(angle))) - 1.);\n        result = max(result, dot(pos, vec3(cos(angle), pointy, sin(angle))) - 1.);\n    }\n    return result;\n}\n\nbool l = true;\n\nvec2 scene(vec3 pos)\n{\n    vec2 result = vec2(1e7, 0.);\n    /*\n    float s1 = distance(pos, vec3(0, 0, -4)) - 1.\n    if(s1 < result.x)\n        result = vec2(s1, 2.);\n    float s2 = distance(pos, vec3(-4, -1, -4.5)) - 2.;\n    if(s2 < result.x)\n        result = vec2(s2, 2.);\n    float s3 = distance(pos, vec3(5., 2.5, -5)) - 2.;\n    if(s3 < result.x)\n        result = vec2(s3, 2.);\n    */\n    for(int i = 0; i < 15; i++)\n    {\n        float fi = float(i) + 0.0019;\n        if(i >= 10)\n            fi += 0.11;\n        float rot1 = 2. * PI * rand(vec2(0.1 + 0.1 * fi, 0.1));\n        float rot2 = 2. * PI * rand(vec2(0.1 + 0.1 * fi, 0.2));\n        vec3 shift = vec3(\n            rand(vec2(0.1 + 0.1 * fi, 0.3)) * 6. - 3.,\n            rand(vec2(0.1 + 0.1 * fi, 0.4)) * 6. - 3.,\n            rand(vec2(0.1 + 0.1 * fi, 0.5)) * 6. - 3.\n        );\n        shift += vec3(0, 0, 6.);\n        int sides = 2 + int(5. * rand(vec2(0.1 + 0.1 * fi, 0.6)));\n        float pointiness = rand(vec2(0.1 + 0.1 * fi, 0.7)) + 0.1;\n        float rotoffset = 2. * PI * rand(vec2(0.1 + 0.1 * fi, 0.8));\n        \n        vec3 temppos = rotation(vec3(0, 1, 0), rot1) * rotation(vec3(0, 0, 1), rot2) * pos + shift;\n        float p1 = prism(temppos, sides, rotoffset, pointiness);\n        if(p1 < result.x)\n            result = vec2(p1, 3. + float(i));\n    }\n    float bs = 15. - distance(pos, vec3(0, 0, -4));\n    if(bs < result.x)\n        result = vec2(bs, 2.);\n    float li = distance(pos, vec3(-3., 4., -4.)) - 0.5;\n    if(l && li < result.x)\n        result = vec2(li, 1.);\n    return result;\n}\n\nvec3 sceneNormal(vec3 pos)\n{\n    float d = 0.001;\n    float base = scene(pos).x;\n    return normalize(vec3(\n        scene(pos + vec3(d, 0, 0)).x - base,\n        scene(pos + vec3(0, d, 0)).x - base,\n        scene(pos + vec3(0, 0, d)).x - base\n    ));\n}\n\nvec4 rt(vec3 rayPos, vec3 rayDir)\n{\n    float retVal = 0.;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        vec2 sc = scene(rayPos);\n        float val = sc.x;\n        if(val < 0.001)\n        {\n            return vec4(rayPos, sc.y);\n        }\n        rayPos += rayDir * val;\n    }\n    return vec4(rayPos, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 rd = rayDir(uv);\n    // l = false;\n    vec4 d = rt(camPos, rd);\n    int paths = 5;\n    float ff = 0.;\n    bool diff = false;\n    while(d.w != 1. && paths-- > 0)\n    {\n        if(paths == 1)\n            l = true;\n        vec3 norm = sceneNormal(d.xyz);\n        vec3 dir;\n        if(d.w >= 3.)\n            ff += 1.;\n        if(rand(vec2(iTime * 0.001 + d.x, 0.01 + d.y + d.z)) > 0.3 || !diff && paths == 1)\n        {\n            dir = normalize(vec3(rand(vec2(iTime * 0.001 + d.x, d.y + d.z))-0.5, rand(vec2(1. - iTime * 0.001 + d.x, 0.05 + d.y + d.z))-0.5, rand(vec2(0.03 + iTime * 0.001 + d.x, 1. - d.y + d.z))-0.5));\n            diff = true;\n        }\n        else\n            dir = normalize(norm + (norm + rd));\n        rd = dir;\n        d = rt(d.xyz + dir * 0.1, dir);\n    }\n    vec3 col;\n    float ls = 1.;\n    if(d.w != 1.)\n    {\n        fragColor = texture(iChannel0, uv) + vec4(0, 0, 0, 0.01);\n        return;\n    }\n    else\n    {\n        ls = max(0., dot(sceneNormal(d.xyz), normalize(rd)));\n        ls = ls * ls;\n        ls = ls * ls;\n        col = vec3(1. - ff / 6., 1. - ff / 6., 1.);\n        col = vec3(1);\n    }\n    fragColor = texture(iChannel0, uv) + vec4(col, ls);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 178]], "test": "untested"}
{"id": "fd3SDN", "name": "Cool raymarching effect", "author": "SnoopethDuckDuck", "description": "forked from artofcode's thngy", "tags": ["raymarching", "template", "artofcode"], "likes": 14, "viewed": 425, "published": 3, "date": "1633106503", "time_retrieved": "2024-07-30T18:58:24.873603", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float b = .5 + .5 * cos(0.3 * iTime);\n    float bd = sdBox(p, vec3(0.8)) - .2;\n    float sd = length(p) - 1.2;\n    return min(bd,sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(3.5 * cos(iTime),2. * sin(0.5 * iTime), 3.5 * sin(iTime));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    float depth = 2.; //1.5 + cos(iTime);\n    \n    // comment / uncomment me\n    d = RayMarch(ro + rd * (1. + depth) * d, -0.5 * depth * rd);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(1.5*rd, n);\n        \n        float spec = pow(max(0., -r.y),32.);\n        spec = .5 + .5 * cos(0.00001*spec); // <-- absolute fudge but works alright\n       \n       float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       float a = atan(p.x,p.z);\n       // dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n       \n       col = 0.4 * vec3(dif) + 1.5 * cos(2. * a) * Bg(r);        \n       col *= (1. + spec);\n       \n       // comment / uncomment me\n       //col = vec3(dif);\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SDN.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1671, 1671, 1694, 1694, 1834], [1836, 1836, 1870, 1870, 2081], [2083, 2083, 2107, 2107, 2297], [2299, 2299, 2349, 2349, 2540], [2542, 2542, 2560, 2560, 2658], [2660, 2660, 2717, 2717, 3914]], "test": "untested"}
{"id": "NsdXD8", "name": "i21/1 - Crystal", "author": "Molive", "description": "wooo inktober\nthis is basically ink right\n\nwatch me successfully do no more of these haha", "tags": ["caustics", "inktober"], "likes": 17, "viewed": 418, "published": 3, "date": "1633100200", "time_retrieved": "2024-07-30T18:58:26.142211", "image_code": "//uniform sampler2D T;\n//layout(location = 2) uniform vec3 TexCoord;\n#define TexCoord vec3(iResolution.xy,0)\n#define T iChannel0\nconst float a = 3.;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{  \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 tex=texture(T,uv);\n    vec3 c= a*tex.rgb/tex.a;\n\n    vec3 color = c;\n    \n    float n = length(color);\n    color*=pow(n,1.1)*6.;\n\n\tcolor=color*(1.+(color/10.))/(1.+color);\n\n\tuv-=.5;   \n    // gamma correction and a slight blue color grading\n\tcolor=pow(color, .45*vec3(1.0,1.1,1.2))*(1.-dot(uv,uv)*.75);\n    \n\tfragColor.rgb=color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi (acos(-1.))\n\nconst int matDiffuse=0;\nconst int matMirror=1;\nconst int matBlack=2;\nconst int matLiquid=3;\nconst int matLight=4;\nconst vec3 lightpos=vec3(24.,12.,-29.);\n//const vec3 lightpos=vec3(19.,12.,-23.);\n#define Epsilon 1.000001\n#define pixelRadius 0.0001\n\n//A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nvec2 random( uvec2  v ) {return vec2(floatConstruct(hash( v.x ^ hash(v.y))),floatConstruct(hash( v.y ^ hash(v.x))));}\n\nvec2 uv;\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n    /// Returns a point on a sphere, r is in 0..1 range\nvec3 pointOnSphere(vec2 r) {\n    r=vec2(6.283185*r.x,2.*r.y-1.);\n    return vec3(sqrt(Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN\n}\n \n    /// Returns a cosine weighted sample\nvec3 lambertSample(vec3 n,vec2 r) {\n    return normalize(n*Epsilon+pointOnSphere(r)); // 1.001 required to avoid NaN\n}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// sphere of size ra centered at point ce\nvec4 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(-1.0); // no intersection\n    h = sqrt( h );\n    float t = (-b-h);\n    return vec4( t, (oc+t*rd)/ra );\n}\n\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nvec4 octahedronIntersect( in vec3 ro, in vec3 rd)\n{\n    vec3 sro = sign(ro);\n    rd = rd*sro;\n    ro = ro*sro;\n    \n    const vec3 v0 = vec3(5,0,0);\n    const vec3 v1 = vec3(0,0,5);\n    const vec3 v2 = vec3(0,5,0);\n    const vec3 v3 = vec3(0,0,-5);\n    const vec3 v4 = vec3(0,-5,0);\n    const vec3 v5 = vec3(-5,0,0);\n    const vec3 v1v0 = v1 - v0;\n    const vec3 v2v0 = v2 - v0;\n    const vec3 v3v0 = v3 - v0;\n    const vec3 v4v0 = v4 - v0;\n    const vec3 v1v5 = v1 - v5;\n    const vec3 v2v5 = v2 - v5;\n    const vec3 v3v5 = v3 - v5;\n    const vec3 v4v5 = v4 - v5;\n    vec3 rov0 = ro - v0;\n    vec3 rov5 = ro - v5;\n\n    const vec3 t1n = cross( v2v0, v1v0 );\n    const vec3 t2n = cross( v3v0, v2v0 );\n    const vec3 t3n = cross( v4v0, v3v0 );\n    const vec3 t4n = cross( v1v0, v4v0 );\n    const vec3 t5n = cross( v1v5, v2v5 );\n    const vec3 t6n = cross( v2v5, v3v5 );\n    const vec3 t7n = cross( v3v5, v4v5 );\n    const vec3 t8n = cross( v4v5, v1v5 );\n    vec3  q = cross( rov0, rd );\n    float d,t,u,v;\n    \n    d = 1.0/dot( rd, t1n );\n    u = d*dot( -q, v1v0 );\n    v = d*dot(  q, v2v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t1n, rov0 ), normalize(t1n*sro));\n    \n    d = 1.0/dot( rd, t2n );\n    u = d*dot( -q, v2v0 );\n    v = d*dot(  q, v3v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t2n, rov0 ), normalize(t2n*sro));\n    \n    d = 1.0/dot( rd, t4n );\n    u = d*dot( -q, v4v0 );\n    v = d*dot(  q, v1v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t4n, rov0 ), normalize(t4n*sro));\n    \n    d = 1.0/dot( rd, t3n );\n    u = d*dot( -q, v3v0 );\n    v = d*dot(  q, v4v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t3n, rov0 ), normalize(t3n*sro));\n    \n    q = cross( rov5, rd );\n    \n    d = 1.0/dot( rd, t5n );\n    u = d*dot( -q, v2v5 );\n    v = d*dot(  q, v1v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t5n, rov5 ), normalize(t5n*sro));\n    \n    d = 1.0/dot( rd, t6n );\n    u = d*dot( -q, v3v5 );\n    v = d*dot(  q, v2v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t6n, rov5 ), normalize(t6n*sro));\n    \n    d = 1.0/dot( rd, t8n );\n    u = d*dot( -q, v1v5 );\n    v = d*dot(  q, v4v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t8n, rov5 ), normalize(t8n*sro));\n    \n    // You can never see this face\n    /*d = 1.0/dot( rd, t7n );\n    u = d*dot( -q, v4v5 );\n    v = d*dot(  q, v3v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 ) return vec4( d*dot( -t7n, rov5 ), normalize(t7n*sro));*/\n    \n    return vec4(-1,1,0,0);\n}\n\nbool inside;\n\nvec4 octahedronIntersectInternal( in vec3 ro, in vec3 rd)\n{\n    vec3 sro = sign(ro);\n    rd = rd*sro;\n    ro = ro*sro;\n        \n    const vec3 v0 = vec3(5,0,0);\n    const vec3 v1 = vec3(0,0,5);\n    const vec3 v2 = vec3(0,5,0);\n    const vec3 v3 = vec3(0,0,-5);\n    const vec3 v4 = vec3(0,-5,0);\n    const vec3 v5 = vec3(-5,0,0);\n    const vec3 v1v0 = v1 - v0;\n    const vec3 v2v0 = v2 - v0;\n    const vec3 v3v0 = v3 - v0;\n    const vec3 v4v0 = v4 - v0;\n    const vec3 v1v5 = v1 - v5;\n    const vec3 v2v5 = v2 - v5;\n    const vec3 v3v5 = v3 - v5;\n    const vec3 v4v5 = v4 - v5;\n    vec3 rov0 = ro - v0;\n    vec3 rov5 = ro - v5;\n\n    const vec3 t1n = cross( v1v0, v2v0 );\n    const vec3 t2n = cross( v2v0, v3v0 );\n    const vec3 t3n = cross( v3v0, v4v0 );\n    const vec3 t4n = cross( v4v0, v1v0 );\n    const vec3 t5n = cross( v2v5, v1v5 );\n    const vec3 t6n = cross( v3v5, v2v5 );\n    const vec3 t7n = cross( v4v5, v3v5 );\n    const vec3 t8n = cross( v1v5, v4v5 );\n    float d,t,u,v;\n    \n    vec3 q = cross( rov5, rd );\n    vec4 side;\n    \n    d = 1.0/dot( rd, t7n );\n    u = d*dot(  q, v4v5 );\n    v = d*dot( -q, v3v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t7n, rov5 ), normalize(t7n*sro));\n    \n    d = 1.0/dot( rd, t8n );\n    u = d*dot(  q, v1v5 );\n    v = d*dot( -q, v4v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t8n, rov5 ), normalize(t8n*sro));\n    \n    d = 1.0/dot( rd, t6n );\n    u = d*dot(  q, v3v5 );\n    v = d*dot( -q, v2v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t6n, rov5 ), normalize(t6n*sro));\n\n    d = 1.0/dot( rd, t5n );\n    u = d*dot(  q, v2v5 );\n    v = d*dot( -q, v1v5 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t5n, rov5 ), normalize(t5n*sro));\n    \n    q = cross( rov0, rd );\n    vec4 side2;\n    \n    d = 1.0/dot( rd, t3n );\n    u = d*dot(  q, v3v0 );\n    v = d*dot( -q, v4v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t3n, rov0 ), normalize(t3n*sro));\n    \n    d = 1.0/dot( rd, t4n );\n    u = d*dot(  q, v4v0 );\n    v = d*dot( -q, v1v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t4n, rov0 ), normalize(t4n*sro));\n    \n    d = 1.0/dot( rd, t2n );\n    u = d*dot(  q, v2v0 );\n    v = d*dot( -q, v3v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t2n, rov0 ), normalize(t2n*sro));\n    \n    d = 1.0/dot( rd, t1n );\n    u = d*dot(  q, v1v0 );\n    v = d*dot( -q, v2v0 );\n    \n    if( u>0.0 && v>0.0 && (u+v)<1.0 && d < 0.) return vec4( d*dot( -t1n, rov0 ), normalize(t1n*sro));\n    \n    return vec4(-1,1,0,0);\n}\n\nvec2 hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// hacky parameter to control the size\nfloat T=4.;\n\nint mat;\nfloat inv;\n\n// intersection function\nvec4 iScene(vec3 ro, vec3 rd)\n{\n    mat = matLiquid;\n    vec4 innerScene;\n    if (inside) {\n    innerScene = octahedronIntersectInternal(ro,rd);\n    } else {\n    innerScene = octahedronIntersect(ro,rd);\n    }\n    if (innerScene.x > 0.) return innerScene;\n    mat = matLight;\n    vec4 light = sphIntersect(ro,rd,lightpos,10.);\n    if (light.x > 0.) return light;\n    mat = matDiffuse;\n    float plane = plaIntersect(ro, rd, vec4(0,1,0,5));\n    if (plane > 0.) return vec4(plane, 0.,1.,0.);\n    //vec4 curve = iCylinderInverse(ro,rd, vec3(-10.,11.,0.), vec3(0.,0.,1.),15.);\n    //if (curve.x > 0. && ro.x+rd.x*curve.x <= -10.) return curve;\n    return vec4(0);\n}\n\nvec2 rv2;\nint bounce = 0;\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    const vec3 lightdir = normalize(vec3(.7,.4,-1));\n    \n    const float THRESHOLD = .02;\n\n    vec3 accum = vec3(1);\n    inside = false;\n    for(bounce = 0;bounce<3;bounce++)\n    {\n        float t = 0.;\n        float k = 0.;\n        vec3 n = vec3(1,0,0);\n        vec3 h = vec3(0);\n        rv2 = random(uvec2(abs(rv2*2000.)));\n\n        t = 0.;\n        k = 0.;\n        n = vec3(1,0,0);\n        h = vec3(0);\n        mat = matBlack;\n        vec4 scene = iScene(cam,dir);\n        if (scene.x > 0.) \n        {\n            t = scene.x;\n            n = scene.yzw;\n            h = cam+dir*t;\n            k = THRESHOLD;\n            \n            /*if (inside) {\n                n= n*-1.;\n            }*/\n\n            // if we hit something\n\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel*=1.-step(.99,fresnel);\n            \n            // debug normals visualization\n            //if (inside)\n            //if (mat != matBound)\n            //if (mat != matLiquid)\n            //return vec3(n*.1+0.1);\n            //return (n*.5+.5) * (.7+.3*step(1.4,length(step(.1,fract(h.xz-.5)))));\n\n            if (mat == matDiffuse)\n            {\n                // bounce the ray in a random direction\n                if (rv2.x > 0.) {\n                    dir = lambertSample(n,rv2);\n                } else {\n                    dir = normalize(lightpos + lambertSample(n,rv2) * 6. - cam);\n                }\n                accum *= dot(dir,n);\n            }\n            else if (mat == matLight)\n            {\n                return accum * vec3(6.,5.5,5.) * step(.8,dot(dir,lightdir));\n            }\n            else if (mat == matMirror)\n            {\n                n += sin(h*4.).bgr*.001;\n                n += sin(h*3.77).bgr*.001;\n                n += sin(h*.737).bgr*.001;\n                \n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matLiquid)\n            {\n                // Randomly reflect or refract, probability based on fresnel term\n                // If non-fresnel, refract\n                if (rv2.x > fresnel) {\n                    // refraction\n                    // Index of refraction\n                    float ior = inside ? 1.364 : 1./1.364;\n        \n                    // Find refraction angle, accounting for surface roughness\n                    vec3 rayDir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              refract(dir, n, ior), // the refracted angle\n                              lambertSample(-n, rv2), // and a random angle projected into the surface\n                              0.01 // based on how smooth the glass surface is\n                              )\n                          );\n        \n                    // Test for total internal reflection\n                    if(dot(n, dir) < 0.0) {\n                        // Not TIR, we're OK to refract\n            \n                        // Set the ray direction\n                        dir=rayDir;\n            \n                        // Flip the inside value as we pass through the surface\n                        inside=!inside;\n                        bounce--;\n                        cam = h + dir * 2. * max(THRESHOLD * 4.,abs(k));\n\n                        if (!inside) {\n                        accum *= vec3(1.) - t * vec3(0.1,0., 0.01);\n                        }\n                        continue;\n                    }\n                }\n    \n                // Ray failed to refract, therefore reflection\n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            } else {\n            return vec3(0,0,1);\n            }\n            \n            cam = h + dir * THRESHOLD * 1.1 / dot(dir,n);\n        }\n        else {\n        bounce++;\n        break;\n        }\n    }\n    return vec3(0);\n}\n\nvec2 ringDof(vec2 seed)\n{\n    seed=fract(seed);\n    if (seed.y>seed.x)\n        seed=1.-seed;\n    float r=seed.x;\n    float a=(seed.y/seed.x)*pi*2.;\n    return vec2(cos(a),sin(a))*r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = float(((int(iFrame*73856093))^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\trv2 = hash2( 24.4316544311+float(iFrame)+seed );\n    //rv2 = random(uvec2(normalize(abs(vec2(seed, 24.4316544311+iFrame+seed)))*20000.0));\n\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // make a camera\n\tvec3 cam = vec3(1.,1.,-80.);\n    //vec3 cam = vec3(0.1,0.1,0.1);\n    vec3 dir = normalize(vec3(uv,2.5));\n\n    // slight jitter for dof\n    //const float dofScale = .05 ;\n    //const float dofDist = 10.;\n    //vec2 dofJitter = ringDof(rv2);\n    //cam.xy += dofJitter*dofScale;\n    //dir.xy -= dofJitter*dofScale/dofDist;\n\n    // spin it to an isometric angle\n    cam.yz = rotate(cam.yz, pi/12.);\n    dir.yz = rotate(dir.yz, pi/12.);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = .8-3.*(iMouse.y/iResolution.y);\n    \tcam.yz = rotate(cam.yz, a);\n    \tdir.yz = rotate(dir.yz, a);\n    }\n\n    // spin it to an isometric angle\n    cam.xz = rotate(cam.xz, pi/1.8);\n    dir.xz = rotate(dir.xz, pi/1.8);\n    \n    // debug camera rotation\n    if (iMouse.z > 0.) {\n        float a = 1.-8.*(iMouse.x/iResolution.x);\n    \tcam.xz = rotate(cam.xz, a);\n    \tdir.xz = rotate(dir.xz, a);\n    }\n    \n    // compute the pixel color\n    vec3 pixel = vec3(0);\n    for (int i = 0; i < 8; i++) {\n        pixel += trace(cam,dir);\n    }\n    pixel /= 8.;\n   \n    // reset buffer if we're clicking\n     if (iMouse.z > 0.) fragColor *= .1;\n\n    // accumulate the pixel\n    //if(pixel.r >= 0.)\n    fragColor += vec4(pixel,1);\n    \n    //gl_FragColor = vec4(random(uvec2(abs(uv*1000.))),1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 202, 202, 583]], "test": "untested"}
{"id": "sstXW8", "name": "Wavy Lines Texture", "author": "Jordan", "description": "Click to change the waviness. Gradient noise by IQ:  https://www.shadertoy.com/view/XdXGW8", "tags": ["noise", "line", "texture", "lines", "perlin", "wavy", "wood", "rock"], "likes": 10, "viewed": 723, "published": 3, "date": "1633075304", "time_retrieved": "2024-07-30T18:58:26.913150", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Overall image scale\n    vec2 uv = 12.0*fragCoord/iResolution.x;\n    \n    // Image scrolling with time\n    uv.x = uv.x + 0.8*iTime;\n    uv.y = uv.y + 2.5*sin(0.2*iTime);\n    \n    // Overall noise scale\n    vec2 uv_nse = 0.2*uv;\n    \n    // Noise octaves\n    float f = 0.0;\n    mat2 m = mat2( 1.0,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv_nse ); uv_nse = m*uv_nse;\n    f += 0.2500*noise( uv_nse ); uv_nse = m*uv_nse;\n    f += 0.1250*noise( uv_nse ); uv_nse = m*uv_nse;\n    f += 0.0625*noise( uv_nse ); uv_nse = m*uv_nse;\n\tf = 0.5 + 0.5*f;\n\t\n    // Waviness amount\n    float waviness = 20.0*(0.5 + 0.5*sin(0.007*iMouse.x));\n    \n    // Apply waviness to the coordinates\n    uv.y = uv.y + f*waviness;\n    \n    // Draw something with the wavy coordinates\n    // Below is basically just a nicer looking version of \"fragColor = vec4(sin(uv.y*100.0))\"\n    float c = 0.7+noise(uv*vec2(0.1,15.5)); \n    fragColor = vec4(c*c-0.5);\n    }", "image_inputs": [], "common_code": "// Gradient noise by IQ: https://www.shadertoy.com/view/XdXGW8\n\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Gradient Noise (http://en.wikipedia.org/wiki/Gradient_noise), not to be confused with\n// Value Noise, and neither with Perlin's Noise (which is one form of Gradient Noise)\n// is probably the most convenient way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces smoother and higher quality than Value Noise, but it's of course slighty more\n// expensive.\n//\n// The princpiple is to create a virtual grid/latice all over the plane, and assign one\n// random vector to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined, the four vertices of the grid are determined and their random vectors\n// fetched. Then, the position of the current point under  evaluation relative to each\n// vertex is doted (projected) with that vertex' random vector, and the result is\n// bilinearly interpolated with a smooth interpolant.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 84, 995]], "test": "untested"}
{"id": "7dtXDn", "name": "Spring on Sliding Cart", "author": "oneshade", "description": "Pull with the mouse.", "tags": ["2d", "physics", "block", "spring", "sliding"], "likes": 16, "viewed": 210, "published": 3, "date": "1633061112", "time_retrieved": "2024-07-30T18:58:27.888542", "image_code": "// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// https://www.shadertoy.com/view/tlcBW2\nfloat udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Path of mass on spring\n    color = 1.0 - max(1.0 - color, texture(iChannel1, fragCoord / iResolution.xy).rgb);\n\n    // Track\n    drawSDF(abs(uv.y), vec3(0.0));\n\n    // Cart\n    float cartPos = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    drawSDF(sdBox(uv - vec2(cartPos, 0.0), cartSize), vec3(1.0, 0.0, 0.0));\n\n    // Spring\n    vec2 oscAnchor = vec2(cartPos, 0.0) + oscOffset;\n    vec2 oscPos = texelFetch(iChannel0, ivec2(1, 0), 0).xy - oscAnchor;\n\n    uv -= oscAnchor;\n    float oscLength = length(oscPos);\n    vec2 dir = oscPos / oscLength;\n    uv *= mat2(dir.x, dir.y, -dir.y, dir.x);\n\n    if (uv.x > 0.0 && uv.x < oscLength) drawSDF(udTriangleWave(uv, 12.0 / oscLength, 0.7), vec3(0.0));\n    drawSDF(sdDisk(uv, vec2(oscLength, 0.0), 2.0 * oscMass), vec3(0.0, 0.0, 1.0));\n\n    // Vignette\n    color *= 1.0 - 2.0 * pow(length(fragCoord / iResolution.xy - 0.5), 4.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) fragColor = vec4(0.0, 0.1, 0.0, 0.0);\n        if (iFragCoord == ivec2(1, 0)) fragColor = vec4(-3.0, 6.0, 0.01, -0.05);\n    }\n\n    if (iFrame > 0) {\n        vec2 cart = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n        float cartPos = cart.x, cartVel = cart.y;\n\n        vec4 osc = texelFetch(iChannel0, ivec2(1, 0), 0);\n        vec2 oscPos = osc.xy, oscVel = osc.zw;\n\n        // Cart\n        if (iFragCoord == ivec2(0, 0)) {\n            oscPos -= vec2(cartPos, 0.0) + oscOffset;\n            float oscLength = length(oscPos);\n            float force = oscPos.x / oscLength;\n            float extension = oscRestLength - oscLength;\n            force *= -oscSpringiness * extension;\n\n            cartVel += force / cartMass * dt;\n            cartVel *= trackFriction;\n            cartPos += cartVel * dt;\n\n            fragColor = vec4(cartPos, cartVel, 0.0, 0.0);\n        }\n\n        // Spring\n        if (iFragCoord == ivec2(1, 0)) {\n            vec2 oscAnchor = vec2(cartPos, 0.0) + oscOffset;\n            oscPos -= oscAnchor;\n\n            float oscLength = length(oscPos);\n            vec2 force = -oscPos / oscLength;\n            float extension = oscRestLength - oscLength;\n            force *= -oscSpringiness * extension;\n\n            force.y -= oscMass * gravity;\n\n            if (iMouse.z > 0.0) {\n                vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 8.0 - oscAnchor;\n                force += (mouse - oscPos) * 0.5;\n            }\n\n            oscVel += force / oscMass * dt;\n            oscVel *= oscDamping;\n            oscPos += oscVel * dt;\n\n            oscPos += oscAnchor;\n            fragColor = vec4(oscPos, oscVel);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define gravity 1.0\n\n#define trackFriction 0.999\n\n#define cartMass 1.0\n#define cartSize vec2(1.5, 0.75)\n\n#define oscMass 0.2\n#define oscRestLength 4.0\n#define oscSpringiness 0.5//0.25\n#define oscDamping 0.94\n#define oscOffset vec2(0.0, 0.4)\n\n#define dt 0.1", "buffer_b_code": "float sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    vec4 oscState = texelFetch(iChannel0, ivec2(1, 0), 0);\n    fragColor.rgb = max(fragColor.rgb, smoothstep(16.0 / iResolution.y, 0.0, sdLine(uv, oscState.xy - oscState.zw * dt, oscState.xy)));\n    fragColor.rgb *= 0.99;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 55, 55, 163], [165, 165, 213, 213, 245], [247, 247, 282, 282, 362], [364, 405, 467, 467, 720], [802, 802, 857, 857, 1912]], "test": "untested"}
{"id": "NdtXD8", "name": "lineto false 3d-2d", "author": "jorge2017a2", "description": "lineto false 3d-2d", "tags": ["linetofalse3d2d"], "likes": 6, "viewed": 315, "published": 3, "date": "1633051812", "time_retrieved": "2024-07-30T18:58:28.857950", "image_code": "/// por jorge flores P.\n// jorge2017a1@\n//lineto false 3d---2d\n\n//referencia\n//.....FabriceNeyret2\n//https://www.shadertoy.com/view/MlVSWc\n//-----letras\n//https://www.shadertoy.com/view/MlSXDm...by David Hoskins.\n\n//--------------image\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n\nvec2 gidDistColor;\nfloat _x,_y, _z;\nfloat x0,y0,z0;\nvec2 gUV;\nvec2 frag;\n\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(-distA, distB);}\n    \n\nvec2 differenceSDF(vec2 distA, vec2 distB)\n{  return max(distA,-distB); }\n\nvec2 intersectSDF(vec2 distA, vec2 distB)\n{    return max(distA, distB);}\n\nvec2 unionSDF(vec2 distA, vec2 distB)\n{ \n    if(distA.x< distB.x)\n        return distA;\n    else\n        return distB;    \n}\n  \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nvoid IniciarPath(vec2 uv)\n{   gUV=uv;\n    gidDistColor= vec2(10000.0,1.0);\n}\n\n//moveto\nvoid M(float x, float y)\n{   _x=x; _y=y;\n    x0=x; y0=y;\n}\n\nvec3 FinPath(vec3 colIn,  vec3 colOut)    \n{   colOut= DrawFig(colIn, colOut,gidDistColor.x);\n    return colOut;\n}\n\nvec3 FinPathId(float idColor,  vec3 colOut)    \n{   \n    vec3 colIn=GetColor(int(idColor));\n    colOut= DrawFig(colIn, colOut,gidDistColor.x);\n    return colOut;\n}\n\nvec3 FinPathDir(vec3 colOut)    \n{   \n    vec3 colIn=GetColor(int(gidDistColor.y));\n    colOut= DrawFig(colIn, colOut,gidDistColor.x);\n    return colOut;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid Z(void)\n{\n    float d1=line(gUV, vec2(_x,_y), vec2(x0,y0));\n    gidDistColor = opU(gidDistColor,  vec2( d1,gidDistColor.y ) );  \n}\n\n//line\nvoid L(float x, float y)\n{    float d1=line(gUV, vec2(_x,_y), vec2(x,y));\n    gidDistColor = unionSDF(gidDistColor,  vec2(d1,gidDistColor.y) ); \n    _x=x;\n    _y=y;\n}\n\n\nvec2 Conv3da2dFrag(vec3 pos )\n{ float xm=frag.x/1.0;\n  float ym=frag.y/1.0;\n  float horizon = 0.3;   //0.2\n  float fov = .5;\n  float scaling = 0.5;\n  vec2 s=vec2(pos.x+(xm+(pos.z-horizon)*scaling), pos.y+(ym+(pos.z-horizon)*scaling));\n    return s;    \n}\n\nvec2 convertirv3da2dEscala(vec3 p3)\n{\n    float escala=1.0/30.0;\n    p3*=escala;\n    vec2 p2=Conv3da2dFrag(p3);\n    return p2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec3 col=vec3(1.0);\n    \n    float aspect = min(iResolution.x, iResolution.y);\n    float tp = 1.0 / aspect;\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) * tp;\n    uv-=vec2(-0.4,-0.2); \n    frag=1.0/iResolution.xy; \n    \n    \n     vec3 p300=vec3(5.0,6.0,0.0); \n     vec3 p30=vec3( 4.0,6.0,0.0);\n     vec3 p31=vec3( 4.0,7.0,0.0);\n     vec3 p32=vec3( 3.0,7.0,0.0);\n     vec3 p33=vec3( 3.0,2.0,0.0);\n     vec3 p34=vec3( 10.0,2.0,0.0);\n     vec3 p35=vec3( 10.0,7.0,0.0);\n     vec3 p36=vec3( 9.0, 7.0,0.0);\n     vec3 p37=vec3( 9.0, 6.0,0.0);\n     vec3 p38=vec3( 8.0, 6.0,0.0);\n  \n      vec2 p00=convertirv3da2dEscala(p300);\n      vec2 p0=convertirv3da2dEscala(p30);\n      vec2 p1=convertirv3da2dEscala(p31);\n      vec2 p2=convertirv3da2dEscala(p32);\n      vec2 p3=convertirv3da2dEscala(p33);\n      vec2 p4=convertirv3da2dEscala(p34);\n      vec2 p5=convertirv3da2dEscala(p35);\n      vec2 p6=convertirv3da2dEscala(p36);\n      vec2 p7=convertirv3da2dEscala(p37);\n      vec2 p8=convertirv3da2dEscala(p38);  \n      \n         \n    IniciarPath(uv );\n    M(p00.x,p00.y);\n    L(p0.x, p0.y);\n    L(p1.x, p1.y);\n    L(p2.x, p2.y);\n    L(p3.x, p3.y);\n    L(p4.x, p4.y);\n    L(p5.x, p5.y);\n    L(p6.x, p6.y);\n    L(p7.x, p7.y);\n    L(p8.x, p8.y);\n    col= FinPath(vec3(1.0,0.0,0.0), col);\n    ///----------\n    \n    //lineas inclinadas\n    float pz=14.0;\n     vec3 p36b=vec3( 9.0, 7.0,pz);\n     vec3 p37b=vec3( 9.0, 6.0,pz);\n     vec3 p35b=vec3( 10.0,7.0,pz);\n     vec3 p34b=vec3( 10.0,2.0,pz);\n     vec3 p30b=vec3( 4.0,6.0,pz);\n     vec3 p31b=vec3( 4.0,7.0,pz);\n     vec3 p32b=vec3( 3.0,7.0,pz);\n     vec3 p300b=vec3(5.0,6.0,pz); \n     vec3 p38b=vec3( 8.0, 6.0,pz);\n      \n     vec2 p2b0=convertirv3da2dEscala(p37);\n     vec2 p2b1=convertirv3da2dEscala(p37b);\n     \n     vec2 p3b0=convertirv3da2dEscala(p36);\n     vec2 p3b1=convertirv3da2dEscala(p36b);\n     \n     vec2 p5b0=convertirv3da2dEscala(p35);\n     vec2 p5b1=convertirv3da2dEscala(p35b);\n     \n     vec2 p4b0=convertirv3da2dEscala(p34);\n     vec2 p4b1=convertirv3da2dEscala(p34b);\n     \n     vec2 p330b0=convertirv3da2dEscala(p30);\n     vec2 p330b1=convertirv3da2dEscala(p30b);\n     \n     vec2 p331b0=convertirv3da2dEscala(p31);\n     vec2 p331b1=convertirv3da2dEscala(p31b);\n     \n     vec2 p332b0=convertirv3da2dEscala(p32);\n     vec2 p332b1=convertirv3da2dEscala(p32b);\n     \n     vec2 p300b0=convertirv3da2dEscala(p300);\n     vec2 p300b1=convertirv3da2dEscala(p300b);\n     \n     vec2 p338b0=convertirv3da2dEscala(p38);\n     vec2 p338b1=convertirv3da2dEscala(p38b);\n     \n     /*\n     IniciarPath(uv );\n     M(p2b0.x, p2b0.y);\n     L(p2b1.x, p2b1.y);\n     col= FinPath(vec3(0.0,1.0,0.0), col);\n     */\n      IniciarPath(uv );\n     M(p3b0.x, p3b0.y);\n     L(p3b1.x, p3b1.y);\n     col= FinPath(vec3(0.0,0.0,1.), col);\n\n     IniciarPath(uv );\n     M(p5b0.x, p5b0.y);\n     L(p5b1.x, p5b1.y);\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n\n     IniciarPath(uv );\n     M(p4b0.x, p4b0.y);\n     L(p4b1.x, p4b1.y);\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     IniciarPath(uv );\n     M(p330b0.x, p330b0.y);\n     L(p330b1.x, p330b1.y);\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     IniciarPath(uv );\n     M(p331b0.x, p331b0.y);\n     L(p331b1.x, p331b1.y);\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     IniciarPath(uv );\n     M(p332b0.x, p332b0.y);\n     L(p332b1.x, p332b1.y);\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     IniciarPath(uv );\n     M(p300b0.x, p300b0.y);\n     L(p300b1.x, p300b1.y);\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     IniciarPath(uv );\n     M(p338b0.x, p338b0.y);\n     L(p338b1.x, p338b1.y);\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     ///------parte de atras\n       pz=14.0;\n     p300=vec3(5.0,6.0,pz); \n     p30=vec3( 4.0,6.0,pz);\n     p31=vec3( 4.0,7.0,pz);\n     p32=vec3( 3.0,7.0,pz);\n     p33=vec3( 3.0,2.0,pz);\n     p34=vec3( 10.0,2.0,pz);\n     p35=vec3( 10.0,7.0,pz);\n     p36=vec3( 9.0, 7.0,pz);\n     p37=vec3( 9.0, 6.0,pz);\n     p38=vec3( 8.0, 6.0,pz);\n     \n     p00=convertirv3da2dEscala(p300);\n     p0=convertirv3da2dEscala(p30);\n     p1=convertirv3da2dEscala(p31);\n     p2=convertirv3da2dEscala(p32);\n     p3=convertirv3da2dEscala(p33);\n     p4=convertirv3da2dEscala(p34);\n     p5=convertirv3da2dEscala(p35);\n     p6=convertirv3da2dEscala(p36);\n     p7=convertirv3da2dEscala(p37);\n     p8=convertirv3da2dEscala(p38);  \n         \n    IniciarPath(uv );\n    M(p00.x,p00.y);\n    L(p0.x, p0.y);\n    L(p1.x, p1.y);\n    L(p2.x, p2.y);\n    L(p3.x, p3.y);\n    L(p4.x, p4.y);\n    L(p5.x, p5.y);\n    L(p6.x, p6.y);\n    L(p7.x, p7.y);\n    L(p8.x, p8.y);\n    col= FinPath(vec3(0.0,0.0,0.0), col);\n    \n    col= mix(col, texture(iChannel0, uv-vec2(0.2,-0.2)).rgb,0.4);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///-------------common\nvec3  Arrcolores[] = vec3[] (\nvec3(0.,0.,0.),\nvec3(0.,0.,1.),\nvec3(0.,1.,0.),\nvec3(0.,1.,1.),\nvec3(1.,0.,0.),\nvec3(1.,0.,1.),\nvec3(1.,1.,0.),\nvec3(1.,1.,1.)\n);\n\nvec3 GetColor(int i)\n{    \n    //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n", "buffer_a_code": "//https://www.shadertoy.com/view/MlSXDm\n// Learning to Dig\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//8x8x1 font data...\n#define _A col += char(vec4(0x386C, 0xC6C6, 0xFEC6, 0xC600));loc.x+=1.;\n#define _B col += char(vec4(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00));loc.x+=1.;\n#define _C col += char(vec4(0x3C66, 0xC0C0, 0xC066, 0x3C00));loc.x+=1.;\n#define _D col += char(vec4(0xF8CC, 0xC6C6, 0xC6CC, 0xF800));loc.x+=1.;\n#define _E col += char(vec4(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00));loc.x+=1.;\n#define _F col += char(vec4(0xFEC0, 0xC0FC, 0xC0C0, 0xC000));loc.x+=1.;\n#define _G col += char(vec4(0x3E60, 0xC0CE, 0xC666, 0x3E00));loc.x+=1.;\n#define _H col += char(vec4(0xC6C6, 0xC6FE, 0xC6C6, 0xC600));loc.x+=1.;\n#define _I col += char(vec4(0x7E18, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _J col += char(vec4(0x606, 0x606, 0x6C6, 0x7C00));loc.x+=1.;\n#define _K col += char(vec4(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _L col += char(vec4(0x6060, 0x6060, 0x6060, 0x7E00));loc.x+=1.;\n#define _M col += char(vec4(0xC6EE, 0xFEFE, 0xD6C6, 0xC600));loc.x+=1.;\n#define _N col += char(vec4(0xC6E6, 0xF6FE, 0xDECE, 0xC600));loc.x+=1.;\n#define _O col += char(vec4(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _P col += char(vec4(0xFCC6, 0xC6C6, 0xFCC0, 0xC000));loc.x+=1.;\n#define _Q col += char(vec4(0x7CC6, 0xC6C6, 0xDECC, 0x7A00));loc.x+=1.;\n#define _R col += char(vec4(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _S col += char(vec4(0x78CC, 0xC07C, 0x6C6, 0x7C00));loc.x+=1.;\n#define _T col += char(vec4(0x7E18, 0x1818, 0x1818, 0x1800));loc.x+=1.;\n#define _U col += char(vec4(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _V col += char(vec4(0xC6C6, 0xC6EE, 0x7C38, 0x1000));loc.x+=1.;\n#define _W col += char(vec4(0xC6C6, 0xD6FE, 0xFEEE, 0xC600));loc.x+=1.;\n#define _X col += char(vec4(0xC6EE, 0x7C38, 0x7CEE, 0xC600));loc.x+=1.;\n#define _Y col += char(vec4(0x6666, 0x663C, 0x1818, 0x1800));loc.x+=1.;\n#define _Z col += char(vec4(0xFE0E, 0x1C38, 0x70E0, 0xFE00));loc.x+=1.;\n#define _a col += char(vec4(0x0, 0x7C06, 0x7EC6, 0x7E00));loc.x+=1.;\n#define _b col += char(vec4(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _c col += char(vec4(0x0, 0x7EC0, 0xC0C0, 0x7E00));loc.x+=1.;\n#define _d col += char(vec4(0x606, 0x7EC6, 0xC6C6, 0x7E00));loc.x+=1.;\n#define _e col += char(vec4(0x0, 0x7CC6, 0xFEC0, 0x7C00));loc.x+=1.;\n#define _f col += char(vec4(0xE18, 0x7E18, 0x1818, 0x1800));loc.x+=1.;\n#define _g col += char(vec4(0x0, 0x7EC6, 0xC67E, 0x67C));loc.x+=1.;\n#define _h col += char(vec4(0xC0C0, 0xFCC6, 0xC6C6, 0xC600));loc.x+=1.;\n#define _i col += char(vec4(0x1800, 0x3818, 0x1818, 0x7E00));loc.x+=1.;\n#define _j col += char(vec4(0xC00, 0x1C0C, 0xC0C, 0xC78));loc.x+=1.;\n#define _k col += char(vec4(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _l col += char(vec4(0x3818, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _m col += char(vec4(0x0, 0xFCB6, 0xB6B6, 0xB600));loc.x+=1.;\n#define _n col += char(vec4(0x0, 0xFCC6, 0xC6C6, 0xC600));loc.x+=1.;\n#define _o col += char(vec4(0x0, 0x7CC6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _p col += char(vec4(0x0, 0xFCC6, 0xC6FC, 0xC0C0));loc.x+=1.;\n#define _q col += char(vec4(0x0, 0x7EC6, 0xC67E, 0x606));loc.x+=1.;\n#define _r col += char(vec4(0x0, 0x6E70, 0x6060, 0x6000));loc.x+=1.;\n#define _s col += char(vec4(0x0, 0x7CC0, 0x7C06, 0xFC00));loc.x+=1.;\n#define _t col += char(vec4(0x1818, 0x7E18, 0x1818, 0x1800));loc.x+=1.;\n#define _u col += char(vec4(0x0, 0xC6C6, 0xC6C6, 0x7E00));loc.x+=1.;\n#define _v col += char(vec4(0x0, 0x6666, 0x663C, 0x1800));loc.x+=1.;\n#define _w col += char(vec4(0x0, 0xB6B6, 0xB6B6, 0x7E00));loc.x+=1.;\n#define _x col += char(vec4(0x0, 0xC6FE, 0x38FE, 0xC600));loc.x+=1.;\n#define _y col += char(vec4(0x0, 0xC6C6, 0xC67E, 0x67C));loc.x+=1.;\n#define _z col += char(vec4(0x0, 0xFE1C, 0x3870, 0xFE00));loc.x+=1.;\n#define _0 col += char(vec4(0x384C, 0xC6C6, 0xC664, 0x3800));loc.x+=1.;\n#define _1 col += char(vec4(0x1838, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _2 col += char(vec4(0x7CC6, 0xE3C, 0x78E0, 0xFE00));loc.x+=1.;\n#define _3 col += char(vec4(0x7E0C, 0x183C, 0x6C6, 0x7C00));loc.x+=1.;\n#define _4 col += char(vec4(0x1C3C, 0x6CCC, 0xFE0C, 0xC00));loc.x+=1.;\n#define _5 col += char(vec4(0xFCC0, 0xFC06, 0x6C6, 0x7C00));loc.x+=1.;\n#define _6 col += char(vec4(0x3C60, 0xC0FC, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _7 col += char(vec4(0xFEC6, 0xC18, 0x3030, 0x3000));loc.x+=1.;\n#define _8 col += char(vec4(0x78C4, 0xE478, 0x9E86, 0x7C00));loc.x+=1.;\n#define _9 col += char(vec4(0x7CC6, 0xC67E, 0x60C, 0x7800));loc.x+=1.;\n#define _EXC col += char(vec4(0x3838, 0x3830, 0x3000, 0x3000));loc.x+=1.;\n#define _QTN col += char(vec4(0x7CFE, 0xC60C, 0x3800, 0x3800));loc.x+=1.;\n#define _COM col += char(vec4(0x0, 0x0, 0x30, 0x3060));loc.x+=1.;\n#define _APO col += char(vec4(0x3030, 0x3000, 0x0, 0x0));loc.x+=1.;\n#define _STP col += char(vec4(0x0, 0x0, 0x30, 0x3000));loc.x+=1.;\n#define _SP loc.x+=1.; \n\nvec2 loc;\nvec2 crd;\n\nfloat char(in vec4 b)\n{\n    float bin;\n    vec2 p = crd- (loc * 9.0);\n    if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n    \n\tp = floor(8.0-p);    int c = int(p.y / 2.0);\n    if (c == 0)\n    {\n    \tbin = b.x;\n    }else\n    if (c == 1)\n    {\n    \tbin = b.y;\n    }else\n    if (c == 2)\n    {\n    \tbin = b.z;\n    }else\n    if (c == 3)\n    {\n    \tbin = b.w;\n    }\n    if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n\treturn mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n\t\n    crd = coord*0.5;\n    \n    float col = 0.0;\n     //loc = vec2(0, 0);\n    // _A _B _C _D _E _F _G _H _I _J _K _L _M _N _O _P _Q _R _S _T _U _V _W _X _Y _Z\n     //loc = vec2(0, 1);\n    //_a _b _c _d _e _f _g _h _i _j _k _l _m _n _o _p _q _r _s _t _u _v _w _x _y _z\n    //loc = vec2(0, 2);\n    //_0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _EXC _QTN _STP _COM _APO\n    \n     \n     loc = vec2(17.0,1.0);\n     _c _o _d _e _SP _b _y _SP _J _F\n    \n\tfragColor = vec4(col);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 517, 564, 564, 591], [592, 592, 635, 635, 662], [663, 663, 711, 711, 739], [746, 746, 790, 790, 819], [821, 821, 864, 864, 894], [896, 896, 935, 935, 1020], [1024, 1024, 1086, 1086, 1276], [1279, 1279, 1336, 1336, 1402], [1404, 1404, 1431, 1431, 1480], [1482, 1491, 1517, 1517, 1549], [1551, 1551, 1595, 1595, 1665], [1667, 1667, 1716, 1716, 1830], [1832, 1832, 1866, 1866, 1987], [1989, 1989, 2036, 2036, 2155], [2157, 2157, 2171, 2171, 2292], [2294, 2301, 2327, 2327, 2467], [2470, 2470, 2501, 2501, 2724], [2726, 2726, 2763, 2763, 2854], [2856, 2856, 2913, 2913, 7653]], "test": "untested"}
{"id": "fsG3zd", "name": "mouse speed example", "author": "ArmandB", "description": "an example showing how to find the speed of your mouse", "tags": ["mouse", "buffer"], "likes": 3, "viewed": 216, "published": 3, "date": "1633049585", "time_retrieved": "2024-07-30T18:58:29.738595", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord); //set up coords\n    vec3 col = vec3(0); //initialize color\n    \n    float speed = texelFetch(iChannel0, ivec2(0), 0).z; //get speed from buffer\n    if (float(iCoord.y) <= speed){ //if current pixel y is <= mouse speed\n        col = vec3(0.2,0.8,0); //set color to green\n    }\n\n    fragColor = vec4(col,1.0); // Output to screen\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord); //set up coords\n    vec3 col = vec3(0); //initialize color\n    \n    if (iCoord == ivec2(0,0)){\n        vec2 prevMousePos = texelFetch(iChannel0, ivec2(0), 0).xy; //read out prev pos from buffer\n        vec2 mousePos = iMouse.xy; //set the current pos\n        float speed = length(mousePos - prevMousePos); //get the mouse speed\n        col = vec3(mousePos, speed); //store data in color\n    }\n    \n    fragColor = vec4(col,1.0); //write the speed and current pos to the buffer\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsG3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 424]], "test": "untested"}
{"id": "NdtSD8", "name": "bubbles uncooperative", "author": "xenn", "description": "how do I remove that weird interference, is it from an alpha channel hiccup?", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 8, "viewed": 407, "published": 3, "date": "1633048040", "time_retrieved": "2024-07-30T18:58:30.734931", "image_code": "\n// Fork of \"Nebulous Nonformanifest\" by xenn. https://shadertoy.com/view/fdV3RW\n// 2021-09-10 01:34:21\n\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                   //   col = min(col,col2);\n                      color += max(color,col);\n                      col2 += mix(col2,color,0.95);\n                     col2 = max(col2,col);\n                      \n                       \n      color = max(col2,col), color;\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color + col * color ), (max(col,(color / 3.0))))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lovely Bubbles\n// by @P_Malin\n// https://www.shadertoy.com/view/Nl2SRc\n//\n// Some lovely shadertoy bubbles.\n// I've wanted to implement something with thin film interference for a while.\n\n\n// CAMERA\n\nvec2 GetWindowCoord( vec2 uv )\n{\n\tvec2 window = uv * 2.0 - 1.0;\n\twindow.x *= iResolution.x / iResolution.y;\n\n\treturn window;\t\n}\n\nvec3 GetCameraRayDir( vec2 window, vec3 cameraPos, vec3 cameraTarget, float fov )\n{\n\tvec3 forward = normalize( cameraTarget - cameraPos );\n\tvec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ) );\n\tvec3 up = normalize( cross( forward, right ) );\n\t\t\t\t\t\t\t  \n\tvec3 dir = normalize(window.x * right + window.y * up + forward * fov);\n\n\treturn dir;\n}\n\n\n// POSTFX\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\nvec3 ApplyTonemap( vec3 linearCol )\n{\n\tconst float kExposure = 0.75;\n\t\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    vec3 x = linearCol * kExposure;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n}\n\nvec3 ApplyGamma( vec3 linearCol )\n{\n\tconst float kGamma = 1.2;\n\n\treturn pow( linearCol, vec3(1.0/kGamma) );\t\n}\n\nvec3 ApplyPostFX( vec2 uv, vec3 col )\n{    \n    col *= 1.3;\n\n    col *= 0.1 + 0.9 * Vignette( uv, 1.0 );\n\n    col *= vec3(1.0, 0.95, 0.8); // warmer\n  \n    col = ApplyTonemap(col);\n\tcol = ApplyGamma(col);\n    \n\treturn col;\n}\n\t\n\n\n// Scene\n\nfloat speed = 1.0;\n\nfloat BubbleOriginForward( float t )\n{\n    t = t * 30.0;\n    if ( t > 0.0)\n    {\n        t = t / (1.0+t/10.0f);\n\n    }\n    return t + iTime * speed;\n}\n\nfloat BubbleOriginInverse( float r )\n{\n    r = r- iTime * speed;\n    if( r > 0.0)\n    {\n        r = -10.0f * r / (r - 10.0f);\n    }\n    r = r / 30.0f;\n    return r;\n}\n\nfloat Scene_Distance(vec3 pos)\n{\n\n    vec3 vPos = pos;\n    vPos.x += 3.0;\n\n    float scale = 50.0;\n    \n    vPos /= scale;\n\n    // wobble\n    vec3 offset = vec3(0);\n    offset += sin( pos.yzx * 8.91 + iTime * 10.0 ) * 0.001;\n    offset += sin( pos.zxy * 7.89 + iTime * 10.0 ) * 0.001;    \n    offset *= 0.08;\n    \n    float f = BubbleOriginForward( vPos.x );\n    \n    f = floor(f);\n    \n    float minD = 1000000.0;\n    \n    for (float b=-1.0; b<=2.0; b+=1.0)\n    {\n        float p = f + b;\n        vec3 o = vPos;\n        o.x = BubbleOriginInverse( p );\n                \n        o.x -= vPos.x;\n\n         float spreadBlend = 1.0 - clamp( vPos.x * 3.0 + 0.2, 0.0, 1.0);\n         \n         float spread = spreadBlend;\n         \n         spread *= 0.05;\n\n         o.y += sin(p * 123.3456) * spread;\n         o.z += sin(p * 234.5678) * spread;\n         \n         o += offset;\n           \n         float rad = sin( p * 456.8342 ) * 0.5 + 0.5;\n                             \n         float d = length(o) - 0.005f - rad * rad * 0.02f;\n         \n         minD = min( minD, d );\n    }\n    \n     return minD * scale;\n}\n\nvec3 Scene_GetNormal( vec3 pos )\n{\n    const float delta = 0.0001;\n    \n    vec4 samples;\n    for( int i=ZERO; i<=4; i++ )\n    {\n        vec4 offset = vec4(0);\n        offset[i] = delta;\n        samples[i] = Scene_Distance( pos + offset.xyz );\n    }\n    \n    vec3 normal = samples.xyz - samples.www;    \n    return normalize( normal );\n}    \n\nfloat Scene_Trace( vec3 rayOrigin, vec3 rayDir, float minDist, float maxDist, float side )\n{\n\tfloat t = minDist;\n\n    const int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tfloat d = Scene_Distance( rayOrigin + rayDir * t ) * side;\n        if ( abs(d) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist + 1.0f;\n            break;\n        }       \n        \n        t += d;        \n\t}\n    \n    return t;\n}\n\nvec3 GetSkyColour( vec3 dir )\n{\n\tvec3 result = vec3(0.0);\n\t\n    vec3 envMap = texture(iChannel1, dir).rgb;\n    envMap = envMap * envMap;\n    float kEnvmapExposure = 0.999;\n    result = -log2(1.0 - envMap * kEnvmapExposure);\n\n    return result;\t\n}\n\nfloat FilmThickness( vec3 pos )\n{\n    return Noise(pos * 0.3f, iTime * 0.5);\n}\n\nvoid Shade( inout vec3 colour, inout vec3 remaining, vec3 pos, vec3 rayDir, vec3 normal )\n{\n    float NdotV = max( dot(normal, -rayDir), 0.0 );\n\n    float filmThickness = FilmThickness(pos);\n\n    vec3 reflection = GetSkyColour( reflect( rayDir, normal ) );\n    \n#if 1\n    // Extra highlight\n    vec3 LightColour = vec3(1,.9,.7) * 0.8;\n    vec3 L = normalize(vec3(1.0, 2.0, 0.0));\n    float NdotL = max( dot( normal, L ), 0.0 );\n    float NdotH = max( dot( normal, normalize(L-rayDir) ), 0.0 );\n    reflection += (pow(NdotH,10000.0) * 10000.0) * NdotL * LightColour;\n    //vReflection += (pow(NdotH,1000.0) * 2000.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,100.0) * 200.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,10.0) * 20.0) * NdotL * LightColour;\n#endif     \n     \n    float ni = N_Air;\n    float nt = N_Water;     \n    \n    float cosi = NdotV;\n    float cost = GetCosT( ni, nt, cosi );\n    float fresnelA = Fresnel( ni, nt, cosi, cost );\n    float fresnelB = Fresnel( nt, ni, cost, cosi );\n\n    float fresnelFactor = 1.50f - (1.0f - fresnelA) * (0.450f - fresnelB);\n    \n    vec3 fresnel = vec3(fresnelFactor);\n\n    vec3 thinFilmColour;\n#if USE_THIN_FILM_LOOKUP\n    thinFilmColour = texture(iChannel0, vec2(NdotV, filmThickness) ).rgb;\n#else\n    thinFilmColour = GetThinFilmColour(NdotV, filmThickness);\n#endif\n    fresnel *= thinFilmColour;\n    \n    colour += reflection * fresnel * remaining;\n    remaining *= (1.0f - fresnel);\n\n\n#if 0\n    float fGlassThickness = 0.5;\n    vec3 vGlassColor = vec3(1,0.95, 0.25);\n\n\tfloat fOpticalDepth = fGlassThickness / NdotV;\n    vec3 vExtinction = exp2( -fOpticalDepth * (1.0 - vGlassColor) ); \n    remaining *= vExtinction;\n#endif    \n}\n\n\nvec3 GetSceneColour( vec3 rayOrigin, vec3 rayDir )\n{    \n    float kFarClip = 20.0;\n\n\tvec3 colour = vec3(0);\n    vec3 remaining = vec3(1);\n    \n    float side = (1.0);\n    \n    float minDist = 0.0;\n    \n    for( int i=0; i<10; i++ )\n    {\n        float t = Scene_Trace( rayOrigin, rayDir, minDist, kFarClip, side );\n        \n        if ( t>=kFarClip )\n        {\n            break;\n        }\n        \n        minDist = t + 0.1f;\n        \n        vec3 hitPos = rayOrigin + rayDir * t;\n\n        vec3 normal = Scene_GetNormal( hitPos );\n\n        Shade(colour, remaining, hitPos, rayDir, normal * side );\n        \n        side = side * -1.0f;\n    }\n    \n    colour += GetSkyColour(rayDir) * remaining; \n\t\n\treturn colour * 0.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float heading = 0.3f + sin(iTime * 0.3) * 0.1;\n\n    float elevation = 1.8 + sin(iTime * 0.134) * 0.1;\n    \n    float fov = 2.5 + sin( iTime * 0.234) * 0.5;\n    \n    float cameraDist = 10.0;\n\tvec3 cameraPos = vec3(sin(heading) * sin(-elevation), cos(-elevation), cos(heading) * sin(-elevation)) * cameraDist;\n\tvec3 cameraTarget = vec3(sin(iTime * 0.1542) * 3.0, 0.0, 0.0);\n\n\tvec3 rayOrigin = cameraPos;\n\tvec3 rayDir = GetCameraRayDir( GetWindowCoord(uv), cameraPos, cameraTarget, fov );\n\t\n\tvec3 sceneCol = GetSceneColour( rayOrigin, rayDir );\n\t\n\tvec3 final = ApplyPostFX( uv, sceneCol );\n\t\n\tfragColor = vec4(final, 1.0);\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Margins 0.\n#define TS abs(sin(iTime / 3.0))\n#define TC abs(cos(iTime / 2.50))\n#define TS2 abs(sin(iTime / 2.0))\n#define TC2 abs(cos(iTime / 2.0))\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * 0.5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * 0.5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n\n\n// Use a lookup texture in Buffer A for thin film interference instead of calculating it at every intersection\n#define USE_THIN_FILM_LOOKUP 0\n\nfloat N_Air = 1.0f;\nfloat N_Water = 1.33f;\n\nfloat PI = 3.141592654;\n\n// used to prevent loop unrolling\n// This will be zero but the compiler doesn't know that as iFrame is a uniform\n#define ZERO min(iFrame,0)\n\n// https://en.wikipedia.org/wiki/Fresnel_equations\nfloat FresnelS(float ni, float nt, float cosi, float cost)\n{\n    return ((nt * cosi) - (ni * cost)) / ((nt * cosi) + (ni * cost));\n}\n\nfloat FresnelP(float ni, float nt, float cosi, float cost)\n{\n    return ((ni * cosi) - (nt * cost)) / ((ni * cosi) + (nt * cost));\n}\n\nfloat Fresnel(float ni, float nt, float cosi, float cost )\n{    \n    float Rs = FresnelS( ni, nt, cosi, cost );\n    float Rp = FresnelP( ni, nt, cosi, cost );\n\n    return (Rs * Rs + Rp * Rp) * 0.5;\n}\n\nfloat FresnelR0(float ni, float nt)\n{\n    float R0 = (ni-nt) / (ni+nt);\n    R0 *= R0;\n    return R0;\n}\n\n// https://en.wikipedia.org/wiki/Snell%27s_law\nfloat GetCosT( float ni, float nt, float cosi )\n{\n    float n = ni/nt;\n    float sinT2 = n*n*(1.0-cosi*cosi);\n    \n    // Total internal reflection\n    if (sinT2 >= 1.0)\n    {\n        return 1.0;\n    } \n\n    float cost = sqrt(1.0 - sinT2);\n    return cost;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    \n    vec3 ot = fr*fr*(3.0-2.0*fr);\n    vec3 zt = 1.0f - ot;\n    \n    \n    float result = 0.0f;\n    \n    result += hash13(fl + vec3(0,0,0)) * (zt.x * zt.y * zt.z);\n    result += hash13(fl + vec3(1,0,0)) * (ot.x * zt.y * zt.z);\n\n    result += hash13(fl + vec3(0,1,0)) * (zt.x * ot.y * zt.z);\n    result += hash13(fl + vec3(1,1,0)) * (ot.x * ot.y * zt.z);\n\n    result += hash13(fl + vec3(0,0,1)) * (zt.x * zt.y * ot.z);\n    result += hash13(fl + vec3(1,0,1)) * (ot.x * zt.y * ot.z);\n\n    result += hash13(fl + vec3(0,1,1)) * (zt.x * ot.y * ot.z);\n    result += hash13(fl + vec3(1,1,1)) * (ot.x * ot.y * ot.z);\n\n    return result;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat Noise(vec3 p, float o)\n{\n    float result = 0.0f;\n    float a = 1.0f;\n    float t= 0.0;\n    float f = 0.5;\n    float s= 2.0f;\n    \n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    result = result / t;\n    \n    return result;\n}\n\n\n\n// Spectrum to xyz approx function from http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    return xyzFit_1931( f );    \n}\n\n\n\n// from  https://github.com/amandaghassaei/SoapFlow/blob/main/python/Thin%20Film%20Interference.ipynb\nfloat ThinFilmAmplitude( float wavelength, float thickness, float cosi )\n{\n    float ni = N_Air;\n    float nt = N_Water;\n    \n    float cost = GetCosT( ni, nt, cosi );\n\n    // # The wavelength inside a medium is scaled by the index of refraction.\n    // wavelength_soap = wavelength / n_soap\n    // wavelength_air = wavelength / n_air\n    // # First calc phase shift of reflection at rear surface, based on film thickness.\n    // phaseDelta = 2 * thickness / math.cos(theta) * 2 * math.pi / wavelength_soap  \n    // # There is an additional path to compute, the segment AJ from:\n    // # https://www.glassner.com/wp-content/uploads/2014/04/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n    // phaseDelta -= 2 * thickness * math.tan(theta) * math.sin(incidentAngle) * 2 * math.pi / wavelength_air\n    // Simplified to:\n    float phaseDelta = 2.0 * thickness * nt * cost * 2.0 * PI / wavelength;\n    \n    // https://en.wikipedia.org/wiki/Reflection_phase_change\n    if (ni < nt)\n        phaseDelta -= PI;\n    if (ni > nt)\n        phaseDelta += PI;\n\n    float front_refl_amp = Fresnel(cosi, cost, ni, nt);\n    float front_trans_amp = 1.0 - front_refl_amp;\n    float rear_refl_amp = front_trans_amp * Fresnel(cost, cosi, nt, ni);\n    \n    rear_refl_amp /= front_refl_amp;\n    front_refl_amp = 1.0f;\n        \n    // http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf\n    return sqrt(front_refl_amp * front_refl_amp + rear_refl_amp * rear_refl_amp + 2.0 * front_refl_amp * rear_refl_amp * cos(phaseDelta));\n}\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;//1.0f;\n    float thicknessMax = 1500.0;//2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(0.0);\n    \n    float t = 0.0;\n    \n    vec3 white = vec3(0.0);\n    \n    for (float wavelength = 380.0; wavelength<=780.0; wavelength += 50.0)\n    {\n        float amplitude = ThinFilmAmplitude( wavelength, thickness, cosi );\n        \n        vec3 XYZ = WavelengthToXYZ( wavelength );\n    \n        white += XYZ;\n    \n        result += XYZ * amplitude;\n        t += 1.0f;\n    }\n\n    result = XYZtosRGB( result );\n      \n    result /= t;\n    //result /= white;\n    //result = vec3(1.0);\n    \n    return result;\n}\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*6.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb(hsv), 0.1), hsv.y*0.075);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m2 = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res1.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res1.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m2*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res1.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res1.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m2*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res1.xy)*2.0-vec2(1.0);\n //   fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res1.xy);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*16.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb(hsv), 0.1), hsv.y*0.075);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 skyCol = vec3(80,180,255)/ 255.0;\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 col = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 243, 243, 322], [324, 324, 347, 347, 502], [504, 504, 561, 561, 1927]], "test": "untested"}
