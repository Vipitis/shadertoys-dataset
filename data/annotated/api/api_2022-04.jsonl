{"id": "NlXfDS", "name": "noise static", "author": "aliva", "description": "jsut noise", "tags": ["static"], "likes": 2, "viewed": 200, "published": 3, "date": "1651348351", "time_retrieved": "2024-07-30T16:50:47.304144", "image_code": "const float e = 2.7182818284590452353602874713527;\n\nvec4 noise(vec2 texCoord)\n{\n    float G = e + (iTime * 0.1);\n    vec2 r = (G * sin(G * texCoord.xy));\n    return vec4(fract(r.x * r.y * (1.0 + texCoord.x)));\n}\n\n\nvoid mainImage(out vec4 o, vec2 texCoord)\n{\n    o = noise(texCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 79, 79, 211], [214, 214, 257, 257, 284]], "test": "untested"}
{"id": "7lsBzl", "name": "Shader of Life", "author": "Yetman", "description": "Yet another implementation of Conway's Game of Life.", "tags": ["2d", "conway", "gameoflife", "multipass", "automaton"], "likes": 16, "viewed": 359, "published": 3, "date": "1651344333", "time_retrieved": "2024-07-30T16:50:48.046160", "image_code": "// -------------------------------------------------------------------\n// Shader of Life: Yet Another Implementation of Conway's Game of Life\n// -------------------------------------------------------------------\n\n// Buffer A: (Inputs: iChannel0 <- Buffer A)\n//   Implements of Conway's Game of Life and handles the user input.\n//   To keep thing interesting over time, the liveness of the border cells are drived by a pseudo random function.\n//\n// Buffer B: (Inputs: iChannel0 <- Buffer A, iChannel1 <- Buffer B)\n//   Keeps track of the energy left behind in each cell.\n//   If the texel's energy is 1.0, it contains a live cell.\n//   If the cell dies, the texel's energy dissipate over time.\n//\n// Image: (Inputs: iChannel0 <- Buffer B)\n//   Maps the cell energy to a fragment color.\n\n// -------------------------------------------------------------------\n\n// User Interactions:\n//  - Hold the mouse button and drag to add live cells within brush radius.\n//  - While Holding SHIFT, Hold the mouse button and drag to kill cells within brush radius.\n//  - If you hold CTRL, the brush will be disabled. This allow for saving an image without adding/killing cells.\n//  - Press space to kill all the cells.\n\n// -------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // procedural palette generation: https://iquilezles.org/articles/palettes/\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.2, 1.3, 1.5);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n    \n    float energy = texelFetch(iChannel0, ivec2(fragCoord), 0).r;\n    vec3 color = a + b * cos(radians(360.0) * (c * energy + d));\n    fragColor.rgb = energy * color;\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated seeding method. \n\nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n// -----------------------------------------------------------------------------\n\n// The probability that a texel at the border (or inside the brush) will be live\n#define EMERGE_PROP 0.25\n\n#define RND_CELL(pos) vec4(step(gold_noise(pos, iTime + 0.1), EMERGE_PROP))\n\n#define BRUSH_RADIUS 10.0\n\n#define SHIFT_ASCII 16\n#define CTRL_ASCII 17\n#define SPACE_ASCII 32\n#define IS_PRESSED 0\n#define JUST_PRESSED 1\n\n#define KEY(ascii, event) (texelFetch(iChannel1, ivec2(ascii, event), 0).x != 0.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Press Space to bring the Apocalypse.\n    if(KEY(SPACE_ASCII, JUST_PRESSED))\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    ivec2 coord = ivec2(fragCoord);\n    ivec2 resolution = ivec2(iResolution.xy);\n    \n    if(coord.y == 0 || coord.y == resolution.y - 1 ||coord.x == 0 || coord.x == resolution.x - 1){\n        fragColor = RND_CELL(fragCoord);\n        return;\n    }\n    \n    // Only add/kill cells if CTRL is not pressed. This was added to allow saving an image with drawing cells.\n    if(!KEY(CTRL_ASCII, IS_PRESSED) && iMouse.z > 0.0 && iMouse.w < 0.0 && distance(iMouse.xy, fragCoord) <= BRUSH_RADIUS){\n        if(KEY(SHIFT_ASCII, IS_PRESSED)) // If SHIFT is pressed, kill all cells within brush radius\n        {\n            fragColor = vec4(0.0);\n            return;\n        } \n        else \n        {\n            fragColor = RND_CELL(fragCoord);\n            return;\n        }\n    }\n    \n    \n    const int NEIGHBOR_COUNT = 8;\n\n    const ivec2 NEIGHBORS[NEIGHBOR_COUNT] = ivec2[NEIGHBOR_COUNT](\n        ivec2(-1, -1), ivec2( 0, -1), ivec2( 1, -1),\n        ivec2(-1,  0),                ivec2( 1,  0),\n        ivec2(-1,  1), ivec2( 0,  1), ivec2( 1,  1)\n    );\n\n    int count = 0;\n    for(int index = 0; index < NEIGHBOR_COUNT; index++)\n    {\n        count += int(texelFetch(iChannel0, coord + NEIGHBORS[index], 0).r != 0.0);\n    }\n\n    bool result = texelFetch(iChannel0, coord, 0).r != 0.0;\n    if(result)\n    { // Alive\n        if(count < 2 || count > 3) result = false; // Death due to under- or over-population\n    } \n    else \n    { // Dead\n        if(count == 3) result = true; // Birth of a new cell\n    }\n\n    fragColor = vec4(result);\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// How fast the energy in a texel dissipates after the cell dies\n#define DISSIPATION_RATE 0.001\n\n// Inputs:\n//  iChannel 0 <- Buffer A ... The Game of Life 2D grid of live cells.\n//  iChannel 1 <- Buffer B ... The Energy left behind by the last live cell that occupied the texel.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, coord, 0) + (1.0 - DISSIPATION_RATE) * texelFetch(iChannel1, coord, 0);\n    fragColor = min(vec4(1.0), fragColor); // Clamp the energy value to avoid values > 1.0\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1277, 1277, 1334, 1414, 1749]], "test": "untested"}
{"id": "slsfRs", "name": "大龙猫 - Cave Probe Screen Explorer", "author": "totetmatt", "description": "Need a fake screen for your sci-fi ship ? There it is ! :) ", "tags": ["green"], "likes": 8, "viewed": 264, "published": 3, "date": "1651333840", "time_retrieved": "2024-07-30T16:50:48.793163", "image_code": "/*\nNothign fancy, just like the effect :) \n\n*/float box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n  }\n  vec3 erot(vec3 p,vec3 ax,float a){\n     return mix(dot(ax,p)*ax,p,cos(a))+cross(ax,p)*sin(a);\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec3 col = vec3(.0);\n  vec3 p,d=normalize(vec3(uv,1.));\n\tfloat i,e,g;\n  for(i=g=e=0.;i++<128.;){\n     p =d*g;\n     p.z -=15.;\n      p = erot(p,vec3(0.,0.,1.),p.z*.1+iTime*.25);\n    float dd,c=16./3.1415;\n    p.xz = vec2(log(dd=length(p.xz)),atan(p.z,p.x))*c;\n    p.y /=dd/=c;\n    p.xz = asin(sin(p.xz-iTime));\n     p = erot(p,vec3(0.,1.,0.),.1);\n     float sc = 1.,scp=1.01;\n      float h= 1000.; \n    for(float i=0.;i<4.;i++){\n       p*=scp;\n       sc*=scp;\n       p.xz = abs(p.xz)-.25;\n       p.xy = p.x > p.y ? p.xy:p.yx;\n       p = erot(p,normalize(vec3(.5,1.,1.)),.785);\n        h= min(box(p-.5,vec3(2.,.1,2.1))/sc,h);\n       h = min(h, (length(p.xz)-.51)/sc);\n     }\n     h = dd*.9*min(h,box(p,vec3(1.))/sc);\n     g+=e=max(.01,abs(h));\n     col +=vec3(.0,.12-abs(dot(asin(sin(p*5.)),asin(cos(p.zxy*7.))))*.03,.0)*(sin(iTime*2.+uv.y*2.*iResolution.y))/exp(.125*i*i*e);\n    \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 164], [167, 167, 201, 201, 266], [267, 267, 324, 374, 1352]], "test": "untested"}
{"id": "NllBzl", "name": "Fork crumpledWa Maadahmed 182", "author": "Maadahmed", "description": "https://twitter.com/nasana_x", "tags": ["cineshader"], "likes": 7, "viewed": 3765, "published": 3, "date": "1651317238", "time_retrieved": "2024-07-30T16:50:49.541163", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n   \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  }\n    \n   vec3 col;\n   col.r  = uv.y - 0.1;\n   col.g = uv.y + 0.3;\n   col.b = uv.y + 0.95;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 416]], "test": "untested"}
{"id": "NtsBRf", "name": "Refraction - Spi3lot", "author": "Spi3lot", "description": "Refraction!!!", "tags": ["reflection", "simulation", "refraction", "light", "code", "the", "physics", "art", "of", "photon", "bigwings"], "likes": 12, "viewed": 352, "published": 3, "date": "1651316908", "time_retrieved": "2024-07-30T16:50:50.281184", "image_code": "// Inspired by https://youtu.be/NCpaaLkmXI8\n\n\n// Better not modify these 6, will probably mess up things\n// Constants\n#define PI 3.1415926535\n#define TAU 2.0 * PI\n\n// Ray Marching\n#define EPSILON 0.001\n#define MAX_STEPS 250\n#define MAX_DIST 1000.0\n#define MAX_INTERNAL_REFLECTIONS 10\n\n\n// Modify these\n// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n#define ZOOM 1.0\n#define DISTANCE 5.0\n#define ROTATION_SPEED 0.5\n\n// My implementation of chromatic aberration (CA) is multiplicative (instead of additive)\n// which indicates that 1.0 means no aberration and values greater than 1.0 create the\n// rainbow-like effect of CA. Values in (0.0; 1.0) invert the order of the rainbow colors.\n// Negative values don't make sense I guess since the ratio of the refractive indices, eta,\n// would then also be negative\n#define CHROMATIC_ABERRATION 1.025\n#define COLOR vec3(0.0, 1.0, 1.0)\n//#define DARKER_WHEN_THICKER\n\n// These are the refractive indices\n#define AIR 1.000293\n#define GLASS 1.52\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat GetDist(vec3 p)\n{\n    float minDist = 1e20;\n    \n    //float sphere1 = sdSphere(p, 0.5);\n    float roundBox1 = sdRoundBox(p, vec3(1.0, 1.0 ,1.0), 0.333);\n    //minDist = max(roundBox1, -sphere1);\n    minDist = roundBox1;\n    \n    return minDist;\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    //return normalize(cross(dFdx(p), dFdy(p)));  // Works best for voxels\n\n    float d = GetDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    return normalize(d - vec3(GetDist(p - e.xyy),\n                              GetDist(p - e.yxy),\n                              GetDist(p - e.yyx)));\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd, float side)\n{\n    float dO = 0.0;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = side * GetDist(p);\n        dO += dS;\n        if (abs(dS) <= EPSILON || dO > MAX_DIST) break;\n    }\n    \n    return dO;\n}\n\n// Correction offset so that RayMarch does not return immediately after starting to march\n// Add it to the ray origin for reflection\n// Subtract it from the ray origin for refraction\nvec3 offset(vec3 n)\n{\n    return EPSILON * 2.0 * n;\n}\n\nbool TIR(vec3 refraction)\n{\n    //return dot(refraction, refraction) == 0.;\n    \n    // Probably faster because the entire expression will be false \n    // if it encounters one false expression\n    return refraction.x == 0. && refraction.y == 0. && refraction.z == 0.;\n}\n\nvec4 RayMarchRefraction(vec3 pOut, vec3 rd, vec3 nOut, float eta, vec4 color)\n{\n    float etaEnter = eta;  // AIR / GLASS\n    float etaExit = 1.0 / eta;  // GLASS / AIR\n\n    vec3 refrDirEnter = refract(rd, nOut, etaEnter);\n\n    // We need to march for the refraction since we need to know the point of intersection\n    pOut -= offset(nOut);\n    float dIn = RayMarch(pOut, refrDirEnter, -1.0);\n    float thickness = dIn;\n\n    // We do not need to check for anything, since we are guaranteed to hit the object\n    // again when we start to march in the interior of the object\n    vec3 pIn = pOut + refrDirEnter * dIn;\n    vec3 nIn = -GetNormal(pIn);\n    vec3 refrDirExit = refract(refrDirEnter, nIn, etaExit);\n\n    // TIR -> Total Internal Reflection\n    for (int i = 0; TIR(refrDirExit) && i < MAX_INTERNAL_REFLECTIONS; i++)\n    {\n        refrDirEnter = reflect(refrDirEnter, nIn);\n        pIn += offset(nIn);\n        dIn = RayMarch(pIn, refrDirEnter, -1.0);\n        pIn += refrDirEnter * dIn;\n        nIn = -GetNormal(pIn);\n        refrDirExit = refract(refrDirEnter, nIn, etaExit);\n        thickness += dIn;\n    }\n\n#ifndef DARKER_WHEN_THICKER\n    thickness = 1.0;\n#endif\n\n    return color * texture(iChannel0, refrDirExit) / thickness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 ro;\n\n    if (iMouse.z > 0.0) \n    {\n        float yaw = TAU * mouse.x;\n        float pitch = PI * mouse.y;\n        \n        float cy = cos(yaw);\n        float sy = sin(yaw);\n        float cp = cos(pitch);\n        float sp = sin(pitch);\n        \n        ro = DISTANCE * vec3(cy, cp, sy);\n        ro.xz *= sp;  // Adjusting X and Z position accordingly when changing the pitch\n    }\n    else\n    {\n        float x = iTime * ROTATION_SPEED;\n        float c = cos(x);\n        float s = sin(x);\n        vec3 cs0 = vec3(c, s, 0);\n        ro = DISTANCE * cs0.xyy;\n    }\n\n    vec3 lookAt = vec3(0),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         c = ro + f * ZOOM,\n         i = c + uv.x * r + uv.y * u,\n         rd = normalize(i - ro);\n         \n    vec4 col;\n    float dOut = RayMarch(ro, rd, 1.0);\n    \n    if (dOut <= MAX_DIST)\n    {\n        vec3 pOut = ro + rd * dOut;\n        //float distOut = GetDist(pOut);\n       \n        // We don't need to check for distOut <= EPSILON because the only other thing that\n        // could've possibly happened when dOut <= MAX_DIST is that we ran out of steps which\n        // is an indicator that we've very likely hit or got very close to hitting an object\n        \n        vec3 nOut = GetNormal(pOut);\n        vec3 reflDir = reflect(rd, nOut);\n        \n        // We don't need to march again for the reflection since a box/sphere\n        // cannot reflect itself - at least not from the outside\n        vec4 reflCol = texture(iChannel0, reflDir);\n        \n        float eta = AIR / GLASS;\n\n        vec4 refrColRed = RayMarchRefraction(pOut, rd, nOut, eta / CHROMATIC_ABERRATION, vec4(1,0,0,1));\n        vec4 refrColGreen = RayMarchRefraction(pOut, rd, nOut, eta, vec4(0,1,0,1));\n        vec4 refrColBlue = RayMarchRefraction(pOut, rd, nOut, eta * CHROMATIC_ABERRATION, vec4(0,0,1,1));\n        \n        //vec4 refrCol = max(max(refrColRed, refrColGreen), refrColBlue);\n        vec4 refrCol = refrColRed + refrColGreen + refrColBlue;\n        refrCol *= vec4(COLOR, 0.333);\n        \n        //col = refrCol;  // No reflection - pure refraction\n        col = mix(refrCol, reflCol, 0.333);  // Refraction and reflection blended together\n    }\n    else\n    {\n        col = texture(iChannel0, rd);\n    }\n\n    fragColor = col;\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1077, 1077, 1110, 1110, 1138], [1140, 1190, 1233, 1233, 1328], [1330, 1330, 1353, 1353, 1583], [1586, 1586, 1610, 1685, 1897], [1900, 1900, 1946, 1946, 2184], [2186, 2369, 2390, 2390, 2422], [2424, 2424, 2451, 2617, 2694], [2696, 2696, 2775, 2775, 3934], [3937, 3937, 3994, 3994, 6465]], "test": "untested"}
{"id": "stfBzs", "name": "pt. III", "author": "nabr", "description": "Wrote this quite some time ago. at the moment things don't look good that i will ever finish or polish this peace as it deserves, so i let it free.\nEnjoy!", "tags": ["sound", "reverberation", "fnd"], "likes": 29, "viewed": 661, "published": 3, "date": "1651310426", "time_retrieved": "2024-07-30T16:50:51.024198", "image_code": "\n#define Z iTime\n#define T (Z<7.8?1.:.9*Z+exp(min(1.-Z+8.,1.)))*max(1.-(Z-2.),1.)*min(2.,max(1.,Z))+(1.-Z)\n#define dmin(a,b)((a.x<b.x)?a:b)\n#define Rt(p,a)(p=cos(a)*p+sin(a)*vec2(p.y,-p.x))\n\n#define S smoothstep\n#define R iResolution.xy\n\nvoid scene0(out vec4, in vec2);\n// https://www.shadertoy.com/view/MscSDB by Shane\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvoid path(inout vec2 p, inout float z){float s = sin(z/24.) * cos(z/16.); p += vec2(s*9.,1e-5);}\n\nvoid L(in vec3 lp,in float lpd, inout float sp)\n{\n    vec2 sn = vec2(1);\n    \n    Rt(sn, 6.*T);\n    lp = vec3(lp.xy+.5*sn,  lp.z-lpd);\n    sp = length(lp)-.2;\n}\n\nvec2 f(in vec3 p) \n{\n  float dl0 = 1e8, dl1 = 1e8;\n  float zp = cos(T)*2.*p.z;\n  path(p.xy, zp );\n  vec3 lp = p;\n  L(lp,7., dl0);\n  L(vec3(-lp.xy, lp.z), 8., dl1);\n  p.z+=8.*T;\n  #define repM(_x,_y)(_y*.5-mod(_x,_y))\n  vec3 gls =p,krs = p,kln = p;\n  \n  // -------- klingen\n  kln.x = atan(p.y, p.x) * 2.86478;\n  kln.xy = repM(vec2(kln.x, p.z), vec2(3));\n  kln.z = length(vec2(p.x, p.y)) - (Z < 8.2 ? (1.4 + (sin(Z) * .5 + .5)) : 2.7);\n  kln = abs(kln) - vec3(1., .125, .4);\n  float fkln = length(max(vec3(.1001, -.1001, -.1), kln)) + min(max(kln.x, max(kln.y, kln.z)), 0.) - .125;\n  \n  // -------- kreise\n  krs.xz = repM(vec2(0, p.z + 1.5), vec2(3));\n  krs.y = length(p.xy) - 2. + (cos(T) * .2 + .2);\n  krs = abs(krs) - vec3(.25, .25, .25);\n  float fkrs = length(vec2(krs.y, krs.z)) - .125;\n  \n  // -------- gleise\n  gls.x = T + atan(p.y, p.x) * 3.81971;\n  gls.xz = repM(gls.xz, vec2(3., 1.125));\n  gls.y = length(p.xy) - 2.;\n  gls = abs(gls) - vec3(1, .125, .45);\n  float fgls = length(max(vec3(-.124, .095, .05), gls)) + min(max(gls.x, max(gls.y, gls.z)), 0.) - .125;\n\n  if(Z>15.&&Z<19.)\n  {\n  float tb = float(mod(Z, 4.)>1.);\n  fgls = max(fgls,tb);\n  fkrs = max(fkrs,tb);\n  }\n  if(Z>20.)fkln = 1000.;\n  return dmin(vec2(min(dl1,dl0),7.),dmin(vec2(min(fkrs,fgls), 3.),vec2(fkln,5.)));\n}\n\n// https://www.shadertoy.com/view/4tdfDH\nfloat ps(in vec3 p, in vec3 light_p)\n{\n    vec3 l = normalize(light_p - p);\n    float t = 0.15;\n    float t_max = distance(light_p, p);\n    float res = 1.0;\n    for (int i = 0; i < 64; ++i)\n    {\n        if (t > t_max)\n            break;\n        float d = f(p + t * l).x;\n        if (d < 0.01)\n            return 0.0;\n        t += d;\n        res = min(res, 8.0 * d / t);\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec4 col = vec4(0.), bg = col;\n    scene0(bg, fragCoord);\n    \n    vec2 RR = iResolution.xy;\n    vec2 st = (2. * fragCoord.xy - RR.xy) / min(RR.x, RR.y);\n   \n    vec3 ro = vec3(0, 0, 0)+1e-4, rd = vec3(0);\n    rd = normalize(vec3(st, 2.));\n     \n \n\t// -------- raymarch\n\tconst vec2 e = vec2(.0001,0);\n\tconst float MAX_DIST =  20.;\n\tfloat h = 0.;\n\tvec3 p = ro;\n    vec2 d = vec2(-1);\n\tfor (uint i = 0u; i < 64u ; ++i)\n\t{\n\t\td = f((ro + rd * h));\n        if(abs(d.x) <( e.x*h) && h < MAX_DIST)break;\n        h += d.x;\n\t\t\n\t} \n  \n\tif(h<MAX_DIST)\n\t{\n    p = (ro + rd * h) ;\n\tvec3 N = normalize(vec3(f(p+e.xyy).x-f(p-e.xyy).x,f(p+e.yxy).x-f(p-e.yxy).x,f(p+e.yyx).x-f(p-e.yyx).x));\n    \n    vec3 lp0 = vec3(p.xy*.5+.5, 6.);\n    vec3 lp1 = vec3(p.xy*.5+.5, 12.);\n    \n    float dmy = 1.;\n    L(lp0, dmy, dmy);\n    L(vec3(-lp1.xy, lp1.z), dmy,dmy);\n    \n    float lr0 =  8. / pow(max(0., dot(lp0 - p, lp0 - p)), 2.);\n    float lr1 = 15. / pow(max(0., dot(lp1 - p, lp1 - p)), 2.);\n\n    float dl = ps(p, lp0) * max(0.0, dot(N, normalize(lp0 - p)))  *  lr0 \n               + ps(p, lp1) * max(0.0, dot(N, normalize(lp1 - p)) ) * lr1 ;\n\n    float spc = pow(max(dot(N, -rd), 0.), 2.)+1e-5;\n    \n\n    col.xyz = vec3(0.745,0.729,0.953);\n    \n    col.xyz = mix(col.xyz*spc*h*.01, col.xyz*dl*spc, 1.0);\n    \n    if(d.y==7.)col.xyz = vec3(1);\n\t}\n  \n\tfragColor =  vec4(pow(col.xyz, vec3(.454545)), 1.);\n    \n    (Z>8.&&Z<11.05)?\n    fragColor = mix(col,bg, step(fract(2.65*T), .5)):\n    (Z>24.)?\n    fragColor = mix(col,bg, .1):fragColor;\n}\nfloat pvalnoise(in vec2 uv) \n{\n        const float k = 212.;\n        vec4 l = vec4(floor(uv), fract(uv));\n        float u = l.x + l.y * k;\n        vec4 v = vec4(u, u + 1.,u + k, u + k + 1.);\n        v = fract(fract(1.23456789 * v) * v / .987654321);\n        l.zw = l.zw * l.zw * (3. - 2. * l.zw);\n        l.x = mix(v.x, v.y, l.z);\n        l.y = mix(v.z, v.w, l.z);\n        return mix(l.x, l.y, l.w);\n}\nfloat glw = 0.;\nfloat f0(in vec3 p) \n{    \n     Rt(p.xy, T);Rt(p.yz, T);\n     float h = 0.1, w = .98, m = 12.8;\n     vec3 v = vec3(.5+atan(p.z, p.x)/6.28, p.y, acos(p.y/length(p))/3.14159);\n     for(int i = 1; i < 7; i++)\n     h += S(-1.6, 2.7, ((w *=.5)*pvalnoise((v.xy*(m*=2.)))));\n     float d = length(p)-1.5+.45*h;\n     glw = 1. / ( 1.0 + pow(abs(d*.2),.5));\n     return d;\n}\nvec3 N1(in vec3 p){\nfloat d=f0(p);\nvec2 e=vec2(.001,0);vec3 n=d-vec3(f0(p-e.xyy),f0(p-e.yxy),f0(p-e.yyx));return normalize(n);\n}\nvoid scene0( out vec4 O, in vec2 U )\n{\n   vec2 st = (U-.5*R)/max(R.y, R.x);\n   vec4 c = vec4(0);\n   #define repM(_x,_y)(_y*.5-mod(_x,_y))\n   // tile screen\n   st = repM(abs(st)-vec2(0., 0.), vec2(1., 1.));\n    \n  \n    vec3 ro = vec3(-1.25, -1.75, 10.), //\n         rd = normalize(vec3(st, -2.)),\n         lp = vec3(1., 4., 5);\n    float d = 0.;\n    for(int i=0; i<18; i++) \n    {  \n     float h = (f0((ro + rd * d)));\n     if(abs(h)<.001) h=.42;\n     c.w+=(.5+h)*.05;\n     d += h;\n    }\n    vec3 p = ro + rd * d, \n         n = N1(p),\n         ld = normalize(lp-p);\n    c.xyz = vec3(0.502,0.251,0.251) * max(0., dot(n, ld))+pow(max(dot(n, -rd), 0.), 3.)+1e-5;\n    c.xyz = mix(c.xyz, vec3(0.318,0.635,0.635)*glw, clamp(.5*c.w, 0., 1.));\n    c.xyz = pow(c.xyz, vec3(.4545));\n    O = c;\n}", "image_inputs": [], "sound_code": "\n#define _f(_x)(fract(_x))\n#define S smoothstep\n#define pi (4.*atan(1.))\n#define pih (2.*atan(1.))\n\n\nfloat flt(in float rt, in float y)\n{\n    float yy = 0.;\n    yy = (sin(.5 * rt) * .5 + .5) + 1.29 - cos(2.71 * y) / tan(1.33 + sin(y));\n    yy = mix(abs(y), cos(-2.71 * y) / (-1.39 + sin(y)), .5);\n    return yy;\n}\n\nfloat drm_cl(float t, float ml, float mx)\n{\n    float ft = _f( mx * t );\n    return sin(ml * 4084.015 * ft )  * exp( -100.* ft ) ;\n}\n\nfloat synth(in float rt, in float t, int ch)\n{\n\n    float yes = 0., yes1 = 0.;\n    float yba = 0.;\n    float yma = 0.;\n\n    // float emx = 3.;\n    float emx = 6.;\n    if (rt > 8.)\n        emx = 12.;\n    if (rt > 20.)\n        emx = 3.;\n\n    float ft1 = _f(2.0 * t), ft2 = _f(emx * t), ft3 = _f(0.5 * t);\n    float x = sin(ft1 * 0.04 + .5);\n    float ph = x * 17152.863;\n    vec4 vp = x + vec4(.81, .95, .63, 1.9);\n    float p0 = ph * vp[int(emx * t) % 4];\n    float p1 = ph * vp[int(.5 * t) % 4];\n\n    float xb = ft3 * 0.02 + .5;\n    vec4 vb = xb * vec4(1.89, 1., 2.01, 1.87);\n    float p2 = 1.11 * 17152.863 * vb[int(.5 * t) % 4];\n\n    yma = sin(p1); //soft with accents\n   \n    \n    yes = atan(sin(p0), cos(p0)); //\n    \n    if (rt > 12. && rt < 24.) //====================INTRO electro synth\n        yes = mix(atan(sin(p0), sin(.5 * p0)), atan(sin(p0), cos(p0)), (sin(2. * rt) * .5 + .5));\n\n    yba = atan(sin(p2), cos(p2));//bass\n\n    yma = flt(rt, yma);\n\n    if (rt > 24.)//apply filter for smoother sound \n        yes = flt(rt, yes) * S(0., 5., (rt - 24.));\n\n    yba = flt(rt, yba);\n    \n    \n    yma *= min(1., 41.1 * ft1) * max(0., 1. - ft1);\n    /*yma = clamp(yes, -1., 1.);\n    \n    return yma;\n    */\n    yes *= min(1., 44.1 * ft2) * max(0., 1. - ft2);\n    yes = clamp(yes, -1., 1.);\n    \n    yba *= min(1., 44.1 * ft3) * max(0., 1. - ft3);\n\n\n    //========================= SUPPORT INSTRUMENS\n    \n    float n = t * 8238.1;\n    n = _f(n * _f(t + n)); //noise\n    \n    // claves\n    float bft = mod(rt, 8.) > 2. ? 2. : 6.;\n    bool dclkbol = mod(rt, 10.) > 8.;\n    float one = 1.;\n    float clk = dclkbol ? sin(8545.42955 * t + .7 * dot(one, n)) * exp(-5. * _f(bft * t)) : 0.;\n    \n    // weird sound\n    float en = ft1; //_f(2. * t);\n    bool ebol = mod(rt, 4.) > 1.;\n    float efx = .5 * sin(t * vec3(13, 5, 17)[int(t) % 3]) + cos(13. * exp(1. - pow(1. - en, 100.)));\n    float e = ebol ? 1e-1 :efx;\n    float fxx = drm_cl(e + .5 * t, .125, 6.);\n    \n    if(mod(rt,102.)>92.)//====================OUTRO ?\n    return 0.08*drm_cl(efx + .5 * t, .5, 1.)*S(1., 0., (mod(rt, 102.) - 95.)/4.);\n    \n    // bongos\n    float ftbng = _f(6. * t);\n    float g = 0.;\n    g = mix(1.11, 1.48, smoothstep(0., 1., float(int(rt) % 3)));\n    float bng = sin(1191.2549 * g * t) * exp(-5.5 * ftbng);\n    bng *= float[](1., 0., 1., 0., 0., 1., 0., 1., 0., 1.)[int(3. * t) % 10];\n    bng *= min(1., 188.2 * ftbng) * max(0., 1. - ftbng);\n    \n    //=================INTRO\n    if(rt > 20.){\n        #define I_ S(0.,\n        #define _I rt-20.);\n\n        yba *= I_ 2., _I \n        bng *= I_ 6., _I \n        clk *= I_ 1., _I \n        yma *= I_ 5., _I \n        fxx *= I_ 12., .9 * _I\n    }\n    else {\n        fxx = 0.;clk = 0.;bng = 0.;yma = 0.;yba = 0.;\n    }\n\n    yes *= (rt < 24.) ? (1./2.) : 1.;\n\n    \n    if(mod(rt, 92.) < 50.)\n    //if (rt < 50.)\n    {\n        //return ((yes + .5 * yma + .1 * clk) + ((.4 * yba + .5 * bng) + .4 * fxx)) *\n        //       S(1., 0., (mod(rt, 92.) - 47.)/4.);//fade out\n               \n        return \n        (.3 * fxx + .3 * yes + .1 * clk  + .4 * yba + .6 * yma + .6 * bng) ;\n             //  S(1., 0., (mod(rt, 92.) - 47.)/4.));//fade out\n    }\n    else{//====================BRIDGE    \n        \n        yba = atan(sin(4. * p2), cos(2.1 * p2));\n        yba = clamp(yba, -1., 1.);\n        yba *= min(1., 44.1 * ft3) * max(0., 1. - ft3);\n        yba *= max(0., .35 * n + 1. - dot(_f(8. * t), _f(8. * t)));\n        yba = mod(t, 6.) > 2. ? .25 * (yba) : 0.;\n\n        float hht = clamp((1. - n * exp(-4. * _f(8. * t))), -1., 1.) * exp(-5. * _f(8. * t));\n        float xe = pow(max(_f(2. * t), .004), .13);\n        float kft = _f(3. * t);\n        float kck = sin(250.5 * xe) * min(1., 44.1 * kft) * max(0., 1. - kft);\n        //e = (.5 * sin(t * vec3(13, 5, 17)[int(t) % 3]) + cos(13. * exp(1. - pow(1. - en, 100.))));\n        fxx = drm_cl(efx + .5 * t, (cos(rt) * .4 + .4) + .1, 2.);\n        fxx *= (sin(rt) * .5 + .5);\n\n        yma = .5 * sin(.1 + p1) + abs(.5 * sin(p1));\n        yma *= S(0., 1., (mod(rt, 92.) - 58.) / 4.);\n        return .7*(.7 * kck + .3 * hht + yba + .3 * yma + .2 * fxx);\n    }\n\n}\n\nvec2 mainSound(in int samp, float t)\n{\n   \n    float xx = 6.;\n    float islVal2 = 2.8031;\n    float islVal3 = 3.5301;\n    \n    if(t > 3.)\n       xx = max(6. - (t - 3.), min(1.22, 6.));\n\n    if(t > 7.7)\n       islVal3 = min(4.7, islVal3 + (t - 7.3));\n\n    if(t > 15.2)\n       islVal2 = min(8.9841, islVal2 + (t - 9.));\n\n    if(t > 24.)\n    {\n       islVal2 = 5.166;\n       islVal3 = 3.1292893;\n    }\n    if(t > 32.)\n    {\n       islVal2 = min(5.707106, islVal2 + (t - 32.));\n    }\n    if(t > 40. && t < 46.)\n    {\n       islVal2 = 4.66;\n       islVal3 = 4.78;\n    }\n    if(mod(t, 92.) > 50.)\n    {\n        islVal2 = 2.8031;\n        islVal3 = 3.5301;\n\n        if(mod(t, 6.) > 4.)\n        {\n            islVal2 = 6.8;\n            islVal3 = 3.2;\n        }\n    }\n\n    vec2 y = vec2(1e-6);\n    vec4 v = vec4(0., 0., 0., 0.);\n\n    float mt = 0.;\n    (t < 16.) ? (mt = mod(t, 16.)):(mt = t);\n\n    float dlt = mt;\n\n    const vec4 dt = vec4(577, 601, 641, 661);\n    \n    /*\n    wrote this comment while back, i have no idea what i means... hahaha\n    \n    the improvement here: the same gain coefficient, it makes it easier to control\n    in this case a hole number on the smoothstep makes the reverberation stable  e.g 7.2 + 3.7\n    */\n    \n    const float g = 1. / 1200.;\n    \n    const vec4 A = vec4(0, -1, 1, 0) * g;\n\n    for(uint j = 0u; j < 4u; ++j)\n        for(uint i = 0u; i < 12u; ++i)\n        {\n            float fdn = 0.;\n            fdn += smoothstep(-islVal3, islVal2, dot(A, dt) * g);\n            dlt += fdn;\n\n            v.xw = vec2(.7) * synth(mt, dlt, 0) * exp(-xx * fdn);\n            v.yz = vec2(.2) * synth((mt + 1e-5 * (11. * sin(mt) + 15. * cos(mt))), mt, 0);\n            (i % 2u == 0u) ? (y.x += v[i % 4u]) : (y.y += v[i % 4u]);\n        }\n        \n    (y*=(1./6.));  \n    return y;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 420, 459, 459, 516], [518, 518, 567, 567, 678], [680, 680, 700, 700, 1967], [1969, 2010, 2048, 2048, 2404], [2405, 2405, 2462, 2462, 3988], [3989, 3989, 4019, 4019, 4390], [4407, 4407, 4429, 4429, 4771], [4772, 4772, 4791, 4791, 4900], [4901, 4901, 4939, 4939, 5685]], "test": "untested"}
{"id": "7tXBzs", "name": "Pixel Bow Generator", "author": "SnoopethDuckDuck", "description": "Pause + click around to change the shape and color :)\n\n(please don't use this for NFTs)", "tags": ["procedural", "generative", "pixelart", "pixelart", "procgen"], "likes": 17, "viewed": 593, "published": 3, "date": "1651307024", "time_retrieved": "2024-07-30T16:50:51.768208", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale factor to enlarge image by\n    float sf = dim.y / (iResolution.y - dim.y);\n    sf *= 0.75;\n\n    // Scale and centre image to screen\n    vec2 coord = round(sf * fragCoord) ;\n    coord -= round(sf * 0.5 * iResolution.xy - 0.5 * dim);\n\n    vec3 col = texelFetch(iChannel0, ivec2(coord), 0).rgb;\n    \n    // Quick and dirty outline\n    vec3 t = texelFetch(iChannel0, ivec2(coord + vec2(0,1)), 0).rgb;\n    vec3 b = texelFetch(iChannel0, ivec2(coord - vec2(0,1)), 0).rgb;\n    vec3 r = texelFetch(iChannel0, ivec2(coord + vec2(1,0)), 0).rgb;\n    vec3 l = texelFetch(iChannel0, ivec2(coord - vec2(1,0)), 0).rgb;\n    \n    vec3 sm = t + b + l + r;\n    if (col == vec3(0) && length(sm) > 0.)\n        col = vec3(0.01);   \n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n \n    float d = length(uv - ms);\n    float k = 1. / iResolution.y;\n    float s =  smoothstep(-k, k, -abs(d-0.025) + 0.005);\n    s = max(s, smoothstep(-k, k, -abs(0.25-abs(uv.y)) + 0.005));\n     \n    // Background + color y-bounds + mouse position\n    if (col == vec3(0.)) {\n        vec3 col2 = clamp(1. - 0.3 * uv.x * uv.x, 0.75, 0.974) * vec3(1);\n        col = mix(vec3(0.974), col2, s);\n    }\n    else\n        col = sqrt(col) + 0.08;\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n#define lineCol(x) ( .5 + .5 * thc(4., x+2. * pi / 3.*vec3(-1,0,1)) )\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat line(in vec2 f, in vec2 p, in vec2 q) { \n    // Translate space. We consider 0,0 to p-q\n    f -= p;\n    \n    vec2 pq = p - q;   \n    float a = atan(pq.x, pq.y) + pi / 2.;\n    \n    // Rotate f\n    float c = cos(a), s = sin(a);    \n    float x = c * f.x - s * f.y;\n    float y = s * f.x + c * f.y;\n\n    // Split space into 1 (above rotated y), 0 (below)\n    float e = step(y, 0.);\n    \n    // Do the same for 4 neighbouring cells (in non-rotated space)\n    float t = step(y,  c);\n    float b = step(y, -c);\n    float r = step(y,  s);\n    float l = step(y, -s);  \n     \n    // If some neighbours are different, we draw a line\n    // Otherwise, we don't (0 0 0 0, 1 1 1 1 -> 0 )  \n    float m = max(max(t,b),max(l,r)) - min(min(t,b),min(l,r));\n    // m = step(1., mod(t + b + l + r, 4.));\n    \n    // Center x at d (in rotated space). Only include cells within d of it.\n    // (only include cells between p and q)\n    float d = 0.5 * length(pq);  \n    return e * m * step(abs(x - d), d);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Change colors above + below y = 0 (unused)\n    float drk = step(0.5 * dim.y, fragCoord.y);\n    drk = 0.;\n    \n    // Center fragCoord + mirror y axis\n    fragCoord -= 0.5 * dim;\n    fragCoord.y = abs(fragCoord.y);\n    vec3 col = vec3(0);    \n    \n    // Use this to flick through patterns. Resets \"seed\" every 60 minutes (I think)\n    // (using mod so hash function doesn't mess up)\n    float fl = mod(floor(floor(iDate[3]/3600.) + iTime), 600.);\n    \n    vec2 f = fragCoord;\n    vec2 p = vec2(0);\n    \n    // Maybe change (static center pixel looks bad)\n    float a0 = 0.;\n    \n    float n = 120.;\n    for (float i = 0.; i < n; i++) {\n        // Random values for line positions\n        float h = h21(vec2(i + fl + 11., 0.131 * i - 103.));\n\n        a0 += 2. * pi * cos(0.1 * ms.x + h * pi * 2.);\n        \n        // New point (2. * (...) and q == floor(q) is interesting too)\n        vec2 q = p + 1. * vec2(cos(a0), sin(a0));\n        q = round(q);\n          \n        // Makes them chunky + weird\n        // f.y = abs(f.y - 0.2);\n        \n        // Color (todo: add noise for texture, maybe)\n        vec3 e = vec3(0.5);\n        vec3 col2 = pal(4. * i/n + 0.25 * fl - 0.25 * drk, e, e, e, \n                        mod(i - 2. * n * ms.y + 33. * fl, n) / n * vec3(0,1,2)/3.);\n        \n        //col2 = lineCol(4. * i/n + 0.1* fl);\n        col2 *= line(f, p, q);\n        \n        // Remove earliest lines in sequence\n        // col2 *= step((0.5 + 0.5 * cos(10. * ms.y)) * n, i);\n    \n        // Alternate color palette\n        //col += 0.333 * col2;\n        \n        if (col == vec3(0))\n            col = col2;\n\n        p = clamp(q, vec2(-0.5 * dim.y, 0), 0.5 * dim);\n    }\n\n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [], "common_code": "// dimensions of sprite - has to be less than screen dimensions\nconst vec2 dim = vec2(61);\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 97, 1387]], "test": "untested"}
{"id": "7lffzl", "name": "Park of Rainbow", "author": "lakartoza", "description": "It's the mario kart road park", "tags": ["rainbow"], "likes": 1, "viewed": 245, "published": 3, "date": "1651286702", "time_retrieved": "2024-07-30T16:50:52.512219", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseRel = iMouse.xy / iResolution.xy;//vec2(1280.,720.);\n    vec2 relCenter = vec2(0.5,0.5);\n    \n    \n    // Rotation Direction\n    vec3 baseValue = vec3(0,2,4);\n    vec3 initialRotationDirection = baseValue;\n\n    // Brightness\n    float distanceFromCenter = length(mouseRel.xy-relCenter);\n    float relCenterRadius = 0.1;\n    float distanceSensitivity = 20.;\n    float inTheZone = max(relCenterRadius,distanceFromCenter) - relCenterRadius;\n    float brightness = 1. - distanceSensitivity*inTheZone;\n    \n    // Circle\n    float distanceFromMouse = 5.*length(uv - mouseRel);\n    float fuzzyFactor1 = 5.;\n    float fuzzyFactor2 = 1.6;\n    float centerBright = 5.;\n    vec3 circleArea = vec3(centerBright*brightness + fuzzyFactor1*pow(distanceFromMouse,fuzzyFactor2));\n\n    // Time varying pixel color\n    vec3 timeVarying = cos(iTime+uv.xyx+initialRotationDirection);\n    \n    \n    \n    vec3 col = 0.5 + distanceFromCenter*circleArea *0.03 + 0.5*timeVarying;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lffzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1179]], "test": "untested"}
{"id": "stffRl", "name": "ａｅｓｔｈｅｔｉｃ alcove", "author": "Xibanya", "description": "sometimes you just gotta make some vaporwave", "tags": ["raymarching", "neon", "aesthetic", "vaporwave"], "likes": 25, "viewed": 499, "published": 3, "date": "1651284758", "time_retrieved": "2024-07-30T16:50:53.428768", "image_code": "float nrand(float x, float y) \n{\n    return fract(sin(dot(\n        vec2(x, y), vec2(12.9898, 78.233))) * \n        43758.5453); \n}\nvec4 Blend(vec4 top, vec4 bottom) \n{\n\tvec4 result;\n\tresult.a = top.a + bottom.a * (1.0 - top.a);\n\tresult.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * \n        (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float jitter = nrand(uv.y, iTime / 20.) * 2. - 1.;\n    uv.x += jitter * step(0.0, abs(jitter)) * 0.00175;\n    \n    vec2 texel = 1. / iResolution.xy;\n\tvec3 duv = texel.xyx * vec3(0.5, 0.5, -0.5);\n\n\tvec3 blur = texture(iChannel0, uv.xy).rgb;\n    \n    float sub = -0.1;\n    float hard = 0.3;\n\n    float modulo = floor(mod(uv.x / texel.x * 0.25, 3.0));\n    vec3 tmp = blur.rgb;\n    float is0 = step(modulo, 0.) * step(0., modulo);\n    float is1 = step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(0., sub * hard, \n        sub * hard * 2.0) * is0;\n    tmp -= vec3(sub * hard, 0., \n        sub * hard) * step(1., modulo) * step(modulo, 1.);\n    tmp -= vec3(sub * hard * 2.0, \n        sub * hard, 0.) * (1. - is0) * (1. - is1);\n    vec3 col = Blend(vec4(tmp, 0.75), vec4(blur, 1.5)).rgb;\n    \n    float scanline = \n        sin((uv.y - sin(iTime / 200.)) * iResolution.y) * 0.015;\n    col.rgb -= scanline;\n    \n    vec2 vigUV = fragCoord.xy / iResolution.xy * 2. - 1.;\n    float vignette = smoothstep(-1., .75, 1. - dot(vigUV, vigUV));\n    col *= vignette;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float _XRot = -5.;\nfloat _YRot = 18.;\nfloat _XPos = -5.;\nfloat _YPos = 1.2;\nfloat _ZPos = 5.;\nfloat _FOV = 60.;\n\nconst int MARCH_STEPS = 100;\nconst int SHADOW_MARCH_STEPS = 50;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 SHADOW_COLOR = vec3(0.2, 0.1, 0.4);\nconst vec3 SPEC_COLOR = vec3(0.3, 0.9, 0.8);\nconst vec3 PINK = vec3(0.8, 0.4, 0.9) * 0.75;\nconst vec3 CYAN = vec3(0.1, 0.8, 0.9);\n\nstruct Objects {\n    float column; float alcove; float wall;\n    float ground; float shape; float accent;\n    float tri;\n};\n\nmat3 YRotationMatrix(float degrees)\n{\n\tfloat angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat3 rotateYMatrix = mat3(\n        c, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c);\n\treturn rotateYMatrix;\n}\nmat3 ZRotationMatrix(float degrees)\n{\n\tfloat angleZ = radians(degrees);\n\tfloat c = cos(angleZ);\n\tfloat s = sin(angleZ);\n\tmat3 rotateZMatrix = mat3(\n        c, -s, 0,\n\t\ts, c, 0,\n\t\t0, 0, 1\n\t\t);\n\treturn rotateZMatrix;\n}\nmat3 XRotationMatrix(float degrees)\n{\n\tfloat angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat3 rotateXMatrix = mat3(\n        1, 0, 0,\n\t\t0, c, -s, \n\t\t0, s, c);\n\treturn rotateXMatrix;\n}\nvoid Rotate(inout vec3 o, vec3 a)\n{\n    vec3 localScaledTranslatedRotX = o * XRotationMatrix(a.x);\n    vec3 localScaledTranslatedRotXY = localScaledTranslatedRotX * YRotationMatrix(a.y);\n    o = localScaledTranslatedRotXY * ZRotationMatrix(a.z);\n}\n\n//https://www.shadertoy.com/view/XtBfzz\nfloat gridTexture( in vec2 p )\n{\n    vec2 i = step(fract(p), vec2(1.0/ 30.));\n    return (1.0-i.x)*(1.0-i.y);\n}\n//https://www.shadertoy.com/view/XlcSz2\nfloat checkersTexture( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y, 2.0 );\n}\n//https://www.shadertoy.com/view/ws3Bzf\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n)\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n//https://iquilezles.org/articles/distfunctions/\nfloat SDFBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    vec3 v = min(d, 0.);\n    return length(max(d, 0.0)) + max(max(v.x, v.y), v.z);\n}\nfloat SDFTri( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat SDFCylinder(vec3 p, float r, float height) \n{\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - height);\n}\nfloat SDFCapped( vec3 p, float r, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat SDFSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\nfloat SDFCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat SDFUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat SDFSub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat ColumnSDF(vec3 p)\n{\n    vec4 a0 = vec4(p, 1.0);\n    vec3 colOffset = vec3(4., 0., 2.);\n    vec3 colPos = a0.xyz + vec3(0.95, 1.3, 2.35);\n\tfloat column = SDFBox(colPos, vec3(.4,.106, .4));\n    a0.xyz += colOffset;\n\tvec3 pos = a0.xyz - vec3(3.03,-1.42,-.43);\n\tcolumn = SDFUnion(column, SDFBox(pos,vec3(.5,.132,.5)), 0.2);\n\tpos = a0.xyz - vec3(3.03,.257,-.43);\n    float cyl = SDFCapped(pos, .36, 1.6);\n    //float cyl = SDFCylinder(pos, .365,1.593)\n\tcolumn = min(column, cyl);\n\tpos = (mat4(\n        1.0, .0, .0, .0, \n        .0, -1.0, .0, .0, \n        .0, .0, -1.0, .0, \n        -3.03, 1.788, -.43, 1.0) * a0).xyz;\n\tcolumn = min(column, SDFBox(pos,vec3(.4,.106,.4)));\n\tpos = (mat4(\n        1.0, .0, .0, .0, \n        .0, -1.0, .0, .0, \n        .0, .0, -1.0, .0, \n        -3.03, 1.924, -.43, 1.0) * a0).xyz;\n\tcolumn = SDFUnion(column, SDFBox(pos,vec3(.5,.132,.5)), 0.15);\n    return column;\n}\nfloat Scene(vec3 p, out Objects o) \n{\n    vec3 floorPos = p - vec3(10., -1.5, 10.);\n    o.ground = SDFBox(floorPos, vec3(200., 0.01, 200.));\n\n    vec3 wallP = p + vec3(10., 0., 20.);\n    o.wall = SDFBox(wallP, vec3(200., 20., 15.));\n    vec3 alcovePos = p + vec3(8., 2., 5.);\n    o.alcove = SDFCapsule(alcovePos, 3.,  2.);\n    o.wall = SDFSub(o.alcove, o.wall, 0.25);\n\n    o.accent = SDFBox(floorPos + vec3(0., -0.04, 18.9), vec3(200., 0.05, 4.));\n    o.accent = SDFSub(o.alcove, o.accent, 0.05);\n\t\n    vec3 colPos = p + vec3(9.5, 0., 1.);\n    o.column = ColumnSDF(colPos);\n    colPos = p + vec3(4.5, 0., 1.);\n    o.column = min(o.column, ColumnSDF(colPos));\n\n    vec3 triPos = alcovePos + vec3(0., -2.5, 1.25);\n    Rotate(triPos, vec3(0., 0., iTime * 6.));\n    o.tri = SDFTri(triPos, vec2(1., 0.1));\n    \n    float sdf = min(o.tri, min(o.accent, min(o.column, min(o.ground, o.wall))));\n\treturn sdf;\n}\n// meant to be called when distance is needed but color zones are not.\nfloat Distance(vec3 p)\n{\n    Objects o;\n    return Scene(p, o);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize( e.xyy * Distance( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx * Distance( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy * Distance( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx * Distance( pos + e.xxx ) );\n}\nfloat March(vec3 pos, vec3 dir, out Objects o) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Scene(p, o);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\n// https://iquilezles.org/articles/rmshadows\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n    float mint = 0.02;\n    float tmax = 2.5;\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i< SHADOW_MARCH_STEPS; i++ )\n    {\n\t\tfloat h = Distance( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0);\n}       \nfloat GetLight(vec3 normal, vec3 p, vec3 lightPos)\n{\n    vec3 lightDir = normalize(p - lightPos);\n    float nDotL;\n    nDotL = max(0., dot((lightDir), normal));\n    float shadow = Shadow(p, lightDir);\n    shadow = smoothstep(0., 0.1, pow(shadow, 5.));\n    nDotL *= shadow;\n    return nDotL;\n}\nfloat GetLight2(vec3 normal, vec3 p, vec3 lightPos)\n{\n    vec3 lightDir = normalize(p - lightPos);\n    float nDotL;\n    nDotL = dot(normalize(lightDir), normal) * 0.5 + 0.5;\n    float shadow = smoothstep(0., 0.1, pow(Shadow(p, lightDir), 5.));\n    nDotL *= shadow;\n    return nDotL;\n}\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 Color(Objects o, vec3 pos, vec3 dir, vec3 normal, float dist)\n{\n    vec3 p = pos + dir * dist;\n    // ALBEDO\n    vec3 triColor = CYAN * 2.;\n    vec3 columnColor = vec3(1.) *  \n        (1. - biplanar(iChannel0, .5 * p, normal).r * 0.75);\n    vec3 sideWallColor = vec3(gridTexture(p.xy + vec2(0.09, 0.)));\n    vec3 alcoveColor = vec3(0.7, 0.8, 0.9) * (1. + columnColor * 0.25);\n    vec3 accentColor = vec3(1.2, 0.5, 0.9);\n    vec3 albedo = alcoveColor;\n    float tally = o.alcove;\n    albedo = o.wall < tally? max(vec3(0.9), sideWallColor) : albedo;\n    tally = min(tally, o.wall);\n    albedo = o.ground < tally? vec3(checkersTexture(p.xz)) : albedo;\n    tally = min(o.ground, tally);\n    albedo = o.column < tally? columnColor : albedo;\n    tally = min(o.column, tally);\n    albedo = o.accent < tally? accentColor : albedo;\n    tally = min(o.accent, tally);\n\n    // doing it this way to avoid issues with the overlap with the capsule\n    if (o.tri < o.ground && o.tri < o.wall && o.tri < o.accent && o.tri < o.column)\n    {\n        albedo = triColor;\n    }\n\n    if (o.wall < o.column && o.wall < o.ground && o.wall < o.alcove && o.wall < o.accent)\n    {\n        normal.xz *= sideWallColor.r;\n        p = pos + dir * max(0., (dist - (1. - sideWallColor.r)));\n    }\n\n    vec3 shadowColor = SHADOW_COLOR;\n\n    // DIFFUSE\n    vec3 light1Pos = vec3(25., 3.5, -10.);\n    float light1Term = GetLight(normal, p, light1Pos);\n    vec3 light1 = PINK * light1Term;\n    shadowColor = mix(shadowColor, PINK, light1Term);\n\n    vec3 light2Pos = vec3(-25., -3.5, 10.);\n    float light2Term = GetLight2(normal, p, light2Pos);\n    vec3 light2 = CYAN * light2Term;\n   \n    float diffuseTerm = clamp(light1Term + light2Term, 0., 1.);\n    vec3 diffuse = mix(shadowColor, light2, light2Term);\n\n    // FRESNEL\n    float fresnelTerm = 1. - max(0., dot(normal, -dir));\n    fresnelTerm = smoothstep(0.5, 0.8, fresnelTerm);\n    albedo += albedo * fresnelTerm * diffuseTerm;\n\n    // SPECULAR\n    vec3 specDir = vec3(-1.5, -0.8, -0.8);\n    float specTerm = max(0., dot(normal, normalize(dir - specDir)));\n    specTerm = o.column < o.ground? smoothstep(0.7, 1., specTerm) : 0.;\n    tally = min(o.column, o.ground);\n    specTerm = o.alcove < tally? 0. : specTerm;\n    tally = min(tally, o.alcove);\n    specTerm = o.wall < tally? specTerm * 2. : specTerm;\n    vec3 spec = SPEC_COLOR * specTerm * diffuseTerm * 0.0;\n\n    spec += (1. - smoothstep(0., 0.15, abs(o.accent + 0.03))) * accentColor * 2.;\n\n    float gloTri = o.tri - 0.01;\n    spec += (1. - smoothstep(0.1, 3., gloTri)) * triColor * 0.25;\n\n    spec += (1. - smoothstep(0., .2, abs(o.tri))) * triColor;\n    \n\n    return albedo * diffuse + spec;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rot = vec2(_XRot, _YRot);\n    //if (iMouse.xy != vec2(0)) rot += (vec2(iMouse.xy / iResolution.xy).yx * 2. - 1.);\n    \n\tvec3 dir = RayDir(_FOV, iResolution.xy, fragCoord);\n    dir *= XRotationMatrix(rot.x);\n    dir = dir * YRotationMatrix(rot.y);\n    vec3 pos = vec3(_XPos, _YPos, _ZPos);\n    Objects o;\n    float dist = March(pos, dir, o);\n    \n    if (dist > MAX_DIST - EPSILON) \n    {\n        fragColor = vec4(0.);\n\t\treturn;\n    }\n    vec3 p = pos + dist * dir;\n    vec3 normal = GetNormal(p);\n    vec3 diffuse = Color(o, pos, dir, normal, dist);\n    fragColor = vec4(diffuse, 1.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stffRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 129], [130, 130, 166, 166, 361], [362, 362, 419, 419, 1559]], "test": "untested"}
{"id": "stsfRX", "name": "compute stat moments", "author": "FabriceNeyret2", "description": "Display the average and std-dev in x (green) and y (red) of a curve.\nRed: right: on all data.  left: only on defined (i.e. non-zero) data.\n\nMouse-draw the curve (take care of releasing the mouse before quitting the window).\nSPACE to erase.  Presets: 1,2,3", "tags": ["statistics", "moments"], "likes": 9, "viewed": 324, "published": 3, "date": "1651249252", "time_retrieved": "2024-07-30T16:50:54.178763", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = vec4( U.y < T(vec2(U.x,0)).x );                    // draw curve\n    vec4 M = T(2);                                         // load all stats\n    if ( abs(M.z-U.x) < M.w ) O = mix(O,vec4(0,1,0,1),.4); // trace std-dev(x)\n    if ( abs(M.z-U.x) < .5  ) O =       vec4(0,1,0,1);     // trace average(x)\n  if (U.x>M.z) {\n    if ( abs(M.x-U.y) < M.y ) O = mix(O,vec4(1,0,0,1),.5); // trace std-dev(y)\n    if ( abs(M.x-U.y) < .5  ) O =       vec4(1,0,0,1);     // trace average(y)\n }else{\n    M = T(3);                                              // stats on defined part only\n    if ( abs(M.x-U.y) < M.y ) O = mix(O,vec4(1,0,0,1),.5); // trace std-dev(y)\n    if ( abs(M.x-U.y) < .5  ) O =       vec4(1,0,0,1);     // trace average(y)\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (U==vec2(1.5)) O.xy = iMouse.xy; // memorize last mouse position\n    \n    float t, n = 0., v = 0.;\n    if (U==vec2(2.5)||U==vec2(3.5)) {   // computes moments 1,2 in x and y\n        O = vec4(0);                    // (not normalized yet)\n        for (float x = 0.; x < R.x; x++ )\n            t = T(vec2(x,0)).x,\n            O += vec4( t, t*t, t*x, t*x*x),\n            n++,                        // counts all values\n            v += step(1e-6,t);          // counts non-zero values\n    }\n    if (U==vec2(2.5)) {                 // computes stats in x and y    \n        O /= n; O.zw /= O.x;            // order-1 and order-2 moments in x and y\n     // O.x                             // average y\n        O.y = sqrt(O.y - O.x*O.x);      // std-dev y\n     // O.z                             // average x\n        O.w = sqrt(O.w - O.z*O.z);      // std-dev x\n    }\n    if (U==vec2(3.5)) {                 // computes stats for defined values\n        O /= v;                         // order-1 and order-2 moments in y\n     // O.x                             // average y\n        O.y = sqrt(O.y - O.x*O.x);      // std-dev y\n    }\n    if (U.y>1.) return;\n   \n    O = T(U);                           // draw curve between prev-mouse and mouse\n    vec2 M = T(1).xy;\n    float a = min(M.x,iMouse.x), b = max(M.x,iMouse.x);\n    if (iMouse.z>0. && iMouse.w<0. && U.x >= a && U.x <= b )\n        O.x = keyDown(32) ? 0.                   // SPACE : erase area\n              : mix( M.y, iMouse.y,(U.x-M.x)/(iMouse.x-M.x) );\n        \n    if ( keyClick(32) &&iMouse.z<0.)  O=vec4(0); // SPACE : erase all\n    \n    if (iFrame==0 ||                    // default value and presets 1,2,3\n        keyClick(49)) U = 2.*U/R.x-1., O.x = R.y*exp(-.5*U.x*U.x*16.);\n    if (keyClick(50)) U = abs(2.*U/R.x-1.)-.5, O.x = R.y*exp(-.5*U.x*U.x*64.); \n    if (keyClick(51)) U = U/R.x, O.x = R.y*U.x*exp(-10.*U.x)/.037;      // / f(1/5)\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch(iChannel0,ivec2(U), 0)\n#define R    iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 784]], "test": "untested"}
{"id": "slsBRX", "name": "Parabola - L-inf Distance", "author": "blackle", "description": "maybe this will be useful to someone", "tags": ["sdf", "linf"], "likes": 15, "viewed": 363, "published": 3, "date": "1651243506", "time_retrieved": "2024-07-30T16:50:54.922774", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linf(vec2 p) {\n    return max(abs(p.x),abs(p.y));\n}\n\nvec3 parabola_SDF(vec2 p, float h) {\n    vec2 p2 = p - min(p.x+p.y,0.)*.5;\n    float t = (sqrt(1.-4.*h*(-abs(p2.x)-p2.y))-1.)/h/2.;\n    t*=p.x<0.?-1.:1.;\n    vec2 closest = vec2(t,t*t*h);\n    float dist = linf(p-closest) * sign(p.x*p.x*h-p.y);\n    return vec3(dist,closest);\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(0.769,0.918,0.624) : vec3(0.671,0.506,0.875);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tfloat scale = 5.;\n    uv*=scale; mouse*=scale;\n    uv.y+=1.; mouse.y+=1.;\n    float pixel_size = scale/iResolution.y;\n    \n    float t = sin(iTime)*.25+.75;\n    float h = mix(.1,20.,pow(t,8.));\n\n    vec3 mousedist = parabola_SDF(mouse, h);\n    vec3 col = shadeDistance(parabola_SDF(uv, h).x);\n    if (iMouse.z > 0.) {\n        float dst = max(abs(mouse.x-uv.x),abs(mouse.y-uv.y));\n        col *= smoothstep(-pixel_size,pixel_size, dst - abs(mousedist.x)) *.5 +.5;\n        col = mix(vec3(0.396,0.894,0.902), col, smoothstep(-pixel_size,pixel_size, distance(mousedist.yz, uv) - .05));\n    }\n    //float sn = abs(uv.y+cos(uv.x*h))-.01;\n    //float snl = 0.*smoothstep(fwidth(sn),0.,sn);\n\n    fragColor = vec4(col,1.0);// + snl;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsBRX.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 214, 214, 251], [253, 253, 289, 289, 529], [531, 531, 560, 560, 896], [898, 898, 955, 955, 1805]], "test": "ok"}
{"id": "NtlBzX", "name": "SDF reconstruction from textures", "author": "AntonioNoack", "description": "first: source sdf, which was used to generate the pixelated texture\nleft: source texture, 8 bit\nmiddle left: linear filtering\ncenter: sdf on linear filtering\nmiddle right: cubic filtering\nright: sdf on cubic filtering", "tags": ["sdf"], "likes": 16, "viewed": 962, "published": 3, "date": "1651224077", "time_retrieved": "2024-07-30T16:50:55.731611", "image_code": "\n// 0.5 is perfect for a thin line,\n// larger values are too sharp,\n// smaller values (for outlines & such) like 0.01 reduce pixel quality for low-bit textures, e.g. R8\n#define SHARPNESS 0.5\n\nfloat smax(float a, float b, float k){\n   if(k <= 0.0) return max(a,b);\n   float h = max(k-abs(a-b), 0.0)/k;\n   float m = h*h*h*0.5;\n   float s = m*k*(1.0/3.0); \n   return max(a,b)+s;\n}\nfloat smin(float a, float b, float k){\n    return -smax(-a,-b,k);\n}\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdf(vec2 p){\n    p.x -= (floor(p.x*6.0)+0.5)/6.0; // repeat shape on x-axis\n    p.y -= (clamp(floor(p.y*4.0),-1.0,0.0)+0.5)/4.0; // repeat shape on y-axis\n    float scale = 10.0;\n    // if sb wants to, he can create a nice letter here :)\n    p *= scale;\n    // sloped edge with small curvature?? doesn't show obvious problems...\n    // I get issues at 22.5° with a 1px thin curve (res=60, sdf=max(length(p)-0.5, 0.3-length(p))),\n    // but that's because of resolution; set it to 120 and everything is fine\n    // float sdf = length(p-vec2(4.0))-5.5;\n    // standard shape: a circle, which is cut off from the top\n    // float sdf = max(length(p)-0.5, p.y+sin(iTime)*.5-.2);\n    // new shape: the letter f\n    vec2 p0 = p;\n    p *= rot(-0.1);\n    p.x += 0.1;\n    if(p.y < 0.0) p = -p;\n    vec2 q1 = p-vec2(0.64,0.3);\n    vec2 q2 = p-vec2(0.64,0.3);\n    float sdf = max(length(q1)-0.8, 0.6-length(q2));\n    sdf = smin(sdf,smax(abs(p.y)-0.1,abs(p.x)-0.3,0.1),0.04);\n    sdf = smax(sdf,abs(dot(p,vec2(1.0,0.3)))-0.7,0.2);\n    // add original shape ^^\n    p0 *= 2.0;\n    p0 += vec2(-1.0,1.5);\n    sdf = min(sdf,0.5*max(length(p0)-0.5, p0.y+sin(iTime)*.5-.2));\n    sdf /= scale;\n    return sdf;\n}\n\nfloat nearestTexture(vec2 p, float res){\n    // make pixelated\n    p = round(p*res)/res;\n    float raw = clamp(sdf(p)*res*SHARPNESS+0.5, 0.0, 1.0);\n    return round(raw*255.0)/255.0;// discretize to 8 bit \n}\n\nfloat linearTexture(vec2 p, float res){\n    p *= res;\n    vec2 index = floor(p)/res;\n    vec2 delta = vec2(0.0,1.0/res);\n    vec2 frac = fract(p);\n    float c00 = nearestTexture(index + delta.xx, res);\n    float c01 = nearestTexture(index + delta.xy, res);\n    float c10 = nearestTexture(index + delta.yx, res);\n    float c11 = nearestTexture(index + delta.yy, res);\n    return mix(\n        mix(c00,c01,frac.y),\n        mix(c10,c11,frac.y),\n        frac.x\n    );\n}\n\n// bicubic interpolation from Inigo Quilez, https://www.shadertoy.com/view/XsSXDy\nconst vec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nconst vec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nconst vec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nconst vec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nconst vec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 ca=RE_A, cb=RE_B;\n// vec4 ca=CR_A, cb=CR_B;\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\nfloat spline(float x, float c0, float c1, float c2, float c3){\n    return c0 * dot(cb, powers(x + 1.0)) + \n           c1 * dot(ca, powers(x      )) +\n           c2 * dot(ca, powers(1.0 - x)) +\n           c3 * dot(cb, powers(2.0 - x));\n}\n\n#define SAM(a,b) nearestTexture((i+vec2(a,b))/res,res)\nfloat bicubicTexture(vec2 p, float res){\n    vec2 f = fract(p*res);\n    vec2 i = floor(p*res);\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n// sdf colors from Inigo Quilez (e.g. https://www.shadertoy.com/view/4llXD7)\nvec3 colorize(float sdf){\n    float d = sdf*6.0;\n    float sh = 10.0*length(vec2(dFdx(d),dFdy(d)));\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-50.0*abs(d));\n    col *= 0.8 + 0.2*cos(150.0*d);\n    return mix( col, vec3(1.0), 1.0-smoothstep(0.0,sh*0.3,abs(d)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x;\n    \n    // texture resolution over whole screen, based on y axis\n    float res = 120.0;\n    // how many slices are shown\n    int numSlices = 6;\n    // the second implementation here is animated\n    // int slice = int(float(fragCoord.x)/float(iResolution.x) + (sin(iTime*3.0/float(numSlices))*.5+.5)*float(numSlices-1));\n    int slice = (numSlices*int(fragCoord.x))/int(iResolution.x);\n    // sample our texture with nearest or with linear filtering\n    float nearestPixel = nearestTexture(uv,res);\n    float linearPixel  = linearTexture( uv,res);\n    float bicubicPixel = bicubicTexture(uv,res);\n    // display the difference between the techniques and the raw, unfiltered texture\n    vec3 col;\n    float sh, f;\n    vec3 white = vec3(1.0);\n    bool halfY = fragCoord.y*2.0 > iResolution.y;\n    switch(slice){\n        case 0:\n            // sdf itself\n            f= sdf(uv);\n            sh = length(vec2(dFdx(f),dFdy(f)));\n            col = halfY ? vec3(smoothstep(-sh,sh,f)) : colorize(f);\n            break;\n        case 1:\n            // raw texture\n            col = halfY ? vec3(nearestPixel) : white;\n            break;\n        case 2:\n            // linearly filtered texture = alpha approach\n            col = halfY ? vec3(linearPixel) : white;\n            break;\n        case 3:\n            // signed distance approach\n            f = (linearPixel-0.5)*SHARPNESS;\n            sh = length(vec2(dFdx(f),dFdy(f)));\n            col = halfY ? vec3(smoothstep(-sh, +sh, f)) : colorize((linearPixel-0.5)/res/SHARPNESS);\n            break;\n        case 4:\n            // bicubic filtered texture\n            col = halfY ? vec3(bicubicPixel) : white;\n            break;\n        case 5:\n            // bicubic filtered texture, then sdf\n            f = (bicubicPixel-0.5)*SHARPNESS;\n            sh = length(vec2(dFdx(f),dFdy(f)));\n            col = halfY ? vec3(smoothstep(-sh,+sh,f)) : colorize((bicubicPixel-0.5)/res/SHARPNESS);\n            break;\n    }\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 230, 230, 377], [378, 378, 416, 416, 445], [447, 447, 465, 465, 528], [530, 530, 548, 548, 1728], [1730, 1730, 1770, 1792, 1937], [1939, 1939, 1978, 1978, 2403], [2871, 2897, 2921, 2921, 2956], [2957, 2957, 3019, 3019, 3193], [3250, 3250, 3290, 3290, 3691], [3693, 3770, 3795, 3795, 4077], [4079, 4079, 4136, 4136, 6191]], "test": "untested"}
{"id": "ftsfRX", "name": "Landmass generator", "author": "JustBoredYo", "description": "Using the distortion of a circle with my standard => perlin noise code I made this", "tags": ["generatorperlinnoise"], "likes": 1, "viewed": 228, "published": 3, "date": "1651221405", "time_retrieved": "2024-07-30T16:50:56.491579", "image_code": "//Itterations to smooth the noise\nfloat octaves = 8.;\n//\"Size\" of the sampled noise texture | Doubles each itteration\nfloat frequency = 0.125;\n//\"Height\" of the sampled value | Halfes each itteration\nfloat amplitude = 1.;\n//Size of the uv space | 1 = noise texture is sampled once across the screen, 2 = twice, etc.\nfloat size = 1.0;\n//Final color of the pixel\nvec4 final = vec4(0.);\n//Radius of the circle in which the noise is shown\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy/iResolution.xy)*size;\n    \n    for(float i = 0.; i < octaves; i++)\n    {\n        //Sample region which increases each itteration\n        vec4 col = texture(iChannel0, (uv*frequency));\n        \n        //Just to get it to be black and white\n        col = vec4(col.x *= amplitude);\n        //You want to see it, right?\n        col.w = 1.0;\n        \n        //Added as it is normalized at the end\n        final += col;\n        \n        //Double/Half the values for the next itteration\n        frequency *= 2.;\n        amplitude *= .5;\n        \n    }\n    \n    //Normalize to not just have a white image and multiply with mask to get a smooth falloff\n    final = (normalize(final)*(octaves/2.));\n    \n    //Calculate a circle and mulriply the distance difference by the current value to get the distortion\n    float dist = sqrt((fragCoord.x - iResolution.x/2.)*final.x*(fragCoord.x - iResolution.x/2.)*final.x+(fragCoord.y - iResolution.y/2.)*final.x*(fragCoord.y - iResolution.y/2.)*final.x);\n    \n    fragColor = vec4(0.3, 0.3, 1, 1);\n    \n    //Color if inside of the Landmass\n    if(dist <= 102. + 3.*((sin(iTime)+1.)/2.))\n       fragColor = vec4(1, 1, 1, 1);\n    if(dist <= 100.)\n    {\n       if(dist >= 80.)\n           fragColor = vec4(0.95, 0.8, 0, 1);\n       else\n           fragColor = vec4(0., 0.7, 0., 1.);\n    }\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[436, 436, 493, 547, 1896]], "test": "untested"}
{"id": "7lXfzX", "name": "basic landscape 2d v2", "author": "jorge2017a2", "description": "basic landscape 2d v2", "tags": ["2d", "basic", "landscape"], "likes": 9, "viewed": 221, "published": 3, "date": "1651197173", "time_retrieved": "2024-07-30T16:50:57.323355", "image_code": "//por jorge2017a2...JFP\n//basic landscape 2d v2 ----------->>>-28-abril-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(2.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec2 rotate(vec2 v, float angle)\n{\n\treturn vec2(v.x * cos(angle) + v.y * sin(angle),\n\t\t    v.y * cos(angle) + v.x * sin(angle));\n}\n\nvec3 PisoOnda(vec2 uv,vec3 colIn, vec3 colOut )\n{   float y=uv.y + sin(uv.x*5.)*0.1;\n    vec3 col= DrawFigBorde(colIn, colOut, y);\n    return col;\n}\n\nfloat PisoOnda(vec2 uv )\n{   float y=uv.y + sin(uv.x*5.)*0.1;\n    return y;\n}\n\nvec3 PisoPlano(vec2 uv,vec3 colIn, vec3 colOut )\n{   float y= uv.y+ 1.0;\n    vec3 col= DrawFigBorde(colIn-(0.5+uv.y/8.0), colOut, y);\n    return col;\n}\n\nvec3 PisoPlanoIzq(vec2 uv,vec3 colIn, vec3 colOut )\n{   float y= uv.y+uv.x+1.0;\n    vec3 col= DrawFigBorde(colIn, colOut, y);\n    return col;\n}\n\nvec3 PisoPlanoDer(vec2 uv,vec3 colIn, vec3 colOut )\n{   float y= uv.y-uv.x+1.0;\n    vec3 col= DrawFigBorde(colIn, colOut, y);\n    return col;\n}\n\nfloat PisoPlanoIzqFl(vec2 uv )\n{   //float y= uv.y+uv.x+1.0;\n     float onda= uv.y+uv.x+sin(uv.x*10.)*0.2; \n     float y=onda;\n    return y;\n}\n\nfloat PisoPlanoDerFl(vec2 uv)\n{   //float y= uv.y-uv.x+1.0;\n    float onda= uv.y-uv.x+sin(uv.x*10.0)*0.2;\n    float y=onda;\n    return y;\n}\n\nvec3 PisoPlanoLinea(vec2 uv,vec3 colIn, vec3 colOut )\n{   float y1= uv.y+ 0.25;\n    float y2= uv.y- 0.25;\n    float dif= differenceSDF(y2,y1);\n    vec3 col= DrawFigBorde(colIn, colOut, dif);\n    return col;\n}\n\nvec3 HacerCascada(vec2 uv, vec3 colOut)\n{   float t=iTime*10.0;\n    uv.y= opRep1D(uv.y, 1.0 );\n    uv.y -= sin(uv.x*5.+t)*0.2;\n    float p1=uv.y-0.1;\n    float p2=uv.y+0.2;\n    float dif= differenceSDF(p1, p2);\n    vec3 col= DrawFigBorde(vec3(0.2,0.2,0.8), colOut, dif);\n    return col;\n}\n\nfloat HacerCascadaFlo(vec2 uv)\n{   float t=0.0;\n    uv.y= opRep1D(uv.y, 1.0 );\n    uv.y -= sin(uv.x*5.)*0.2+t;\n    float p1=uv.y-0.1;\n    float p2=uv.y+0.2;\n    float dif= differenceSDF(p1, p2);\n    return dif;\n}\n\nvec3 HacerCascadaTriangulo(vec2 uv, vec3 colOut)\n{   float t=iTime*10.0;\n    vec2 uv0=uv;\n    float dif= HacerCascadaFlo(uv+vec2(0.0+0.125*sin(t*20.0),t));\n    \n    float d1= PisoPlanoIzqFl(vec2(uv0.x, -uv0.y+5.0));\n    float d2= PisoPlanoDerFl(vec2(uv0.x, -uv0.y+5.0));\n    float d3= uv.y-10.0;\n    float uni= unionSDF(d1, d2);  //inclinados\n    float inter= differenceSDF(d3,uni);  //\n    dif= differenceSDF(dif,uni);\n    vec3 col= DrawFigBorde(vec3(1.0), colOut, inter);\n    col= DrawFigBorde(vec3(0.2,0.0,1.0), col, dif);\n    return col;\n}\n\nvec3 CascadaBloque(vec2 uv, vec3 colOut)\n{   float d1= sdBox(uv,vec2(3.0,5.0) ); //grande\n    float d2= sdBox(uv,vec2(2.5,4.5) ); //chico\n    float dif1= differenceSDF(d1, d2);\n    float t=iTime;\n    float d3=HacerCascadaFlo(uv+vec2(0.0+0.125*sin(t*20.0),t));\n    float dif2= intersectSDF(d3,d2);    \n    vec3 col= DrawFigBorde(vec3(1.0), colOut, d2);\n    col= DrawFigBorde(vec3(0.0), col, dif1);    \n    col= DrawFigBorde(vec3(0.2,0.2,0.8), col, dif2);\n    return col;\n}\n\nvec3 nubes(vec2 uv, vec3 colOut)\n{   vec3 col;\n    float d1,d2,d3;\n     d1= sdCircle(uv, 1.0 );\n     d2= sdCircle(uv-vec2(1.5,0.0), 1.5 );\n     d3= sdCircle(uv-vec2(3.0,-0.25), 1.2 );\n     float duni= unionSDF(d1, d2);\n     duni= unionSDF(duni,d3);\n     col= DrawFigBorde(vec3(1.0), colOut, duni);\n     return col;\n}\n    \nvec3 Hacermonte(vec2 uv,vec3 colIn, vec3 colOut)\n{   float x=uv.x;\n    float xx=x+2.0*cos(x*0.5);\n    float fx2=3.0*sin(xx*0.5)/xx;\n    float monte=uv.y+fx2;\n    vec3 col= DrawFigBorde(colIn, colOut, monte); //cafe\n    return col;\n}\n\nvec3 BloqueSimple(vec2 uv, vec3 colOut)\n{   float d1= sdBox(uv-vec2(0.0,2.5),vec2(2.5,0.5) ); //grande sup\n    float d2= sdBox(uv,vec2(2.0,3.0) ); //grande inf\n    float d3= PisoOnda(uv-vec2(0.0,2.5));\n    d1= differenceSDF(d1,d3);\n    vec3 col;\n    col= DrawFigBorde(vec3(0.6,1.2,0.3)*0.8-(uv.x/7.0), colOut, d2); \n    col= DrawFigBorde(vec3(0.8,0.2,0.3)*0.8-(uv.x/8.0), col, d1); \n    return col;\n}\n\n\nvec3 Hacermontev2(vec2 uv,vec3 colIn, vec3 colOut)\n{   float x=uv.x;\n    float xx=x+cos(x*0.25);\n    float fx2=3.0*sin(xx+cos(xx*1.5));\n    float monte=uv.y+fx2;\n    vec3 col= DrawFigBorde(colIn-(-0.12+uv.y/8.0), colOut, monte); //cafe\n    return col;\n}\n\n\nfloat starPattern(vec2 p)\n{\n\treturn 0.1 / (abs(cos(p.x)) + 0.01) * 0.1 / (abs(sin(p.y)) + 0.01) * abs(sin(p.x)) * abs(cos(p.y));\n}\n\nvec3 stars(vec2 p)\n{\n\tp -= 0.5;\n\n\tfloat a = starPattern(rotate(p * 26.0, 0.1)) * max(0.0, 1.3 + cos(p.x + iTime)) +\n\t\tstarPattern(rotate(p * 50.0, 0.2)) * max(0.0, 1.2 + cos(p.x * 0.4 + iTime * 2.0));\n\n\treturn vec3(a * 0.1 * (1.0 + (2.0 + sin(iTime * 30.0)) * 0.2));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float t=iTime;\n    //float t0=mod(t,15.0);\n    \n    vec3 col=vec3(0.0,0.1,0.8)+stars(uv*0.5);\n    \n    \n    \n    uv.x+=t;\n    uv.x= opRep1D(uv.x, 5.0 );\n    float esc=8.0;\n    uv*=esc;\n    \n    float trep=t*0.25;\n    vec2 uv0=uv;\n    float mu=2.5;\n    uv.y+=mu*sin(t*0.25);\n    \n    col= Hacermonte(uv-vec2(0.0,10.0),vec3(0.7,0.35,0.2), col);\n    col= Hacermonte(uv-vec2(10.0,8.0),vec3(0.7,0.35,0.2)*0.8, col);\n    col= Hacermontev2(uv-vec2(5.0,4.0),vec3(0.7,0.35,0.2)*0.6, col);\n    \n    col= HacerCascadaTriangulo(uv-vec2(0.0,3.0),col);\n    uv=uv0;\n    uv.y-=4.0+1.0*sin(t*0.125);\n    uv.x= opRep1D(uv.x+t, 20.0 );\n    col= nubes(uv-vec2(4.0,7.0),col);\n    col= nubes(uv-vec2(-8.0,5.0),col);\n    uv=uv0;\n    uv.y+=mu*sin(t*0.25);\n    \n    col= PisoOnda(uv+vec2(0.0,-0.2),vec3(0.0),col); //pasto\n    col= PisoOnda(uv,vec3(0.2,0.8,0.2),col); //pasto\n    col= PisoPlano(uv,vec3(0.1,0.46,0.2), col );\n    col= PisoPlanoLinea(uv-vec2(0.0,-0.8),vec3(0.5,0.4,0.3), col);\n            \n    col= BloqueSimple(uv-vec2(10.0,2.0),col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXfzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 361, 397, 397, 442], [448, 448, 495, 495, 522], [523, 523, 566, 566, 593], [594, 594, 642, 642, 670], [674, 674, 736, 736, 866], [868, 868, 949, 949, 1077], [1080, 1080, 1117, 1117, 1191], [1193, 1193, 1228, 1228, 1251], [1253, 1253, 1287, 1287, 1383], [1385, 1385, 1434, 1434, 1533], [1535, 1535, 1561, 1561, 1612], [1614, 1614, 1664, 1664, 1765], [1767, 1767, 1820, 1820, 1910], [1912, 1912, 1965, 1965, 2055], [2057, 2057, 2089, 2117, 2199], [2201, 2201, 2232, 2260, 2340], [2342, 2342, 2397, 2397, 2550], [2552, 2552, 2593, 2593, 2840], [2842, 2842, 2874, 2874, 3054], [3056, 3056, 3106, 3106, 3599], [3601, 3601, 3643, 3643, 4072], [4074, 4074, 4108, 4108, 4390], [4396, 4396, 4446, 4446, 4628], [4630, 4630, 4671, 4671, 5030], [5033, 5033, 5085, 5085, 5286], [5289, 5289, 5316, 5316, 5419], [5421, 5421, 5441, 5441, 5689], [5693, 5693, 5750, 5750, 6970]], "test": "untested"}
{"id": "NtfBRf", "name": "3D Color Experiment 5619", "author": "SnoopethDuckDuck", "description": "gave it a ltitle roullette spin too :)", "tags": ["e"], "likes": 15, "viewed": 323, "published": 3, "date": "1651195623", "time_retrieved": "2024-07-30T16:50:58.124214", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 3.;\n    float t = -100. * tanh(0.5 * iTime);\n    vec3 ro = r * vec3(cos(t), 0, sin(t));\n    ro.y = 1.6;\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float d = p.y;\n    \n    p.xz *= Rot(2. * p.y);\n    \n    vec3 q = vec3(0, 0.3 * thc(2., p.y * 10. + 4. * iTime), 0);\n    float d2 = length(p-q); //sdBox(p-q, vec3(0.6)) - 0.4;\n    d2 -= 0.5 - clamp(p.y, 0., 0.5);\n    d = -smin(-d, d2 - 0.5);\n    d = min(d, d2);\n    \n    return 0.5 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 3.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n       \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        col = 0.5 * n + 0.5;\n        float fres = pow(1. + dot(rd, n), 1.);\n        //if (length(p.xz) < 2.5)\n        col = mix(col, vec3(dif), fres);\n       \n    }\n    \n    \n    vec3 e = vec3(0.5);\n    float h = 2. * clamp(p.y, -1., 0.75);\n    vec3 col2 = pal(h, e, e, e, 0.25 * vec3(0,1,2)/3.);\n    \n    float lg = log(length(p.xz));\n    for (int i = 0; i < 3; i++)\n        col2 = pal(4. * length(col) + h + floor((iTime - 4. * lg))/2., e, e, e, 0.5 * col2);\n    \n    \n    col = clamp(col2, 0., 1.);\n    col *= clamp(exp(0.2-0.1 * length(p.xz)), 0., 1.);\n    //col = mix(col, col2, exp(-10. * length(p.xz)));\n    //col *= col2;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 808], [810, 810, 833, 833, 1125], [1127, 1127, 1170, 1170, 1477], [1479, 1479, 1503, 1503, 1693], [1695, 1695, 1745, 1745, 1936], [1938, 1938, 1995, 1995, 3374]], "test": "untested"}
{"id": "NtXfzX", "name": "Fractal Mess 9876543", "author": "SnoopethDuckDuck", "description": "experimenting", "tags": ["e"], "likes": 8, "viewed": 287, "published": 3, "date": "1651168311", "time_retrieved": "2024-07-30T16:50:58.911110", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    float k = 1. + 0.99 * cos(10. * length(d) * pi + iTime);\n    return a + b*thc(k, 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    float t = 0.25 * iTime;\n\n    float v = log(length(uv));//0.75 * log(1. + uv.x);\n\n    vec3 e = vec3(0.5);\n    vec3 col = pal(v, e, e, e, 0.25 * vec3(0,1,2)/3.);\n    \n    float m = 0.;\n    float n = 9.;\n    for (float i = 0.; i < n; i++) {\n        float io = 2. * pi * i / n;\n        float l = m * iTime + pi * length(col) / 12.;\n        uv *= rot(l);  \n        uv = abs(uv);\n        v = log(length(uv));\n        v += h21(floor(1.5 * pi * vec2(atan(uv.x,uv.y), 0.125 * iTime - 0.2 * log(length(uv)))));\n        col = pal(v + 0.25 * iTime + 1. * thc(10., iTime + 0.111 * io) * atan(uv.x,uv.y)/pi, e, e, e, 0.6 * col);\n       // m += 0.08;\n    }\n    col = clamp(col, 0., 1.);\n    col = mix(col, vec3(1), clamp(exp(0.5-12. * length(ouv)), 0., 1.) );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXfzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 130, 130, 205], [207, 207, 273, 273, 379], [381, 381, 438, 438, 1305]], "test": "untested"}
{"id": "7llfz2", "name": "Mighty Mriya", "author": "dr2", "description": "Antonov 225 (gone)", "tags": ["plane", "flight", "antonov"], "likes": 20, "viewed": 362, "published": 3, "date": "1651163148", "time_retrieved": "2024-07-30T16:50:59.827660", "image_code": "// \"Mighty Mriya\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2e (vec2 p);\n\nmat3 flMat;\nvec4 csWm, csWt;\nvec3 sunDir, qHit, flPos, dwf, dwr;\nfloat tCur, dstFar, angWm, drpWm, angWt, drpWt, grndScl, flSzFac, flyVel;\nint idObj, vuMode;\nbool wlDown;\nconst int idFus = 1, idCkp = 2, idEng = 3, idWngM = 4, idWngT = 5, idFin = 6,\n   idWhl = 7, idLeg = 8, idFr = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 ww;\n  float dMin, d, s, w, t, wg;\n  dMin = dstFar / flSzFac;\n  p = flMat * (p - flPos) / flSzFac;\n  q = p;\n  w = 1.;\n  s = 0.;\n  if (q.z < -1.5) {\n    s = q.z + 1.5;\n    s *= s;\n    w *= 1. - 0.025 * s;\n    s *= 0.026;\n  } else if (q.z > 3.5) {\n    s = q.z - 3.5;\n    s *= s;\n    w *= 1. - 0.05 * s;\n    s *= -0.02;\n  }\n  d = PrCapsDf (q - vec3 (0., s, 0.), w, 7.);\n  if (wlDown) d = max (d, - min (PrBoxDf (vec3 (abs (q.x) - 0.45, q.y + 1., q.z - 0.4),\n     vec3 (0.2, 0.25, 1.6)), PrBoxDf (vec3 (abs (q.x) - 0.2, q.y + 1., q.z - 4.8),\n     vec3 (0.1, 0.3, 0.2))));\n  DMINQ (idFus);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.65, 0.1, 6.);\n  d = PrCapsDf (q, 0.02, 0.3);\n  DMINQ (idFr);\n  q = p;\n  q.z -= -0.7;\n  q.xz = abs (q.xz);\n  q -= vec3 (0.2, 0.8, 4.);\n  d = PrCapsDf (q.xzy, 0.07, 0.2);\n  DMINQ (idFr);\n  q = p;\n  q.yz -= vec2 (0.4, 3.5);\n  d = PrCapsDf (q, 0.6, 1.5);\n  DMINQ (idCkp);\n  ww = vec2 (4., 1.4);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (0.7, 1.3);\n  q.xy = Rot2Cs (q.xy, csWm.xy);\n  q.xz = Rot2Cs (q.xz, csWm.zw);\n  t = ww.y * (1. - 0.3 * q.x / ww.x);\n  s = 1.1 * (q.z - 0.2) / ww.y;\n  d = SmoothMax (PrCaps2Df (q.yz, 0.15 * (t - s * s), t), abs (abs (p.x) - ww.x) - ww.x, 0.06);\n  d = SmoothMax (d, - abs (PrBox2Df (vec2 (abs (p.x) - 6.9, q.z - 0.085 * q.x + 1.2),\n     vec2 (0.85, 0.2))), 0.03);\n  DMINQ (idWngM);\n  for (float k = 0.; k < 4.; k ++) {\n    q = p;\n    q.x = abs (q.x);\n    q -= (k + 1.1) * dwr + vec3 (0., 0.65, 0.1);\n    d = PrCapsDf (q, 0.05, 0.25);\n    DMINQ (idFr);\n  }\n  for (float k = 0.; k < 3.; k ++) {\n    q = p;\n    q.x = abs (q.x);\n    q -= (k + 1.3) * dwf + vec3 (0., 0.22, 2.8);\n    d = max (PrRoundCylDf (q.yzx - vec3 (0.25, -0.1, 0.), 0.25, 0.05, 0.), 0.3 - q.y);\n    DMINQ (idFr);\n    d = min (SmoothMax (abs (PrCapsDf (q, 0.3 * (1. - 0.5 * q.z * q.z), 0.9)) - 0.02,\n       abs (q.z + 0.1) - 0.55, 0.02), PrCylDf (q, 0.28, 0.25));\n    s = q.z + 0.2;\n    d = max (min (d, PrCapsDf (q + vec3 (0., 0., 0.2), 0.25 * (1. - 2. * s * s), 0.7)),\n       - PrCylDf (vec3 (q.xy, q.z + 0.8), 0.07, 0.2));\n    DMINQ (idEng);\n  }\n  ww = vec2 (1.3, 0.85);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (0.8, -5.8);\n  q.xy = Rot2Cs (q.xy, csWt.xy);\n  q.xz = Rot2Cs (q.xz, csWt.zw);\n  d = min (ww.x - abs (abs (p.x) - ww.x), abs (PrBox2Df (vec2 (abs (p.x) - 1.7,\n     q.z - 0.07 * q.x + 0.6), vec2 (0.7, 0.25))));\n  t = ww.y * (1. - 0.25 * q.x / ww.x);\n  s = (q.z - 0.1) / ww.y;\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.03);\n  DMINQ (idWngT);\n  ww = vec2 (1.5, 0.65);\n  q = p;\n  q.x = abs (q.x);\n  q.xy = Rot2Cs (q.xy, sin (drpWt + vec2 (0.5 * pi, 0.)));\n  q -= vec3 (2.7, 0.8, -6.9);\n  t = ww.y * (1. - 0.25 * abs (q.y) / ww.x);\n  s = (q.z + 0.1 * abs (q.y) / ww.x - 0.2) / ww.y;\n  d = SmoothMax (PrCaps2Df (vec2 (q.x, q.z + 0.1 * abs (q.y) / ww.x), 0.1 * (t - s * s), t),\n     abs (q.y - 0.35 * ww.x) - 0.65 * ww.x, 0.06);\n  d = SmoothMax (d, - abs (PrBox2Df (vec2 (q.y - 0.8, q.z + 0.3), vec2 (0.5, 0.2))), 0.03);\n  DMINQ (idFin);\n  q.z -= -0.3;\n  d = PrCapsDf (q, 0.05, 0.2);\n  DMINQ (idFr);\n  if (wlDown) {\n    q = p;\n    q.yz -= vec2 (-1., 0.4);\n    t = 0.45;\n    s = abs (q.z) - 3.5 * t;\n    q.z = mod (q.z + 0.5 * t, t) - 0.5 * t;\n    q.x = abs (q.x) - 0.5;\n    d = max (PrRoundCylDf (vec3 (q.yz, abs (q.x) - 0.09), 0.16, 0.03, 0.02), s);\n    DMINQ (idWhl);\n    d = max (min (PrCylDf (q.yzx, 0.05, 0.09), PrCylDf (vec3 (q.xz, q.y - 0.2), 0.03, 0.2)), s);\n    DMINQ (idLeg);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.2, -1.06, 4.8);\n    d = PrRoundCylDf (vec3 (q.yz, abs (q.x) - 0.07), 0.1, 0.03, 0.01);\n    DMINQ (idWhl);\n    d = min (PrCylDf (q.yzx, 0.05, 0.07), PrCylDf (vec3 (q.xz, q.y - 0.2), 0.03, 0.2));\n    DMINQ (idLeg);\n  }\n  return 0.6 * flSzFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4, colY4, colB4;\n  vec2 s;\n  float t;\n  col4 = vec4 (1., 1., 0.95, 0.2);\n  colY4 = vec4 (0.8, 0.8, 0., 0.2);\n  colB4 = vec4 (0.2, 0.2, 1., 0.2);\n  if (idObj == idFus) {\n    col4 = mix (colB4, col4, smoothstep (0.07, 0.08, abs (qHit.y + 0.6)));\n    col4 = mix (colY4, col4, smoothstep (0.07, 0.08, abs (qHit.y + 0.35)));\n    if (PrCylDf (qHit - vec3 (0., 0., 0.4), 0.98, 1.7) < 0. ||\n       abs (qHit.x) < 0.4 && qHit.y < 0. && PrCylDf (qHit - vec3 (0., 0., 4.7), 0.93, 0.3) < 0.)\n       col4 *= vec4 (vec3 (0.2), 0.);\n    if (! wlDown && qHit.y < 0.) col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.012, \n       min (abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 0.45) - 0.1, qHit.z - 0.4), vec2 (0.1, 1.6))),\n       abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 0.2) - 0.05, qHit.z - 4.8), vec2 (0.05, 0.2)))));\n    col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.01, abs (PrRoundBox2Df (qHit.yz - vec2 (-0.4, 3.5),\n       vec2 (0.3, 0.15), 0.05)));\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.4 && abs (qHit.y - 0.45) < 0.07 && abs (abs (qHit.x) - 0.2) > 0.03 &&\n       abs (abs (qHit.z - 1.35) - 0.2) > 0.03) col4 = vec4 (0., 0., 0., -1.);\n  } else if (idObj == idEng) {\n    t = length (qHit.xy);\n    if (PrCapsDf (qHit, 0.3 * (1. - 0.5 * qHit.z * qHit.z), 0.85) < 0.) {\n      if (qHit.z > 0. && t < 0.14) col4 = vec4 (1., 0., 0., 0.2);\n      else col4 *= vec4 (vec3 (0.3), 0.);\n    } else {\n      if (abs (qHit.z + 0.1) > 0.5) col4 = colY4;\n      else col4 = mix (colB4, col4, smoothstep (0.02, 0.03, abs (qHit.z - 0.3)));\n    }\n  } else if (idObj == idWngM) {\n    t = qHit.z + 0.1 * abs (qHit.x);\n    col4 = mix (colB4, col4, smoothstep (0.04, 0.05, abs (t - 1.2)));\n    col4 = mix (colY4, col4, smoothstep (0.04, 0.05, abs (t - 1.)));\n    if (qHit.y < 0.) {\n      if (abs (abs (qHit.x) - 3.9) < 2.1) col4 *= 0.7 + 0.3 *\n         smoothstep (0.008, 0.012, abs (qHit.z - 0.1 * abs (qHit.x) + 1.));\n    } else {\n      s = Rot2D (qHit.xz - vec2 (3.5, -0.3), -0.1 * pi);\n      s.x = abs (abs (s.x) - 0.8) - 0.3;\n      col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.012, abs (PrBox2Df (s, vec2 (0.3, 0.15))));\n    }\n  } else if (idObj == idWngT) {\n    t = qHit.z + 0.15 * abs (qHit.x);\n    col4 = mix (colB4, col4, smoothstep (0.02, 0.03, abs (t - 0.7)));\n    col4 = mix (colY4, col4, smoothstep (0.02, 0.03, abs (t - 0.6)));\n  } else if (idObj == idFin) {\n    t = qHit.z + 0.15 * abs (qHit.y);\n    col4 = mix (colB4, col4, smoothstep (0.02, 0.03, abs (t - 0.4)));\n    col4 = mix (colY4, col4, smoothstep (0.02, 0.03, abs (t - 0.3)));\n  } else if (idObj == idWhl) {\n    col4 = mix (vec4 (0.7, 0.7, 0.75, 0.1), vec4 (0.3, 0.3, 0.3, 0.),\n       step (0.07, length (qHit.yz)));\n  } else if (idObj == idLeg) {\n     col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n  }\n  return col4;\n}\n\nfloat GrndDf (vec3 p)\n{\n  vec3 q;\n  float d, hb, hn, hf, a, r, vs;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    hb = sqrt (r) / (2. * pi);\n    vs = 40.;\n    hf = (r > 1.4) ? 2.5 * hb * mix (Fbm2e (vs * vec2 (hb, a + 1.)),\n       Fbm2e (vs * vec2 (hb, a)), a) : 0.;\n    hn = (r > 1.8) ? 0. : 0.03 * Fbm2e (8. * q.xz) * (1. - smoothstep (1.4, 1.8, r));\n    d = q.y - hn - mix (hb, hf, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r);\n    d = max (r - 20., d);\n  }\n  return grndScl * d;\n}\n\nfloat GrndDfN (vec3 p)\n{\n  return GrndDf (p) - 0.8 * Fbm2 (0.5 * p.xz);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDfN (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  rd.y = abs (rd.y);\n  q = 0.01 * (ro.xz + 0.5 * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.2, 0.8, ff);\n  fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  sd = max (dot (rd, sunDir), 0.);\n  skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) * min (0.3 * pow (sd, 64.) +\n     0.5 * pow (sd, 2048.), 1.);\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.7), skCol, 0.3 + 0.7 * fd), clCol, 0.1 + 0.9 * f * fd);\n  return col;\n}\n\nvec3 TrkPos (float t)\n{\n  vec3 r;\n  vec2 cs;\n  t *= 0.05 / (2. * pi);\n  t = mod (t, 1.);\n  cs = sin (2. * pi * t + vec2 (0.5 * pi, 0.));\n  r.xz = vec2 (1., cs.y);\n  r.xz = 40. * cs.x * r.xz / dot (r.xz, r.xz) + vec2 (1., - 5.);\n  r.y = 10. + 2. * sin (2. * pi * t);\n  return r;\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vel, acc, va, flVd, fpF, fpB;\n  vec2 cs;\n  float oRl, dt;\n  if (vuMode == 0) {\n    dt = 1.;\n    flPos = TrkPos (t);\n    fpF = TrkPos (t + dt);\n    fpB = TrkPos (t - dt);\n    vel = (fpF - fpB) / (2. * dt);\n    acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n    va = cross (acc, vel) / length (vel);\n    flVd = normalize (vel);\n    oRl = 2. * length (va) * sign (va.y);\n    oRl = smoothstep (0.01, 0.03, abs (oRl)) * oRl;\n    cs = sin (oRl + vec2 (0.5 * pi, 0.));\n    flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n       mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n  } else {\n    flPos = vec3 (0.);\n    flMat = mat3 (1., 0., 0., 0., 1., 0., 0., 0., 1.);\n  }\n}\n\nvoid FlyerParms ()\n{\n  angWm = 0.1 * pi;\n  drpWm = 0.02 * pi;\n  csWm = vec4 (sin (drpWm + vec2 (0.5 * pi, 0.)), sin (angWm + vec2 (0.5 * pi, 0.)));\n  angWt = 0.12 * pi;\n  drpWt = -0.03 * pi;\n  csWt = vec4 (sin (drpWt + vec2 (0.5 * pi, 0.)), sin (angWt + vec2 (0.5 * pi, 0.)));\n  dwr = vec3 (1.4, 0., 0.);\n  dwr.xy = Rot2Cs (dwr.xy, sin (- drpWm + vec2 (0.5 * pi, 0.)));\n  dwr.xz = Rot2Cs (dwr.xz, sin (-0.7 * angWm + vec2 (0.5 * pi, 0.)));\n  dwf = vec3 (1.5, 0., 0.);\n  dwf.xy = Rot2Cs (dwf.xy, sin (-0.9 * drpWm + vec2 (0.5 * pi, 0.)));\n  dwf.xz = Rot2Cs (dwf.xz, sin (-1.3 * angWm + vec2 (0.5 * pi, 0.)));\n  wlDown = (mod (0.05 * tCur, 2.) > 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, nDotL, sh;\n  FlyerParms ();\n  dstGrnd = (vuMode == 0) ? GrndRay (ro, rd) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = ObjCol ();\n      if (col4.a >= 0.) {\n        nDotL = max (dot (vn, sunDir), 0.);\n        if (col4.a > 0.) nDotL = pow (nDotL, 1.5);\n        sh = ObjSShadow (ro, sunDir);\n        col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n           col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      } else col = SkyCol (ro, reflect (rd, vn));\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn =  GrndNf (ro);\n      col = mix (vec3 (0.2, 0.4, 0.1), vec3 (0., 0.5, 0.), clamp (0.7 * Noisefv2 (ro.xz) - 0.3,\n         0., 1.));\n      col = mix (vec3 (0.6, 0.6, 0.7) * (0.7 + 0.3 * Noisefv2 (4. * vec2 (length (ro.xz), ro.y))),\n         col, smoothstep (0.5, 0.8, vn.y));\n      col *= 0.1 + 0.9 * max (0., max (dot (vn, sunDir), 0.));\n    }\n  } else {\n    col = (vuMode == 0) ? SkyCol (ro, rd) : vec3 (0.6, 0.6, 0.75) * (0.2 + 0.2 * (rd.y + 1.) *\n       (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, b;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  vuMode = 0;\n  if (vuMode == 0) {\n    flSzFac = 0.2;\n    flyVel = 1.5;\n    FlyerPM (tCur * flyVel);\n    ro = vec3 (1., 10., 1.);\n    vd = flPos - ro;\n    b = length (vd);\n    zmFac = 6. + 0.2 * b;\n    az = 0.5 * pi + atan (- vd.z, vd.x);\n    el = asin (vd.y / b);\n    if (mPtr.z > 0.) {\n      az += 0.4 * pi * mPtr.x;\n      el += 0.2 * pi * mPtr.y;\n    }\n    vuMat = StdVuMat (el, az);\n    grndScl = 100.;\n    dstFar = 10. * grndScl;\n    sunDir = normalize (vec3 (0., 2., -1.));\n    sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * sin (0.1 * pi * tCur));\n  } else {\n    flSzFac = 0.3;\n    FlyerPM (0.);\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x;\n      el = pi * mPtr.y;\n    } else {\n      az = 0.6 * pi + 2. * pi * mod (0.02 * tCur, 1.);\n      el = 0.15 * pi * sin (0.1 * pi * tCur);\n    }\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * vec3 (0., 0., -8.);\n    zmFac = 4.;\n    dstFar = 120.;\n    sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  }\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2e (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.96875);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llfz2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1218, 1218, 1240, 1240, 4999], [5001, 5001, 5034, 5034, 5217], [5219, 5219, 5240, 5240, 5495], [5497, 5497, 5534, 5534, 5763], [5765, 5765, 5781, 5781, 8534], [8536, 8536, 8559, 8559, 9097], [9099, 9099, 9123, 9123, 9172], [9174, 9174, 9208, 9208, 9696], [9698, 9698, 9720, 9720, 9975], [9977, 9977, 10009, 10009, 10704], [10706, 10706, 10729, 10729, 10985], [10987, 10987, 11011, 11011, 11706], [11708, 11708, 11728, 11728, 12358], [12360, 12360, 12395, 12395, 13665], [13667, 13667, 13723, 13723, 15391], [15393, 15393, 15425, 15425, 15525], [15527, 15527, 15573, 15573, 15620], [15622, 15622, 15655, 15655, 15744], [15746, 15746, 15793, 15793, 15840], [15842, 15842, 15884, 15884, 15935], [15937, 15937, 15980, 15980, 16044], [16046, 16046, 16103, 16103, 16179], [16181, 16181, 16225, 16225, 16285], [16287, 16287, 16332, 16332, 16424], [16426, 16426, 16471, 16471, 16509], [16511, 16511, 16547, 16547, 16753], [16755, 16755, 16785, 16785, 16898], [16900, 16900, 16931, 16931, 16995], [17029, 17029, 17053, 17053, 17165], [17167, 17167, 17192, 17192, 17378], [17380, 17380, 17401, 17401, 17555], [17557, 17557, 17579, 17579, 17735]], "test": "untested"}
{"id": "slsBR2", "name": "Diagonal Checkers [63 Chars]", "author": "cmzw", "description": "diagonal checkers", "tags": ["2d", "checkerboard", "pattern", "golf"], "likes": 6, "viewed": 352, "published": 3, "date": "1651156752", "time_retrieved": "2024-07-30T16:51:00.566684", "image_code": "// golfed version by @Xor\nvoid mainImage( out vec4 O, vec2 I )\n{\n    I = cos(I/5.); O = vec4(I.x > I.y);\n}\n\n// Original [71 chars]\n// void mainImage( out vec4 O, in vec2 I )\n// {\n//     vec2 p = cos(I/5.); O = vec4(p.x > p.y);\n// }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 64, 64, 106]], "test": "untested"}
{"id": "Nlsfz2", "name": "Mya_waveform_Test", "author": "mya_cat", "description": "waveform", "tags": ["waveform"], "likes": 1, "viewed": 238, "published": 3, "date": "1651149603", "time_retrieved": "2024-07-30T16:51:01.327649", "image_code": "vec3 line(vec2 pos,vec2 point1,vec2 point2,float width,vec3 color ,float antialias)\n{\n    \n    float k = (point1.y - point2.y)/(point1.x - point2.x);\n    float b = point1.y - k * point1.x;\n    \n    float d = abs(k * pos.x - pos.y + b) / sqrt(k * k + 1.0);\n    float t = smoothstep(width/2.0-antialias, width/2.0 + antialias, d);\n    return vec3(color*(1.0 - t));\n\n}\n\nfloat random(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nvec2 stepPoint(float x,float cycle , float scale)\n{\n    float step =x- mod(x,cycle); \n    return vec2(step, random(step) * scale*0.5 + 0.3);\n}\n\nvec3 shakeLine(vec2 uv,float cycle,float width,vec3 color ,float antialias , float scale)\n{\n    vec2 p1 =stepPoint(uv.x,cycle , scale);\n    vec2 p2 =stepPoint(uv.x+cycle,cycle , scale);\n    return line(uv,p1,p2,width,color,antialias);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float scale = 1.0- abs( uv.x- 0.5); \n    uv.x =fract(uv.x + iTime*0.2); \n\n \n    vec3 l1= shakeLine(uv,0.01 ,0.002,vec3(1,0,0),0.001 , scale);\n    vec3 l2= shakeLine(uv,0.05 ,0.002,vec3(0,1,0),0.001 , scale);\n    vec3 l3= shakeLine(uv,0.001,0.002,vec3(0,0,1),0.001 , scale);\n    \n    vec3 l4 = line(uv ,vec2(0,0.4),vec2(1,0.4),0.002, vec3(1,1,1),0.00);\n    vec3 col = l1 + l2 +l3 +l4;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlsfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 85, 365], [367, 367, 391, 391, 439], [441, 441, 492, 492, 583], [585, 585, 676, 676, 821], [823, 823, 880, 930, 1415]], "test": "untested"}
{"id": "fllBRj", "name": "change blindness: look for it:-)", "author": "FabriceNeyret2", "description": "mouse controls camera\ninspiration: https://twitter.com/social_brains/status/1518786027288104960", "tags": ["raymarching", "short", "reproduction"], "likes": 15, "viewed": 439, "published": 3, "date": "1651132583", "time_retrieved": "2024-07-30T16:51:02.081633", "image_code": "#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))            // rotation 2D\n#define r(a)          cos(a+vec2(0,11))                       // unit vector in dir a\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., a, A, d,i, PI2 = 6.28,\n         da = PI2/7., T = mod(iTime,PI2+da), B = T-PI2;       // animation cycle : danse & shift\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),             // ray direction\n          p = 7./R, q,                                        // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(0);      // mouse control of camera\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(.5-6.*M.y),                               // camera rotations\n        q.xz *= rot(2.-6.*M.x);\n        for (a = 0.; a < 7.; a++ )                            // --- draw 7 spheres\n            A = da*a - da*smoothstep(0.,da,B),                // direction of each sphere\n            d = length( q - vec3( 1.5*r( A )                  // spread & shift\n                                 - .2*r( A + PI2*sin(B<0.?T:0.)) ,0).xzy  // danse\n                      ) - .3,\n            d < t ? t=d, i=a : t;                             // keep closest sphere\n        p += .2*t*D;                                          // step forward = dist to closest obj          \n   }                                                          // --- color scheme\n   O *=  O * ( 1. + cos( da*(i - T/(PI2+da) )  + vec4(0,23,21,0)  ) ) / .8; // hue(i+slow shift)\n}", "image_inputs": [{"id": 28853, "src": "https://soundcloud.com/nathanevans-music/wellerman-sea-shanty", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 200, 200, 1551]], "test": "untested"}
{"id": "NtlfRj", "name": "texelFetch 1", "author": "dilip019", "description": "simple use of texelFetch", "tags": ["texture", "multisample", "texelfetch"], "likes": 0, "viewed": 351, "published": 3, "date": "1651132132", "time_retrieved": "2024-07-30T16:51:02.866535", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord/iResolution.xy; \n    \n    \n    ivec2 vpCoords = ivec2(512,512);\n // ivec2 vpCoords = ivec2(int(iChannelResolution[0]), int(iChannelResolution[1]));\n \n     \n\tvpCoords.x =vpCoords.x * int( uv.x); \n\tvpCoords.y =vpCoords.y * int( uv.y); \n    \n    vec4 text = texture(iChannel0,uv);\n    \n    int load = 0;//  sample\n    vec4 text1 =  texelFetch(iChannel0, ivec2(fragCoord) ,load); \n      \n   \n    fragColor = text1; \n }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 497]], "test": "untested"}
{"id": "slXBz2", "name": "Random gradient test", "author": "lspgn", "description": "Random gradient experiment", "tags": ["gradient"], "likes": 2, "viewed": 195, "published": 3, "date": "1651121141", "time_retrieved": "2024-07-30T16:51:03.651436", "image_code": "float fct(float x)\n{\n  return -sqrt(1.0-pow(x-1.0,2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\n    float shift = cos(iTime*5.0)*0.2;\n    // Time varying pixel color\n    float v1 = (fct(uv.x*2.0+shift)+1.0)*0.5+(fct(uv.y*2.0+shift)+1.0)*0.5;\n    float v2 = (fct(-uv.x*0.3+shift)+1.0)*0.5+(fct(uv.y*0.5+shift)+1.0)*0.5;\n    float v3 = (fct(uv.x*0.3+shift)+1.0)*0.5+(fct(-uv.y*0.5+shift)+1.0)*0.5;\n    float v4 = (fct(-uv.x*2.0+shift)+1.0)*0.5+(fct(-uv.y*2.0+shift)+1.0)*0.5;\n    float v = max(max(v1, v2), max(v3, v4));\n    vec3 m = vec3(v);\n\n    // Output to screen\n    fragColor = vec4(m,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 58], [60, 60, 117, 167, 718]], "test": "untested"}
{"id": "NlfBRj", "name": "Repeated Path Automata", "author": "SnoopethDuckDuck", "description": "Press r to reset\n\nIt's not visually interesting but kind of mathy", "tags": ["feedback", "cellularautomata"], "likes": 5, "viewed": 251, "published": 3, "date": "1651105845", "time_retrieved": "2024-07-30T16:51:04.409409", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zm = 0.5;\n    vec3 col = texelFetch( iChannel0, ivec2(vec2(-145, 80) + mix(fragCoord, 0.5 * iResolution.xy, zm)), 0 ).rgb;\n   \n    col.rgb = col.ggg - col.b;\n    fragColor.rgb = vec3(col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "///\n\n// This is an old idea of mine, and I've never implemented it very well\n\n// Idea:\n// You have 1 particle which follows a fixed route/sequence\n// e.g. up x3, right x5, down x6, left x4\n// Once it's gone up/right/down/left, it will start again\n// If it hits inactive white cells, it will travel through them, pause the sequence\n// and start the sequence again once it's left those cells\n\n// Some sequences have very short \"cycles\" - they'll twirl in a very obvious pattern\n// into the distance\n// Other sequences have very long cycles, and you can only see a pattern after 100s\n// or 1000s of frames.\n\n// I'm not sure if there are sequences which don't repeat\n\n///\n\n#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec3 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n   // return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n   return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n// Change me\n#define mx 9.\n#define val vec4(2,2,2,6)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        vec2 f = 0.01 * fragCoord + 0.01 * iTime; \n        float h = h21(f);\n        float h2 = h21(f.yx + 1.);\n\n        fragColor.r = 0.;//floor(4. * h2); // 0 1 2 3\n        fragColor.g = 0.;\n        vec2 i = 0.5 * iResolution.xy;\n        vec2 f2 = fragCoord;\n        if (f2.x > i.x && f2.x <= i.x + 1. && f2.y > i.y && f2.y <= i.y + 1.) { \n       // if (h > 0.999) {      \n            fragColor.b = mx;\n        }\n        return;\n    }\n    \n    // center cell\n    vec3 e = Cell(px); \n\n    // neighbour cells\n    vec3 t = Cell(px + ivec2(0,-1));\n    vec3 b = Cell(px + ivec2(0,1));\n    vec3 l = Cell(px + ivec2(-1,0));\n    vec3 r = Cell(px + ivec2(1,0));   \n\n    vec3 k = t + b + l + r;\n    //float k = max( max(l.x, r.x), max(t.x, b.x) );\n \n    // red: direction\n    // green: on/off\n    // blue: is cell active / how many gens before it turns\n    \n    // if cell is active, become inactive\n    if (e.b >= 1.) {\n        e = vec3(e.r, 1, 0);\n        //return;\n    }\n    \n    // (please dont judge me, im too lazy to untab everything)\n    if (true) {//k.b <= 2.) {\n        if (e.g == 1. || k.g > 1.) {\n            if (t.b >= 1. && t.r == 0.)\n                e = t;\n            else if (r.b >= 1. && r.r == 1.) \n                e = r;\n            else if (b.b >= 1. && b.r == 2.) \n                e = b;\n            else if (l.b >= 1. && l.r == 3.)\n                e = l;    \n        } else {\n            if (t.b >= 1. && t.r == 0.) {\n                if (t.b == val.x)\n                    e = vec3(1, 1, mx); \n                else\n                    e = vec3(0, 1, t.b - 1.);       \n            }\n            else if (r.b >= 1. && r.r == 1.) {\n                if (r.b == val.y)\n                    e = vec3(2, 1, mx);\n                else\n                    e = vec3(1, 1, r.b - 1.);\n            }\n            else if (b.b >= 1. && b.r == 2.) {\n                if (b.b == val.z)\n                    e = vec3(3, 1, mx);\n                else\n                    e = vec3(2, 1, b.b - 1.);\n            }\n            else if (l.b >= 1. && l.r == 3.) {\n                if (l.b == val.w)\n                    e = vec3(0, 1, mx);\n                else\n                    e = vec3(3, 1, l.b - 1.);\n            }    \n        }\n    }    \n    //e = clamp(e, 0., 1.);\n\tfragColor = vec4(e, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.1415926535\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 258]], "test": "untested"}
{"id": "NlXBzS", "name": "XY Oscilloscope Music - Cube", "author": "shyshokayu", "description": "This is just one really fast point of light moving around.\nE to toggle waveform\nQ to toggle point cache texture (blue is free memory, if there is no free left then you might see artifacting in the oscilloscope, overrides waveform view)", "tags": ["oscilloscope", "framework", "music", "xy"], "likes": 43, "viewed": 1411, "published": 3, "date": "1651101966", "time_retrieved": "2024-07-30T16:51:05.355879", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n/*\n    ---| Go to Common tab to play with sound |---\n*/\n\n#define VISUAL_LINE_COLOR vec3(0.45, 1.0, 0.4)\n#define VISUAL_LINE_BLUR 2.0\n#define VISUAL_LINE_BRIGHTNESS 1000.0\n\nfloat sliderPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 ab = b - a;\n    return dot(p - a, ab) / dot(ab, ab);\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in float d) {\n    return mix(a, b, saturate(d));\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    return closestPointLine(a, b, sliderPointLine(a, b, p));\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p, in float k) {\n    vec2 d = p - closestPointLine(a, b, k);\n    return dot(d, d);\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 d = p - closestPointLine(a, b, p);\n    return dot(d, d);\n}\n\nfloat distToLine(in vec2 a, in vec2 b, in vec2 p) {\n    return sqrt(distToLineSqr(a, b, p));\n}\n\nvec2 pointTex(in float t) {\n    // Estimate location based on texture coordinate\n    t *= float(VISUAL_ITERATIONS);\n    \n    // Convert to int for texelFetch and for more reliable arithmetic\n    int i = int(t);\n    int j = i + 1;\n    \n    // Interpolation between two sampled points\n    ivec2 ip1 = ivec2(i % int(iChannelResolution[0].x), i / int(iChannelResolution[0].x));\n    ivec2 ip2 = ivec2(j % int(iChannelResolution[0].x), j / int(iChannelResolution[0].x));\n    vec2 p1 = texelFetch(iChannel0, ip1, 0).xy;\n    vec2 p2 = texelFetch(iChannel0, ip2, 0).xy;\n    \n    vec2 p = mix(p1, p2, fract(t));\n\n    return p;\n}\n\nvec2 pointTexi(in int i) {\n    int r = int(iChannelResolution[0].x);\n    return texelFetch(iChannel0, ivec2(i % r, i / r), 0).xy;\n}\n\nfloat imageVectorScopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    float d = 0.01 + distanceSqr(a - b); // Emit less light if line is longer\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return min((0.00000004 / ((ld + (VISUAL_LINE_BLUR * 0.00001)) * d)), 0.2) * VISUAL_LINE_BRIGHTNESS;\n}\n\nfloat imageVectorScopeLines(in vec2 uv) {\n    float v = 0.0; // Total value\n    float lv = 0.0; // Last value\n    float cv = 0.0; // Current value\n    \n    vec2 cp;\n    vec2 lp = pointTexi(0);\n    \n    float fv = 1.0 / float(VISUAL_ITERATIONS);\n    float k;\n    \n    for(int i = 1; i < VISUAL_ITERATIONS; i++) {\n        cp = pointTexi(i); // Get the point\n        k = float(i) * fv;\n        cv = imageVectorScopeLine(lp, cp, uv) * (1.0 - k); // Set current value and multiply by time\n        v += max(lv, cv); // Eliminate circles between the lines\n        lv = cv; // Set last value to current value\n        lp = cp; // Set last point to current point\n    }\n    \n    return v * fv;\n}\n\nvec3 imageVectorScope(in vec2 uv) {\n    vec3 col = vec3(0.0);\n\n    // Lines\n    float v = imageVectorScopeLines(uv);\n    vec3 emitCol = pow(v * 0.5, 0.5) * VISUAL_LINE_COLOR;\n\n    // Grid\n    vec3 surfaceCol = vec3(1.0);\n    float gridV =  0.25 * (max(max(step(fract(uv.x * 4.0), 0.01), step(1.0 - 0.01, fract(uv.x * 4.0))), max(step(fract(uv.y * 4.0), 0.01), step(1.0 - 0.01, fract(uv.y * 4.0)))));\n    surfaceCol = mix(surfaceCol, vec3(2.0), gridV);\n\n    // Ambient light                                                           Inner display tube light absorption?\n    vec3 lightCol = vec3(0.045) * max(0.0, dot(uv + 0.5, vec2(0.12, 0.15) * 4.0)) * linearstep(-0.5, 3.0, length(uv));\n\n    // Color compositing\n    col = surfaceCol * lightCol;\n    col += emitCol * (1.0 - gridV);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n\n    return col;\n}\n\nfloat imageOscilloscopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    const float ta = 0.0;\n    const float tb = 0.004;\n    const float dta = ta * ta;\n    const float dtb = tb * tb;\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return linearstep(dtb, dta, ld);\n}\n\nvec3 oscilloscopePoint(float x) {\n    return vec3(x, pointTex(1.0 - ((x * 0.5) + 0.5)));\n}\n\nvec3 imageOscilloscope(in vec2 uv) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    \n    float scale = 2.0;\n    un *= scale;\n    \n    const float segments = 250.0;\n    const float thickness = 1.0 / segments;\n    const float gridThickness = 0.001;\n    const float gridInterval = 2.0;\n    float ip = round(uv.x * segments);\n    float unit = 1.0 / segments;\n\n    vec3 p0 = oscilloscopePoint((ip - 2.0) * unit),\n         p1 = oscilloscopePoint((ip - 1.0) * unit),\n         p2 = oscilloscopePoint((ip) * unit),\n         p3 = oscilloscopePoint((ip + 1.0) * unit),\n         p4 = oscilloscopePoint((ip + 2.0) * unit);\n\n    float dist1 = min(min(distToLine(p0.xy, p1.xy, uv), distToLine(p1.xy, p2.xy, uv)),\n                      min(distToLine(p2.xy, p3.xy, uv), distToLine(p3.xy, p4.xy, uv))) - thickness;\n    \n    float dist2 = min(min(distToLine(p0.xz, p1.xz, uv), distToLine(p1.xz, p2.xz, uv)),\n                      min(distToLine(p2.xz, p3.xz, uv), distToLine(p3.xz, p4.xz, uv))) - thickness;\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(0.8, 0.2, 0.2) * smoothstep(un, -un, dist1);\n    col += vec3(0.2, 0.2, 0.8) * smoothstep(un, -un, dist2);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    vec2 uv = (u - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    uv *= 2.0;\n    \n    vec3 col = mix(\n        mix(\n            imageVectorScope(uv),\n            imageOscilloscope(uv),\n            texelFetch(iChannel3, ivec2(69, 2), 0).x // nice\n        ),\n        ((texture(iChannel0, (u / iResolution.xy)).xyz * 0.5) + 0.5), // Show cached points visually\n        texelFetch(iChannel3, ivec2(81, 2), 0).x\n    );\n\n    col = pow(col, vec3(1.0 / 1.3));\n\n    // Full depth dithering, a way to make your images less bandy in low color ranges.\n    // Since we're using floats here, we can use that as an opportunity to dither that to the common color format, 32bit rgba.\n    float depth = 256.0;\n    vec3 cd = col * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    vec3 ditheredCol = (step(texture(iChannel2, u * 0.125).x + 0.00001, df) + di) / depth;\n    \n    o = vec4(ditheredCol, 1.0);\n\n    // Just uncomment this line and see how much of a difference this dithering makes in the dark areas.\n    //o = vec4(col, 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n#define VISUAL_ITERATIONS 600 // Number of iterations to draw the whole line for the current frame\n#define VISUAL_DURATION 0.02 // How long the line should last for a frame\n\n// Mathematical functions\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\n#define map(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(map(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define distanceSqr(v) dot(v, v)\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\n#define rote(r) rot(r * PI)\n\nmat3 rotX(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c  , -s ,\n        0.0, s  , c\n    );\n}\n\nmat3 rotY(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , 0.0, -s ,\n        0.0, 1.0, 0.0,\n        s  , 0.0, c\n    );\n}\n\nmat3 rotZ(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , -s , 0.0,\n        s  , c  , 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 roteX(float r) {\n    return rotX(r * PI);\n}\n\nmat3 roteY(float r) {\n    return rotY(r * PI);\n}\n\nmat3 roteZ(float r) {\n    return rotZ(r * PI);\n}\n\nmat4 matrixTransform(float x, float y, float z) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        x  , y  , z  , 1.0\n    );\n}\n\nmat4 matrixTransform(vec3 p) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        p.x, p.y, p.z, 1.0\n    );\n}\n\nmat4 matrixScale(float x, float y, float z) {\n    return mat4(\n        x  , 0.0, 0.0, 0.0,\n        0.0, y  , 0.0, 0.0,\n        0.0, 0.0, z  , 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixScale(vec3 p) {\n    return mat4(\n        p.x, 0.0, 0.0, 0.0,\n        0.0, p.y, 0.0, 0.0,\n        0.0, 0.0, p.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nfloat easeIn(float x) {\n    return x * x;\n}\n\nfloat easeOut(float x) {\n    return 1.0 - easeIn(1.0 - x);\n}\n\nfloat easeInOut(float x) {\n    return mix(easeIn(x), easeOut(x), x);\n}\n\nfloat easeIn(float a, float b, float x) {\n    return easeIn(linearstep(a, b, x));\n}\n\nfloat easeOut(float a, float b, float x) {\n    return easeOut(linearstep(a, b, x));\n}\n\nfloat easeInOut(float a, float b, float x) {\n    return easeInOut(linearstep(a, b, x));\n}\n\nfloat randomnoise11(float p) {\n    return fract(sin(p * 12.9898) * 43758.5453123);\n}\n\nvec2 randomnoise12(float p) {\n    float x = randomnoise11(p);\n    return vec2(x, randomnoise11(p + x));\n}\n\n// Musical functions\n#define pitch(x) (pow(1.059460646483, x) * 440.0)\n\n#define sine(x) sin((x) * PI)\n#define cosine(x) cos((x) * PI)\n#define square(x) ((fract((x) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define cosquare(x) ((fract(((x) + 0.5) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define saw(x) ((fract((x) * 0.5) * 2.0) - 1.0)\n#define cosaw(x) ((fract(((x) + 0.5) * 0.5) * 2.0) - 1.0)\n#define cotriangle(x) (-(abs(fract((x) * 0.5) - 0.5) * 4.0) + 1.0)\n#define triangle(x) cotriangle((x) + 0.5)\n\n// Some musical functions made specifically for this preview\n// Probably stupidly impractical but whatever...\nvec3 box(float t) {\n    const vec3[] points = vec3[](\n        vec3(-1.0, -1.0, -1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(-1.0, 1.0, 1.0),\n        vec3(-1.0, 1.0, 1.0),\n        vec3(-1.0, 1.0, -1.0),\n        vec3(-1.0, 1.0, -1.0),\n        vec3(-1.0, -1.0, -1.0),\n        \n        vec3(1.0, -1.0, -1.0),\n        vec3(1.0, -1.0, 1.0),\n        vec3(1.0, -1.0, 1.0),\n        vec3(1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, -1.0),\n        vec3(1.0, 1.0, -1.0),\n        vec3(1.0, -1.0, -1.0),\n        \n        vec3(-1.0, -1.0, -1.0),\n        vec3(1.0, -1.0, -1.0),\n        vec3(1.0, -1.0, 1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(-1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, -1.0),\n        vec3(-1.0, 1.0, -1.0)\n    );\n    \n    int i = (int(t) * 2) % (points.length());\n    return mix(points[i], points[i + 1], fract(t));\n}\n\nvec3 tetrisT(float t) {\n    const vec3[] points = vec3[](\n        vec3(1.5, -1.0, -0.5),\n        vec3(-1.5, -1.0, -0.5),\n        vec3(-1.5, -1.0, -0.5),\n        vec3(-1.5, 0.0, -0.5),\n        vec3(-1.5, 0.0, -0.5),\n        vec3(-0.5, 0.0, -0.5),\n        vec3(-0.5, 0.0, -0.5),\n        vec3(-0.5, 1.0, -0.5),\n        vec3(-0.5, 1.0, -0.5),\n        vec3(0.5, 1.0, -0.5),\n        vec3(0.5, 1.0, -0.5),\n        vec3(0.5, 0.0, -0.5),\n        vec3(0.5, 0.0, -0.5),\n        vec3(1.5, 0.0, -0.5),\n        vec3(1.5, 0.0, -0.5),\n        vec3(1.5, -1.0, -0.5),\n        \n        vec3(1.5, -1.0, 0.5),\n        vec3(-1.5, -1.0, 0.5),\n        vec3(-1.5, -1.0, 0.5),\n        vec3(-1.5, 0.0, 0.5),\n        vec3(-1.5, 0.0, 0.5),\n        vec3(-0.5, 0.0, 0.5),\n        vec3(-0.5, 0.0, 0.5),\n        vec3(-0.5, 1.0, 0.5),\n        vec3(-0.5, 1.0, 0.5),\n        vec3(0.5, 1.0, 0.5),\n        vec3(0.5, 1.0, 0.5),\n        vec3(0.5, 0.0, 0.5),\n        vec3(0.5, 0.0, 0.5),\n        vec3(1.5, 0.0, 0.5),\n        vec3(1.5, 0.0, 0.5),\n        vec3(1.5, -1.0, 0.5),\n        \n        \n        vec3(1.5, -1.0, -0.5),\n        vec3(1.5, -1.0, 0.5),\n        vec3(-1.5, -1.0, 0.5),\n        vec3(-1.5, -1.0, -0.5),\n        vec3(-1.5, 0.0, -0.5),\n        vec3(-1.5, 0.0, 0.5),\n        vec3(-0.5, 0.0, 0.5),\n        vec3(-0.5, 0.0, -0.5),\n        vec3(-0.5, 1.0, -0.5),\n        vec3(-0.5, 1.0, 0.5),\n        vec3(0.5, 1.0, 0.5),\n        vec3(0.5, 1.0, -0.5),\n        vec3(0.5, 0.0, -0.5),\n        vec3(0.5, 0.0, 0.5),\n        vec3(1.5, 0.0, 0.5),\n        vec3(1.5, 0.0, -0.5)\n    );\n    \n    int i = (int(t) * 2) % (points.length());\n    return mix(points[i], points[i + 1], fract(t));\n}\n\nvec3 hihats(float t) {\n    vec3 p = vec3(0.0);\n\n    p.xy = ((randomnoise12(t) * 2.0) - 1.0) * 0.5 * fract(-t + 0.25);\n    \n    p.xy *= step(fract(t * 2.0), 0.125) * step(fract(t * 0.5), 0.85);\n    \n    return p;\n}\n\nvec3 kick(float t) {\n    float tf = (t * 300.0) - (20.0 * (fract(-t * 0.5) * easeOut(0.0, 0.1, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p *= 3.0 * fract(-t * 3.0);\n    p *= smoothstep(0.0625, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 kicks(float t) {\n    vec3 p;\n    \n    float t2 = fract(t * 0.125) * 8.0;\n    \n    p += kick(t2);\n    p += kick(t2 - 2.5);\n    \n    p += kick(t2 - 4.0);\n    p += kick(t2 - 6.5);\n    \n    return p;\n}\n\nvec3 snare(float t) {\n    float tf = (t * 400.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy += ((randomnoise12(t) * 2.0) - 1.0) * 2.0 * fract(t * 3.0);\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.0625 * 4.0, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snares(float t) {\n    vec3 p;\n    \n    float t2 = fract((t * 0.25) + 0.25) * 4.0;\n    \n    p += snare(t2);\n    p += snare(t2 - 2.0);\n    \n    return p;\n}\n\nvec3 drums(float t) {\n    vec3 p;\n    \n    p += kicks(t);\n    p += snares(t);\n    \n    return p;\n}\n\nfloat freqArpeggiator1(float t) {\n    t = fract(t * 0.25) * 4.0;\n    float s = ((triangle(floor(fract(t * 1.5) * 4.0) * 0.25) * 0.5) + 0.5) * 4.0;\n    s += ((triangle(floor(t) * 0.5) * 0.5) + 0.5) * 10.0;\n    s += 1.0;\n    \n    return pitch(s);\n}\n\n// Fade in at t = (0.0 .. 0.0 + delta) then fade out at t = (1.0 .. 1.0 - delta)\nfloat declick(float t, float delta) {\n    return linearstep(0.0, delta, t) * linearstep(1.0, 1.0 - delta, t);\n}\n\n// This is your sandbox:\nvec2 point(float t) {\n    vec3 p = vec3(0.0);\n    \n    t = fract(t / 32.0) * 32.0; // Loop\n    \n    float freq = freqArpeggiator1(t) * 3.0;\n    float tf = t * freq;\n    \n    p += box(tf);\n    // What the hell\n    p = mix(p, vec3(\n        (easeInOut(easeInOut(easeInOut(easeInOut(easeInOut((p.x * 0.5) + 0.5))))) * 2.0) - 1.0,\n        (easeInOut(easeInOut(easeInOut(easeInOut(easeInOut((p.y * 0.5) + 0.5))))) * 2.0) - 1.0,\n        (easeInOut(easeInOut(easeInOut(easeInOut(easeInOut((p.z * 0.5) + 0.5))))) * 2.0) - 1.0\n    ), step(8.0, t) * ((sine(t * 6.0) * 0.5) + 0.5));\n    \n    float k = floor(fract(t * 6.0) * 2.0) + 1.0;\n    p = mix(p, round(p * k) / k, fract(-t * 0.5) * step(4.0, fract(t * 0.125) * 8.0));\n    \n    p *= 0.6;\n    \n    // Fade in every second\n    p *= easeOut(-0.25, 0.5, fract(t));\n    //p *= easeOut(-0.75, 1.0, fract(-t));\n    \n    // Distort the cube so it looks like a hypercube\n    p *= mix(1.0, mix(0.5, 1.0, (sine(-tf * 0.1) * 0.5) + 0.5), step(16.0, t) * ((saw(-t) * 0.5) + 0.5));\n    \n    p = inverse(roteX(t * 0.25) * roteY(t * 0.25)) * p;\n    \n    p -= vec3(0.0, 0.0, -1.5);\n    \n    p.xy /= p.z;\n    \n    p += step(8.0, t) * hihats(t);\n    p += step(16.0, t) * drums(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p *= easeOut(0.0, 0.5, t);\n    p *= easeOut(32.0, 31.5, t);\n    \n    return clamp(p.xy, vec2(-1.0), vec2(1.0));\n}\n", "buffer_a_code": "// Samples coordinates every frame instead of sampling every iteration for every pixel for every frame\nvoid mainImage(out vec4 o, in vec2 u) {\n    // Estimate time based on pixel and calculate point\n    u.y -= 0.5; // For some reason this fixes the error where t > VISUAL_ITERATIONS is wrong\n    float t = u.x + (u.y * iResolution.x);\n    \n    // Skip samples if outside used region\n    if(t > float(VISUAL_ITERATIONS)) { // Not perfect but saves a bit of performance (not sure because of SIMD)\n        o = vec4(0.0, 0.0, 0.5, 1.0);\n        return;\n    }\n    \n    t /= float(VISUAL_ITERATIONS);\n    t *= VISUAL_DURATION;\n    \n    // Output point result\n    o.xy = point((iTime - t) + iTimeDelta);\n    o.zw = vec2(0.0, 1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "vec2 mainSound(int s, float t) {\n    vec2 v = point(t);\n\n    // Some background noise (optional)\n    v += (((texture(iChannel0, vec2(t * 1.4236, t * 1.2267)).xy * 2.0) - 1.0) * 0.0625 * 0.25);\n\n    return v * 0.25; // User convenience, we don't want to destroy any ears\n}\n", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXBzS.jpg", "access": "api", "license": "mit", "functions": [[1446, 1446, 1502, 1502, 1566], [1568, 1568, 1625, 1625, 1662], [1664, 1664, 1720, 1720, 1783], [1785, 1785, 1851, 1851, 1919], [1921, 1921, 1975, 1975, 2043], [2045, 2045, 2096, 2096, 2139], [2141, 2141, 2168, 2221, 2759], [2761, 2761, 2787, 2787, 2892], [2894, 2894, 2955, 2955, 3243], [3245, 3245, 3286, 3286, 3929], [3931, 3931, 3966, 3966, 4826], [4828, 4828, 4890, 4890, 5149], [5151, 5151, 5184, 5184, 5241], [5243, 5243, 5279, 5279, 6520], [6522, 6522, 6561, 6561, 7607]], "test": "untested"}
{"id": "stfBRj", "name": "Cylinder Slicing", "author": "shyshokayu", "description": "Not very interesting, since it's almost identical to the previous one, but the next one will be more interesting...", "tags": ["loop", "gif", "seamless", "satisfying", "original"], "likes": 32, "viewed": 375, "published": 3, "date": "1651099566", "time_retrieved": "2024-07-30T16:51:06.108865", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define RAY_MAX_ITERATIONS 100\n#define RAY_MAX_DISTANCE 100.0\n#define RAY_SURF_DISTANCE 0.0001\n\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\nfloat sine(float t) { return sin(t * PI); }\nfloat cose(float t) { return cos(t * PI); }\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nmat2 rote(float r) {\n    return rot(r * PI);\n}\n\nmat3 rotX(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c  , -s ,\n        0.0, s  , c\n    );\n}\n\nmat3 rotY(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , 0.0, -s ,\n        0.0, 1.0, 0.0,\n        s  , 0.0, c\n    );\n}\n\nmat3 rotZ(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , -s , 0.0,\n        s  , c  , 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 roteX(float r) {\n    return rotX(r * PI);\n}\n\nmat3 roteY(float r) {\n    return rotY(r * PI);\n}\n\nmat3 roteZ(float r) {\n    return rotZ(r * PI);\n}\n\n#define range(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(range(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define distanceSqr(v) dot(v, v)\n\nfloat easeIn(float x) {\n    return x * x;\n}\n\nfloat easeOut(float x) {\n    return 1.0 - easeIn(1.0 - x);\n}\n\nfloat easeInOut(float x) {\n    return mix(easeIn(x), easeOut(x), x);\n}\n\nfloat easeIn(float a, float b, float x) {\n    return easeIn(linearstep(a, b, x));\n}\n\nfloat easeOut(float a, float b, float x) {\n    return easeOut(linearstep(a, b, x));\n}\n\nfloat easeInOut(float a, float b, float x) {\n    return easeInOut(linearstep(a, b, x));\n}\n\nfloat noise1random(float p) {\n    return fract(cos(p * 12.9898) * 43758.5453123);\n}\n\nfloat noise1random(vec2 p) {\n    return noise1random(p.x + noise1random(p.y));\n}\n\nfloat sdPlane(vec3 p, float y) {\n    return p.y - y;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, float t, float r) {\n  return length(vec2(length(p.xz) - t, p.y)) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nstruct mapresult {\n    float d;\n    int m;\n};\n\nmapresult map(vec3 p, float time) {\n    float d = RAY_MAX_DISTANCE;\n    int m = 0;\n    \n    float sd;\n    \n    // Time loop control\n    float tx = time * 0.5;\n    float ti = floor(tx);\n    float tf = tx - ti;\n    \n    float slicedFactor = step(tf, 1.0 - 0.25); // 1.0 if slicing is complete, 0.0 otherwise.\n    float slicingFactor = step(tf, 1.0 - 0.6); // 1.0 if slicing is in process, 0.0 otherwise.\n\n    // Cylinder\n    {\n        vec3 p2 = vec3(p.x, p.y, abs(p.z));\n    \n        vec3 o = vec3(0.0);\n\n        o.x = -1.0;\n        o.x += 1.0 * easeOut(0.0, 0.5, tf);\n        o.x += 1.0 * easeOut(0.75, 1.0, tf);\n\n        o.y = 0.0;\n        o.y += -8.0 * easeIn(0.75, 1.0, tf);\n        \n        o.z = 2.0;\n\n        vec3 po = p2 - o;\n\n        po.xy *= rote(0.5 + ((tf - 0.75) * (1.0 - slicedFactor)));\n        sd = sdCappedCylinder(po - vec3(0.0, 0.5, 0.0), 0.5, 1.0);\n        if(sd < d) {\n            d = sd;\n            m = 2;\n        }\n        \n        // Keep the sliced detail\n        sd = -sdBox(po, vec3(4.0, 0.0625, 4.0));\n        sd = mix(sd, 0.0, slicedFactor);\n        if(sd >= d) {\n            d = sd;\n            m = 2;\n        }\n        \n        sd = sdCappedCylinder(p2.yxz - vec3(0.0, -8.0, 2.0), 8.0, 1.0);\n        if(sd < d) {\n            d = sd;\n            m = 2;\n        }\n    }\n    \n    // Slicer\n    {\n        vec3 originp = p;\n        originp -= vec3(0.0, 0.0, 0.0);\n        originp.yz *= rote(tf - 0.125 + 0.05);\n    \n        // Cut out cylinders\n        sd = -sdBox(originp - vec3(0.0625, 3.0, 4.0), vec3(0.0625, 3.0, 4.0));\n        sd = max(sd, -sdBox(originp - vec3(0.0625, -3.0, -4.0), vec3(0.0625, 3.0, 4.0)));\n        sd = mix(sd, 0.0, slicingFactor);\n        sd = mix(0.0, sd, slicedFactor);\n        if(sd >= d) {\n            d = sd;\n            m = 2;\n        }\n        \n        sd = sdCappedCylinder(originp - vec3(0.0625, 0.0, 0.0), 4.0, 0.0625);\n        sd = min(sd, sdCappedCylinder(originp.yxz - vec3(0.0, -16.0 + 0.125 + 0.0625, 0.0), 16.0, 0.09375));\n        if(sd < d) {\n            d = sd;\n            m = 3;\n        }\n    }\n    \n    // Path\n    {\n        sd = sdBox(p - vec3(-8.0, -10.125, 0.0), vec3(8.0, 10.0, 16.0) - 0.0625);\n        sd -= 0.0625;\n        sd = max(sd, -sdCappedCylinder(p.yxz - vec3(0.0, -8.0, 2.0), 9.0, 1.0));\n        sd = max(sd, -sdCappedCylinder(p.yxz - vec3(0.0, -8.0, -2.0), 9.0, 1.0));\n        if(sd < d) {\n            d = sd;\n            m = 1;\n        }\n    }\n    \n    return mapresult(d, m);\n}\n\nmapresult march(vec3 ro, vec3 rd, float time) {\n    float d = 0.0;\n    int m = 0;\n    for(int i = 0; i < RAY_MAX_ITERATIONS; i++) {\n        mapresult mr = map(ro + (rd * d), time);\n        float sd = mr.d;\n        d += sd;\n        m = mr.m;\n        if(d > RAY_MAX_DISTANCE) return mapresult(RAY_MAX_DISTANCE, 0);\n        if(abs(sd) < RAY_SURF_DISTANCE) break;\n    }\n    return mapresult(d, m);\n}\n\nvec3 normal(vec3 p, float time) {\n    vec2 e = vec2(RAY_SURF_DISTANCE * 2.0, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy, time).d - map(p - e.xyy, time).d,\n        map(p + e.yxy, time).d - map(p - e.yxy, time).d,\n        map(p + e.yyx, time).d - map(p - e.yyx, time).d\n    ));\n}\n\nfloat shadow(vec3 origin, vec3 dir, float time) {\n    return step(RAY_MAX_DISTANCE, march(origin, dir, time).d);\n}\n\nfloat directionalLightShaded(vec3 origin, vec3 direction, vec3 normal, float time) {\n    return max(0.0, dot(normal, direction)) * shadow(origin + ((normal * RAY_SURF_DISTANCE) * 2.0), direction, time);\n}\n\nvec3 sky(vec3 rd, vec3 sunDir) {\n    float sun = dot(rd, sunDir);\n    float sunk = (sun * 0.5) + 0.5;\n    float suna = pow(sunk, 4.0);\n    float sunb = pow(suna, 32.0);\n\n    vec3 skyColorOut = mix(vec3(0.6, 0.6, 0.7), vec3(3.0, 1.5, 0.7), suna);\n    skyColorOut = mix(skyColorOut, vec3(5.0, 4.0, 2.5), sunb);\n    skyColorOut = mix(skyColorOut, vec3(8.0, 6.0, 4.0), smoothstep(0.9997, 0.9998, sunk));\n\n    float m = 1.0 - pow(1.0 - max(rd.y, 0.0), 4.0);\n\n    return skyColorOut;\n}\n\nvec3 aces(vec3 x) {\n    return clamp((x * ((2.51 * x) + 0.03)) / (x * ((2.43 * x) + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float aspect = max(iResolution.x / iResolution.y, iResolution.y / iResolution.x);\n    vec2 uv = (fragCoord / iResolution.xy) - 0.5;\n    uv.x *= aspect;\n    uv *= 2.0;\n    \n    float time = (iTime + ((1.0 / 60.0) * noise1random(iTime + uv)));\n    \n    vec3 ro = vec3(0.0, 0.0, -10.0);\n    vec3 rd = normalize(vec3(0.0, 0.0, 1.0));\n    ro.xy += uv * 4.0; // Ortho projection\n\n    mat3 rotation =\n        roteX(0.125) *\n        roteY(0.25);\n    \n    ro *= rotation;\n    rd *= rotation;\n\n    mapresult mr = march(ro, rd, time);\n    float d = mr.d;\n    int m = mr.m;\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p, time);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float skyFactor = d / RAY_MAX_DISTANCE;\n    \n    vec3 sunDir = normalize(vec3(0.5, 0.9, 0.5));\n    \n    vec3 skyColor = sky(rd, sunDir);\n    \n    vec3 surfaceColor = vec3(0.0);\n\n    // Path\n    if(m == 1) {\n        surfaceColor = vec3(0.0);\n    }\n    // Ball\n    else if(m == 2) {\n        surfaceColor = vec3(0.3);\n    }\n    // Other stuff\n    else if(m == 3) {\n        surfaceColor = vec3(-0.25);\n    }\n    \n    vec3 surfaceReflColor = vec3(0.0);\n    for(int i = 0; i < 30; i++) {\n        float seed = texture(iChannel3, vec2(time, float(i) * 0.62842)).x;\n        vec3 rdRefl = reflect(rd, n);\n        rdRefl = normalize(rdRefl + ((texture(iChannel3, vec2(p.x + p.z, p.y + p.z) + seed).xyz - 0.5) * 2.0) * 2.0);\n        surfaceReflColor += sky(rdRefl, sunDir);\n    }\n    surfaceReflColor /= 30.0;\n    surfaceColor += surfaceReflColor;\n\n    surfaceColor *= mix(directionalLightShaded(p, sunDir, n, time), 1.0, 0.5);\n    \n    col = mix(\n        surfaceColor,\n        skyColor,\n        skyFactor\n    );\n    \n    col = aces(col);\n    \n    col *= steprange(-1.0, 1.0, uv.x);\n    col *= steprange(-1.0, 1.0, uv.y);\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfBRj.jpg", "access": "api", "license": "mit", "functions": [[1301, 1301, 1322, 1322, 1344], [1345, 1345, 1366, 1366, 1388], [1390, 1390, 1409, 1409, 1475], [1477, 1477, 1497, 1497, 1523], [1525, 1525, 1545, 1545, 1671], [1673, 1673, 1693, 1693, 1819], [1821, 1821, 1841, 1841, 1969], [1971, 1971, 1992, 1992, 2019], [2021, 2021, 2042, 2042, 2069], [2071, 2071, 2092, 2092, 2119], [2398, 2398, 2421, 2421, 2441], [2443, 2443, 2467, 2467, 2503], [2505, 2505, 2531, 2531, 2575], [2577, 2577, 2618, 2618, 2660], [2662, 2662, 2704, 2704, 2747], [2749, 2749, 2793, 2793, 2838], [2840, 2840, 2869, 2869, 2923], [2925, 2925, 2953, 2953, 3005], [3007, 3007, 3039, 3039, 3061], [3063, 3063, 3096, 3096, 3124], [3126, 3126, 3167, 3167, 3219], [3221, 3221, 3271, 3271, 3387], [3389, 3389, 3418, 3418, 3513], [3562, 3562, 3597, 3597, 6027], [6029, 6029, 6076, 6076, 6424], [6426, 6426, 6459, 6459, 6715], [6717, 6717, 6766, 6766, 6831], [6833, 6833, 6917, 6917, 7037], [7039, 7039, 7071, 7071, 7518], [7520, 7520, 7539, 7539, 7631], [7633, 7633, 7685, 7685, 9504]], "test": "untested"}
{"id": "flfBR2", "name": "Rectangle Distance Field", "author": "VPaltoDance", "description": "Signed distance field for rectangle", "tags": ["distancefield", "rectangle", "box"], "likes": 1, "viewed": 466, "published": 3, "date": "1651091454", "time_retrieved": "2024-07-30T16:51:06.932663", "image_code": "#define COLOR_WHITE vec3(1.0)\n#define COLOR_BLACK vec3(0.0)\n#define COLOR_MAGENDA vec3(1.0, 0.0, 1.0)\n\n#define BOX_RECT vec2(0.6, 0.3)\n#define BOX_COLOR1 vec3(0.2, 0.7, 0.9)\n#define BOX_COLOR2 vec3(0.9, 0.7, 0.2)\n\nfloat calculateBoxSDF(vec2 point, vec2 boxRect)\n{\n   vec2 delta = abs(point) - boxRect;\n   return length(max(delta, 0.0)) + min(max(delta.x,delta.y),0.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n\n    float distField = calculateBoxSDF(uv, BOX_RECT);\n    \n    vec3 finalColor = mix(COLOR_WHITE, BOX_COLOR2, sign(distField));\n    finalColor *= 1.0 - exp(-2.0*abs(distField));;\n    finalColor *= 0.8 + 0.2 * cos(150.0 * distField);\n    finalColor = mix(finalColor, COLOR_WHITE, 1.0 - smoothstep(0.0, 0.02, abs(distField)));\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfBR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 263, 263, 371], [373, 373, 430, 480, 918]], "test": "untested"}
{"id": "7tsfRB", "name": "Pixel Art Generator", "author": "SnoopethDuckDuck", "description": "I'm quite happy with this, have a play with the values :)\n\nBased on this shader and forked shader:\nhttps://www.shadertoy.com/view/NtXBRH\n\nIssues:\nOver-engineered +  laggy when n is high\nNeed large n for medium shapes because random walk overlaps a lot", "tags": ["procedural", "generative", "pixelart", "procgen"], "likes": 22, "viewed": 1123, "published": 3, "date": "1651076336", "time_retrieved": "2024-07-30T16:51:07.993826", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale factor to enlarge image by\n    float sf = dim.y / (iResolution.y - dim.y);\n    sf *= 0.75;\n\n    // Scale and centre image to screen\n    vec2 coord = round(sf * fragCoord) ;\n    coord -= round(sf * 0.5 * iResolution.xy - 0.5 * dim);\n\n    vec3 col = texelFetch(iChannel0, ivec2(coord), 0).rgb;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(uv);\n    float m = mlength(uv);\n    \n    float s = step(m, 0.44);\n\n    vec3 col2 = mix(vec3(0.5,0.75,1.), vec3(1), 1.-s);\n    if (col == vec3(0))\n        col += 0.42 * exp(-1. * d) * col2;\n    else\n        col = sqrt(col) + 0.08;\n\n        \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n#define lineCol(x) ( .5 + .5 * thc(4., x+2. * pi / 3.*vec3(-1,0,1)) )\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat side(vec2 f, float a) {\n    f *= rot(a + pi/2.);    \n    return step(f.y, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center fragCoord + mirror x axis\n    fragCoord -= 0.5 * dim;\n    fragCoord.x = abs(fragCoord.x);\n    vec3 col = vec3(0);    \n    \n    // Use this to flick through patterns\n    float fl = 0.001 * iDate[1] + floor(-fragCoord.x/dim.x + iTime);\n\n    vec2 p = vec2(0);\n    \n    float a0 = 0.;\n    \n    float n = 120.;\n    for (float i = 0.; i < n; i++) {\n        // Random values for line positions\n        float h = h21(vec2(i + fl + 11., 0.131 * i - 103.));\n\n        // 0.5 and 2./3. work well\n        float m = (2./3.);//mix(0.5, 2./3., mod(i, 2.));\n        a0 += pi * (m * floor(5. * h) - 1.);\n        \n        // p + 2. * () works well too\n        // (probably worth replacing cos,sin with orthogonal vectors)\n        vec2 q = p + 1. * vec2(cos(a0), sin(a0));\n        q = round(q);\n        \n        // Center coords at p (side() cuts the plane through 0,0)\n        vec2 f = abs((0.5 + 0.5 * mod(fl, 2.)) * fragCoord - p);\n        // f = fragCoord - p;\n        vec2 pq = p - q;\n        float a = atan(pq.x, pq.y);\n        \n        // Center half (draw everything under the line)\n        float c = side(f, a);\n             \n        // Shifted halves for 1 pixel line\n        float t = side(f - vec2(0,1), a);\n        float b = side(f + vec2(0,1), a);\n        float l = side(f - vec2(1,0), a);\n        float r = side(f + vec2(1,0), a);\n        float mx = max(max(t,b), max(l,r));\n        float mn = min(min(t,b), min(l,r));\n        \n        // Line (not a line segment yet)\n        vec3 col2 = c * (mx - mn) * vec3(1);\n        \n        // Cut line into a line segment\n        float d = length(pq);\n        f *= rot(a + pi / 2.);\n        col2 *= step(abs(f.x - 0.5 * d), 0.5 * d);      \n       \n        // Darken\n        //col2 *= smoothstep(0., 1., 1.-i/n);\n       \n        // Color\n        vec3 e = vec3(0.5);\n        col2 *= pal(4. * i/n + 0.25 * fl, e, e, e, (i/n) * vec3(0,1,2)/3.);\n        //col2 *= lineCol(20. * i/n + 0.1 * fl);\n        \n        if (col == vec3(0))\n            col = col2;\n        //col = clamp(col + col2, 0., 1.);\n\n        p = clamp(q, vec2(0, -0.5 * dim.y), 0.5 * dim);\n    }\n   \n    // Restrict to bounds\n    //col *= step(fragCoord.x, 0.5 * dim.x) * step(fragCoord.y, 0.5 * dim.y);\n    \n   \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [], "common_code": "// dimensions of sprite - has to be less than screen dimensions\nconst vec2 dim = vec2(61);\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 97, 727]], "test": "untested"}
{"id": "NtlfRB", "name": "Pixel Lines V4", "author": "SnoopethDuckDuck", "description": "Playing about - really want to use this for procgen pixel art", "tags": ["copy", "thing"], "likes": 14, "viewed": 387, "published": 3, "date": "1651069185", "time_retrieved": "2024-07-30T16:51:08.960242", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale factor to enlarge image by\n    float sf = dim.y / (iResolution.y - dim.y);\n\n    // Scale and centre image to screen\n    vec2 coord = ceil(sf * fragCoord) ;\n    coord -= ceil(sf * 0.5 * iResolution.xy - 0.5 * dim);\n\n    vec3 col = texelFetch(iChannel0, ivec2(coord), 0).rgb;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(uv);\n\n    col += 0.4 * exp(-1. * d) * vec3(1,0.5,1);\n       \n    // Sloppy way of keeping it square-ish\n    // if (coord.x < - 11. || coord.x >= dim.x + 11.)\n    //     col = vec3(0.825);\n        \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define lineCol(x) ( .5 + .5 * thc(4., x+2. * pi / 3.*vec3(-1,0,1)) )\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat side(vec2 f, float a) {\n    f *= rot(a + pi/2.);    \n    return step(f.y, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center fragCoord + add a slight bend\n    fragCoord -= 0.5 * dim;\n    fragCoord.y += cos(fragCoord.x/dim.x * 10. + iTime);\n   \n    vec3 col = vec3(0);    \n    \n    // Use fl if you want to flick through patterns\n    float fl = floor(0. * iTime);\n    \n    // I'm not sure what value for n looks best\n    float n = 40.;\n    for (float i = 0.; i < n; i++) {\n        // Random values for line positions\n        float h = h21(vec2(i + fl + 11., 0.131 * i - 103.));\n        float h2 = h21(vec2((i+1.) + fl + 11., 0.131 * (i+1.) - 103.));    \n        \n        // Move stuff about a bit\n        float v = pi * (1. + thc(4., 0.125 * pi * i/n + 0.25 * iTime));\n        h *= v;\n        h += 2. * pi * i / n;\n        h2 *= v;       \n        h2 += 2. * pi * (1. - i / n);\n\n        // Line positions\n        float o = 0.5 * iTime;\n        vec2 p = 40. * vec2(cos(h + o), sin(h + o));\n        vec2 q = 40. * vec2(cos(h2 + o),sin(h2 - o));\n\n        // Center coords at p (side() cuts the plane through 0,0)\n        vec2 f = fragCoord - p;\n        vec2 pq = p - q;\n        float a = atan(pq.x, pq.y);\n        \n        // Center half (draw everything under the line)\n        float c = side(f, a);\n             \n        // Shifted halves for 1 pixel line\n        float t = side(f - vec2(0,1), a);\n        float b = side(f + vec2(0,1), a);\n        float l = side(f - vec2(1,0), a);\n        float r = side(f + vec2(1,0), a);\n        float mx = max(max(t,b), max(l,r));\n        float mn = min(min(t,b), min(l,r));\n        \n        // Line (not a line segment yet)\n        vec3 col2 = c * (mx - mn) * vec3(1);\n        \n        // Cut line into a line segment\n        float d = length(pq);\n        f *= rot(a + pi / 2.);\n        col2 *= step(abs(f.x - 0.5 * d), 0.5 * d);      \n       \n        // Darken\n        col2 *= smoothstep(0., 1., 1.-i/n);\n       \n        // Color\n        vec3 e = vec3(0.5);\n        col2 *= pal(3. * i/n + 0.25 * iTime, e, e, e, vec3(0,1,2)/3.);\n        \n        col = clamp(col + col2, 0., 1.);\n    }\n   \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [], "common_code": "// dimensions of sprite - has to be less than screen dimensions\nconst vec2 dim = vec2(81);\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 97, 666]], "test": "untested"}
{"id": "NtlfzB", "name": "SmearCam", "author": "lassemt", "description": "Smear effect for textures", "tags": ["smear"], "likes": 3, "viewed": 508, "published": 3, "date": "1651063389", "time_retrieved": "2024-07-30T16:51:09.766087", "image_code": "const float TWO_PI = 6.283185307179586;\nconst float amount = 0.2;\nconst float speeed = 0.05;\n\nvec2 rotate2D(vec2 position, float theta){\n\tmat2 m = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) );\n\treturn m * position;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vUv = fragCoord/iResolution.xy;\n\tvec2 p = vUv;\n\t// Displace image by its own rg channel\n\tvec2 sPos = vUv;\n\tvec2 off = texture(iChannel0, sPos ).rg - 0.5;\n\t\n\t// rotate\n\tfloat ang = iTime * TWO_PI * speeed;\n\toff = rotate2D(off, ang);\n\tp += off * amount;\n\t\n\tvec4 col = texture(iChannel0, p);\n\t\n\tfragColor = col;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 136, 136, 227], [229, 229, 284, 284, 604]], "test": "untested"}
{"id": "NtsfzS", "name": "Game of life + tracers", "author": "fyisic123", "description": "Pretty basic version of Conway's Game of Life. \nYou can paint with your mouse, and press R  to reset.\nSettings are under Common.", "tags": ["game", "life", "buffer", "gameoflife", "of", "tracers"], "likes": 3, "viewed": 253, "published": 3, "date": "1651052523", "time_retrieved": "2024-07-30T16:51:10.528050", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = texelFetch(iChannel0, ivec2(fragCoord / Pixel_Scaling), 0).r; // get pixel from buffer A\n    float t = texelFetch(iChannel1, ivec2(fragCoord), 0).r;  // get Tracer brightness \n    vec3 col = hue(t * 3.) * t * TRACER_BRIGHTNESS;  // get tracer color.\n    col += c; \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n\n// settings.\n#define Pixel_Scaling 4.  // pixel size  (may need reset if changed)\n#define Time_Scale 2  // frames to skip animation. 0 or 1 is full fps, 2 is every 2nd frame, 3 is every 3rd, and on.\n#define Brush_Size 2.\n#define TRACER_DECAY 1.5\n#define TRACER_BRIGHTNESS 0.2\n                      \n\n\nfloat hash11(float p)// random stuff\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n", "buffer_a_code": "\n\nbool evaluateFrame()\n{\n    if (Time_Scale == 0)\n        return true;\n    else if (iFrame % Time_Scale != 0)\n        return false;\n    else\n        return true;\n}\n\nfloat getRandomPixelState(vec2 pos)\n{\n    return step(.5, hash11(pos.x * pos.y * fract(iDate.x + iDate.y + iDate.z + iDate.w)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 bufferRes = iResolution.xy / Pixel_Scaling;  // Get buffer resolution\n    if (fragCoord.x > bufferRes.x || fragCoord.y > bufferRes.y)  // check if pixel is within buffer.           \n          return;\n    \n             \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(82,0),0).x > 0.)  // Randomize pixels on first frame or R is pressed.\n    {        \n        fragColor = vec4(getRandomPixelState(fragCoord));        \n        return;        \n    } \n        \n    vec4 Mus = iMouse;   // Brush \n    if (Mus.z > 0.)  \n    {                        \n        if (length((Mus.xy / Pixel_Scaling) - fragCoord) < Brush_Size)\n        {            \n            fragColor = vec4(1.); \n            return;\n        }\n        \n    }\n    \n    ivec2 coord = ivec2(fragCoord);  // convert coords to interger coordanate.\n    \n    if (!evaluateFrame())  // check if we should animate this frame or skip.\n    {           \n        fragColor = texelFetch(iChannel0, coord, 0).rgba;                  \n        return;   \n    }\n    \n                  \n    float neighborState = 0.;\n    float thisPixelState = 0.;\n    for(int x = -1; x <= 1; x++)  // nearby pixels life status\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            if (x == 0 && y == 0)  // if its this pixel store that value\n            {\n                thisPixelState =  texelFetch(iChannel0, coord, 0).r;                \n            }\n            else // otherwise if neighbor is alive add to counter.\n            {\n                neighborState +=  texelFetch(iChannel0, coord+ ivec2(x,y), 0).r;\n            }\n              \n        }\n    \n    }\n        \n    // Conway's Game of Life rules applied\n    float c =0.; \n    if (thisPixelState == 0.) // if pixel is dead\n    {\n        if (neighborState == 3.) // become alive if 3 neighbors are alive.\n            c = 1.;\n    }\n    else if (neighborState == 2. || neighborState == 3.) // if pixel is alive and has 2 or 3 alive neighbors\n            c = 1.;                                      // then stay alive otherwise pixel is dead (default value); \n                \n    \n    fragColor = vec4(c);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n                    \n    ivec2 coord = ivec2(fragCoord);  // convert coordanates to integer coordanate.\n    float c = 0.;\n    \n    // Tracers\n    for(int x = -1; x <= 1; x++)  // combine values of adjecent pixels.\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            c += texelFetch(iChannel1, coord + ivec2(x,y)  , 0).r;\n        }\n    }   \n    c *= 0.11111111111; // calculate avarage.\n    c *= max(0., 1. - (iTimeDelta * TRACER_DECAY)); // decay (darken).\n    \n    \n    // Add value from Buffer A and clamp to max 2.    \n    c = min(1.5, (c + texelFetch(iChannel0, ivec2(fragCoord / Pixel_Scaling), 0).r)); \n    \n    fragColor = vec4(c);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 370]], "test": "untested"}
{"id": "fllfzS", "name": "Perlin noise Ridged Multifratal", "author": "MrNissenDK", "description": "I recreated again my perlin noise to create Ridged Multifractal, after my old one had some sharp conners squarish.", "tags": ["noise", "perlin", "multifractal", "ridged"], "likes": 3, "viewed": 265, "published": 3, "date": "1651052109", "time_retrieved": "2024-07-30T16:51:11.333895", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 10.;\n    \n    float time = iTime * 0.5;\n    \n    float r = 1. - abs(perlin(vec3(-uv - vec2(time      + 058., time *  0.5), time), 1, .5) * 2. - 1.);\n    float g = 1. - abs(perlin(vec3( uv + vec2(time      + 255., time *  0.2), time), 1, .5) * 2. - 1.);\n    float b = 1. - abs(perlin(vec3( uv + vec2(time      + 954., time *  0.1), time), 1, .5) * 2. - 1.);\n    vec3 col = vec3(r,g,b);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "uint seed = 455245u;\n\nfloat modF(float x, float y)\n{\n    return x -  y * floor( x / y );\n}\n\nvec3 modF(vec3 a, float y)\n{\n    a = a;\n    return a -  y * floor( a / y );\n}\n\nint modI(int x, int y)\n{\n    return x -  y * (x / y);\n}\n\nvec3 modI(vec3 a, int y)\n{\n    a = floor(a);\n    return a -  float(y) * floor( a / float(y) );\n}\n\nuint modU(uint x, uint y)\n{\n    return x - ( x / y ) * y;\n}\n\nint random(uint i)\n{\n    uint si = i + seed;\n    si *= i;\n    si += seed;\n    si *= si;\n    si ^= seed;\n    si += i + seed;\n    si *= si;\n    si *= si;\n    si *= si;\n    si ^= seed;\n    return abs( modI( int(si), 255) );\n}\nint random(float i)\n{\n    return random(uint(i));\n}\nint random(int i)\n{\n    return random(uint(i));\n}\nint random(vec3 i)\n{\n    return random(\n        uint(random(\n            uint(random(\n                uint(i.x)\n            )) + uint(i.y)\n        )) + uint(i.z)\n    );\n}\n\nfloat fade(float t)\n{\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 fade(vec3 t)\n{\n    return vec3(fade(t.x), fade(t.y), fade(t.z));\n}\n\n\n\nint inc(int num)\n{\n    num++;\n    return num;\n}\n\nint inc(float num)\n{\n    return inc(int(num));\n}\n\nfloat grad(int hash, vec3 pos)\n{\n    int h = hash & 15;\n    float u = (h < 8) ? pos.x : pos.y;\n    \n    float v;\n    \n    if(h < 4)\n    {\n        v = pos.y;\n    }else if( h == 12 || h == 14 )\n    {\n        v = pos.x;\n    }else\n    {\n        v = pos.z;\n    }\n    \n    return (((h&1) == 0) ? u : -u)+((h&2) == 0 ? v : -v);\n}\n\nfloat lerp(float a, float b, float x)\n{\n    return a + x * (b - a);\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 posI = floor(pos);\n    vec3 posF = pos - posI;\n    \n    posI.x = float(int(posI.x) & 255);\n    posI.y = float(int(posI.y) & 255);\n    posI.z = float(int(posI.z) & 255);\n    \n    vec3 uvw = fade(posF);\n    \n    int aaa = random(vec3(     posI.x ,     posI.y ,     posI.z  ));\n    int aba = random(vec3(     posI.x , inc(posI.y),     posI.z  ));\n    int aab = random(vec3(     posI.x ,     posI.y , inc(posI.z) ));\n    int abb = random(vec3(     posI.x , inc(posI.y), inc(posI.z) ));\n    int baa = random(vec3( inc(posI.x),     posI.y ,     posI.z  ));\n    int bba = random(vec3( inc(posI.x), inc(posI.y),     posI.z  ));\n    int bab = random(vec3( inc(posI.x),     posI.y , inc(posI.z) ));\n    int bbb = random(vec3( inc(posI.x), inc(posI.y), inc(posI.z) ));\n    \n    float x1, x2, y1, y2;\n    \n    x1 = lerp(\n        grad(aaa, posF), \n        grad(baa, vec3(posF.x - 1., posF.y     , posF.z     )),\n        uvw.x\n    );\n    x2 = lerp(\n        grad(aba, vec3(posF.x     , posF.y - 1., posF.z     )), \n        grad(bba, vec3(posF.x - 1., posF.y - 1., posF.z     )),\n        uvw.x\n    );\n    y1 = lerp(x1,x2, uvw.y);\n    \n    x1 = lerp(\n        grad(aab, vec3(posF.x     , posF.y     , posF.z - 1.)), \n        grad(bab, vec3(posF.x - 1., posF.y     , posF.z - 1.)),\n        uvw.x\n    );\n    x2 = lerp(\n        grad(abb, vec3(posF.x     , posF.y - 1., posF.z - 1.)), \n        grad(bbb, vec3(posF.x - 1., posF.y - 1., posF.z - 1.)),\n        uvw.x\n    );\n    y2 = lerp(x1,x2, uvw.y);\n    \n    return (lerp (y1, y2, uvw.z) + 1.) / 2.;\n}\n\nfloat perlin(vec3 pos, int octaves, float persistence)\n{\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.;\n    \n    for(int i=0;i<octaves;i++) {\n        total += noise(pos * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    \n    return total/maxValue;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 605]], "test": "untested"}
{"id": "ftlBzS", "name": "Perlin noise from standard Noise", "author": "JustBoredYo", "description": "Got bored and wanted to play around with some noise so I figured trying this could be fun.", "tags": ["noiseperlinnoise"], "likes": 0, "viewed": 179, "published": 3, "date": "1651048563", "time_retrieved": "2024-07-30T16:51:12.205565", "image_code": "//Itterations to smooth the noise\nfloat octaves = 8.;\n//\"Size\" of the sampled noise texture | Doubles each itteration\nfloat frequency = 0.125;\n//\"Height\" of the sampled value | Halfes each itteration\nfloat amplitude = 1.;\n//Size of the uv space | 1 = noise texture is sampled once across the screen, 2 = twice, etc.\nfloat size = 1.0;\n//Final color of the pixel\nvec4 final = vec4(0.);\n//Radius of the circle in which the noise is shown\nfloat maskRadius = 200.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    maskRadius *= ((sin(iTime)+1.)/2.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy/iResolution.xy)*size;\n    \n    for(float i = 0.; i < octaves; i++)\n    {\n        //Sample region which increases each itteration\n        vec4 col = texture(iChannel0, (uv*frequency));\n        \n        //Just to get it to be black and white\n        col = vec4(col.x *= amplitude);\n        //You want to see it, right?\n        col.w = 1.0;\n        \n        //Added as it is normalized at the end\n        final += col;\n        \n        //Double/Half the values for the next itteration\n        frequency *= 2.;\n        amplitude *= .5;\n        \n    }\n    \n    //Calculate how far away the point is and normalize from 0(outside or edge) to 1(center)\n    float mask = (maskRadius - sqrt((fragCoord.x - iResolution.x/2.)*(fragCoord.x - iResolution.x/2.)+(fragCoord.y - iResolution.y/2.)*(fragCoord.y - iResolution.y/2.)))/maskRadius;\n        \n    //Normalize to not just have a white image and multiply with mask to get a smooth falloff\n    final = (normalize(final)*(octaves/2.))*mask;\n    \n    // Output to screen\n    fragColor = vec4(final);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 519, 519, 1682]], "test": "untested"}
{"id": "7tXfzB", "name": "Ridged Multifractal", "author": "MrNissenDK", "description": "So I tried to make Ridged Multifractal with my noise generation, but feel like it need some work.", "tags": ["noise", "perlin", "rainbow", "colorfull"], "likes": 1, "viewed": 248, "published": 3, "date": "1651043395", "time_retrieved": "2024-07-30T16:51:13.030359", "image_code": "float seed = 437585.453123;\nfloat PI = 3.141592653589793;\nfloat res = 10.; // how many sqrs along the x axes\n\nfloat hash21(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec2 (127.1, 351.7));\n  return fract(sin(f)*a);\n}\n\nvec2 hash2(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  p = vec2(dot (p, vec2 (127.1, 351.7)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p)*a);\n}\n\nvec3 hash23(vec2 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec3 p3 = vec3(dot (p, vec2 (127.1, 351.7)), dot (p, vec2 (261.5, 183.3)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p3)*a);\n}\n\nvec2 hash32(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec2 p2 = vec2(dot (p, vec3 (127.1, 351.7, 251.45)), dot (p, vec3 (261.5, 183.3, 376.89)));\n  return fract(sin(p2)*a);\n}\nfloat hash31(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec3 (127.1, 351.7, 251.45));\n  return fract(sin(f)*a);\n}\n\n//6t5-15t4+10t3\nfloat ease(float t)\n{\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\nvec2 ease(vec2 t)\n{\n  return vec2(ease(t.x), ease(t.y));\n}\nvec3 ease(vec3 t)\n{\n  return vec3(ease(t.x), ease(t.y), ease(t.z));\n}\nvec4 ease(vec4 t)\n{\n  return vec4(ease(t.x), ease(t.y), ease(t.z), ease(t.w));\n}\n\nfloat noise(vec2 point){\n    vec2 fr = ease(fract(point));\n    vec2 hi = ceil(point);\n    vec2 lo = floor(point);\n    \n    return mix(\n        mix(\n            hash21(lo), \n            hash21(vec2(hi.x , lo.y)), \n            fr.x\n        ), \n        mix(\n            hash21(vec2(lo.x , hi.y)),\n            hash21(hi),\n            fr.x\n        ), \n        fr.y\n    );\n}\n\nfloat noise(vec3 point){\n    vec3 fr = ease(fract(point));\n    vec3 hi = ceil(point);\n    vec3 lo = floor(point);\n    \n    return mix(\n        mix(\n            mix(\n                hash31(lo), \n                hash31(vec3(hi.x , lo.yz)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.y, lo.z)),\n                hash31(vec3(hi.xy, lo.z)),\n                fr.x\n            ), \n            fr.y\n        ),\n        mix(\n            mix(\n                hash31(vec3(lo.xy, hi.z)), \n                hash31(vec3(hi.x , lo.y, hi.z)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.yz)),\n                hash31(hi),\n                fr.x\n            ), \n            fr.y\n        ),\n        fr.z\n    );\n}\n\nfloat octal(vec3 uv, int octaves, float persistence)\n{\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += noise(uv * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total/maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    \n    /*vec3 col = vec3(\n        (\n            noise(uv)\n          + noise(uv * 2.) * .5\n          + noise(uv * 4.) * .25\n          + noise(uv * 8.) * .125\n        ) / 1.875\n    );*/\n\n    float r = 1.-abs((-octal(vec3(uv + vec2(sin(iTime / 10.), cos(iTime / 10.)) * 10., 500. + iTime / 5.0), 8, .5) + .5) * 2.);\n    float g = 1.-abs((-octal(vec3(uv + vec2(sin(iTime / 10.), cos(500. + iTime / 10.)) * 10., 2. * iTime / 5.0), 8, .5) + .5) * 2.);\n    float b = 1.-abs((-octal(vec3(uv + vec2(sin(500. + iTime / 10.), cos(iTime / 10.)) * 10., 2. * iTime / 5.0), 8, .5) + .5) * 2.);\n    \n    vec3 col = vec3(r, g, b);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 133, 133, 283], [285, 285, 306, 306, 484], [486, 486, 507, 507, 722], [724, 724, 745, 745, 948], [949, 949, 971, 971, 1129], [1131, 1147, 1168, 1168, 1219], [1220, 1220, 1239, 1239, 1278], [1279, 1279, 1298, 1298, 1348], [1349, 1349, 1368, 1368, 1429], [1431, 1431, 1455, 1455, 1799], [1801, 1801, 1825, 1825, 2587], [2589, 2589, 2643, 2643, 3015], [3017, 3017, 3074, 3124, 3875]], "test": "untested"}
{"id": "flXBzB", "name": "Sine SDF (Analytic Chebyshev)", "author": "blackle", "description": "my best Sine SDF approximation yet. no loops at all!", "tags": ["sdf", "sine"], "likes": 48, "viewed": 2549, "published": 3, "date": "1651026136", "time_retrieved": "2024-07-30T16:51:13.889064", "image_code": "//excluding the function cubicRoot:\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this works by exploiting the fact that there exist polynomials T_n\n//such that T_n(cos(x)) = cos(n*x). these are chebyshev polynomials\n//of the first kind. T_2 is a parabola, and we can estimate the\n//distance to the cosine curve by using the analytic distance to this\n//parabola.\n//\n//to get the distance from p to the sine curve, we first do\n//p.x = sin(p.x*frequency)/frequency\n//then we produce the closest point on the parabola\n//T_2(x) = 2x^2 - 1\n//call this point \"q\". we undo the mapping we made to p with\n//q.x = asin(q.x*frequency)/frequency\n//we do need to clamp it between -1 and 1 before passing into asin\n//but that is the gist of the method.\n//\n//this estimate only works for one half of the principal half cycle,\n//so we need to use two estimates for either side, and take the closest\n//point to p. finally we do a single newton's method update to finalize\n//the estimate. I'm not sure how accurate this is, but it looks extremely\n//close to the ground truth.\n//\n// article: https://suricrasia.online/demoscene/sine-distance/\n//\n//other solutions:\n//  iq:        https://www.shadertoy.com/view/3t23WG\n//  fabrice:   https://www.shadertoy.com/view/tsXXRM\n//  blackle 2: https://www.shadertoy.com/view/3lSyDG\n\n#define PI 3.141592653\n\n//perform one step of netwon's method to finalize the estimate\n#define ONE_NEWTON_STEP\n\n// of equation x^3+c1*x+c2=0\n/* Stolen from http://perso.ens-lyon.fr/christophe.winisdoerffer/INTRO_NUM/NumericalRecipesinF77.pdf,\n   page 179 */\n// subsequently stolen from https://www.shadertoy.com/view/MdfSDn\nfloat cubicRoot(float c1, float c2) {\n\tfloat q = -c1/3.;\n\tfloat r = c2/2.;\n\tfloat q3_r2 = q*q*q - r*r;\n\tif(q3_r2 < 0.) {\n\t\tfloat a = -sign(r)*pow(abs(r)+sqrt(-q3_r2),.333333);\n\t\tfloat b = a == 0. ? 0. : q/a;\n\t\treturn a+b;\n\t}\n\tfloat theta = acos(r/pow(q,1.5));\n\treturn -2.*pow(q,.5)*cos(theta/3.);\n}\n\nvec2 cls_one(vec2 p, float f) {\n    //sorry this is unreadable\n    float f2 = f*f; //sq\n    float cmn = 8.*f2*f2;\n    float x = sin(p.x*f)/f;\n    float pp = ((-4.*p.y-4.)*f2 + 1.)/cmn;\n    float qq = -x/cmn;\n    float sol = cubicRoot(pp, qq);\n    \n    x = asin(clamp(sol*f,-1.,1.))/f;\n    return vec2(x,-cos(f*2.*x));\n}\n\nvec3 sine_SDF(vec2 p, float freq) {\n    float wavelen = PI/freq;\n\n    //map p to be within the principal half cycle\n    float cell = round(p.x/wavelen)*wavelen;\n    float sgn = sign(cos(p.x*freq));\n    p.x = (p.x-cell)*sgn;\n    \n    vec2 off = vec2(-PI/freq/2.,0);\n    //approximate either side of the principal half cycle with\n    //the distance to the 2nd chebyshev polynomial of the 1st kind\n    vec2 a = -off+cls_one(off+p, freq/2.);\n    vec2 b =  off-cls_one(off-p, freq/2.);\n\n    //pick closest, comment out to see how the one-sided approximation looks\n    if (length(p-b) < length(p-a)) a = b;\n\n#ifdef ONE_NEWTON_STEP\n    //newton's method update via lagrange multipliers\n    //visually very close after one step, but more increases accuracy quadratically\n    vec3 K = vec3(a,p.x-p.y);\n    \n    //it might be possible to simplify this a lot...\n    vec3 lagrange = vec3(2.*(K.x-p.x)+K.z*-cos(K.x*freq)*freq,\n        2.*(K.y-p.y)-K.z,\n        K.y+sin(K.x*freq));\n    K -= (inverse(mat3(2.-K.z*-sin(K.x*freq)*freq*freq,0,cos(K.x*freq)*freq,0,2,1,-cos(K.x*freq)*freq,-1,0))*lagrange);\n    a = K.xy;\n    a.y = -sin(a.x*freq);\n#endif\n\n    float dist = length(p-a)*sign(p.y+sin(p.x*freq));\n    //map the closest point back to global coordinates\n    a.x *= sgn; a.x += cell;\n    return vec3(dist,a);\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tfloat scale = 5.;\n    uv*=scale; mouse*=scale;\n    float pixel_size = scale/iResolution.y;\n    \n    float t = sin(iTime)*.5+.5;\n    float freq = mix(20.,.1,sqrt(t));\n\n    vec3 mousedist = sine_SDF(mouse, freq);\n    vec3 col = shadeDistance(sine_SDF(uv, freq).x);\n    if (iMouse.z > 0.) {\n        col *= smoothstep(-pixel_size,pixel_size, distance(mouse, uv) - abs(mousedist.x)) *.5 +.5;\n        col = mix(vec3(.8,.9,.4), col, smoothstep(-pixel_size,pixel_size, distance(mousedist.yz, uv) - .05));\n    }\n    float sn = abs(uv.y+cos(uv.x*freq))-.01;\n    float snl = 0.*smoothstep(fwidth(sn),0.,sn);\n\n    fragColor = vec4(col,1.0) + snl;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXBzB.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1568, 1780, 1817, 1817, 2078], [2080, 2080, 2111, 2142, 2399], [2401, 2401, 2436, 2436, 3701], [3703, 3703, 3732, 3732, 4057], [4059, 4059, 4116, 4116, 4877]], "test": "ok"}
{"id": "NlXfzS", "name": "Fork Line Segme lakartoza 665", "author": "lakartoza", "description": "Modified https://www.shadertoy.com/view/3tdSDj by IQ", "tags": ["2d", "distancefield", "sdf", "line", "distance", "segment"], "likes": 1, "viewed": 225, "published": 3, "date": "1651015099", "time_retrieved": "2024-07-30T16:51:14.647037", "image_code": "// Signed distance and line segment\n\n// Segment:              https://www.shadertoy.com/view/3tdSDj\n// and many more here:   https://iquilezles.org/articles/distfunctions2d\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nvec3 line_color(in float d) {\n\n\tvec3 color = vec3(1.) - sign(d) * vec3(0., 0.8, 0.);\n\tcolor *= 1.5 - exp(.5 * abs(d));\n\tcolor *= .5 + .3 * d;\n\tcolor = mix(color, vec3(1.), 1. - smoothstep(.0, .015, abs(d)));\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\tfloat zoom = 2.5;\n\tpos *= zoom;\n    \n    \n    // Head\n    vec2 headPos = pos+vec2(0.,0.6);\n\tvec2 headCoord1 = vec2(0.,0.5);\n\tvec2 headCoord2 = vec2(0.,0.5);\n\tfloat headThickness = 0.1;\n\n\tfloat headD = line_segment(headPos, headCoord1, headCoord2) - headThickness;\n\n\tvec3 headColor = line_color(headD);\n\t\n    \n    // Body\n    vec2 bodyPos = pos+vec2(0.,0.8);\n\tvec2 bodyCoord1 = vec2(0.,0.5);\n\tvec2 bodyCoord2 = vec2(0.,0.);\n\tfloat bodyThickness = 0.05;\n\n\tfloat bodyD = line_segment(bodyPos, bodyCoord1, bodyCoord2) - bodyThickness;\n    \n\tvec3 bodyColor = line_color(bodyD);\n\n\n    // Left arm\n    vec2 leftArmPos = pos+vec2(0.12,0.32);\n\tvec2 leftArmCoord1 = vec2(0.,0.);\n\tvec2 leftArmCoord2 = vec2(-0.25,-0.25);\n\tfloat leftArmThickness = 0.03;\n\n\tfloat leftArmD = line_segment(leftArmPos, leftArmCoord1, leftArmCoord2) - leftArmThickness;\n    \n\tvec3 leftArmColor = line_color(leftArmD);\n\n\n    // Right arm\n    vec2 rightArmPos = pos+vec2(-0.12,0.32);\n\tvec2 rightArmCoord1 = vec2(0.,0.);\n\tvec2 rightArmCoord2 = vec2(0.02*sin(iTime*3.)+0.20,0.25);\n\tfloat rightArmThickness = 0.03;\n\n\tfloat rightArmD = line_segment(rightArmPos, rightArmCoord1, rightArmCoord2) - rightArmThickness;\n    \n\tvec3 rightArmColor = line_color(rightArmD);\n\n\n    // Right leg\n    vec2 rightLegPos = pos+vec2(-0.08,0.87);\n\tvec2 rightLegCoord1 = vec2(0.,0.);\n\tvec2 rightLegCoord2 = vec2(0.05,-0.35);\n\tfloat rightLegThickness = 0.03;\n\n\tfloat rightLegD = line_segment(rightLegPos, rightLegCoord1, rightLegCoord2) - rightLegThickness;\n    \n\tvec3 rightLegColor = line_color(rightLegD);\n\n\n    // Left leg\n    vec2 leftLegPos = pos+vec2(0.05,0.87);\n\tvec2 leftLegCoord1 = vec2(0.,0.);\n\tvec2 leftLegCoord2 = vec2(-0.05,-0.35);\n\tfloat leftLegThickness = 0.03;\n\n\tfloat leftLegD = line_segment(leftLegPos, leftLegCoord1, leftLegCoord2) - leftLegThickness;\n    \n\tvec3 leftLegColor = line_color(leftLegD);\n\n\n\n\n\n\n    vec3 color = headColor+bodyColor+leftArmColor+rightArmColor+rightLegColor+leftLegColor;\n\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 227, 227, 347], [349, 349, 378, 378, 577], [579, 579, 634, 634, 2685]], "test": "untested"}
{"id": "ftfBzS", "name": "one more wrongness of float hash", "author": "FabriceNeyret2", "description": "seed = hash(seed) get stuck with float hash !\nselect a #define", "tags": ["hash"], "likes": 7, "viewed": 283, "published": 3, "date": "1651007335", "time_retrieved": "2024-07-30T16:51:15.594504", "image_code": "  #define hash(p)   fract(sin( (p) * 12.9898 +1. ) * 43758.5453)  // get stuck soon !\n//#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) // get stuck later !\n//#define hash(p)   vec2( hash(vec3(p.x)).x, hash(vec3(p.y)).x ) \n\nfloat line(vec2 p, vec2 a,vec2 b) {                    // line SDF\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);                      \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, U = u/R,\n          P = vec2(1,2), P0;\n    float d = 9., l, i,n;\n    \n    for( i=0.; i< float(min(1000,iFrame/5)); i++ ) {  // ---polyline loop\n        P0 = P, P = hash(P),                          // next point = hash(prev)\n        l = line(U, P0,P);\n        if (l<d) d=l, n=i;                            // keep closest to pixel\n      }\n   \n    O = vec4( smoothstep( 1.5/R.y, 0., d ) * (1.-exp2(-2.*n/i)) ); // display\n}\n", "image_inputs": [], "common_code": "  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 uhash3( uvec3 x )         // iq version\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 hash( vec3 f )            // vec3 to vec3. any scaling. f.z=0 seed is ok.\n{ \n    return uhash3( uvec3( floatBitsToUint(f.x),\n                          floatBitsToUint(f.y),\n                          floatBitsToUint(f.z) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 289, 320, 446], [448, 448, 486, 486, 938]], "test": "untested"}
{"id": "ftXfRS", "name": "XY Oscilloscope Music - Springs", "author": "shyshokayu", "description": "This is just one really fast point of light moving around.\nE to toggle waveform\nQ to toggle point cache texture (blue is free memory, if there is no free left then you might see artifacting in the oscilloscope, overrides waveform view)", "tags": ["oscilloscope", "music", "xy"], "likes": 19, "viewed": 547, "published": 3, "date": "1651004934", "time_retrieved": "2024-07-30T16:51:16.631731", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n/*\n    ---| Go to Common tab to play with sound |---\n*/\n\n#define VISUAL_LINE_COLOR vec3(0.45, 1.0, 0.4)\n#define VISUAL_LINE_BLUR 2.0\n#define VISUAL_LINE_BRIGHTNESS 1000.0\n\nfloat sliderPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 ab = b - a;\n    return dot(p - a, ab) / dot(ab, ab);\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in float d) {\n    return mix(a, b, saturate(d));\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    return closestPointLine(a, b, sliderPointLine(a, b, p));\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p, in float k) {\n    vec2 d = p - closestPointLine(a, b, k);\n    return dot(d, d);\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 d = p - closestPointLine(a, b, p);\n    return dot(d, d);\n}\n\nfloat distToLine(in vec2 a, in vec2 b, in vec2 p) {\n    return sqrt(distToLineSqr(a, b, p));\n}\n\nvec2 pointTex(in float t) {\n    // Estimate location based on texture coordinate\n    t *= float(VISUAL_ITERATIONS);\n    \n    // Convert to int for texelFetch and for more reliable arithmetic\n    int i = int(t);\n    int j = i + 1;\n    \n    // Interpolation between two sampled points\n    ivec2 ip1 = ivec2(i % int(iChannelResolution[0].x), i / int(iChannelResolution[0].x));\n    ivec2 ip2 = ivec2(j % int(iChannelResolution[0].x), j / int(iChannelResolution[0].x));\n    vec2 p1 = texelFetch(iChannel0, ip1, 0).xy;\n    vec2 p2 = texelFetch(iChannel0, ip2, 0).xy;\n    \n    vec2 p = mix(p1, p2, fract(t));\n\n    return p;\n}\n\nvec2 pointTexi(in int i) {\n    int r = int(iChannelResolution[0].x);\n    return texelFetch(iChannel0, ivec2(i % r, i / r), 0).xy;\n}\n\nfloat imageVectorScopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    float d = 0.01 + distanceSqr(a - b); // Emit less light if line is longer\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return min((0.00000004 / ((ld + (VISUAL_LINE_BLUR * 0.00001)) * d)), 0.2) * VISUAL_LINE_BRIGHTNESS;\n}\n\nfloat imageVectorScopeLines(in vec2 uv) {\n    float v = 0.0; // Total value\n    float lv = 0.0; // Last value\n    float cv = 0.0; // Current value\n    \n    vec2 cp;\n    vec2 lp = pointTexi(0);\n    \n    float fv = 1.0 / float(VISUAL_ITERATIONS);\n    float k;\n    \n    for(int i = 1; i < VISUAL_ITERATIONS; i++) {\n        cp = pointTexi(i); // Get the point\n        k = float(i) * fv;\n        cv = imageVectorScopeLine(lp, cp, uv) * (1.0 - k); // Set current value and multiply by time\n        v += max(lv, cv); // Eliminate circles between the lines\n        lv = cv; // Set last value to current value\n        lp = cp; // Set last point to current point\n    }\n    \n    return v * fv;\n}\n\nvec3 imageVectorScope(in vec2 uv) {\n    vec3 col = vec3(0.0);\n\n    // Lines\n    float v = imageVectorScopeLines(uv);\n    vec3 emitCol = pow(v * 0.5, 0.5) * VISUAL_LINE_COLOR;\n\n    // Grid\n    vec3 surfaceCol = vec3(1.0);\n    float gridV =  0.25 * (max(max(step(fract(uv.x * 4.0), 0.01), step(1.0 - 0.01, fract(uv.x * 4.0))), max(step(fract(uv.y * 4.0), 0.01), step(1.0 - 0.01, fract(uv.y * 4.0)))));\n    surfaceCol = mix(surfaceCol, vec3(2.0), gridV);\n\n    // Ambient light                                                           Inner display tube light absorption?\n    vec3 lightCol = vec3(0.045) * max(0.0, dot(uv + 0.5, vec2(0.12, 0.15) * 4.0)) * linearstep(-0.5, 3.0, length(uv));\n\n    // Color compositing\n    col = surfaceCol * lightCol;\n    col += emitCol * (1.0 - gridV);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n\n    return col;\n}\n\nfloat imageOscilloscopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    const float ta = 0.0;\n    const float tb = 0.004;\n    const float dta = ta * ta;\n    const float dtb = tb * tb;\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return linearstep(dtb, dta, ld);\n}\n\nvec3 oscilloscopePoint(float x) {\n    return vec3(x, pointTex(1.0 - ((x * 0.5) + 0.5)));\n}\n\nvec3 imageOscilloscope(in vec2 uv) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    \n    float scale = 2.0;\n    un *= scale;\n    \n    const float segments = 250.0;\n    const float thickness = 1.0 / segments;\n    const float gridThickness = 0.001;\n    const float gridInterval = 2.0;\n    float ip = round(uv.x * segments);\n    float unit = 1.0 / segments;\n\n    vec3 p0 = oscilloscopePoint((ip - 2.0) * unit),\n         p1 = oscilloscopePoint((ip - 1.0) * unit),\n         p2 = oscilloscopePoint((ip) * unit),\n         p3 = oscilloscopePoint((ip + 1.0) * unit),\n         p4 = oscilloscopePoint((ip + 2.0) * unit);\n\n    float dist1 = min(min(distToLine(p0.xy, p1.xy, uv), distToLine(p1.xy, p2.xy, uv)),\n                      min(distToLine(p2.xy, p3.xy, uv), distToLine(p3.xy, p4.xy, uv))) - thickness;\n    \n    float dist2 = min(min(distToLine(p0.xz, p1.xz, uv), distToLine(p1.xz, p2.xz, uv)),\n                      min(distToLine(p2.xz, p3.xz, uv), distToLine(p3.xz, p4.xz, uv))) - thickness;\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(0.8, 0.2, 0.2) * smoothstep(un, -un, dist1);\n    col += vec3(0.2, 0.2, 0.8) * smoothstep(un, -un, dist2);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    vec2 uv = (u - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    uv *= 2.0;\n    \n    vec3 col = mix(\n        mix(\n            imageVectorScope(uv),\n            imageOscilloscope(uv),\n            texelFetch(iChannel3, ivec2(69, 2), 0).x // nice\n        ),\n        ((texture(iChannel0, (u / iResolution.xy)).xyz * 0.5) + 0.5), // Show cached points visually\n        texelFetch(iChannel3, ivec2(81, 2), 0).x\n    );\n\n    col = pow(col, vec3(1.0 / 1.3));\n\n    // Full depth dithering, a way to make your images less bandy in low color ranges.\n    // Since we're using floats here, we can use that as an opportunity to dither that to the common color format, 32bit rgba.\n    float depth = 256.0;\n    vec3 cd = col * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    vec3 ditheredCol = (step(texture(iChannel2, u * 0.125).x + 0.00001, df) + di) / depth;\n    \n    o = vec4(ditheredCol, 1.0);\n\n    // Just uncomment this line and see how much of a difference this dithering makes in the dark areas.\n    //o = vec4(col, 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n#define VISUAL_ITERATIONS 300\n#define VISUAL_DURATION 0.02\n\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\n#define map(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(map(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define distanceSqr(v) dot(v, v)\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\n#define rote(r) rot(r * PI)\n\nfloat easeIn(float x) {\n    return x * x;\n}\n\nfloat easeOut(float x) {\n    return 1.0 - easeIn(1.0 - x);\n}\n\nfloat easeInOut(float x) {\n    return mix(easeIn(x), easeOut(x), x);\n}\n\nfloat easeIn(float a, float b, float x) {\n    return easeIn(linearstep(a, b, x));\n}\n\nfloat easeOut(float a, float b, float x) {\n    return easeOut(linearstep(a, b, x));\n}\n\nfloat easeInOut(float a, float b, float x) {\n    return easeInOut(linearstep(a, b, x));\n}\n\nfloat randomnoise11(float p) {\n    return fract(sin(p * 12.9898) * 43758.5453123);\n}\n\nvec2 randomnoise12(float p) {\n    float x = randomnoise11(p);\n    return vec2(x, randomnoise11(p + x));\n}\n\n#define pitch(x) (pow(1.059460646483, x) * 440.0)\n\n#define sine(x) sin((x) * PI)\n#define cosine(x) cos((x) * PI)\n#define square(x) ((fract((x) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define cosquare(x) ((fract(((x) + 0.5) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define saw(x) ((fract((x) * 0.5) * 2.0) - 1.0)\n#define cosaw(x) ((fract(((x) + 0.5) * 0.5) * 2.0) - 1.0)\n#define cotriangle(x) (-(abs(fract((x) * 0.5) - 0.5) * 4.0) + 1.0)\n#define triangle(x) cotriangle((x) + 0.5)\n\nvec3 box(float t) {\n    const vec3[] points = vec3[](\n        vec3(-1.0, -1.0, -1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(-1.0, 1.0, 1.0),\n        vec3(-1.0, 1.0, 1.0),\n        vec3(-1.0, 1.0, -1.0),\n        vec3(-1.0, 1.0, -1.0),\n        vec3(-1.0, -1.0, -1.0),\n        \n        vec3(1.0, -1.0, -1.0),\n        vec3(1.0, -1.0, 1.0),\n        vec3(1.0, -1.0, 1.0),\n        vec3(1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, -1.0),\n        vec3(1.0, 1.0, -1.0),\n        vec3(1.0, -1.0, -1.0),\n        \n        vec3(-1.0, -1.0, -1.0),\n        vec3(1.0, -1.0, -1.0),\n        vec3(1.0, -1.0, 1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(-1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, 1.0),\n        vec3(1.0, 1.0, -1.0),\n        vec3(-1.0, 1.0, -1.0)\n    );\n    \n    int i = (int(t) * 2) % (points.length());\n    return mix(points[i], points[i + 1], fract(t));\n}\n\nvec3 hihats(float t) {\n    vec3 p = vec3(0.0);\n\n    p.xy = ((randomnoise12(t) * 2.0) - 1.0) * 0.5 * fract(-t + 0.25);\n    \n    p.xy *= step(fract(t * 2.0), 0.125) * step(fract(t * 0.5), 0.85);\n    \n    return p;\n}\n\nvec3 kick(float t) {\n    float tf = (t * 300.0) - (20.0 * (fract(-t * 0.5) * easeOut(0.0, 0.1, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p *= 3.0 * fract(-t * 3.0);\n    p *= smoothstep(0.0625, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 kicks(float t) {\n    vec3 p;\n    \n    float t2 = fract(t * 0.125) * 8.0;\n    \n    p += kick(t2);\n    p += kick(t2 - 0.5);\n    p += kick(t2 - 1.75);\n    p += kick(t2 - 2.5);\n    \n    p += kick(t2 - 4.0);\n    p += kick(t2 - 4.5);\n    p += kick(t2 - 5.75);\n    p += kick(t2 - 6.5);\n    p += kick(t2 - 7.5);\n    \n    return p;\n}\n\nvec3 snare(float t) {\n    float tf = (t * 400.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy += ((randomnoise12(t) * 2.0) - 1.0) * 2.0 * fract(t * 3.0);\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.0625 * 4.0, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snare2(float t) {\n    float tf = (t * 1200.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy += ((randomnoise12(t) * 2.0) - 1.0) * 2.0 * fract(t * 3.0);\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.0625 * 3.0 * 0.25, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snares(float t) {\n    vec3 p;\n    \n    float t2 = fract((t * 0.25) + 0.25) * 4.0;\n    \n    p += snare(t2);\n    p += snare(t2 - 2.0);\n    \n    return p;\n}\n\nvec3 drums(float t) {\n    vec3 p;\n    \n    p += kicks(t);\n    p += snares(t);\n    \n    return p;\n}\n\nfloat freqArpeggiator1(float t) {\n    float i = (fract(floor(t * 8.0) * 0.25) * 16.0);\n    i += (fract(floor(t * 1.0) * 0.25) * 12.0);\n    i += 2.0;\n    \n    return pitch(i);\n}\n\nfloat freqArpeggiator2(float t) {\n    float s = (triangle(floor(t * 8.0) * 0.25) * 0.5) + 0.5;\n    s += ((triangle(floor(t) * 0.5) * 0.5) + 0.5) * 2.0;\n    s += 1.0;\n    \n    return s * 300.0;\n}\n\nfloat freqArpeggiator3(float t) {\n    return ((fract(floor(t * 8.0) * 0.25) * 2.0) + (fract(floor(t) * 0.25) * 2.0) + 1.0) * 440.0;\n}\n\nvec3 spiralSpeedup(float t) {\n    vec3 p;\n    \n    t -= easeOut(0.0, 8.0, t) * 4.0;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy *= 2.0;\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p *= fract((tf * 0.125) + (t * 0.25));\n    \n    p *= (fract(-t) * 0.5) + 0.5;\n    \n    float pan = sine(t * 0.5);\n    p.xy *= vec2((pan * 0.25) + 0.75, (-pan * 0.25) + 0.75);\n    p.xy *= vec2((pan * 0.25) + 0.75, (-pan * 0.25) + 0.75);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 spiralWithHihat(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy *= 2.0;\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p *= fract((tf * 0.125) + (t * 0.25));\n    \n    p *= (fract(-t) * 0.5) + 0.5;\n    \n    float pan = sine(t * 0.5);\n    p.xy *= vec2((pan * 0.25) + 0.75, (-pan * 0.25) + 0.75);\n    p.xy *= vec2((pan * 0.25) + 0.75, (-pan * 0.25) + 0.75);\n    \n    p *= easeOut(8.0, 7.75, t);\n    \n    p += hihats(t);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 spiralWithHihatAndDrums(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy *= 2.0;\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p *= mix(fract((tf * 0.125) + (t * 0.25)), 1.0, (1.0 - fract(-t)) * easeOut(0.0, 8.0, t));\n    \n    p *= (fract(-t) * 0.5) + 0.5;\n    \n    vec2 p2 = p.xy;\n    float pan = sine(t * 0.5);\n    p2 *= vec2((pan * 0.25) + 0.75, (-pan * 0.25) + 0.75);\n    p2 *= vec2((pan * 0.25) + 0.75, (-pan * 0.25) + 0.75);\n    \n    p.xy = mix(p.xy, p2, linearstep(16.0, 8.0, t));\n    \n    p += kicks(t);\n    p += hihats(t);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 transitionToRegularSpring(float t) {\n    vec3 p;\n    \n    float t2 = t + 16.0;\n    \n    float freq = freqArpeggiator1(t2);\n    float tf = t2 * freq;\n    \n    p = vec3(sin(tf * 3.1415), 0.0, cos(tf * 3.1415));\n    \n    tf += freq * 0.0625 * 0.0625 * 0.125;\n    \n    p.y = mix(\n        (easeIn(fract(tf * 0.25)) * 2.0) - 1.0,\n        (easeOut(fract(tf * 0.25)) * 2.0) - 1.0,\n        (sine(t * 8.0) * 0.5) + 0.5\n    );\n    \n    p.yz *= rot(((easeIn(0.5, 0.0, t) * -0.5) * PI));\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy = mix(p.xy * 0.5 * ((fract(-t) * 0.5) + 0.5), p.xy / p.z, easeOut(0.0, 0.5, t));\n    \n    return p;\n}\n\nvec3 regularSpring(float t) {\n    vec3 p;\n    \n    float t2 = t + 16.0;\n    \n    float freq = freqArpeggiator1(t2);\n    float tf = t2 * freq;\n    \n    // A little different than normal but it sounds better this way imo (slight PI imperfection to desync spring cycle)\n    p = vec3(sin(tf * 3.1415), 0.0, cos(tf * 3.1415));\n    \n    p.y = mix(\n        (easeIn(fract(tf * 0.25)) * 2.0) - 1.0,\n        (easeOut(fract(tf * 0.25)) * 2.0) - 1.0,\n        (sine(t * 8.0) * 0.5) + 0.5\n    );\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 regularSpringRotating(float t) {\n    vec3 p;\n    \n    float t2 = t + 16.0;\n    \n    float freq = freqArpeggiator1(t2);\n    float tf = t2 * freq;\n    \n    p = vec3(sin(tf * 3.1415), 0.0, cos(tf * 3.1415));\n    \n    p.y = mix(\n        (easeIn(fract(tf * 0.25)) * 2.0) - 1.0,\n        (easeOut(fract(tf * 0.25)) * 2.0) - 1.0,\n        (sine(t * 8.0) * 0.5) + 0.5\n    );\n    \n    p.yz *= rot(t * 0.5 * PI);\n    p.xz *= rot(t * 0.5 * PI);\n    p.xy *= rot(t * 0.5 * PI);\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 sphericalSpring(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    t = fract(t * 0.125) * 8.0;\n    p = vec3(sine(tf), 0.0, cosine(tf));\n    \n    p.y = (((fract((tf * 0.125) + (t * 0.5))) * 2.0) - 1.0);\n    \n    p.xz *= abs(sine((t * freq * 0.125) + (t * 0.5)));\n    \n    p.xy *= rot(t * 0.5 * PI);\n    \n    p *= 1.25;\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 0.75 + 0.25 * fract(-t * 8.0);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 sphericalSpringRotating(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    t = fract(t * 0.125) * 8.0;\n    p = vec3(sine(tf), 0.0, cosine(tf));\n    \n    p.y = (((fract((tf * 0.125) + (t * 0.5))) * 2.0) - 1.0);\n    \n    p.xz *= abs(sine((t * freq * 0.125) + (t * 0.5)));\n    \n    p.xy *= rot(t * 0.5 * PI);\n    p.yz *= rot(t * 0.5 * PI);\n    \n    p *= 1.25;\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 0.75 + 0.25 * fract(-t * 8.0);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 springTunnel(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    tf += t;\n    p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy *= 3.7;\n    \n    p *= pow(fract((tf * 0.125) + (t - pow(fract(-t * 2.0), 2.0)) * 0.5), 2.0);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p.xy = clamp(p.xy, vec2(-1.5), vec2(1.5));\n    \n    // Clamping fun\n    /*vec2 clbl = vec2(-((sine(t * 0.5) * 0.25) + 1.0), -((sine(t * 0.5) * 0.25) + 1.0));\n    vec2 clbr = vec2(((sine(t * 0.5 + 0.5) * 0.25) + 1.0), -((sine(t * 0.5 + 0.5) * 0.25) + 1.0));\n    vec2 cltl = vec2(-((sine(t * 0.5 + 1.5) * 0.25) + 1.0), ((sine(t * 0.5 + 1.5) * 0.25) + 1.0));\n    vec2 cltr = vec2(((sine(t * 0.5 + 1.0) * 0.25) + 1.0), ((sine(t * 0.5 + 1.0) * 0.25) + 1.0));\n    \n    float cll = mix(clbl.x, cltl.x, linearstep(clbl.y, cltl.y, p.y));\n    float clb = mix(clbl.y, clbr.y, linearstep(clbl.x, clbr.x, p.x));\n    float clr = mix(clbr.x, cltr.x, linearstep(clbr.y, cltr.y, p.y));\n    float clt = mix(cltl.y, cltr.y, linearstep(cltl.x, cltr.x, p.x));\n    \n    p.xy = clamp(p.xy, vec2(cll, clb), vec2(clr, clt));*/\n    \n    p.xy = clamp(p.xy, vec2(-1.25), vec2(1.25));\n\n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 springTunnel2(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    tf += t;\n    p = vec3(sine(tf), cosine(tf), saw(tf * 0.25 - t * 0.25) + 1.0);\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p -= vec3(0.0, 0.0, -0.5);\n    p.xy /= p.z * 2.0;\n    \n    return p;\n}\n\nvec3 springTunnelEnd(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    tf += t;\n    p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy *= 3.7;\n    \n    p *= mix(pow(fract((tf * 0.125) + (t + pow(fract(-t * 2.0), 2.0)) * 0.5), 2.0), 0.7, (1.0 - fract(-t * 0.5)));\n    \n    p.xy = clamp(p.xy, vec2(-1.25), vec2(1.25));\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 springTunnelEndFadeToCircle(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    float kd = easeOut(12.0, 16.0, t);\n    \n    tf += t;\n    p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy *= mix(3.7, 1.25, kd);\n    \n    p *= mix(mix(pow(fract((tf * 0.125) + (t + pow(fract(-t * 2.0), 2.0)) * 0.5), 2.0), 0.7, (1.0 - fract(-t * 0.5))), 1.0, kd);\n    \n    p.xy = clamp(p.xy, vec2(-1.25), vec2(1.25));\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec3 spinningDonut(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    p = vec3(0.0, 0.0, 0.0);\n    \n    p.x -= 0.5 * fract(-t * 4.0);\n    p.xz *= rote(tf * (((fract(floor(t * 2.0) * 0.25) * 8.0) + 3.0)));\n    \n    p.x -= 1.0;\n    p.xy *= rote(tf);\n    \n    p.yz *= rote(t * 0.25);\n    p.xz *= rote(t * 1.0);\n    p.xy *= rote(t * 0.5);\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\n// Unused for now\nvec3 fractalDonut(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator1(t) * 0.25;\n    float tf = t * freq;\n    \n    p = vec3(0.0, 0.0, 0.0);\n    \n    float st = 8.0;\n    \n    p.x -= 0.0625 * 0.25;\n    p.xy *= rote(tf * 512.0);\n    \n    p.x -= 0.0625;\n    p.xy *= rote(tf * 64.0);\n    \n    p.x -= 0.25;\n    p.xz *= rote(tf * 8.0);\n    \n    p.x -= 1.0;\n    p.xy *= rote(tf);\n    \n    p += vec3(0.0, 0.0, 0.0);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    p.xy *= step(0.0, p.z);\n    \n    return p;\n}\n\n// Unrelated, might remove later but it sounds cool\nvec3 spikyBeam(float t) {\n    vec3 p;\n    \n    float freq = freqArpeggiator2(t);\n    float tf = t * freq;\n    \n    float k = sine(tf) + sine(tf * 0.5) + sine(tf * 0.25);\n    p = vec3(k, k, 0.0);\n    \n    p.xy *= rote(t);\n    \n    p *= (fract(-t * 8.0) * 0.5) + 0.5;\n    \n    p += drums(t);\n    p += hihats(t);\n    \n    p -= vec3(0.0, 0.0, -2.0);\n    p.xy /= p.z;\n    \n    return p;\n}\n\nvec2 point(float t) {\n    vec3 p = vec3(0.0);\n    \n    t -= 2.0;\n    t = max(t, -2.0);\n    \n    float t2 = t;\n    \n    p += steprange(0.0, 8.0, t2) * spiralSpeedup(t2);\n    t2 -= 8.0;\n    \n    p += steprange(0.0, 8.0, t2) * spiralWithHihat(t2);\n    t2 -= 8.0;\n    \n    p += steprange(0.0, 8.0, t2) * spiralWithHihatAndDrums(t2);\n    t2 -= 8.0;\n    \n    p += steprange(0.0, 0.5, t2) * transitionToRegularSpring(t2);\n    p += steprange(0.5, 8.0, t2) * regularSpring(t2);\n    t2 -= 8.0;\n    \n    p += steprange(0.0, 8.0, t2) * regularSpringRotating(t2);\n    t2 -= 8.0;\n    \n    p += steprange(0.0, 8.0, t2) * sphericalSpring(t2);\n    t2 -= 8.0;\n    \n    p += steprange(0.0, 8.0, t2) * sphericalSpringRotating(t2);\n    t2 -= 8.0;\n    \n    p += steprange(0.0, 16.0, t2) * springTunnel(t2);\n    t2 -= 16.0;\n    \n    p += steprange(0.0, 12.0, t2) * springTunnelEnd(t2);\n    p += steprange(12.0, 16.0, t2) * springTunnelEndFadeToCircle(t2);\n    t2 -= 16.0;\n    \n    p += steprange(0.0, 16.0, t2) * spinningDonut(t2);\n    p *= smoothstep(16.0, 15.75, t2);\n    t2 -= 16.0;\n    \n    //p = springTunnel2(t);\n    \n    //p = spikyBeam(t);\n    \n    //p = round(p * 32.0) / 32.0;\n    \n    return clamp(p.xy, vec2(-1.0), vec2(1.0));\n}\n", "buffer_a_code": "// Samples coordinates every frame instead of sampling every iteration for every pixel for every frame\nvoid mainImage(out vec4 o, in vec2 u) {\n    // Estimate time based on pixel and calculate point\n    u.y -= 0.5; // For some reason this fixes the error where t > VISUAL_ITERATIONS is wrong\n    float t = u.x + (u.y * iResolution.x);\n    \n    // Skip samples if outside used region\n    if(t > float(VISUAL_ITERATIONS)) { // Not perfect but saves a bit of performance (not sure because of SIMD)\n        o = vec4(0.0, 0.0, 0.5, 1.0);\n        return;\n    }\n    \n    t /= float(VISUAL_ITERATIONS);\n    t *= VISUAL_DURATION;\n    \n    // Output point result\n    o.xy = point((iTime - t) + iTimeDelta);\n    o.zw = vec2(0.0, 1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "vec2 mainSound(int s, float t) {\n    vec2 v = point(t);\n\n    // Some background noise (optional)\n    v += (((texture(iChannel0, vec2(t * 1.4236, t * 1.2267)).xy * 2.0) - 1.0) * 0.0625 * 0.25);\n\n    return v * 0.25; // User convenience, we don't want to destroy any ears\n}\n", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXfRS.jpg", "access": "api", "license": "mit", "functions": [[1446, 1446, 1502, 1502, 1566], [1568, 1568, 1625, 1625, 1662], [1664, 1664, 1720, 1720, 1783], [1785, 1785, 1851, 1851, 1919], [1921, 1921, 1975, 1975, 2043], [2045, 2045, 2096, 2096, 2139], [2141, 2141, 2168, 2221, 2759], [2761, 2761, 2787, 2787, 2892], [2894, 2894, 2955, 2955, 3243], [3245, 3245, 3286, 3286, 3929], [3931, 3931, 3966, 3966, 4826], [4828, 4828, 4890, 4890, 5149], [5151, 5151, 5184, 5184, 5241], [5243, 5243, 5279, 5279, 6520], [6522, 6522, 6561, 6561, 7607]], "test": "untested"}
{"id": "NlfBRS", "name": "XY Oscilloscope Music Framework", "author": "shyshokayu", "description": "This is just one really fast point of light moving around.\nE to toggle waveform\nQ to toggle point cache texture (blue is free memory, if there is no free left then you might see artifacting in the oscilloscope, overrides waveform view)", "tags": ["oscilloscope", "framework", "music", "xy"], "likes": 24, "viewed": 513, "published": 3, "date": "1651004816", "time_retrieved": "2024-07-30T16:51:17.765699", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n/*\n    ---| Go to Common tab to play with sound |---\n*/\n\n#define VISUAL_LINE_COLOR vec3(0.45, 1.0, 0.4)\n#define VISUAL_LINE_BLUR 2.0\n#define VISUAL_LINE_BRIGHTNESS 1000.0\n\nfloat sliderPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 ab = b - a;\n    return dot(p - a, ab) / dot(ab, ab);\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in float d) {\n    return mix(a, b, saturate(d));\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    return closestPointLine(a, b, sliderPointLine(a, b, p));\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p, in float k) {\n    vec2 d = p - closestPointLine(a, b, k);\n    return dot(d, d);\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 d = p - closestPointLine(a, b, p);\n    return dot(d, d);\n}\n\nfloat distToLine(in vec2 a, in vec2 b, in vec2 p) {\n    return sqrt(distToLineSqr(a, b, p));\n}\n\nvec2 pointTex(in float t) {\n    // Estimate location based on texture coordinate\n    t *= float(VISUAL_ITERATIONS);\n    \n    // Convert to int for texelFetch and for more reliable arithmetic\n    int i = int(t);\n    int j = i + 1;\n    \n    // Interpolation between two sampled points\n    ivec2 ip1 = ivec2(i % int(iChannelResolution[0].x), i / int(iChannelResolution[0].x));\n    ivec2 ip2 = ivec2(j % int(iChannelResolution[0].x), j / int(iChannelResolution[0].x));\n    vec2 p1 = texelFetch(iChannel0, ip1, 0).xy;\n    vec2 p2 = texelFetch(iChannel0, ip2, 0).xy;\n    \n    vec2 p = mix(p1, p2, fract(t));\n\n    return p;\n}\n\nvec2 pointTexi(in int i) {\n    int r = int(iChannelResolution[0].x);\n    return texelFetch(iChannel0, ivec2(i % r, i / r), 0).xy;\n}\n\nfloat imageVectorScopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    float d = 0.01 + distanceSqr(a - b); // Emit less light if line is longer\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return min((0.00000004 / ((ld + (VISUAL_LINE_BLUR * 0.00001)) * d)), 0.2) * VISUAL_LINE_BRIGHTNESS;\n}\n\nfloat imageVectorScopeLines(in vec2 uv) {\n    float v = 0.0; // Total value\n    float lv = 0.0; // Last value\n    float cv = 0.0; // Current value\n    \n    vec2 cp;\n    vec2 lp = pointTexi(0);\n    \n    float fv = 1.0 / float(VISUAL_ITERATIONS);\n    float k;\n    \n    for(int i = 1; i < VISUAL_ITERATIONS; i++) {\n        cp = pointTexi(i); // Get the point\n        k = float(i) * fv;\n        cv = imageVectorScopeLine(lp, cp, uv) * (1.0 - k); // Set current value and multiply by time\n        v += max(lv, cv); // Eliminate circles between the lines\n        lv = cv; // Set last value to current value\n        lp = cp; // Set last point to current point\n    }\n    \n    return v * fv;\n}\n\nvec3 imageVectorScope(in vec2 uv) {\n    vec3 col = vec3(0.0);\n\n    // Lines\n    float v = imageVectorScopeLines(uv);\n    vec3 emitCol = pow(v * 0.5, 0.5) * VISUAL_LINE_COLOR;\n\n    // Grid\n    vec3 surfaceCol = vec3(1.0);\n    float gridV =  0.25 * (max(max(step(fract(uv.x * 4.0), 0.01), step(1.0 - 0.01, fract(uv.x * 4.0))), max(step(fract(uv.y * 4.0), 0.01), step(1.0 - 0.01, fract(uv.y * 4.0)))));\n    surfaceCol = mix(surfaceCol, vec3(2.0), gridV);\n\n    // Ambient light                                                           Inner display tube light absorption?\n    vec3 lightCol = vec3(0.045) * max(0.0, dot(uv + 0.5, vec2(0.12, 0.15) * 4.0)) * linearstep(-0.5, 3.0, length(uv));\n\n    // Color compositing\n    col = surfaceCol * lightCol;\n    col += emitCol * (1.0 - gridV);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n\n    return col;\n}\n\nfloat imageOscilloscopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    const float ta = 0.0;\n    const float tb = 0.004;\n    const float dta = ta * ta;\n    const float dtb = tb * tb;\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return linearstep(dtb, dta, ld);\n}\n\nvec3 oscilloscopePoint(float x) {\n    return vec3(x, pointTex(1.0 - ((x * 0.5) + 0.5)));\n}\n\nvec3 imageOscilloscope(in vec2 uv) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    \n    float scale = 2.0;\n    un *= scale;\n    \n    const float segments = 250.0;\n    const float thickness = 1.0 / segments;\n    const float gridThickness = 0.001;\n    const float gridInterval = 2.0;\n    float ip = round(uv.x * segments);\n    float unit = 1.0 / segments;\n\n    vec3 p0 = oscilloscopePoint((ip - 2.0) * unit),\n         p1 = oscilloscopePoint((ip - 1.0) * unit),\n         p2 = oscilloscopePoint((ip) * unit),\n         p3 = oscilloscopePoint((ip + 1.0) * unit),\n         p4 = oscilloscopePoint((ip + 2.0) * unit);\n\n    float dist1 = min(min(distToLine(p0.xy, p1.xy, uv), distToLine(p1.xy, p2.xy, uv)),\n                      min(distToLine(p2.xy, p3.xy, uv), distToLine(p3.xy, p4.xy, uv))) - thickness;\n    \n    float dist2 = min(min(distToLine(p0.xz, p1.xz, uv), distToLine(p1.xz, p2.xz, uv)),\n                      min(distToLine(p2.xz, p3.xz, uv), distToLine(p3.xz, p4.xz, uv))) - thickness;\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(0.8, 0.2, 0.2) * smoothstep(un, -un, dist1);\n    col += vec3(0.2, 0.2, 0.8) * smoothstep(un, -un, dist2);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    vec2 uv = (u - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    uv *= 2.0;\n    \n    vec3 col = mix(\n        mix(\n            imageVectorScope(uv),\n            imageOscilloscope(uv),\n            texelFetch(iChannel3, ivec2(69, 2), 0).x // nice\n        ),\n        ((texture(iChannel0, (u / iResolution.xy)).xyz * 0.5) + 0.5), // Show cached points visually\n        texelFetch(iChannel3, ivec2(81, 2), 0).x\n    );\n\n    col = pow(col, vec3(1.0 / 1.3));\n\n    // Full depth dithering, a way to make your images less bandy in low color ranges.\n    // Since we're using floats here, we can use that as an opportunity to dither that to the common color format, 32bit rgba.\n    float depth = 256.0;\n    vec3 cd = col * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    vec3 ditheredCol = (step(texture(iChannel2, u * 0.125).x + 0.00001, df) + di) / depth;\n    \n    o = vec4(ditheredCol, 1.0);\n\n    // Just uncomment this line and see how much of a difference this dithering makes in the dark areas.\n    //o = vec4(col, 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n#define VISUAL_ITERATIONS 300 // Number of iterations to draw the whole line for the current frame\n#define VISUAL_DURATION 0.02 // How long the line should last for a frame\n\n// Mathematical functions\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\n#define map(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(map(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define distanceSqr(v) dot(v, v)\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\n#define rote(r) rot(r * PI)\n\nfloat easeIn(float x) {\n    return x * x;\n}\n\nfloat easeOut(float x) {\n    return 1.0 - easeIn(1.0 - x);\n}\n\nfloat easeInOut(float x) {\n    return mix(easeIn(x), easeOut(x), x);\n}\n\nfloat easeIn(float a, float b, float x) {\n    return easeIn(linearstep(a, b, x));\n}\n\nfloat easeOut(float a, float b, float x) {\n    return easeOut(linearstep(a, b, x));\n}\n\nfloat easeInOut(float a, float b, float x) {\n    return easeInOut(linearstep(a, b, x));\n}\n\nfloat randomnoise11(float p) {\n    return fract(sin(p * 12.9898) * 43758.5453123);\n}\n\nvec2 randomnoise12(float p) {\n    float x = randomnoise11(p);\n    return vec2(x, randomnoise11(p + x));\n}\n\n// Musical functions\n#define pitch(x) (pow(1.059460646483, x) * 440.0)\n\n#define sine(x) sin((x) * PI)\n#define cosine(x) cos((x) * PI)\n#define square(x) ((fract((x) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define cosquare(x) ((fract(((x) + 0.5) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define saw(x) ((fract((x) * 0.5) * 2.0) - 1.0)\n#define cosaw(x) ((fract(((x) + 0.5) * 0.5) * 2.0) - 1.0)\n#define cotriangle(x) (-(abs(fract((x) * 0.5) - 0.5) * 4.0) + 1.0)\n#define triangle(x) cotriangle((x) + 0.5)\n\n// Some musical functions made specifically for this preview\nvec3 hihats(float t) {\n    vec3 p = vec3(0.0);\n\n    p.xy = ((randomnoise12(t) * 2.0) - 1.0) * 0.5 * fract(-t + 0.25);\n    \n    p.xy *= step(fract(t * 2.0), 0.125) * step(fract(t * 0.5), 0.85);\n    \n    return p;\n}\n\nvec3 kick(float t) {\n    float tf = (t * 300.0) - (20.0 * (fract(-t * 0.5) * easeOut(0.0, 0.1, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p *= 3.0 * fract(-t * 3.0);\n    p *= smoothstep(0.0625, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 kicks(float t) {\n    vec3 p;\n    \n    float t2 = fract(t * 0.125) * 8.0;\n    \n    p += kick(t2);\n    p += kick(t2 - 0.5);\n    p += kick(t2 - 1.75);\n    p += kick(t2 - 2.5);\n    \n    p += kick(t2 - 4.0);\n    p += kick(t2 - 4.5);\n    p += kick(t2 - 5.75);\n    p += kick(t2 - 6.5);\n    p += kick(t2 - 7.5);\n    \n    return p;\n}\n\nvec3 snare(float t) {\n    float tf = (t * 400.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy += ((randomnoise12(t) * 2.0) - 1.0) * 2.0 * fract(t * 3.0);\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.0625 * 4.0, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snare2(float t) {\n    float tf = (t * 1200.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy += ((randomnoise12(t) * 2.0) - 1.0) * 2.0 * fract(t * 3.0);\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.0625 * 3.0 * 0.25, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snares(float t) {\n    vec3 p;\n    \n    float t2 = fract((t * 0.25) + 0.25) * 4.0;\n    \n    p += snare(t2);\n    p += snare(t2 - 2.0);\n    \n    return p;\n}\n\nvec3 drums(float t) {\n    vec3 p;\n    \n    p += kicks(t);\n    p += snares(t);\n    \n    return p;\n}\n\nfloat freqArpeggiator1(float t) {\n    float i = (fract(floor(t * 8.0) * 0.25) * 16.0);\n    i += (fract(floor(t * 1.0) * 0.25) * 12.0);\n    i += 2.0;\n    \n    return pitch(i);\n}\n\n// This is your sandbox:\nvec2 point(float t) {\n    vec3 p = vec3(0.0); // vec3 for 3d visualizations, if you wish.\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    p = vec3(sine(tf), cosine(tf), 0.0);\n    p *= mix(1.0, ((saw((tf + t) * 0.25) * 0.5) + 0.5), easeInOut(fract(-t)));\n    p *= 0.6;\n    \n    p += drums(t);\n    \n    return clamp(p.xy, vec2(-1.0), vec2(1.0));\n}\n", "buffer_a_code": "// Samples coordinates every frame instead of sampling every iteration for every pixel for every frame\nvoid mainImage(out vec4 o, in vec2 u) {\n    // Estimate time based on pixel and calculate point\n    u.y -= 0.5; // For some reason this fixes the error where t > VISUAL_ITERATIONS is wrong\n    float t = u.x + (u.y * iResolution.x);\n    \n    // Skip samples if outside used region\n    if(t > float(VISUAL_ITERATIONS)) { // Not perfect but saves a bit of performance (not sure because of SIMD)\n        o = vec4(0.0, 0.0, 0.5, 1.0);\n        return;\n    }\n    \n    t /= float(VISUAL_ITERATIONS);\n    t *= VISUAL_DURATION;\n    \n    // Output point result\n    o.xy = point((iTime - t) + iTimeDelta);\n    o.zw = vec2(0.0, 1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "vec2 mainSound(int s, float t) {\n    vec2 v = point(t);\n\n    // Some background noise (optional)\n    v += (((texture(iChannel0, vec2(t * 1.4236, t * 1.2267)).xy * 2.0) - 1.0) * 0.0625 * 0.25);\n\n    return v * 0.25; // User convenience, we don't want to destroy any ears\n}\n", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfBRS.jpg", "access": "api", "license": "mit", "functions": [[1446, 1446, 1502, 1502, 1566], [1568, 1568, 1625, 1625, 1662], [1664, 1664, 1720, 1720, 1783], [1785, 1785, 1851, 1851, 1919], [1921, 1921, 1975, 1975, 2043], [2045, 2045, 2096, 2096, 2139], [2141, 2141, 2168, 2221, 2759], [2761, 2761, 2787, 2787, 2892], [2894, 2894, 2955, 2955, 3243], [3245, 3245, 3286, 3286, 3929], [3931, 3931, 3966, 3966, 4826], [4828, 4828, 4890, 4890, 5149], [5151, 5151, 5184, 5184, 5241], [5243, 5243, 5279, 5279, 6520], [6522, 6522, 6561, 6561, 7607]], "test": "untested"}
{"id": "7tXBW7", "name": "RPS Automaton", "author": "Spi3lot", "description": "Rock Paper Scissors Automaton - Watch cells play rock paper scissors against each other", "tags": ["automata", "cellular", "paper", "rock", "moore", "automaton", "scissors", "rps"], "likes": 3, "viewed": 216, "published": 3, "date": "1651004536", "time_retrieved": "2024-07-30T16:51:18.622408", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// [0; 8]\n#define NEIGHBOR_THRESHOLD 3\n\n#define R vec3(0.0, 1.0, 1.0)\n#define P vec3(1.0, 0.0, 1.0)\n#define S vec3(1.0, 1.0, 0.0)\n\n\nvec3 getColorFromNoise(float white)\n{\n    return (white < 0.333) ? R : ((white < 0.666) ? P : S);\n}\n\nvec3 getWinner(ivec2 coord)\n{\n    vec3 me;\n    int r = 0;\n    int p = 0;\n    int s = 0;\n\n    for (int j = -1; j <= 1; j++)\n    {\n        for (int i = -1; i <= 1; i++)\n        {\n            vec3 rps = texelFetch(iChannel0, coord + ivec2(i, j), 0).rgb;\n\n            if (i == j && j == 0)\n                me = rps;\n            else if (rps == R)\n                r++;\n            else if (rps == P)\n                p++;\n            else if (rps == S)\n                s++;\n        }\n    }\n\n    if (me == R)\n        return (p >= NEIGHBOR_THRESHOLD) ? P : R;\n    else if (me == P)\n        return (s >= NEIGHBOR_THRESHOLD) ? S : P;\n    else if (me == S)\n        return (r >= NEIGHBOR_THRESHOLD) ? R : S;\n\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    vec3 col;\n\n    if (iFrame < 100) {\n        vec2 uv = fragCoord / iResolution.xy;\n        float white = texture(iChannel1, uv).r;\n        \n        col = getColorFromNoise(white);\n    }\n    else {\n        col = getWinner(coord);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "slsfW7", "name": "360° panoramic camera tour", "author": "FabriceNeyret2", "description": "cylindrical perspective camera, opening 360°\nmouse.xy: rot\nSPACE : toggles traveling vs circular trajectory.\n", "tags": ["projection", "perspective", "cameras", "cylindrical"], "likes": 16, "viewed": 355, "published": 3, "date": "1651002061", "time_retrieved": "2024-07-30T16:51:19.372403", "image_code": "// variant of https://shadertoy.com/view/ftffWN\n\n#define T(U)          ( V = smoothstep(0.,-.05,abs(fract(U)-.5) -.5 ),    \\\n                        texture(iChannel0, U) * V.x*V.y ) // pattern\n#define rot(a)          mat2(cos( a + vec4(0,11,33,0)))\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0. )\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy, V,\n          U = ( 2.*u - R ) / R.x,                     // normalized screen coordinates\n          M = iMouse.xy/R;\n    float s, a,  W = 1./3.14;                         // 1/W: camera opening\n    vec3  P = vec3(0), T,D;                           // ray direction. flat perspective  = (U,W)\n    a = U.x/W, D.y=U.y, D.xz = W* vec2(sin(a),cos(a));//   cylindrical perspective (panorama)\n    D = normalize(D); \n    if (iMouse.z > 0.)                                // camera control\n      D.yz *= rot( 1.57*(2.*M.y-1.) ),\n      D.xz *= rot( 6.28*(2.*M.x-1.) );\n    T = keyToggle(32) ? 10.*vec3(cos(iTime),0,sin(iTime)) : vec3(0,0,10.*iTime); // motion\n    if  keyToggle(32) D.xz *= rot( -iTime );\n    P += T;\n\n    O-=O;\n    float  t = 10.,c = 1.;    \n    P.y+= 5.;\n    for ( ; c > 0. && t > .01 ; c -= .04 )            // march scene\n        t =  min(s=length(mod(P,10.) -5.)-1.,P.y+5.), // distance to objects\n        P += t*D;                                     // sphere-tracing step\n    if (t==s) { O = vec4(c,0,0,1); return; }          // --- coloring & shading\n    \n    P = D/abs(D.y); P += T/10.; \n    if (P.y<0.) O = T(P.xz+vec2(.5,0)) *vec4(0,1,1,0);// draw floor square grid\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NlsfDM", "name": "nanoKontrol2", "author": "byt3_m3chanic", "description": "nanoKontrol2 - Created originally for use with KodeLife (and a real nanoKontrol2 using a midi texture). Just was playing around and hooked up the midi to (mic/soundcloud/audio) for automated fun!\nhttps://twitter.com/byt3m3chanic/status/1518968742314754049", "tags": ["nanokontrol2"], "likes": 30, "viewed": 702, "published": 3, "date": "1650998557", "time_retrieved": "2024-07-30T16:51:20.325853", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    NanoKontrol2 Korg Midi interface\n    04/26/22 | byt3_m3chanic\n\n    Use sound or mic in iChannel0\n    \n    \n    Made mostly just cause I had a day to play, but also a pretty \n    good demo of how to access the midi texture in KodeLife\n    (though here on Shadertoy I'm just pumping the sound to controll)\n    \n    https://twitter.com/byt3m3chanic/status/1518968742314754049\n\n    to use in KodeLife - replace the sampleFreq calls with midiCoord \n\n    ivec2 midiCoord(int offset){\n        int x = offset % 32;\n        int y = offset / 32;\n        return ivec2(x,y);\n    }\n    \n    float md1 = texelFetch(midi1, midiCoord(3 * 127 + i), 0).x;\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\n// button color\nconst vec3 lcolor = vec3(0.949,0.008,0.290);\n// power color\nconst vec3 tcolor = vec3(0.855,0.969,0.812);\n\nmat2 rot(float g) {return mat2(cos(g), sin(g),-sin(g), cos(g));}\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\nfloat sampleFreq(float freq) {\n    return texture(iChannel0, vec2(freq, 0.1)).x;\n}\n\nfloat box(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat px = 0.;\n\nvoid nanoBody(inout vec3 C, vec2 p) {\n    vec2 uv=p-vec2(0);\n    \n    //body\n    float d = box(uv,vec2(.725,.2))-.015;\n    d=smoothstep(px,-px,d);\n    \n    //inset\n    float i = box(uv,vec2(.715,.1875))-.015;\n    i=smoothstep(px,-px,i);\n    \n    //shadow\n    float sd = box(uv+vec2(0,.01),vec2(.71,.19));\n    sd=smoothstep(.045-px,-px,abs(sd)-.01);\n    float hs = hash21(uv*sin(uv.x));\n    \n    C= mix(C,vec3(.0),sd);\n    C= mix(C,vec3(.015)-(hs*.01),d);\n    C= mix(C,vec3(.035)-(hs*.01),clamp(min(uv.y+.45,i),0.,1.));\n    \n    // button fame boxes\n    float r = box(uv+vec2(.55,.15),vec2(.13,.0275));\n    r=smoothstep(px,-px,abs(r)-.00075);\n    C= mix(C,vec3(.1),r);\n    \n    r = box(uv+vec2(.55,.05),vec2(.13,.021));\n    r=smoothstep(px,-px,abs(r)-.00075);\n    C= mix(C,vec3(.1),r);\n    \n    // power light\n    float l = box(uv+vec2(.7,-.175),vec2(.0125,.002))-.0025;\n    float sl=smoothstep(.02-px,-px,l);\n    l=smoothstep(px,-px,l);\n    C= mix(C,tcolor*.2,sl);\n    C= mix(C,tcolor,l);\n}\n\nvoid knob(inout vec3 C, vec2 p, float level) {\n    vec2 uv = p-vec2(0);\n    //base\n    uv*=rot(level*PI2);\n    float k = length(uv)-.037;\n    float dk = length(uv)-.027;\n    dk=smoothstep(px,-px,abs(dk)-.005);\n    k=smoothstep(px,-px,k);\n\n    C= mix(C,vec3(.001),k);\n    C= mix(C,uv.x>0.?vec3(.16):vec3(.05),dk);\n    \n    //line\n    float l = box(uv-vec2(0,.01),vec2(.0015,.01));\n    l=smoothstep(px,-px,l);\n    \n    C= mix(C,vec3(.6),l);\n}\n\nvoid slider(inout vec3 C, vec2 p, float level) {\n    vec2 uv=p-vec2(0);\n    \n    //background\n    float d = box(uv,vec2(.015,.125))-.015;\n    d=smoothstep(px,-px,d);\n    C= mix(C,uv.x<0.?vec3(.1):vec3(.15),d);\n    \n    //lines\n    float l = box(uv,vec2(.015,.0001));\n    l = min(box(vec2(uv.x,abs(abs(uv.y)-.075)-.025),vec2(.015,.0001)),l);\n    l=smoothstep(px,-px,l);\n    C= mix(C,uv.x>0.?vec3(.00):vec3(.5),l);\n    \n    //slider\n    level = (level*.75)-.15;\n    float b = box(uv-vec2(0,level),vec2(.0125,.0175))-.0075;\n    b=smoothstep(px,-px,b);\n    \n    C= mix(C,vec3(.01),b);\n}\n\nvoid button(inout vec3 C, vec2 p, float state, int type) {\n    vec2 uv = p-vec2(0);\n    //base\n    float b = box(uv,vec2(.0125,type==2?.005:.0125))-.005;\n    float sl=smoothstep(.02-px,-px,b);\n    b=smoothstep(px,-px,b);\n    \n    if(state>.001) C= mix(C,lcolor*.2,sl);\n    C= mix(C,state>.001?lcolor:vec3(.05),b);\n}\n\nvoid backdrop( inout vec3 C, vec2 p) {\n    vec2 uv = p-vec2(0);\n    uv*=rot(.78);\n    float d = box(uv,vec2(5.,.4));\n    float dcut=d;\n    float sd=smoothstep(.03-px,-px,d);\n    d=smoothstep(px,-px,d);\n    C=mix(C,vec3(.0001),sd);\n    C=mix(C,vec3(.001),d);\n    C=mix(C,vec3(0.384,0.510,0.227),clamp(min((p.y+.015)*2.865,d),0.,1.));\n\n    \n    float i = .03;\n    vec2 nv=p-vec2(1.-T*.1,-.02);\n    vec2 f = fract(nv*40.)-.5;\n    vec2 fid = floor(nv*40.)+.5;\n    fid.x=mod(fid.x,30.);\n    float ht = sampleFreq(fid.x*.015)*.85; \n    \n    float bd = box(f,vec2(.4))-.01;\n    bd=max(bd,dcut);\n    bd=smoothstep(px,-px,bd);\n\n    float bx = box(f,vec2(.3))-.01;\n    bx=abs(bx)-.12;\n    bx=max(bx,dcut);\n    bx=smoothstep(px,-px,bx);\n    \n    //draw dots\n    if(fid.x<40.&& fid.y>0.) {\n        float avg = (fid.y*.095)-.5; \n        if(ht>avg) C=mix(C,vec3(.0001),bx);\n        if ( ht>avg&&ht<avg+.1) C=mix(C,vec3(.0001),bd);\n    }\n  \n      \n    uv.y=abs(uv.y-.38)-.02;\n    float nd = box(uv,vec2(5.,.0075));\n    nd=smoothstep(px,-px,nd);\n    C=mix(C,tcolor,nd);\n\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    float hs = hash21(uv*sin(uv.x));\n    vec3 C = vec3(.3-(hs*.05));\n\n    px=2./R.x;\n\n    backdrop(C, uv);\n    \n    // uncomment for fun\n    //uv.x+=T*.3;\n    //uv.x=mod(uv.x+1.,2.)-1.;\n    \n    nanoBody(C, uv+vec2(0,.25));\n    // to use midi texture you loop over\n    // the control values based on a 32x32\n    // texture\n    // https://hexler.net/kodelife/manual/parameters-built-in\n\n    // sliders\n    for(int i = 0; i<8;i++) {\n        //float md1 = (texelFetch(midi1, midiCoord(3 * 127 + i), 0).x);\n        float md1 = sampleFreq(float(i)*.042)*.35; \n        vec2 p = vec2(.25,.29)-vec2(float(i)*.13,0);\n        \n        slider(C, uv+p, md1);\n    }    \n\n    // knobs\n    int tk = 0;\n    for(int i = 16; i<24;i++) {\n    //\n        float md1 = sampleFreq(float(i)*.051)*.5; \n        vec2 p = vec2(.25,.0925)-vec2(float(tk)*.13,0);\n        knob(C,uv+p,md1);\n        \n        tk++;\n    }\n    \n    // solo buttons\n    tk = 0;\n    for(int i = 32; i<40;i++) {\n        float md1 = sampleFreq(float(tk)*.02)*.45; \n        if(md1<.2) md1 = 0.;\n        vec2 p = vec2(.3125,.2)-vec2(float(tk)*.13,0);\n        button(C,uv+p, md1, 0);\n        tk++;\n    }  \n\n    // mute buttons\n    tk = 0;\n    for(int i = 48; i<56;i++) {\n        float md1 = sampleFreq(float(tk)*.1)*.45; \n        if(md1<.1) md1 = 0.;\n        vec2 p = vec2(.3125,.25)-vec2(float(tk)*.13,0);\n        button(C,uv+p, md1, 0);\n        tk++;\n    }  \n\n    // record buttons\n    tk = 0;\n    for(int i = 64; i<72;i++) {\n        float md1 = sampleFreq(float(i-35)*.1)*.45; \n        if(md1<.1) md1 = 0.;\n        vec2 p = vec2(.3125,.3)-vec2(float(tk)*.13,0);\n        button(C,uv+p, md1, 0);\n        tk++;\n    }  \n    \n    // track buttons\n    for(int i = 41; i<46;i++) {\n        float md1 = sampleFreq(float(i-41)*.1)*.45; \n        if(md1<.25)md1 = 0.;\n        // track button midi jumps all over? why Korg?\n        // fixing my brute force\n        float fk = 0.;\n        if(i==41){\n        fk=10.;\n        }else if(i==42){\n        fk=9.;\n        }else if(i==43){\n        fk=7.;\n        }else if(i==44){\n        fk=8.;\n        }else{\n        fk=11.;\n        }\n\n        vec2 p = vec2(1.,.4)-vec2(float(fk)*.05,0);\n        button(C,uv+p, md1, 0);\n        tk++;\n    }\n    \n    // cycle button\n    tk = 0;\n    float md1 = sampleFreq(float(.23434)*.1)*.45; \n    if(md1<.2) md1 = 0.;\n    button(C,uv+vec2(.65,.30), md1, 2);\n    \n    // marker buttons\n        for(int i = 60; i<63;i++) {\n        float md1 = sampleFreq(float(i-35)*.1)*.45; \n        if(md1<.1) md1 = 0.;\n        vec2 p = vec2(.55,.30)-vec2(float(tk)*.05,0);\n        button(C,uv+p, md1, 2);\n        tk++;\n    }  \n    \n    // track buttons\n        for(int i = 58; i<60;i++) {\n        float md1 = sampleFreq(float(i-57)*.078)*.45; \n        if(md1<.25) md1 = 0.;\n        vec2 p = vec2(.8,.25)-vec2(float(tk)*.05,0);\n        button(C,uv+p, md1, 2);\n        tk++;\n    }  \n\n    if(hs<.65) C = clamp(C+(hs*.005),C,vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "image_inputs": [{"id": 28893, "src": "https://soundcloud.com/boris-brejcha/schaltzentrale-boris-brejcha-joker-remake-free", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsfDM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[974, 974, 993, 993, 1038], [1039, 1039, 1063, 1063, 1118], [1120, 1120, 1150, 1150, 1202], [1204, 1204, 1236, 1236, 1316], [1334, 1334, 1371, 1371, 2324], [2326, 2326, 2372, 2372, 2766], [2768, 2768, 2816, 2816, 3350], [3352, 3352, 3410, 3410, 3667], [3669, 3669, 3707, 3707, 4725], [4727, 4727, 4768, 4768, 7786]], "test": "untested"}
{"id": "7lsBDM", "name": "Poisson distribution", "author": "FabriceNeyret2", "description": "1: Poisson random distribution.    mouse.y = lambda = average ( and variance )\n2: normalized by lambda\n3: ( p - average ) / stddev ( i.e. show fluctuations )\n4: uniform ( approx of white noise )", "tags": ["random", "poisson", "statistics", "probabilities"], "likes": 6, "viewed": 500, "published": 3, "date": "1650995789", "time_retrieved": "2024-07-30T16:51:21.165608", "image_code": "// https://en.wikipedia.org/wiki/Poisson_distribution\n//#define hash2(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 4375.85453) // float hash\n//#define hash2(p)  hash(vec3(p,0)).x                                      // integer hash\n  #define hash2(p)  ( U.y/R.y < .5 ?  fract(sin(dot(p, vec2(12.9898, 78.233))) * 4375.85453) : hash(vec3(p,0)).x ) // bottom/top \n\n//#define hash1(f)  hash2(vec2(f,1))                         // float hash\n//#define hash1(f)  hash(vec3(f)).x                          // integer hash\n  #define hash1(f)  ( U.y/R.y < .5 ? hash2(vec2(f,1)) : hash(vec3(f)).x ) // bottom/top\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    float lambda = iMouse.z>0. ? exp2(5.*iMouse.y/R.y) : 3., // average ( and variance )\n            seed = hash2(U),\n          x = 0., p = exp(-lambda), s = p,S;\n    while( ( seed = hash1(seed) ) > s )\n        s += p *= lambda/ ++x;\n    \n    s = 4.*U.x/R.x; \n    x =   s<1. ? x/10.                             // Poisson distrib with 3 different normalizations\n        : s<2. ? .5*x/lambda\n        : s<3. ? .5+.5*(x-lambda)/sqrt(lambda)\n        :        hash1(seed);                      // Uniform\n    O = vec4( sqrt(x) );                           // to sRGB\n}", "image_inputs": [], "common_code": "const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 uhash3( uvec3 x )         // iq version\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)/float(0xffffffffU);\n}\n\nvec3 hash( vec3 f )            // vec3 to vec3. any scaling. f.z=0 seed is ok.\n{ \n    return uhash3( uvec3( floatBitsToUint(f.x),\n                          floatBitsToUint(f.y),\n                          floatBitsToUint(f.z) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[606, 606, 644, 644, 1237]], "test": "untested"}
{"id": "7tsfWM", "name": "Procedural sky", "author": "rabbitator", "description": "procedural sky with clouds and sun", "tags": ["procedural", "sun", "clouds", "sky"], "likes": 6, "viewed": 788, "published": 3, "date": "1650991361", "time_retrieved": "2024-07-30T16:51:21.968462", "image_code": "#define st smoothstep\n\nfloat noise(vec2 p) {\n  return fract(sin(p.x * 83.876 + p.y * 76.123) * 3853.875);\n}\n\nfloat perlin(vec2 uv, float iters) {\n  float c = 1.0;\n  for (float i = 0.0; i < iters; i++) {\n    float p = pow(2.0, i + 1.0);\n    vec2 luv = uv * vec2(p) + iTime * 0.2;\n    vec2 gv = st(0.0, 1.0, fract(luv));\n    vec2 id = floor(luv);\n    float lb = noise(id + vec2(0.0, 0.0));\n    float rb = noise(id + vec2(1.0, 0.0));\n    float lt = noise(id + vec2(0.0, 1.0));\n    float rt = noise(id + vec2(1.0, 1.0));\n    float b = mix(lb, rb, gv.x);\n    float t = mix(lt, rt, gv.x);\n    c += 1.0 / p * mix(b, t, gv.y);\n  }\n  return c / 2.0;\n}\n\nfloat dst_sun(vec2 uv) {\n  return st(0.42, 0.35, sqrt(length(uv - vec2(33.8, 34.7))));\n}\n\nfloat dst_cldsun(vec2 uv) {\n  return 0.8 * st(0.6, 0.2, sqrt(length(uv - vec2(33.8, 34.7))));\n}\n\nfloat dst_galo(vec2 uv) {\n  return st(1.0, 0.1, pow(length(uv - vec2(33.8, 34.7)), 0.4));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  uv *= 5.0;\n  uv += 33.0;\n\n  vec3 sky = vec3(0.3, 0.5, 0.8);\n  vec3 cloud = 0.85 * vec3(1.0, 1.0, 1.0);\n  vec3 galo = vec3(1.0, 0.9, 0.8);\n  vec3 sun = vec3(1.0, 1.0, 0.98);\n  vec3 cld_sun = 1.3 * vec3(1.0, 1.0, 0.75);\n\n  float j = sin(2.0) * 0.1 + 0.7;\n  float dst_cloud = st(j, j + 0.1, perlin(uv, 8.0));\n  float dst_sun = dst_sun(uv);\n\n  vec3 color = mix(sky, galo, dst_galo(uv));\n  color = mix(color, sun, dst_sun);\n  color = mix(color, cloud, dst_cloud);\n  color = mix(color, mix(color, cld_sun, dst_cldsun(uv)), dst_cloud);\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 107], [109, 109, 145, 145, 642], [644, 644, 668, 668, 732], [734, 734, 761, 761, 829], [831, 831, 856, 856, 922], [924, 924, 979, 979, 1614]], "test": "untested"}
{"id": "flsBD7", "name": "visual shepard tone", "author": "mmalex", "description": "sorry for the misspelling and thanks @fabriceneyret2 for the correction! shepard, not shepherd: https://en.wikipedia.org/wiki/Shepard_tone", "tags": ["tone", "shepard", "shepherd"], "likes": 18, "viewed": 1118, "published": 3, "date": "1650985846", "time_retrieved": "2024-07-30T16:51:22.814200", "image_code": "void mainImage( out vec4 f, in vec2 c ){ vec2 uv = c/iResolution.xy;float\nt=fract(iTime),col=0.;for (float oct=0.;oct<4.;++oct) col+=((oct==0.)?t:(\noct==3.)?1.-t:1.)*texture(iChannel0,(uv.xy-0.5)*exp2(t+oct)+(floor(iTime)\n-oct+4.)*vec2(23.4353,75.3456)).x;f=vec4(vec3(sqrt(col*0.25)),1.);}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 289]], "test": "untested"}
{"id": "NllfDM", "name": "Pixel Lines V3", "author": "SnoopethDuckDuck", "description": "Just playing around with forked shader", "tags": ["copy", "thing"], "likes": 11, "viewed": 293, "published": 3, "date": "1650983262", "time_retrieved": "2024-07-30T16:51:23.737732", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale factor to enlarge image by\n    float sf = dim.y / (iResolution.y - 81.);\n\n    // Scale and centre image to screen\n    vec2 coord = ceil(sf * fragCoord) ;\n    coord -= ceil(sf * 0.5 * iResolution.xy - 0.5 * dim);\n\n    vec3 col = texelFetch(iChannel0, ivec2(coord), 0).rgb;\n    \n    float m = mlength(coord - 0.5 * dim + 0.5);\n    col += step(abs(m- 0.5 * dim.x - 0.5), 0.);   \n        \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float line(vec2 f, float t, float o) {\n    float a = 0.25 + 0.25 * cos(-7.5 * t + o);\n    float y = a * dim.y * sin(t + o) + (1.-a) * f.x * cos(t + o);\n    //y = 0.45 * dim.y * cos(10000. * pow((f.y - f.x)/dim.x, 3.)+ t + o);\n    y *= 0.5 + 0.5 * cos(7.5 * f.x/dim.x - 3.75 * t + o + 0. * pi/30. * h21(f));\n    return step(f.y, y);\n}\n\n// a bit sloppy\nvec3 lineCol(float x) {\n    float o = 2. * pi / 3.;\n    return 0.5 + 0.5 * thc(4., vec3(x-o,x,x+o));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center fragCoord\n    fragCoord -= 0.5 * dim;\n\n    vec3 col;\n    \n    float n = 15.;\n    for (float i = 0.; i < n; i++) {\n        // Lower framerate + offset time for each line\n        float time = 0.25 * floor(15. * iTime) / 15.;\n        float o = 2. * pi * i / n;\n        \n        // Center line (draw everything under the line)\n        float c = line(fragCoord, time, o); \n        \n        // Shift line up/down/left/right\n        float t = line(fragCoord - vec2(0,1), time, o);\n        float b = line(fragCoord + vec2(0,1), time, o);\n        float l = line(fragCoord - vec2(1,0), time, o);\n        float r = line(fragCoord + vec2(1,0), time, o);\n        \n        // Only draw cells which have 0 and 1 cell neighbours\n        float mx = max(max(t,b), max(l,r));\n        float mn = min(min(t,b), min(l,r));\n         \n        // Only draw new line if a line hasn't been drawn already on this pixel\n        if (col == vec3(0))\n            col = c * (mx - mn) * lineCol(2. * pi * i / n + 0.75 * pi);\n    }\n    \n    // Restrict to bounds\n    col *= step(fragCoord.x, 0.5 * dim.x) * step(fragCoord.y, 0.5 * dim.y);\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// dimensions of sprite - has to be less than screen dimensions\nconst vec2 dim = vec2(81);\n\n#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 97, 488]], "test": "untested"}
{"id": "7tlBWN", "name": "Pixel Lines V2", "author": "SnoopethDuckDuck", "description": "Inspired by this post: https://twitter.com/andrevenancio/status/1514417812969865217\n(very cool)", "tags": ["copy", "thing"], "likes": 4, "viewed": 268, "published": 3, "date": "1650979098", "time_retrieved": "2024-07-30T16:51:24.566515", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale factor to enlarge image by\n    float sf = dim.y / (iResolution.y - dim.y);\n\n    // Scale and centre image to screen\n    vec2 coord = ceil(sf * fragCoord) ;\n    coord -= ceil(sf * 0.5 * iResolution.xy - 0.5 * dim);\n\n    vec3 col = texelFetch(iChannel0, ivec2(coord), 0).rgb;\n    \n    // Sloppy way of keeping it square-ish\n    // if (coord.x < - 11. || coord.x >= dim.x + 11.)\n    //     col = vec3(0.825);\n        \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define lineCol(x) ( .5 + .5 * thc(4., x+2. * pi / 3.*vec3(-1,0,1)) )\n\n// y = sin(t) + x * cos(t) line\nfloat line(vec2 f, float t) {\n    float y = mix(f.x * cos(t), dim.y * sin(t), 0.3);   \n    return step(f.y, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center fragCoord\n    fragCoord -= 0.5 * dim;\n\n    vec3 col = vec3(0);\n    \n    float n = 15.;\n    for (float i = 0.; i < n; i++) {\n        // Lower framerate + offset time for each line\n        float time = floor(30. * iTime) / 30. + pi * i / n;\n        \n        // Center line (draw everything under the line)\n        float c = line(fragCoord, time); \n        \n        // Shift line up/down/left/right\n        float t = line(fragCoord - vec2(0,1), time);\n        float b = line(fragCoord + vec2(0,1), time);\n        float l = line(fragCoord - vec2(1,0), time);\n        float r = line(fragCoord + vec2(1,0), time);\n        \n        // Only draw cells which have 0 and 1 cell neighbours\n        float mx = max(max(t,b), max(l,r));\n        float mn = min(min(t,b), min(l,r));\n         \n        // Only draw new line if a line hasn't been drawn already on this pixel\n        if (col == vec3(0))\n            col = c * (mx - mn) * lineCol(2. * pi * i / n + 0.75 * pi);\n        else\n            break;\n    }\n    \n    // Restrict to bounds\n    col *= step(fragCoord.x, 0.5 * dim.x) * step(fragCoord.y, 0.5 * dim.y);\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [], "common_code": "// dimensions of sprite - has to be less than screen dimensions\nconst vec2 dim = vec2(81);", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 97, 518]], "test": "untested"}
{"id": "slffD7", "name": "Basics_2", "author": "Ron1Adi", "description": "Basic", "tags": ["basic"], "likes": 1, "viewed": 150, "published": 3, "date": "1650976331", "time_retrieved": "2024-07-30T16:51:25.487054", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    float mask  = Circle(uv, vec2(0), .4, .05);\n          mask -= Circle(uv, vec2(-.13, .2), .07, .01);\n          mask -= Circle(uv, vec2(.13, .2), .07, .01);\n    float mount = Circle(uv, vec2(0.,0.), .3, .02);\n          mount -= Circle(uv, vec2(0.,0.1), .3, .02);\n    //col = vec3(mount);\n    mask -= mount;\n    col = vec3(1., 1., 0.)*mask;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slffD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 141], [143, 143, 200, 250, 777]], "test": "untested"}
{"id": "slfBDM", "name": "raymarching funny balls 2000", "author": "Heksi", "description": "yep", "tags": ["raymarching"], "likes": 0, "viewed": 200, "published": 3, "date": "1650968059", "time_retrieved": "2024-07-30T16:51:26.626009", "image_code": "precision highp float;\n\n#define PI 3.14159265359\n#define minDist 0.00001\n#define maxMarch 800\n#define maxDist 50.\n\nstruct camera {\n    vec3 origin;\n    vec3 lookVec;\n    vec3 rightVec;\n    vec3 upVec;\n};\n\nstruct rayMarchHit {\n    bool hasHit;\n    int marchCount;\n    vec3 pos;\n    vec3 normal;\n    float distTraveled;\n    float closestDistance;\n};\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat distToSphere(vec3 c, float r, vec3 p) {\n    return length(c - p) - r;\n}\n\nfloat distToSphereMod(vec3 c, float r, vec3 p) {\n    return length(c - p) - r;\n}\n\nfloat distToGround(vec3 p, float h) {\n    //float r = p.y - h\n    //+ noise(p.xz * 19. + iTime) / 80.\n    //+ noise(p.xz * 5. + iTime) / 40.\n    //+ noise(p.xz + iTime) / 4.;\n\n    //float m = length(p.xz);\n    //return r + m*m/10. / (1. + m * 0.05);\n    \n    float r = distToSphere(vec3(0, -20, 0), 20., p) \n    + noise(p.xy * 2. + iTime) / 20.\n    + noise(p.yz * 2. + iTime) / 20.\n    + noise(p.xz * 2. + iTime) / 20.;\n    return r;\n}\n\nfloat sdf(vec3 p) {\n    const int objectCount = 2;\n    float dists[objectCount];\n    float smallestDistance = 1e10;\n    \n    dists[0] = distToSphereMod(\n        vec3(0, 0.5, 0),\n        1., \n        p\n    );\n\n    dists[1] = distToGround(p, -0.4);\n\n    for (int i = 0; i < objectCount; i++) {\n        smallestDistance = min(smallestDistance, dists[i]);\n    }\n\n    return smallestDistance;\n}\n\nvec3 getNormalAt(vec3 p) {\n    float d = sdf(p);\n    vec2 e = vec2(0.01, 0);\n    return normalize(d - vec3(\n        sdf(p-e.xyy),\n        sdf(p-e.yxy),\n        sdf(p-e.yyx)\n    ));\n}\n\nrayMarchHit rayMarch(vec3 origin, vec3 direction) {\n    rayMarchHit hit = rayMarchHit(\n        false,      // hasHit\n        0,          // marchCount\n        origin,     // pos\n        vec3(0),  // normal\n        0.,         // distTraveled\n        0.          // closestDistance \n    );\n\n    for (int i = 0; i < maxMarch; i++) {\n        float distToScene = sdf(hit.pos);\n\n        if (distToScene < hit.closestDistance) {\n            hit.closestDistance = distToScene;\n        }\n\n        hit.marchCount += 1;\n        hit.distTraveled += distToScene;\n        hit.pos = origin + direction * hit.distTraveled;\n        hit.normal = getNormalAt(hit.pos);\n\n        if (distToScene <= minDist) {\n            hit.hasHit = true;\n            break;\n        }\n        \n        if (hit.distTraveled >= maxDist) { break; }\n    }\n\n    return hit;\n}\n\nvec3 getSunCol(vec3 normal, vec3 lightDir) {\n    vec3 sunColor = vec3(0);\n    sunColor += max(smoothstep(0.99, 1., dot(normal, lightDir)) , 0.);  \n    sunColor += max(smoothstep(0.9, 1., dot(normal, lightDir)) , 0.) / 3.;\n    \n    return sunColor;\n}\n\nvec3 getSkyCol(vec3 normal, vec3 lightDir) {\n    // base color\n    vec3 skyCol = mix(\n        vec3(0.2, 0.2, 0.9),\n        vec3(0.4, 0.7, 1),\n        dot(normal, lightDir)\n    );\n    \n    // clouds\n    skyCol = mix(\n        skyCol,\n        mix(skyCol, vec3(1.), noise(normal.xz * 5.) * noise(normal.xz * 1.) * .2),\n        smoothstep(-1., 1., dot(normal, vec3(0, 1, 0)))\n    );\n    \n    return skyCol + getSunCol(normal, lightDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= vec2(1, -1);\n\n    vec2 muv = iMouse.xy / iResolution.xy;\n\n    camera cam = camera(\n        vec3(-cos(muv.x * 10.) * 7., muv.y * 20. - 10., -sin(muv.x * 10.) * 7.),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n\n    cam.lookVec = normalize(vec3(0, 0.5, 0)-cam.origin);\n    cam.rightVec = cross(cam.lookVec, vec3(0, 1, 0));\n    cam.upVec = cross(cam.lookVec, cam.rightVec);\n\n    vec3 lightDir = normalize(vec3(\n        0.5, 2, 1\n    ));\n    \n    vec3 rayDir = normalize(\n        cam.lookVec + \n        cam.rightVec*uv.x + \n        cam.upVec*uv.y\n    );\n    \n    vec3 col = getSkyCol(rayDir, lightDir);\n    \n    rayMarchHit marchHit = rayMarch(cam.origin, rayDir);\n    \n    if (marchHit.hasHit) {\n        vec3 reflected = rayDir - (2. * dot(rayDir, marchHit.normal) * marchHit.normal);\n        \n        col = vec3(0.5,0.5,0.5);\n        \n        // fresnel\n        col = mix(col, getSkyCol(reflected, lightDir), smoothstep(0.5, 1., 1.-dot(marchHit.normal, reflected)));\n        \n        // specular\n        col += getSunCol(reflected, lightDir);\n        \n        // diffuse\n        col *= max(dot(marchHit.normal, lightDir), 0.);\n        \n        // shadow\n        rayMarchHit shadow = rayMarch(marchHit.pos - rayDir/100., lightDir);\n        \n        if (shadow.hasHit) {\n            col *= 0.;\n        }\n        \n        // fog\n        col = mix(col, getSkyCol(rayDir, lightDir), smoothstep(0.6, 1., marchHit.distTraveled / maxDist));\n    }\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 369, 369, 436], [438, 438, 458, 458, 667], [669, 669, 714, 714, 746], [748, 748, 796, 796, 828], [830, 830, 867, 1079, 1265], [1267, 1267, 1286, 1286, 1656], [1658, 1658, 1684, 1684, 1840], [1842, 1842, 1893, 1893, 2677], [2679, 2679, 2723, 2723, 2928], [2930, 2930, 2974, 2992, 3363], [3365, 3365, 3422, 3422, 5021]], "test": "untested"}
{"id": "Wd3yRB", "name": "Penguin Books paperbacks pattern", "author": "tutmann", "description": "Penguin Books paperbacks pattern\nCopied from: https://www.reddit.com/r/generative/comments/izhyms/tile_system_inspired_by_penguin_books_paperbacks/", "tags": ["wip", "pattern"], "likes": 5, "viewed": 235, "published": 3, "date": "1650965662", "time_retrieved": "2024-07-30T16:51:27.498676", "image_code": "const vec3 bg = vec3(1.0, 0.95, 0.88);\nconst vec3 fg = vec3(0.14, 0.14, 0.14);\nconst float lw = 0.05;\nconst float aa = 0.05;\n\nconst uint k = 1103515245U;  // GLIB C\nconst float pi2 = 1.57079632679;\n\nconst float num_tiles = 5.0;\nconst float translation = 0.03;\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 rotate(in vec2 p, in float rot) {\n    return p * mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n}\n\n\n\nvec3 tile_cross(in vec2 pos) {\n    float col = min(abs(pos.x), abs(pos.y));\n \treturn mix(fg, bg, smoothstep(lw, lw+aa, col));    \n}\n\nvec3 tile_qcircle(in vec2 pos) {\n    float r1 = length(pos-vec2(1.));\n    float r2 = length(pos+vec2(1.));\n    float d = min(r1, r2);\n    d = abs(d-1.0);\n \treturn mix(fg, bg, smoothstep(lw, lw+aa, d));    \n}\n\nvec3 tile_qcircle_1full(in vec2 pos) {\n    float r1 = length(pos-vec2(1.));\n    float r2 = length(pos+vec2(1.));\n    float d = min(r1, r2);\n    d = abs(d-1.0);\n    d = min(d, step(1.0,r2));\n    d = smoothstep(lw, lw+aa, d);\n \treturn mix(fg, bg, d);    \n}\n\nvec3 tile(float id, vec2 p) {\n    int tile_type = int(id * 3.0);\n    vec3 col;\n    if (tile_type > 1) {\n        col = tile_qcircle_1full(p);\n    } else if (tile_type > 0) {\n        col = tile_qcircle(p);\n    } else {\n        col = tile_cross(p);\n    }\n    p = abs(p);\n//    col = min(col, smoothstep(1.0,0.99, max(p.x, p.y)));\n    return col;\n}\nconst float n_tiles = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord / min(iResolution.x, iResolution.y) +  vec2(iTime * translation)) * num_tiles;\n    vec2 p = fract(pos) * 2.0 - 1.0;\n\n    vec3 tile_id = hash(uvec3(trunc(pos),0));\n    int tile_type = int(tile_id.x * n_tiles);\n    float rot = float(int(tile_id.y * 4.0)) * pi2;\n    \n    p = rotate(p, rot);\n    \n    vec3 col = tile(tile_id.x, p);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3yRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 283, 283, 416], [418, 418, 456, 456, 517], [521, 521, 551, 551, 652], [654, 654, 686, 686, 861], [863, 863, 901, 901, 1117], [1119, 1119, 1148, 1148, 1463], [1492, 1492, 1549, 1549, 1967]], "test": "untested"}
{"id": "NlXfD7", "name": "Phsicly inspired sky", "author": "El_Sargo", "description": "My attempt at making a semi realistic sky for cheap.", "tags": ["3d", "sky", "atmosphere"], "likes": 2, "viewed": 332, "published": 3, "date": "1650956557", "time_retrieved": "2024-07-30T16:51:28.478057", "image_code": "const float Earth = 63.71;\nconst float AtRad = 64.01;\nconst float directScatterCoef = .055;\nconst float inDirectScatterCoef = .3;\nconst float sunCoef = .1;\nconst vec3 rgbScatter = vec3(1,2,4);\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 getSky(vec3 rd, vec3 pos, vec3 sun){\n//Distances, proportaional to the real world\n    float atDist = sphIntersect(pos, rd, vec3(0), AtRad).y;\n    float snDist = sphIntersect(pos, sun,vec3(0), AtRad).y-1.1;\n    \n    float rds = dot(sun, rd);\n    float ssc = (abs(rds)*0.5+0.5);\n    vec3 tra = normalize(sun-rd);\n    vec2 jab = vec2(\n    max(tra.x, max(tra.y, tra.z)),\n    min(tra.x, max(tra.y, tra.z))\n    );\n    float fla = pow(abs(sin(atan(jab.x,jab.y)*40.)), 100.)*.001;\n\n    vec3 light = vec3(smoothstep(0.999, .9999, rds))*2.;\n         light += atDist * (1.-abs(rd.y)) * ssc*0.2;\n         light += (1.-exp(-rgbScatter*atDist*inDirectScatterCoef*(atDist*5.*.5+.5)));\n         light *= exp(\n             -rgbScatter*\n             (atDist*directScatterCoef+snDist*sunCoef)\n         );\n         \n     return light;\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uc = (uv-0.5)*vec2(1,iResolution.y/iResolution.x);\n    vec3 rd = normalize(\n        vec3(uc, -.7)\n    );\n    rd.yz*=rot(.35);\n    \n    float m = iMouse.y / iResolution.y*5.+1.;\n    float f = iMouse.x / iResolution.x*10.+4.;\n\n    vec3 sun = vec3(0,0,1);\n    sun.yz *= rot(-m+.75);\n    sun.xz *= rot(-f+.75);\n    //sun.xz *=rot(1.5);\n\n\n    vec3 col;\n    vec3 ro = vec3(0,63.71002,0);\n    float EarthD = sphIntersect(ro, rd, vec3(0), Earth).x;\n    if (EarthD > -0.1){\n        vec3 p = ro+rd*EarthD;\n        vec3 nor = normalize(p);\n        vec3 ref = reflect(rd, nor);\n        float f = dot(rd,ref)*.25+.75;\n        col = getSky(ref, p, sun)*f*vec3(0.502,0.549,0.918);\n    } else\n        col = getSky(rd, ro, sun);\n\n    col = pow(col, vec3(2.4));\n    fragColor = vec4(aces_tonemap(col*2.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 261, 261, 479], [481, 481, 522, 567, 1302], [1304, 1304, 1322, 1322, 1395], [1397, 1397, 1427, 1427, 1874], [1876, 1876, 1933, 1933, 2776]], "test": "untested"}
{"id": "flfBDM", "name": "roads-v2", "author": "jorge2017a2", "description": "roads-v2", "tags": ["2d", "3d", "mouse", "roadsv2"], "likes": 6, "viewed": 242, "published": 3, "date": "1650938543", "time_retrieved": "2024-07-30T16:51:29.416548", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//roads-v2 --25-abril-2022\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    vec3 p0=p;\n\tfloat  d0= sdBox(p-vec3(0.0,35.0,0.0), vec3(5.5,12.0,0.5));\n    float  d1a= sdBox(p-vec3(0.0,-8.0,0.0), vec3(50.0,30.0,5.0));\n    float  d1b= sdBox(p-vec3(-10.0,-14.5,0.0), vec3(105.0,35.0,10.0));\n    float  d1c= sdBox(p-vec3(-70.0,20.0,0.0), vec3(50.0,30.0,5.0));\n    float  d1ba= sdBox(p-vec3(-35.0,-11.5,0.0), vec3(25.0,30.0,15.0));\n    float  d2=sdCylinderXZ(p-vec3(-35.0,-7.0,0.0), vec2(20.0,30.) );\n    float  d3=sdCylinderXZ(p-vec3(-35.0,25.0,0.0), vec2(9.0,25.) );\n    res =opU2(res, vec2(d0,101.0));\n    res =opU2(res, vec2(d1a,100.0));\n    res =opU2(res, vec2(d1b,100.0)); //bloque medio 2 pasos\n    res =opU2(res, vec2(d1ba,100.0)); //bloque medio 2 pasos\n    res =opU2(res, vec2(d1c,100.0));  //superior 2do bloque\n    res =opU2(res, vec2(d2,100.0));  //cilindro grande\n    res =opU2(res, vec2(d3,100.0)); //cilindro chico    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < int(100.0*0.8); i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\t\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color==100 ) { return  getColorTextura( p, nor,id_color); }\n   if (id_color==101 )\n   {   p=vec3(-p.x, p.y, p.z);\n       vec3 pnew=p-vec3(-10.0,20.0,0.0);\n       pnew*=1.2;\n       return  getColorTextura( pnew, nor,id_color); \n   }   \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float  t=iTime*10.0;\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(20.0-t,60.0,-25.0);\n   ro.x= opRep1D(ro.x, 50.0 );\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(50.0));\n   rd= rotate_y(rd, radians(-45.0));\n   rd= rotate_z(rd, radians(10.0));\n   \n   \n   //Camera with mouse control:\n   if( iMouse.z > 0.0)\n   //rd= rotate_y(rd, iMouse.x/iResolution.x*6.28+radians(360.*cos(iTime*1.0*+sin(iTime*1.0))));  //radians(360.*cos(iTime*vel*+sin(iTime*vel))));\n   rd= rotate_y(rd, iMouse.x/iResolution.x+0.5*cos(iTime*0.25));\n\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "buffer_a_code": "//por jorge2017a2....walk 2d-n3\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//oneshade\nvec2 RotatePOA(in vec2 p, in vec2 o, in float a) {\n    float c = cos(a), s = sin(a);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nvec2 cossin(float x)\n{\treturn vec2(cos(x),sin(x));  }\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.5,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0)); return colOut; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 hacerPiernaIzq(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,8.0);vec2 b1=vec2(3.0,5.0);  //pierna\n    vec2 a2=vec2(3.0,5.0);vec2 b2=vec2(3.0,2.0); //rodilla\n    vec2 a3=vec2(3.0,2.0);vec2 b3=vec2(4.0,2.0); //pie\n\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=(1.0 + sin(t+PI));//t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    p3=RotatePOA(p2,a3,ang3);\n\n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    float d3= sdSegment(p3,a3,b3);\n\n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    colOut= DrawFig(vec3(0.0,0.0,1.0), colOut,d3 );\n    return colOut;\n}\n\n\nvec3 hacerPiernaDer(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,8.0);vec2 b1=vec2(3.0,5.0);  //pierna\n    vec2 a2=vec2(3.0,5.0);vec2 b2=vec2(3.0,2.0); //rodilla\n    vec2 a3=vec2(3.0,2.0);vec2 b3=vec2(4.0,2.0); //pie\n\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n  r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=(1.0 + sin(t+PI)); //t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    p3=RotatePOA(p2,a3,ang3);\n\n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    float d3= sdSegment(p3,a3,b3);\n\n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    colOut= DrawFig(vec3(0.0,0.0,1.0), colOut,d3 );\n    return colOut;\n}\n\n\nvec3 hacerBrazoIzq(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,9.0);  //Brazo\n    vec2 a2=vec2(3.0,9.0);vec2 b2=vec2(3.0,6.0); //Ante brazo\n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.8; r3=0.2;    \n   t1=t;\n   t2=t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    \n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    \n    colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    return colOut;\n}\n\nvec3 hacerBrazoDer(vec2 p, float t, vec3 colOut,vec3 colIn)\n{   vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,9.0);  //Brazo\n    vec2 a2=vec2(3.0,9.0);vec2 b2=vec2(3.0,6.0); //Ante brazo\n    \n    float t1, t2, t3;\n    float r1, r2, r3;\n\n   r1=0.6; r2=0.2; r3=0.2;    \n   t1=t;\n   t2=t+TWO_PI;\n   t3=(1.0 + sin(t+PI));\n\n    float ang1=r1*sin(t1);\n    float ang2=r2*sin(t2);\n    float ang3=r3*sin(t3);\n\n    vec2 p1,p2, p3;\n    p1=RotatePOA(p,a1,ang1);\n    p2=RotatePOA(p1,a2,ang2);\n    \n    float d1= sdSegment(p1,a1,b1);\n    float d2= sdSegment(p2,a2,b2);\n    \n    colOut= DrawFig(vec3(0.0+colIn.r,1.0,0.0+colIn.b), colOut,d1 );\n    colOut= DrawFig(vec3(1.0,0.0+colIn.g,0.0+colIn.b), colOut,d2 );\n    return colOut;\n}\n\nvec3 HacerCuerpoyCabeza(vec2 p, float t, vec3 colOut,vec3 colIn)\n{\n  vec2 a1=vec2(3.0,12.0);vec2 b1=vec2(3.0,8.0);  //Pansa\n  float d1= sdSegment(p,a1,b1);\n  float d2=sdCircle(p-vec2(3.0,13.0), 0.5 );  //cabeza\n  \n  colOut= DrawFig(vec3(0.0,1.0,0.0), colOut,d1);\n  colOut= DrawFig(vec3(0.5,5.0,1.0), colOut,d2);\n  return colOut;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(-1.0,0.0);\n    uv*=7.0;\n\n    vec3  col=vec3(0.5);\n\n   float t=iTime;\n   uv-=vec2(0.0,-7.0);\n\n    col= HacerCuerpoyCabeza(uv, t, col,vec3(0.0));\n   col= hacerPiernaIzq(uv,t, col,vec3(0.0));\n   col= hacerPiernaDer(uv,t+PI, col,vec3(0.0,0.5,0.5));\n   col= hacerBrazoIzq(uv, t, col,vec3(0.2,0.5,0.3));\n   col= hacerBrazoDer(uv, t-PI, col, vec3(1.0,0.5,0.4));\n   \n   vec2 a1=vec2(0.0,0.0);\n   vec2 b1=vec2(6.5,0.0);\n    float d1= sdSegment(uv-vec2(-2.0,2.0),a1,b1);\n    col= DrawFig(vec3(0.0,1.0,1.0), col,d1 );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 521, 521, 605], [606, 606, 645, 645, 740], [741, 741, 780, 780, 875], [876, 876, 915, 915, 1010], [1012, 1012, 1048, 1048, 1093], [1094, 1094, 1128, 1128, 1224], [1225, 1225, 1259, 1259, 1350], [1351, 1351, 1385, 1385, 1476], [1478, 1478, 1503, 1503, 2408], [2410, 2410, 2434, 2434, 2596], [2598, 2598, 2646, 2646, 2925], [2927, 2927, 2971, 2971, 3297], [3299, 3299, 3336, 3336, 3593], [3595, 3595, 3685, 3685, 4645], [4647, 4647, 4696, 4696, 4831], [4834, 4834, 4904, 4904, 5167], [5169, 5169, 5196, 5196, 5285], [5287, 5287, 5345, 5345, 5393], [5395, 5395, 5418, 5418, 5530], [5532, 5532, 5563, 5563, 6124], [6126, 6126, 6183, 6183, 7019]], "test": "untested"}
{"id": "ftsBD4", "name": "Forest Hexrosa", "author": "ufffd", "description": "playing with the an incomplete version of hexrosa that was tuned to work with n7", "tags": ["forest", "tiling", "bricks", "aperiodic", "hexrosa"], "likes": 19, "viewed": 464, "published": 3, "date": "1650931595", "time_retrieved": "2024-07-30T16:51:30.704105", "image_code": "#define MAX_STEPS 50\n#define PI 3.141592653589793\n#define NORMAL_MAP false // true for overly expensive normal maps\n\nconst int nfold = 7;\nconst float hexH = 1.;\nconst int hexL = 6;\nvec2 center = vec2(0.);\nfloat initR = 0.;\nconst float angle1 = 1. / float(nfold) * PI * 2.;\nconst float angle2 = PI * 0.5 - angle1 / 2.;\nconst float sidelength = hexH / (2. * cos(0.5 * angle1) + 1.);\nconst float hexW = 2. * sidelength * sin(0.5 * angle1);\nconst float offX = hexW / 2.;\nconst float offY = sidelength + ((hexH - sidelength) / 2.);\n\nfloat hexSDF(in vec2 position) {\n    position /= vec2(sqrt(3.0), 1.5); // magic numbers\n    position.y -= 0.5;\n    position.x -= fract(floor(position.y) * 0.5);\n    position = abs(fract(position) - 0.5);\n    return abs(1. - max(position.x * tan(angle2) * 1.15 + position.y, position.x / hexW * 1.15)) * sqrt(3.) * 0.5; // magic numbers\n}\n\nfloat drawHex(in vec2 position, in float size) {\n    // position *= vec2(hexH,hexW)/hexH;\n    float sdf = hexSDF(position);\n    if (position.x < -0.5) sdf = 0.;\n    if (position.x > 0.5) sdf = 0.;\n    if (position.y < -0.5) sdf = 0.;\n    if (position.y > 0.5) sdf = 0.;\n    return smoothstep(size-0.002,size+0.002,sdf);\n}\n  \nfloat lineSDF( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat drawLine(in vec2 p, in vec2 a, in vec2 b, in float lt) {\n    return 1.-smoothstep(0.0,lt,lineSDF(p, a, b));\n}\n\n\nfloat moveDot( in vec2 start, in vec2 end, in float dt, in float size, in vec2 uv) {\n    vec2 dotpos = mix(start,end,mod(dt,1.));\n    float dotstep = length(uv+dotpos);\n    return 1.0 - smoothstep(size,size+0.0001,dotstep);\n}\n\nvec3 drawHexrosa(in vec2 uv, in float thic) {\n    // incomplete version of hexrosa, tuned to work with n7\n    vec3 color = vec3(0.);\n    \n    float dt = iTime * 0.5;\n    \n    float lines = 0.;\n        // dot positions of hexagon edge. magic numbers, the lot of them\n        float xedge = 0.0317 * 2.;\n        float y12 = 0.139 * 1.46;\n        float y1 = 0.139;\n        float y2 = 0.139 * 0.55;\n        float y3 = 0.;\n\n        // points, clock wise (12 at top)\n        vec2 p12 = vec2(0.,y12);\n        vec2 p1 = vec2(xedge/2.,y1);\n        vec2 p2 = vec2(xedge,y2);\n        vec2 p3 = vec2(xedge,y3);\n        vec2 p4 = vec2(xedge,-y2);\n        vec2 p5 = vec2(xedge/2.,-y1);\n        vec2 p6 = vec2(0.,-y12);                    \n        vec2 p7 = vec2(-xedge/2.,-y1);\n        vec2 p8 = vec2(-xedge,-y2);                    \n        vec2 p9 = vec2(-xedge,y3);\n        vec2 p10 = vec2(-xedge,y2);\n        vec2 p11 = vec2(-xedge/2.,y1);\n                    \n        float lt = thic*0.002;\n    \n    //the hex rosa is made of 2 sets of nfold# of what I call 'branches'. a branch is a single triangular array of 'seeds' drawn as 'hexes' (base hexagons shapes)\n    //this loop doubles the process for each set of branches\n    for(int outset=0;outset<2;outset++){    \n        vec2 ouv = uv;\n        ouv *= Rot(float(outset) * PI / float(nfold));\n        //this loop divides the circle by nfold# and draws that many branches, evenly spaced\n        for (int branch=0;branch<nfold;branch++){\n            vec2 buv = ouv;\n            buv *= Rot(angle1 * float(branch));\n            buv.y -= .08 / float(nfold); // magic numbers\n            buv.y += sidelength * float(outset) * 0.41; // magic numbers\n            //this loop sets and positions the row being drawn in the current branch\n            for (int row=0;row<hexL;row++) { // the hexagonal loop could probably be optimized\n                //this loop sets and positions the individual seed being drawn in the current row\n                for (int col = row * -1; col <= row; col += 2) {\n                    vec2 huv = buv;\n                    vec2 hexcenter = vec2(float(col)*offX,float(row)*offY) * 0.41;\n                    huv += hexcenter; // magic numbers\n                    huv.y += offY/PI;\n                    \n                    float mainhex = drawHex(huv, 0.749); // magic numbers\n                    color += mainhex * 0.8;\n                    \n                    lines += drawLine(huv,p12,p2,lt);\n                    lines += drawLine(huv,p12,p10,lt);\n                    lines += drawLine(huv,p2,p8,lt);\n                }            \n            }            \n        }\n    }\n    \n    color = vec3(lines);\n    \n    return clamp(color, vec3(0.),vec3(1.));\n}\nvec3 drawHexrosa(in vec2 uv) {\n    return drawHexrosa(uv, 5.);\n}\n\nstruct March \n{\n    float dist;\n    int mater;\n    bool hit;\n    vec3 p;\n};\n\n// array of structs not working, neither is declaring mat1\n// struct Mater\n// {\n//     vec3 col;\n// };\n\n// Mater mat1;\n// mat1.col = vec3(1.,0.,0.);\n\nvec3 mat1 = vec3(1.,0.,0.);\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCube( vec3 p, float b ) {\n    return sdBox(p,vec3(b));\n}\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat Bounce3(float x, float base) {\n    \n    x = -log(1.-x)/log(base);\n    x -= (1.-pow(base, -.5)) / (1.-1./base);\n    \n    float i = floor(x);\n\n    x = fract(x);\n    \n    x = (1.-pow(base, -x)) / (1.-1./base);\n    float bounce = -4.*x*(x-1.);\n    \n    bounce /= pow(base*.8, i+1.);\n    return .4*bounce;   \n}\n\nMarch map(in vec3 p, in int mode) {\n    float d = 1000.;\n    int mater = -1;\n    \n    if (mode==0) {\n\n        float floatyT = sin(PI * 1.5 + iTime * 0.5); // timing of floaters\n        float floatheight = 1.25 + 0.5 * floatyT; // float up\n        if (mod(iTime*0.5,PI*2.)/(PI*2.) > 0.5) { // hover at top\n            floatheight = 1.75;\n        }\n        if (mod(iTime*0.5,PI*2.)/(PI*2.) > 0.75) { // fall\n            // floatheight = Bounce3(fract(iTime*0.5), 0.5);\n            floatheight = .75 + 2.5*Bounce3(fract(iTime*0.5*(2./PI)), 0.7);\n        }\n        vec3 floatyp = p - vec3(0.,floatheight,0.);\n        float ballsize = sin(PI*1.5+iTime*0.25)*0.5;\n        ballsize = clamp(ballsize+0.15, 0.05, 0.2);\n        float ball = length(floatyp)-ballsize;\n        if (ball < d) mater = 1;\n        // d = min(d,ball);\n\n        floatyp.xz *= Rot(iTime + sin(PI*1.15+iTime*0.5)*1.8);\n        if (mod(iTime * 0.5, PI*2.) < PI) \n            floatyp.xy *= Rot(iTime * 0.25);\n        // floatyp.yz *= Rot(iTime * 0.08);\n        float cubesize = sin(PI*.5+iTime*0.25)*0.5;\n        cubesize = clamp(cubesize+0.15, 0.05, 0.15);\n        float cube = sdCube(floatyp,cubesize) - 0.02;\n        if (cube < d) mater = 1;\n        // d = min(d,cube);\n        d = min(d,smin(cube,ball,0.1));\n    }\n    \n    float brickfloor = p.y - .6;\n    if (brickfloor < d) mater = 2;\n    d = min(d, brickfloor);\n    \n    vec3 rock1p = p;\n    rock1p.x = mod(rock1p.x - 2., 2.) + 2.;\n    rock1p.z = mod(rock1p.z - 1.5, 2.) + 1.5;\n    rock1p.y *= 1.1;\n    float rocksize = noise(p.xz*3.)*0.4;\n    rocksize *= smoothstep(3.,4.,length(p.xz));\n    float rock1 = length(rock1p-vec3(2.5,0.55,2.))-rocksize;\n    rock1 -= noise(p.xz*5.) * 0.2;\n    rock1 -= noise(p.xz*8.) * 0.1;\n    if (rock1 < d) mater = 4;\n    d = min(d, rock1);\n    \n    vec3 mush1p = p;\n    mush1p.xz *= Rot(0.5);\n    mush1p.xz += 3. + sin(p.x) * 0.2;\n    mush1p.y -= .6;\n    float mush1s = .2;\n    // mush1p.x = mod(mush1p.x - 1., 2.) + 1.;\n    mush1p.z = mod(mush1p.z, 3.) - 1.5;\n    mush1p.x = mod(mush1p.x, 3.) - 1.5;\n    mush1p.x += sin(p.z)*0.2;\n    mush1p.z += sin(p.x)*0.2;\n    float mush_stem = sdVerticalCapsule(vec3(mush1p),0.8*mush1s,0.08*mush1s);\n    float mush = mush_stem;\n    float mush_cap = length(mush1p-vec3(0.,1.*mush1s,0.))-.1*mush1s;\n    mush_cap = sdCutSphere(mush1p-vec3(0.,1.*mush1s,0.), .25*mush1s, 0.);\n    mush = min(mush, mush_cap);\n    if (mush < d) mater = 5;\n    d = min(d, mush);\n    \n    float clsize = 0.09;\n\n    if (length(p.xz) > 2.) {\n    for (int j=0;j<3;j++) {\n    \n        vec3 cloverp = p - vec3(1.,.6,0.);\n\n        cloverp *= 0.5 + float(j)/8.;\n        cloverp.x += float(j);\n\n        cloverp.xz *= Rot(0.8 + 0.3*sin(length(cloverp.xz)));\n        cloverp.x = mod(cloverp.x, .8) - 0.15;\n        // cloverp.y = mod(cloverp.z, .3) - 0.15;\n        cloverp.z = mod(cloverp.z, .8) - 0.15;\n        cloverp.xz *= Rot(noise(p.xz) * 5.);\n\n        cloverp.x += sin(p.x + iTime*0.5) * cloverp.y * .3;\n        cloverp.z += sin(p.x + iTime*0.22) * cloverp.y * .2;\n        //\n        // cloverp.x += noise(p.xz) * 0.05;\n        \n        \n        // cloverp.x += cloverp.y;\n\n        float cloverstem = sdVerticalCapsule(vec3(cloverp),clsize*0.6,clsize*0.05);\n        float clover = min(cloverstem, 2000.);\n        cloverp.xz *= Rot(0.2);\n        float cloverleaf1 = sdCappedCylinder(cloverp - clsize*vec3(.2,.7,0.),clsize*0.18,clsize*0.02) - 0.01*clsize;\n        cloverp.yz *= Rot(-0.1);\n        float cloverleaf2 = sdCappedCylinder(cloverp - clsize*vec3(-.08,.69,-.12),clsize*0.18,clsize*0.018) - 0.01*clsize;\n        cloverp.xy *= Rot(0.1);\n        float cloverleaf3 = sdCappedCylinder(cloverp - clsize*vec3(-.08,.69,.12),clsize*0.18,clsize*0.015) - 0.01*clsize;\n        clover = min(clover, cloverleaf1);\n        clover = min(clover, cloverleaf2);\n        clover = min(clover, cloverleaf3);\n        if (clover < d) mater = 3;\n        d = min(d, clover);\n        \n        \n    }\n    }\n    \n    March result;\n    result.dist = d;\n    result.mater = mater;\n    result.hit = d < 0.0001;\n    result.p = p;\n    \n    return result;\n}\nMarch map(in vec3 p) {\n    return map(p,0);\n}\n\nMarch raymarch(in vec3 ro, in vec3 rd, in int steps, in int mode) {\n    March march; // initialize result struct\n    vec3 p;\n    float d = 0.;\n    for (int i=0;i<steps;i++){\n        p = ro + rd * d;\n        march = map(p,mode);\n        d += march.dist;\n        if (march.hit) break;\n        if (march.dist > 100.) break;\n    }\n    return march;\n}\n\nMarch raymarch(in vec3 ro, in vec3 rd) {\n    return raymarch(ro,rd,MAX_STEPS, 0);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p).dist;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).dist,\n        map(p-e.yxy).dist,\n        map(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 n) {\n    float floatyT = sin(PI*1.5 + iTime * 0.5); // timing of floaters\n    vec3 lightPos = vec3(0., 2. + 0.5*floatyT, 0.);\n    vec3 l = normalize(lightPos-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = raymarch(p+n*0.0001*2., l, 60, 1).dist;\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\nfloat GetLight(vec3 p) {\n    vec3 n = GetNormal(p);\n    return GetLight(p,n);\n}\n\nvec2 hexrosaNormal(in vec2 uv) { // expensive, ~33% GPU\n    if (!NORMAL_MAP) return vec2(0.);\n    float s = 0.001;\n    \n    float p = drawHexrosa(uv,7.).r;\n    float h1 = drawHexrosa(uv + vec2(s,0),7.).r;\n    float v1 = drawHexrosa(uv + vec2(0,s),7.).r;\n       \n   \treturn (p - vec2(h1, v1)) * 10.;\n}\n\nvec3 getCol(in March march) {\n    vec3 col = vec3(0.);\n    vec3 norm = GetNormal(march.p);\n    if (march.mater == 1) {\n        col = vec3(0.95,0.94,0.99);\n    }\n    if (march.mater == 2) {\n        vec3 hexrosa = drawHexrosa(march.p.xz * .4);\n        col = 1. - hexrosa;\n        vec3 bricktexture = texture(iChannel0,march.p.xz * 0.1 * iResolution.x/800.).rgb;\n        col *= bricktexture * vec3(.9,0.8,0.6);\n        vec2 hexnorm = hexrosaNormal(march.p.xz * .4);\n        norm.rg += hexnorm;\n        \n    \n        // grass zone\n        vec2 grasslim = march.p.xz * 0.5 - 0.5;\n        grasslim += texture(iChannel0,march.p.xz).rb;\n        grasslim += texture(iChannel0,march.p.xz * 0.05).rb - 0.5;\n        float grasszone = length(grasslim) - 1.1;\n        grasszone = clamp(grasszone,0.,1.);\n\n        vec3 grass = texture(iChannel0,march.p.xz * Rot(0.5) * .5).rgb * vec3(0.1,0.5,0.1);\n        grass -= texture(iChannel0,march.p.xz * Rot(-0.5) * .1).rgb * vec3(0.05,0.3,0.05);\n        col = mix(col,grass,grasszone);\n\n        // col = vec3(grasszone);\n        \n        float mossbricks = grasszone * hexrosa.r * (1. - grasszone);\n        mossbricks += mossbricks;\n        mossbricks *= mossbricks;\n        col.g += mossbricks;\n        \n        float floatyT = min(1.25,sin(PI*1.75 + iTime * 0.5) + 0.75); // timing of floaters\n        \n        float glowbricks = hexrosa.r * (1. - grasszone);\n        col.r += clamp(glowbricks * (2.*floatyT - length(march.p.xz)),0.,1.);\n        \n        float glowbricksfine = drawHexrosa(march.p.xz * .4,3.).r * (1. - grasszone);\n        col.g += clamp(glowbricksfine * glowbricksfine * (1.5*floatyT - length(march.p.xz)),0.,1.);\n        \n        \n        float glowbrickscenter = hexrosa.r * (1. - grasszone);\n        col.b += clamp(glowbricksfine * glowbricks * (1.*floatyT - length(march.p.xz)),0.,1.);\n        \n    }\n    if (march.mater == 3) { // clovers\n        col = vec3(0.01,0.25,0.05);\n    }\n    if (march.mater == 4) { // rocks\n        vec3 bricktexture = texture(iChannel0,march.p.xz * 0.1).rgb;\n        col = vec3(1.);\n        col *= bricktexture * vec3(0.6,0.57,0.49);\n        col.g += smoothstep(0.2,.45,1.-march.p.y) * 0.11;\n        col.g += smoothstep(0.35,.45,1.-march.p.y) * 0.6;\n        col -= smoothstep(0.35,.45,1.-march.p.y) * 0.5;\n        col *= (1. - smoothstep(0.3,.4,1.-march.p.y) * 0.5);\n        col *= 0.6+march.p.y*march.p.y;\n    }\n    if (march.mater == 5) { // mushies\n        col = vec3(0.86,0.7,0.5);\n        col = mix(col,col*norm.g,0.6);\n        col += 1.-march.p.y*1.6;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = vec3(0.);\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // raymarch\n    vec3 ro = vec3(0.,5.,-3.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,2.));\n    \n    float d = 0.;\n    ro.xz *= Rot(iTime*0.02);\n    // rd.yz *= Rot(0.5);\n    rd.yz *= Rot(1.);\n    \n    rd.xz *= Rot(iTime*0.02);\n    \n    March march = raymarch(ro,rd);\n    \n    if (march.hit) {\n        col = mat1;\n    }\n    \n    // for debugging\n    // if (march.mater == 5) {fragColor = vec4(1.,0.,0.,1.); return;}\n    \n    vec3 norm = GetNormal(march.p);\n    \n    col = getCol(march);\n    if (march.mater == 1) {\n        march.dist += 0.001;\n        // single bounce reflection\n        ro = ro + rd * march.dist;\n        rd = reflect(rd, norm);\n        March bounce = raymarch(ro,rd);\n        vec3 bouncecol = getCol(bounce);\n        // if (bounce.hit) col = getCol(bounce);\n        vec3 forest = texture(iChannel1,rd).rgb;\n        \n        float floatyT = sin(iTime * 0.5); // timing of floaters\n        bouncecol.r += floatyT * 0.7;\n        forest += floatyT * 0.5;\n        \n        col = mix(bouncecol,forest,smoothstep(0.4,0.5,norm.g));\n    }\n    \n    float shad = GetLight(march.p, norm);\n    shad = mix(shad,1.,0.8); // dim the lights\n    col *= shad;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[528, 528, 560, 560, 865], [867, 867, 915, 956, 1188], [1192, 1192, 1242, 1242, 1365], [1367, 1367, 1429, 1429, 1482], [1485, 1485, 1569, 1569, 1710], [1712, 1712, 1757, 1817, 4424], [4425, 4425, 4455, 4455, 4489], [4747, 4747, 4800, 4800, 4859], [4860, 4860, 4912, 4912, 5019], [5020, 5020, 5051, 5051, 5138], [5139, 5139, 5172, 5172, 5203], [5204, 5204, 5251, 5313, 5589], [5591, 5591, 5630, 5630, 5721], [5723, 5723, 5759, 5759, 6034], [6036, 6036, 6071, 6071, 10123], [10124, 10124, 10146, 10146, 10169], [10171, 10171, 10238, 10238, 10517], [10519, 10519, 10559, 10559, 10602], [10604, 10604, 10628, 10628, 10822], [10824, 10824, 10856, 10856, 11177], [11178, 11178, 11202, 11202, 11257], [11259, 11259, 11291, 11314, 11559], [11561, 11561, 11590, 11590, 14128], [14130, 14130, 14187, 14237, 15553]], "test": "untested"}
{"id": "7llfD4", "name": "Ball Lighting Visit", "author": "lakartoza", "description": "It's a first try!", "tags": ["balllightning"], "likes": 0, "viewed": 205, "published": 3, "date": "1650923195", "time_retrieved": "2024-07-30T16:51:31.542863", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float pi = 3.14;\n    \n    \n    float x= uv.x *iMouse.x/1024.0;\n    float y= uv.y *iMouse.y/576.0;\n    \n    float circy = x*(3.0*y-sin(470.0) -1.5);\n    float circx = (5.0*x-tan(470.0/pi)*pi/2.0-2.5);\n\n    float f = circy*circy + circx*circx;\n    \n\n\n    vec3 col = vec3( 0.85, (3.0-3.0*f), 0.5);\n    \n    fragColor = vec4(col, 1.0);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 678]], "test": "untested"}
{"id": "ftffWN", "name": "cameras: photo vs panoramic", "author": "FabriceNeyret2", "description": "camera:   left: flat perspective      right: cylindrical perspective\n                key ↑↓ : opening           mouse.xy: rot\nscene:     top: straight ribbon        bottom: cylindrical ribbon\n                roof: square grid           floor: polar grid\n", "tags": ["projection", "perspective", "cameras", "cylindrical"], "likes": 10, "viewed": 336, "published": 3, "date": "1650917980", "time_retrieved": "2024-07-30T16:51:32.382617", "image_code": "#define T(U)    ( V = smoothstep(0.,-.05,abs(fract(U)-.5) -.5 ),    \\\n                  texture(iChannel0, U) * V.x*V.y ) // pattern\n#define rot(a)    mat2(cos( a + vec4(0,11,33,0)))\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O-=O;\n    vec2  R = iResolution.xy, V,\n          U = ( 2.*u - R ) / R.x,                   // normalized screen coordinates\n          M = iMouse.xy/R;\n    if ( int(u) ==int(R)/2 ) { O = vec4(1,0,0,1); return; } // red separator\n    \n    float Z = 8., H = 1.5, a,                       // Z: object distance\n          W = iMouse.z > 1e4 ? .38/ M.x : 1.;       // 1/W: camera opening\n    W = 1./max(0.,texelFetch(iChannel1,ivec2(0),0).y );\n    vec3  P, D = vec3( U , W );                     // ray direction: left: flat perspective\n    if (D.x>0.) {                                   //                right: cylindrical perspective (panorama)\n          a = U.x/W;\n          D.xz = W* vec2(sin(a),cos(a));\n          if (abs(a) > 3.14/2.) O.r+=.5;            // view > 180° : mid-red alert\n          if (abs(a) > 3.14)    O.r+=.5;            // view > 360° : red alert\n       }\n    D = normalize(D);\n    if (iMouse.z > 0.)\n      D.yz *= rot( 1.57*(2.*M.y-1.) ),\n      D.xz *= rot( 1.57*(2.*M.x-1.) );\n    \n    P = Z* D/abs(D.z);                              // draw flat ribbon \n    if ( abs(P.y-1.) < .5 && P.z>0. ) { \n        O += T(P.xy-.5); return; }                  // with mapped texture\n    \n    P = Z* D/length(D.xz);                          // draw cylindrical ribbon\n    if ( abs(P.y+1.) < .5 ) {                       // with mapped texture\n        O += T(vec2(Z*atan(P.x,P.z),P.y)-.5); return; } \n    \n    P = H * D/abs(D.y);\n    if ( P.y > 0. ) {                               // draw roof square grid\n        O +=   T(P.xz+vec2(.5,0) ) \n             * vec4(0,1,1,0) * exp(-P.z/Z);         // color + darkening with z\n        return; } \n  \n    if ( P.y < 0. ) {                               // draw floor polar grid\n        O +=  T(vec2(Z*atan(P.x,P.z),Z*log(length(P.xz)))+vec2(.5,0) )\n             * vec4(1,.5,0,0) * exp(-P.z/Z);        // color + darkening with z\n        return; }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0,ivec2(U),0);\n    if (iFrame==0) O.xy = vec2(0,1);\n    if keyClick(38) O.x++, O.y *= 1.1;\n    if keyClick(40) O.x--, O.y /= 1.1;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftffWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 220, 220, 2127]], "test": "untested"}
{"id": "NtsfD4", "name": "oblique relief (terrain tilted z", "author": "FabriceNeyret2", "description": "For panorama depiction you sometime want 3D view but with mountains still looking quite like they are from the floor.\nleft: classical rotated camera    right: with tilted terrain\nmouse.y controls camera angle.    mouse.x select render mode (red separator)", "tags": ["raymarching", "panorama", "mountain", "short", "terrainrendering", "obliquerelief"], "likes": 35, "viewed": 672, "published": 3, "date": "1650908523", "time_retrieved": "2024-07-30T16:51:33.188463", "image_code": "// ref: http://www.reliefshading.com/design/plan-oblique-relief/\n\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))          // rotation 2D\n#define T(U,l)    textureLod( iChannel0, U/S +.2, l ).r // terrain\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t=9., S=4.;                                   // texture scaling\n    vec2  R  = iResolution.xy,\n          U  = ( 2.*u - R )/R.y,                        // normalized screen coords\n          M  = iMouse.z > 0. ? ( 2.*iMouse.xy - R*vec2(1,2) ) / R.y \n                             : vec2(cos(iTime),-.14-.7+.7*sin(0.74*iTime)); // auto-demo\n    vec3  D  = normalize(vec3(U, -3.5)),                // ray direction\n          p0 = vec3(0,0,7), p=p0, q;                    // marching point along ray \n\n    for (int i=0; i<200 && t > .01; i++) {              // --- ray marching loop\n        q = p;\n        if (U.x < M.x) \n              q.yz *=  rot(-M.y);                       // left: classical rotation\n        else  q.y += q.z * -M.y;                        // right: terrain tilting\n     //  q.yz *= rot(.14);                              // rotation\n        t = q.y - .2 *S*T(q.xz,0.) +.3,                 // terrain pseudo-SDF\n        p += .3*t*D;                                    // step forward = dist to obj          \n   }\n   t = length(p-p0)-2.; O = vec4( exp(-t/10.) );        // depth-shading\n   t = T(q.xz,0.);                                      // final look:\n   O *= ( 1. + 100.*(t-T(q.xz,1.)) ) * (.2+t);          // add details + ambient occlusion\n   \n  if ( abs(U.x-M.x)*R.y < 1.5 ) O = vec4(1,0,0,1);      // red separator\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 241, 241, 1595]], "test": "untested"}
{"id": "7tfBDN", "name": "01 Simple 2D graphics", "author": "ccc9527", "description": "four functions for drawing simple 2D graphics.\nbut how can i blur the triangle?\nI will be very grateful to him who can tell me the solution.", "tags": ["2d", "triangle", "line", "circle", "rectangle"], "likes": 0, "viewed": 284, "published": 3, "date": "1650893585", "time_retrieved": "2024-07-30T16:51:34.022233", "image_code": "//画线函数,p为uv,即屏幕上任意一点,ab为线段两端点,size.x是线段宽,\n//size.y是线段边缘模糊百分比,color是线段颜色\nvec3 DrawLine(vec2 uv,vec2 a,vec2 b,vec2 size,vec3 color)\n{\n    vec2 ap = uv-a;\n    vec2 ab = b-a;\n    \n    float t = dot(ap,ab)/dot(ab,ab);//点p在线段上投影占ab的百分比\n    t = clamp(t,0.0,1.0);\n    \n    //ap-ab*t表示点p-点p到线段ab的垂点,即d是点p到线段的距离\n    float d = length(ap-ab*t);\n    float s = smoothstep(size.x,size.x-size.y*size.x,d);\n    \n    return s*color;\n}\n//画圆函数,p表示圆心,uv表示屏幕上任意一点,size.x是圆半径\n//size.y表示圆边缘模糊百分比,color是圆的颜色\nvec3 DrawCircle(vec2 p,vec2 uv,vec2 size,vec3 color)\n{\n    uv -= p;\n    float d = length(uv);//uv点到中心点的距离\n    d = smoothstep(size.x,size.x-size.x*size.y,d);\n    \n    return d*color;\n}\n//点p到直线ab的距离\nfloat DistanceToLine(vec2 p,vec2 a,vec2 b)\n{\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    float t = dot(ap,ab)/dot(ab,ab);\n    vec2 n = a+ab*t;\n    return length(p-n);\n}\n//画三角形函数,uv同上,a,b,c是三角形三个顶点,color是三角形颜色\nvec3 DrawTriangle(vec2 uv,vec2 a,vec2 b,vec2 c,vec3 color_a,\n    vec3 color_b,vec3 color_c)\n{\n    vec2 ap = uv-a;\n    vec2 bp = uv-b;\n    vec2 cp = uv-c;\n    vec2 ab = b-a;//逆时针方向的三角形三条边\n    vec2 bc = c-b;\n    vec2 ca = a-c;\n    \n    //ap与ab,bp与bc,cp与ca的三个叉乘符号若是同号,代表点p在三角形内\n    //这是一种判断点是否在三角形内的方法,还可以根据三个小三角形面积是否等于\n    //大三角形面积判断\n    float c1 = ap.x*ab.y-ap.y*ab.x;\n    float c2 = bp.x*bc.y-bp.y*bc.x;\n    float c3 = cp.x*ca.y-cp.y*ca.x;\n    \n    float s = DistanceToLine(a,b,c);//大三角形的面积\n    if(c1*c2>0.0 && c2*c3>0.0)\n    {\n        float d1 = DistanceToLine(uv,a,b);//uv到ab的距离\n        float d2 = DistanceToLine(uv,b,c);//uv到bc的距离\n        float d3 = DistanceToLine(uv,c,a);//uv到ca的距离\n        \n        //三个小三角形的面积,用于除以总面积表示重心坐标\n        float s1 = d1*length(ab);\n        float s2 = d2*length(bc);\n        float s3 = d3*length(ca);\n        \n        //s2/s是对应a点颜色比例,s3/s是对应b点颜色比例\n        //s1/s是对应c点颜色比例,画图之后更清晰易懂\n        return s2/s*color_a+s3/s*color_b+s1/s*color_c;\n    }\n    \n    return vec3(0.0);\n}\n//画矩形函数,uv同上,ab分别是矩形的左上点和右下点,blur的xy分别是\n//xy方向的模糊百分比,color是矩形颜色\nvec3 DrawRectangle(vec2 uv,vec2 a,vec2 b,vec2 blur,vec3 color)\n{\n    float x = b.x-a.x;\n    float y = a.y-b.y;\n    \n    //矩形的四个边界,左右下上\n    float x1 = smoothstep(0.0,x*blur.x,uv.x-a.x);\n    float x2 = smoothstep(x,x-x*blur.x,uv.x-a.x);\n    float y1 = smoothstep(0.0,y*blur.y,uv.y-b.y);\n    float y2 = smoothstep(y,y-y*blur.y,uv.y-b.y);\n    \n    return x1*x2*y1*y2*color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //将(0,0)点移动到屏幕中心,并使得xy方向单位长度相同\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //线段的两个端点\n    vec2 a = vec2(-0.5,0.1);\n    vec2 b = vec2(-0.2,0.4);\n    //圆心\n    vec2 p = vec2(0.4,0.2);\n    //三角形三个顶点坐标和颜色\n    vec2 t1 = vec2(-0.4,-0.1);\n    vec2 t2 = vec2(-0.6,-0.4);\n    vec2 t3 = vec2(-0.2,-0.4);\n    vec3 c1 = vec3(1,0,0);\n    vec3 c2 = vec3(0,1,0);\n    vec3 c3 = vec3(0,0,1);\n    //矩形左上点后右下点\n    vec2 r1 = vec2(0.2,-0.05);\n    vec2 r2 = vec2(0.6,-0.45);\n    \n    col += DrawLine(uv,a,b,vec2(0.01,0.1),vec3(1.0,0.0,0.0));\n    col += DrawCircle(p,uv,vec2(0.2,0.1),vec3(0.0,1.0,0.0));\n    col += DrawTriangle(uv,t1,t2,t3,c1,c2,c3);\n    col += DrawRectangle(uv,r1,r2,vec2(0.1,0.1),vec3(1.0,0.0,1.0));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 148, 207, 207, 554], [555, 693, 747, 747, 892], [893, 920, 964, 964, 1086], [1087, 1171, 1264, 1264, 2473], [2474, 2612, 2676, 2676, 3006], [3008, 3008, 3065, 3140, 3947]], "test": "untested"}
{"id": "ftXfD4", "name": "noise testee", "author": "fl0a1e", "description": "noise learn", "tags": ["3d", "noise"], "likes": 2, "viewed": 200, "published": 3, "date": "1650889969", "time_retrieved": "2024-07-30T16:51:34.845033", "image_code": "// noise\n\n\n#define X 14.743529f   // 0.0 ~ 1000000.0000\n#define Y 58.086473f  // 0.0 ~ 1000000.0000\n#define size 1923.0f\n\nfloat noise(vec2 uv){\n     float noi = fract(sin(dot(uv.xy, \n                    vec2(X, Y*iTime)))\n                    *size);\n    return noi;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    \n    // Output to screen\n    fragColor = vec4(vec3(noise(uv)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 143, 143, 267], [270, 270, 327, 327, 467]], "test": "untested"}
{"id": "NllyRN", "name": "Raycasting Overlapping Objects", "author": "Shane", "description": "A cell by cell traversal of overlapping objects.", "tags": ["raycasting", "cube", "cell", "block", "overlap", "traversal"], "likes": 67, "viewed": 1236, "published": 3, "date": "1650889208", "time_retrieved": "2024-07-30T16:51:35.829402", "image_code": "/*\n\n    Raycasting Overlapping Objects\n    ------------------------------\n    \n    Rendering inside a pixelshader environment can be challenging, and \n    in many cases, restrictive. If you've ever tried to render a grid\n    of closely packed or overlapping objects, you'll notice neighboring \n    grid cell overlap artifacts. Sometimes, you can render four cells at\n    a time to account for the overlap, but in a 3D scene, a pixel ray \n    can usually visit more cells than you can accomodate for. Traversing \n    a grid in a cell by cell manner along the line of sight can fix that\n    problem, but isn't of much use when objects overlap cell boundaries.\n    \n    In that case, you will have to perform a neighboring cell by cell \n    traversal, like this one. A cell by cell traversal with neighbor\n    checks is not ideal, but will be artifact free. This traversal only\n    accounts for four neighboring cells, so only a certain amount of \n    overlap is possible, but as you can see, you can create more \n    interesting variations when overlap is allowed. If you wanted to \n    create a more interesting cityscape, a traversal like this would give\n    you more options.\n    \n    This scene works on an extruded 2D (XZ) grid schematic, but a proper \n    3D voxel version (XYZ) is possible. In fact, Reinder has incorporated \n    just that in his \"RIOW 2.09\" scene. It's in static form, but I think\n    a realtime version would be possible.\n    \n    Rendering overlapped artifact free scenes in this manner gives the \n    user another tool to work with, but ultimately, I'd imagine more \n    sophisticated partitioning structures would be required to render \n    more sophisticated scenes.\n    \n    As for the scene itself, I made it up as I went along, so I'm not \n    really sure what it's supposed to represent, but it reminds me of \n    the final minutes of touchdown in various places I've flown to... \n    I've been to some dreary places in my time. :)\n\n\n    Other traversal rendering schemes:\n    \n    // This is a static image, but I believe it is the first example \n    // on Shadertoy involving a 3D voxel cell traversal that caters \n    // for overlapping objects (the cube of white spheres).\n    RIOW 2.09: A Scene Testing All - reinder\n    https://www.shadertoy.com/view/MtycDD\n    \n    // Fizzer has all kinds of really cool traversal examples.\n    Procedural Octree - Fizzer\n    https://www.shadertoy.com/view/3dSGDR\n    \n    // One of IQ's BVH examples. There are a few on Shadertoy, and\n    // all are worth a look.\n    Boxes traced - IQ\n    https://www.shadertoy.com/view/4tKBWy\n    \n    // Abje's stackless version, based on IQ's example.\n    many boxes - abje\n    https://www.shadertoy.com/view/wsS3Wz\n    \n    // OCB's really nice architectural sci-fi scene constructed\n    // with three variable sized grids. OCB has similar examples\n    // that are worth the look too.\n    Hope - ocb\n    https://www.shadertoy.com/view/MllfDX\n\n*/\n\n\n#define FAR 25.\n \n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec2 to vec2 hash.\nvec2 hash22(vec2 p) {\n    \n    return fract(sin(vec2(dot(p, vec2(12.783, 78.137)), dot(p, vec2(41.581, 57.263))))\n                          *vec2(43758.5453, 23421.6361));\n}\n\n// Rectangle scale. Smaller scales mean smaller squares, thus more of\n// them. Sometimes, people (including myself) will confuse matters\n// and use the inverse number. :)\nvec2 s = vec2(1, 1)/4.; \n\n // Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   return dot(p - ro, n)/dot(rd, n);\n\n}\n\n// Grid cell function.\nvec2 gridID(vec2 p){\n    // Using the rectangle's center position for the ID. \n    return floor(p/s) + .5;\n\n}\n\n\nfloat hm(vec2 p){\n\n    // Only one texture read.\n    vec3 tx = texture(iChannel0, p/iChannelResolution[0].xy*24.).xyz;  tx *= tx;\n    // Greyscale height. Using \"tx.x\" would work, too.\n\tfloat f = dot(tx, vec3(.299, .587, .114));\n    float f2 = f; \n    \n    return f*1.8;//min(f*2., 1.8);//max(f*2. - .075, 0.);//*12. + f2*4.;\n\n}\n\n// IQ's box routine.\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 invRd, in vec3 dim){ \n\n\t// Ray-box intersection.\n    vec3 n = ro*invRd;\n    vec3 k = abs(invRd)*dim;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max(max(t1.x, t1.y ), t1.z);\n\tfloat tF = min(min(t2.x, t2.y ), t2.z);\n\t\n\tif( tN>tF || tF<0.) return vec4(1e8);\n\n\t//vec3 nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\treturn vec4(tN, t1);\n}\n\nvec3 gN;\nfloat gObjID;\n\nvec2 gDist;\n\nvec4 raycast(vec3 ro, vec3 rd, int iters){\n   \n    vec4 res = vec4(FAR, 0, 0, 0);\n    \n    vec3 invRd = 1./rd;\n    \n    gObjID = -1.;\n    \n    \n    // Rectangle normals: Any two will do. By the way, there's nothing\n    // stopping you from declaring all four normals for all surrounding\n    // walls, but since you know only two will be in front of the\n    // direction ray at any given time, it makes sense to only choose\n    // two.\n    //\n    // Declare two normals. Any side by side ones will do.\n    vec2 n1 = vec2(-1, 0), n2 = vec2(0, -1); // Right and top edges.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing cell\n    // wall, if you prefer), use the normal index from the back cell wall. This \n    // trick is possible because of the rectangle symmetry. As an aside, for \n    // anyone who doesn't know, dotting the direction ray with the face normal \n    // is something you do in software engines for back face culling.\n    n1 = dot(rd.xz, n1)<0.? -n1 : n1;\n    n2 = dot(rd.xz, n2)<0.? -n2 : n2;\n    \n    // Initiate the ray position at the ray origin.\n    vec3 pos = ro;\n    \n    // Obtain the coordinates of the cell that the current ray position \n    // is contained in -- I've arranged for the cell coordinates to \n    // represent the cell center to make things easier.\n    vec2 ip = gridID(pos.xz);\n    \n    vec2 gIP = ip;\n    \n    float t1 = 1e8, t2 = 1e8, tT = 1e8;\n    \n    float floorDist = (0. - ro.y)/rd.y;\n    \n    int hit = 0;\n    \n    gDist = vec2(1e8);\n    \n    gDist.y = floorDist;\n    \n    vec4 t44 = vec4(FAR);\n    \n    //vec3 ip0 = vec3(ip.x*s.x, pos.y, ip.y*s.y);\n   float d = 1e8;\n    // Iterate through 24 cells -- Obviously, if the cells were smaller,\n    // you'd need more to cover the distance.\n    for(int i = 0; i<iters; i++){ \n    \n        // If we've hit the ocean plane, return immediately.\n        if (pos.y<0.){ gN = vec3(0, 1, 0); gObjID = 0.; return vec4(floorDist, vec3(0)); }\n\n         \n        vec2 svIP;\n        //d = 1e8;\n        t1 = rayLine(pos.xz, rd.xz, (ip + n1*.5)*s, -n1);\n        t2 = rayLine(pos.xz, rd.xz, (ip + n2*.5)*s, -n2);\n        \n        // This example doesn't differ much from a simple cell by cell traversal.\n        // The difference is the neighbor check. \n        float gMa;\n        // Checking four cells to cater for overlap, instead of the usual one only.\n        for(int j = 0; j<4; j++){ \n         \n            // Standard 2x2 neighbor check.\n            vec2 offs = vec2(j&1, j>>1) - .5;\n            vec2 ipJ = floor(ip - offs) + .5;\n            \n            // Height.\n            float ma = hm(ipJ*s);\n            // Skipping blocks below a certain height to make a clear water line distinction.\n            if(ma<1./20.) continue; \n\n            // At this point, we haven't advanced the ray to the back of the cell boundary,\n            // so we're at one of the front cell face positions. Therefore, check to see if \n            // we're under the pylon height. If so, we've hit a face, so mark the face as hit, \n            // then break.\n\n            vec2 w = hash22(ipJ + .21)*.8 + .05;//(min(ma, 1.)*.7 + .3) + .1;// - .02;\n                \n            t44 = iBox(ro - vec3(ipJ.x*s.x, ma/2., ipJ.y*s.y), invRd, vec3(s.x*w.x, ma/2., s.y*w.y));\n\n            // Nearest of the four boxes.\n            if(t44.x<d && (t44.x<length(pos - ro) + min(t1, t2))){\n\n                d = t44.x;\n                gN = t44.yzw;\n                gN = -sign(rd)*step(gN.yzx, gN)*step(gN.zxy, gN);\n                svIP = ipJ;\n                gMa = ma;\n   \n            }\n        \n        }\n       \n \n        gDist.x = d; \n     \n        // We've hit a box, so return.\n        if(d<FAR) { hit = 1; gObjID = 1.; return vec4(d, 0, svIP); }\n\n        // Determine the closest edge then record the closest distance and\n        // asign its normal index.\n        vec3 tn = t1<t2? vec3(t1, n1) : vec3(t2, n2);\n\n        \n        // Advance the cell index position by the indices of the \n        // cell wall normal that you hit. \n        ip += tn.yz;\n        // Advance the ray position by the distance to the next cell wall.\n        pos += rd*tn.x;\n    \n    }\n    \n    \n  /*  \n    float fID = tT<t1 && tT<t2? 0. : t1<t2? 1. : 2.;\n    if(fID == 1.){ fID = dot(rd.xz, vec2(-1, 0))<0.? -fID : fID; }\n    else if(fID == 2.){ fID = dot(rd.xz, vec2(0, -1))<0.? -fID : fID; }\n    \n    \n    \n    res.x = length(pos - ro);*/\n    \n    // Top face distance.\n    //float tB = (.0 - ro.y)/rd.y;\n    //if (tB>=0.){ gN = vec3(0, 1, 0); gObjID = 0.; return vec4(tB, 0, vec2(0)); }\n \n    // No hit, so return the far plane.\n    if(hit == 0) res.x = FAR;\n    \n    float fID = -1.;\n    return vec4(res.x, fID, ip);\n    \n}\n\n// Standard normal function.\nvec3 nr(float fID, vec3 rd) {\n\t\n    vec3 n = fID == 0.? vec3(0, 1, 0) : abs(fID) == 1.? vec3(1, 0, 0) : vec3(0, 0, 1);\n    n *= fID<-.001? -1. : 1.; \n\treturn n;\n}\n\n///////\n\nfloat surface(vec3 p){\n\n    // Very cheap sinusoidal water effect.\n    vec3 q = p*3.;\n    float t = iTime;\n    float wat = dot(sin(q + vec3(t*.75, 0, 0) - cos(q.yzx*2. - vec3(0, t, 0))*2.), vec3(.333));\n    q.xy *= rot2(3.14159/4.)*2.;\n    float wat2 = dot(sin(q + vec3(t*.75*2., 0, 0) - cos(q.yzx*2. - vec3(0, t*2., 0))*2.), vec3(.333));\n    wat = mix(wat, wat2, 1./3.);\n    \n    // For anyone not familiar, abs(x*x + a) is a smooth absolute function trick.\n    // In this case, it's used to subtly smooth off the crests of the waves.\n    return 1. - sqrt(wat*wat*.98 + .02);\n}\n\nfloat bObjID;\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n    \n    // Water surface bump map only.\n    return surface(p);\n    \n    /*\n    // Water surface bump map.\n    if(bObjID<.5) return surface(p);\n    else {\n        // More subtle texture based bump mapping on the blocks.\n        vec2 uv = abs(n.y) > .5? p.xz : abs(n.x)>.5 ? p.zy : p.xy;\n        vec3 tx = texture(iChannel1, uv).xyz; tx *= tx;\n        return dot(tx, vec3(.299, .587, .114));\n    }\n    */\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p, n);\n    \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, n),\n                      bumpSurf3D(p - e.yxy, n),\n                      bumpSurf3D(p - e.yyx, n)) - ref)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n///////\n\nvoid mainImage( out vec4 c, vec2 u )\n{\n    \n    // Unit direction vector, camera (moving along Z), and point light (above the camera).\n    // A \"to\" and \"from\" camera system is better, and only requires a few more lines, but\n    // we're keeping things simple.\n    vec3 r = normalize(vec3(u - iResolution.xy*.5, iResolution.y*2.5)), \n         o = vec3(iTime, 2, iTime*.25), l = o + vec3(-1, 4, 12);\n    \n    \n    \n    // Rotating the unit direction ray, for a bit of visual interest.\n    r.xz = rot2(.5)*r.xz;\n    r.xy = rot2(.1)*r.xy;\n    r.yz = rot2(-.25)*r.yz;\n\n    // Raycasting\n    vec4 res = raycast(o, r, 160);\n    \n     \n    float t = res.x; // Ray distance.\n    float fID = res.y; // Face ID.\n    vec2 id = res.zw; // Block position ID.\n    \n    float objID = gObjID; // Scene object ID: Blocks or water.\n    bObjID = gObjID; // Bump object ID: Something I've hacked in at the last minute. \n    \n    // Object height.\n    float h = hm(id*s);\n    \n    t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n    \n    // Scene color, initialized to zero.\n    c = vec4(0);\n    \n    // If we've hit an object, light it up.\n    if(t<FAR){\n    \n        // Hit position and normal.\n        vec3 p = o + r*t, n = gN;//nr(fID, r);\n \n        if(objID<.5) n = doBumpMap(p, n, .01);\n\n        // Point light.\n        //l -= p; // Light to surface vector. Ie: Light direction vector.\n        //float d = max(length(l), 0.001); // Light to surface distance.\n        //l /= d; // Normalizing the light direction vector.\n        \n        // Directional light.\n        l = normalize(vec3(-.8, .25, .9)); \n        \n        // Diffuse.\n        float dif = max(dot(l, n), 0.);\n        \n        // Shadows.\n        float sh = 0.;\n        if(dif>0.){\n           vec4 resSh = raycast(p + n*.002, l, 64);\n           \n           if(resSh.x>FAR - 1e-3) sh = 1.; //\n           //if(resSh.x>d - 1e-3) sh = 1.; // Point light.\n           \n        }\n         \n         \n\n        // Scene object color.\n        //\n        // UV coordinates.\n        //vec2 uv = fID == 0.? p.xz : abs(fID) == 1.? p.zy : p.xy;\n        vec2 uv = abs(n.y) > .5? p.xz : abs(n.x)>.5 ? p.zy : p.xy;\n        //\n        // Texture color.\n        vec3 tx = texture(iChannel1, rot2(3.14159/1.)*uv/2.).xyz; tx *= tx;\n        vec3 tx2 = texture(iChannel1, rot2(-3.14159/1.)*uv/1. + .5).xyz; tx2 *= tx2;\n        tx = mix(tx, tx2, .5);\n        //\n        c.xyz = .05 + tx*1.5;\n        \n        // Random Earth tone coloring.\n        vec3 bCol = .65 + .3*cos(6.2831*hash21(id + .04)/3. + vec3(0, 1, 2) - .5);\n        //vec3 bCol = .65 + .3*cos(6.2831*id.y*s.y/8. + vec3(0, 1, 2)*1.5 - 1.);\n        c.xyz *= bCol*1.5;\n        // Applying a little river weathering to the blocks -- Obviously more\n        // to the surfaces that are closer to the water level.\n        const vec3 wCol = vec3(.7, 1, .9);\n        c.xyz *= mix(vec3(1), wCol*1.1, tx*clamp(1. - p.y/h, 0., 1.));//\n\n        \n        vec3 c2 = wCol*(tx*.5 + .5);\n   \n        if(objID<.5) c.xyz = c2;\n       \n\n       \n        // Fake water level shore line AO. I'll look for a better way, but\n        // this is cheap and it works well enough for this example.\n        if(p.y<.1){//objID<.5\n       \n           // Raytrace just above water level for a few cells in the direction of \n           // the unit ray, and if you hit a block, you're near enough to it to\n           // be occluded... That's my story and I'm sticking to it. :D\n           vec4 resR = raycast(p + n*.002, normalize(vec3(r.x, 0, r.z)), 8);\n           resR.x = max(resR.x - .15, p.y-.05);\n           \n           c.xyz = mix(c.xyz, c2/2., 1. - smoothstep(-.1, .1, resR.x));// - .25\n       \n        }\n        \n        // IQ's rim lighting snippet: For anyone not familiar, he's using \n        // the Fresnel factor for some sillouette lighting.\n        float rim = pow(clamp(1. + dot(r, n), 0., 1.), 5.);\n        \n         \n        // Specular reflection. \n        //float spe = pow(clamp(dot(l, reflect(r, n)), 0., 1.), 8.);\n        float spe = pow(clamp(dot(reflect(l, n), r), 0., 1.), 8.);\n        \n       \n        // AO routine. Hacked together from one of IQ's old routines.\n        // I started this example a while ago, so I don't think it's\n        // complete. I'll need to take a proper look later.\n        vec2 p2 = (p.xz - id*s);\n        float h0 = hm(id*s);\n        float py = (1. - smoothstep(0., 1., -p.y + h0));\n        vec4 h4 = vec4(hm((id + vec2(-1, 0))*s), hm((id + vec2(1, 0))*s), \n                       hm((id + vec2(0, -1))*s), hm((id + vec2(0, 1))*s));\n                       \n        vec4 h4mh0 = h4 - h0;\n        \n        float ao = 1.;\n        float minEdge = min(s.x, s.y)/4.;\n        float edge = s.y/4.;\n        float edge2 = s.x/4.;\n        \n        float aoSh = .5;\n        if(n.y>.5){\n            if(p2.y>minEdge && h4mh0.w>0.) ao = min(ao, 1. - smoothstep(0., 1., (p2.y - edge)/edge)*aoSh);\n            if(p2.y<-minEdge && h4mh0.z>0.) ao = min(ao, 1. - smoothstep(0., 1., (-p2.y - edge)/edge)*aoSh);\n            if(p2.x<-minEdge && h4mh0.x>0.) ao = min(ao, 1. - smoothstep(0., 1., (-p2.x - edge2)/edge2)*aoSh);\n            if(p2.x>minEdge && h4mh0.y>0.) ao = min(ao, 1. - smoothstep(0., 1., (p2.x - edge2)/edge2)*aoSh);\n        }\n        else {\n            \n            vec4 mEdge4 = vec4(minEdge) - (h4 - h0)/2.;\n            vec4 hp = p.y - h4 - mEdge4;\n            \n            if(n.z<-.5 && hp.z<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.z)/(mEdge4.z))*aoSh);\n            if(n.z>.5  && hp.w<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.w)/(mEdge4.w))*aoSh);\n            if(n.x<-.5 && hp.x<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.x)/(mEdge4.x))*aoSh);\n            if(n.x>.5 && hp.y<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.y)/(mEdge4.y))*aoSh);\n             \n        }\n        ao = max(ao, 0.);\n       \n        \n        //////////////////\n\n        // Last minute edge routine. I've returned the nearest rectangle ID\n        // and dimensions from the \"raycasting\" routine, and the rest \n        // figures itself out.\n        vec2 ipJ = id;\n        float ma = h0;\n        vec2 w = (hash22(ipJ + .21)*.8 + .05)*s;\n        p2 = (p.xz - id*s); // Local coordinates.\n        float rct = abs(max(abs(p2.x) - w.x, abs(p2.y) - w.y));\n        float topEdge = max(abs(p.y - ma), rct);\n        float sideEdge = abs(abs(p2.x) - w.x);\n        sideEdge = max(sideEdge, abs(abs(p2.y) - w.y));\n        float objEdge = min(topEdge, sideEdge) - .006;\n\n        // Rendering light and dark edges.\n        //c.xyz = mix(c.xyz, vec3(0), 1. - smoothstep(0., 2./iResolution.y, length(p2) - .02));\n        c.xyz = mix(c.xyz, c.xyz*1.5, 1. - smoothstep(0., 2./iResolution.y, objEdge - .006));\n        c.xyz = mix(c.xyz, c.xyz/1.5/2., 1. - smoothstep(0., 2./iResolution.y, objEdge));\n\n        ///////////////////// \n        \n        // Applying diffuse lighting, ambient lighting, and attenuation.\n        c.xyz = c.xyz*(dif*sh + vec3(1, .2, .1)*spe*sh*4. + vec3(.5, .7, 1).zyx*rim*1. + .25);\n        \n        // Applying ambient occlusion.\n        c.xyz *= ao;\n  \n        // Reflections: It's based on one of IQ's nice looking reflective\n        // pass shortcuts. Not quite as realistic as proper object and sky coloring,\n        // but really effective for scenarios like these.\n        vec3 ref = reflect(r, n);\n        vec4 resRef = raycast(p + n*.001, ref, 64); // Note the fewer iterations.\n        vec3 refTx = texture(iChannel3, ref).xyz; refTx *= refTx;\n        if(resRef.x<FAR - 1e-3) refTx *= 0.;\n        // Fresnel reflection.\n        float fr = mix(.03, .25, pow(max(0., 1. + dot(r, n)), 3.));\n        if(objID<.5) refTx *= 2.; // More reflection on the water.\n        c.xyz = mix(c.xyz, refTx, fr);\n        // Alternate reflections. Gives it a cartoonish look.\n        //c.xyz += c.xyz*refTx*2.;  \n        \n    }\n    \n    // Applying horizon fog.\n    c = mix(clamp(c, 0., 1.), vec4(.87, .95, .95, 0), smoothstep(0., .99, t*t/FAR/FAR));\n    \n    // Subtle vignette.\n    u /= iResolution.xy;\n    c *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n    \n    // Very subtle tone mapping, which can sometimes even things out.\n    //c *= 1.1/(1. + c*.2);\n    \n    // Rough gamma correction. The short explanation is that that if you don't do\n    // this, all your colors and shades will be wrong. :)\n    c = vec4(sqrt(clamp(c.xyz, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2979, 3012, 3034, 3034, 3092], [3094, 3122, 3143, 3143, 3206], [3208, 3235, 3256, 3256, 3408], [3608, 3666, 3714, 3926, 3966], [3968, 3991, 4011, 4069, 4100], [4103, 4103, 4120, 4151, 4431], [4433, 4502, 4553, 4581, 4893], [4932, 4932, 4974, 4974, 9627], [9629, 9658, 9687, 9687, 9820], [9831, 9831, 9853, 9897, 10409], [10425, 10452, 10491, 10532, 10897], [10899, 11090, 11145, 11246, 12238], [12248, 12248, 12286, 12508, 20634]], "test": "untested"}
{"id": "ftByWc", "name": "mackjam_ap", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 2, "viewed": 429, "published": 3, "date": "1650871757", "time_retrieved": "2024-07-30T16:51:36.593359", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n#define iTime iTime*.5\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 0.);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    l.xy *= r2d(iTime);\n    float cube = max(max(l.x, l.y), l.z);\n      th.xy *= r2d(iTime);\n\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  p.xz *= r2d(iTime);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*.01;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 5.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  \n\n//  pcc.xz *= r2d(iTime);\n  pcc.xz = abs(pcc.xz);\n  //pcc.xz *= r2d(iTime);\n  //pcc.yz *= r2d(.5*iTime);\n  pcc.y = mod(pcc.y+repyc*.5, repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 2.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/15.5))*.5*sat(sin(p.y*.05+5.*iTime));\n    rd = normalize(rd+normalize(p)*.1);\n    p+=rd*res.x*.25;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = (vec3(212, 140, 32)/255.).zxy;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*1.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.).zxy*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, background, 1.-sat(exp(-depth*depth*0.001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*1.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  vec2 ouv2 = uv;\n  vec2 ouv = uv;\n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n  //uv *= r2d(sin(mix(lenny(uv), length(uv), -2.)*15.-iTime));\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n    uv2 *= r2d(.01*iTime);\n  uv2 = abs(uv2);\n  //uv *= r2d(FFTI(.1)*10.);\n  //uv = abs(uv);\n  //uv -= vec2(.25);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.1)*1.;\n  col += rdr(uv2)*.25;\n  col *= 1.-sat(length(uv));\n  //col = mix(vec3(0.), vec3(199, 242, 58)/255., col*.4);\n  col = pow(col, vec3(2.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n//  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  float repy = .05;\n  float idy = floor((ouv.y+repy*.5)/repy);\n  col = mix(col, col.zxy, mod(idy+float(int(iTime*8.)),5.)/5.);\n\ncol = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n  ouv *= r2d(ouv.x*5.*sin(iTime*.5));\n  ouv.y += iTime*2.1;\n  col = mix(col, col.zxy, sat((min(sin(ouv.y*100.), sin(ouv.x*100.))+.97)*5.));\n  \n  float repx = .1;\n  ouv2.x = abs(ouv2.x);\n  float idx = floor((ouv2.x+repx*.5)/repx);\n  col *= 1.-sat((abs(ouv2.y)-.1-FFTS(idx/10.))*10.);\n  \n\tfragColor = vec4(col.yxz, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28793, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftByWc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "NlSyWc", "name": "mackjam_ao", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 2, "viewed": 283, "published": 3, "date": "1650871753", "time_retrieved": "2024-07-30T16:51:37.418154", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define iTime iTime*.5\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 0.);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    l.xy *= r2d(iTime);\n    float cube = max(max(l.x, l.y), l.z);\n      th.xy *= r2d(iTime);\n\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  p.xz *= r2d(iTime);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*.01;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 5.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  \n\n//  pcc.xz *= r2d(iTime);\n  pcc.xz = abs(pcc.xz);\n  //pcc.xz *= r2d(iTime);\n  //pcc.yz *= r2d(.5*iTime);\n  pcc.y = mod(pcc.y+repyc*.5, repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 2.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/15.5))*.5*sat(sin(p.y*.05+5.*iTime));\n    rd = normalize(rd+normalize(p)*.1);\n    p+=rd*res.x*.25;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = (vec3(212, 140, 32)/255.).zxy;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*1.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.).zxy*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, background, 1.-sat(exp(-depth*depth*0.001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*1.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  vec2 ouv = uv;\n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n  //uv *= r2d(sin(mix(lenny(uv), length(uv), -2.)*15.-iTime));\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n    uv2 *= r2d(.01*iTime);\n  uv2 = abs(uv2);\n  //uv *= r2d(FFTI(.1)*10.);\n  //uv = abs(uv);\n  //uv -= vec2(.25);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.1)*1.;\n  col += rdr(uv2)*.25;\n  col *= 1.-sat(length(uv));\n  //col = mix(vec3(0.), vec3(199, 242, 58)/255., col*.4);\n  col = pow(col, vec3(2.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n//  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  float repy = .05;\n  float idy = floor((ouv.y+repy*.5)/repy);\n  col = mix(col, col.zxy, mod(idy+float(int(iTime*8.)),5.)/5.);\n\ncol = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n  ouv *= r2d(ouv.x*5.*sin(iTime*.5));\n  ouv.y += iTime*2.1;\n  col = mix(col, col.zxy, sat((min(sin(ouv.y*100.), sin(ouv.x*100.))+.97)*5.));\n  \n\tfragColor = vec4(col.yxz, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28792, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSyWc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "flfBW4", "name": "simple_color_waves", "author": "dwberns", "description": "first shader ever", "tags": ["first", "colorwaves"], "likes": 2, "viewed": 206, "published": 3, "date": "1650849325", "time_retrieved": "2024-07-30T16:51:38.281844", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(3.0 * iTime+uv.xyx+vec3(0,2,4))*cos(5.0 * iTime+uv.xyx+vec3(2,3,-1));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 337]], "test": "untested"}
{"id": "7tsfDH", "name": "Sphere Slicing", "author": "shyshokayu", "description": "Another blessing...", "tags": ["loop", "gif", "seamless", "satisfying", "original"], "likes": 19, "viewed": 355, "published": 3, "date": "1650845194", "time_retrieved": "2024-07-30T16:51:40.390207", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define RAY_MAX_ITERATIONS 100\n#define RAY_MAX_DISTANCE 100.0\n#define RAY_SURF_DISTANCE 0.0001\n\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\nfloat sine(float t) { return sin(t * PI); }\nfloat cose(float t) { return cos(t * PI); }\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nmat2 rote(float r) {\n    return rot(r * PI);\n}\n\nmat3 rotX(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c  , -s ,\n        0.0, s  , c\n    );\n}\n\nmat3 rotY(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , 0.0, -s ,\n        0.0, 1.0, 0.0,\n        s  , 0.0, c\n    );\n}\n\nmat3 rotZ(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , -s , 0.0,\n        s  , c  , 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 roteX(float r) {\n    return rotX(r * PI);\n}\n\nmat3 roteY(float r) {\n    return rotY(r * PI);\n}\n\nmat3 roteZ(float r) {\n    return rotZ(r * PI);\n}\n\n#define range(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(range(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define distanceSqr(v) dot(v, v)\n\nfloat easeIn(float x) {\n    return x * x;\n}\n\nfloat easeOut(float x) {\n    return 1.0 - easeIn(1.0 - x);\n}\n\nfloat easeInOut(float x) {\n    return mix(easeIn(x), easeOut(x), x);\n}\n\nfloat easeIn(float a, float b, float x) {\n    return easeIn(linearstep(a, b, x));\n}\n\nfloat easeOut(float a, float b, float x) {\n    return easeOut(linearstep(a, b, x));\n}\n\nfloat easeInOut(float a, float b, float x) {\n    return easeInOut(linearstep(a, b, x));\n}\n\nfloat sdPlane(vec3 p, float y) {\n    return p.y - y;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, float t, float r) {\n  return length(vec2(length(p.xz) - t, p.y)) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nstruct mapresult {\n    float d;\n    int m;\n};\n\nmapresult map(vec3 p) {\n    float d = RAY_MAX_DISTANCE;\n    int m = 0;\n    \n    float sd;\n    \n    // Time loop control\n    float tx = iTime * 0.25;\n    float ti = floor(tx);\n    float tf = tx - ti;\n\n    float slicedFactor = step(tf, 1.0 - 0.25); // 1.0 if slicing is complete, 0.0 otherwise.\n\n    // Ball\n    {\n        vec3 o = vec3(0.0);\n\n        o.x = -16.0;\n        o.x += 16.0 * easeOut(0.0, 0.5, tf);\n        o.x += 12.0 * easeOut(0.75, 1.0, tf);\n\n        o.y = 0.0;\n        o.y += -8.0 * easeIn(0.75, 1.0, tf);\n\n        vec3 po = p - o;\n\n        sd = sdSphere(po, 1.0);\n        if(sd < d) {\n            d = sd;\n            m = 2;\n        }\n        \n        // Keep the sliced detail\n        po.xy *= rote(iTime);\n        sd = -sdBox(po, vec3(0.0625, 4.0, 4.0));\n        sd = mix(sd, 0.0, slicedFactor);\n        if(sd >= d) {\n            d = sd;\n            m = 2;\n        }\n    }\n    \n    // Slicer\n    {\n        vec3 originp = p;\n        originp -= vec3(0.0, 0.0, 2.0);\n        originp.yz *= rote(tf - 0.125);\n    \n        // Cut out ball\n        sd = -sdBox(originp - vec3(0.0, 4.0, 4.0), vec3(0.0625, 4.0, 4.0));\n        sd = mix(0.0, sd, slicedFactor);\n        if(sd >= d) {\n            d = sd;\n            m = 2;\n        }\n        \n        sd = sdCappedCylinder(originp - vec3(0.0, 0.0, 0.0), 4.0, 0.0625);\n        sd = min(sd, sdCappedCylinder(originp.yxz - vec3(0.0, -16.0 + 0.125, 0.0), 16.0, 0.09375));\n        if(sd < d) {\n            d = sd;\n            m = 3;\n        }\n    }\n    \n    // Path\n    {\n        sd = sdBox(p - vec3(-8.0 - 0.0625, -10.125, 0.0), vec3(8.0, 10.0, 16.0) - 0.0625);\n        sd -= 0.0625;\n        sd = max(sd, -sdCappedCylinder(p.yxz - vec3(0.0, -8.0, 0.0), 9.0, 1.0));\n        if(sd < d) {\n            d = sd;\n            m = 1;\n        }\n    }\n    \n    // Pusher\n    {\n        vec3 o = vec3(0.0);\n        o.x = -20.0;\n        o.x += -8.0;\n        o.x -= 1.0;\n        o.x += 16.0 * easeOut(0.0, 0.5, tf);\n        o.x += 4.0 * easeInOut(0.625, 0.5, tf);\n        o.x += 4.2 * easeIn(0.625, 0.75, tf);\n        o.x += -24.0 * easeIn(0.75, 1.0, tf);\n    \n        sd = sdCappedCylinder(p.yxz - o.yxz, 8.0, 0.25);\n        if(sd < d) {\n            d = sd;\n            m = 3;\n        }\n        \n        sd = sdCappedCylinder(p.yxz - o.yxz - vec3(0.0, 8.0 - 0.125, 0.0), 0.125, 0.5);\n        if(sd < d) {\n            d = sd;\n            m = 3;\n        }\n    }\n    \n    return mapresult(d, m);\n}\n\nmapresult march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    int m = 0;\n    for(int i = 0; i < RAY_MAX_ITERATIONS; i++) {\n        mapresult mr = map(ro + (rd * d));\n        float sd = mr.d;\n        d += sd;\n        m = mr.m;\n        if(d > RAY_MAX_DISTANCE) return mapresult(RAY_MAX_DISTANCE, 0);\n        if(abs(sd) < RAY_SURF_DISTANCE) break;\n    }\n    return mapresult(d, m);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(RAY_SURF_DISTANCE * 2.0, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).d - map(p - e.xyy).d,\n        map(p + e.yxy).d - map(p - e.yxy).d,\n        map(p + e.yyx).d - map(p - e.yyx).d\n    ));\n}\n\nfloat shadow(vec3 origin, vec3 dir) {\n    return step(RAY_MAX_DISTANCE, march(origin, dir).d);\n}\n\nfloat directionalLightShaded(vec3 origin, vec3 direction, vec3 normal) {\n    return dot(normal, direction) * shadow(origin + ((normal * RAY_SURF_DISTANCE) * 2.0), direction);\n}\n\nvec3 sky(vec3 rd, vec3 sunDir) {\n    float sun = dot(rd, sunDir);\n    float sunk = (sun * 0.5) + 0.5;\n    float suna = pow(sunk, 4.0);\n    float sunb = pow(suna, 32.0);\n\n    vec3 skyColorOut = mix(vec3(0.6, 0.6, 0.7), vec3(3.0, 1.5, 0.7), suna);\n    skyColorOut = mix(skyColorOut, vec3(5.0, 4.0, 2.5), sunb);\n    skyColorOut = mix(skyColorOut, vec3(8.0, 6.0, 4.0), smoothstep(0.9997, 0.9998, sunk));\n\n    float m = 1.0 - pow(1.0 - max(rd.y, 0.0), 4.0);\n\n    return skyColorOut;\n}\n\nvec3 aces(vec3 x) {\n    return clamp((x * ((2.51 * x) + 0.03)) / (x * ((2.43 * x) + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float aspect = max(iResolution.x / iResolution.y, iResolution.y / iResolution.x);\n    vec2 uv = (fragCoord / iResolution.xy) - 0.5;\n    uv.x *= aspect;\n    uv *= 2.0;\n    \n    vec3 ro = vec3(0.0, 0.0, -10.0);\n    vec3 rd = normalize(vec3(0.0, 0.0, 1.0));\n    ro.xy += uv * 5.0; // Ortho projection\n\n    mat3 rotation =\n        roteX(0.125) *\n        roteY(0.25);\n    \n    ro *= rotation;\n    rd *= rotation;\n\n    mapresult mr = march(ro, rd);\n    float d = mr.d;\n    int m = mr.m;\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float skyFactor = d / RAY_MAX_DISTANCE;\n    \n    vec3 sunDir = normalize(vec3(0.5, 0.9, 0.5));\n    \n    vec3 skyColor = sky(rd, sunDir);\n    \n    vec3 surfaceColor = vec3(0.0);\n\n    // Path\n    if(m == 1) {\n        surfaceColor = vec3(0.0);\n    }\n    // Ball\n    else if(m == 2) {\n        surfaceColor = vec3(0.3);\n    }\n    // Other stuff\n    else if(m == 3) {\n        surfaceColor = vec3(-0.25);\n    }\n    \n    vec3 surfaceReflColor = vec3(0.0);\n    for(int i = 0; i < 30; i++) {\n        float seed = texture(iChannel3, vec2(iTime, float(i) * 0.62842)).x;\n        vec3 rdRefl = reflect(rd, n);\n        rdRefl = normalize(rdRefl + ((texture(iChannel3, vec2(p.x + p.z, p.y + p.z) + seed).xyz - 0.5) * 2.0) * 2.0);\n        surfaceReflColor += sky(rdRefl, sunDir);\n    }\n    surfaceReflColor /= 30.0;\n    surfaceColor += surfaceReflColor;\n\n    surfaceColor *= mix(directionalLightShaded(p, sunDir, n), 1.0, 0.5);\n    \n    col = mix(\n        surfaceColor,\n        skyColor,\n        skyFactor\n    );\n    \n    col = aces(col);\n    \n    col *= steprange(-1.0, 1.0, uv.x);\n    col *= steprange(-1.0, 1.0, uv.y);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsfDH.jpg", "access": "api", "license": "mit", "functions": [[1301, 1301, 1322, 1322, 1344], [1345, 1345, 1366, 1366, 1388], [1390, 1390, 1409, 1409, 1475], [1477, 1477, 1497, 1497, 1523], [1525, 1525, 1545, 1545, 1671], [1673, 1673, 1693, 1693, 1819], [1821, 1821, 1841, 1841, 1969], [1971, 1971, 1992, 1992, 2019], [2021, 2021, 2042, 2042, 2069], [2071, 2071, 2092, 2092, 2119], [2398, 2398, 2421, 2421, 2441], [2443, 2443, 2467, 2467, 2503], [2505, 2505, 2531, 2531, 2575], [2577, 2577, 2618, 2618, 2660], [2662, 2662, 2704, 2704, 2747], [2749, 2749, 2793, 2793, 2838], [2840, 2840, 2872, 2872, 2894], [2896, 2896, 2929, 2929, 2957], [2959, 2959, 3000, 3000, 3052], [3054, 3054, 3104, 3104, 3220], [3222, 3222, 3251, 3251, 3346], [3395, 3395, 3418, 3418, 5822], [5824, 5824, 5859, 5859, 6201], [6203, 6203, 6224, 6224, 6444], [6446, 6446, 6483, 6483, 6542], [6544, 6544, 6616, 6616, 6720], [6722, 6722, 6754, 6754, 7201], [7203, 7203, 7222, 7222, 7314], [7316, 7316, 7368, 7368, 9095]], "test": "untested"}
{"id": "stlBWH", "name": "Marble Satisfaction", "author": "shyshokayu", "description": "My first submission...", "tags": ["marble", "satisfying", "perfect"], "likes": 13, "viewed": 291, "published": 3, "date": "1650829305", "time_retrieved": "2024-07-30T16:51:41.287807", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n#define RAY_MAX_ITERATIONS 100\n#define RAY_MAX_DISTANCE 100.0\n#define RAY_SURF_DISTANCE 0.0001\n\n#define RINGS 6.0\n\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\nfloat sine(float t) { return sin(t * PI); }\nfloat cose(float t) { return cos(t * PI); }\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nmat2 rote(float r) {\n    return rot(r * PI);\n}\n\nmat3 rotX(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c  , -s ,\n        0.0, s  , c\n    );\n}\n\nmat3 rotY(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , 0.0, -s ,\n        0.0, 1.0, 0.0,\n        s  , 0.0, c\n    );\n}\n\nmat3 rotZ(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , -s , 0.0,\n        s  , c  , 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 roteX(float r) {\n    return rotX(r * PI);\n}\n\nmat3 roteY(float r) {\n    return rotY(r * PI);\n}\n\nmat3 roteZ(float r) {\n    return rotZ(r * PI);\n}\n\nfloat sdPlane(vec3 p, float y) {\n    return p.y - y;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, float t, float r) {\n  return length(vec2(length(p.xz) - t, p.y)) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nstruct mapresult {\n    float d;\n    int m;\n};\n\nmapresult map(vec3 p) {\n    float d = RAY_MAX_DISTANCE;\n    int m = 0;\n    \n    float sd = sdCappedCylinder(p - vec3(0.0, -20.0, 0.0), 2.5, 20.0);\n    if(sd < d) {\n        d = sd;\n        m = 1;\n    }\n    \n    float tsk = iTime / (RINGS * 0.5);\n    sd = sdSphere(p - vec3(sine(tsk) * 2.0, abs(cose(iTime)) + 0.25, cose(tsk) * 2.0), 0.25);\n    if(sd < d) {\n        d = sd;\n        m = 2;\n    }\n    \n    float r = atan(p.x, p.z);\n    r /= TAU;\n    r = fract(r + (0.5 / RINGS)) - (0.5 / RINGS);\n    r = round(r * RINGS) / RINGS;\n    float y = abs(sine((iTime / RINGS) - r));\n    vec2 po = p.xz * rote(r * 2.0);\n    \n    sd = -sdCappedCylinder(vec3(po.x, p.y, po.y) - vec3(0.0, -0.015, 2.0), 0.0625, 0.03);\n    if(sd >= d) {\n        d = sd;\n        m = 1;\n    }\n    \n    sd = min(\n        sdTorus(vec3(po.y, po.x, p.y) - vec3(2.0, 0.0, 1.25 + y), 0.25 + 0.0625, 0.0625),\n        sdCappedCylinder(vec3(po.x, p.y, po.y) - vec3(0.0, (0.5 - 0.0625) + y, 2.0), 0.0625, 0.5)\n    );\n    \n    if(sd < d) {\n        d = sd;\n        m = 3;\n    }\n    \n    return mapresult(d, m);\n}\n\nmapresult march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    int m = 0;\n    for(int i = 0; i < RAY_MAX_ITERATIONS; i++) {\n        mapresult mr = map(ro + (rd * d));\n        float sd = mr.d;\n        d += sd;\n        m = mr.m;\n        if(d > RAY_MAX_DISTANCE) return mapresult(RAY_MAX_DISTANCE, 0);\n        if(abs(sd) < RAY_SURF_DISTANCE) break;\n    }\n    return mapresult(d, m);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(RAY_SURF_DISTANCE * 2.0, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).d - map(p - e.xyy).d,\n        map(p + e.yxy).d - map(p - e.yxy).d,\n        map(p + e.yyx).d - map(p - e.yyx).d\n    ));\n}\n\nfloat shadow(vec3 origin, vec3 dir) {\n    return step(RAY_MAX_DISTANCE, march(origin, dir).d);\n}\n\nfloat directionalLightShaded(vec3 origin, vec3 direction, vec3 normal) {\n    return dot(normal, direction) * shadow(origin + ((normal * RAY_SURF_DISTANCE) * 2.0), direction);\n}\n\nvec3 sky(vec3 rd, vec3 sunDir) {\n    float sun = dot(rd, sunDir);\n    float sunk = (sun * 0.5) + 0.5;\n    float suna = pow(sunk, 4.0);\n    float sunb = pow(suna, 32.0);\n\n    vec3 skyColorOut = mix(vec3(0.5, 0.6, 0.7), vec3(3.0, 1.5, 0.7), suna);\n    skyColorOut = mix(skyColorOut, vec3(5.0, 4.0, 2.5), sunb);\n    skyColorOut = mix(skyColorOut, vec3(8.0, 6.0, 4.0), smoothstep(0.9997, 0.9998, sunk));\n\n    float m = 1.0 - pow(1.0 - max(rd.y, 0.0), 4.0);\n\n    return skyColorOut;\n}\n\nvec3 aces(vec3 x) {\n    return clamp((x * ((2.51 * x) + 0.03)) / (x * ((2.43 * x) + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float aspect = max(iResolution.x / iResolution.y, iResolution.y / iResolution.x);\n    vec2 uv = (fragCoord / iResolution.xy) - 0.5;\n    uv.x *= aspect;\n    uv *= 2.0;\n    \n    vec3 ro = vec3(0.0, 0.5, -5.0);\n    vec3 rd = normalize(vec3(uv, 1.6));\n\n    mat3 rotation =\n        roteX(0.125) *\n        roteY(iTime * 0.0625 * 0.25);\n    \n    ro *= rotation;\n    rd *= rotation;\n\n    mapresult mr = march(ro, rd);\n    float d = mr.d;\n    int m = mr.m;\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float skyFactor = d / RAY_MAX_DISTANCE;\n    \n    vec3 sunDir = normalize(vec3(0.5, 0.25, 0.5));\n    \n    vec3 skyColor = sky(rd, sunDir);\n    \n    vec3 surfaceColor = vec3(0.0);\n\n    // I know this is some strange stuff, but it looks good, so don't touch it.\n    if(m == 1) {\n        surfaceColor = mix(vec3(0.0, 0.0, 0.0), vec3(0.7, 0.7, 0.7), fract((floor(p.x) + floor(p.z)) * 0.5));\n        \n        vec3 surfaceReflColor = vec3(0.0);\n        for(int i = 0; i < 30; i++) {\n            float seed = texture(iChannel3, vec2(iTime, float(i) * 0.62842)).x;\n            vec3 rdRefl = reflect(rd, n);\n            rdRefl = normalize(rdRefl + ((texture(iChannel3, vec2(p.x + p.z, p.y + p.z) + seed).xyz - 0.5) * 2.0) * 3.0);\n            surfaceReflColor += sky(rdRefl, sunDir);\n        }\n        surfaceReflColor /= 30.0;\n        surfaceColor += surfaceReflColor;\n    }\n    else if(m == 2) {\n        surfaceColor = vec3(2.0);\n        surfaceColor += sky(reflect(rd, n), sunDir);\n    }\n    else if(m == 3) {\n        surfaceColor = vec3(-0.25);\n        \n        vec3 surfaceReflColor = vec3(0.0);\n        for(int i = 0; i < 5; i++) {\n            float seed = texture(iChannel3, vec2(iTime, float(i) * 0.62842)).x;\n            vec3 rdRefl = reflect(rd, n);\n            rdRefl = normalize(rdRefl + ((texture(iChannel3, vec2(p.x + p.z, p.y + p.z) + seed).xyz - 0.5) * 2.0) * 0.75);\n            surfaceReflColor += sky(rdRefl, sunDir);\n        }\n        surfaceReflColor /= 5.0;\n        surfaceColor += surfaceReflColor;\n    }\n    \n    surfaceColor *= mix(directionalLightShaded(p, sunDir, n), 1.0, 0.5);\n    \n    col = mix(\n        surfaceColor,\n        skyColor,\n        skyFactor\n    );\n    \n    col = aces(col);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlBWH.jpg", "access": "api", "license": "mit", "functions": [[1320, 1320, 1341, 1341, 1363], [1364, 1364, 1385, 1385, 1407], [1409, 1409, 1428, 1428, 1494], [1496, 1496, 1516, 1516, 1542], [1544, 1544, 1564, 1564, 1690], [1692, 1692, 1712, 1712, 1838], [1840, 1840, 1860, 1860, 1988], [1990, 1990, 2011, 2011, 2038], [2040, 2040, 2061, 2061, 2088], [2090, 2090, 2111, 2111, 2138], [2140, 2140, 2172, 2172, 2194], [2196, 2196, 2229, 2229, 2257], [2259, 2259, 2300, 2300, 2352], [2354, 2354, 2404, 2404, 2520], [2569, 2569, 2592, 2592, 3634], [3636, 3636, 3671, 3671, 4013], [4015, 4015, 4036, 4036, 4256], [4258, 4258, 4295, 4295, 4354], [4356, 4356, 4428, 4428, 4532], [4534, 4534, 4566, 4566, 5013], [5015, 5015, 5034, 5034, 5126], [5128, 5128, 5180, 5180, 7474]], "test": "untested"}
{"id": "NtSyWc", "name": "mackjam_an", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 2, "viewed": 377, "published": 3, "date": "1650811425", "time_retrieved": "2024-07-30T16:51:42.090661", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 0.);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    l.xy *= r2d(iTime);\n    float cube = max(max(l.x, l.y), l.z);\n      th.xy *= r2d(iTime);\n\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  p.xz *= r2d(iTime);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*.01;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 5.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  \n\n//  pcc.xz *= r2d(iTime);\n  pcc.xz = abs(pcc.xz);\n  //pcc.xz *= r2d(iTime);\n  //pcc.yz *= r2d(.5*iTime);\n  pcc.y = mod(pcc.y+repyc*.5, repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 2.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/15.5))*.5*sat(sin(p.y*.05+5.*iTime));\n    rd = normalize(rd+normalize(p)*.1);\n    p+=rd*res.x*.25;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = (vec3(212, 140, 32)/255.).zxy;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*1.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.).zxy*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, background, 1.-sat(exp(-depth*depth*0.001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*1.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  vec2 ouv = uv;\n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n  //uv *= r2d(sin(mix(lenny(uv), length(uv), -2.)*15.-iTime));\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n    uv2 *= r2d(.01*iTime);\n  uv2 = abs(uv2);\n  //uv *= r2d(FFTI(.1)*10.);\n  //uv = abs(uv);\n  //uv -= vec2(.25);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.1)*1.;\n  col += rdr(uv2)*.25;\n  col *= 1.-sat(length(uv));\n  //col = mix(vec3(0.), vec3(199, 242, 58)/255., col*.4);\n  col = pow(col, vec3(2.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n//  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  float repy = .05;\n  float idy = floor((ouv.y+repy*.5)/repy);\n  col = mix(col, col.zxy, mod(idy+float(int(iTime*8.)),5.)/5.);\n\ncol = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n  \n\tfragColor = vec4(col.yxz, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28791, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSyWc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "ftSyWc", "name": "mackjam_am", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 4, "viewed": 374, "published": 3, "date": "1650811417", "time_retrieved": "2024-07-30T16:51:42.845642", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 0.);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    l.xy *= r2d(iTime);\n    float cube = max(max(l.x, l.y), l.z);\n      th.xy *= r2d(iTime);\n\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  p.xz *= r2d(iTime);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*.01;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  \n\n//  pcc.xz *= r2d(iTime);\n  pcc.xz = abs(pcc.xz);\n  //pcc.xz *= r2d(iTime);\n  //pcc.yz *= r2d(.5*iTime);\n  pcc.y = mod(pcc.y+repyc*.5, repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 2.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/15.5))*.5*sat(sin(p.y*.05+5.*iTime));\n    rd = normalize(rd+normalize(p)*.1);\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*1.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.).zxy*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, background, 1.-sat(exp(-depth*depth*0.001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*1.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  vec2 ouv = uv;\n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n  //uv *= r2d(sin(mix(lenny(uv), length(uv), -2.)*15.-iTime));\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n    uv2 *= r2d(.01*iTime);\n  uv2 = abs(uv2);\n  //uv *= r2d(FFTI(.1)*10.);\n  //uv = abs(uv);\n  //uv -= vec2(.25);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.1)*1.;\n  col += rdr(uv2)*.25;\n  col *= 1.-sat(length(uv));\n  //col = mix(vec3(0.), vec3(199, 242, 58)/255., col*.4);\n  col = pow(col, vec3(2.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n//  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  float repy = .05;\n  float idy = floor((ouv.y+repy*.5)/repy);\n  col = mix(col, col.zxy, mod(idy+float(int(iTime*8.)),5.)/5.);\n\ncol = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .75);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n  \n\tfragColor = vec4(col.yxz, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28790, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSyWc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "7tXBDH", "name": "Turkish flag", "author": "nuudl3", "description": "Turkish flag using sdf functions. Thanks to @BigWIngs for inspiration.", "tags": ["sdf"], "likes": 3, "viewed": 182, "published": 3, "date": "1650800352", "time_retrieved": "2024-07-30T16:51:43.657472", "image_code": "float circleSDF(vec2 uv)\n{\n   return length(uv) - 0.1; \n}\n\n\nfloat Moon(vec2 uv)\n{\n    float scale = 3.f;\n    float l1 = length(uv) - 0.1 * scale;\n    float l2 = distance(vec2(0.03,0)* scale, uv) - 0.085 * scale;\n    \n    return max(l1, -l2);\n    \n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdSquare(vec2 p)\n{\n  vec2 k = normalize(vec2(-0.5, 0.5));\n  p = abs(p);\n  float dk = dot(k.xy,p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    \n  k = normalize(vec2(-0.923, 0.328));\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  \n  k = normalize(vec2(0.5, -0.5));\n  p -= 4.0*min(dot(k.xy,p),0.0)*k.xy;\n  return sign(p.x - 0.1f);\n  \n  \n \n  //return sign(p.y - 0.1f);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    \n    vec2 k = normalize(vec2(k1.x, k1.y));\n    p -= 3.0*min(dot(k.xy,p),0.0)*k.xy;\n    \n    \n    return sign(p.x - 0.08f);\n    \n    //p.y -= r;\n    //vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    //float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    //return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = (fragCoord-0.5 * iResolution.xy)/iResolution.y * 0.8;    \n    uv.x = ((fragCoord-0.5 * iResolution.xy)/iResolution.y).x * 0.8 + 0.1;\n    \n    vec2 ux = fragCoord/iResolution.xy;\n    float t = uv.x*7.-2.*iTime+uv.y*3.;\n    uv.y += sin(t) * 0.02;    \n    ux.y += sin(t) * 0.02;    \n    \n    //uv.y += sin(iTime + (1.0f + uv.x) * .6) * 0.1;    \n    //uv.x += sin(iTime * uv.x)/ 32.f;\n\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(1,0,0);\n    col = mix(vec3(1,1,1), col, step(0., Moon(uv)));    \n    //col = mix(vec3(1,1,1), col, step(0., sdStar5(uv-vec2(0.4, 0.0), 0.1f, 0.4f)));  \n    uv = rotate(uv,9.6*3.1415/32.);\n    vec2 translate = rotate(vec2(0.3, 0.0),9.6*3.1415/32.);\n    col = mix(vec3(1,1,1), col, step(0., sdStar5(uv - translate, 0.1f, 0.4f)));\n    //col = mix(vec3(0,0,0), col, step(0., ux.y-0.01));\n    col = mix(vec3(0,0,0), col, smoothstep(0. , 0.04, ux.y));    \n    col = mix(vec3(0,0,0), col, smoothstep(1. , 0.96, ux.y));    \n    col = mix(vec3(0,0,0), col, smoothstep(1. , 0.98, ux.x));\n\n\n    //col = mix(vec3(1,1,1), col, step(0., sdHexagon(uv-vec2(0.0, 0.0), 0.1f)));    \n    //col = mix(vec3(1,1,0), col, step(0., circleSDF(uv-vec2(0.07, 0.0))));    \n    //col = mix(vec3(0.5,1,0), col, step(0., sdSquare(uv-vec2(0.5, 0.0))));\n\n\n\n\n    col *= 0.8 - cos(t) * 0.1;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 57], [60, 60, 81, 81, 248], [250, 250, 292, 292, 482], [484, 484, 508, 508, 847], [849, 849, 879, 879, 963], [965, 965, 1016, 1016, 1522], [1526, 1526, 1583, 1633, 3058]], "test": "untested"}
{"id": "7tfBW8", "name": "log polar sphere", "author": "takahiroando", "description": "See these sites for the details.\n\nhttps://www.osar.fr/notes/logspherical/\nhttps://github.com/pac-dev/notes/blob/master/content/logspherical/logpolar3d_rods.glsl\n", "tags": ["logpolar"], "likes": 17, "viewed": 387, "published": 3, "date": "1650788589", "time_retrieved": "2024-07-30T16:51:44.802411", "image_code": "/*\nSee these sites for the details.\n\nhttps://www.osar.fr/notes/logspherical/\nhttps://github.com/pac-dev/notes/blob/master/content/logspherical/logpolar3d_rods.glsl\n*/\n\n#define M_PI 3.14151692\n#define AA 1\n\n\n// These lines are parsed by dspnote to generate sliders\nfloat camera_y = 0.5; //dspnote param: 0.5 - 3\nfloat rho_offset = 0.0; //dspnote param: 0 - 10\nfloat density = 13.0; //dspnote param: 5 - 50, 13\nfloat radius = 0.9; //dspnote param: 0.05 - 1, 0.9\n\nfloat height = 0.01;\nfloat lpscale;\n\nfloat sdf(in vec3 p3d)\n{\n\t// Choose 2 dimensions and apply the forward log-polar map\n\tvec2 p = p3d.xz;\n\tfloat r = length(p);\n\tp = vec2(log(r), atan(p.y, p.x));\n\n\t// Scale everything so it will fit nicely in the ]-pi,pi] interval\n\tp *= lpscale;\n\tfloat mul = r/lpscale;\n\n\t// Apply rho-translation, which yields zooming\n\tp.x -= rho_offset + iTime*lpscale*0.23;\n\t\n\t// Turn tiled coordinates into single-tile coordinates\n\tp = mod(p, 2.0) - 1.0;\n\n\t// Get rounded cylinder distance, using the original Y coordinate shrunk\n\t// proportionally to the other dimensions\n\treturn (length(vec3(p, max(0.0, p3d.y/mul))) - radius) * mul;\n}\n\nvec3 color(in vec3 p)\n{\n\tvec3 top = vec3(0.3, 0.4, 0.5);\n\tvec3 ring = vec3(0.6, 0.04, 0.0);\n\tvec3 bottom = vec3(0.3, 0.3, 0.3);\n\tbottom = mix(vec3(0.0), bottom, min(1.0, -1.0/(p.y*20.0-1.0)));\n\tvec3 side = mix(bottom, ring, smoothstep(-height-0.001, -height, p.y));\n\treturn mix(side, top, smoothstep(-0.01, 0.0, p.y));\n}\n\n// Adapted from http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\n// Based on http://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 iUV = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n\tlpscale = floor(density)/M_PI;\n\n\t // camera movement\t\n\tfloat an = 0.04*iTime;\n\tvec3 ro = vec3(1.0*cos(an), camera_y, 1.0*sin(an));\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t// camera matrix\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 tot = vec3(0.0);\n\t\n\t#if AA>1\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\t// pixel coordinates\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n\t\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n\t\t// create view ray\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + 3.5*ww); // fov\n\n\t\t// raymarch\n\t\tconst float tmax = 10.0;\n\t\tfloat t = 0.0;\n\t\tfor( int i=0; i<256; i++ )\n\t\t{\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t}\n\t\n\t\t// shading/lighting\t\n\t\tvec3 col = vec3(0.0);\n\t\tif( t<tmax )\n\t\t{\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\t\tfloat amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n\t\t\tcol = color(pos)*amb + color(pos)*dif;\n\t\t}\n\n\t\t// gamma        \n\t\tcol = sqrt( col );\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\n\tfragColor = vec4(tot, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 522, 582, 1120], [1122, 1122, 1145, 1145, 1442], [1444, 1521, 1551, 1551, 1761]], "test": "untested"}
{"id": "NlfBW8", "name": "basic planets v2", "author": "jorge2017a2", "description": "basic planets v2", "tags": ["basicplanetsv2"], "likes": 5, "viewed": 233, "published": 3, "date": "1650765458", "time_retrieved": "2024-07-30T16:51:46.282453", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//referencia\n// \"field of stars\" by ändrom3da\n//https://glslsandbox.com/e#80574.18\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n///------------\nvec3 ti = vec3(0.0, 0.0, 0.0);  // tile index\n\n#define RANDOMFACTOR_STARS 0.99825\n#define SPEED 1.0\n\n///#define TILE_DISTANCE 2.0\n#define TILE_DISTANCE 20.0\n\n#define TILE_ATTENTUATION 0.\n//#define STAR_INTENSITY 1.\n#define STAR_SIZE 1.00\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n//---------------\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 N33(vec3 p) {\n    vec3 a = fract(p/9999.99*vec3(1293.34,2389.34,3949.65));\n    a+=dot(a,a+99.99);\n    return fract(vec3(a.x*a.y*2.22,a.y*a.z,a.z*a.x));\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 opRepTI(vec3 p, vec3 r)\n{\n\tti= floor(((p/2.0) + r*0.5)/r);  // tile index global variable\n\treturn mod(p + r,2.0 * r) - r;\t\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    \n    res =opU2(res, vec2(planeDist1,60.0));\n    p.y=p.y-5.0;\n    \n     vec3 r = opRepTI(p, vec3(TILE_DISTANCE));\n    float boxes;\n\tif (N33(ti).x*1.75 > RANDOMFACTOR_STARS)\n    {  boxes = sdSphere(r + TILE_ATTENTUATION*N33(ti), 6.0);\n       res =opU2(res, vec2(boxes,100.0));\n\t}    \n\telse\n\t{   boxes = sdSphere(r,0.0);\n        res =opU2(res, vec2(boxes,1.0));\n\t}\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col+0.2; }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n}\n\n//iq\nfloat xorTexture( in vec2 pos )\n{  float xor = 0.0;\n    for( int i=0; i<8; i++ )\n    {   xor += mod( floor(pos.x)+floor(pos.y), 2.0 );\n       pos *= 0.5;\n        xor *= 0.5;\n    }\n    return xor;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color==1) {return vec3(1.0);}\n    if (id_color==36) {return  vec3(0.8549, 0.8549, 0.8549); }\n     \n    if (id_color==60)\n    {return vec3(1.0)*xorTexture(p.xz*10.0 );}\n    \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t0,t;\n       t0=iTime;\n    t=t0*25.0;\n    light_pos1= vec3(50., 160.0, -25.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(-50., -120.0, 25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n    \n   vec3 ro=vec3(8.0,7.0,-25.0+t);\n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   //if(10.0*sin(t0)>0.0)\n   //rd= rotate_y(rd, radians(270.0));\n   \n   float tc=(abs(22.0*sin(t0*0.8)));\n   if(tc<6.6)\n       rd= rotate_y(rd, 4.71);\n   else if(tc<12.0)\n   {\n       vec3 ro=vec3(8.0,18.0,-25.0+t);\n       rd= rotate_x(rd, 0.35);\n    }   \n   else if(tc<18.0)\n       rd= rotate_z(rd, 0.38);\n       \n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[926, 926, 962, 962, 983], [985, 1010, 1044, 1044, 1140], [1141, 1141, 1175, 1175, 1266], [1267, 1267, 1301, 1301, 1392], [1394, 1394, 1412, 1412, 1552], [1555, 1555, 1574, 1574, 1636], [1637, 1637, 1667, 1667, 1766], [1768, 1768, 1793, 1793, 2260], [2262, 2262, 2286, 2286, 2448], [2450, 2450, 2498, 2498, 2777], [2779, 2779, 2823, 2823, 3144], [3146, 3146, 3183, 3183, 3440], [3442, 3442, 3532, 3532, 4492], [4494, 4494, 4543, 4543, 4621], [4623, 4623, 4655, 4655, 4855], [4857, 4862, 4895, 4895, 5059], [5061, 5061, 5131, 5131, 5413], [5415, 5415, 5442, 5442, 5531], [5533, 5533, 5591, 5591, 5639], [5641, 5641, 5664, 5664, 5776], [5778, 5778, 5809, 5809, 6430], [6432, 6432, 6489, 6489, 7211]], "test": "untested"}
{"id": "ftXfW8", "name": "basic planets v1", "author": "jorge2017a2", "description": "basic planets v1", "tags": ["basicplanetsv1"], "likes": 3, "viewed": 236, "published": 3, "date": "1650765453", "time_retrieved": "2024-07-30T16:51:47.313696", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 400.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n//referencia\n// \"field of stars\" by ändrom3da\n//https://glslsandbox.com/e#80574.18\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n///------------\nvec3 ti = vec3(0.0, 0.0, 0.0);  // tile index\n\n#define RANDOMFACTOR_STARS 0.99825\n#define SPEED 1.0\n\n///#define TILE_DISTANCE 2.0\n#define TILE_DISTANCE 20.0\n\n#define TILE_ATTENTUATION 0.\n//#define STAR_INTENSITY 1.\n#define STAR_SIZE 1.00\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n//---------------\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\nvec3 N33(vec3 p) {\n    vec3 a = fract(p/9999.99*vec3(1293.34,2389.34,3949.65));\n    a+=dot(a,a+99.99);\n    return fract(vec3(a.x*a.y*2.22,a.y*a.z,a.z*a.x));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 opRepTI(vec3 p, vec3 r)\n{\tti= floor(((p/2.0) + r*0.5)/r);  // tile index global variable\n\treturn mod(p + r,2.0 * r) - r;\t\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    vec3 r = opRepTI(p, vec3(TILE_DISTANCE));\n    float boxes;\n\tif (N33(ti).x*1.1 > RANDOMFACTOR_STARS)\n    {  boxes = sdSphere(r + TILE_ATTENTUATION*N33(ti), 6.0);\n       res =opU2(res, vec2(boxes,100.0));\n\t}\n    else\n\t{   boxes = sdSphere(r,0.0);\n        res =opU2(res, vec2(boxes,0.0));\n\t}\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n\n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=8.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    \n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col+0.2; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color==0) { colobj=vec3(0.0);  return colobj; }\n     if (id_color==1) { colobj=vec3(1.0);  return colobj; }\n    \n   if (id_color==100 )\n   { return  getColorTextura( p, nor,100); }\n        \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        \n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));        \n        vec3 result;\n         result= lightingv3(nor, p,light_pos1,rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    \n    float fog = 1.0 - pow(128./hit.x, 0.80)*1.5;\n    if (hit.x > MAX_DIST) col = vec3(0.0, 0.0, 0.0);\n        \n   return col;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) \n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=iTime*60.0;\n \tlight_pos1= vec3(10., 10.0, 25.0 ); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(-10., 10.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \n     vec3 ro = vec3(0.,10., 0.+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    //light_pos1-=ro;\n    //light_pos2-=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[876, 894, 930, 930, 951], [953, 953, 971, 971, 1111], [1113, 1113, 1132, 1132, 1194], [1196, 1196, 1226, 1226, 1324], [1326, 1326, 1351, 1351, 1704], [1706, 1706, 1730, 1730, 1892], [1894, 1894, 1942, 1942, 2216], [2218, 2218, 2262, 2262, 2583], [2585, 2585, 2622, 2622, 2879], [2881, 2881, 2971, 2971, 3984], [3986, 3986, 4035, 4035, 4278], [4280, 4280, 4312, 4312, 4509], [4511, 4511, 4581, 4581, 4801], [4803, 4803, 4830, 4830, 4919], [4921, 4921, 4979, 4979, 5027], [5029, 5029, 5052, 5052, 5164], [5166, 5166, 5197, 5197, 5901], [5903, 5903, 5954, 5954, 6145], [6147, 6147, 6204, 6204, 6634]], "test": "untested"}
{"id": "ftXBW8", "name": "Sphere Shading", "author": "VPaltoDance", "description": "Simple sphere shading with phong", "tags": ["phong", "sphere", "shading"], "likes": 2, "viewed": 230, "published": 3, "date": "1650761241", "time_retrieved": "2024-07-30T16:51:48.139488", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_ERROR 0.01\n\n\n#define LIGHT vec4(0.0, 5.0, 6.0, 10.0)\n#define RAY_ORIGIN vec3(0.0, 1.0, 0.0)\n#define RAY_DIRECTION normalize(vec3(uv.x, uv.y, 1.0))\n#define SPHERE_CENTER vec4(0.0, 1.0, 6.0, 1.0)\n\nfloat calculateDistance(vec3 point, out bool hitSphere)\n{    \n    float sphereDist = length(point - SPHERE_CENTER.xyz) - SPHERE_CENTER.w;\n    float planeDist = point.y;\n    \n    hitSphere = planeDist > sphereDist;\n    \n    return min(planeDist, sphereDist);\n}\n\nfloat calculateDistance(vec3 point)\n{    \n    float sphereDist = length(point - SPHERE_CENTER.xyz) - SPHERE_CENTER.w;\n    float planeDist = point.y;\n    \n    \n    return min(planeDist, sphereDist);\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDelta, out bool hitSphere)\n{\n    float dist = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = rayOrigin + rayDelta * dist;\n        float dS = calculateDistance(p, hitSphere);\n        dist += dS;\n        \n        if(dist > MAX_DIST || dist < SURFACE_ERROR) break;\n    }\n    \n    return dist;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDelta)\n{\n    float dist = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = rayOrigin + rayDelta * dist;\n        float dS = calculateDistance(p);\n        dist += dS;\n        \n        if(dist > MAX_DIST || dist < SURFACE_ERROR) break;\n    }\n    \n    return dist;\n}\n\nvec3 calculateNormal(vec3 p) {\n\tfloat d = calculateDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        calculateDistance(p-e.xyy),\n        calculateDistance(p-e.yxy),\n        calculateDistance(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat calculateDiffuseLighting(vec3 point)\n{\n    vec3 lightPos = LIGHT.xyz;\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightPos - point);\n    vec3 n = calculateNormal(point);\n    float d = length(lightPos - point);\n    \n    \n    float diff = clamp(dot(l, n), 0.0, 1.0) * LIGHT.w / d / d;\n    \n    float ray = RayMarch(point + n * 2.0 * SURFACE_ERROR, l);\n    if(ray< length(point - lightPos)) diff *= 0.1;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y ;\n    \n    bool isSphere = false;\n    float dist = RayMarch(RAY_ORIGIN, RAY_DIRECTION, isSphere);\n    \n    vec3 point = RAY_ORIGIN + RAY_DIRECTION * dist;\n    \n    float diff = calculateDiffuseLighting(point);\n    \n    calculateDistance(RAY_ORIGIN);\n    \n    vec3 col = vec3(diff);\n    if(isSphere)\n        col *= vec3(0.5, 0.3, 0.7);\n    else\n        col *= vec3(0.5, 0.3, 0.1);\n        \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 313, 313, 515], [517, 517, 554, 554, 716], [718, 718, 785, 785, 1073], [1075, 1075, 1122, 1122, 1399], [1401, 1401, 1431, 1431, 1660], [1662, 1662, 1706, 1706, 2120], [2122, 2122, 2179, 2179, 2670]], "test": "untested"}
{"id": "7tsBDn", "name": "radial wipe transition", "author": "oatmealine", "description": "use mouse to change the angle", "tags": ["radial", "transition", "wipe"], "likes": 4, "viewed": 396, "published": 3, "date": "1650745564", "time_retrieved": "2024-07-30T16:51:48.983232", "image_code": "// licensed under CC BY-SA 3.0\n// https://creativecommons.org/licenses/by-sa/3.0/\n\n#define PI 3.14159\n#define SPEED 0.4\n#define FORWARD -normalize((iMouse.xy / iResolution.xy) * 2.0 - 1.0)\n\n// debug thingy\n// #define RENDERSPIRAL\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize uv [-1.0 - 1.0]\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    vec2 normalized = normalize(uv);\n    float uvDot = dot(normalized, FORWARD);\n    float uvDot90 = dot(vec2(normalized.y, -normalized.x), FORWARD); // rotated 90deg\n    // get the angle between this pixel and the slice\n    float angle = acos(uvDot) / PI;\n    // lefthand side\n    float angle1 = (1.0 - angle) * 0.5;\n    // righthand side\n    float angle2 = angle * 0.5 + 0.5;\n    // mix between the two based on which side of the spiral we're on\n    float spiral = mix(angle1, angle2, floor(uvDot90) + 1.0);\n    \n    // do the wipe\n    float t = fract(iTime * SPEED + 0.3); // adding a small amt just so the preview looks nicer\n    vec4 tex1 = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 tex2 = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    #ifdef RENDERSPIRAL\n    fragColor = vec4(vec3(spiral), 1.0);\n    #else\n    fragColor = mix(tex1, tex2, floor(t - spiral) + 1.0);\n    #endif\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsBDn.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[231, 231, 288, 321, 1280]], "test": "untested"}
{"id": "NtlfWn", "name": "20220423", "author": "nippa_nikki", "description": "2022/04/23", "tags": ["2d"], "likes": 2, "viewed": 184, "published": 3, "date": "1650729246", "time_retrieved": "2024-07-30T16:51:49.862880", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 q = uv - vec2(0.5,0.5);\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.0-(q.x*2.0),1.0-(q.y*2.0),1.0);\n    \n    float r = atan(q.y,q.x);\n    \n    float r_normal = (r+3.1415)/6.283;\n    \n    float len = length(q);\n    \n    col *= smoothstep(0.9,0.95,abs(cos(r*4.0+len*5.0+iTime))*abs(cos(len*iMouse.y)))+smoothstep(0.2,0.7,(cos((uv.y-uv.x)*6.0+iTime*2.0))+1.0)*0.2;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 597]], "test": "untested"}
{"id": "fllfWn", "name": "20220423-2", "author": "nippa_nikki", "description": "2022/04/23", "tags": ["2d"], "likes": 9, "viewed": 254, "published": 3, "date": "1650729236", "time_retrieved": "2024-07-30T16:51:50.756491", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float width = 800.0;float height = 450.0;\n    float as = width/height;\n\n    // Time varying pixel color\n    vec3 col_1 = vec3(1.0,1.0,1.0);\n    \n    uv.x = uv.x*as-(1.0-(1.0/as));\n    \n    vec2 ori = vec2(uv.x+.1*(cos(iTime*5.0)+0.2*cos(iTime*25.0)),uv.y+.1*sin(iTime*5.0));\n    //ori = vec2(uv.x,uv.y);\n    //ori = vec2(uv.x-iMouse.x/iResolution.x+0.5,uv.y-iMouse.y/iResolution.y+0.5);\n    \n    float di = length(ori-vec2(.5,.5));\n    float r = atan(ori.y-0.5,ori.x-0.5);\n    \n    float circle = smoothstep(.4,.5,.005/abs(di-cos(r*10.0)*.4));\n    \n    float limen = .99;\n    \n    float atom = 1.0;\n    \n    atom *= circle * smoothstep(limen,limen+.01,abs(cos(r*15.0/2.0+3.14592*iTime*1.0)));\n    \n    atom += smoothstep(0.96,0.965,1.0-di);\n    \n    //atom += smoothstep(.4,.5,);\n    \n    atom += .025/abs(di);\n    \n    atom += .001/abs(di-abs(cos(iTime))*.25) * step(-0.2,cos(iTime*160.0)+cos(iTime*139.0));\n    atom += .001/abs(di-abs(cos(iTime*1.3+0.6))*.25)\n    * step(1.0,cos(iTime*160.0)+cos(iTime*139.0))\n    * step(0.8,abs(cos(r*5.0+iTime*5.0)));\n    atom = clamp(atom,.0,1.0);\n    float tri_d = .15;\n    float tri_r = iTime;\n    float triangle = .001/abs((ori.y-0.5-tri_d*sin(tri_r))-tan(tri_r-3.141592/6.0)*(ori.x-0.5-tri_d*cos(tri_r)));\n    tri_r += (2.0/3.0)*3.141;\n    triangle += .001/abs((ori.y-0.5-tri_d*sin(tri_r))-tan(tri_r-3.141592/6.0)*(ori.x-0.5-tri_d*cos(tri_r)));\n    tri_r += (2.0/3.0)*3.141;\n    triangle += .001/abs((ori.y-0.5-tri_d*sin(tri_r))-tan(tri_r-3.141592/6.0)*(ori.x-0.5-tri_d*cos(tri_r)));\n    triangle = clamp(triangle,.0,1.0);\n    col_1 *= atom;\n    col_1 += triangle;\n    \n    col_1 *= vec3(1.0-di,.2+di,.2+di);\n    // Output to screen\n    fragColor = vec4(col_1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1861]], "test": "untested"}
{"id": "ftlfWn", "name": "20220423-1", "author": "nippa_nikki", "description": "2022/04/23", "tags": ["2d"], "likes": 1, "viewed": 162, "published": 3, "date": "1650728018", "time_retrieved": "2024-07-30T16:51:51.746843", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = 800.0/450.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.0,1.0,1.0);\n    col.x *= clamp(0.0,1.0,fract(5.0*(uv.y-(uv.x+iTime*0.001)*pow(cos(iTime*0.1)*0.4,2.0))-iTime*0.3)-0.2);\n    col.y *= clamp(0.0,1.0,fract((uv.y+0.1-uv.x*(pow(cos(iTime*0.1)*0.7,2.0)-0.2))/aspect*10.0)-0.2);\n    \n    col = col*0.3+vec3(0.3,0.7,0.7);\n    \n    col.y += smoothstep(0.99,0.998,fract((cos(uv.y*(30.0)-(uv.x+iTime*0.1)*300.0-2.0)+1.0)/2.0))*0.3;\n    \n    if(abs((uv.y-0.5)*15.0-cos((uv.x+iTime*0.2)*5.0))<0.03) col += 0.1;\n    if(abs((uv.y-0.5)*15.0+cos((uv.x+iTime*0.2+4.0)*5.0))<0.03) col += 0.1;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 825]], "test": "untested"}
{"id": "7tfBDr", "name": "Beacon in space", "author": "libreliu", "description": "Practice II", "tags": ["raymarching"], "likes": 0, "viewed": 113, "published": 3, "date": "1650724059", "time_retrieved": "2024-07-30T16:51:52.740187", "image_code": "#define RAYMARCH_MAX_STEPS 100\n#define RAYMARCH_MAX_DIST 100.5f\n#define RAYMARCH_SURF_DIST 1e-2\n#define GRAD_APPROX_EPS 1e-3\n#define PI 3.14159265359\n\nint grid_max = 10;\n\n// -- Perlin noise related stuff --\n// Copied from https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fractualNoise(vec2 uv) {\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n// --------------------------------\n\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return sqrt((p.x - c.x) * (p.x - c.x) + (p.y - c.y) * (p.y - c.y) + (p.z - c.z) * (p.z - c.z)) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat groundSDF(vec3 p) {\n    return abs(p.y+5.);\n    //return length(p.xy) + 0.5;\n}\n\nvec3 groundDiffuse(vec3 p) {\n    //return vec3(p.z - floor(p.z));\n    return vec3(sin(10.*p.z));\n}\n\nfloat sceneSDFStart(vec3 p) {\n    //return sdTorus(p, vec2(1.5, 0.5));\n    return sdOctahedron(p, 1.5);\n}\n\nfloat sceneSDFEnd(vec3 p) {\n    return sphereSDF(p, vec3(0.0, 0.0, 0.0), 1.5);\n}\n\nfloat sceneSDF(vec3 p) {\n    //return min(sphereSDF(p, vec3(0.0, 0.0, 0.0), 1.5), groundSDF(p));\n    //return sdTorus(p, vec2(1.5, 0.5));\n    float weight = sin(iTime) * 0.5 + 0.8;\n    \n    float blend = sceneSDFStart(p) * (weight - 0.2) + (0.8 - weight) * sceneSDFEnd(p);\n    \n    return min(blend, groundSDF(p));\n}\n\nvoid sceneMaterial(vec3 p, out vec3 diffuseColor) {\n    if (groundSDF(p) <= RAYMARCH_SURF_DIST) {\n        // ground color\n        diffuseColor = groundDiffuse(p);\n    }\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD, out float dist) {\n    vec3 curIsect = rayO;\n    rayD = normalize(rayD);\n    float t = 0.0f;\n    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {\n        dist = sceneSDF(curIsect);\n        if (dist < RAYMARCH_SURF_DIST || dist > RAYMARCH_MAX_DIST) {\n            break;\n        }\n        \n        t += dist;\n        curIsect = rayO + t * rayD;\n    }\n    return t;\n}\n\n// grad f(x,y,z) = (df/dx, df/dy, df/dz)\n// normal at (x_0, y_0, z_0) is normalized grad SDF(x,y,z)\n//     evaluated at (x_0, y_0, z_0)\nvec3 sceneNormal(vec3 p) {\n    float pSDF = sceneSDF(p);\n    vec2 eps = vec2(1e-3, 0);\n    vec3 grad = pSDF - vec3(\n        sceneSDF(p - eps.xyy),    // f(x_0 - eps.x, y_0, z_0)\n        sceneSDF(p - eps.yxy),    // f(x_0, y_0 - eps.x, z_0)\n        sceneSDF(p - eps.yyx)     // f(x_0, y_0, z_0 - eps.x)\n    );\n    \n    // normalize does the rest\n    return normalize(grad);\n}\n\nvec3 shadeScene(vec3 isect) {\n    // contrib from mainLight - point light\n    vec3 lightPos = vec3(5.0, 5.0, 5.0);\n    //vec3 lightPos = vec3(5.0f * cos(2.0 * iTime), 0.0, 5.0 * sin(2.0 *iTime));\n    \n    // test if the light can reach our ball\n    vec3 light2Isect = normalize(isect - lightPos);\n    float rayDist, lightT = rayMarch(lightPos, light2Isect, rayDist);\n    float visibility = 0.0f;\n    //float visibility = 1.0f;\n    if (length(lightPos + lightT * light2Isect - isect) < 10. * RAYMARCH_SURF_DIST) {\n        // shall contribute light\n        visibility = 1.0f;\n    }\n    \n    vec3 lightColor = vec3(0.5, 0.5, 0.5);\n    vec3 lightL = lightColor * 5.5f;\n    \n    vec3 diffuseColor = vec3(1.0f);\n    sceneMaterial(isect, diffuseColor);\n    \n    vec3 isectN = sceneNormal(isect);\n    vec3 lightContrib = \\\n        visibility * diffuseColor * clamp(dot(isectN, normalize(lightPos - isect)), 0., 1.) * lightL / length(isect - lightPos);\n    vec3 ambientContrib = diffuseColor * 0.1;\n    return lightContrib + ambientContrib;\n}\n\nvec2 toSphericalCoord(vec3 v) {\n  /* -PI ~ PI */\n  float theta = atan(v.y, v.x);\n\n  /* -PI/2 ~ PI/2 */\n  float phi = asin(clamp(v.z, -1.f, 1.f));\n  return vec2(theta, phi);\n}\n\n// TODO\nvec3 shadeSkybox(vec3 rayD) {\n    vec3 lineColor = vec3(abs(sin(iTime)), 0., 0.);\n    vec3 outColor = vec3(0.0f, 0.0f, 0.0f);\n\n    vec2 sphCoord = toSphericalCoord(rayD);\n    vec2 coordInner = sphCoord / (5. * PI / 180.);\n    coordInner.x = coordInner.x - floor(coordInner.x);\n    coordInner.y = coordInner.y - floor(coordInner.y);\n    \n    if (length(coordInner) < 0.1) {\n        outColor = lineColor;\n    } else {\n        //outColor = vec3(fractualNoise((sphCoord) * 4. + (iTime)));\n    }\n    \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Compute camera properties\n    vec3 camPos = vec3(10.0, 0.0, 0.0);\n    vec3 camLookat = vec3(-1.0, -3.0 + 6.0 * mouseUV.y, -3.0 + 6.0 *mouseUV.x);\n    vec3 camUp = vec3(0.0, 0.0, 1.0);\n    vec3 camZ = normalize(camLookat - camPos);            // forward\n    vec3 camX = normalize(cross(camZ, normalize(camUp)));  // right\n    vec3 camY = cross(camX, camZ);                        // up\n    float camVertFOV = 120.0f * (PI / 180.0f) / 2.;       // 120 degree\n    vec3 camScrC = camPos + camZ;\n    vec3 camScrP = camScrC + camY * (uv.x -0.5) * tan(camVertFOV) + camX * (uv.y-0.5) * tan(camVertFOV) / aspectRatio;\n    \n    vec3 rayD = normalize(camScrP - camPos);\n    vec3 rayO = camPos;\n    float distClosest, tClosest = rayMarch(rayO, rayD, distClosest);\n    \n    \n    //vec3 outColor = vec3(distClosest );\n    //vec3 outColor = dist > 1. ? vec3(0.0) : vec3(1.0);\n    \n    vec3 outColor;\n    if (distClosest > 10.0f * RAYMARCH_SURF_DIST) {\n        outColor = shadeSkybox(rayD);\n    } else {\n        outColor = shadeScene(rayO + tClosest * rayD);\n    }\n\n    // Output to screen\n    fragColor = vec4(outColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 318, 318, 433], [435, 435, 461, 461, 940], [942, 942, 972, 972, 1205], [1245, 1245, 1287, 1287, 1393], [1395, 1445, 1478, 1478, 1543], [1545, 1545, 1583, 1583, 1863], [1865, 1865, 1890, 1890, 1949], [1951, 1951, 1979, 2016, 2049], [2051, 2051, 2080, 2121, 2156], [2158, 2158, 2185, 2185, 2238], [2240, 2240, 2264, 2377, 2556], [2558, 2558, 2609, 2609, 2728], [2730, 2730, 2784, 2784, 3128], [3130, 3266, 3292, 3292, 3640], [3642, 3642, 3671, 3715, 4675], [4677, 4677, 4708, 4725, 4851], [4853, 4861, 4890, 4890, 5379], [5381, 5381, 5438, 5488, 6752]], "test": "untested"}
{"id": "NtfBDr", "name": "Flat Sphere", "author": "libreliu", "description": "Practice I", "tags": ["raymarching"], "likes": 0, "viewed": 104, "published": 3, "date": "1650724043", "time_retrieved": "2024-07-30T16:51:53.618838", "image_code": "#define RAYMARCH_MAX_STEPS 100\n#define RAYMARCH_MAX_DIST 100.5f\n#define RAYMARCH_SURF_DIST 1e-2\n#define GRAD_APPROX_EPS 1e-3\n#define PI 3.14159265359\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return sqrt((p.x - c.x) * (p.x - c.x) + (p.y - c.y) * (p.y - c.y) + (p.z - c.z) * (p.z - c.z)) - r;\n}\n\nfloat groundSDF(vec3 p) {\n    return abs(p.y+2.5);\n}\n\nfloat sceneSDF(vec3 p) {\n    return min(sphereSDF(p, vec3(0.0, 0.0, 0.0), 1.5), groundSDF(p));\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD, out float dist) {\n    vec3 curIsect = rayO;\n    rayD = normalize(rayD);\n    float t = 0.0f;\n    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {\n        dist = sceneSDF(curIsect);\n        if (dist < RAYMARCH_SURF_DIST || dist > RAYMARCH_MAX_DIST) {\n            break;\n        }\n        \n        t += dist;\n        curIsect = rayO + t * rayD;\n    }\n    return t;\n}\n\n// grad f(x,y,z) = (df/dx, df/dy, df/dz)\n// normal at (x_0, y_0, z_0) is normalized grad SDF(x,y,z)\n//     evaluated at (x_0, y_0, z_0)\nvec3 sceneNormal(vec3 p) {\n    float pSDF = sceneSDF(p);\n    vec2 eps = vec2(1e-3, 0);\n    vec3 grad = pSDF - vec3(\n        sceneSDF(p - eps.xyy),    // f(x_0 - eps.x, y_0, z_0)\n        sceneSDF(p - eps.yxy),    // f(x_0, y_0 - eps.x, z_0)\n        sceneSDF(p - eps.yyx)     // f(x_0, y_0, z_0 - eps.x)\n    );\n    \n    // normalize does the rest\n    return normalize(grad);\n}\n\nvec3 shadeScene(vec3 isect) {\n    // contrib from mainLight - point light\n    //vec3 lightPos = vec3(5.0, 0.0, -5.0);\n    vec3 lightPos = vec3(5.0f * cos(2.0 * iTime), 0.0, 5.0 * sin(2.0 *iTime));\n    \n    // test if the light can reach our ball\n    vec3 light2Isect = normalize(isect - lightPos);\n    float rayDist, lightT = rayMarch(lightPos, light2Isect, rayDist);\n    float visibility = 0.0f;\n    //float visibility = 1.0f;\n    if (length(lightPos + lightT * light2Isect - isect) < 10. * RAYMARCH_SURF_DIST) {\n        // shall contribute light\n        visibility = 1.0f;\n    }\n    \n    vec3 lightColor = vec3(0.5, 0.5, 0.5);\n    vec3 lightL = lightColor * 5.5f;\n    \n    vec3 isectN = sceneNormal(isect);\n    vec3 lightContrib = \\\n        visibility * clamp(dot(isectN, normalize(lightPos - isect)), 0., 1.) * lightL / length(isect - lightPos);\n    \n    return lightContrib;\n}\n\n// TODO\nvec3 shadeSkybox(vec3 rayD) {\n    return vec3(0.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Compute camera properties\n    vec3 camPos = vec3(5.0, 0.0, 0.0);\n    vec3 camLookat = vec3(-1.0, 0.0, 0.0);\n    vec3 camUp = vec3(0.0, 0.0, 1.0);\n    vec3 camZ = normalize(camLookat - camPos);            // forward\n    vec3 camX = normalize(cross(camZ, normalize(camUp)));  // right\n    vec3 camY = cross(camX, camZ);                        // up\n    float camVertFOV = 120.0f * (PI / 180.0f) / 2.;       // 120 degree\n    vec3 camScrC = camPos + camZ;\n    vec3 camScrP = camScrC + camY * (uv.x -0.5) * tan(camVertFOV) + camX * (uv.y-0.5) * tan(camVertFOV) / aspectRatio;\n    \n    vec3 rayD = normalize(camScrP - camPos);\n    vec3 rayO = camPos;\n    float distClosest, tClosest = rayMarch(rayO, rayD, distClosest);\n    \n    \n    //vec3 outColor = vec3(distClosest );\n    //vec3 outColor = dist > 1. ? vec3(0.0) : vec3(1.0);\n    \n    vec3 outColor;\n    if (distClosest > 10.0f * RAYMARCH_SURF_DIST) {\n        outColor = shadeSkybox(rayD);\n    } else {\n        outColor = shadeScene(rayO + tClosest * rayD);\n    }\n\n    // Output to screen\n    fragColor = vec4(outColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 193, 193, 299], [301, 301, 326, 326, 353], [355, 355, 379, 379, 451], [453, 453, 507, 507, 851], [853, 989, 1015, 1015, 1363], [1365, 1365, 1394, 1482, 2245], [2247, 2255, 2284, 2284, 2309], [2311, 2311, 2368, 2418, 3597]], "test": "untested"}
{"id": "7lXBDr", "name": "Procedural Infinite Grid", "author": "VPaltoDance", "description": "An infinite procedural grid shader.", "tags": ["grid", "proceduralgrid", "infinitegrid"], "likes": 2, "viewed": 451, "published": 3, "date": "1650717644", "time_retrieved": "2024-07-30T16:51:54.467569", "image_code": "#define GRID_THICKNESS 1.0\n#define GRID_SCALE 80.0\n\n#define GRID_COLOR vec4(0.8, 0.8, 0.8, 1.0)\n#define BACKGROUND_COLOR vec4(0.1, 0.1, 0.1, 1.0)\n\n#define GRID_WOBBLE 1\n\n\n// Calculating grid bsed on uv coordinates\nfloat calculateGrid(in vec2 uv, float thickness)\n{\n    float gridX = float(fract(uv.x) <= thickness);\n    float gridY = float(fract(uv.y) <= thickness);\n\n    return max(gridX, gridY);\n}\n\n// Calculate simple wobble amount for demonstration\n#ifdef GRID_WOBBLE\n    vec2 calculateWobble(float multiplier, float freq, float scale)\n    {\n        return multiplier * vec2(sin(iTime * freq)) / scale;\n    }\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenCoord = fragCoord / GRID_SCALE;\n    \n    // Apply wobble if needed\n    #ifdef GRID_WOBBLE\n        screenCoord += calculateWobble(2000.0, 0.1, GRID_SCALE);\n    #endif\n    \n    // Scale the thickness appropriately to match the grid coordinate system scale\n    float scaledThickness = GRID_THICKNESS / GRID_SCALE;\n    float grid = calculateGrid(screenCoord, scaledThickness);\n    \n    // Applying different colors for grid and background\n    vec4 finalColor = mix(BACKGROUND_COLOR, GRID_COLOR, grid);\n    \n    // Output to screen\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 214, 264, 264, 399], [621, 621, 676, 676, 1248]], "test": "untested"}
{"id": "fl2cWG", "name": "mackjam_al", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 3, "viewed": 324, "published": 3, "date": "1650711360", "time_retrieved": "2024-07-30T16:51:55.219560", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 0.);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    l.xy *= r2d(iTime);\n    float cube = max(max(l.x, l.y), l.z);\n      th.xy *= r2d(iTime);\n\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  p.xz *= r2d(iTime);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*.01;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  \n\n//  pcc.xz *= r2d(iTime);\n  pcc.xz = abs(pcc.xz);\n  //pcc.xz *= r2d(iTime);\n  //pcc.yz *= r2d(.5*iTime);\n  pcc.y = mod(pcc.y+repyc*.5, repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 2.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/15.5))*.5*sat(sin(p.y*.05+5.*iTime));\n\n    p+=rd*res.x*.95;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*1.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.).zxy*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*1.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  vec2 ouv = uv;\n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  uv = abs(uv);\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n    uv2 *= r2d(.01*iTime);\n  uv2 = abs(uv2);\n  //uv *= r2d(FFTI(.1)*10.);\n  //uv = abs(uv);\n  //uv -= vec2(.25);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.1)*1.;\n  col += rdr(uv2)*.25;\n  col *= 1.-sat(length(uv));\n  //col = mix(vec3(0.), vec3(199, 242, 58)/255., col*.4);\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n//  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  float repy = .05;\n  float idy = floor((ouv.y+repy*.5)/repy);\n  col = mix(col, col.zxy, mod(idy+float(int(iTime*8.)),5.)/5.);\n\ncol = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n  \n\tfragColor = vec4(col.yxz, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28789, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2cWG.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "Nt2cWG", "name": "mackjam_ak", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 1, "viewed": 254, "published": 3, "date": "1650711338", "time_retrieved": "2024-07-30T16:51:56.004459", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 0.);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    l.xy *= r2d(iTime);\n    float cube = max(max(l.x, l.y), l.z);\n      th.xy *= r2d(iTime);\n\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  p.xz *= r2d(iTime);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  \n\n//  pcc.xz *= r2d(iTime);\n  pcc.xz = abs(pcc.xz);\n  //pcc.xz *= r2d(iTime);\n  //pcc.yz *= r2d(.5*iTime);\n  pcc.y = mod(pcc.y+repyc*.5, repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 10.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2*sat(sin(p.y*.05+5.*iTime));\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*1.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.).zxy*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*1.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  vec2 ouv = uv;\n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n    uv2 *= r2d(.01*iTime);\n  uv2 = abs(uv2);\n  uv *= r2d(FFTI(.1)*10.);\n  uv = abs(uv);\n  uv -= vec2(.25);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.1)*1.;\n  col += rdr(uv2)*.15;\n  col *= 1.-sat(length(uv));\n  //col = mix(vec3(0.), vec3(199, 242, 58)/255., col*.4);\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  float repy = .05;\n  float idy = floor((ouv.y+repy*.5)/repy);\n  col = mix(col, 1.-col.zxy, mod(idy+float(int(iTime*4.)),5.)/5.);\n\ncol = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n  \n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28788, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2cWG.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "7lfBWn", "name": "Interactive 2.5D Line Waves", "author": "SnoopethDuckDuck", "description": "Click around the screen to change things!\n\n(Avoid the top-left corner, it's kind of ugly)", "tags": ["waves", "interactive", "lines", "25d"], "likes": 17, "viewed": 376, "published": 3, "date": "1650709261", "time_retrieved": "2024-07-30T16:51:56.860172", "image_code": "#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Change me!\n    float sc = 1.;   \n    uv *= sc;\n\n    // Line smoothstep\n    float s;   \n    \n    // Mouse parameters\n    float mx = 8. * (ms.x + 0.5);\n    float my = ceil(5. * (ms.y + 0.5));\n    \n    float n = 50.;\n    for (float i = 0.; i < n; i++) {\n        float t = 0.2 * iTime + 2. * pi * i / n; \n        \n        // Modified: y = sin(t) + uv.x * cos(t)\n        float y = sin(mx * uv.x + t) -  uv.x * cos(t) \n                + 0.5 * fract( pi * 0.2 * iTime + my * (uv.x + i / n));\n\n        // Include new line/wave\n        float k = sc / iResolution.y;\n        s = max(s, smoothstep(-k, k, -abs(uv.y - 0.25 * y) + k));\n    }\n    \n    // Background + color\n    s += exp(-4. * length(uv));\n    vec3 e = vec3(0.5);\n    vec3 col = pal(0.5 * s + 0.85, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 1042]], "test": "untested"}
{"id": "NlXBDn", "name": "Pretty sweet colors", "author": "mrange", "description": "CC0: Pretty sweet colors\nI watched a YT (https://www.youtube.com/watch?v=pG0t19bEYJw), didn't remember anything except I thought \nthe colors and shapes were pretty sweet around 0:09 in the video. So improvised a shader around it.\n", "tags": ["2d"], "likes": 18, "viewed": 541, "published": 3, "date": "1650695712", "time_retrieved": "2024-07-30T16:51:57.692945", "image_code": "// CC0: Pretty sweet colors\n//  I watched a YT (https://www.youtube.com/watch?v=pG0t19bEYJw), didn't remember anything except I thought \n//  the colors and shapes were pretty sweet around 0:09 in the video. So improvised a shader around it.\n//  Unfortunately in chromium (Chrome, Edge etc) the colors for me looks dull and boring. Hopefully it's ok for you.\n//  In FF it looks right though.\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n\nfloat plane(vec2 p, vec3 pl) {\n  return dot(p, pl.xy) + pl.z;\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nconst vec3[] bcols = vec3[](\n    HSV2RGB(vec3(243.0/360.0,0.95,0.07))\n  , HSV2RGB(vec3(246.0/360.0,0.89,0.28))\n  , HSV2RGB(vec3(244.0/360.0,0.80,0.23))\n  , HSV2RGB(vec3(263.0/360.0,0.84,0.27))\n  , HSV2RGB(vec3(277.0/360.0,0.86,0.26))\n  , HSV2RGB(vec3(337.0/360.0,0.98,0.61))\n  , HSV2RGB(vec3(348.0/360.0,0.99,0.83))\n  , HSV2RGB(vec3(357.0/360.0,0.93,0.85))\n  );\nconst int noOfBCols = bcols.length();\n\nvec2 transform(vec2 p, float i) {\n  float tm = TIME*0.2;\n  float ii = i/float(noOfBCols);\n  float f =sin(3.0*p.y+2.1*i+tm);\n  vec2 sp = toSmith(p);\n//  sp.y -= 0.1*i+0.9*sin(+0.1*i);\n  sp *= ROT(0.1*i+tm);\n  sp *= ROT(mix(0.0, 0.2, ii)*f);\n//  p.x += 0.08*f;\n  p = fromSmith(sp);;\n  return p;\n}\n\nfloat df(vec2 p, float i) {\n  return plane(p, vec3(normalize(-vec2(1.0, 1.0)), 0.2*i-0.3));\n}\n\nvec3 effect(vec2 p, vec2 np) {\n  float aaa = 2.0/RESOLUTION.y;\n  vec3 col = bcols[0];\n  \n  for (int i = 1; i < noOfBCols; ++i) {\n    float ii = float(i);\n    vec2 pp   = transform(p, ii);\n    vec2 npp  = transform(np, ii);\n    float aa  = distance(pp, npp)*sqrt(0.5);\n    float d = df(pp, ii);\n    col = mix(col, col*0.33, exp(-max(10.0*d*aaa/aa, 0.0)));\n    col = mix(col, bcols[i], smoothstep(aa, -aa, d));\n  }\n  \n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1.0 + 2.0*q;\n  p.x     *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p + 2.0/RESOLUTION.y;\n  \n  vec3 col = effect(p, np);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[722, 722, 744, 744, 890], [1185, 1285, 1306, 1306, 1379], [1380, 1480, 1502, 1502, 1551], [1554, 1554, 1584, 1584, 1617], [1619, 1619, 1642, 1722, 1861], [1863, 1863, 1888, 1967, 2106], [2509, 2509, 2542, 2542, 2803], [2805, 2805, 2832, 2832, 2898], [2900, 2900, 2930, 2930, 3334], [3336, 3336, 3391, 3391, 3610]], "test": "untested"}
{"id": "stsfR7", "name": "Fork crumpledWa Maadahmed 391", "author": "Maadahmed", "description": "https://twitter.com/nasana_x", "tags": ["cineshader"], "likes": 4, "viewed": 3328, "published": 3, "date": "1650682431", "time_retrieved": "2024-07-30T16:51:58.828908", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n   \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  }\n    \n   vec3 col;\n   col.r  = uv.y - 0.1;\n   col.g = uv.y + 0.3;\n   col.b = uv.y + 0.95;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 416]], "test": "untested"}
{"id": "sdSfWG", "name": "simple sdf arc", "author": "ArmandB", "description": "sdf arc", "tags": ["sdf", "arc"], "likes": 3, "viewed": 225, "published": 3, "date": "1650676200", "time_retrieved": "2024-07-30T16:51:59.589873", "image_code": "float sdfArc(float sa, float ea, float r, vec2 uv){\n    float tau = 6.28318530718;\n    //find coterminal angles\n    sa = mod(mod(radians(sa),tau) + tau, tau);\n    ea = mod(mod(radians(ea),tau) + tau, tau);\n    float a = mod(mod(atan(uv.y,uv.x),tau) + tau, tau);\n    //https://stackoverflow.com/questions/12234574/calculating-if-an-angle-is-between-two-angles\n    if ((sa <= a && a <= ea && sa < ea) || ((sa <= a || a <= ea) && sa >= ea)){\n        return abs(r - length(uv));\n    }\n    //get closest endpoint\n    vec2 p1 = vec2(cos(sa), sin(sa))*r;\n    vec2 p2 = vec2(cos(ea), sin(ea))*r;\n    return min(distance(p1, uv), distance(p2, uv));\n}\n\nvec3 colorSdf(float d){//from https://www.shadertoy.com/view/tlSGzG\n    vec3 col = vec3(1.0) - sign(d*2.0)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d*2.0));\n\tcol *= 0.8 + 0.2*cos(140.0*d*2.0);\n\treturn mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d*2.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = colorSdf(sdfArc(iTime*20.0, iTime*40.0, 0.3, uv - vec2(0.8, 0.5)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 641], [643, 643, 666, 710, 908], [910, 910, 967, 967, 1124]], "test": "untested"}
{"id": "fllfR4", "name": "Blob Dance Party", "author": "cra_manning_w", "description": "Fun with circles and sine waves", "tags": ["2d", "circles"], "likes": 0, "viewed": 224, "published": 3, "date": "1650675805", "time_retrieved": "2024-07-30T16:52:00.579228", "image_code": "//For the behavior of blob shape, see 'blobRadius()' and 'randBlob()'.\n//For the behavior of blob color, see 'colorBlob()'.\n//For the behavior of the lights, see 'genLighting()', 'getWorldLighting()', and 'getBlobLighting()'.\n\n///////////////////////\n//    Blob shape     //\n///////////////////////\n\n//The size of blobs relative to their cell.\n#define BLOB_AVERAGE_SIZE_PER_CELL_SIZE 0.4\n\n\n//A distorted circle.\nstruct Blob\n{\n    float initialRadius;\n    \n    Ripple fastRhythm;\n    float fastRhythmWeight;\n    \n    Ripple slowRhythm1, slowRhythm2;\n    float slowRhythmWeight;\n    \n    vec2 center;\n    float scale; //A bit redundant, but makes the shape much easier to manipulate\n};\n\n//Gets the oscillating effect from a blob's slow rhythms.\nfloat blobSlowRhythm(Blob blob, float thetaT)\n{\n    return blob.slowRhythmWeight * (\n        ripple(blob.slowRhythm1, thetaT, iTime) +\n        ripple(blob.slowRhythm2, thetaT + 0.4128901, iTime) //Arbitrary offset to keep the rhythms unaligned\n    );\n}\n//Gets the min/max of a blob's slow rhythm output.\nvec2 blobSlowRhythmRange(Blob blob)\n{\n    return blob.slowRhythmWeight *\n              (rippleRange(blob.slowRhythm1) +\n               rippleRange(blob.slowRhythm2));\n}\n\n//Gets the oscillating effect from a blob's fast rhythms.\nfloat blobFastRhythm(Blob blob, float thetaT)\n{\n    return blob.fastRhythmWeight *\n           ripple(blob.fastRhythm, thetaT, iTime);\n}\n//Gets the min/max of a blob's fast rhythm output.\nvec2 blobFastRhythmRange(Blob blob)\n{\n    return blob.fastRhythmWeight * rippleRange(blob.fastRhythm);\n}\n\n//Computes the blob's radius at a specific angle, determined by a direction vector.\nfloat blobRadius(Blob blob, vec2 offset)\n{\n    float thetaT = angleT(offset);\n    return blob.scale * (blob.initialRadius +\n                         blobSlowRhythm(blob, thetaT) +\n                         blobFastRhythm(blob, thetaT));\n}\n\n//Returns 1) the signed-distance to this blob,\n//        2) a 0-or-1 value indicating whether you're inside the blob.\nvec2 blobCollision(Blob blob, vec2 pos)\n{\n    vec2 relativePos = pos - blob.center;\n    float dist = length(relativePos),\n          radius = blobRadius(blob, relativePos);\n    \n    float signedDist = dist - radius;\n    float mask = 1.0 - max(0.0, sign(signedDist));\n    return vec2(signedDist, mask);\n}\n\n//Generates a randomized blob, given some uniform-random 0-1 values,\n//    and the range of possible values.\nBlob randBlob(vec3 rngSeeds,\n              vec2 rangeInitialRadius,\n              vec2 rangeFastPolyrhythm, vec2 rangeFastAmplitude, vec2 rangeFastSpikes,\n              vec2 rangeSlow1Speed, vec2 rangeSlow1Spikes,\n              vec2 rangeSlow2Speed, vec2 rangeSlow2Spikes,\n              vec2 rangeSlowAmplitude,\n              vec2 cellCenter, float cellSize)\n{\n    float halfCellSize = cellSize * 0.5;\n    \n    //Generate some random signals.\n    vec4 rng1 = hashTo4(rngSeeds * 7777.7777),\n         rng2 = hashTo4((rngSeeds.zxy + rng1.wxz) * 5555.5555),\n         rng3 = hashTo4((rngSeeds.yzx + rng1.yzw) * 8989.9898),\n         rng4 = hashTo4(rngSeeds.xzy * 5555.5555);\n\n    float polyrhythm = floor(mix(rangeFastPolyrhythm.x, rangeFastPolyrhythm.y, rng1.r));\n    float tempo = BLOB_TEMPO * polyrhythm;\n    \n    //The blob will wander around its center position.\n    //The wandering is based on sampling from a noise texture\n    //    (so we can take non-uniform sources like blue noise).\n    //Depends on linear sampling to get a smooth wandering.\n    float wanderSpeed = mix(0.001, 0.02, rng4.x),\n          wanderLookupAngle = PI2 * iTime * wanderSpeed;\n    vec2 wanderRadiusTexels = 10.0 / iChannelResolution[1].xy,\n         wanderLookupDir = vec2(cos(wanderLookupAngle), sin(wanderLookupAngle)),\n         wanderLookup = rng4.yz + (wanderRadiusTexels * wanderLookupDir);\n    vec4 wanderNoise = texture(iChannel1, wanderLookup);\n    vec2 wanderPosOffset = halfCellSize *\n                           mix(vec2(-0.5), vec2(0.5),\n                               smoothstep(0.0, 1.0, wanderNoise.xy));\n                               \n    vec2 blobCenter = cellCenter + wanderPosOffset +\n                      (halfCellSize * mix(vec2(-0.5), vec2(0.5), rng3.gb));\n    \n    return Blob(\n        mix(rangeInitialRadius.x, rangeInitialRadius.y, rng1.g),\n        //Fast rhythm:\n        Ripple(mix(rangeFastAmplitude.x, rangeFastAmplitude.y, rng1.b),\n               tempo,\n               int(mix(rangeFastSpikes.x, rangeFastSpikes.y, rng1.a)),\n               true),\n        1.0,\n        //Slow rhythms:\n        Ripple(1.0,\n               mix(rangeSlow1Speed.x, rangeSlow1Speed.y, rng2.r),\n               int(mix(rangeSlow1Spikes.x, rangeSlow1Spikes.y, rng2.g)),\n               false),\n        Ripple(1.0,\n               mix(rangeSlow2Speed.x, rangeSlow2Speed.y, rng2.b),\n               int(mix(rangeSlow2Spikes.x, rangeSlow2Spikes.y, rng2.a)),\n               false),\n        mix(rangeSlowAmplitude.x, rangeSlowAmplitude.y, rng3.r),\n        //Transform:\n        blobCenter,\n        BLOB_AVERAGE_SIZE_PER_CELL_SIZE * cellSize\n    );\n}\n\n\n\n////////////////////////\n//    Dance Floor     //\n////////////////////////\n\n//A \"dance floor\" is split into a grid,\n//    and N blobs are generated within each grid.\n//The blobs wander back and forth by using a position offset,\n//    taken by linear-sampling a noise texture.\n\n//The range/probability of blobs per-cell are kept constant to make the code simpler (and faster).\n//The number of blobs for a specific cell is computed as a random value within this range, floored to integer.\n#define BLOBS_COUNT_MIN 0.2   /* Chance of 0 blobs in a cell */\n#define BLOBS_COUNT_MAX 1.5\n#define N_MAX_BLOBS (int(BLOBS_COUNT_MAX))\n\nstruct DanceFloor\n{\n    float cellSize;\n    float seed;\n\n    //Each dance floor gets a pseudo-random offset to help hide the grid alignment.\n    vec2 offset;\n};\n\n//Generates a dance floor with a pseudo-random offset.\nDanceFloor makeDanceFloor(float cellSize, float seed)\n{\n    return DanceFloor(cellSize, seed,\n                      cellSize * fract(seed * vec2(9999.2374, 4444.98725)));\n}\n\nvec2 danceFloorCellIndex(DanceFloor df, vec2 pos) { return floor((pos - df.offset) / df.cellSize); }\nvec2 danceFloorCellPos(DanceFloor df, vec2 cellIdx) { return ((cellIdx + 0.5) * df.cellSize) + df.offset; }\n\n//Generates the blobs for a specific dance floor cell.\n//The cell index should be integers, but is passed as floats for simplicity.\nvoid blobsInCell(DanceFloor danceFloor, vec2 cellIndex,\n                 out int nBlobs, out Blob blobs[N_MAX_BLOBS])\n{\n    vec3 noiseInput = vec3((cellIndex * 2.952832938), danceFloor.seed);\n    \n    nBlobs = int(mix(BLOBS_COUNT_MIN, BLOBS_COUNT_MAX, hashTo1(noiseInput * 888.888)));\n   \n    vec2 cellCenter = danceFloorCellPos(danceFloor, cellIndex);\n    for (int i = 0; i < min(N_MAX_BLOBS, nBlobs); ++i) //Explicitly limit the iterations to a hard-coded max,\n    {                                                  //    in case that helps the compiler optimize/unroll\n        blobs[i] = randBlob(\n            hashTo3(vec3(hashTo1(noiseInput.xy * 9191.1919),\n                         noiseInput.z * 1919.9191,\n                         float(i * 3000))),\n            \n            //Radius:\n            vec2(0.87, 1.2),\n            \n            //Fast:\n            vec2(1.0, 3.99999), vec2(0.02, 0.2), vec2(2.0, 6.75),\n            \n            //Slow1:\n            vec2(0.175, 0.25), vec2(1.0, 4.5),\n            //Slow2:\n            vec2(0.3, 0.4), vec2(1.0, 4.15),\n            //Slow general:\n            vec2(0.2, 0.4),\n            \n            //Transform data:\n            cellCenter, danceFloor.cellSize\n        );\n    }\n}\n\n//Describes a specific point inside a blob.\nstruct BlobHit\n{\n    vec2 cellIndex;\n    float blobIndex;\n    \n    float blobRadius;\n    \n    //The point, relative to the blob's center.\n    vec2 posOffset;\n    //The point's distance from the blob center.\n    float dist;\n};\n\n//Finds which blob in the dance floor a given position is touching.\n//Returns whether any such blob was found, and outputs data about the blob into an 'out' variable.\nbool danceFloorBlobAt(DanceFloor danceFloor, vec2 pos,\n                      out BlobHit hitData, out Blob blobData, out int blobIdx)\n{\n    vec2 cellIndex = danceFloorCellIndex(danceFloor, pos);\n    cellIndex = floor(cellIndex);\n    \n    //Check the neighboring cells as well as this one, to handle blobs near the boundary.\n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            vec2 neighborCellIndex = cellIndex + vec2(x, y);\n            \n            //Get the blobs in this cell.\n            int nBlobs;\n            Blob blobs[N_MAX_BLOBS];\n            blobsInCell(danceFloor, neighborCellIndex, nBlobs, blobs);\n                        \n            //Check for collision.\n            for (int i = 0; i < nBlobs; ++i) {\n                vec2 toPos = pos - blobs[i].center;\n                float radius = blobRadius(blobs[i], toPos);\n                float dist = length(toPos);\n                if (dist <= radius)\n                {\n                    blobIdx = i;\n                    blobData = blobs[i];\n                    hitData = BlobHit(neighborCellIndex, float(i),\n                                      radius, toPos, dist);\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\n\n//////////////////////////\n//    World lighting    //\n//////////////////////////\n\n//Computes the global \"ambient\" light brightness, from 0 to 1.\nfloat getGlobalLight(float time)\n{\n    //Define a bunch of cycling amplitudes.\n    //Mix them together in different ways (max, min, mul, add),\n    //    and then smoothly interpolate between the ways.\n    \n    float modeT = OSCILLATE(0.0, 1.0, time / 6.0);\n    \n    Ripple cycles[] = Ripple[](\n        Ripple(1.0, 0.7, 1, false),\n        Ripple(0.7, 0.1, 1, false),\n        Ripple(1.0, 0.6, 1, false),\n        Ripple(1.0, 0.3, 1, false)\n    );\n    \n    float rMin = 99999.999,\n          rMax = -99999.999,\n          rSum = 0.0,\n          rProd = 1.0;\n    for (int i = 0; i < cycles.length(); ++i)\n    {\n        float r = ripple(cycles[i], iTime, iTime);\n        rMin = min(rMin, r);\n        rMax = max(rMax, r);\n        rSum += r;\n        rProd *= r;\n    }\n\n    if (modeT < 0.33333)\n        return SATURATE(mix(rProd, rMin, INV_LERP(0.0, 0.33333, modeT)));\n    else if (modeT < 0.66667)\n        return SATURATE(mix(rMin, rSum, INV_LERP(0.33333, 0.66667, modeT)));\n    else\n        return SATURATE(mix(rSum, rMax, INV_LERP(0.66667, 1.0, modeT)));\n}\n\n\n//////////////////////////\n//    Floor lighting    //\n//////////////////////////\n\n\nconst vec3[] LIGHT_COLORS = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(1.0, 0.0, 0.5),\n    vec3(0.0, 0.3, 1.0)\n);\n\n#define STREAK_THICKNESS 0.012\n\n//Party lighting for one dance floor.\nstruct FloorLighting\n{\n    vec3 dir;\n    vec2 offset;\n    int nStreaks;\n    float streaksAngleSpacing;\n    vec4 streakColor;\n};\n\n\n//Computes randomized lighting for a dance floor.\nFloorLighting genLighting(DanceFloor df, float time)\n{\n    //Change the lighting at regular intervals, based on tempo.\n    float lightingIdx = floor((time * BLOB_TEMPO * 0.5) +\n                              (0.2 * hashTo1(df.seed * 12.439782)));\n    \n    vec2 seeds = vec2(df.seed, lightingIdx);\n    vec4 rand1 = hashTo4(seeds * 4565.6545);\n    \n    float lightingAngle = PI2 * sign(rand1.x - 0.5) *\n                          mix(0.0, PI2/4.0, rand1.x);\n    \n    return FloorLighting(\n        vec3(cos(lightingAngle), sin(lightingAngle), -1.0),\n        mix(vec2(-0.5), vec2(0.5), hashTo2(rand1.xyz +\n                                           (rand1.w * df.seed) +\n                                           3453.34534)),\n        int(mix(0.0, 5.99999, rand1.y)),\n        PI2 * mix(0.01, 0.031, rand1.z),\n        vec4(RAND_IN_ARRAY(LIGHT_COLORS, rand1.w),\n             mix(0.5, 1.0, hashTo1((time * (df.seed + 0.1)) * 8979.7899)))\n    );\n}\n\n//Computes the influence of floor lighting on a given pixel,\n//    not including the light's effect on blobs.\nvec3 getWorldLighting(FloorLighting lights, vec2 pos)\n{\n    vec3 color = vec3(0.0);\n    //See if any streaks are passing through this position.\n    for (int i = 0; i < lights.nStreaks; ++i)\n    {\n        float angleOffset = lights.streaksAngleSpacing *\n                            float(i - (lights.nStreaks / 2)),\n              aSin = sin(angleOffset),\n              aCos = cos(angleOffset);\n        vec2 streakOrigin = (lights.dir.xy * -2.5) + lights.offset,\n             //Note that direction doesn't need to be normalized.\n             streakDir = normalize(mat2(aCos, aSin, -aSin, aCos) * lights.dir.xy);\n\n        float lineDist = distToLine(streakOrigin, streakDir, pos);\n        if (lineDist < STREAK_THICKNESS)\n        {\n            //The line gets weaker at the edges, and far from the source.\n            float lineStrength = (1.0 - (lineDist / STREAK_THICKNESS)) *\n                                 //Note: this second term can break if\n                                 //    the line is exactly vertical.\n                                 (1.0 - SATURATE((pos - streakOrigin).x / streakDir.x / 6.0));\n            color += lights.streakColor.rgb * lights.streakColor.a * lineStrength;\n        }\n    }\n    \n    return SATURATE(color);\n}\n\n//Computes the influence of floor lighting on the surface of a blob.\nvec3 getBlobLighting(FloorLighting lights, Blob blob, BlobHit hit,\n                     vec3 blobNormal, float globalAmbient)\n{\n    //Mute the party light's saturation when lighting a blob,\n    //    since blobs already have a specific color palette.\n    vec3 lightHSV = RGBtoHSV(lights.streakColor.rgb);\n    lightHSV.y /= mix(2.0, 8.0, 1.0 - globalAmbient);\n    vec3 lightColor = HSVtoRGB(lightHSV);\n    \n    //Augment the computed normal with a smooth dropoff\n    //    based on the side of the blob we are on.\n    float offsetNormalStrength = mix(9.0, 20.0, globalAmbient);\n    vec3 normal = normalize(blobNormal +\n                            vec3(hit.posOffset * offsetNormalStrength, 0.05));\n    \n    float ambient = 0.0,\n          diffuse = dot(normal, -lights.dir);\n    \n    return max(ambient, diffuse) * lightColor;\n}\n\n\n//////////////////////////\n//    Blob coloring     //\n//////////////////////////\n\n//Each blob takes from this palette.\n//I used an online palette generator to find these.\n#if 1\n    const vec3 BODY_PALETTE[] = vec3[](\n        vec3(1.000, 0.749, 0.718), //#FFBFB7\n        vec3(1.000, 0.792, 0.498), //#FFCA7F\n        vec3(1.000, 0.831, 0.278) //#FFD447\n    );\n    const vec3 BORDER_PALETTE[] = vec3[](\n        vec3(0.196, 0.051, 0.427), //#320D6D\n        vec3(0.369, 0.063, 0.165), //#5E102A\n        vec3(0.298, 0.110, 0.000) //#4C1C00\n    );\n    const vec3 DETAILS_PALETTE[] = vec3[](\n        vec3(0.600, 0.400, 0.573), //#996692\n        vec3(0.722, 0.424, 0.302), //#B86C4D\n        vec3(0.439, 0.012, 0.325) //#700353\n    );\n#elif 0\n    //TODO: Try some different palettes\n#else\n    #error No palette chosen!\n#endif\n\n\n//Computes the color for a point in a blob.\nvec3 colorBlob(DanceFloor floor, FloorLighting lighting, float worldAmbient,\n               Blob blob, BlobHit hit,\n               int floorIdx, int blobIdx)\n{\n    //Generate random numbers to color with.\n    vec3 rand1 = hashTo3(5120.0 *\n                           vec3(vec2(hit.cellIndex) / PI,\n                                hashTo1(vec2(floorIdx, blobIdx))));\n\n    //Pick a randomized palette.\n    //Bias each dance floor towards a specific palette.\n    vec3 paletteBias = hashTo3(float(floorIdx + 1) * 5434.3454);\n    #define PALETTE_T(noiseChannel) applyBias(rand1.noiseChannel, \\\n                                              paletteBias.noiseChannel, \\\n                                              0.45)\n    vec3 cBody = RAND_IN_ARRAY(BODY_PALETTE, PALETTE_T(x)),\n         cBorder = RAND_IN_ARRAY(BORDER_PALETTE, PALETTE_T(y)),\n         cDetails = RAND_IN_ARRAY(DETAILS_PALETTE, PALETTE_T(z));\n         \n    //Apply a floor-wide adjustment to the palette.\n    //HSV space is more convenient for this kind of work.\n    vec3 hsvBody = RGBtoHSV(cBody),\n         hsvBorder = RGBtoHSV(cBorder),\n         hsvDetails = RGBtoHSV(cDetails);\n    vec3 colorRand3 = hashTo3(7348.3498 * float(floorIdx)),\n         shiftRange = vec3(0.05, 0.1, 0.075),\n         shiftAmount = mix(-shiftRange, shiftRange, colorRand3);\n    hsvBody = SATURATE(hsvBody + shiftAmount);\n    hsvBorder = SATURATE(hsvBorder + shiftAmount);\n    hsvDetails = SATURATE(hsvDetails + shiftAmount);\n    cBody = HSVtoRGB(hsvBody);\n    cBorder = HSVtoRGB(hsvBorder);\n    cDetails = HSVtoRGB(hsvDetails);\n\n    //Simulate a bump-map via a scalar that tracks\n    //    whether the surface is facing inward or outward.\n    #define BUMP_STRENGTH 0.6\n    float bumpOutward = 0.0;\n\n    //Calculate some measurements.\n    float blobAverageRadius = blob.initialRadius * blob.scale;\n    float thetaT = angleT(hit.posOffset),\n          edgeT = hit.dist / hit.blobRadius,\n          circleT = hit.dist / blobAverageRadius;\n    float slowRhythm = blobSlowRhythm(blob, thetaT),\n          fastRhythm = blobFastRhythm(blob, thetaT);\n    vec2 slowRhythmRange = blobSlowRhythmRange(blob),\n         fastRhythmRange = blobFastRhythmRange(blob);\n    float slowRhythmT = INV_LERP(slowRhythmRange.x, slowRhythmRange.y, slowRhythm),\n          fastRhythmT = INV_LERP(fastRhythmRange.x, fastRhythmRange.y, fastRhythm);\n        \n\n    //Fade to the border color at the edge of the blob.\n    float borderMask = smoothstep(0.0, 1.0, pow(edgeT, 2.0 / floor.cellSize));\n    bumpOutward = SATURATE(pow(edgeT, 10.0)*5.0);\n    \n    //Add a \"rim\" circle.\n    //The circle has an inside dropoff, and an outside dropoff.\n    //It's positioned based on the blob's \"initialRadius\",\n    //    so it's circular and not affected by the rhythms,\n    //    but very small influences *are* added from rhythms to create more motion.\n    float perfectAlignment = pow(fastRhythmT * slowRhythmT, 2.5);\n    float innerEnd = OSCILLATE(mix(0.70, 0.60, perfectAlignment),\n                               0.72,\n                               fastRhythmT),\n          outerStart = OSCILLATE(0.75,\n                                 mix(0.77, 0.82, perfectAlignment),\n                                 slowRhythmT);\n    #define RIM_BUMP_STRENGTH 1.0\n    float blobCircleEndRadius = outerStart * blobAverageRadius;\n    //Define it as a piecewise equation with 3 parts:\n    //   1. inside the circle\n    //   2. on the border\n    //   3. outside the circle\n    float inCircleT = INV_LERP(0.0, innerEnd, circleT),\n          outCircleT = INV_LERP(blobCircleEndRadius, hit.blobRadius,\n                                hit.dist);\n    float pastInner = step(innerEnd, circleT),\n          pastOuter = step(outerStart, circleT);\n    vec3 circlePhases = vec3(1.0-pastInner,\n                             pastInner*(1.0-pastOuter),\n                             pastOuter);\n    #define INNER_SLOPE_EXP 5.0\n    #define OUTER_SLOPE_EXP 0.4\n    // Vary the rim strength based on the rhythms.\n    vec3 rimStrengthWeights = vec3(0.1,\n                                   0.85,\n                                   0.05),\n         rimStrengths = vec3(1.0,\n                             pow(slowRhythmT, 5.0),\n                             pow(fastRhythmT, 2.0));\n    float rimStrength = dot(rimStrengthWeights, rimStrengths) /\n                        (rimStrengthWeights.x + rimStrengthWeights.y + rimStrengthWeights.z);\n    vec3 perPhaseStrengths = rimStrength * vec3(\n        pow(inCircleT, INNER_SLOPE_EXP),\n        1.0,\n        pow(1.0 - outCircleT, OUTER_SLOPE_EXP)\n    );\n    vec3 perPhaseDerivative = rimStrength * RIM_BUMP_STRENGTH * vec3(\n        -(1.0 / innerEnd) * INNER_SLOPE_EXP *\n          pow(inCircleT, INNER_SLOPE_EXP-1.0),\n        0.0,\n        OUTER_SLOPE_EXP *\n          pow(-outCircleT + 1.0, OUTER_SLOPE_EXP - 1.0)\n    );\n    float rimMask = dot(circlePhases, perPhaseStrengths),\n          rimBump = clamp(dot(circlePhases, perPhaseDerivative), -1.0, 1.0);\n    //If the border bump and rim bump are pushing in the same direction,\n    //    average them together.\n    //Otherwise, take the larger of the two by magnitude.\n    bumpOutward = (sign(rimBump) != sign(bumpOutward)) ?\n                      (rimBump + bumpOutward)/2.0 :\n                      ((abs(rimBump) > abs(bumpOutward)) ?\n                           rimBump : bumpOutward);\n    \n    //TODO: Add an angle-based effect inside the rim.\n    \n    vec3 detailedBody = mix(cBody, cDetails, rimMask);\n    vec3 albedo = mix(detailedBody, cBorder, borderMask);\n    \n    //Add some lighting.\n    vec2 towardsOutside = normalize(hit.posOffset);\n    //TODO: Should the normal take into account the blob radius's changes? It fortunately has an analytical derivative.\n    vec3 normal = normalize(vec3(towardsOutside * bumpOutward,\n                                 1.0 / BUMP_STRENGTH));\n    vec3 lightColor = getBlobLighting(lighting, blob, hit, normal, worldAmbient);\n\n    return albedo * lightColor;\n}\n\n\n////////////////////////////\n//    Post-processing     //\n////////////////////////////\n\nvec3 postProcess(vec3 color)\n{\n    //Disable PP until I'm finished with lighting.\n    return color;\n\n    //Increase brightness and contrast.\n    vec3 colorHSV = RGBtoHSV(color);\n    colorHSV.z = smoothstep(0.0, 1.0, pow(colorHSV.z, 0.68));\n    color = HSVtoRGB(colorHSV);\n    \n    return color;\n}\n\n\n/////////////////\n//    main     //\n/////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float worldAmbient = getGlobalLight(iTime);\n    \n    //Set the background color to something neutral:\n    fragColor.rgb = vec3(0.23, 0.21, 0.25);\n    fragColor.a = 1.0;\n\n    vec2 uv = -1.0 + (2.0 * fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n\n    //Generate the dance floors, and collect the world lights.\n    #define N_FLOORS 5\n    DanceFloor floors[N_FLOORS];\n    FloorLighting floorLights[N_FLOORS];\n    vec3 worldLightColor = vec3(0.0);\n    for (int floorI = 0; floorI < N_FLOORS; ++floorI)\n    {\n        float floorT = float(floorI + 1) / float(N_FLOORS),\n              floorSize = pow(floorT, 1.6235) * 2.0,\n              floorSeed = float(floorI) * PHI * 1000.0;\n\n        floors[floorI] = makeDanceFloor(floorSize, floorSeed);\n        floorLights[floorI] = genLighting(floors[floorI], iTime);\n        \n        worldLightColor += getWorldLighting(floorLights[floorI], uv);\n    }\n    \n    //Render the blob at this pixel.\n    vec3 blobColor = vec3(0.0);\n    for (int floorI = 0; floorI < N_FLOORS; ++floorI)\n    {\n        DanceFloor df = floors[floorI];\n        \n        BlobHit blobHit;\n        Blob blob;\n        int blobI;\n        if (danceFloorBlobAt(df, uv, blobHit, blob, blobI))\n        {\n            FloorLighting lighting = floorLights[floorI];\n            \n            float floorT = float(floorI + 1) / float(N_FLOORS),\n                  fadeT = 1.0 - (floorT - (1.0 / float(N_FLOORS)));\n            blobColor = colorBlob(df, lighting, worldAmbient,\n                                  blob, blobHit,\n                                  floorI, blobI) *\n                           pow(fadeT, 0.75);//TODO: Check out this param\n            break;\n        }\n    }\n    \n    //Compute the final color.\n    fragColor.rgb = postProcess(SATURATE(blobColor + worldLightColor));\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//TODO: Figure this all out.\n\n#define NOTE(Hz, amplitude) (sin(float(Hz) * PI2 * time) * float(amplitude))\n#define CHORD(Hz, weights, amplitude) \\\n    (float(amplitude) * dot(weights, \\\n                            sin(Hz * PI2 * time)))\n#define SHARPEN(x) (-1.0 + (2.0 * smoothstep(-1.0, 1.0, x)))\n\n#define MUSIC_TEMPO (BLOB_TEMPO / 4.0)\n\nfloat rhythm(float amp1, float amp2, float amp3, float amp4, float amp5, float amp6,\n             float time)\n{\n    float sum = NOTE(MUSIC_TEMPO * 1.0, amp1) + NOTE(MUSIC_TEMPO * 2.0, amp2) +\n                NOTE(MUSIC_TEMPO * 3.0, amp3) + NOTE(MUSIC_TEMPO * 4.0, amp4) +\n                NOTE(MUSIC_TEMPO * 5.0, amp5) + NOTE(MUSIC_TEMPO * 6.0, amp6);\n    return (0.5 + (0.5 * sum)) / (amp1 + amp2 + amp3 + amp4 + amp5 + amp6);\n}\n#define RHYTHM(amp1, amp2, amp3, amp4, amp5, amp6) rhythm(float(amp1), float(amp2), \\\n                                                          float(amp3), float(amp4), \\\n                                                          float(amp5), float(amp6), \\\n                                                          time)\n\n#define BEATS_PER_MEASURE 4\n#define MEASURE(n) SHARPEN(SHARPEN(0.5 + (0.5 * NOTE(MUSIC_TEMPO / (float(n) * float(BEATS_PER_MEASURE)), 1.0))))\n\nvec2 mainSound(int samp, float time)\n{\n    return vec2(0);\n    \n    float beat = CHORD(vec3(55, 110, 220),\n                       vec3(0.55, 0.35, 0.1),\n                       1.0) *\n                  //RHYTHM(1, 0, 0, 0, 0, 0) *\n                  MEASURE(1);\n    \n    \n    return vec2(beat);\n}", "sound_inputs": [], "common_code": "\n///////////////////////\n//    Randomness     //\n///////////////////////\n\n// A modified version of this: https://www.shadertoy.com/view/4djSRW\n\n//Hash 1D from 1D-3D data\nfloat hashTo1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hashTo1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hashTo1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Hash 2D from 1D-3D data\nvec2 hashTo2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Hash 3D from 1D-3D data\nvec3 hashTo3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hashTo3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hashTo3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//Hash 4D from 1D-4D data\nvec4 hashTo4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\nvec4 hashTo4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\nvec4 hashTo4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hashTo4(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n#define PI 3.1415926535898\n#define PI2 (2.0 * PI)\n\n#define PHI 1.618033988\n\n\n#define OSCILLATE(a, b, input) (mix(a, b, 0.5 + (0.5 * cos(PI2 * (input)))))\n\n#define INV_LERP(a, b, x) ((x-a) / (b-a))\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n\n#define RAND_IN_ARRAY(array, t) array[int(mix(0.0, float(array.length()) - 0.00001, t))]\n\n\n//Gets the angle of the given vector, in the range 0-1.\nfloat angleT(vec2 dir) { return 0.5 + (0.5 * atan(dir.y, dir.x)/PI); }\n\n//Given a uniformly-distributed value, and another target value,\n//    biases the uniform value towards the target.\n//The \"biasStrength\" should be between 0 and 1.\nfloat applyBias(float x, float target, float biasStrength)\n{\n    //Degenerative case if x=0.\n    if (x == 0.0)\n        return mix(x, target, biasStrength);\n    \n    //Get the \"scale\" of the target relative to x.\n    //Multiplying x by this number would give exactly the target.\n    float scale = target / x;\n    \n    //Weaken the \"scale\" by pushing it towards 1.0, then apply it to 'x'.\n    //Make sure to respect the sign, in case 'x' or 'target' is negative.\n    return x * sign(scale) * pow(abs(scale), biasStrength);\n}\n\nfloat distToLine(vec2 lineP, vec2 lineDir, vec2 pos)\n{\n    //Reference: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    \n    vec2 numerator2 = lineDir * (lineP - pos).yx;\n    return abs(numerator2.x - numerator2.y) / length(lineDir);\n}\n\n//RGB<=>HSV converter, from here: https://stackoverflow.com/a/17897228\nvec3 RGBtoHSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSVtoRGB(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n////////////////\n//   Ripple   //\n////////////////\n\n//An oscillating value, as a function of the angle around a circle.\nstruct Ripple\n{\n    float scale, speed;\n    int nSpikes;\n    bool canBeNegative;\n};\nfloat ripple(Ripple r, float angleT, float time)\n{\n    float inpt = (time * r.speed) +\n                  (angleT * float(r.nSpikes));\n    float minVal = (r.canBeNegative ? -r.scale : 0.0);\n    return OSCILLATE(minVal, r.scale, inpt);\n}\n\nvec2 rippleRange(Ripple r)\n{\n    return vec2(r.canBeNegative ? -r.scale : 0.0,\n                r.scale);\n}\n\n\n//////////////////////\n//    Constants     //\n//////////////////////\n\n//The speed at which blobs \"dance\".\n#define BLOB_TEMPO 2.0", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[685, 743, 790, 790, 995], [996, 1047, 1084, 1084, 1215], [1217, 1275, 1322, 1322, 1410], [1411, 1462, 1499, 1499, 1566], [1568, 1652, 1694, 1694, 1889], [1891, 2009, 2050, 2050, 2311], [2313, 2422, 2782, 2782, 5042], [5831, 5886, 5941, 5941, 6058], [6060, 6060, 6111, 6111, 6160], [6161, 6161, 6214, 6214, 6268], [6270, 6402, 6521, 6521, 7630], [7903, 8070, 8205, 8205, 9353], [10998, 11048, 11102, 11166, 11986], [11988, 12098, 12153, 12153, 13342], [13344, 13413, 13540, 13663, 14239], [15060, 15104, 15263, 15308, 21053], [21144, 21144, 21174, 21225, 21440], [21498, 21498, 21555, 21555, 23367]], "test": "untested"}
{"id": "stlBzM", "name": "Simple Line Waves", "author": "SnoopethDuckDuck", "description": "Saw this post, tried to do the same but got distracted: \nhttps://twitter.com/andrevenancio/status/1514417812969865217\n\nThe line equation is basically: y = sin(t) + x * cos(t)\nIt goes up and down and is tangent to 2 cos waves, fun to modify\n", "tags": ["waves", "lines", "waveywavelines"], "likes": 6, "viewed": 343, "published": 3, "date": "1650667865", "time_retrieved": "2024-07-30T16:52:03.225153", "image_code": "#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // (better to use fragCoord for a pixelated version)\n    // uv = floor(0.25 * iResolution.y * uv) / (0.25 * iResolution.y);\n    \n    float s;   \n    float m = mod(floor(0.5 * iTime), 10.) + 1.;\n    \n    float n = 40.;\n    for (float i = 0.; i < n; i++) {\n        float t = 0.2 * iTime + 2. * pi * i / n; \n        \n        // Uncomment for other versions\n        float y = sin(m * t + 11. * uv.x) -  4. * uv.x * cos(t * 0.5);\n        // y = sin(m * t + 11. * uv.x) -  4. * uv.x * cos(t);\n         y = sin(t + 11. * uv.x) -  4. * uv.x * cos(t * 0.5);\n        \n        float k = 1. / iResolution.y;\n        s = max(s, smoothstep(-k, k, -abs(uv.y - 0.25 * y) + k));\n    }\n\n    vec3 col = vec3(s);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 883]], "test": "untested"}
{"id": "NllBzM", "name": "School's out", "author": "ruojake", "description": "An aquatic mess", "tags": ["3d", "raymarching", "sea", "underwater"], "likes": 7, "viewed": 347, "published": 3, "date": "1650655637", "time_retrieved": "2024-07-30T16:52:04.511715", "image_code": "// School's out by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat thing(vec3 p)\n{\n    float t = iTime * 3.141592;\n    \n    p.xy *= rot(p.z * .01);\n    p.xz *= rot(t * -.1);\n    \n    \n    vec3 i = floor(p / 16. + .5);\n    p.xz += i.y * t;\n    p = fract(p / 16. + .5) * 16. - 8.;\n    \n    float s = sin(t + dot(i, vec3(1)));\n    float ns = s * -.5 + .5;\n    \n    p.xz *= rot(t * .3 + i.x - i.z);\n    p.xz *= rot(p.y + t * .2);\n    p.yx *= rot(p.z * .5);\n    p.x -= clamp(p.x + .2, -.5,.5);\n    p.z -= clamp(p.z - .4, -.5,.5);\n    p = abs(p) - 1.7 - s * .55;\n\n    return (length(p) - .6) * (.4 - s * .125);\n}\n\nfloat scene(vec3 p)\n{\n    return min(thing(p), thing(-p + 8.)) - .05;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec2 e = vec2(.001, 0);\n\n    return normalize(\n        d - vec3(\n            scene(p - e.xyy),\n            scene(p - e.yxy),\n            scene(p - e.yyx)\n        )\n    );\n}\n\nfloat shadow(vec3 o, vec3 ld)\n{\n    float d = 0.;\n    float t = .1;\n    vec3 p;\n    for(int i = 0; i < 250; ++i)\n    {\n        p = o + t * ld;\n        d = scene(p);\n        if(abs(d)<.01 || t > 32.) return clamp((t - 24.) / 8., 0., 1.);\n        t += d;\n    }\n    return 1.;\n}\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126,.7152,.0722));\n}\n\nvec3 reinhard(vec3 c)\n{\n    float l = lum(c);\n    float n = l * (1. + l / 9.) / (1. + l);\n    return c * n / l;\n}\n\nfloat vignette(vec2 fc)\n{\n    vec2 uv = fc / iResolution.xy * 2. - 1.;\n    float v = length(uv);\n    return 1. - v * v * v * .25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;;\n\n    vec3 ro = vec3(0,0,-12);\n    vec3 rd = normalize(vec3(uv, 2));\n    vec3 p;\n    float d, t = 0., i = 0.;\n    \n    for(;i < 1. && t < 120.;i += 1./256.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        if(abs(d) < .0001 * t) break;\n        t += d;\n    }\n    vec3 ld = normalize(vec3(1));\n    vec3 n = normal(p, d);\n\n    float l = dot(ld, n) * .5 + .5;\n    float s = shadow(p + n * .01, ld);\n    l *= s;\n    float spec = pow(clamp(dot(reflect(rd, n), ld), 0., 1.), 32.) * s;\n    float e = exp(-t * .05 + .3);\n    vec3 fog = mix(vec3(.025,.1,.15), vec3(2.,1.55,1.22), clamp(l * e + clamp(dot(rd, ld) * 2. - 1.,0.,1.) * .1, 0., 1.));\n    vec3 col = mix(vec3(l) + spec * 3., fog, 1. - e);\n   \n    col = mix(vec3(lum(col)), col, 1.5);\n    col = reinhard(col);\n    col = pow(col, vec3(1./2.2));\n    col *= vignette(fragCoord);\n    //col = vec3(i);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllBzM.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[113, 113, 132, 132, 205], [207, 207, 228, 228, 752], [754, 754, 775, 775, 825], [827, 827, 857, 857, 1034], [1036, 1036, 1067, 1067, 1311], [1313, 1313, 1332, 1332, 1378], [1380, 1380, 1403, 1403, 1493], [1495, 1495, 1520, 1520, 1626], [1628, 1628, 1685, 1685, 2641]], "test": "untested"}
{"id": "NlsfzM", "name": "AI Escape valve", "author": "xenn", "description": "Basic Kleinian group limit set with fully dynamic GI (+ temporal reprojection denoising and some weird hacky thing where I try to accumulate encoded lighting data from neighboring pixels) plus a bunch of very superfluous postprocess effects. ", "tags": ["3d", "raymarching", "fractal", "math", "gi", "global", "dof", "bokeh", "pathtracing", "kleinian", "montecarlo", "apollonian"], "likes": 13, "viewed": 433, "published": 3, "date": "1650652255", "time_retrieved": "2024-07-30T16:52:06.227127", "image_code": "\n\n// Fork of \"Kleinian Landscape\" by amoser. https://shadertoy.com/view/WttBRr\n// 2022-04-22 17:47:11\n\n// Final post-processing\n// \n\n// Sample scene color with FXAA, 0-1 range uvs\nvec4 sceneColor(vec2 uv)\n{\n    vec4 outColor = vec4(FXAA(uv, iChannel1, 1.0/iResolution.xy), 1.0);\n    \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvAspectCorrected = uv - 0.5;\n    uvAspectCorrected = vec2(uvAspectCorrected.x*(iResolution.x/iResolution.y), uvAspectCorrected.y);\n    uvAspectCorrected += 0.5;\n    \n    // Fringe\n\tconst int fringeSamples = 64;\n    float fringeAmount = fringeStrength*saturate(distance(uvAspectCorrected, vec2(0.5))-fringeStart);\n\n    vec4 outColor = vec4(0);\n\n    if(fringeAmount > 0.0)\n    {\n        for(int i = 0; i < fringeSamples; i++)\n        {\n            float fringe = 1.0+(float(i-fringeSamples/2)*fringeAmount)/float(fringeSamples);\n            outColor += vec4(sceneColor(((uv-0.5)*fringe + 0.5)))*HUE(mod(0.85-1.0*float(i)/float(fringeSamples), 1.0));\n        }\n        outColor /= float(fringeSamples)*0.6;\n    }\n    else\n    {\n        outColor = vec4(sceneColor(uv));\n    }\n\n    \n    // Vignette\n    outColor *= pow(saturate(1.25-1.5*distance(uv, vec2(0.5))), 0.9);\n    outColor += 0.001*(hash12(fragCoord+mod(iTime, 512.0)*0.21+0.1*iMouse.xy)-0.5);\n    \n    // Saturation / discolor highlights\n   // outColor = mix(outColor, vec4(1, 1, 0.66, 1)*vec4(dot(outColor.rgb, luma)), 1.0-saturate(1.05-dot(outColor.rgb, luma))); \n    \n    // Saturation / discolor shadows\n   //               outColor = mix(outColor, vec4(0.6, 0.8, 1, 1)*vec4(dot(outColor.rgb, luma)), saturate(0.3-3.0*dot(outColor.rgb, luma))); \n    \n    // Tonemap + color grade\n  // \toutColor = toneMap(outColor, vec3(0.95,0.95,0.85), vec3(1.15, 1.3, 1.3));\n    \n    // Ungraded tonemap\n    outColor = toneMap(outColor, vec3(1), vec3(1));\n    \n    fragColor = pow(outColor, vec4(1.0/gamma));\n    \n    // For debugging depth\n    //fragColor = vec4(1.0-UDEPTH(fragCoord)*maxDepth);\n    // For debugging GI\n\t//fragColor = textureLod(iChannel0, uv, 0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Path tracing, partly based (unsurprisingly) on iq's implementation\n//\n// Single sample, one bounce, but stores indirect bounces as \"point lights\" for re-use across neighboring pixels (done in Buffer B) so we only compute final direct light here.\n// I have no idea if any of this is a good idea, but it was a fun experiment.\n// Supports specular (GGX) with multiple importancs sampling, and uses a roughness map\n\nvec4 orbitTrap;\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nfloat intersect(in ray ray, int maxSteps, float bias)\n{\n    float res = -1.0;\n\n    float t = bias;\n    \n    for(int i=1; i<maxSteps+1; i++ )\n    {\n\t\tvec3 samplePoint = ray.origin+ray.direction*t;\n        if (samplePoint.y >= 1.0 || samplePoint.y <= -1.0 )//|| max(abs(samplePoint.x),abs(samplePoint.z)) >= 6.0)\n        {\n            return -1.0;\n        }\n\n        float h = sceneDistanceFunction(samplePoint, orbitTrap);\n        if(h < mix(0.0001, 0.01, saturate(distance(ray.origin, samplePoint)/12.0)/*smoothstep(0.0, 6.0, distance(ray.origin, samplePoint))*/) || t > maxDepth) \n        {\n            break;\n        }\n        //if( h<0.0012 || t>tmax ) break;\n        t +=  h;\n    }\n    \n    if(t<maxDepth) \n    {\n        res = t;\n    }\n    \n    return res;\n}\n\n// TODO this\n/*\nvec3 dropToFloor(in vec3 origin, int maxSteps)\n{\n    float res = -1.0;\n    \n    float t = 0.001;\n    for(int i=1; i<maxSteps+1; i++ )\n    {\n\t\tvec3 samplePoint = origin + vec3(0, -1, 0)*t;\n        if (samplePoint.y >= 1.0 || samplePoint.y <= -1.0 )//|| max(abs(samplePoint.x),abs(samplePoint.z)) >= 6.0)\n        {\n            // No floor found\n            return origin;\n        }\n        float h = sceneDistanceFunction(samplePoint, orbitTrap);\n        if(h < 0.001 || t > maxDepth)\n        {\n            break;\n        }\n        t +=  h;\n    }\n    \n    if(t<maxDepth) \n    {\n        res = t;\n    }\n    \n    return origin + vec3(0, -res, 0);\n}\n*/\n\nfloat shadow(in ray ray, int maxSteps)\n{\n    float res = 0.0;\n\n    float t = 0.001;\n    \n    float k = 8.0;\n    \n    float h = 0.1;\n    \n    for(int i=1; i<maxSteps+1; i++ )\n    {\n        vec3 samplePoint = ray.origin+ray.direction*t;\n        if (samplePoint.y >= 1.0 || samplePoint.y <= -1.0 )//|| max(abs(samplePoint.x),abs(samplePoint.z)) >= 6.0)\n        {\n            return 1.0;\n        }\n        h = sceneDistanceFunction(ray.origin+ray.direction*t, orbitTrap);\n        res = min( res, (k*h)/t );\n        //if( h<0.0015*pow(distance(ray.origin, samplePoint), 1.0) || t>tmax) break;\n        if(h < 0.00009 || t > maxDepth) \n        {\n            break;\n        }\n        t += h;\n    }\n\n    if(t > maxDepth)\n    {\n        res = 1.0;\n    }\n    \n    return res;\n}\n\nfloat softShadow(in ray ray, int maxSteps/*float mint, float k*/)\n{\n    float k = 4.0;\n    float res = 0.0;\n    float t = 0.001;\n\tfloat h = 1.0;\n    \n    for( int i=0; i<int(maxSteps); i++ )\n    {\n        h = sceneDistanceFunction(ray.origin + ray.direction*t, orbitTrap);\n\n        if(res<0.001)\n        {\n            break;\n        }\n        t += h;//clamp( h, 0.01, 0.05 );\n    }\n    return 1.0-saturate(res);\n}\n\nvoid calculateColor(ray cameraRay, float sa, vec2 fragCoord, out vec3 camHitPosition, out float depth, out vec3 camHitNormal, out vec3 baseColor, out vec3 directLight, out vec3 indirectLight, out pointLight bounceLight, vec3 sunDirection, vec3 sunColor)\n{\n    const float epsilon = 0.0001;\n    float seed = mod(iTime, 1024.0)+0.13*iMouse.x+1.25*iMouse.y;\n    \n    vec3 bounceColor = vec3(1);\n    \n    vec3 totalDirect = vec3(0);\n    vec3 totalGi = vec3(0);\n    \n    ray currentRay = cameraRay;\n    \n    // TODO manually unroll bounces to reduce number of ifs?\n    for(int bounce = 0; bounce<2; bounce++)\n    {\n        currentRay.direction = normalize(currentRay.direction);\n        \n       \n        float traced = -1.0;\n        if(bounce == 0)\n        {\n            traced = intersect(currentRay, 128, 0.005);\n        }\n        else\n        {\n            traced = intersect(currentRay, 80, 0.005);\n        }\n        if(traced < 0.0)\n        {\n            if( bounce==0 ) \n            {\n                // No hit, draw BG\n                vec3 bgColor = getSky(currentRay, sunDirection, sunColor);\n                totalDirect = bgColor;\n\n                // Out\n                directLight = bgColor;\n                indirectLight = vec3(0);\n\n                return;\n            }\n            break;\n        }\n\n        vec3 position = currentRay.origin + currentRay.direction*traced;\n        vec3 surfaceNormal = calcNormal(position);\n        \n        vec3 triplanarNormal = surfaceNormal;\n\t\t\n        float emissiveFactor = saturate((1.0 - orbitTrap.z*50.0)*100000.0);\n        \n        vec3 emissiveColor = pow(((sin(position.x*5.0+mod(iTime, 1024.0)/2.0)+1.0)/2.0), 8.0)*1.33*pow(vec3(0.35,1.0,0.55),vec3(2.0))*emissiveFactor + 0.02*vec3(0.35,1.0,0.55)*emissiveFactor;\n\n        vec3 surfaceColor1 = vec3(0.7);\n        vec3 surfaceColor2 = vec3(0.6, 0.5, 0.8);\n\n        vec3 surfaceColor = mix(surfaceColor1, surfaceColor2, saturate((orbitTrap.y*3.5-0.25)*1.0))*(1.0-emissiveFactor) + emissiveFactor*(vec3(0.5,0.8,1.0));\n        \n        #ifdef ROUGHNESS_MAP\n        \tfloat roughness = saturate(pow(triPlanarMapCatRom(iChannel2, 5.0, triplanarNormal, position*7.0, iChannelResolution[2].xy), vec3(2.0)).r*2.0);\n\t\t#else\n        \tconst float roughness = 0.4;\n        #endif\n        \n\t\t// Direct lighting\n        vec3 iColor = vec3(0.0);\n\n        // Direct sun light\n        vec3 currentSunDir = sunDirection;\n        \n        float sunDiffuse = 0.0;\n        float sunSpec = 0.0;\n\n        if(bounce == 0)\n        {\n            sunDiffuse = saturate(dot(currentSunDir, surfaceNormal))*0.9;\n            sunSpec = GGX(surfaceNormal, -currentRay.direction, currentSunDir, roughness, 0.1);\n        }\n        else\n        {\n            sunDiffuse = saturate(dot(currentSunDir, surfaceNormal));\n            sunSpec = 0.0;\n        }\n        float sunShadow = 1.0;\n        if(sunDiffuse > 0.0) \n        {\n            sunShadow = shadow(ray(position + surfaceNormal*epsilon, currentSunDir), 80);\n        }\n\n        iColor += sunColor*sunDiffuse*sunShadow + sunColor*sunSpec*sunShadow;\n        \n        // Carry surface color through next bounce\n        vec3 previousBounceColor = bounceColor;\n        bounceColor *= surfaceColor;\n\n\t\tif(bounce == 0)\n        {\n            totalDirect += bounceColor*iColor + emissiveColor;\n            // Out\n            camHitPosition = position;\n            depth = traced;\n            baseColor = surfaceColor;\n            camHitNormal = surfaceNormal;\n        }\n        else if(bounce == 1)\n        {\n            totalGi += bounceColor*iColor + emissiveColor;\n\n            // Virtual point light from direct lighting of first bounce, accumulated in Buffer B\n            bounceLight.worldPosition = position;\n            bounceLight.normal = surfaceNormal;\n            bounceLight.color = (previousBounceColor*iColor + emissiveColor);\n\n            // TODO texture map\n            \n            float lightDistance = distance(bounceLight.worldPosition, camHitPosition);\n            float NdotL = saturate(dot(normalize(camHitNormal), normalize(bounceLight.worldPosition - camHitPosition)));\n            \t\n            if(NdotL > 0.00001 && length(baseColor) > 0.00001)\n            {\t\n                // Cancel out cosine distribution\n                bounceLight.color /= NdotL;\n                // Cancel out inverse square attenuation \n                bounceLight.color *= lightDistance*lightDistance;\n                // For debugging direct light\n                //bounceLight.color *= 0.0;\n            }\n        }\n\n\t\t// Send bounce ray\n        vec3 reflectDirection = reflect(normalize(currentRay.direction), normalize(surfaceNormal));\n        currentRay.direction = cosineDirection(surfaceNormal, fragCoord, seed);\n\n        currentRay.origin = position;\n    }\n    \n    // Out\n\tdirectLight = totalDirect;\n    indirectLight = totalGi;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 rt, in float cr)\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3(cu, cv, -cw);\n}\n//Marching parameters\n#define MAXSTEPS 50\n#define HITTHRESHOLD 0.009\n#define FAR 64.\n//AA : change to 1 to turn it off\n#define AA 1\n//IFS iterations : try 2 or 3\n#define NIFS 6\n//scale and translate for the IFS in-loop transformation\n#define SCALE 2.3\n#define TRANSLATE 4.5\n\nmat2x2 rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2x2(c, -s,\n\t\t\t\t  s, c);\n}\n\nvec4 sd2d(vec2 p, float o)\n{\n    float time = 0.2*o+0.6*iTime;\n \tfloat s =.5+0.25*cos(iTime/2.);\n    p*= s;\n    float RADIUS =(1.+sin(iTime));\n    int i;\n    vec3 col;  \n    p = p*rot(-0.4*time);// twist\n\n    for ( i = 0; i<NIFS; i++)\n    {        \n        if (p.x<0.) {p.x = -p.x;col.r++;}\n\t\tp = p*rot(0.9*sin(time));\n        if (p.y<0.) {p.y = -p.y;col.g++; }\n        if (p.x-p.y<0.){ p.xy = p.yx;col.b++;}        \n      \tp = p*SCALE-TRANSLATE;\n        p = p*rot(0.3*(iTime));\n    }\n    \n    float d = 0.425*(length(p)-RADIUS) * pow(SCALE, float(-i))/s;\n    col/=float(NIFS);\n    vec3 oc = mix(vec3(0.7,col.g,0.2),vec3(0.2,col.r,0.7), col.b);\n    \n    return vec4(oc,d);\n}\n\nvec4 map (vec3 p)\n{\n\treturn sd2d(p.xz,p.y);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float h = 0.;\n    float k =3.5;//shadowSmooth\n    float res = 1.;\n    float t = 0.2; //bias\n    for (int i = 0; t < 15.; i++) // t < shadowMaxDist\n    {\n        h = map(ro + rd * t).w;\n\t\tres = min(res, k*h / t);\n        if (h < HITTHRESHOLD)\n        {\n           break;\n        }\n        t = t + h;\n    }\n    return clamp(res+0.05,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    //camera\n    float height = -0.4;\n    float rot=iTime*0.05;\n    float dist= 32.+6.*sin(0.5*iTime);\n    vec3 ro = dist * vec3(cos(rot),height,sin(rot));\n   \tvec3 lookAt = vec3 (0.,0.,0.);\n    vec3 fw = normalize(lookAt-ro);\n    //tilting camera for a \"weirder\" feel when rotating around Y axis\n    vec3 right = normalize(cross(vec3(0.,1.,1.0), fw));\n    vec3 up = normalize(cross (fw, right));\n    right = normalize(cross(up,fw));\n    \n    //light\n    rot+=sin(iTime)*0.2;\n    vec3 lightPos =  dist * vec3(cos(rot),height,sin(rot));\n    \n    //raymarch\n    vec3 pos, closest;\n    float t;\n    float smallest;\n    int i;\n    vec3 sdfCol; \n    vec3 col;\n    \n    for (int x=0; x<AA;x++)\n    for (int y=0; y<AA;y++)\n    {\n        t = 0.; smallest = 500.;\n        vec2 o = vec2(float(x),float(y)) / float(AA) - 0.5;\n        vec2 uv = (fragCoord+o)/iResolution.xy;\n        uv -= 0.5;\n        uv.x *= iResolution.x/iResolution.y; \n        vec3 rd = normalize( fw *0.5 + right * uv.x + up * uv.y);  \n        \n        for ( i=0; i<MAXSTEPS; i++)\n        {\n            pos = ro + rd *t;   \n            vec4 mr = map(pos);\n            float d = mr.w;\n            if (d < smallest) smallest = d; closest = pos; sdfCol = mr.rgb;\n            if (abs(d)<HITTHRESHOLD || t> FAR) {break;}\n            t +=d;\n        }   \n        pos = closest;\n        vec3 c;\n        if (t<FAR)\n        { \n            c = sdfCol; \n            vec3 toLight = normalize(lightPos-pos);\n            float s = shadow(pos,toLight);\n            c*=s; \n          \tc = mix(c, 1.5*c,1.-s);\n        }\n        else \n        {\n            c = vec3(0.);                \n        }     \n        col += c;\n    }\n    col/=float(AA*AA);\n    \n    fragColor = vec4 (col,t);\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n    vec2 jitter = vec2(hash12(vec2(13.1, mod(float(iFrame*4),4096.0))),hash12(vec2(4.1, mod(float(iFrame*3),4096.0))))*AAjitter-(AAjitter/2.0);\n    \n    vec2 jitteredCoord = fragCoord + jitter;\n    vec2 uv = jitteredCoord/iResolution.xy;\n\tvec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n    \n    float sa = hash13(vec3(iFrame, fragCoord.x, fragCoord.y));\n    \n    ray cameraRay;\n    \n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n\t    mouseLocation += iTime/9.0;\n    #endif\n    #ifdef INTERACTIVE\n\t    mouseLocation += 0.002*iMouse.x;\n    #endif\n    \n    vec3 sunDirection = initialSunDirection;\n    vec3 sunColor = initialSunColor;\n    \n    #ifdef ANIMATE_SUN\n\t    sunDirection.yz *= ROT(mod(iTime*0.05, PI*2.0));\n    \tsunDirection.xy *= ROT(sin(mod(iTime*0.025, PI*2.0)));\n    \n    \t// \"moon\"\n    \tif (sunDirection.y <= 0.0)\n        {\n            float colorMix = smoothstep(0.0, -0.2, sunDirection.y);\n            if(sunDirection.y <= -0.2)\n            {\n\t            sunDirection.y += 0.2;\n    \t        sunDirection.y *= -1.0;\n        \t    sunDirection.y -= 0.2;\n            }\n           \tsunColor = mix(sunColor, moonColor, colorMix);\n        }\n\t#endif\n\n\n    // TODO more interesting camera movement\n    // TODO avoid intersections\n    cameraRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    //cameraRay.origin.y = 1.0;\n    //cameraRay.origin = dropToFloor(cameraRay.origin, 7) + vec3(0, 0.02, 0);\n    cameraRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    cameraRay.direction.xyz = normalize(cameraRay.direction.xzy);\n    \n    vec3 color = vec3(0.0);\n    \n    // Results from ray tracing to pack up for use in subsequent passes\n    pointLight bounceLight;\n    vec3 baseColor = vec3(0);\n    vec3 camHitPosition;\n    vec3 directLight;\n    vec3 indirectLight;\n    vec3 camHitNormal;\n    float depth;\n    \n\tcalculateColor(cameraRay, sa, fragCoord, camHitPosition, depth, camHitNormal, baseColor, directLight, indirectLight, bounceLight, sunDirection, sunColor);\n    \n    float dither = 0.008*hdrScale*(hash12(fragCoord+mod(iTime, 512.0)*0.21+0.1*iMouse.xy)-0.5);\n    \n    depth /= depthScale;\n    if(depth <= 0.0 || depth > maxDepth)\n    {\n        depth = maxDepth;\n    }\n    \n    directLight += dither;\n    bounceLight.color += dither;\n    \n    directLight /= hdrScale;\n    indirectLight /= hdrScale;\n    bounceLight.color /= hdrScale;\n    bounceLight.worldPosition /= depthScale;\n    \n    // Clamp brightness, preserve color\n    float totalLight = max(max(length(indirectLight), length(directLight)),  length(bounceLight.color));\n    if(totalLight >= 1.0)\n    {\n        directLight /= totalLight;\n        indirectLight /= totalLight;\n        bounceLight.color /= totalLight;\n    }\n    \n    // For debugging\n    //NdotL = saturate(dot(normalize(camHitNormal), normalize(bounceLight.worldPosition*depthScale - camHitPosition)));\n    //virtualPointColor = baseColor*bounceLight.color*NdotL;\n    //indirectLight = virtualPointColor;\n    //bounceLight.color = indirectLight;\n    \n    // For debugging\n    //bounceLight.color = camHitPosition/depthScale;//clamp(bounceLight.worldPosition, 0.0, depthScale);\n    //bounceLight.color = camHitNormal;\n    //bounceLight.color = bounceLight.worldPosition;\n    \n    \n    \n    // Buffer packing layout:\n    // x = vec4(directLight.rgb, baseColor.r)\n    // y = vec4(bounceLight.color.rgb, baseColor.g)\n    // z = vec4(bounceLight.position.xyz, baseColor.b)\n    // w = vec4(normal.xyz, depth)\n    \n    //#ifdef STORE_NORMAL\n        // Tried packing both normal and depth, loses too much precision in depth to be useful for temporal reprojection\n    //    fragColor = vec4(pack(vec4(directLight, baseColor.r)), pack(vec4(bounceLight.color, baseColor.g)), pack(vec4(bounceLight.worldPosition, baseColor.b)), pack(vec4(camHitNormal/2.0 + 0.5, pow((saturate(depth)), 1.0/depthDistributionExponent))));\n    //#else\n   // \tfragColor = vec4(pack(vec4(directLight, baseColor.r)), pack(vec4(bounceLight.color, baseColor.g)), pack(vec4(bounceLight.worldPosition, baseColor.b)), pow((saturate(depth)), 1.0/depthDistributionExponent));\n    //#endif\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Kleinian Landscape\n//\n// Except where otherwise specified or cited, all work is my own and available under\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Constants, helper functions\n// \n\n#define CLAMP_INDIRECT\n#define ANIMATE_CAMERA\n#define ANIMATE_SUN\n#define INTERACTIVE\n#define ROUGHNESS_MAP\n#define INDIRECT_GATHER_CHECK_DIRECTION\n\n\n////////// GENERAL\n\n#define PI 3.1415926536\n\nconst float gamma = 2.2;\n\n// Dynamic range; keep as low as possible since these buffers are packed with very low precision\nconst float hdrScale = 1.0;\nconst float depthScale = 1.0;\nconst float maxDepth = 32.0;\nconst float depthDistributionExponent = 1.0;\n\nconst vec3 luma = vec3(0.299, 0.587, 0.114);\nconst float goldenAngle = 2.4;\n\n#ifdef TEMPORAL_JITTER\n\tconst float AAjitter = 1.0;\n#else\n\tconst float AAjitter = 0.0;\n#endif\n\nfloat saturate(float a)\n{\n    return clamp(a, 0.0, 1.0);\n}\n\n// from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// from Fabrice Neyret\n#define ROT(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define HUE(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0) ) )\n\n\n\n// Buffer unpacking\n#define UBOUNCE_COLOR(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).y))\n#define UBOUNCE_POSITION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).z))\n#define UBOUNCE_LIGHT(coord) (texelFetch(iChannel2, ivec2(coord), 0))\n#define UBOUNCE_LIGHT_BLUR(coord) UBOUNCE_LIGHT(coord)\n\n#define UDIRECT_ILLUMINATION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).x))\n#define UNORMAL(coord) (((unpack(texelFetch(iChannel0, ivec2(coord), 0).w)).xyz - 0.5)*2.0)\n#define UDEPTH(coord) (pow(texelFetch(iChannel0, ivec2(coord), 0).w, depthDistributionExponent))\n\n#define UDEPTH_CHANNEL1(coord) (texelFetch(iChannel1, ivec2(coord), 0).w)\n#define UBASE_COLOR(coord) vec3((unpack(texelFetch(iChannel0, ivec2(coord), 0).x)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).y)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).z)).w)\n\n// Color packing from cornusammonis: https://www.shadertoy.com/view/Xlfcz8\nuint packSnorm4x8(vec4 x) \n{\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 unpackSnorm4x8(uint x) \n{\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n\n#define unpack(x) unpackSnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packSnorm4x8(x))\n\n\n////////// SCENE\n\nstruct pointLight\n{\n    vec3 worldPosition;\n    vec3 normal;\n    vec3 color;\n};\n    \nstruct directionalLight\n{\n    vec3 worldPosition;\n    float angle;\n    vec3 color;\n};\n    \nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float metal;\n};\n\nvec3 initialSunDirection = normalize(vec3(-0.2, 0.7, -0.4));\nvec3 initialSunColor = 1.25*vec3(1.0,0.60,0.3);\n// \"Moon\" is just sun reflected and re-colored when it crosses horizon line\nvec3 moonColor = 1.5*vec3(1.0,0.60,0.3)*vec3(0.25, 0.45, 0.75);\nvec3 skyColor = vec3(0);\n\n// Sphere inversion fractal, similar to iq's \"Apollonian\" (https://www.shadertoy.com/view/4ds3zn) but with octogonal symmetry\nfloat map(vec3 p, inout vec4 orbitTrap)\n{\n    const float s = 1.0;//0.97;\n    const float horizontalWrap = sqrt(s*2.0)/2.0;\n    \n\tfloat scale = 1.0;\n\n\torbitTrap = vec4(1000.0); \n    \n    for(int i=0; i<9; i++)\n\t{\n        p.xz /= horizontalWrap;\n        vec3 pOffset = (0.5*p+0.5);\n\n        vec3 pOffsetWrap = 2.0*fract(pOffset);\n        \n        p = -1.0 + pOffsetWrap;\n        p.xz *= horizontalWrap;\n        \n\t\tfloat r2 = dot(p,p);\n\t\t\n        if(i < 2)\n        {\n\t        orbitTrap.z = min(orbitTrap.z, vec4(abs(p),r2).z);\n        }\n        if(i > 2)\n        {\n            orbitTrap.xyw = min(orbitTrap.xyw, vec4(abs(p),r2).xyw);\n        }\n        \n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat fractal = 0.33*abs(p.y)/scale;\n    return fractal;\n}\n\nfloat sceneDistanceFunction(vec3 p, inout vec4 orbitTrap)\n{\n    return map(p, orbitTrap);\n}\n\nvec3 calcNormal(in vec3 position)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n    vec4 dummyOrbitTrap;\n\n    return normalize( \n        vec3(\n        sceneDistanceFunction(position+eps.xyy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.xyy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yxy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yxy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yyx, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yyx, dummyOrbitTrap))\n    \t);\n}\n\nvec3 getSky(ray cameraRay, vec3 sunDirection, vec3 sunColor)\n{\n    // TODO could take dot product with some random hemisphere samples to create fake stars\n    vec3 bgColor = vec3(1.0);\n\n    #ifdef WATER\n        if(cameraRay.direction.y < 0.0)\n        {\n            cameraRay.direction *= vec3(1, -1, 1);\n            bgColor *= waterColor;\n        }\n    #endif\n\n    bgColor *= skyColor + saturate((dot(cameraRay.direction, sunDirection)-.9975)*800.0)*sunColor*80.0 + saturate(dot(cameraRay.direction, sunDirection)+0.75)*sunColor*0.015;\n\treturn bgColor;\n}\n\n\n////////// PATH TRACING\n    \nconst int unpackedNone = 0;\n\n// TODO flags for applying filters to packed textures\n/*\nconst int unpackedDirect = 1;\nconst int unpackedBounce = 2;\nconst int unpackedDepth = 3;\nconst int unpackedBaseColor = 4;\n*/\n\n// from hornet, who says:\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 sampleLevel0(sampler2D sceneTexture, vec2 uv, float mipLevel)\n{\n    return textureLod(sceneTexture, uv, mipLevel);\n}\nvec4 SampleTextureCatmullRom(sampler2D sceneTexture, vec2 uv, vec2 texSize, float mipLevel, int getPacked)\n{\n    vec4 result = vec4(0.0);\n    if(getPacked == unpackedNone)\n    {\n        // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n        // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n        // location [1, 1] in the grid, where [0, 0] is the top left corner.\n        vec2 samplePos = uv * texSize;\n        vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n        // Compute the fractional offset from our starting texel to our original sample location, which we'll\n        // feed into the Catmull-Rom spline function to get our filter weights.\n        vec2 f = samplePos - texPos1;\n\n        // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n        // These equations are pre-expanded based on our knowledge of where the texels will be located,\n        // which lets us avoid having to evaluate a piece-wise function.\n        vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n        vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n        vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n        vec2 w3 = f * f * (-0.5 + 0.5 * f);\n\n        // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n        // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n        vec2 w12 = w1 + w2;\n        vec2 offset12 = w2 / w12;\n\n        // Compute the final UV coordinates we'll use for sampling the texture\n        vec2 texPos0 = texPos1 - vec2(1.0);\n        vec2 texPos3 = texPos1 + vec2(2.0);\n        vec2 texPos12 = texPos1 + offset12;\n\n        texPos0 /= texSize;\n        texPos3 /= texSize;\n        texPos12 /= texSize;\n        \n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos0.y), mipLevel) * w0.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos0.y), mipLevel) * w12.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos0.y), mipLevel) * w3.x * w0.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos12.y), mipLevel) * w0.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos12.y), mipLevel) * w12.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos12.y), mipLevel) * w3.x * w12.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos3.y), mipLevel) * w0.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos3.y), mipLevel) * w12.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos3.y), mipLevel) * w3.x * w3.y;\n    }\n    \n    return result;\n}\n\n\nvec3 triPlanarMap(sampler2D inTexture, float contrast, vec3 normal, vec3 position)\n{\n    vec3 xTex = textureLod(inTexture, (position).yz, 0.0).rgb;\n    vec3 yTex = textureLod(inTexture, (position).xz, 0.0).rgb;\n    vec3 zTex = textureLod(inTexture, -(position).xy, 0.0).rgb;\n    vec3 weights = normalize(abs(pow(normal.xyz, vec3(contrast))));\n    \n    return vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z);\n}\n\n// from tux: https://www.shadertoy.com/view/lsj3z3\nvec3 triPlanarMapCatRom(sampler2D inTexture, float contrast, vec3 normal, vec3 position, vec2 texResolution)\n{\n    vec3 signs = sign(normal);\n    \n    vec3 xTex = SampleTextureCatmullRom(inTexture, (position).yz, texResolution, 0.0, 0).rgb;\n    vec3 yTex = SampleTextureCatmullRom(inTexture, (position).xz, texResolution, 0.0, 0).rgb;\n    vec3 zTex = SampleTextureCatmullRom(inTexture, -(position).xy, texResolution, 0.0, 0).rgb;\n    \n    vec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n  \n    return clamp(vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z), vec3(0), vec3(1));\n}\n    \n\n// from iq\nvec3 cosineDirection(in vec3 nor, vec2 fragCoord, float seed)\n{\n    vec2 randomSeed = (fragCoord * .152 + seed * 1500. + 50.0);\n    vec2 random = hash22(randomSeed);\n    float u = random.x;\n    float v = random.y;\n    \n    // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n\n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n\n// Camera projection stuff\nvec3 stereographicPlaneToSphere(vec2 cartPointOnPlane) \n{\n    float x2 = cartPointOnPlane.x*cartPointOnPlane.x;\n    float y2 = cartPointOnPlane.y*cartPointOnPlane.y;\n    return vec3(\n        (2.0*cartPointOnPlane.x) / (1.0 + x2 + y2), \n\t    (-1.0 + x2 + y2) / (1.0 + x2 + y2),\n        (2.0*cartPointOnPlane.y) / (1.0 + x2 + y2));\n}\nvec2 stereographicSphereToPlane(vec3 cartPointOnSphere) \n{\n    return vec2(\n        cartPointOnSphere.x / (1.0-cartPointOnSphere.y), \n        cartPointOnSphere.z / (1.0-cartPointOnSphere.y));\n}\nvec2 cameraRayToUv(ray cameraRay, float projectionDist)\n{\n    vec2 uv = vec2(normalize(cameraRay.direction).x, normalize(cameraRay.direction).y);\n    uv *= projectionDist/dot(normalize(cameraRay.direction), vec3(0, 0, projectionDist));\n    return uv;\n}\nray uvToCameraRay(vec2 uv, float projectionDist)\n{\n    ray cameraRay;\n    cameraRay.direction = normalize(vec3(uv.x, uv.y, projectionDist));\n    return cameraRay;\n}\n\n\n////////// POST\n\n// Bloom settings\nconst float bloomIntensity = -0.2;\nconst float bloomRadius = 0.6;\n\n// Fringe/chromatic aberration settings\nconst float fringeStrength = 01.91;\nconst float fringeStart = 0.0;\n\n// Bokeh settings\nconst float bokehScale = 0.75;\nconst float bokehClamp = 0.0125;\nconst float bokehForceSharp = 0.01;\nconst float bokehFringe = 0.6;\nfloat bokehAspectRatio = 1.75;\n\n// FXAA settings\nconst float spanMax = 1.0;\nconst float reduceMult = (1.0/spanMax);\nconst float reduceMin = (1.0/48.0);\nconst float subPixelShift = (1.0/4.0);\n\nvec3 FXAA( vec2 uv2, sampler2D tex, vec2 rcpFrame) \n{\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + subPixelShift)));\n   \n    float lumaTopLeft = dot(textureLod(tex, uv.zw, 0.0).xyz, luma);\n    float lumaTopRight = dot(textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomLeft = dot(textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomRight = dot(textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaCenter  = dot(textureLod(tex, uv.xy, 0.0).xyz,  luma);\n\n    float lumaMin = min(lumaCenter, min(min(lumaTopLeft, lumaTopRight), min(lumaBottomLeft, lumaBottomRight)));\n    float lumaMax = max(lumaCenter, max(max(lumaTopLeft, lumaTopRight), max(lumaBottomLeft, lumaBottomRight)));\n\n    vec2 direction;\n    direction.x = -((lumaTopLeft + lumaTopRight) - (lumaBottomLeft + lumaBottomRight));\n    direction.y =  ((lumaTopLeft + lumaBottomLeft) - (lumaTopRight + lumaBottomRight));\n\n    float dirReduce = max(\n        (lumaTopLeft + lumaTopRight + lumaBottomLeft + lumaBottomRight) * (0.25 * reduceMult),\n        reduceMin);\n    float rcpDirMin = 1.0/(min(abs(direction.x), abs(direction.y)) + dirReduce);\n    \n    direction = min(vec2( spanMax,  spanMax),\n          max(vec2(-spanMax, -spanMax),\n          direction * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + direction * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + direction * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// \"Airy disc\" bloom, complete gibberish and not based on anything physical; I just like the way it looks.\nvec4 getBloom(sampler2D sceneTexture, vec2 uv, vec2 resolution, float seed, float aspectRatio)\n{ \n    vec2 randomSeed = (uv*resolution * .152 + seed);\n    float random = hash12(randomSeed)*PI*2.0;\n\n    float stepsCenter = 7.0;\n    float stepsRing = 6.0;\n    float mipLevel = log2(resolution.x)/2.25;\n    vec4 outColor = vec4(0);\n    \n    float bloomSum = 0.0;\n    float weight = 0.0;\n    float totalBloom = 0.0;\n\n    vec2 radius = vec2(bloomRadius);\n    radius.y *= aspectRatio;\n\n    vec2 offsetUv = uv;\n    \n    for(float j = 1.0; j < (stepsCenter + 1.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsCenter + 1.0), 0.75))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 1.0;\n        \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsCenter), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    radius *= 2.0;\n    \n    for(float j = 2.0; j < (stepsRing + 2.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsRing + 2.0), 0.25))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 0.5;\n       \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsRing), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    return outColor/totalBloom;\n}\n\nvec4 toneMap(vec4 inputColor, vec3 gamma, vec3 exposure)\n{\n    vec3 gradedColor = vec3(pow(inputColor.r,gamma.r)*exposure.r,pow(inputColor.g,gamma.g)*exposure.g,pow(inputColor.b,gamma.b)*exposure.b);\n    vec4 graded = vec4(1.0-1.0/(gradedColor + vec3(1.0)), inputColor.w);\n    \n    vec3 x = clamp(graded.xyz,0.0001,0.999);\n    \n    // ACES tone mapping approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return vec4(clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0001,0.999), inputColor.z);\n}", "buffer_b_code": "// Final indirect light \n//\n// Makes use of what we computed in Buffer A.\n// Recalculates screen space normals (they couldn't be stored properly in the buffer packing scheme without precision issues).\n\n// Recalculate world position from depth, texture coordinate for reconstructing normal\n// TODO optimize, or use a simpler camera projection\nvec3 reCalcWorldPosition(vec2 uv)\n{\n    vec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n    ray currentRay;\n    \n    // Current frame ray direction, camera ray and direction must match Buffer A\n\n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n    mouseLocation += iTime/9.0;\n    #endif\n\n    #ifdef INTERACTIVE\n    mouseLocation += 0.002*iMouse.x;\n    #endif\n\n    currentRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    currentRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    currentRay.direction.xyz = normalize(currentRay.direction.xzy); \n\n    \n    // Recover world position of current frame intersection point from ray direction\n    float pixelDepthForReprojection = UDEPTH(uv*iResolution.xy)*depthScale;\n    return (currentRay.direction)*pixelDepthForReprojection + currentRay.origin;\n}\n\n// Reconstructs screen space normal for deferred rendering. Bad.\nvec3 reCalcNormalFast(vec2 uv)\n{\n    float offsetPixel = 1.0;\n    \n    vec3 center = reCalcWorldPosition(uv);\n    \n    // Only sample two points, but vary which ones per frame in the hopes that temporal AA will smooth out artifacts\n    if(iFrame % 4 == 0)\n    {\n        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));\n        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));\n    \n        return normalize(cross(up-center, center-right));\n    }\n    else if(iFrame % 4 == 1)\n    {\n        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));\n        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(center-down, left-center));\n    }\n    else if(iFrame % 4 == 2)\n    {\n        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));\n        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(up-center, left-center));\n    }\n    else\n    {\n        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));\n        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(center-down, center-right));\n    }\n}\n\n// Reconstructs normal for deferred rendering using distance function. Slow.\nvec3 reCalcNormalSlow(vec2 uv)\n{\n    float offsetPixel = 1.0;\n    vec3 center = reCalcWorldPosition(uv);\n    return calcNormal(center);\n}\n\n// Get the indirect lighting from a \"virtual point light\" as stored in Buffer A\nvec3 getVirtualLightContribution(vec2 uv, vec2 offsetUv, vec3 baseColor, float roughness, vec3 camHitNormal, vec3 camHitPosition, out float dotProduct, out float brdfRef)\n{\n    // Avoid hotspots from lights nearly touching geometry\n    float minDistance = 0.2;\n    \n    vec3 lightPosition = UBOUNCE_POSITION(offsetUv*iResolution.xy).xyz*depthScale;\n    \n    // Diffuse\n    float diffuse = saturate(dot(normalize(camHitNormal), normalize(lightPosition - camHitPosition)))*0.9;\n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n    \tmouseLocation += iTime/9.0;\n    #endif\n\n    #ifdef INTERACTIVE\n    \tmouseLocation += 0.002*iMouse.x;\n    #endif\n    vec3 camOrigin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    float specular = GGX(normalize(camHitNormal), -normalize(camHitPosition - camOrigin), normalize(lightPosition - camHitPosition), roughness, 0.1);\n    \n    \n    float lightDistance = max(distance(lightPosition, camHitPosition), minDistance);\n    float lightDistance2 = lightDistance*lightDistance;\n    dotProduct = dot(reCalcNormalFast(uv), reCalcNormalFast(offsetUv));\n    \n    brdfRef = diffuse + specular;\n    \n    return ((UBOUNCE_COLOR(offsetUv*iResolution.xy).rgb))/lightDistance2;\n}\n\n// This is where we accumulate the \"point lights\" from neighboring pixels that we stored in Buffer A\n// Requires some ad hoc corrections since this causes us to miss some occlusion/shadows, but since everything is localized to nearby pixels it works pretty OK?\nvec3 accumulateLights(vec2 uv)\n{\n    int steps = 32;\n    vec2 radius = max(vec2(.01), 13.0/iResolution.xy);\n    const float goldenAngle = 2.4;    \n    \n    float depth = UDEPTH(uv*iResolution.xy)*depthScale;\n    vec3 baseColor = UBASE_COLOR(uv*iResolution.xy)/hdrScale;\n    vec3 camHitNormal = reCalcNormalSlow(uv);\n    vec3 camHitPosition = reCalcWorldPosition(uv);\n    \n    vec2 offsetUv = uv;\n    vec3 sum = vec3(0);\n    float totalBlur = 0.0;\n    float weight = 1.0; \n    float dotProduct = 1.0;\n    float brdfRef = 1.0;\n    // Counterproductive to apply pixel jitter to low-discrepency points...\n    //float seed = nrand(uv*iResolution.xy + vec2(mod(iTime*131.5,4096.0), mod(iTime*535.1,4096.0)));\n    float seed = hash11(mod(iTime*33.1, 1024.0));\n    mat2 rot = ROT(mod(seed, 2.0*PI));\n    \n    #ifdef ROUGHNESS_MAP\n    \tfloat roughness = saturate(pow(triPlanarMapCatRom(iChannel2, 5.0, camHitNormal, camHitPosition*7.0, iChannelResolution[2].xy), vec3(2.0)).r*2.0);\n    #else\n    \tconst float roughness = 0.4;\n    #endif\n    \n    // Start with \"correct\" GI contribution (i.e. the path that was actually sent for this pixel)\n    sum += getVirtualLightContribution(uv+0.0, uv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);\n    sum *= brdfRef;\n    totalBlur += 1.0;\n  \n    for(float i = 0.0; i < float(steps); i++)\n    {       \n        // Rotated Hammersley disc kernel\n        //offsetUv = uv + ((hammersleyDisk(int(i), steps)))*radius*rot;\t\n        // Spiral kernel\n        offsetUv = uv + (radius*pow(((i+1.0)/float(steps)), 0.5))*vec2(sin(mod((i+1.0)*goldenAngle+seed, 2.0*PI)), cos(mod((i+1.0)*goldenAngle+seed, 2.0*PI)));\n\n        dotProduct = 1.0;\n        vec3 sampledIndirect = getVirtualLightContribution(uv, offsetUv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);\n        float sampledDepth = UDEPTH(floor(offsetUv*iResolution.xy))*depthScale;\n\n        // TODO magic numbers\n        weight = 1.0;\n        \n        // Add hoc occlusion part 1\n        #ifdef INDIRECT_GATHER_CHECK_DIRECTION\n        \tif((dotProduct < 0.7) || distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)\n        #else\n            if(distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)\n        #endif\n        {\n            weight = 0.0;\n        }\n        \n        // Ad hoc occlusion part 2\n        float curOcclusion = saturate(200000.0*(depth-sampledDepth-0.03));\n        weight *= saturate(1.0-curOcclusion);\n\n        sum += brdfRef*sampledIndirect*weight;\n        totalBlur += weight;\n    }\n    \n    // Fade into shadow when we don't have good sample coverage\n    sum *= smoothstep(1.0, 2.0, totalBlur);\n    \n    return hdrScale*(baseColor*sum)/totalBlur;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 baseColor = UBASE_COLOR(fragCoord)/hdrScale;\n    vec3 indirectLight = accumulateLights(uv);\n    #ifdef CLAMP_INDIRECT\n\t    indirectLight = min(indirectLight, vec3(hdrScale/2.0));\n    #endif\n    float depth = UDEPTH(fragCoord);\n    \n    float currentDepthMin = 100000.0;\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,0))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,0))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(0,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(0,-1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,-1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,-1))*1.0, currentDepthMin);\n    \n    fragColor = vec4(indirectLight, pow(currentDepthMin, 1.0/depthDistributionExponent));\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Temporal AA / denoise\n//\n// Lots more terrible ad hoc corrections to reduce ghosting, \"fireflies\" etc.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n       \n    vec2 fragCoordDejittered = fragCoord;\n    vec2 uvDejittered = uv;\n    \n    vec3 currentDirect = UDIRECT_ILLUMINATION(fragCoordDejittered).rgb*hdrScale;\n    currentDirect = max(vec3(0), currentDirect);\n    \n    vec3 currentIndirect = vec3(0);\n    \n    currentIndirect = UBOUNCE_LIGHT(fragCoordDejittered).rgb*hdrScale;\n    currentIndirect = max(vec3(0), currentIndirect);\n    currentIndirect = clamp(currentIndirect, vec3(0.0001), vec3(hdrScale));\n       \n    float currentDepth = UDEPTH(fragCoordDejittered)*depthScale;\n    \n    float currentDepthMax = 0.0;\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,0))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,0))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(0,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(0,-1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,-1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,-1))*depthScale, currentDepthMax);\n\n    float currentDepthMin = 100000.0;\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,0))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,0))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(0,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(0,-1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,-1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,-1))*depthScale, currentDepthMin);\n    \n    float oldDepthMax = 0.0;\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,0)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,0)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(0,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(0,-1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,-1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,-1)), oldDepthMax);\n\n\n    float oldDepthMin = 100000.0;\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,0)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,0)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(0,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(0,-1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,-1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,-1)), oldDepthMin);\n    \n    ray currentRay;\n    // Current frame ray direction, camera ray and direction must match Buffer A\n    \n    \n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n\t    mouseLocation += /*0.01*iMouse.x+*/ + iTime/9.0;\n    #endif\n    \n    #ifdef INTERACTIVE\n\t    mouseLocation += 0.002*iMouse.x;\n    #endif\n  \n    currentRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    currentRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    currentRay.direction.xyz = normalize(currentRay.direction.xzy); \n\n    // Recover world position of current frame intersection point from ray direction\n    float pixelDepthForReprojection = UDEPTH(uv*iResolution.xy)*depthScale;\n    vec3 currentWorldPosition = normalize(currentRay.direction)*pixelDepthForReprojection*2.0 + currentRay.origin;\n\n    // Previous frame data\n    vec3 prevRayOrigin = texelFetch(iChannel1, ivec2(0), 0).xyz;\n    vec3 prevWorldPosition = currentWorldPosition+(currentRay.origin - prevRayOrigin);\n    vec3 prevRayDirection = prevWorldPosition-prevRayOrigin;\n    float prevPixelDepth = length(prevRayDirection);\n    prevRayDirection = normalize(prevRayDirection);\n    \n    // Find warped UV coords based on world space position of this pixel at previous frame\n    prevRayDirection.xzy = prevRayDirection.xyz;\n    vec2 prevUv = stereographicSphereToPlane(normalize(prevRayDirection))*1.5 + 0.5;\n    prevUv = vec2(prevUv.x/(iResolution.x/iResolution.y), prevUv.y);\n       \n    // Store temporal reprojection parameters\n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store latest camera pos for reprojection\n        fragColor.xyz = currentRay.origin;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Copy second-latest camera pos for reprojection\n        fragColor.xyz = texelFetch(iChannel1, ivec2(0,0), 0).xyz;\n        return;\n    }\n    \n    // Sample history color with Catmull-Rom filter\n    // since bilinear results in too much blurring from repeated re-sampling of reprojected history\n    vec3 oldColor = textureLod(iChannel1, prevUv, 0.0).rgb;\n    vec3 oldColorSharp = SampleTextureCatmullRom(iChannel1, prevUv, iChannelResolution[1].xy, 0.0, 0).rgb;\n   \n    // HW filtering is fine for depth\n    float oldDepth = textureLod(iChannel1, prevUv, 0.0).w*depthScale;\n    \n    bool offscreen = false;\n    float mixWeight = 0.0;\n    \n    // Don't read offscreen pixels or region reserved for non-color (camera) data\n    vec2 borderPadding = 1.0*vec2(1.0/(ceil(iResolution.x)), 1.0/(ceil(iResolution.y)));\n    if(prevUv.x <= borderPadding.x || prevUv.y <= borderPadding.y || prevUv.x >= 1.0 - borderPadding.x || prevUv.y >= 1.0 - borderPadding.y ||\n       (floor(prevUv.y*iResolution.y) <= 1.0 && floor(prevUv.x*iResolution.x) <= 10.0))\n    {\n        offscreen = true;\n    }\n\t\n    // TODO dilate motion vector, i.e. take longest in neighborhood?\n    // BUG for some reason this seems to behave differently based on overall distance to camera -- precision issue?\n    mixWeight = max(0.0,(50.0*(sqrt(currentDepth)-sqrt(oldDepth)-0.01)));\n    //mixWeight += saturate(200.0*(currentDepth-oldDepth));\n    mixWeight = (mixWeight + 0.04);\n\n    vec2 biasUv = vec2(0);\n   \t\n    mixWeight = saturate(mixWeight);\n\n    // Don't use Catmull-Rom for newly-unoccluded regions since they are extremely noisy\n    if(mixWeight < 0.1 && !offscreen)\n    {\n        oldColor = oldColorSharp;\n    }\n    \n    if(offscreen)\n    {\n       mixWeight = 1.0;\n    }\n    \n    #ifdef CLAMP_INDIRECT      \n        vec3 blurredGi1 = textureLod(iChannel2, uvDejittered, 1.5).rgb*hdrScale;\n        currentIndirect = min(currentIndirect, blurredGi1 + 0.01);\n        currentIndirect = max(currentIndirect, blurredGi1 - 0.02);\n\n        vec3 blurredGi2 = textureLod(iChannel2, uvDejittered, 2.5).rgb*hdrScale;\n        currentIndirect = min(currentIndirect, blurredGi2 + 0.03);\n        currentIndirect = max(currentIndirect, blurredGi2 - 0.04);\n\n        if(mixWeight > 0.15 || offscreen)\n        {\n            // Blur indirect pixels more when we don't have history data\n            vec3 blurredGi3 = textureLod(iChannel2, uvDejittered, 4.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi3 + 0.005);\n            currentIndirect = max(currentIndirect, blurredGi3 - 0.04);\n\n            vec3 blurredGi4 = textureLod(iChannel2, uvDejittered, 5.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi4 + 0.01);\n            currentIndirect = max(currentIndirect, blurredGi4 - 0.08);\n\n            // For debugging. Also happens to look neat.\n            //currentIndirect = vec3(1,0,0);\n        }\n        else\n        {\n            vec3 blurredGi5 = textureLod(iChannel2, uvDejittered, 4.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi5 + 0.08);\n            currentIndirect = max(currentIndirect, blurredGi5 - 0.1);\n        }\n    #endif\n    \n    //currentDirect += bloomIntensity*getBloom(iChannel1, prevUv, iChannelResolution[0].xy, mod(iTime*139.8 + iMouse.x, 4096.0), bokehAspectRatio*iResolution.x/iResolution.y).rgb;\n       \n    vec3 combinedColor = mix(oldColor, currentDirect + currentIndirect, mixWeight);\n    \n    if(currentDepth >= maxDepth - 0.01)\n    {\n        vec3 sunDirection = initialSunDirection;\n        vec3 sunColor = initialSunColor;\n        #ifdef ANIMATE_SUN\n            sunDirection.yz *= ROT(mod(iTime*0.05, PI*2.0));\n            sunDirection.xy *= ROT(sin(mod(iTime*0.025, PI*2.0)));\n            // \"moon\"\n            if (sunDirection.y <= 0.0)\n            {\n                float colorMix = smoothstep(0.0, -0.2, sunDirection.y);\n                if(sunDirection.y <= -0.2)\n                {\n                    sunDirection.y += 0.2;\n                    sunDirection.y *= -1.0;\n                    sunDirection.y -= 0.2;\n                }\n                sunColor = mix(sunColor, moonColor, colorMix);\n            }\n        #endif\n\n        combinedColor.rgb = getSky(currentRay, sunDirection, sunColor);\n    }\n    \n    combinedColor = clamp(combinedColor, vec3(0.0001), 2.0*vec3(hdrScale));\n\n\n\n    // For debugging\n    //float minMaxVisualize = distance(currentDepthMin, oldDepthMin) + distance(currentDepthMax, oldDepthMax);\n \n    float combinedDepth = currentDepth/depthScale;\n    \n    // For debugging\n    //fragColor = vec4(vec3(minMaxVisualize), combinedDepth);\n    //fragColor = vec4(vec3(mixWeight), combinedDepth);\n    //fragColor = vec4(vec3(biasUv, 0.0), combinedDepth);\n    //fragColor = vec4(vec3(distance(oldDepthMax, oldDepthMin)), combinedDepth);\n    //fragColor = vec4(vec3(distance(currentDepthMax, currentDepthMin)), combinedDepth);\n    //fragColor = vec4(blurGi(uv), combinedDepth);\n    //fragColor = vec4(currentDirect + currentIndirect, combinedDepth);\n    \n    fragColor = vec4(combinedColor, combinedDepth);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Bokeh with fake color fringing + autofocus, anamorphic (including realistic \"swirly\" artifacts near edges)\n//\n// Ended up quite hairy/hacky from to trying to avoid edge/background bleed artifacts, but works pretty well.\n// I originally wanted to do a separable version but didn't have enough buffers left, so it's fairly slow.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 randomSeed = (fragCoord * .152 + iTime * 1500. + iMouse.x);\n    float random = hash12(randomSeed)*PI*2.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float depth = textureLod(iChannel0, uv, 0.0).w*depthScale;\n        \n    // Autofocus\n    float focalDepth = texelFetch(iChannel1, ivec2(0), 0).w;\n    float focalDepthNew = min(min(min(textureLod(iChannel0, vec2(0.5, 0.25), 5.5).w*depthScale, textureLod(iChannel0, vec2(0.6, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.4, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.5, 0.5), 8.0).w*depthScale);\n    focalDepth = mix(focalDepth, focalDepthNew, 0.05);\n    \n    vec2 offsetUv = vec2(0);\n    vec4 foregroundColor = vec4(0);\n    vec4 backgroundColor = vec4(0);\n    vec4 midgroundColor = vec4(0);\n    vec4 midgroundColorNoFringe = vec4(0);\n    vec4 totalColor = vec4(0);\n    \n    const float steps = 32.0;\n    const float stepsSmooth = 24.0;\n    \n    vec2 radiusClamp = vec2(bokehClamp);\n    radiusClamp.y *= iResolution.x/iResolution.y;\n    \n    // Radius of circle of confusion based on depth at current pixel\n    vec2 trueRadius = vec2(bokehScale);\n    trueRadius.y *= iResolution.x/iResolution.y;\n    trueRadius *= 1.0-focalDepth/depth;\n  \n    vec2 erodedRadius = vec2(1);\n    vec2 smoothedRadius = vec2(0);\n    \n    const float additionalDilation = 1.25;\n    const float searchMipLevel = 0.0;\n    \n    // Preprocess, estimate kernel size etc.\n    for(float i = 0.0; i < stepsSmooth; i++)\n    {   \n        vec2 searchRadius = additionalDilation/**vec2(1.0/bokehAspectRatio, 1)*/*(radiusClamp*pow((i)/steps, 0.5));\n        offsetUv = uv + searchRadius*vec2(sin(i*goldenAngle/* + random*/), cos(i*goldenAngle/* + random*/));\n        \n        float depthGathered = textureLod(iChannel0, offsetUv, searchMipLevel).w*depthScale;\n\n        vec2 radiusGathered = vec2(bokehScale);\n        radiusGathered.y *= iResolution.x/iResolution.y;\n        radiusGathered *= 1.0-focalDepth/depthGathered;\n        \n        if(length(radiusGathered) >= length(radiusClamp))\n        {\n            radiusGathered = radiusClamp;\n        }\n        \n        smoothedRadius += abs(radiusGathered);\n        erodedRadius = min(abs(radiusGathered), erodedRadius);\n    }\n    smoothedRadius /= stepsSmooth;\n    \n    // Main blur\n    // Limited radius\n    vec2 radiusBias = vec2(bokehForceSharp);\n    radiusBias.y *= iResolution.x/iResolution.y;\n    vec2 radius = max(vec2(0), smoothedRadius-radiusBias);\n    radius /= (1.0-bokehForceSharp);\n    \n    float totalBlur = 0.0;\n    bool fringeValid = true;\n    \n    // Try to sample from lower-res mips to reduce noise, but don't want to go too low and introduce any visible blockiness\n    float mipLevel = min(max(log2(length(erodedRadius*iResolution.xy/3.0))+0.5, 0.0), max(log2(length(min(smoothedRadius, trueRadius)*iResolution.xy/3.0))-1.5, 0.0));   \n    mipLevel = min(mipLevel, 2.0);\n  \n    vec4 currentColor;\n    vec4 colorFringed;\n    float falloff = 1.0;\n    float vignette = 1.0;\n    if(length(radius) > 1.0/length(iResolution.xy))\n    {\n        for(float i = 0.5; i < steps; i++)\n        {   \n            vec2 offset = (radius*pow(i/steps, 0.5))*vec2(sin(i*goldenAngle + random), cos(i*goldenAngle + random));\n            \n            // \"Swirly\" bokeh\n            offset *= ROT(atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)-PI);\n            if(offset.y >= radius.y-3.0*(radius.y)*distance(uv, vec2(0.5)))\n            {\n                vignette = saturate(offset.y - (radius.y-3.0*(radius.y)*distance(uv, vec2(0.5))));\n                vignette = saturate(1.0 - 0.8*vignette/radius.y);\n                vignette = saturate(0.0001 + vignette);\n                offset.y /= 1.0+saturate(1.0-vignette)/2.0;\n                \n            }\n            offset *= ROT(-atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)+PI);\n\n            offset *= vec2(1.0/bokehAspectRatio, 1);\n            \n            offsetUv = uv + offset;\n\n            falloff = ((i+1.0)/steps);\n\n            // Using dilated depth to reduce bleed\n            float depthGathered = textureLod(iChannel2, offsetUv, 0.0).w*depthScale;\n\n            vec2 radiusGathered = vec2(bokehScale);\n            radiusGathered.y *= iResolution.x/iResolution.y;\n            radiusGathered *= 1.0-focalDepth/depthGathered;\n            radiusGathered *= vec2(1.0/bokehAspectRatio, 1);\n          \n            float distanceFromCenter = distance(offsetUv, uv);\n\n            if((depthGathered > depth && length(trueRadius) < bokehScale/6.0 /*&& length(radiusGathered) > length(trueRadius)*/))\n            {\n                float factor = smoothstep(bokehScale/80.0, bokehScale/6.0, length(trueRadius));\n                offsetUv = mix(uv, offsetUv, factor);\n            }\n            float curMipLevel = mipLevel;\n            currentColor = textureLod(iChannel0, offsetUv, mipLevel);\n            colorFringed = currentColor * 12.1*vec4(1.0, 0.16, 0.3, 1.0) * HUE(mod((0.2 + 0.3*float(i)/float(steps-1.0)), 1.0)) * falloff;\n            totalBlur += 1.0*vignette;\n\n            // Is the sample we gathered at a depth such that it would actually be scattered onto the current pixel?\n            if((length(radiusGathered) < distanceFromCenter*0.66))\n            {\n                fringeValid = false;\n                currentColor = vec4(0,0,0,1);\n                colorFringed = vec4(0,0,0,1);\n                totalBlur -= 1.0*vignette;\n            }\n             \n            midgroundColor += mix(currentColor, colorFringed, bokehFringe)*vignette;\n            midgroundColorNoFringe += currentColor*vignette;\n        }\n        // If we rejected some samples, the color fringe would become biased\n        if(!fringeValid)\n        {\n            midgroundColor = midgroundColorNoFringe;\n        }\n        else\n        {\n            midgroundColor = mix(midgroundColorNoFringe, midgroundColor, smoothstep(0.0, 4.0/length(iResolution.xy), length(radius)));\n        }\n        if(totalBlur > 0.0)\n        {\n\t        midgroundColor /= totalBlur;\n        }\n        else\n        {\n            midgroundColor = textureLod(iChannel0, uv, 0.0);\n        }\n    }\n    else\n    {\n        midgroundColor = textureLod(iChannel0, uv, 0.0);\n        // For debugging\n        //midgroundColor = vec4(1,0,0,1)*textureLod(iChannel0, uv, 0.0)*steps;\n    }\n    \n    totalColor += midgroundColor;\n    \n    // Bloom\n    totalColor += bloomIntensity*getBloom(iChannel0, uv, iChannelResolution[0].xy, mod(iTime*13.8 + iMouse.x, 1024.0), bokehAspectRatio*iResolution.x/iResolution.y);\n    \n    // Auto exposure\n    float exposure = texelFetch(iChannel1, ivec2(1, 0), 0).w;\n    float exposureNew = length(textureLod(iChannel0, vec2(0.5, 0.5), 8.0).rgb)*3.0 + 0.5;\n    exposure = mix(exposure, exposureNew, 0.05);  \n    exposure = max(exposure, 0.0) + 0.001;\n    totalColor /= exposure;\n\n    float outAlpha = 0.0;\n    \n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store focal depth\n        fragColor.w = focalDepth;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Store exposure\n        fragColor.w = exposure;\n        return;\n    }\n    \n    fragColor = vec4(totalColor.rgb, fragColor.w);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 180, 206, 206, 306]], "test": "untested"}
{"id": "fllfzM", "name": "Flimsy Balls", "author": "fyisic123", "description": "Here is my first attempt at working with buffers :) Was interested in using them to pass other data than just pixels. I also applied some very flimsy \"physics\" :P \nSettings to play with is under Common. \n", "tags": ["balls", "bounce", "hue", "buffer", "data", "store"], "likes": 7, "viewed": 294, "published": 3, "date": "1650651434", "time_retrieved": "2024-07-30T16:52:07.300258", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{                                  \n    vec3 ballCol = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;  // fetch pixel from buffer C\n    float LumMask = 1. - ((ballCol.r + ballCol.g + ballCol.b) * .333333); // using luminocity to make a mask \n        \n        \n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y; // create background\n    uv *= vec2(8., 16.) * .5;\n    vec2 ID = floor(uv);\n    uv.x += 0.5 * mod(ID.y, 2.); // offsets every other background tile\n    vec2 gv = fract(uv) - .5;    \n    float bg = 0.0 + (0.05 * fract(iTime * 0.1+ log(abs(gv.x + uv.x)))) * LumMask;  \n    \n    \n    fragColor = vec4(ballCol + bg, 1.);\n        \n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n\n\n// changes require \"Reset time\" to work (back play arrow)\n#define BALLCOUNT 50\n#define BALL_MIN_SIZE 20. \n#define BALL_MAX_SIZE 30. \n\n#define TIME_SCALE 50.\n#define MAX_VELOCITY 6.\n#define TRACER_INTENSITY 3.5\n\n\nvec2 hash21(float p) // random stuff\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\nfloat hash11(float p)// random stuff\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)// random stuff\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);   // fragCoord as integers      \n    if (iCoord.x > BALLCOUNT || iCoord.y > 1)  // skip pixels with no saved data\n        return;             \n    if (iCoord.y == 0)  // if its top pixel, deal with postion and direction\n    {\n        vec2 pos1,dir1;        \n        if(iFrame  == 0)  // initialize balls by setting start position and start velocity (direction)\n        {\n            vec2 n1 = hash21(iDate.w + fragCoord.x * 123.1234 );\n            vec2 n2 = hash21(iDate.w + fragCoord.x * 321.123);\n            float n = (n2.x + n2.y) * .5;\n            pos1 = iResolution.xy * n1;   \n            \n            dir1 = normalize(n2) * (0.3 + (MAX_VELOCITY * n));\n            if (n1.x + n2.x > 1.)\n                dir1.x *= -1.;\n            if (n1.y + n2.y > 1.)\n                dir1.y *= -1.;\n        }\n        else  // if already initialized fetch data from buffer  \n        {\n            vec4 data = texelFetch(iChannel1, ivec2(iCoord.x, 0),0).rgba;\n            pos1 = data.rg;\n            dir1 = data.ba;           \n        }        \n        \n        vec2 oldPos = pos1;\n        \n        float speed = iTimeDelta *  TIME_SCALE;  // move ball                       \n        pos1 += (dir1 *speed);       \n        \n        if (pos1.x >= iResolution.x || pos1.x <= 0.)  // change direction if outside of screen.\n        {\n            dir1.x *=-1.;\n            pos1.x = oldPos.x;\n        }\n        else if (pos1.y >= iResolution.y|| pos1.y <= 0.)\n        {\n            dir1.y *=-1.;    \n            pos1.y = oldPos.y;\n        }   \n        pos1.x = clamp(pos1.x, 0. , iResolution.x);\n        pos1.y = clamp(pos1.y, 0. , iResolution.y);\n        fragColor = vec4(pos1.x, pos1.y, dir1.x, dir1.y); // save data in buffer\n    }          \n    else // if its second from top pixel, deal with size and hue\n    {\n        if (iFrame == 0) // if its first frame, initiate \n        {\n            float ID = hash11(iDate.w + fragCoord.x);            \n            float size = BALL_MIN_SIZE + ((BALL_MAX_SIZE - BALL_MIN_SIZE) * ID);\n            fragColor = vec4(ID, size, 0., 0.);        \n        }\n        else // otherwise just pass same data.\n            fragColor = texelFetch(iChannel0, ivec2(iCoord.x, 1),0).rgba;                        \n    \n    }        \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);   // fragCoord as integers  \n    if (iCoord.x > BALLCOUNT || iCoord.y > 1) // make sure pixel contains data otherwise return\n        return;               \n    if (iCoord.y == 1) // if its second top pixel, just pass the existing data on and return\n    {\n        fragColor = texelFetch(iChannel0,iCoord,0).rgba;\n        return;\n    }    \n    vec4 data = texelFetch(iChannel0, iCoord,0).rgba;  // fetch data from pixel\n    vec2 pos1 = data.rg;\n    vec2 dir1 = data.ba;\n    float r1 = texelFetch(iChannel0, ivec2(iCoord.x, 1),0).g;\n    \n    for(int i=0; i < BALLCOUNT; i++)  // check all the balls for collisions and apply new velocity.\n    {\n        if (i != iCoord.x)\n        {\n            vec4 otherOBJ = texelFetch(iChannel0, ivec2(i, 0),0).rgba;\n            vec2 pos2 = otherOBJ.rg;        \n            \n            float r2 = texelFetch(iChannel0, ivec2(i, 1),0).g;\n                        \n            float edgeDist = length(pos1-pos2) -r1  -r2;\n            if (edgeDist < 0.)                        \n            {\n                vec2 dir2 = otherOBJ.ba;                \n                float angle = atan(pos2.y - pos1.y, pos2.x - pos1.x);                                \n                pos1.x = clamp(pos1.x + cos(angle) * edgeDist, 0., iResolution.x);\n                pos1.y = clamp(pos1.y + sin(angle) * edgeDist, 0., iResolution.y);\n                vec2 tanVec = normalize(vec2(-(pos2.x - pos1.x), pos2.y - pos1.y));                \n                vec2 relVel = dir2 - dir1;                \n                float valLength = min(dot(relVel, tanVec) , MAX_VELOCITY);\n                vec2 velCompOn = tanVec * valLength ;\n                vec2 velCompPerp = relVel - velCompOn ;\n                dir1 += velCompPerp;  \n                break;\n            }            \n        }\n    }\n    fragColor = vec4(pos1.x, pos1.y, dir1.x, dir1.y); // set the data to buffer                         \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);  // fragCoord as integers\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n                   \n    vec3 col = vec3(0.);               // Creating tracers by taking avarage of nearby pixels  \n    for (int x = -1; x <= 1; x++)      // then avaraging them. You can also just darken each frame. \n        for (int y = -1; y <= 1; y++)  // but this makes it smoother.\n            col += texelFetch(iChannel1,iCoord+ ivec2(x,y), 0).rgb ;   \n    col /= 9.;\n    col = mix(col, texelFetch(iChannel1,iCoord, 0).rgb, .5);    \n    float d = TRACER_INTENSITY * (1.0 / iFrameRate);\n    col = mix(col, vec3(0.) , clamp(d, 0., 1.) );\n    \n                \n    vec3 bCol = vec3(0.);   // Drawing balls using data from buffer B\n    float p =0.;    \n    for(int i=0; i <= BALLCOUNT; i++)\n    {\n        vec2 pos =texelFetch(iChannel0, ivec2(i,0),0).rg;\n        if (length(fragCoord-pos) < BALL_MAX_SIZE)\n        {\n            vec2 data = texelFetch(iChannel0, ivec2(i, 1),0).rg;\n            float size = data.g * 1.5;\n            float l = length(fragCoord-pos);\n        \n            float p = smoothstep(size,size*0.7, l) * 0.1 ;\n            p += smoothstep(size*0.7,0., l) ;\n            \n            vec3 bCol = hue(data.r - (p * 0.15)) * p ;\n            p = 1. - p;\n            col = vec3(\n            bCol.r + col.r * p, \n            bCol.g + col.g * p, \n            bCol.b + col.b * p);\n        \n        }                        \n    }    \n    fragColor = clamp(vec4(col, 1.), 0., 1.); // clamping to avoid issues with tracers.\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 711]], "test": "untested"}
{"id": "7tXBz7", "name": "paint with deformations", "author": "FabriceNeyret2", "description": "paint deformations with mouse. \n- click and drag: displace. \n- LEFT/RIGHT keys + click or click&drag: rotate to left or right.\n- UP/DOWN keys + click or click&drag:  grow/shrink.\n- DEL: undo\n- rewind: reset", "tags": ["swirl", "distortion", "vortex", "uvmap", "vorticity", "divergencefree", "viamapping"], "likes": 29, "viewed": 955, "published": 3, "date": "1650648862", "time_retrieved": "2024-07-30T16:52:08.213815", "image_code": "// variant of   swirl2 https://shadertoy.com/view/7l2cRz\n//            + displacement https://www.shadertoy.com/view/sdjyRV\n\n// === applies the uv field to a texture =================\n\n//#define fwidth(v) length(vec2(dFdx(v),dFdy(v)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = T(u).xy;                    // distorted uv field\n    O = texture( iChannel1, u );    // apply map\n    \n    float v = length(u-.5);         // apply circle\n    O = mix( O, vec4(1,0,0,0), smoothstep( 1.5, 0.,  abs(v-.3)/fwidth(v) ) );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === distort the uv field ====================\n\n#define keyDown(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n\n#define ortho(D)     vec2( -(D).y, (D).x )              // vec ortho to D\n//#define S(D)       ortho(D) / max( dot(D,D) , 1e-3 )  // irrotational swirl\n  #define S(D)       ortho(D) / max( length(D)*smoothstep(0.,3.,length(D)) , 1e-3 )  / 6e4 // irrotational swirl\n//#define S(D)       ortho(D) * smoothstep(1.,0.,length(D)/.25) *.1\n\nfloat f(float x) {\n    x = abs(x)/.2; \n\treturn x < 1. ? - .02 * smoothstep(1.,0.,x) : 0.;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if ( u== vec2(.5) )                                 // previous mouse pos\n      { O = vec4(iMouse.xy*sign(iMouse.z), T(0).xy);return; }\n      \n    vec2 U = u / R.y, V,\n         M =   iMouse.xy / R.y,\n         d = ( iMouse.xy - T(0).zw ) / R.y;             // mouse drag direction\n    if (iMouse.z > 0.)  {                               // if click\n       float s = keyDown(37) ? -1. : keyDown(39) ? 1.   // key pressed\n               : keyDown(38) ? 2.  : keyDown(40) ? -2. : 0., l;\n       if ( abs(s) == 1. )                              // --- left or right key : swirl\n           U +=  S(U-M)  * sign(s);                 // swirl field\n       else  if ( abs(s) == 2. )                        // up or bottom key : grow/shrink\n           l = length(U-M),\n           U = M + (U-M) * ( 1. + f(l) * sign(s) ); \n       else if ( T(0).z > 0. )                          // --- drag & no key: displace\n           U -= .5*d *smoothstep(.2,0., length(U-M) );  // displacement field\n    }\n    O = texture( iChannel0, U *R.y/R ); \n    if keyDown(8) O = texture( iChannel1, (N-1. + U *R.y/R ) / N ); \n    \n    if ( iFrame < 1 ) O = vec4(u/R,0,0);                // init uv field\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R      iResolution.xy\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n\n#define N 2.   // N² undo levels\n", "buffer_b_code": "// === undo buffer \n// stores N² frames: if click, or every second if mouse drag\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (iMouse.w <= 0. && ( iMouse.z<=0. || iFrame%60>0 ))  { O = T(U); return; }\n    U *= N/R;\n    vec2 I = floor(U), F = fract(U);\n    if (I.x>0.) I.x--; else I.x = N-1., I.y--;\n    O = I.y < 0. ? texture(iChannel1, F)\n                 : texture(iChannel0,(I+F)/N);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 274, 274, 518]], "test": "untested"}
{"id": "stffz7", "name": "Cubes in a Box (sound)", "author": "incription", "description": "the tri function! try changing all the constants in common, they should all work", "tags": ["sound", "music", "satisfying"], "likes": 13, "viewed": 395, "published": 3, "date": "1650647815", "time_retrieved": "2024-07-30T16:52:09.315869", "image_code": "#define F(x,y) c = mix(x, c, smoothstep(0., fwidth(y), y))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.5;\n    \n    vec3 c = vec3(0);\n    \n    float d = sdBox(uv, BOX_SIZE(iTime) + 1. * vec2(BOX_R));\n    F(vec3(1), opOnion(d, BOX_R));\n    \n    for(int i=0;i<BOXES;i++) {\n        if(i<BOXES-1) F(vec3(1), sdSegment(uv, boxPos(i, iTime), boxPos(i + 1, iTime)) - 0.002);\n    }\n    \n    for(int i=0;i<BOXES;i++) {\n        vec2 pos = boxPos(i, iTime);\n        \n        F(vec3(1), sdBox(pos - uv, vec2(BOX_RADIUS)));\n        F(hue_to_rgb(float(i)/float(BOXES)), sdBox(pos - uv, vec2(BOX_RADIUS - .005)));\n    }\n   \n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "#define BOXES 10\nfloat BOX_RADIUS = .04;\n\nvec2 BOX_SIZE(float time) { return  vec2(.47, .2) * 1.; }\nfloat BOX_R = 0.004;\nvec2 VELOCITY = vec2(0.253, 0.15);\n\nvec3 hue_to_rgb(float hue){\n        float R = abs(hue * 6. - 3.) - 1.;\n        float G = 2. - abs(hue * 6. - 2.);\n        float B = 2. - abs(hue * 6. - 4.);\n        return clamp(vec3(R,G,B), 0., 1.);\n}\n\nvec2 circle(float x) {\n    return vec2(sin(x), cos(x));\n}\n\nvec2 tri(float x, vec2 p) {\n    return 2. * abs(x/p - floor(x/p + .5));\n}\n\nvec2 velocity(int box, float time) {\n    return BOX_SIZE(time) * vec2(VELOCITY * float(box + 1)/float(BOXES));\n}\n\nvec2 boxPos(int box, float time) {\n    vec2 boxSize = BOX_SIZE(time) - BOX_RADIUS;\n    vec2 start = -boxSize;\n    return start + tri(time, boxSize / velocity(box, time)) * 2. * boxSize;\n}\n\n//https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat opOnion( float d, float r )\n{\n  return abs(d) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "sound_code": "vec2 trihi(float x, vec2 p) {\n    p /= 2.;\n    return (x/p - floor(x/p)) / 2.;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float amp;\n    for(int i=0; i<BOXES; i++) {\n        vec2 boxSize = BOX_SIZE(time) - BOX_RADIUS;\n        vec2 period = trihi(time, boxSize / velocity(i, time));\n        \n        float hz = pow(2., (5. * float(BOXES-i))/12.) * 261.625565 * 2.;\n        \n        //if(min(period.x,period.y) < .1) amp = 1.\n        amp += sin(6.2831*hz*time)*exp(-300.0*period.x) * .2;\n        amp += sin(6.2831*hz*time)*exp(-300.0*period.y) * .2;        \n    }\n    \n    if(time < .25) amp = 0.;\n    \n    \n    return vec2( amp );\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stffz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 118, 118, 779]], "test": "untested"}
{"id": "stXfR7", "name": "flower leaf distance 2d test", "author": "yasuo", "description": "flower leaf distance 2d test", "tags": ["flower"], "likes": 6, "viewed": 218, "published": 3, "date": "1650637495", "time_retrieved": "2024-07-30T16:52:10.255357", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a)mat2(cos(a),-sin(a),sin(a),cos(a))\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n// Using the Desmos website to create the following formula\nfloat flowerleaf(vec2 p, float w, float h){\n    p.y-=h;\n    p.x = abs(p.x);\n    float a = (p.x*0.5)-(-(p.x*p.x)-p.y*w);\n    //float b = -(p.x*0.5)-(-(p.x*p.x)-p.y*w);\n    float d = a;\n    d = max(-p.y-(h*2.0),d);\n    return d;\n}\n\nvec3 flower(vec2 p, vec3 col){\n    p*=2.0;\n    p.y-=0.15;\n    vec2 prevP = p;\n    \n    p.x+=sin(p.y*12.0)*0.2*cos(p.x*7.0)*0.5;\n    float d = B(p-vec2(0.0,-0.5),vec2(0.03,0.3));\n    col = mix(col,vec3(0.3,0.4,0.3),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*-20.0));\n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.23);\n\n    d = flowerleaf(p*Rot(radians(45.0)),0.6,0.2);\n    col = mix(col,vec3(0.3,0.0,0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    p*=Rot(radians(iTime*25.0));\n    p = DF(p,2.5);\n    p = abs(p);\n    p -= vec2(0.18);\n\n    d = flowerleaf(p*Rot(radians(45.0)),0.6,0.2);\n    col = mix(col,vec3(0.6,0.0,0.0),S(d,0.0));\n        \n    p = prevP;\n    \n    p*=Rot(radians(iTime*-30.0));\n    p = DF(p,1.5);\n    p = abs(p);\n    p -= vec2(0.1);\n\n    d = flowerleaf(p*Rot(radians(45.0)),0.5,0.2);\n    col = mix(col,vec3(0.8,0.1,0.1),S(d,0.0));\n    \n    p = prevP;\n    \n    p*=Rot(radians(iTime*35.0));\n    p = DF(p,2.0);\n    p = abs(p);\n    p -= vec2(0.07);\n\n    \n    d = flowerleaf(p*Rot(radians(45.0)),0.5,0.1);\n    col = mix(col,vec3(0.9,0.3,0.3),S(d,0.0));\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    p.y-=iTime*0.1;\n    p*=2.;\n    vec3 col = vec3(0.0);\n\n    p = mod(p,0.7)-0.35;\n\n    col = flower(p,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[325, 385, 428, 428, 613], [615, 615, 645, 645, 1720], [1722, 1722, 1779, 1779, 1986]], "test": "untested"}
{"id": "7lsBR8", "name": "Asymmetric Texture Raycasting", "author": "Shane", "description": "A cell by cell traversal of a packed asymmetric rectangle grid texture.", "tags": ["procedural", "grid", "raycast", "dof", "rectangle", "traversal", "packed", "asymmetric"], "likes": 57, "viewed": 1218, "published": 3, "date": "1650633318", "time_retrieved": "2024-07-30T16:52:11.300562", "image_code": "/*\n\n    Asymmetric Texture Raycasting\n    -----------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 8 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 8., coc = 6.;\n    // Linear distance from either side of the focal point.\n    float l = abs(focD - texture(iCh, uv).w)*2.;\n    // Using it to calculate the DOF.\n    vec2 dof = clamp((l - coc)/(1.*coc), 0., 2.)/vec2(800, 450); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)*dof).xyz;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n     \n    \n    // Apply some depth of field, then present to the screen.\n    vec3 col = DpthFld(iChannel0, fragCoord/iResolution.xy);\n    //vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// If you want things to wrap, you need a wrapping scale.  Wrapping is not much \n// different to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash \n// function for anything that's procedurally generated with random numbers. If you're \n// using a repeat texture, then that'll have to wrap too.\nvec3 gSc = vec3(16);\n\n// Maximum frames to perform the precalculation.\nint maxFrames = 1;\n\n   \n#define cubemapRes vec2(1024)\n\n\n/* \n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube iCh, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(iCh, fcP[id]);\n}\n*/\n\n// Wrapping cube face conversion.\nvec2 convert(in vec2 p){ return fract((floor(p*cubemapRes) + .5)/cubemapRes) - .5; }\n\n// Cube face conversion with no wrapping.\n//vec2 convert2(in vec2 p){ return ((floor(p*cubemapRes) + .5)/cubemapRes); }\n\n// Cube face conversion with no wrapping.\nvec4 convert2(in vec4 p){ return ((floor(p*cubemapRes.xyxy) + .5)/cubemapRes.xyxy); }\n\n\nvec4 tx0(samplerCube iCh, vec2 p){\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(-.5, uv.yx));\n \n}\n/*\nvec4 tx1(samplerCube iCh, vec2 p){\n\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(.5, uv.y, -uv.x));\n}\n*/\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n} \n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    p = mod(p, gSc.xy);\n    return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n}\n\n// IQ's vec2 to vec2 hash.\nvec2 hash22(vec2 p){\n    p = mod(p, gSc.xy);\n    return fract(sin(vec2(dot(p, vec2(12.783, 78.137)), dot(p, vec2(41.581, 57.263))))\n                          *vec2(43758.5453, 23421.6361));\n}", "cube_a_code": "\n// Dave Hoskins's vec2 to float hash -- Modified for this particular example.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21B(vec2 p){ \n   \n    \n    p = mod(p, gSc.xy);\n    //return texture(iChannel1, p/gSc.xy).x;\n    //return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); \n    //return (fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453) - .5)*.85; \n    //return hash21(p);\n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.523);\n    return (fract((p3.x + p3.y) * p3.z) - .5)*.85;\n\n}\n\n// The asymmetric block pattern.\n//\n// By the way, you could take a simple line-drawing and partitioning approach to greatly\n// minimize the instruction count, and if 2D bump mapping effects, etc, are all you're\n// after, it might be worth doing. However, if you wish to raymarch this, or do other\n// interesting things, the four rectangles, and corresponding IDs, are a necessary evil.\nvec4 pattern(vec2 p, vec2 sc){\n\n    //p = conv(p);\n\n    vec2 p0 = p;\n\n    vec2 ip = floor(p*sc) + .5; // Grid ID.\n    p -= ip/sc; // Local coordinates.\n    \n    vec3 e = vec3(-1, 0, 1); // Helper vector.\n    \n\n    float h11 = hash21B(ip); // Original cell.\n    \n    float h10 = hash21B(ip + e.xy); // Left.\n    float h01 = hash21B(ip + e.yz); // Top.\n    float h12 = hash21B(ip + e.zy); // Right.\n    float h21 = hash21B(ip + e.yx); // Bottom.\n    \n    float h00 = hash21B(ip + e.xz); // Top left.\n    float h02 = hash21B(ip + e.zz); // Top right.\n    float h22 = hash21B(ip + e.zx); // Bottom right.\n    float h20 = hash21B(ip + e.xx); // Bottom left.\n      \n     \n    vec2[4] ctr;\n    vec2[4] l;\n    \n    \n    // The code looks fiddly, but it's based on a simple idea.\n    // A while ago, I noticed that if you ran vertical and \n    // horizontal lines on alternate checkered tiles, you could\n    // render perpendicular lines on either side at random\n    // positions and everything would line up to form rectangles.\n    // The following is just an implementation of that.\n    \n    // If you uncomment the SHOW_GRID define you'll see that \n    // each cell consists of either a vertical line flanked on\n    // either side by horizontal lines at random Y-positions, or \n    // a horizontal line flanked on either side by vertical\n    // lines at random X-positions.\n    \n    // Implementing the aforementioned is simple enough. However, \n    // lines are great, but cell boundaries -- in order to\n    // render things like blocks would be the thing we'd be more \n    // interested in rendering, so that requires a little more\n    // work.   \t\n    \n    \n    \n    \n    if(mod((ip.x + ip.y), 2.)<.5){ // Horizontal cell.\n\n        // Partition the cell with a randomly positioned horizontal \n        // line and two joining randomly positioned vertical lines\n        // then determine the cell dimensions and cell center of\n        // all four resultant rectangular blocks.\n        \n        // Four block dimensions (X: Width, Y: Height).\n        l[0] = vec2(h01 - h10, h00 - h11) + 1.;\n        l[1] = vec2(-h01 + h12, h02 - h11) + 1.;\n        l[2] = vec2(-h21 + h12, -h22 + h11) + 1.;\n        l[3] = vec2(h21 - h10, -h20 + h11) + 1.;\n        \n        // Four block centers.\n        ctr[0] = vec2(h01, h11) + l[0]*vec2(-.5, .5);\n        ctr[1] = vec2(h01, h11) + l[1]*vec2(.5, .5);\n        ctr[2] = vec2(h21, h11) + l[2]*vec2(.5, -.5);\n        ctr[3] = vec2(h21, h11) + l[3]*vec2(-.5, -.5); \n\n    }\n    else { // Vertical cell.\n\n        // Partition the cell with a randomly positioned vertical \n        // line and two joining randomly positioned horizontal lines\n        // then determine the cell dimensions and cell center.\n        \n        // Four block dimensions (X: Width, Y: Height).\n        l[0] = vec2(-h00 + h11, h01 - h10) + 1.;\n        l[1] = vec2(h02 - h11, h01 - h12) + 1.;\n        l[2] = vec2(h22 - h11, -h21 + h12) + 1.;\n        l[3] = vec2(-h20 + h11, -h21 + h10) + 1.;\n        \n        // Four block centers.\n        ctr[0] = vec2(h11, h10) + l[0]*vec2(-.5, .5);\n        ctr[1] = vec2(h11, h12) + l[1]*vec2(.5, .5);\n        ctr[2] = vec2(h11, h12) + l[2]*vec2(.5, -.5);\n        ctr[3] = vec2(h11, h10) + l[3]*vec2(-.5, -.5); \n        \n\n    }\n                                                                             \n\n    // Debugging: Show the squares with a set single dimension.\n    //l[0] = l[1] = l[2] = l[3] = vec2(.7); // Overlapping: vec2(1.5); \n    \n    // Scaling down the block dimensions.\n    //l[0] /= sc; l[1] /= sc; l[2] /= sc; l[3] /= sc;\n    \n    \n    \n    // Determine the minimum block using the standard method.\n    float d = 1e5;\n    vec2 tileID = vec2(0);\n    //vec2 ctri = vec2(0);\n    vec2 li = vec2(0);\n    vec2 svP;\n     \n  \n    vec3 col;\n    for(int i = 0; i<4; i++){\n    \t \n         vec2 ap = abs(p - ctr[i]/sc) - l[i]/sc/2.;\n         float bx = max(ap.x, ap.y);\n    \t//float bx = sBoxS(p - ctr[i]/sc, l[i]/sc/2., 0.);\n        \n        if(bx<d) {\n            d = bx;\n            tileID = (ip + ctr[i]);\n            //ctri = ctr[i];\n            li = l[i];\n            svP = p - ctr[i]/sc;\n            \n            float rnd = hash21(tileID);\n            \n            col = .5 + .5*cos(6.2831*rnd + vec3(0, 1, 2));\n        }\n        \n    }\n    \n    \n    // Return the distance value of the closed rectangular block\n    // and it's cell center, which doubles as a unique ID. In this\n    // case, though, we're returning the the tile center and \n    // and tile dimensions.\n    //return vec4(svP, li);//li/s\n    return vec4(tileID/sc, li/sc);//vec4(tileID/sc, li/sc);\n//return vec4(d, col);//li/s\n}\n\n\n\nvec4 funcFace0(vec3 q3){\n\n\n    // Coordinates.\n    vec2 p = (q3.xy); \n    vec4 p4 = pattern(p, gSc.xy);\n    \n    return p4;\n\n\n}\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    // We're only using one cube map face, so don't calculate any others...\n    // or give the annoying compiler a chance to calculate others.\n    if(faceID > 0) return;\n  \n  \n    // Pixel storage.\n    vec4 col = vec4(0);\n    \n    \n    \n    // Precalculation flag: GPUs are annoying. Sometimes, they'll will calculate\n    // both the \"if\" and \"else\" statements every time. The \"if\" part here is extremely\n    // expensive, so we don't want that. The solution is to not have an \"if-else\"\n    // statement at all.\n    int preCalc = 0;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0, 0).x<2 || iFrame<maxFrames){\n        \n \n        \n        //if(iFrame>=maxFrames) return;\n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==0){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace0(p);\n            //col = mix(col, 1.-funcFace0(p*2.), 1./16.);\n            \n            preCalc = 1;\n           \n        }\n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    \n    \n    if(preCalc == 0 && faceID == 0){\n\n       col = tx0(iChannel0, uv);\n       //col = texture(iChannel0, vec3(-.5, uv.yx - .5));\n       //col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Asymmetric Texture Raycasting\n    -----------------------------\n    \n    This is a cell by cell traversal of a packed asymmetric rectangle grid\n    texture. I've been wanting to put up a ray traversal example that \n    people may not have seen before. I'm pretty sure there are no packed\n    rectangle grid traversals on Shadertoy, and I don't recall seeing a \n    texture traversal either, but there might be a couple lurking around.\n    \n    Traversing a packed rectangle algorithm created in realtime is not the \n    easist thing to do, but it's definitely doable, and it's accurate. \n    Unfortunately, the process is not quite fast enough... Not yet anyway. \n    Reading from a precalculated buffer texture is subject to resolution \n    constraints, but is way faster, so is the lesser of the two evils. \n    Getting pixels to play nice wasn't fun (it never is), but it's done now, \n    so hopefully the next time won't be as frustrating. :)\n    \n    In theory, traversing a texture grid is pretty easy: Read into the\n    texture and read out the precalculated central grid object position\n    ID and object dimensions (width and height for rectangles), then use\n    them to traverse to the next cell position -- Raytracing to rectangle\n    edges isn't rocket science. However, calculations have to be perfect,\n    and pixel resolution contraints don't always allow for that, so various\n    fudges are necessary.\n    \n    Anyway, the purpose of this was just to show that it could be done. I \n    kind of cobbled this together from my other examples, so I wouldn't pay \n    too much attention to it. I'd like to put together a static path\n    traced version later.\n    \n    \n    Related examples:\n    \n    // The packed texture pattern itself was based on an\n    // idea I came up with a while back.\n    Asymmetric Blocks - Shane\n    https://www.shadertoy.com/view/Ws3GRs\n    \n    // For anyone completely new to cell by cell traversal, here's an\n    // unlisted simplified 2D rectangle traversal example that should \n    // be much easier to understand.\n    Minimal Line Traversal - Shane\n    https://www.shadertoy.com/view/sdfBDM\n    \n    \n*/\n\n// Far plane. Ironically, this one is quite close. :)\n#define FAR 25.\n\n\n // Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This is trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   return dot(p - ro, n)/dot(rd, n);\n\n}\n\nvec2 getUV(vec2 p){\n\n    //p /= 2.;\n \n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    vec2 ip = floor(p); //p -= ip;\n    return fract((ip + .5)/cubemapRes) - .5;\n    \n}\n\n// The path is a 2D sinusoid that varies over time, which depends upon the \n// frequencies and amplitudes.\nvec2 path(in float z){ \n    //return vec2(0);\n    return vec2((cos(z*.36/8.) - sin(z*.2/8.)*1.2)*6., sin(z*.12));\n} \n\n\nfloat h(vec2 p){\n\n    // Only one texture read.\n    vec3 tx = texture(iChannel0, p/iChannelResolution[0].xy).xyz;  tx *= tx;///iChannelResolution[0].xy\n    // Greyscale height. Using \"tx.x\" would work, too.\n\tfloat f = dot(tx, vec3(.299, .587, .114));\n    float f2 = f;//min(f, .5);\n    \n    //f = sin(f*6.2831 + iTime)*.5 + .5;\n    // Using the camera path to carve out a channel for the camera to glide through.\n    vec2 pth = path(p.y);\n    float pX = abs(p.x - pth.x); // The channel.\n    f *= min(pX*pX/24., 1.);\n    \n    // Overall height.\n    return f*8. + f2*.5 + pth.y;\n\n}\n\n// Rectangle scale: This was hacked in at the last minute and is a little\n// fickle. Sizes one to about 8 are OK. Lower numbers mean smaller rectangles,\n// which require more traversal steps in the \"raycast\" function.\nconst vec2 txSc = vec2(6);\n\n// Grid cell function.\nvec4 gridID(vec2 p){\n\n    // Same size squares, for comparison. \n    //return vec4(floor(p/txSc) + .5, txSc);\n\n    // Texture multiple ID.\n    vec2 p0 = (floor(p/txSc)*txSc.xy);\n\n    // Texture grid information -- Cube map faces are annoying to read into.\n    vec2 uv = getUV(p/txSc);\n    \n    // Read the texture face information.\n    vec4 hm2 = texture(iChannel3, vec3(-.5, uv.yx)); \n    // Converting to exact pixel positions for wrapping purposes.\n    hm2 = convert2(hm2)*txSc.xyxy;\n\n    // Return the central position and dimension of the nearest rectangle.\n    return vec4((p0 + hm2.xy), hm2.zw);\n\n}\n\n\n\n\n// Sign function without the zero, which can cause problems for some routines.\nvec3 sign2(in vec3 p){ return vec3(p.x<0.? -1 : 1, p.y<0.? -1 : 1,  p.z<0.? -1 : 1); }\n//vec2 sign2(in vec2 p){ return vec2(p.x<0.? -1 : 1, p.y<0.? -1 : 1); }\n\nvec4 raycast(vec3 ro, vec3 rd){\n   \n    // Result.\n    vec4 res = vec4(FAR, 0, 0, 0);\n    \n    // Unit direction sign.\n    vec3 srd = sign2(rd);\n    \n    // Rectangle normals: Any two will do. By the way, there's nothing\n    // stopping you from declaring all four normals for all surrounding\n    // walls, but since you know only two will be in front of the\n    // direction ray at any given time, it makes sense to only choose\n    // two.\n    //\n    // Declare two normals. Any side by side ones will do.\n    vec2 n1 = vec2(-1, 0), n2 = vec2(0, -1); // Right and top edges.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing cell\n    // wall, if you prefer), use the normal index from the back cell wall. This \n    // trick is possible because of the rectangle symmetry. As an aside, for \n    // anyone who doesn't know, dotting the direction ray with the face normal \n    // is something you do in software engines for back face culling.\n    n1 = dot(rd.xz, n1)<0.? -n1 : n1;\n    n2 = dot(rd.xz, n2)<0.? -n2 : n2;\n    \n    // Initiate the ray position at the ray origin.\n    vec3 pos = ro;\n    \n    // Obtain the coordinates of the cell that the current ray position \n    // is contained in -- I've arranged for the cell coordinates to \n    // represent the cell center to make things easier.\n    //vec2 ip = gridID(pos.xz);\n    \n    float t1 = 1e8, t2 = 1e8, tT = 1e8;\n    \n    int hit = 0;\n    \n    vec4 gID = gridID(pos.xz);\n    vec2 ip;// = gID.xy;\n    \n    \n    // Iterate through 24 cells -- Obviously, if the cells were smaller,\n    // you'd need more to cover the distance.\n    for(int i = 0; i<120; i++){ \n\n         \n        ip = gID.xy;\n        float ma = h(ip);\n        \n        // At this point, we haven't advanced the ray to the back of the cell boundary,\n        // so we're at one of the front cell face positions. Therefore, check to see if \n        // we're under the pylon height. If so, we've hit a face, so mark the face as hit, \n        // then break.\n        if(pos.y<ma){\n            // Hit a side.\n            hit = 1;\n            break; \n        \n        } \n        \n        // Ray intersection from the currect cell position to each of the \n        // visible cell walls. Normals face inward.\n        // You pass in the current position, the unit direction ray, a known \n        // point on the cell wall (any will do) and the cell wall's normal.\n        t1 = rayLine(pos.xz, rd.xz, (ip + n1*gID.zw*.5), -n1);\n        t2 = rayLine(pos.xz, rd.xz, (ip + n2*gID.zw*.5), -n2);\n        \n        // Determine the closest edge then record the closest distance and\n        // asign its normal index.\n        vec3 tn = t1<t2? vec3(t1, n1) : vec3(t2, n2);\n        \n        // Top face distance.\n        tT = (ma - pos.y)/rd.y;\n        tT = tT<0. ? 1e8 : tT;\n        \n        \n        // We've now advanced to one of the back faces of the cell. Check to see whether\n        // we're still under the pylon height, and if so, we've hit the top face --  \n        // I always have to think about this, but the logic is that we haven't hit a front\n        // cell face and we're still under the height, so we've hit the top. Anyway, mark \n        // the top face as hit, advance the distance in the Y direction to the top face, \n        // then break.\n        if(tT<tn.x){\n            \n            //dist += tT;\n            pos += rd*tT; \n            hit = 2;\n            break;\n             \n        }      \n         \n    \n        // If this cell's ID matches the ID of the backgound cell, \n        // flag it as hit in order to color it, or whatever.\n        //if(length(cell - ip)<.001){ hit = 1; break; }\n        \n        // Advance the cell index position by the indices of the \n        // cell wall normal that you hit. \n        //ip += tn.yz;\n        // Advance the ray position by the distance to the next cell wall.\n        pos += rd*tn.x;\n        \n        // Textures have fixed size, so increasing the scale effects stepping from\n        // one grid cell to the next. Hence, the \"txSc\" variable.\n        gID = gridID(pos.xz + (srd.xz/1024.)*txSc);// + (srd.xz/1024.)*txSc\n         \n    \n    }\n    \n    float fID = tT<t1 && tT<t2? 0. : t1<t2? 1. : 2.;\n    if(fID == 1.){ fID = dot(rd.xz, vec2(-1, 0))<0.? -fID : fID; }\n    else if(fID == 2.){ fID = dot(rd.xz, vec2(0, -1))<0.? -fID : fID; }\n    \n    res.x = length(pos - ro);\n    if(hit == 0) res.x = FAR;\n    \n    return vec4(res.x, fID, ip);\n    \n}\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better one than this somewhere. \nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);    \n}\n\n// Standard normal function.\nvec3 nr(float fID, vec3 rd) {\n\t\n    vec3 n = fID == 0.? vec3(0, 1, 0) : abs(fID) == 1.? vec3(1, 0, 0) : vec3(0, 0, 1);\n    n *= fID<-.001? -1. : 1.; \n\treturn n;\n}\n\n// Very lame sky with sun-like object. Basically, this was a quick hack to emulate\n// the \"Forest Blurred\" cube map... It needs work. :)\nvec3 getSky(vec3 rd, vec3 ld){\n\n    float lgt = max(dot(rd, ld), 0.);\n    vec3 sky = mix(vec3(.1, .05, .04), vec3(.95, .97, 1)*3., clamp((rd.y + .5),0., 1.))/1.5;\n    sky = mix(sky, vec3(8), pow(lgt, 8.));\n    return min(sky*vec3(1, 1.1, 1.3), 1.);\n}\n\n// Block face pattern field.\nvec3 df(vec2 p){\n    \n    // Asymetric grid pattern.\n    const float sc = 1.5;\n    p /= sc;\n    \n    // Texture multiple.\n    vec2 p0 = floor(p);\n    // Read into the texture (from the cube map face).\n    vec2 uv = getUV(p);\n    vec4 hm2 = texture(iChannel3, vec3(-.5, uv.yx));\n    hm2 = convert2(hm2);\n    // Rectangle distance. \n    vec2 q = abs((uv + .5) - hm2.xy) - hm2.zw/2.;\n    float d = max(q.x, q.y); \n    // Rectangle distance and central ID.\n    return vec3(d, p0 + hm2.xy);\n    \n}\n\nvoid mainImage(out vec4 c, vec2 u){\n\n\n    // Screen coordinates: The coordinates are already in one to one ratio form, so \n    // a simple translation and scaling is all that is necessary in this setting.\n    u = (u - iResolution.xy*.5)/iResolution.y;\n    \n    // Ray origin.\n    vec3 o = vec3(0, 1.5, iTime*1.5);\n    \n    \n    // \"Look At\" position.\n    vec3 lk = o + vec3(0, -.35, 1.);//vec3(0, -.25, iTime);  \n \n    \n\t// Sending the camera and \"look at\" vectors along the path. The \"path\" function is \n\t// synchronized with the distance function.\n    o.xy += path(o.z);\n\tlk.xy += path(lk.z);\n \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n\n    vec3 fwd = normalize(lk - o);    \n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    // Camera.\n    mat3 mCam = mat3(rgt, up, fwd);\n    \n    // Camera movement. Rotation, swivle, etc.\n    mCam *= rot(vec3(-path(o.z).x/64., 0, 0)); // Camera roll.\n    //mCam *= rot(vec3(0, 0, iTime/4.)); // Camera pitch.\n    \n    // Unit direction ray.\n    vec3 r = mCam*normalize(vec3(u, 1./FOV));\n \n    // Directional light.\n    vec3 l = normalize(vec3(.2, .7, .8)); \n\n    // Raycasting\n    vec4 res = raycast(o, r);\n    \n    float t = res.x, d;\n    float fID = res.y;\n    vec2 id = res.zw;\n    \n    t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n    \n    // Scene color, initialized to zero.\n    c = vec4(0);\n    \n    // If we've hit an object, light it up.\n    if(t<FAR){\n    \n        vec3 p = o + r*t, n = nr(fID, r);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        l = normalize(vec3(.7, .8, 1));\n        \n        // Diffuse.\n        float dif = max(dot(l, n), 0.);\n        \n        float sh = 1.;\n        if(dif>0.){\n           vec4 resSh = raycast(p + n*.002, l);\n           \n           if(resSh.x<FAR - 1e-3) sh = 0.; //\n           //if(resSh.x<d - 1e-3) sh = 0.; // Point light.\n           \n        }\n\n        \n        // Scene object color.\n        //\n        // Coloring half the grid objects.\n        float rnd = fract(sin(dot(id, vec2(157, 113)))*43758.5453);\n        //float rnd2 = fract(sin(dot(id + .5, vec2(157, 113)))*43758.5453);\n    \n  \n        // Rectangle ID to texure color.\n        vec3 txC = texture(iChannel1, id/gSc.xy*txSc).xyz; txC *= txC;\n\n         \n        // UV coordinates for each face.\n        vec2 uv = fID == 0.? p.xz : abs(fID) == 1.? p.zy : p.xy;\n        \n        // Texture pattern layers.\n        vec3 tx = texture(iChannel1, rot2(3.14159/3.*1.)*uv/2.).xyz; tx *= tx;\n        vec3 tx2 = texture(iChannel1, rot2(-3.14159/6.*1.)*uv/1. + .5).xyz; tx2 *= tx2;\n        vec3 tx3 = texture(iChannel1, rot2(-3.14159/12.*1.)*uv*2. + 1.).xyz; tx3 *= tx3;\n        // Mixing the layers.\n        tx = mix(tx, tx2, .35);\n        tx = mix(tx, tx3, .35);\n        float gr = dot(tx, vec3(.299, .587, .114));\n        \n        // Applying the texture color and pattern.\n        c.xyz = txC;\n        c.xyz *= (.75 + gr*1.5);\n         \n        \n        // IQ's rim lighting snippet: For anyone not familiar, he's using \n        // the Fresnel factor for some sillouette lighting.\n        float rim = pow(clamp(1. + dot(r, n), 0., 1.), 5.);\n        \n         \n        // Specular reflection. \n        float spe = pow(clamp(dot(l, reflect(r, n)), 0., 1.), 8.);\n        \n        // Grid rectangle central position and dimension.\n        // Note the desperate step hack to ensure we hit the correct cell -- Seems to work.\n        vec4 gID = gridID(p.xz + sign2(r).xz/1024.*txSc);\n       \n        // Lamest AO ever, and not accurate at all. I'll sort it out later.\n        vec2 p2 = (p.xz - gID.xy);\n        float h0 = h(gID.xy);\n        vec4 h4 = vec4(h((gID.xy + vec2(-1, 0))*gID.zw), h((gID.xy + vec2(1, 0))*gID.zw), \n                       h((gID.xy + vec2(0, -1))*gID.zw), h((gID.xy + vec2(0, 1))*gID.zw));\n                       \n        vec4 h4mh0 = h4 - h0;\n        float ao = 1.;\n        float minEdge = min(gID.z, gID.w)/4.;\n        float edge = gID.w/4.;//min(s.x, s.y)/4.;\n        float edge2 = gID.z/4.;//max(s.x, s.y)/4.;\n        \n         \n        float aoSh = .25;\n        if(n.y>.5){\n            if(p2.y>minEdge && h4mh0.w>0.) ao = min(ao, 1. - smoothstep(0., 1., (p2.y - edge)/edge)*aoSh);\n            if(p2.y<-minEdge && h4mh0.z>0.) ao = min(ao, 1. - smoothstep(0., 1., (-p2.y - edge)/edge)*aoSh);\n            if(p2.x<-minEdge && h4mh0.x>0.) ao = min(ao, 1. - smoothstep(0., 1., (-p2.x - edge2)/edge2)*aoSh);\n            if(p2.x>minEdge && h4mh0.y>0.) ao = min(ao, 1. - smoothstep(0., 1., (p2.x - edge2)/edge2)*aoSh);\n        }\n        else {\n            \n            vec4 mEdge4 = vec4(minEdge) - (h4 - h0)/2.;\n            vec4 hp = p.y - h4 - mEdge4;\n             \n            \n            if(n.z<-.5 && hp.z<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.z)/(mEdge4.z))*aoSh);\n            if(n.z>.5  && hp.w<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.w)/(mEdge4.w))*aoSh);\n            if(n.x<-.5 && hp.x<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.x)/(mEdge4.x))*aoSh);\n            if(n.x>.5 && hp.y<0.) ao = min(ao, 1. - smoothstep(0., 1., -(hp.y)/(mEdge4.y))*aoSh);\n             \n        }\n        ao = max(ao, 0.);\n        \n        \n        // Side wall shading. Also a hack, but it's effective.\n        vec2 pth = path(p.z);\n        ao *= pow(clamp((p.y - pth.y + .001)/(h0 - pth.y + .001), 0., 1.), 1.);\n        \n        // Side wall debugging.\n        //if(abs(n.y)<.5) c.xyz *= vec3(2, 1, 1);\n        \n        \n        // Local coordinates.\n        vec2 lc = p.xz - gID.xy;\n        // Domain.\n        vec2 ap = abs(lc) - gID.zw/2.;\n        \n        // Face edges.\n        float fEdge = max(ap.x, ap.y);\n        fEdge = abs(fEdge);\n        fEdge = max(fEdge, -(p.y - h0)) - .01;\n        // Side edges.\n        float sEdge = min(ap.x, ap.y);\n        sEdge = max(-sEdge, (p.y - h0)) - .01;\n        // Combining.\n        fEdge = min(fEdge, sEdge);\n        \n        \n        // Applying the finer pattern to the box faces... This  definitely needs\n        // a tidy up.\n        vec3 d3 = df(uv);\n        vec3 sC = c.xyz; // Old color.\n        vec3 txC2 = texture(iChannel1, hash22(d3.yz + .1)).xyz; txC2 *= txC2;\n        //if(fID == 0.){ // Top of the box only.\n        vec3 smC = txC2;\n        smC *= (.75 + gr*1.5);\n        smC = mix(sC, smC, .5);\n        c.xyz = mix(c.xyz/8., smC, 1. - smoothstep(0., txSc.x*.001*(1. + res.x*res.x*.001), d3.x + .007));\n        //}\n\n   \n        \n        // Applying diffuse lighting, ambient lighting, etc.\n        vec3 cCol = (dif*sh + vec3(1, .8, .5)*spe*sh + vec3(.3, .5, 1)*rim*4. + .25)*ao;\n        c.xyz = c.xyz*cCol;\n        sC = sC*cCol;\n        \n        \n        // Applying the edges. I've hacked a lot of this in after the fact, so will need\n        // to reorder, etc.\n        vec3 svC = c.xyz;\n        float grr = dot(c.xyz, vec3(.299, .587, .114));\n        c.xyz = mix(c.xyz/(.5 + grr*grr), vec3(1), .03/(.5 + grr*grr)); // Lightening.\n        float grrC = dot(sC, vec3(.299, .587, .114));\n        sC = mix(sC/(.5 + grrC*grrC), vec3(1), .03/(.5 + grrC*grrC)); // // Lightening.\n        \n        // Edge rendering.\n        const float ew = .05;\n        c.xyz = mix(c.xyz + .0, mix(sC, vec3(1), .1), \n                    (1. - smoothstep(0., .001*(1. + res.x*res.x*.05), fEdge - ew)));\n        c.xyz = mix(c.xyz, vec3(0), (1. - smoothstep(0., .001*(1. + res.x*res.x*.05), fEdge))*.6);\n        c.xyz = mix(c.xyz, mix(sC, vec3(0), .6),\n                    (1. - smoothstep(0., .001*(1. + res.x*res.x*.05), abs(fEdge - ew) - .01/2.)));\n     \n       \n        \n        // Reflection: Not a proper reflective color pass, but it works well\n        // enough here. If we hit something, render nothing, otherwise, render\n        vec3 ref = reflect(r, n);\n        vec4 resRef = raycast(p + n*.002, ref);\n        vec3 refTx = getSky(ref, l);\n        if(resRef.x<FAR - 1e-3) refTx *= 0.; // Point light.\n        \n        // Fresnel reflection of sorts. This has been poached from one of IQ's examples.\n        float fr = mix(.03, .25, pow(max(0., 1. + dot(r, n)), 3.));\n        c.xyz = mix(c.xyz, min(refTx, 1.)*3., fr);\n        \n        \n        \n        // Debug.\n        //c.xyz = vec3((dif + .5))*ao;\n        \n        \n        \n    }\n    \n    // Applying some distance fog.\n    vec4 fCol = vec4(getSky(r, l), 1);\n    c = mix(clamp(c, 0., 1.), fCol, smoothstep(.2, .8, t/FAR));\n    \n\n    /*\n    // Just the height texture on its own, for anyone interested.\n    vec2 u2 = u + iTime/8.;\n    vec3 d3 = df(u2);\n    float rnd = hash21(d3.yz/32. + .05);\n    //float rnd = hash21(hm2.zw)*.5 + .5;\n    vec3 rCol = .5 + .5*cos(6.2831*rnd*8. + vec3(0, 1, 2)*1.5);\n    c.xyz = mix(vec3(0), rCol, 1. - smoothstep(0., 1./iResolution.y, d3.x));\n    // Equal to the focal point to avoid blurriness from the DOF pass.\n    // Alternatively, you could turn DOF off.\n    t = 8.; \n    */\n    \n    // Temporal blurring. Not used here.\n    //vec4 bTx = texture(iChannel2, u0/iResolution.xy);\n    //c = mix(bTx, vec4(max(c.xyz, 0.), t), 1./2.);\n    \n    // Backbuffer value. The camera to hit point distance is there for DOF calculations.\n    if(iFrame < maxFrames) c = vec4(1);\n    c = vec4(max(c.xyz, 0.), t);\n    \n    \n}", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 905, 942, 988, 1704], [1707, 1707, 1762, 1835, 2043]], "test": "untested"}
{"id": "flsfzH", "name": "Meatballs", "author": "kristemmerman", "description": "An attempt at meat :)\n\n", "tags": ["3d", "noise", "meat"], "likes": 25, "viewed": 579, "published": 3, "date": "1650623023", "time_retrieved": "2024-07-30T16:52:12.052552", "image_code": "float sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = 111.0*p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+(  0.0+  0.0+  0.0));\n    float b = hash1(n+(111.0+  0.0+  0.0));\n    float c = hash1(n+(  0.0+317.0+  0.0));\n    float d = hash1(n+(111.0+317.0+  0.0));\n    float e = hash1(n+(  0.0+  0.0+157.0));\n\tfloat f = hash1(n+(111.0+  0.0+157.0));\n    float g = hash1(n+(  0.0+317.0+157.0));\n    float h = hash1(n+(111.0+317.0+157.0));\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\nfloat fbm_2( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<2; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat map(vec3 p){\n\n\n  float s;\n\n  float s1 =sdSphere(p+vec3(1.0,0.1,0.0), 1.7*(sin(iTime+p.x)*0.005+1.0));\n  float s2 =sdSphere(p+vec3(-1.0,0.0,0.1), 1.8*(sin(iTime+p.x+1.0)*0.005+1.0));\n  s = opSmoothUnion(s1,s2,0.5);\n  \n  vec3 noiseP =p*0.7;\n\n  float n =smoothstep(-0.2,1.0,fbm_4(noiseP*2.0+fbm_4(noiseP*2.0)*1.5))*0.1;\n  s-=n;\n  \n  float skin = smoothstep(0.5,1.0,1.0-n*5.0);\n  s+=skin*smoothstep(-1.0,1.0,fbm_2(noiseP*50.0)*fbm_2(noiseP*4.0))*0.02;\n\n  return s;\n\n}\nvec4 getColor(vec3 p){\n\n  vec3 noiseP =p*0.7;\n  float n1=abs(fbm_2(noiseP*1.0));\n \n  float n =smoothstep(-0.2,1.0,fbm_4(noiseP*2.0+fbm_4(noiseP*2.0)*1.5));\n  vec3 base1 = mix(vec3(0.2,0,0.1),vec3(0.9,0.2,0.3),vec3(n));\n  vec3 lum = vec3(0.299, 0.587, 0.114);\n  vec3 gray = vec3(dot(lum, base1));\n   vec4 color =vec4(0,0,0,0);\n  color.xyz = mix(base1, gray, vec3(pow(n1,2.0)));\n  color.w =40.0;\n  float s = smoothstep(0.2,0.4,n);\n  color.w -=s*20.0;\n  color.xyz+=vec3(s)*vec3(0.7,0.7,0.4)*0.5;\n  return color;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * map(p + e.xyy) +\n      e.yyx * map(p + e.yyx) +\n      e.yxy * map(p + e.yxy) +\n      e.xxx * map(p + e.xxx));\n}\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < 256; i++) {\n    vec3 p = ro + depth * rd;\n    \n    float d =map(p);\n    \n    depth += d;\n    if (d < 0.001 || depth > end) break;\n  }\n\n  return depth;\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n      \n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n       \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  float time =sin( iTime*0.2)*0.2+1.3;\n  // camera\t\n  vec3 ta = vec3( 0.0, 0.0, 0.0 );\n  vec3 ro = ta + vec3( 10.0*cos(time ), 0, 10.0*sin(time ) );\n  // camera-to-world transformation\n  mat3 ca = setCamera( ro, ta, 0.0 );\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\n  // focal length\n  const float fl = 3.5;\n        \n  // ray direction\n  vec3 rd = ca * normalize( vec3(p,fl) );\n\n  vec3 col = vec3(0);\n\n\n  float d = rayMarch(ro, rd, 0., 100.); \n\n  if (d > 100.0) \n  {\n    col = vec3(0.2,0.2,0.4)*0.5*(1.0-pow(length(p)*0.5,2.0)); // ray didn't hit anything\n  } \n  else \n  {\n    vec3 p = ro + rd * d; // point on sphere we discovered from ray marching\n    vec3 N = calcNormal(p);\n    vec4 colin = getColor(p);\n    vec3 albedo = colin.xyz;\n    vec3 lightpos =vec3(2.0,3.0,3.0);\n    vec3 L = normalize(lightpos - p);\n    \n    float shadow = calcSoftshadow(p,L, 0.01, 3.0);\n    vec3 irr =vec3(max(0.0,dot(N,L))*2.0)*shadow+vec3(0.1,0.1,0.2);\n    col =irr*albedo;\n    \n    vec3  ref = reflect(rd,N);            \n    float fre = clamp(1.0+dot(N,rd),0.0,1.0);\n    float spe = (colin.w/15.0)*pow( clamp(dot(ref,L),0.0, 1.0), colin.w )*2.0*(0.5+0.5*pow(fre,42.0));\n    col += spe*shadow;\n   \n    col +=vec3(pow(1.0+dot(rd,N),2.0))*vec3(0.2,0.1,0.1);\n\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 60], [62, 62, 85, 85, 162], [164, 164, 188, 188, 239], [241, 241, 267, 267, 1180], [1312, 1312, 1338, 1338, 1550], [1551, 1551, 1577, 1577, 1789], [1791, 1791, 1849, 1849, 1949], [1950, 1950, 2002, 2002, 2102], [2108, 2108, 2126, 2126, 2577], [2578, 2578, 2600, 2600, 3088], [3090, 3090, 3115, 3115, 3351], [3355, 3355, 3413, 3413, 3612], [3613, 3613, 3691, 3691, 4381], [4383, 4383, 4435, 4435, 4612], [4614, 4614, 4671, 4671, 5988]], "test": "untested"}
{"id": "fljcWG", "name": "mackjam_aj", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 5, "viewed": 361, "published": 3, "date": "1650610337", "time_retrieved": "2024-07-30T16:52:12.944168", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 0.);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    l.xy *= r2d(iTime);\n    float cube = max(max(l.x, l.y), l.z);\n      th.xy *= r2d(iTime);\n\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  p.xz *= r2d(iTime);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./10.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  \n\n//  pcc.xz *= r2d(iTime);\n  pcc.xz = abs(pcc.xz);\n  //pcc.xz *= r2d(iTime);\n  //pcc.yz *= r2d(.5*iTime);\n  pcc.y = mod(pcc.y+repyc*.5, repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2*sat(sin(p.y*.05+5.*iTime));\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*1.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*10.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n    uv2 *= r2d(.1*iTime);\n  //uv2 = abs(uv2);\n  //uv -= vec2(.25);\n  //uv *= r2d(FFTI(.1)*10.);\n  //uv = abs(uv);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.1)*4.;\n  col += rdr(uv2)*.5;\n  col *= 1.-sat(length(uv));\n  col = mix(vec3(0.), vec3(199, 242, 58)/255., col*.4);\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28786, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljcWG.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "7lBcDy", "name": "mackjam_ai", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 2, "viewed": 264, "published": 3, "date": "1650610299", "time_retrieved": "2024-07-30T16:52:13.735053", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 1.1);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./10.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  pcc.xz *= r2d(iTime);\n  pcc.yz *= r2d(.5*iTime);\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2*sat(sin(p.y*.05+5.*iTime));\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*10.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  vec2 dir = normalize(vec2(1.));\n  float str = 0.1*FFTS(.2)*15.;\n  \n  col.x = rdr(uv+dir*str).x;\n  col.y = rdr(uv).y;\n  col.z = rdr(uv-dir*str).z;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n float stp = .2*length(uv);\n  vec2 uv2 = floor(uv/stp)*stp;\n  \n  //uv -= vec2(.25);\n  //uv *= r2d(FFTI(.1)*10.);\n  uv = abs(uv);\n  \n  vec3 col = rdr2(uv+rdr(uv).xy*.01);\n  col += rdr(uv2)*.5;\n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28785, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBcDy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "4dSBzV", "name": "rps cell auto", "author": "netgrind", "description": "rps", "tags": ["rps"], "likes": 1, "viewed": 172, "published": 3, "date": "1650609129", "time_retrieved": "2024-07-30T16:52:14.587773", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor =texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float s = .1;\n\nvec2 getDir(vec2 p){\n    vec2 v = (vec2(cos(iTime+p.x), sin(iTime+p.y)));\n    if(abs(v.x)<.25)\n        v.x = 0.;\n    if(abs(v.y)<.25)\n        v.y = 0.;\n \treturn ceil(abs(v))*sign(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 1.-uv;\n    vec3 c = texture(iChannel0, uv).rgb;   \n    \n    vec2 dir = getDir((uv.xy-.5)*vec2(cos(iTime), sin(iTime*.5))*20.);\n    \n    uv = 1.-uv;\n   uv = fract((fragCoord.xy+dir) / iResolution.xy);\n\n    vec3 f = texture(iChannel0, uv).rgb;\n    vec3 o = c;\n    if(f.r>0. && o.g >0.){\n        c.g-=s;\n        if(c.g<0.)\n        \tc = f+vec3(s,0.,0.);\n    }\n    if (f.g>0. && o.b >0.){\n        c.b-=s;\n        if(c.b<0.)\n        \tc = f+vec3(.0,s,0.);\n    }\n    if(f.b>0. && o.r >0.){\n        c.r-=s;\n        if(c.r<0.)\n        \tc = f+vec3(.0,0.,s);\n    }\n    \n    if(iFrame<=1 || iMouse.z> 0.){\n    \tc = texture(iChannel1, uv).rgb;  \n        if(c.r>c.g && c.r>c.b)\n            c = vec3(1., 0., 0.);\n        else if(c.g>c.r && c.g>c.b)\n            c = vec3(0., 1., 0.);\n        else\n            c = vec3(0., 0., 1.);\n\n    }\n    \n    fragColor = vec4(c, 1.);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 137]], "test": "untested"}
{"id": "stlfR4", "name": "Rotating a shape.", "author": "bzm3r", "description": "Using a signed distance field. ", "tags": ["sdf", "tutorial", "box"], "likes": 0, "viewed": 205, "published": 3, "date": "1650594856", "time_retrieved": "2024-07-30T16:52:15.439497", "image_code": "#define PI 3.1415926538\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    // 2D rotation matrix: https://en.wikipedia.org/wiki/Rotation_matrix\n    return mat2(c, -s, s, c);\n}\n\nfloat sdfBox(in vec2 p, in vec2 center, in vec2 half_wh, mat2 rotor) {\n    // vec2 p: the point for which to calculate sdf\n    // vec2 center: the center of the box\n    // vec2 half_wh: the half-width and half-height of the box\n    // based on IQ's Box SDF tutorial: https://www.youtube.com/watch?v=62-pRVZuS5c\n    // which is a \"mandatory\" watch\n    \n    // put p in the \"right hand quadrant\" relative to box center\n    vec2 symm_p = abs((p - center) * rotor);\n    vec2 delta = symm_p - half_wh;\n    // when the point is outside the box, outside will be positive, inside = 0\n    vec2 outside = max(delta, vec2(0.0));\n    // when the point is inside the box, inside will be negative, outside = 0\n    float inside = min(max(delta.x, delta.y), 0.0);\n    \n    return length(outside) + inside;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set the default background to white\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    // the position of the pixel that will be painted is stored in fragCoord\n    vec2 p = fragCoord;\n    \n    // the center of the box\n    vec2 center = vec2(0.25 * iResolution.x, 0.75 * iResolution.y);\n    vec2 half_wh = 0.5 * vec2(0.1 * iResolution.x, 0.3 * iResolution.y);\n    \n    // play around with this to get a feel for how it controls anti-aliasing\n    float smooth_cutoff = 0.01;\n    mat2 rotor = rotate(-0.25 * PI);\n    col *= smoothstep(0.0, 1.0 + smooth_cutoff, sdfBox(p, center, half_wh, rotor));\n\n    // set the colour of pixels in the fragment to be col, with alpha 1.0\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 47, 47, 196], [198, 198, 268, 614, 989], [991, 991, 1010, 1010, 1086], [1089, 1089, 1146, 1189, 1850]], "test": "untested"}
{"id": "ftsBRN", "name": "Interesting Particle Automata", "author": "SnoopethDuckDuck", "description": "Press r to reset\n\nThis is a very slow one but looks cool.", "tags": ["feedback", "cellularautomata"], "likes": 11, "viewed": 343, "published": 3, "date": "1650594546", "time_retrieved": "2024-07-30T16:52:16.345075", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(1. * fragCoord), 0 ).rbb;\n    //col += 0.5;\n    //col *= 2.5 * col * col;\n    vec3 e = vec3(0.5);\n    vec3 col2 = pal(0.75 + 0.5 * length(col), col,  min(col,1.-col), e, 2.5 * col);\n    vec3 col3 = pal(-0.25 + 0.5 * length(col), col, min(col,1.-col), e, 0.6 * vec3(1));\n   // col = 1. * mix(col, col2, step(0. * iResolution.x, fragCoord.x));\n    //col = mix(col, col3, step(fragCoord.x, 0.5 * iResolution.x));\n    col = 2. * sqrt(col) + 0.0;\n    fragColor.rgb = vec3(col);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec3 max2(vec3 a, vec3 b) {\n    //vec3 j = abs(a-b);\n    //if (dot(b, b) > dot(j,j) && dot(a,a) > dot(j,j))\n    //    return j;\n    if (a.x > b.x)\n        return a;\n    return b;\n}\n\nvec3 min2(vec3 a, vec3 b) {\n    if (dot(a,a) < dot(b,b))\n        return a;\n    return b;\n}\n\nvec3 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n   // return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n   return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat test(float x) {\n    return abs(fract(x + 0.5) - 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        vec2 f = fragCoord + 0.01 * iTime; \n        float o = 0.01;\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        float s = step(abs(length(uv)-0.), 0.05);\n        \n        float h = h21(f);\n        if (h > 0.99)\n            h = 1.;\n        else\n            h = 0.;\n       // h *= s;\n       // float h = step(fragCoord.x, 1.) * step(fragCoord.y,1.);\n        fragColor.r = h;\n        float sc = 0.01;\n       // if (fragCoord.x > 0.5 * iResolution.x && fragCoord.y > 0.1 * iResolution.y)\n        fragColor.g = cos(sc * fragCoord.x) * cos(sc * fragCoord.y) * 0.5 + 0.5;\n      //  fragColor.b = 0.;h21(f);\n        return;\n    }\n    \n    // center cell\n    vec3 e = Cell(px); \n\n    // neighbour cells\n    vec3 t = Cell(px + ivec2(0,-1));\n    vec3 b = Cell(px + ivec2(0,1));\n    vec3 l = Cell(px + ivec2(-1,0));\n    vec3 r = Cell(px + ivec2(1,0));   \n\n    float k = max( max(l.x, r.x), max(t.x, b.x) );\n \n    // how much y val changes by (used for rotation)\n    float sa = 1./16.;\n    \n    // m = 0.125 checks exact quadrant for each direction\n    // m > 0.125 oversteps and creates more particles where e.x = 1\n    float m = 0.13;\n    if (l.x == 1. && (test(l.y + 0.) < m) || \n        r.x == 1. && (test(r.y + 0.5) < m) || \n        t.x == 1. && (test(t.y + 0.25) < m) || \n        b.x == 1. && (test(b.y + 0.75) < m)) { \n    \n        e.x = 1.;\n        e.y = fract(e.y + sa);        \n    } else {\n        // increasing makes reds more blurry\n        // (isn't just visual - e.x greater => e.z greater => e.z > 0.12 more often)\n        e.x = 0.1 * k; \n       \n    }\n\n    // stops e.x = 1 particles from duping too much\n    if (k == 1. && e.x == 1. && e.z > 0.12) {\n        e.x = 0.;\n        e.z += 0.01;    \n    }\n    e.z *= 0.995;\n    if (e.x == 1.)\n        e.z += 0.008;\n   \n    \n    \n   // if (e.x == 0.)\n  //      e.x = 1.;\n    e = clamp(e, 0., 1.);\n\tfragColor = vec4( e, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    else\n        fragColor.rgb = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.1415926535\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 576]], "test": "untested"}
{"id": "7tlfR4", "name": "Custom Newton's fractal", "author": "Fraktoler", "description": "Newton's fractal is generated using Newton-Raphson iteration", "tags": ["fractal", "iteration"], "likes": 2, "viewed": 235, "published": 3, "date": "1650593532", "time_retrieved": "2024-07-30T16:52:17.259630", "image_code": "precision highp float;\n\n#define PI 3.1415926535897932384626433832795028841\n\nvec3 HSLtoRGB(vec3 hsl) {\n    //0 <= h <= 360\n    //0 <= s <= 1\n    //0 <= l <= 1\n    float chroma = hsl.y * (1.0 - abs(2.0 * hsl.z - 1.0));\n    float h_prime = hsl.x / 60.0;\n    float x = chroma * (1.0 - abs(mod(h_prime, 2.0) - 1.0));\n    vec3 rgb;\n    if (0.0 <= h_prime && h_prime < 1.0) {\n        rgb = vec3(chroma, x, 0.0);\n    } else if (1.0 <= h_prime && h_prime < 2.0) {\n        rgb = vec3(x, chroma, 0.0);\n    } else if (2.0 <= h_prime && h_prime < 3.0) {\n        rgb = vec3(0.0, chroma, x);\n    } else if (3.0 <= h_prime && h_prime < 4.0) {\n        rgb = vec3(0.0, x, chroma);\n    } else if (4.0 <= h_prime && h_prime < 5.0) {\n        rgb = vec3(x, 0.0, chroma);\n    } else {\n        rgb = vec3(chroma, 0.0, x);\n    }\n    float m = hsl.z - 0.5 * chroma;\n    return rgb + m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 3.0;\n    vec2 center = vec2(0.0);\n    vec2 z = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x * zoom + center;\n    float exponent = 2.0 + iTime * 0.2;\n    float iter = 0.0;\n    const float max_iter = 256.0;\n    while (iter < max_iter) {\n        vec2 oldz = z;\n        vec2 f = power(z, exponent) - vec2(1.0, 0.0); //Function f(z)\n        vec2 df = exponent * power(z, exponent - 1.0); //f'(z)\n        z = z - div(f, df);\n\n        float r = mag2(z - oldz);\n        if (r < 1.0e-6) {\n            break;\n        }\n        iter += 1.0;\n    }\n\n    if (iter >= max_iter) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        float h = arg(z) / PI;\n        if (h < 0.0) {\n            h = h + 2.0;\n        }\n        vec3 col = HSLtoRGB(vec3(h * 180.0, 1.0, 0.5));\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "float mag(vec2 z) {\n    return length(z);\n}\n\nfloat mag2(vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 swap(vec2 z) {\n    return vec2(z.y, z.x);\n}\n\nvec2 rabs(vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(vec2 z, vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / mag2(w);\n}\n\nvec2 rec(vec2 z) {\n    return conj(z) / mag2(z);\n}\n\nvec2 squ(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n}\n\nvec2 cube(vec2 z) {\n    return z * vec2(z.x * z.x - 3.0 * z.y * z.y, 3.0 * z.x * z.x - z.y * z.y);\n}\n\nvec2 power(vec2 z, float p) {\n    return pow(mag2(z), p * 0.5) * cis(p * arg(z));\n}\n\nvec2 powervec2(vec2 z, vec2 w) {\n    float r = mag2(z);\n    float argz = arg(z);\n    float argzw = w.x * argz + 0.5 * w.y * log(r);\n    return pow(r, w.x * 0.5) * exp(-w.y * argz) * cis(argzw);\n}\n\nvec2 sqrtp(vec2 z) {\n    float r = mag(z);\n    return vec2(1.0, sign(z.y)) * sqrt(0.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 powexp(vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(vec2 z) {\n    return vec2(log(mag2(z)) * 0.5, arg(z));\n}\n\nvec2 logb(vec2 z, vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(squ_exp - vec2(1.0, 0.0), mulI(squ_exp + vec2(1.0, 0.0)));\n}\n\nvec2 tangent(vec2 z) {\n    if (z.y < -21.0) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(mulI(squ_exp + vec2(1.0, 0.0)), squ_exp - vec2(1.0, 0.0));\n}\n\nvec2 cot(vec2 z) {\n    if (z.y < -21.0) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(vec2 z) {\n    return rec(cosine(z));\n}\n\nvec2 csc(vec2 z) {\n    return rec(sine(z));\n}\n\nvec2 arcsin(vec2 z) {\n    return mulI(ln(sqrtp(vec2(1.0, 0) - squ(z)) - mulI(z)));\n}\n\nvec2 arccos(vec2 z) {\n    return -mulI(ln(mulI(sqrtp(vec2(1.0, 0) - squ(z))) + z));\n}\n\nvec2 arctan(vec2 z) {\n    return -0.5 * mulI(ln(div(vec2(0.0, 1.0) - z, vec2(0.0, 1.0) + z)));\n}\n\nvec2 arccot(vec2 z) {\n    return -0.5 * mulI(ln(div(z + vec2(0.0, 1.0), z - vec2(0.0, 1.0))));\n}\n\nvec2 arcsec(vec2 z) {\n    return arccos(rec(z));\n}\n\nvec2 arccsc(vec2 z) {\n    return arcsin(rec(z));\n}\n\nvec2 sinhyp(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp - vec2(1.0, 0.0), squ_exp + vec2(1.0, 0.0));\n}\n\nvec2 tanhyp(vec2 z) {\n    if (z.x > 21.0) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp + vec2(1.0, 0.0), squ_exp - vec2(1.0, 0.0));\n}\n\nvec2 coth(vec2 z) {\n    if (z.x > 21.0) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(vec2 z) {\n    return rec(coshyp(z));\n}\n\nvec2 csch(vec2 z) {\n    return rec(sinhyp(z));\n}\n\nvec2 arcsinh(vec2 z) {\n    return ln(z + sqrtp(squ(z) + vec2(1.0, 0.0)));\n}\n\nvec2 arccosh(vec2 z) {\n    return ln(z + mul(sqrtp(z + vec2(1.0, 0.0)), sqrtp(z - vec2(1.0, 0.0))));\n}\n\nvec2 arctanh(vec2 z) {\n    return 0.5 * ln(div(vec2(1.0, 0.0) + z, vec2(1.0, 0.0) - z));\n}\n\nvec2 acoth(vec2 z) {\n    return 0.5 * ln(div(z + vec2(1.0, 0.0), z - vec2(1.0, 0.0)));\n}\n\nvec2 asech(vec2 z) {\n    return arccosh(rec(z));\n}\n\nvec2 acsch(vec2 z) {\n    return arcsinh(rec(z));\n}\n\nvec2 linear(vec2 z, vec2 a, vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(vec2 z, vec2 a, vec2 b, vec2 c) {\n    return mul(squ(z), a) + mul(z, b) + c;\n}\n\nvec2 cubic(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return mul(cube(z), a) + mul(squ(z), b) + mul(z, c) + d;\n}\n\nvec2 linearroot(vec2 z, vec2 a, vec2 b) {\n    return div(-b, a);\n}\n\nvec4 quadraticroots(vec2 a, vec2 b, vec2 c) {\n    vec2 sqrtdelta = sqrtp(squ(b) - 4.0 * mul(a, c));\n    vec2 twoa = a + a;\n    return vec4(div(sqrtdelta - b, twoa), -div(b + sqrtdelta, twoa));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 101, 157, 861], [863, 863, 920, 920, 1755]], "test": "untested"}
{"id": "fllfzN", "name": "Drawing a coloured solid circle", "author": "bzm3r", "description": "See, for simple black and white: https://www.shadertoy.com/view/NlsBzN \n\nNow we use the mix function to colour our pixels.", "tags": ["sdf", "tutorial", "circle"], "likes": 1, "viewed": 184, "published": 3, "date": "1650590867", "time_retrieved": "2024-07-30T16:52:18.091405", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set the default background to white\n    vec3 bg_col = vec3(1.0, 1.0, 1.0);\n    // colour of our circle\n    vec3 circ_col = vec3(0.4, 0.5, 0.3);\n    \n    // the position of the pixel that will be painted is stored in fragCoord\n    vec2 p = fragCoord;\n    \n    // the center of the circle\n    vec2 center = vec2(0.25 * iResolution.x, 0.75 * iResolution.y);\n\n    float radius = 100.0;\n    // play around with this to get a feel for how it controls anti-aliasing\n    float smooth_cutoff = 0.01;\n    \n    // smoothstep(x, y, z) returns:\n    //      0 if z < x, \n    //      1 if z > y,\n    //      a \"smoothened\" (Hermite interpolated) value between 0 and 1 if x < z < y\n    // this is where the SDF magic happens: length(p - center) is a distance\n    float sdf_factor = smoothstep(radius, \n                                  radius * (1.0 + smooth_cutoff), \n                                  length(p - center));\n    // we mix colors, with the ratio determined by the sdf factor\n    vec3 col = mix(circ_col, bg_col, sdf_factor);\n\n    // set the colour of pixels in the fragment to be col, with alpha 1.0\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 100, 1197]], "test": "untested"}
{"id": "NlsBzN", "name": "Drawing a solid circle", "author": "bzm3r", "description": "Using a signed distance field. ", "tags": ["sdf", "tutorial", "circle"], "likes": 0, "viewed": 148, "published": 3, "date": "1650589564", "time_retrieved": "2024-07-30T16:52:18.946122", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set the default background to white\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    // the position of the pixel that will be painted is stored in fragCoord\n    vec2 p = fragCoord;\n    \n    // the center of the circle\n    vec2 center = vec2(0.25 * iResolution.x, 0.75 * iResolution.y);\n\n    float radius = 100.0;\n    // play around with this to get a feel for how it controls anti-aliasing\n    float smooth_cutoff = 0.01;\n    \n    // smoothstep(x, y, z) returns:\n    //      0 if z < x, \n    //      1 if z > y,\n    //      a \"smoothened\" (Hermite interpolated) value between 0 and 1 if x < z < y\n    // this is where the SDF magic happens: length(p - center) is a distance\n    col *= smoothstep(radius, radius * (1.0 + smooth_cutoff), length(p - center));\n\n    // set the colour of pixels in the fragment to be col, with alpha 1.0\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsBzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 100, 927]], "test": "untested"}
{"id": "stffR8", "name": "voronoi from scratch", "author": "mAmaro", "description": "noi", "tags": ["cineshader"], "likes": 9, "viewed": 3386, "published": 3, "date": "1650580239", "time_retrieved": "2024-07-30T16:52:19.887603", "image_code": "#if 0\nfloat Circle(vec2 uv, vec2 Pos, float Rad)\n{\n    //TODO(): How tf do i do radius correctly????\n    return smoothstep(0.05, 0.044, 1./Rad*length(uv-Pos));\n}\n\nfloat UnilatSin(float Freq)\n{\n    return 1.0+0.5*cos(iTime*Freq);\n}\n\nvec2 Noise(vec2 Pos, float Freq)\n{\n    vec3 a = fract(Pos.xyx * vec3(123.45, 345.678, 567.89));\n    a += dot(a, a + 345.578*UnilatSin(Freq));   \n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AR = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    vec3 Col = vec3(0.1,.1,.03);\n    //uv.x = abs(uv.x);\n    //uv = vec2(0.17*atan(uv.x, uv.y), 0.2*log(length(0.6*uv)));\n    float Dots = .0;\n    \n    float MinDist = 100.0;\n    float VCI = 0.; //VertCellIndex\n    for(float i=0.; i<50.; i+=1.)\n    {\n        float RowCount = 10.0;//*UnilatSin(iTime*0.0001);\n        vec2 Margin = vec2(0.4, 0.3);\n        vec2 Step = vec2(0.1, 0.09);\n        vec2 Point = vec2((-0.5*AR)+Margin.x+Step.x*mod(i,RowCount),\n        -0.5+Margin.y+Step.y*floor(i/RowCount));\n        Point+=sin(Noise(vec2(i), 0.0)*iTime)*0.4;\n        \n        Dots += Circle(uv, Point, 0.3);\n        float Dist = length(uv-Point);\n        \n        if(Dist<MinDist)\n        {\n            MinDist = Dist;\n            VCI = i;\n        }\n    }\n   \n   //TODO(): Spatial partition\n   \n   vec4 Output = vec4(Col + Dots + floor(250.0*mod(MinDist,0.03))*4.1,1.0);\n   if(fragCoord.x/iResolution.x <.5)\n   {\n       Output = 1.-vec4(Col +Dots + floor(250.0*mod(MinDist,0.03))*4.1,1.0); \n   }\n  \n    fragColor = Output;\n}\n\n#elif 1\n\nvec2 Noise(vec2 P)\n{\n    vec3 a = fract(P.xyx * vec3(123.45, 345.678, 567.89));\n    a += dot(a, a + 518.);   \n    return fract(a.y*a.xz);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,\n         U =  u / R.y - vec2(.4, .3);\n    \n    float d = 9.;\n    for(int N=10, i=0; i<50; i++)\n        P = .1 * vec2( i%N, i/N ) \n            + sin( Noise(vec2(i)) *iTime ) *.4,\n        d = min( d, length(U-P) );\n\n   \n   O = vec4( smoothstep( 0., 4./R.y, .03*abs(2.*fract(d/.03+.6)-1.) ) );\n   if(u.x < .5*R.x )  O = 1.-O; \n}\n\n#else\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, d = R;\n    for(int n=10, i=0; i<50; i++)\n        d = min( d, length(   .1 * vec2( i%n, i/n ) \n                            + .4 * sin( fract(sin(vec2(i)* R) * 4e4 ) *iTime ) \n                            -  u / R.y + vec2(.4, .3) ) );\n\n   O += R.y/1e2* abs(2.*fract(d.x/.03+.6)-1.) -O;\n   if(u.x < .5*R.x )  O = 1.-O; \n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stffR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Ntsfz4", "name": "Newb3", "author": "7wingfly", "description": "A bit more random and interesting than newb1 and newb2. I think it could make a nice loading screen. If only I had done any of this on purpose.\nI am still a noob.\n\nhttps://codepen.io/7wingfly/details/mdpqyjV", "tags": ["newb"], "likes": 1, "viewed": 220, "published": 3, "date": "1650577984", "time_retrieved": "2024-07-30T16:52:20.640590", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord /= 2.0;\n    vec2 p = (fragCoord.xy / iResolution.xy) - .25;\n\tp.x *= (iResolution.x / iResolution.y) * 2.;    \n    p.y += mix(.10, .12, sin(iTime / 1.));\n\n    vec3 col = sin(vec3(mix(0., 10., cos(iTime)),0,2) / 10.) * .10 + mix(.1, .5, sin(iTime * 2.) + 1.);    \n\n    float w = mix(20., 22., cos(iTime) * 2.);\n    \n    float rx = mix(.0, 2., sin(iTime / 2.));\n    float r = 0.4 + 0.1 * cos(atan(-p.x + 2., p.y / 2.) * 60.0 + w * -p.x + ((length(iMouse) / 150.) * rx));\n\n    float r1 = 0.2 + 0.1 * cos(atan(-p.x + 2., -p.y / 2.) * 5.0 + w * -p.x + (iTime * 2.));\n    float r2 = 0.4 + 0.1 * cos(atan(-p.x + 4., -p.y / 4.) * 10.0 + w * -p.x + (iTime * 4.));\n    float r3 = 0.6 + 0.1 * cos(atan(-p.x + 6., -p.y / 6.) * 20.0 + w * -p.x + (iTime * 6.));\n    \n    float q = length(p);\n\n    col *= .0 - (1.0 - smoothstep(r, r * 600., abs(-p.y / 100. * sin(mix(.0, 100., sin(iTime) + 1.))))) * (.5 - smoothstep(.0, .1, p.y));\n\n    col /= smoothstep(r / 100., r, q) / mix(.05, .2, sin(iTime) + 1.0);     \n    col /= smoothstep(r / 200., r1, q) / mix(.01, .2, sin(iTime) + 2.0);\n    \n    col.r /= smoothstep(r2 / 100., r2, q) / .1;\n    col.g /= smoothstep(r1 / 100., r1, q) / .3;\n    col.b /= smoothstep(r3 / 100., r3, q) / .3;\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntsfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1320]], "test": "untested"}
{"id": "7lXBR4", "name": "Flood Fill Test", "author": "SnoopethDuckDuck", "description": "Press r to reset\n\nA messy modification of this: https://www.shadertoy.com/view/NtXBRH\n\nTakes a while to fill in + some shapes don't have many regions + black outline on white lines needs fixing", "tags": ["feedback", "cellularautomata"], "likes": 8, "viewed": 436, "published": 3, "date": "1650569592", "time_retrieved": "2024-07-30T16:52:21.474361", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(1. * fragCoord), 0 ).rgb;\n    //col += 0.5;\n    //col *= 2.5 * col * col;\n    vec3 e = vec3(0.5);\n    vec3 col2 = pal(0.75 + 0.5 * length(col), col,  min(col,1.-col), e, 2.5 * col);\n    vec3 col3 = pal(-0.25 + 0.5 * length(col), col, min(col,1.-col), e, 0.6 * vec3(1));\n   // col = 1. * mix(col, col2, step(0. * iResolution.x, fragCoord.x));\n    //col = mix(col, col3, step(fragCoord.x, 0.5 * iResolution.x));\n    col = sqrt(col) + 0.05;\n    fragColor.rgb = vec3(col);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec3 max2(vec3 a, vec3 b) {\n    //vec3 j = abs(a-b);\n    //if (dot(b, b) > dot(j,j) && dot(a,a) > dot(j,j))\n    //    return j;\n    if (dot(a,a) > dot(b,b))\n        return a;\n    return b;\n}\n\nvec3 min2(vec3 a, vec3 b) {\n    if (dot(a,a) < dot(b,b))\n        return a;\n    return b;\n}\n\nvec3 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n   // return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n   return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 squiggle(in vec2 fragCoord )\n{ \n    float a;\n    vec2 p = 0.5 * iResolution.xy;\n       \n    float d = 100.;\n    for (float i = 0.; i < 400.; i++) {\n        float h = h21(vec2(i - iTime, 103. + i));\n\n        a += pi * 0.15 * (floor(5. * h) - 2.);\n        \n        vec2 q = p + 8. * vec2(thc(2., a), ths(2., a));\n\n        d = min(d, seg(fragCoord, p, q));\n        //d = min(d, seg(vec2(-fragCoord.x, fragCoord.y), p, q));\n        \n        p = q;\n    }\n    \n    float k = 0. / iResolution.y;\n    float s = step(d, 3.);//smoothstep(-k, k, -d + 1.);\n    \n    vec3 col = vec3(s);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        vec2 f = fragCoord + 0.01 * iTime; \n        float o = 0.01;\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        float s = step(abs(length(uv)-0.), 0.1);\n        //vec3 col = (vec3(h21(f-o), h21(f), h21(f+o)) - 0.5);\n        vec3 e = vec3(0.5);\n        float h = h21(f + 113.);\n        vec3 col = (pal(10. * h21(f), e, e, e, 1. * vec3(0,1,2)/3.));\n        //if (h < 0.999)\n          //  col = vec3(0);\n        col *= step(length(fract(0.1 * fragCoord)-0.5), 0.1);\n        col += squiggle(fragCoord);\n        col += squiggle(iResolution.xy - fragCoord);\n        col = clamp(col, 0., 1.);\n        \n        if (fragCoord.x < 1. || fragCoord.x > iResolution.x-1. ||\n            fragCoord.y < 1. || fragCoord.y > iResolution.y-1.)\n            col = vec3(1);\n            \n        \n        fragColor.rgb = col;\n        return;\n    }\n    \n    // center cell\n    vec3 e = Cell(px); \n\n    // neighbour cells\n    vec3 t = Cell(px + ivec2(0,-1));\n    vec3 b = Cell(px + ivec2(0,1));\n    vec3 l = Cell(px + ivec2(-1,0));\n    vec3 r = Cell(px + ivec2(1,0));   \n\n    vec3 h = 0.5 * (l+r);\n    vec3 v = 0.5 * (t + b);  \n    vec3 k = max(h,v); // \"average\" of neighbours\n   // vec3 k = 0.5 *(h+v);\n    //k = 0.25 * (l + r + t + b);\n    \n    k = max2( max2(l,r), max2(t,b) );\n    \n    vec3 km = min2(min2(t,b),min2(l,r));\n    \n    // difference between center and average\n    vec3 j = abs(e - k);\n    \n    if (k != vec3(1)) {\n        if (e == vec3(0))\n            e = k;\n        else\n            e = max2(e, k);\n    }\n\n    e = clamp(e, 0., 1.);\n\tfragColor = vec4( e, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    else\n        fragColor.rgb = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.1415926535\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 572]], "test": "untested"}
{"id": "7lXBz4", "name": "Voronoi Tracking Experiment 3", "author": "aiekick", "description": "just the Voronoi Tracking Experiment 1 with a simple layering\n\nuse mouse for add particles\nuse spacebar for clear the screen", "tags": ["voronoi", "experiment", "tracking"], "likes": 15, "viewed": 304, "published": 3, "date": "1650567033", "time_retrieved": "2024-07-30T16:52:22.237322", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Voronoi Tracking Experiment 1\n\n// based on the shader https://www.shadertoy.com/view/tlKGDh of michael0884\n\n// use mouse for add particles\n// use spacebar for clear the screen\n\n#define COUNT_STEPS 50\n#define SCALE_STEP 0.005\n#define OFFSET_STEP 2.0\n    \nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromoneInv(vec2 p)\n{\n\treturn getPheromone(p);\n}\n\nvec4 layer(vec2 p, float scale, vec3 light)\n{\n\tp -= iResolution.xy * 0.5;\n\tp *= scale;\n\tp += iResolution.xy * 0.5;\n\t\t\n\tvec4 color;\n\tcolor.a = step(0.95, clamp(getPheromone(p).x*100.0,0.0,1.0));\n\tcolor.rgb = light * color.a;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    // lighting\n    float e = 100.0 / min(iResolution.x, iResolution.y);\n\tfloat f = getPheromoneInv(fragCoord).x;\n\tfloat fx = (f-getPheromoneInv(fragCoord + vec2(1,0)).x)/e;\n\tfloat fy = (f-getPheromoneInv(fragCoord + vec2(0,1)).x)/e;\n\tvec3 n = normalize(vec3(0,0,1) - vec3(fx,fy,0.0));\n\tfloat diff = max(dot(vec3(0,0,1), n), 0.0);\n\tfloat spec = pow(max(dot(normalize(lightDirection), reflect(vec3(0,0,1),n)), 0.0), specularPower);\t\n    vec3 color = vec3(clamp((lightDiffuse * diff + lightSpecular * spec) * 1.5, 0.0, 1.0));\n\t\n    // cycle\n    float a = iTime * 0.5;\n    vec2 off = vec2(cos(a), sin(a));\n\t\n    // layering of same texture\n\tfloat fcount = float(max(COUNT_STEPS, 1));\n\tfloat scale = 1.0 + fcount * SCALE_STEP;\n\tfloat fog = 0.0;\n\tfloat fogStep = 1.0 / fcount;\n\tfloat offScale = 1.0 + fcount * OFFSET_STEP;\n\tfor (int i = 0 ; i < COUNT_STEPS ; ++i)\n\t{\n\t\tscale -= SCALE_STEP;\n\t\tfog += fogStep;\n        offScale -= OFFSET_STEP;\n\t\tvec4 c = layer(fragCoord + off * offScale, scale, color);\n\t\tif (c.a > 0.5) // smart merge for avoid overwrite\n\t\t\tfragColor.rgb = c.rgb * fog;\n\t}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by Stephane Cuillerdier - Aiekick/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// particle\n// x,y => pos [0 > iResolution.xy]\n// z   => angle [0 > 2pi]\n// abs(w) => sensor angle [0 > pi]\n// if (w > 0.0) => activation\n\nvec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid SelectIfNearestNeighbor(inout vec4 pnb, vec2 p, vec2 dx)\n{\n    vec4 p_nb = getParticle(p + dx);\n    \n\tif(length(loop_d(p_nb.xy - p, iResolution.xy)) < length(loop_d(pnb.xy - p, iResolution.xy)))\n    {\n        pnb = p_nb;\n    }\n}\n\nvoid SearchForNearestNeighbor(inout vec4 pnb, vec2 p, float ring)\n{\n\t// sides\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,ring));\n\t\n\t// corners\n\tSelectIfNearestNeighbor(pnb, p, vec2(-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring));\n}\n\nvoid EmitParticle(vec2 g, inout vec4 p)\n{\n\tfloat rand = Random(g + p.xy).x;\n\t\n\tp.xy = g; // pos\n\tp.z = rand * 6.28318; // angle\n\n    // sensor angle and activation\n    p.w = mix(sensor_angle_rad_inf, sensor_angle_rad_sup, rand);\n}\n\nvoid MoveParticle(inout vec4 p)\n{\n    // left sensor\n\tfloat an = p.z + p.w;\n    vec2 sleft = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    // right sensor\n\tan = p.z - p.w;\n    vec2 sright = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    float diff_angle = \n        getPheromone(sleft).x - \n        getPheromone(sright).x;\n\t\n    p.z += dt * sensor_strenght * tanh(0.3 * diff_angle);\n\tp.xy += dt * particle_speed * vec2(cos(p.z), sin(p.z));\n    \n\tp.xy = loop(p.xy, iResolution.xy);\n}\n\nvoid PaintByMouse(vec2 g, inout vec4 p)\n{\n\tif (iMouse.z > 0.0)\n\t{\n\t\tif (length(g - iMouse.xy) < uMouseRadius)\n\t\t{\n\t\t\tEmitParticle(g, p);\n\t\t}\n\t}\n}\n\nvoid mainImage( out vec4 fragParticles, in vec2 fragCoord )\n{\n\tfragParticles = getParticle(fragCoord);\n\t\n\tSearchForNearestNeighbor(fragParticles, fragCoord, 1.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 2.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 3.0);\n\t\n\tMoveParticle(fragParticles);\n\tPaintByMouse(fragCoord, fragParticles);\n\n\tif (iFrame < 1) // reset \n\t{\n\t\tfragParticles = vec4(0);\n        \n        // start shape\n        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        uv.y += sin(uv.x * 5.0) * 0.3;\n        uv.x = mod(uv.x, 0.1);\n        float st = 5.0 / iResolution.y;\n        if (length(uv) < st)\n            EmitParticle(fragCoord, fragParticles);\n\t}\n    \n    if (reset(iChannel3))\n        fragParticles = vec4(0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by Stephane Cuillerdier - Aiekick/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define dt 0.25\n\n// mouse\nconst float uMouseRadius = 1.0;\n\n// particle\nconst float particle_speed = 5.0;\n\n// pheromones\nconst float gauss_coef = 1.4;\nconst float decay = 0.15;\n\n// sensor\nconst float sensor_strenght = 20.0;\nconst float sensor_distance = 20.0;\nconst float sensor_angle_rad_inf = 1.0;\nconst float sensor_angle_rad_sup = 1.8;\n\n// shading\nconst vec3 lightDiffuse = vec3(0.191553,0.267195,0.373984);\nconst vec3 lightSpecular = vec3(0.243903,1,0);\nconst vec3 lightDirection = vec3(0.08232,-0.24085,-0.58841);\nconst float specularPower = 20.0;\n\n// borderless \nvec2 loop_d(vec2 p, vec2 s){\n\treturn mod(p + s * 0.5, s) - s * 0.5;\n}\n\nvec2 loop(vec2 p, vec2 s){\n\treturn mod(p, s);\n}\n\nvec2 Random(vec2 p){\n\tvec3 a = fract(p.xyx * vec3(123.34,234.35,345.65));\n\ta += dot(a, a + 34.45);\n\treturn fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nbool reset(sampler2D sam) {\n    return texture(sam, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}", "buffer_b_code": "// Created by Stephane Cuillerdier - Aiekick/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// pheromone\n// x   => pheromone quantity\n\nvec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid DiffusePheromones(vec2 g, inout vec4 fragPheromone)\n{\n    // laplacian\n\tfloat v = 0.0;\n    v += getPheromone(g + vec2(-1, 0)).x; // l\n\tv += getPheromone(g + vec2( 0, 1)).x; // t\n\tv += getPheromone(g + vec2( 1, 0)).x; // r\n\tv += getPheromone(g + vec2( 0,-1)).x; // b\n\tv -= 4.0 * fragPheromone.x;\n    \n\tfragPheromone += dt * v;\n}\n\nvoid mainImage( out vec4 fragPheromone, in vec2 fragCoord )\n{\n    fragPheromone = getPheromone(fragCoord);\n    \n    DiffusePheromones(fragCoord, fragPheromone);\n\t\n\t// write pheromones for each particles\n\tvec4 p = getParticle(fragCoord);\n\tif (p.w > 0.0)\n\t{\n\t\tfloat gauss = exp(-pow(length(fragCoord - p.xy)/gauss_coef,2.));\n\t\tfragPheromone += dt * gauss;\n\t}\n\t\n\t// dissipation  \n\tfragPheromone -= dt * decay * fragPheromone;\n    \n    if (iFrame < 1 || reset(iChannel3)) // reset \n\t\tfragPheromone = vec4(0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXBz4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[395, 395, 422, 422, 490], [492, 492, 522, 522, 549], [551, 551, 596, 596, 791], [793, 793, 850, 850, 1965]], "test": "untested"}
{"id": "NlXfR4", "name": "Color Automata 2", "author": "SnoopethDuckDuck", "description": "Press r to reset\n\nPrimary colors don't look so great but the behaviours are kind of interesting", "tags": ["feedback", "cellularautomata"], "likes": 6, "viewed": 222, "published": 3, "date": "1650563648", "time_retrieved": "2024-07-30T16:52:23.092035", "image_code": "vec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(1. * fragCoord), 0 ).rgb;\n    col += 0.5;\n    col *= 2.5 * col * col;\n    vec3 e = vec3(0.5);\n    vec3 col2 = pal(0.75 + 0.5 * length(col), col,  min(col,1.-col), e, 2.5 * col);\n    vec3 col3 = pal(-0.25 + 0.5 * length(col), col, min(col,1.-col), e, 0.6 * vec3(1));\n    col = 1. * mix(col, col2, step(0. * iResolution.x, fragCoord.x));\n    //col = mix(col, col3, step(fragCoord.x, 0.5 * iResolution.x));\n    \n    fragColor.rgb = vec3(col);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec3 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n   // return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n   return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        vec2 f = fragCoord + 0.01 * iTime; \n        float o = 0.01;\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        float s = step(abs(length(uv)-0.), 0.1);\n        fragColor.rgb = (vec3(h21(f-o), h21(f), h21(f+o)) - 0.5);\n        float h = h21(f + 113.);\n        if (h < 0.995)\n            fragColor.rgb = vec3(0);\n        //fragColor *= s;\n        return;\n    }\n    \n    // center cell\n    vec3 e = Cell(px); \n\n    // neighbour cells\n    vec3 t = Cell(px + ivec2(0,-1));\n    vec3 b = Cell(px + ivec2(0,1));\n    vec3 l = Cell(px + ivec2(-1,0));\n    vec3 r = Cell(px + ivec2(1,0));   \n\n    vec3 h = 0.5 * (l+r);\n    vec3 v = 0.5 * (t + b);  \n    vec3 k = max(h,v); // \"average\" of neighbours\n   // vec3 k = 0.5 *(h+v);\n    k = 0.25 * (l + r + t + b);\n    \n    // difference between center and average\n    vec3 j = abs(e - k);\n\n    if (dot(e,k) < 1.) e = 1.12 * j + 0.9 * k;\n   // e -= 0.0025;\n    //if (dot(j, k) < 0.1) e += 0.001 * (k.yzx - 0.);\n    \n    e = clamp(e, 0., 1.);\n\tfragColor = vec4( e, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    else\n        fragColor.rgb = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 109], [111, 111, 168, 168, 654]], "test": "untested"}
{"id": "NlsBzn", "name": "Space ship", "author": "A_Toaster", "description": "Raymarched SDF spaceship. Definitely can be improved+optimized.", "tags": ["raymarching", "space"], "likes": 59, "viewed": 3776, "published": 3, "date": "1650559527", "time_retrieved": "2024-07-30T16:52:24.130259", "image_code": "#define EPS 0.00002\n\n#define MAX_DIST 10.0\n\n// SHIP SDF /////////////////////////////////////////\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat opSubtract( float d1, float d2 ) {\n\t return max(-d1,d2); \n}\n\nvec3 opElongate(in vec3 p, in vec3 h )\n{\n    return p - clamp( p, -h, h );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n\n}\n\nfloat shipWindows(in vec3 p) {\n    return sdRoundBox(vec3(abs(p.x) - 0.56, p.y - 0.76, p.z-0.57), vec3(0.5, 0.5, 0.5), 0.05);\n}\n\n// returns 0 for body, 1 for window\nfloat windowDeform(in vec3 p){\n\treturn 1.0 - smoothstep(0.0, 0.01, shipWindows(p));\n}\n\n\nfloat shipBody( in vec3 p) {\n\treturn opSmoothUnion(\n\t\tsdEllipsoid(p, vec3(0.3, 0.4, 0.3)),\n\t\tsdCapsule(vec3(abs(p.x), p.y, abs(p.z)), vec3(0.2, 0.0, 0.2), vec3(0.28, -0.1, 0.28), 0.015),\n\t\t0.02\n\t) + 0.01 * windowDeform(p);\n}\n\nfloat shipEngine( in vec3 p){\n\treturn opSubtract(\n\t\tsdCone(p + vec3(0.0, 0.34, 0.0), vec2(0.6, 1.0), 0.25),\n\t\tsdCone(p + vec3(0.0, 0.42, 0.0), vec2(0.40, 1.0), 0.05) - 0.07\n\t);\n}\n\n\n// ring and landing gear\nfloat shipRing( in vec3 p){\n\treturn min(\n\t\tsdTorus(opElongate(p + vec3(0, 0.05, 0), vec3(0, 0.05, 0)), vec2(0.4, 0.013)),\n\t\tsdCappedCone(vec3(abs(p.x), p.y, abs(p.z)), vec3(0.1, -0.3, 0.1), vec3(0.17, -0.5, 0.17), 0.02, 0.01)\n\t);\n}\n\n\n\n\nfloat ship(in vec3 p){\n\treturn min(\n\t\tmin(\n\t\t\tshipBody(p),\n\t\t\tshipEngine(p)\n\t\t),\n\t\tshipRing(p)\n\t);\n}\n\n// Ship map\nfloat map(in vec3 p){\n    float d2 = dot(p,p);\n    if(d2 > 1.){\n        return sqrt(d2)-0.5;\n    }\n    return ship(p.xzy); // Rotat eship so it's horizontal\n}\n\nfloat windowMat(in vec3 p) {\n    return smoothstep(-0.001, 0.0,-shipWindows(p.xzy));\n}\n\n\nfloat engineMat(in vec3 p) {\n    return smoothstep(-EPS - 0.01, -EPS, -shipEngine(p.xzy));\n}\n\n\n// Engine plume\n// returns 3D value noise - from https://iquilezles.org/articles/gradientnoise/\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n    \n}\nfloat fbm( in vec3 x, in float H, in int octaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat exhaustNoise(in vec3 p, in int octaves){\n    vec3 p2 = p.xzy;\n    vec3 noise_pos = p2 * vec3(10. / p2.y, 2., 10. / p2.y) + vec3(0., 50. * iTime, 0.); // Moving origin to make exhaust move\n   \n    float strength = smoothstep(0.25, 2., -p2.y) * -p2.y * 0.1;\n    float distort = fbm(noise_pos, 1.2, octaves) * strength;\n    return distort;\n}\n\nfloat exhaust(in vec3 p, in int octaves) {\n    vec3 p2 = p.xzy + vec3(0., -0.25, 0.); // origin centered on start of exhaust\n    float distort = exhaustNoise(p, octaves);\n\n    return sdCone(p2, vec2(0.1, 1.0), 100.0) + distort;\n}\n\nvec3 exhaustNormal( in vec3 pos ) // for function f(p)\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*exhaust(pos+e*h, 2);\n    }\n    return normalize(n);\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal( in vec3 pos ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nbool intersect( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( h < EPS * dist) return true;\n\t\th = map(ro + rd * dist);\n        dist += h;\n\t\tif( dist > MAX_DIST) return false;\n    }\n\treturn false;\n}\n\n// Often fails because of inexact SDF, but this is okay - it leads to a cool pattern in the exhaust.\nbool intersect_exhaust( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h < 0.0001 * dist) return true;\n        vec3 p = ro + rd * dist;\n\t\th = exhaust(ro + rd * dist, 6);\n        dist += h * 0.9;\n\t\tif( dist > 20.) return false;\n    }\n\treturn h < 0.01;\n}\n\n// Faster, lower quality exhaust\nbool intersect_exhaust_lq( in vec3 ro, in vec3 rd, out float dist)\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n\t\tif( h < 0.02 * dist) return true;\n        vec3 p = ro + rd * dist;\n\t\th = exhaust(ro + rd * dist, 1);\n        dist += h * 0.9 + 0.02;\n\t\tif( dist > 50.) return false;\n    }\n\treturn false;\n}\n\n// From https://www.shadertoy.com/view/4slSWf\nvoid generateRay( out vec3 resRo, out vec3 resRd, in vec3 po, in vec3 ta, in vec2 pi )\n{\n\tvec2 p = (2.0*pi-iResolution.xy)/iResolution.y;\n        \n    // camera matrix\n    vec3 ww = normalize( ta - po );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n\n    resRo = po;\n    resRd = rd;\n}\n\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n\n// Background based off of https://www.shadertoy.com/view/llj3Rz\nvec3 background( in vec3 d, in vec3 l , in float starsize)\n{\n    vec3 col = vec3(0.0);\n         col += 0.6*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 1.5*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    col = smoothstep(0.15, 0.5, col);\n    \n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 30.0*d.xy*starsize );\n    vec2 vyz = voronoi( 30.0*d.yz*starsize );\n    vec2 vzx = voronoi( 30.0*d.zx*starsize );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,10.0*starsize)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,100.0*starsize)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\nvec3 BlackBody( float t )\n{\n    const float h = 6.6e-34; // Planck constant\n    const float k = 1.4e-23; // Boltzmann constant\n    const float c = 3e8;// Speed of light\n\n    vec3 w = vec3( 610.0, 549.0, 468.0 ) / 1e9; // approximate wavelength of primaries\n    \n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    vec3 w5 = w*w*w*w*w;    \n    vec3 o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;\n}\n\nvec3 shadeExhaust(vec3 p, vec3 rd) {\n    vec3 norm = exhaustNormal(p);\n    float ndotr = dot(rd, norm);\n    float rim = pow(1.0-abs(ndotr),2.0);\n    float temp_gradient = mix(1200., 0., -p.z * 0.03);\n    float temperature = temp_gradient + smoothstep(-0.5, 0.5, -exhaustNoise(p, 8)) * 200.;\n    float thickness = (rim + 0.03) * 0.00001;\n    \n    return vec3(BlackBody(temperature) * thickness);\n}\n\n\nvec3 shadeShip(vec3 p, vec3 rd, vec3 lightDir) {\n    float window = windowMat(p);\n    float engine = engineMat(p);\n    vec3 norm = calcNormal(p);\n    float spec_strength = mix(0.6, 0.9, window);\n    spec_strength = mix(spec_strength, 0.01, engine);\n\n\tfloat ndotl = dot(norm,lightDir);\n    float ao = mix(0.6, 1.0, calcAO(p, norm));\n    float shadowAttenuation = softshadow(p + norm * EPS, lightDir, 0.01, 3.0);\n    float occ = ao * shadowAttenuation;\n\n    \n    // Diffuse\n    vec3 albedo = mix(vec3(0.9, 0.1, 0.1), vec3(0.05, 0.05, 0.05), window);\n    albedo = mix(albedo, vec3(0.05), engine);\n    \n\tvec3 light = smoothstep(-.1, 1.0, ndotl) * vec3(1.);\n\n\tvec3 col = albedo * light * occ;\n\t\n    vec3 exhaust_dir = vec3(0., 0., -1.);\n    float ndotexhaust = dot(norm, exhaust_dir);\n    light = smoothstep(-.1, 1.0, ndotexhaust) * vec3(1., 0.8, 0.2) * 15.;\n    float exhaust_occ = softshadow(p + norm * EPS, exhaust_dir, 0.001, 0.5) + 0.2;\n    \n\tcol += albedo * light * exhaust_occ;\n    \n\t// specular\n\tvec3 h = normalize(lightDir-rd);\n\tfloat s = pow(max(0.0,dot(norm,h)),50.0) * spec_strength;\n\t\n\tvec3 specular = s*vec3(1.0);\n\n\n    // Reflections\n    // I think these look too sharp on the body of the ship. \n    // Skybox reflection\n\tvec3 rr = reflect(rd, norm);\n    float rr_atten = softshadow(p + norm * EPS, rr, 0.01, 100.0);\n\tspecular += mix(albedo * occ * spec_strength, background(rr, lightDir, spec_strength), rr_atten);\n    \n    // Exhaust reflection\n    float exhaust_d;\n    bool rr_exhaust_hit = intersect_exhaust_lq(p, rr, exhaust_d);\n    if(rr_exhaust_hit){\n        specular += rr_atten * spec_strength * shadeExhaust (p + rr * exhaust_d, rr);\n    }\n\t\n\tfloat ndotr = dot(norm,rd);\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0) * spec_strength;\n\tfresnel = mix(spec_strength, 1.0, fresnel );\n\n\tcol = mix( col, specular, fresnel );\n\t\n\treturn col;\n}\n\n\n\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // camera\n    float an = 0.3*iTime;\n\tvec3  po = vec3(1.0 + 3.5*sin(an),1.0,3.5*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    vec3 ro,  rd;  generateRay( ro,  rd,  po, ta, fragCoord.xy );\n    \n    vec4 ship_sphere = vec4(vec3(0.), 0.6);\n    \n    vec3 col = vec3(0.0);\n\n    vec3 star_dir = normalize(vec3(1., 1., 1.));//normalize(vec3(sin(0.5*iTime),2. * sin(0.34253*iTime),cos(0.5*iTime)));\n\n    \n    float dist; bool hit;\n    float exhaust_dist;\n    hit = intersect(ro, rd, dist);\n    if(hit){\n        vec3 pos = ro + dist * rd;\n        col = shadeShip(pos, rd, star_dir);\n        hit = intersect_exhaust(ro, rd, exhaust_dist);\n        if(hit && exhaust_dist < dist){\n            col += shadeExhaust(ro + rd * exhaust_dist, rd);\n        }\n    } else {\n        col = background(rd, star_dir, 1.5) * 0.5;\n        hit = intersect_exhaust(ro, rd, exhaust_dist);\n        if(hit){\n            col += shadeExhaust(ro + rd * exhaust_dist, rd);\n        }\n    }\n    \n\n    col = col * vec3(1., 1., 1.);\n    col = encodeSRGB(col);\n    // Output to screen\n    fragColor = vec4(col, 0.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 98, 133, 133, 159], [161, 161, 220, 220, 309], [311, 323, 370, 370, 715], [717, 717, 750, 750, 815], [817, 817, 869, 869, 990], [992, 992, 1056, 1056, 1602], [1605, 1605, 1650, 1650, 1741], [1744, 1744, 1784, 1784, 1809], [1811, 1811, 1851, 1851, 1887], [1889, 1889, 1941, 1941, 2042], [2044, 2044, 2074, 2074, 2171], [2173, 2209, 2239, 2239, 2294], [2297, 2297, 2325, 2325, 2521], [2523, 2523, 2552, 2552, 2701], [2704, 2729, 2756, 2756, 2960], [2965, 2965, 2987, 2987, 3065], [3067, 3079, 3100, 3100, 3237], [3239, 3239, 3267, 3267, 3325], [3328, 3328, 3356, 3356, 3420], [3423, 3519, 3545, 3545, 3763], [3764, 3764, 3815, 3815, 4024], [4026, 4026, 4072, 4072, 4370], [4372, 4372, 4414, 4414, 4601], [4603, 4603, 4659, 4659, 4944], [4948, 4948, 5013, 5013, 5237], [5240, 5292, 5345, 5345, 5664], [5667, 5667, 5709, 5709, 6013], [6016, 6016, 6074, 6074, 6281], [6283, 6384, 6450, 6450, 6703], [6705, 6738, 6806, 6806, 7061], [7063, 7109, 7197, 7197, 7515], [7518, 7518, 7586, 7586, 7846], [7849, 7849, 7870, 7870, 7964], [7966, 7966, 7993, 7993, 8366], [8369, 8434, 8494, 8494, 9314], [9316, 9316, 9343, 9343, 9752], [9754, 9754, 9790, 9790, 10150], [10153, 10153, 10201, 10201, 12003], [12008, 12008, 12041, 12041, 12209], [12212, 12212, 12269, 12284, 13354]], "test": "untested"}
{"id": "NlsfRH", "name": "Bullet trace", "author": "chertkov", "description": "A subtle bullet trace shader. This effect is apparently called \"Bullet Schlieren\". Imagine bullet flying out of the origin point and being currently in the target point. Shader emulates thinner air along the way.", "tags": ["trace", "bullet", "schlieren"], "likes": 2, "viewed": 324, "published": 3, "date": "1650541904", "time_retrieved": "2024-07-30T16:52:27.513214", "image_code": "float force = 0.5;\nfloat thickness = 0.1;\nvec2 origin = vec2(0.0, 0.5);\nvec2 target = vec2(0.0, 0.5);\n\n//distance from C to a line defined by two points: A and B\nfloat distance_to_line(vec2 C, vec2 A, vec2 B) {\n    float k = (B.y - A.y) / (B.x - A.x);\n    float t = B.y - k * B.x;\n    \n    return abs((k * C.x - C.y + t) / sqrt(k * k + 1.0));\n}\n\n//closest point to C on a line defined by A and B\nvec2 closest_point(vec2 C, vec2 A, vec2 B){\n    float k = (B.y - A.y) / (B.x - A.x);\n    float t = B.y - k * B.x;\n    \n    float x = (-1.0 * (-C.x - k * C.y) - k * t) / (k * k + 1.0);\n    float y = (k * (C.x + k * C.y) + t) / (k * k + 1.0);\n    return vec2(x, y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    origin.x = sin(iTime * 4.0 - 12.3);\n    target.x = sin(iTime * 4.0);\n    \n    \n    float d_line = distance_to_line(uv, origin, target);\n    float d_origin = distance(uv, origin);\n    float d_target = distance(uv, target);\n    \n    //fragment is close to origin or target\n    float mask = 1.0 - smoothstep(0.0, thickness, \n        min(d_origin, d_target));\n    \n    //fragment is close to the segment of a line between origin and target\n    vec2 P = closest_point(uv, origin, target);\n    if(P.x >= min(origin.x, target.x) && P.x <= max(origin.x, target.x) && \n    P.y <= max(origin.y, target.y) && P.y >= min(origin.y, target.y)) \n    {\n        mask = 1.0 - smoothstep(0.0, thickness, d_line);     \n    }\n    \n    vec2 disp = (uv - P) * force * mask;\n  \n    //fragColor.rgb = vec3(mask);\n    fragColor = texture(iChannel0, uv - disp);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 162, 210, 210, 344], [346, 396, 439, 439, 661], [663, 663, 718, 718, 1599]], "test": "untested"}
{"id": "flfBzn", "name": "WangTiles + CornerTiles", "author": "73begonia", "description": "WangTiles + CornerTiles", "tags": ["procedural", "2d", "tile", "wang", "corner"], "likes": 2, "viewed": 292, "published": 3, "date": "1650537838", "time_retrieved": "2024-07-30T16:52:28.505561", "image_code": "#define R vec3(1., 0., 0.)\n#define G vec3(0., 1., 0.)\n#define B vec3(0., 0., 1.)\n#define Y vec3(1., 1., 0.)\n\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n\nstruct wangTile\n{ \n    vec3 topColor;\n    vec3 rightColor;\n    vec3 bottomColor;\n    vec3 leftColor;\n};\n\nstruct cornerTile\n{\n    vec3 tlColor;\n    vec3 trColor;\n    vec3 brColor;\n    vec3 blColor;\n};\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdLine(vec2 p, vec2 p0, vec2 p1, float width) {\n    vec2 dir0 = p1 - p0;\n    vec2 dir1 = p - p0;\n    float h = clamp(dot(dir1, dir0)/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return d;\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nwangTile wTile[16];\ncornerTile cTile[16];\n\nvoid iniWangTile()\n{\n    wTile[0].topColor = G; wTile[0].rightColor = B; wTile[0].bottomColor = G; wTile[0].leftColor = B;\n    wTile[1].topColor = G; wTile[1].rightColor = B; wTile[1].bottomColor = G; wTile[1].leftColor = Y;\n    wTile[2].topColor = G; wTile[2].rightColor = B; wTile[2].bottomColor = R; wTile[2].leftColor = B;\n    wTile[3].topColor = G; wTile[3].rightColor = B; wTile[3].bottomColor = R; wTile[3].leftColor = Y;\n    wTile[4].topColor = G; wTile[4].rightColor = Y; wTile[4].bottomColor = G; wTile[4].leftColor = B;\n    wTile[5].topColor = G; wTile[5].rightColor = Y; wTile[5].bottomColor = G; wTile[5].leftColor = Y;\n    wTile[6].topColor = G; wTile[6].rightColor = Y; wTile[6].bottomColor = R; wTile[6].leftColor = B;\n    wTile[7].topColor = G; wTile[7].rightColor = Y; wTile[7].bottomColor = R; wTile[7].leftColor = Y;\n    wTile[8].topColor = R; wTile[8].rightColor = B; wTile[8].bottomColor = G; wTile[8].leftColor = B;\n    wTile[9].topColor = R; wTile[9].rightColor = B; wTile[9].bottomColor = G; wTile[9].leftColor = Y;\n    wTile[10].topColor = R; wTile[10].rightColor = B; wTile[10].bottomColor = R; wTile[10].leftColor = B;\n    wTile[11].topColor = R; wTile[11].rightColor = B; wTile[11].bottomColor = R; wTile[11].leftColor = Y;\n    wTile[12].topColor = R; wTile[12].rightColor = Y; wTile[12].bottomColor = G; wTile[12].leftColor = B;\n    wTile[13].topColor = R; wTile[13].rightColor = Y; wTile[13].bottomColor = G; wTile[13].leftColor = Y;\n    wTile[14].topColor = R; wTile[14].rightColor = Y; wTile[14].bottomColor = R; wTile[14].leftColor = B;\n    wTile[15].topColor = R; wTile[15].rightColor = Y; wTile[15].bottomColor = R; wTile[15].leftColor = Y;\n}\n\nvoid iniCornerTile()\n{\n    cTile[0].tlColor = R; cTile[0].trColor = R; cTile[0].brColor = R; cTile[0].blColor = R;\n    cTile[1].tlColor = Y; cTile[1].trColor = R; cTile[1].brColor = R; cTile[1].blColor = R;\n    cTile[2].tlColor = R; cTile[2].trColor = R; cTile[2].brColor = R; cTile[2].blColor = Y;\n    cTile[3].tlColor = Y; cTile[3].trColor = R; cTile[3].brColor = R; cTile[3].blColor = Y;\n    cTile[4].tlColor = R; cTile[4].trColor = R; cTile[4].brColor = Y; cTile[4].blColor = R;\n    cTile[5].tlColor = Y; cTile[5].trColor = R; cTile[5].brColor = Y; cTile[5].blColor = R;\n    cTile[6].tlColor = R; cTile[6].trColor = R; cTile[6].brColor = Y; cTile[6].blColor = Y;\n    cTile[7].tlColor = Y; cTile[7].trColor = R; cTile[7].brColor = Y; cTile[7].blColor = Y;\n    cTile[8].tlColor = R; cTile[8].trColor = Y; cTile[8].brColor = R; cTile[8].blColor = R;\n    cTile[9].tlColor = Y; cTile[9].trColor = Y; cTile[9].brColor = R; cTile[9].blColor = R;\n    cTile[10].tlColor = R; cTile[10].trColor = Y; cTile[10].brColor = R; cTile[10].blColor = Y;\n    cTile[11].tlColor = Y; cTile[11].trColor = Y; cTile[11].brColor = R; cTile[11].blColor = Y;\n    cTile[12].tlColor = R; cTile[12].trColor = Y; cTile[12].brColor = Y; cTile[12].blColor = R;\n    cTile[13].tlColor = Y; cTile[13].trColor = Y; cTile[13].brColor = Y; cTile[13].blColor = R;\n    cTile[14].tlColor = R; cTile[14].trColor = Y; cTile[14].brColor = Y; cTile[14].blColor = Y;\n    cTile[15].tlColor = Y; cTile[15].trColor = Y; cTile[15].brColor = Y; cTile[15].blColor = Y;\n}\n\nint getHorizontal(wangTile tileArray[16], wangTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].leftColor == tile.rightColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCornerHorizontal(cornerTile tileArray[16], cornerTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].tlColor == tile.trColor && tileArray[index].blColor == tile.brColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getVertical(wangTile tileArray[16], wangTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].bottomColor == tile.topColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCornerVertical(cornerTile tileArray[16], cornerTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].blColor == tile.tlColor && tileArray[index].brColor == tile.trColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCross(wangTile tileArray[16], wangTile tileBottom, wangTile tileLeft)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].bottomColor == tileBottom.topColor && tileArray[index].leftColor == tileLeft.rightColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCornerCross(cornerTile tileArray[16], cornerTile tileBottom, cornerTile tileLeft)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].blColor == tileBottom.tlColor && tileArray[index].brColor == tileBottom.trColor && tileArray[index].tlColor == tileLeft.trColor && tileArray[index].blColor == tileLeft.brColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nvec3 drawWangTile(vec2 uv, vec2 offset, wangTile tile)\n{\n\tvec3 col = vec3(1.);\n    vec2 p = uv + offset;\n    \n    float b = sdTrapezoid(p, vec2(0.05, 0.), vec2(0.1, 0.), float(0.05), float(0.1));\n    float d = sdTrapezoid(p, vec2(-0.05, 0.), vec2(-0.1, 0.), float(0.05), float(0.1));\n    float c = sdTrapezoid(vec2(p.x, p.y + 0.075), float(0.1), float(0.05), float(0.025));\n    float a = sdTrapezoid(vec2(p.x, p.y - 0.075), float(0.05), float(0.1), float(0.025));\n    float z = sdCircle(p, 0.1);\n    \n    if(z < 0.)\n    \tcol = vec3(0.);\n  \tif(a < 0.)\n    \tcol = tile.topColor;\n  \tif(b < 0.)\n    \tcol = tile.rightColor;\n  \tif(c < 0.)\n    \tcol = tile.bottomColor;\n  \tif(d < 0.)\n    \tcol = tile.leftColor;\n        \n\treturn col;\n}\n\nvec3 drawCornerTile(vec2 uv, vec2 offset, cornerTile tile)\n{\n    vec3 col = vec3(1.);\n    vec2 p = uv + offset;\n    \n    float a = sdCircle(p + vec2(0.1, -0.1), 0.1);\n    float b = sdCircle(p + vec2(-0.1, -0.1), 0.1);\n    float c = sdCircle(p + vec2(-0.1, 0.1), 0.1);\n    float d = sdCircle(p + vec2(0.1, 0.1), 0.1);\n    float z = sdCircle(p, 0.1);\n    \n    if(z < 0.)\n    \tcol = vec3(0.);\n    if(a < 0. && p.x < 0. && p.y > 0. && p.x > -0.1 && p.y < 0.1)\n    \tcol = tile.tlColor;\n    if(b < 0. && p.x > 0. && p.y > 0. && p.x < 0.1 && p.y < 0.1)\n        col = tile.trColor;\n  \tif(c < 0. && p.x > 0. && p.y < 0. && p.x < 0.1 && p.y > -0.1)\n        col = tile.brColor;\n    if(d < 0. && p.x < 0. && p.y < 0. && p.x > -0.1 && p.y > -0.1)\n        col = tile.blColor;\n    \n    return col;\n}\n\nvec3 drawLine(vec2 uv, inout vec3 col)\n{\n    float t;\n    uv.x += 0.1;\n    uv.y += 0.1;\n    \n    for(int i = 0; i < 10; i ++)\n    {\n        t = sdLine(vec2(uv.x - float(i) * 0.2), vec2(0., 0.0), vec2(0., -1.), float(0.005));\n        if(t < 0.)\n            col *= vec3(0.);\n    }\n    for(int i = 0; i < 6; i++)\n    {\n        t = sdLine(vec2(uv.x, uv.y - float(i) * 0.2), vec2(1.8, 0.0), vec2(0., 0.), float(0.005));\n        if(t < 0.)\n            col *= vec3(0.);\n    }\n        \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = fragCoord/iResolution.xy; // <0,1>\n    uv.x -= 0.05;\n    uv.y -= 0.1;\n  \tuv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    seed = int(iTime * 0.5) % 32767;\n    \n    iniWangTile();\n    iniCornerTile();\n  \n  \tvec3 col = vec3(1.);\n    vec2 offset;\n    \n    int wangTileIndex[45];\n    wangTileIndex[0] = rand() % 16;\n    int cornerTileIndex[45];\n    cornerTileIndex[0] = rand() % 16;\n\n    if(seed % 2 == 0)\n    {\n        for(int i = 0; i < 5; i++)\n        {\n            for(int j = 0; j < 9; j++)\n            {\n                if(i == 0 && j == 0)\n                    col = drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[0]]);\n                else if(i == 0 && j != 0)\n                {\n                    wangTileIndex[j] = getHorizontal(wTile, wTile[wangTileIndex[j - 1]]);\n                    col *= drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[j]]);\n                }\n                else if(i !=0 && j == 0)\n                {\n                    wangTileIndex[i * 9] = getVertical(wTile, wTile[wangTileIndex[(i-1) * 9]]);\n                    col *= drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[i * 9]]);\n                }\n                else if(i !=0 && j != 0)\n                {\n                    wangTileIndex[i * 9 + j] = getCross(wTile, wTile[wangTileIndex[(i - 1) * 9 + j]], wTile[wangTileIndex[i * 9 + j - 1]]);\n                    col *= drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[i * 9 + j]]);\n                }\n            }\n        }\n    }\n    \n    else\n    {\n        for(int i = 0; i < 5; i++)\n        {\n            for(int j = 0; j < 9; j++)\n            {\n                if(i == 0 && j == 0)\n                    col = drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[0]]);\n                else if(i == 0 && j != 0)\n                {\n                    cornerTileIndex[j] = getCornerHorizontal(cTile, cTile[cornerTileIndex[j - 1]]);\n                    col *= drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[j]]);\n                }\n                else if(i !=0 && j == 0)\n                {\n                    cornerTileIndex[i * 9] = getCornerVertical(cTile, cTile[cornerTileIndex[(i-1) * 9]]);\n                    col *= drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[i * 9]]);\n                }\n                else if(i !=0 && j != 0)\n                {\n                    cornerTileIndex[i * 9 + j] = getCornerCross(cTile, cTile[cornerTileIndex[(i - 1) * 9 + j]], cTile[cornerTileIndex[i * 9 + j - 1]]);\n                    col *= drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[i * 9 + j]]);\n                }\n            }\n        }\n    }\n    \n    \n    \n    col *= drawLine(uv, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 143, 143, 200], [403, 403, 427, 427, 446], [448, 448, 513, 513, 823], [825, 825, 902, 902, 1448], [1450, 1450, 1503, 1503, 1687], [1689, 1689, 1724, 1724, 1752], [1797, 1797, 1817, 1817, 3475], [3477, 3477, 3499, 3499, 4997], [4999, 4999, 5057, 5057, 5268], [5270, 5270, 5338, 5338, 5588], [5590, 5590, 5646, 5646, 5857], [5859, 5859, 5925, 5925, 6175], [6177, 6177, 6255, 6255, 6525], [6527, 6527, 6617, 6617, 6975], [6977, 6977, 7033, 7033, 7703], [7705, 7705, 7765, 7765, 8489], [8491, 8491, 8531, 8531, 8986], [8989, 8989, 9046, 9046, 12252]], "test": "untested"}
{"id": "flScD3", "name": "Jalta lighthouse", "author": "deni_de", "description": "Jalta, Crimea", "tags": ["raymarch", "sea", "day", "lighhouse"], "likes": 22, "viewed": 576, "published": 3, "date": "1650531561", "time_retrieved": "2024-07-30T16:52:29.502894", "image_code": "#define PI 3.14\n#define wavelength 4.8\n#define steepness 0.7\n\n#define surfaceEdge .001\n\n#define normalPower 1.0\nvec3 ambient = vec3(0.001);\n\n//OPERATORS_3D______OPERATORS_3D______OPERATORS_3D______OPERATORS_3D______OPERATORS_3D______\nfloat random (vec2 seed) \n{\n    return fract(sin(dot(seed.xy,\n                         vec2(12.9898,78.233)))\n                             * 43758.5453123);\n}\nmat2 Rotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\nvec3 Wave(vec4 wave, vec3 pos, vec2 SW)\n{\n    float s = SW.x;\n    float w = SW.y;\n    float k = 2. * PI / w ;\n    float c = sqrt(9.8 / k);\n    vec2 d = normalize(wave.xy);\n    \n    float f = k * (dot(d, pos.xz) - c * iTime);\n    float a = s / k;\n    \n    return vec3(d.x * (a * cos(f)),\n\t\t\t\ta * sin(f),\n\t\t\t\td.y * (a * cos(f)));\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) \n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Low quality, turbulent FBM (for raymarching)\nfloat fbm(vec2 uv) \n{\n    float h = 0.0, a = 1.0;    \n    for (int i = 0; i < 4; ++i) \n    {\n        h += 1.0-abs(a * noise(iTime - uv) ); // ridged perlin noise\n        a *= 0.45; uv *= 2.02;\n    }   \n    \n    return h;\n}\n\n//PRIMITIVE____PRIMITIVE____PRIMITIVE____PRIMITIVE____PRIMITIVE____PRIMITIVE____\nvec2 sphere(vec3 position, vec4 objPosition, float matId)\n{\n    return vec2(length(position-objPosition.xyz) - objPosition.w,matId);\n}\n\nvec2 box(vec3 position, vec3 bounds, float matId)\n{\n  vec3 q = abs(position) - bounds;\n  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),matId);\n}\n\nvec2 sdHexPrism( vec3 p, vec2 h, float matId)\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),matId);\n}\n\nvec2 sdTorus( vec3 p, vec2 t ,float matId)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return vec2(length(q)-t.y, matId);\n}\n\n//vec2 sdCone( vec3 p, vec2 c, float h ,float matId)\nvec2 sdCone( in vec3 p, in vec2 c, float h, float matId)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return vec2(sqrt(d)*sign(s), matId);\n}\n\nvec2 sdBoxFrame( vec3 p, vec3 b, float e ,float matId)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return vec2(min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),matId);\n}\n//OBJECTS_STRUCT_______OBJECTS_STRUCT_______OBJECTS_STRUCT_______OBJECTS_STRUCT_______\nvec2 waterplane(vec3 position, float matId)\n{\n    vec4 waveInfo = vec4(1,-3,0,0);\n    vec4 waveInfo2 = vec4(-1,5,0,0);\n    vec4 waveInfo3 = vec4(-3,2,0,0);\n    float oPos = position.y;\n    \n    vec3 wave = vec3(fbm(position.xz + 0.7 + iTime));\n    wave += Wave(waveInfo, position,vec2(steepness,wavelength));\n    wave += Wave(waveInfo3,position,vec2(steepness * 2., wavelength / 2.));\n      \n    float o = (wave.x + wave.y + wave.z) / 3. ;\n    // .21 | .11\n    oPos += o * 0.11;\n    return vec2(oPos,matId);\n}\n\nvec2 pier(vec3 position, float matId)\n{\n    vec3 boxPosCtrl = (position - vec3(-8.8,0,14));\n    float boxs = box( boxPosCtrl, vec3(9,1,1), matId).x;\n    \n    boxPosCtrl = (position - vec3(-8.8, 2.1, 14.21));\n    boxs = min( boxs, box( boxPosCtrl, vec3(9,1.5,.1), matId).x );\n    \n    boxPosCtrl = position - vec3(-2.3, 0, 12.21);\n    boxs = min( boxs, box( boxPosCtrl , vec3(4,1,2), matId).x );\n    \n    boxPosCtrl = position - vec3(-1.3, 0.21, 12.21);\n    boxs = min( boxs, box( boxPosCtrl , vec3(3,2,1), matId).x );\n    \n    boxs -= texture(iChannel0,position.xy * .21).b * 0.07;\n    \n    return vec2(boxs,matId);\n}\n\nvec2 lighthouse(vec3 position, float matId)\n{\n    vec3 tmpPose = position - vec3(0,4.0,13);\n    tmpPose.yz *= Rotate(1.6);\n    float lhouse = sdHexPrism(tmpPose, vec2(1,2.55),matId).x;\n    \n    tmpPose = position - vec3(0,8.8,13);    \n    lhouse = min(lhouse, sdCone(tmpPose, vec2(1,1.2), 1.4, matId).x);\n    \n    tmpPose = position - vec3(0,5,12);  \n    lhouse = max( -box( tmpPose, vec3(.1,.2,.5), matId).x, lhouse );\n    \n    tmpPose = position - vec3(0,3.5,12);  \n    lhouse = max( -box( tmpPose, vec3(.1,.2,.5), matId).x, lhouse );\n    \n    tmpPose = position - vec3(0,9,13);  \n    lhouse = min(  lhouse, box( tmpPose, vec3(.05,.7,.05), matId).x);\n    \n    tmpPose = position - vec3(0,7,13); \n    tmpPose.xz *= Rotate(0.7);\n    lhouse = min( lhouse, sdBoxFrame( tmpPose, vec3(.8,.5,.8), .05, matId).x);\n    \n    tmpPose = position - vec3(0,5.7,13);\n    tmpPose.yz *= Rotate(1.6);\n    lhouse = min( lhouse, sdHexPrism(tmpPose, vec2(1.5, .021),matId).x);\n    \n    tmpPose = position - vec3(0,2.4,13);\n    tmpPose.yz *= Rotate(1.6);\n    lhouse = min( lhouse, sdHexPrism(tmpPose, vec2(1.3, .5),matId).x);\n    \n    tmpPose = position - vec3(0,7.4,13);\n    tmpPose.yz *= Rotate(1.6);\n    lhouse = min( lhouse, sdHexPrism(tmpPose, vec2(1.3, .021),matId).x);\n    \n    lhouse -= texture(iChannel2,position.xy * .21).b * 0.02;\n    \n    return vec2(lhouse,matId);\n}\n//RAYFUNCTIONS______RAYFUNCTIONS______RAYFUNCTIONS______RAYFUNCTIONS______RAYFUNCTIONS______\nvec2 Map(vec3 position)\n{\n    float mat = 2.0;\n    float final = position.y;\n    \n    float waterplane = waterplane(position,1.).x;\n    final = waterplane;\n    float prevd = final;\n    \n    float pier = pier(position,2.).x;\n    final = min(waterplane, pier);\n    \n    if (final < prevd)\n        mat = 3.0;\n    prevd = final;\n    \n    float lighthouse = lighthouse(position + vec3(0.5,0,0),3.).x;\n    final = min(final,lighthouse);\n    if (final < prevd)\n        mat = 4.0;\n    prevd = final;\n    ;\n    float sphDist = sphere(position + vec3(0.5,0,0), vec4(0, 6.9, 13, 0.21),0.).x;\n    final = min(final,sphDist);\n    \n    if (final < prevd)\n        mat = 5.0;\n    prevd = final;\n\n    return vec2(final,mat);\n}\n\nvec2 Raycast(vec3 rayOrigin, vec3 rayDirection)\n{\n    //distance of a point on ray\n    float d = 0.0;\n    float matId = 0.0;\n    \n    //cast all ray points\n    for(int i = 0; i < 200; i++)\n    {\n        vec3 position = rayOrigin + rayDirection * d;\n        \n        //map.x = distS;\n        vec2 map = Map(position);\n        \n        matId = map.y;\n                \n        if (map.x < 0.001) break;\n        \n        d += map.x;\n        \n        if(d > 120.0) break;\n        \n    }\n    if(d > 100.0) d = -1.0;\n    return vec2(d,matId);\n}\n\nvec3 CalcNormal(vec3 position)\n{\n    float d = Map(position).x;\n    \n    vec2 edge = vec2(0.001, 0);\n    vec3 normal = d - vec3(\n        Map(position-edge.xyy).x,\n            Map(position-edge.yxy).x,\n                Map(position-edge.yyx).x\n                                        );\n    return normalize(normal);\n}\n\n//LIGHTNING____LIGHTNING____LIGHTNING____LIGHTNING____LIGHTNING____LIGHTNING____LIGHTNING____\nvec3 CalcLight(vec3 position,vec3 lightPosition,vec3 rayOrigin, vec3 rayDirection, vec4 lightColor, bool point)\n{\n    vec3 l;\n    vec3 n = CalcNormal(position);\n    float shadow;\n    \n    if(point)\n    {\n        l = normalize(lightPosition-position);\n        shadow = Raycast(position + n * surfaceEdge, l).x;\n    }\n    else\n    {\n        l = normalize(lightPosition);\n        shadow = step( Raycast(position + n * surfaceEdge, l).x, 0.0);\n    }\n    \n    float nl = clamp(dot(n,l), 0., 1.);\n    return lightColor.rgb * (nl * shadow * lightColor.w) ;\n}\n\nvec3 SkyMotions(float status, vec3 rd, vec3 ro, vec3 lp)\n{\n    //color = vec3(0.6,0.7,0.9) - 0.5 * rd.y;\n        //color = mix(color,vec3(0.9,0.95,1.2),exp(-10.0*rd.y));\n    vec3 day_colorsky = (vec3(0.6,0.7,0.9) - 0.5 * rd.y);\n    vec3 day_colorhorz = vec3(0.9,0.95,1.2);\n    float stat = dot(lp.x,lp.y);\n    vec3 colorsky = mix(day_colorsky, day_colorhorz, exp(-10.0 *rd.y ));\n    float sun = pow(1.0 - length( ( rd + vec3(0.5 + status,0.1,-0.4)) - 0.4), 20.5) * 25.;\n    \n    return colorsky + clamp(sun,0.01,1.);\n}\n\nfloat ao(vec3 p, vec3 n) \n{\n\tfloat o = 0.0, s = 0.011, w = 1.0;\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tfloat d = Map(p + n*s).x;\n\t\to += (s - d)*w;\n\t\tw *= 0.98;\n\t\ts += s/float(i + 1);\n\t}\n\t\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 RenderImage(out vec3 ro, out vec3 rd, vec3 color, vec3 lp, float status)\n{\n    for(int i = 0; i < 2; i++)\n    {\n        //SKY\n        //color = vec3(0.6,0.7,0.9) - 0.5 * rd.y;\n        //color = mix(color,vec3(0.9,0.95,1.2),exp(-10.0*rd.y));\n\n        //2.0 = standard\n        color = SkyMotions(status,rd,ro,lp);\n\n        //AMBIENT < ? >\n        vec3 ambient = clamp(color,vec3(0),vec3(1));\n\n        vec2 ray = Raycast(ro,rd);\n        if(ray.x > 0.0)\n        {\n            vec3 diffuse = vec3(0);\n            vec3 position = ro + rd * ray.x;\n            vec3 normal = CalcNormal(position);\n            vec3 l = normalize(lp-position);          \n\n            float bounce = clamp(0.5 + 0.5 * dot(normal,vec3(0.0,-1.0,0.0)),0.0,1.0);\n            float SkyAmbient = clamp(0.5 + 0.5 * dot(normal,vec3(0.0,1.0,0.0)),0.0,1.0)+ 0.05;\n\n            float AO = ao(position, normal);\n\n            diffuse += CalcLight( position, lp, ro, rd, vec4(1, 1, 1, 1.0), false);\n            diffuse +=  ambient * SkyAmbient * ctrl; //vec3(0.9,0.95,1.2) * SkyAmbient;      \n            vec3 mat = vec3(0.16);\n\n            if(ray.y > 4.5)\n            {\n                //SPHERE\n                mat = vec3(1,0,0) * (sin(iTime * 3.0)  * sin(iTime * 0.21) );\n                return mat * AO * 2.0;\n            }\n            else if(ray.y > 3.5)\n            {\n                //LIGHTHOUSE\n                mat = vec3(1,1,1) * diffuse * 5.0 * ctrl;\n                return mat * AO * 2.0;\n            }  \n            else if(ray.y > 2.5)\n            {\n                //PIER\n                vec3 channel0 = texture(iChannel0,position.xy * 0.21 + position.zy * 0.21).rgb;\n                mat = channel0;\n                mat =  mat * diffuse * ctrl;\n                return mat * AO * 2.0;\n            }   \n            else if(ray.y > 1.5)\n            {\n                //WATER  \n                mat = vec3(0.21,0.21,0.7) * diffuse * ctrl;\n                \n                vec3 ref = reflect(rd, normal);\n                ro = position + normal;\n                rd = ref;\n                \n                color -= mat * AO * 0.5;\n            }\n\n            //color += 1. - (length(uv.xy) +.5);\n            //fog\n            //mat = mix(mat, vec3(0.45, 0.8, 1.0), 1.0 - exp(-0.02*t));\n            //color = mat * AO * 2.0;\n        }\n    \n    }\n        \n    return color;\n}\n//MAIN_PROCESSING______MAIN_PROCESSING______MAIN_PROCESSING______MAIN_PROCESSING______\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lp = vec3(-50,9,31);\n    lp.yx *= Rotate(iTime * 0.31) ;\n    float status = (vec2(1,1) * Rotate(iTime * 0.16)).x;\n    vec2 uv = (fragCoord-0.5 *iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(8.1, 3, -15); // Y 1.7\n    vec3 rd = normalize(vec3(uv,1));\n    \n    vec3 color = vec3(0);\n    color = RenderImage(ro,rd,color,lp,status);\n    color = pow(color,vec3(0.53));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ctrl vec3(0.21,0.21,0.21);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flScD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 234, 261, 261, 392], [393, 393, 419, 419, 500], [502, 502, 543, 543, 831], [833, 911, 938, 938, 1318], [1320, 1368, 1389, 1389, 1590], [1592, 1673, 1732, 1732, 1807], [1809, 1809, 1860, 1860, 1971], [1973, 1973, 2020, 2020, 2305], [2307, 2307, 2351, 2351, 2429], [2431, 2484, 2542, 2676, 3024], [3026, 3026, 3082, 3082, 3381], [3382, 3469, 3514, 3514, 3978], [3980, 3980, 4019, 4019, 4597], [4599, 4599, 4644, 4644, 5958], [5959, 6052, 6077, 6077, 6761], [6763, 6763, 6812, 6845, 7300], [7302, 7302, 7334, 7334, 7618], [7620, 7714, 7827, 7827, 8265], [8267, 8267, 8325, 8436, 8785], [8787, 8787, 8814, 8814, 9006], [9008, 9008, 9087, 9087, 11349], [11350, 11437, 11494, 11494, 11918]], "test": "untested"}
{"id": "7tBcDy", "name": "mackjam_ah", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 2, "viewed": 385, "published": 3, "date": "1650523315", "time_retrieved": "2024-07-30T16:52:30.257876", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 1.1);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./10.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p+vec3(0.,iTime*55.,0.);\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(5.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  pcc.xz *= r2d(iTime);\n  pcc.yz *= r2d(.5*iTime);\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2*sat(sin(p.y*.05+5.*iTime));\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 dof = vec3(rand()-.5, rand()-.5, 0.)*.1*FFTS(.05)*10.;\n  vec3 ro = vec3(0.,-5.,-5.)-dof*.1;\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd += dof*.1;\n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  _seed = texture(iChannel2, fragCoord.xy/iResolution.xy).x+iTime;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  //uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n float stp = .01*length(uv);\n  //uv = floor(uv/stp)*stp;\n  \n  //uv -= vec2(.25);\n  //uv *= r2d(FFTI(.1)*10.);\n // uv = abs(uv);\n  \n  vec3 col = rdr(uv+rdr(uv).xy);\n  \n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28784, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBcDy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "slByDy", "name": "mackjam_ag", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 4, "viewed": 411, "published": 3, "date": "1650523301", "time_retrieved": "2024-07-30T16:52:31.020836", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*.2)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\n\nfloat rand()\n{\n  return hash11(_seed++);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return mix(max(l.x, max(l.y, l.z)), length(p)-s.x, 1.1);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*5.1+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./10.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,40.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p;\n  float stpcube = PI*2./4.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(10.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  pcc.xz *= r2d(iTime);\n  pcc.yz *= r2d(.5*iTime);\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2*sat(sin(p.y*.05+5.*iTime));\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 ro = vec3(0.,-5.,-5.);\n  vec3 ta = vec3(sin(iTime)*5.,85.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  //uv *= r2d(-iTime*.5);\n  //uv = abs(uv);\n  //uv -= vec2(.2+uv.y, 0.);\n  //uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n float stp = .01*length(uv);\n  //uv = floor(uv/stp)*stp;\n  \n  //uv -= vec2(.25);\n  //uv *= r2d(FFTI(.1)*10.);\n // uv = abs(uv);\n  \n  vec3 col = rdr(uv);\n  \n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  col = mix(col, texture(iChannel0, gl_FragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime*.5);\n  col = abs(col);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28783, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slByDy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "NtXBRH", "name": "Simple Shape Generator", "author": "SnoopethDuckDuck", "description": "Simply flips a random walk. Looks really cool I think.", "tags": ["procedural", "hexagon", "generative"], "likes": 36, "viewed": 518, "published": 3, "date": "1650497986", "time_retrieved": "2024-07-30T16:52:31.841641", "image_code": "#define pi 3.14159\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Change me for different patterns!\n    float f = 2./3.; \n    //f = 0.5;\n    //f = 0.5 + 0.5 * cos(0.01 * iTime);\n      \n    // Angle + point\n    float a = 0.;\n    vec2 p = vec2(0);\n       \n    float d = 100.;\n    for (float i = 0.; i < 50.; i++) {\n        // Random number gives us a unique shape\n        float h = h21(vec2(i - floor(iTime), 103. + i));\n        \n        // Angle moves: LEFT | left | forwards | right | RIGHT\n        // f changes by how much\n        a += pi * (f * floor(5. * h) - 1.);\n        \n        // New point\n        vec2 q = p + 0.05 * ths(5., pi * iTime) * vec2(cos(a), sin(a));\n        \n        // Segment from old to new point (check normal and flipped x coords)\n        // Uncomment second line to see non-mirrored version\n        d = min(d, seg(uv, p, q));\n        d = min(d, seg(vec2(-uv.x, uv.y), p, q));\n        \n        p = q;\n    }\n    \n    float k = 0.5 / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.009);\n    \n    vec3 col = vec3(s);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 104, 104, 223], [225, 225, 244, 244, 319], [321, 321, 378, 378, 1474]], "test": "untested"}
{"id": "stlBzr", "name": "Square Mayhem", "author": "nuudl3", "description": "This is my first shadertoy project, I wanted to test drawing lines, in future I want to add rotation animations.\n\nI would be happy to hear your suggestions!\n\nedit: I improved my code's performance with sdf methods and added rotations. ", "tags": ["lines", "primitives"], "likes": 3, "viewed": 288, "published": 3, "date": "1650492952", "time_retrieved": "2024-07-30T16:52:32.673418", "image_code": "//Improved with sdf functions\n\nfloat rhombusSDF(vec2 p, float scale)\n{\n    p = abs(p);\n    \n    float d = p.x + p.y; \n    \n    float f1 = d - scale;\n    float f2 = d - scale + 0.01;\n    \n    return max(f1 ,-f2);\n}\n\nfloat squareSDF(vec2 p, float scale)\n{\n    p = abs(p);\n    \n    float f1 = max(p.x, p.y) - scale;    \n    float f2 = max(p.x, p.y) - scale + 0.005;\n    return max(f1,-f2);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv = rotate(uv, 3.1415/16. * iTime);\n    // Time varying pixel color\n    float px=2.5/iResolution.y ;\n    vec3 col = vec3(0.);\n    col = mix(vec3(1,1,1), col, smoothstep(0., px, rhombusSDF(uv, 0.025f)));    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, squareSDF(uv, 0.025f)));\n    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, rhombusSDF(uv, 0.05f)));    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, squareSDF(uv, 0.05f)));\n    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, rhombusSDF(uv, 0.1f)));    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, squareSDF(uv, 0.1f)));\n    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, rhombusSDF(uv, 0.2f)));    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, squareSDF(uv, 0.2f)));\n    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, rhombusSDF(uv, 0.4f)));    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, squareSDF(uv, 0.4f)));\n    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, rhombusSDF(uv, 0.8f)));    \n    col = mix(vec3(1,1,1), col, smoothstep(0., px, squareSDF(uv, 0.8f)));\n\n    col *= cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// OLD CODE with loops and line equations\n\n/*float drawLine(vec2 p1, vec2 p2, vec2 p3)\n{\n    vec2 p13 = p3 - p1;\n    vec2 p12 = p2 - p1;\n    \n    float len = dot(p13, p12) / distance(p2, p1);\n    \n    p12 = normalize(p12);\n    \n    vec2 project = p12 * len + p1;\n    \n    if(distance(project, p3) < 0.005f && distance(p1, project) < distance(p1,p2) && distance(p2, project) < distance(p1,p2)) return 1.0f;\n    //if(distance(project, p3) < 0.05f) return 1.0f;\n    \n    return 0.0f;\n  \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2((fragCoord.x/iResolution.x - 0.5f) * 2.0f, (fragCoord.y/iResolution.y - 0.5f) * 2.0f);\n    \n    vec2 mouse_uv = vec2((iMouse.x/iResolution.x - 0.5f) * 2.0f, (iMouse.y/iResolution.y - 0.5f) * 2.0f);\n    \n    float yx = iResolution.y / iResolution.x;\n    \n    //rotation vectors \n    \n    vec2 n = vec2(1.0f,0);    \n    vec2 e = vec2(0,1.0f);\n    vec2 s = vec2(-1.0f,0);\n    vec2 w = vec2(0,-1.0f); \n    \n    vec2 ne = normalize(vec2(1.0f,1.0f));\n    vec2 se = normalize(vec2(1.0f,-1.0f));\n    vec2 sw = normalize(vec2(-1.0f,-1.0f));\n    vec2 nw = normalize(vec2(-1.0f,1.0f));\n\n\n    vec2 k1 = n * 0.1f;    \n    vec2 k2 = e * 0.1f;\n    vec2 k3 = s * 0.1f;\n    vec2 k4 = w * 0.1f;\n\n    //float lix = drawLine(k1,k2,uv)\n     //           +drawLine(k2,k3,uv)\n       //         +drawLine(k3,k4,uv)\n         //       +drawLine(k4,k1,uv);\n    float lix = 0.;\n    \n    int prev = 1;\n    for(int i = 0; i < 640;)\n    {\n       \n        vec2 k1 = n * 0.01f * float(i) ;    \n        vec2 k2 = e * 0.01f * float(i) ;\n        vec2 k3 = s * 0.01f * float(i) ;\n        vec2 k4 = w * 0.01f * float(i) ;\n        \n        k1.x *= yx;        \n        k2.x *= yx;\n        k3.x *= yx;\n        k4.x *= yx;\n\n        lix += drawLine(k1,k2,uv)\n                +drawLine(k2,k3,uv)\n                +drawLine(k3,k4,uv)\n                +drawLine(k4,k1,uv);\n        \n        \n        \n        \n        vec2 f1 = ne * 0.01f * float(i) * 1.414;    \n        vec2 f2 = se * 0.01f * float(i) * 1.414;\n        vec2 f3 = sw * 0.01f * float(i) * 1.414;\n        vec2 f4 = nw * 0.01f * float(i) * 1.414;\n        \n        f1.x *= yx;        \n        f2.x *= yx;\n        f3.x *= yx;\n        f4.x *= yx;\n        \n        lix += drawLine(f1,f2,uv)\n                +drawLine(f2,f3,uv)\n                +drawLine(f3,f4,uv)\n                +drawLine(f4,f1,uv);\n        \n        \n        \n        i = prev + i;\n        prev = i;\n        \n    }\n    \n    \n    \n    float lines = drawLine(vec2(0.1,0.1), mouse_uv, uv); \n    //float lines = 0.0f;\n    \n    //if(distance(uv, vec2(0,0)) < 0.01f) lines = 1.0f;\n    \n    lix = lix * cos(iTime);\n    vec3 col = vec3(lix, 1.0f - lix , uv.x + 1.0f);\n    if(lix == 0.0f)\n    {\n        col = vec3(0,0,0);\n    }\n    \n    \n    \n    \n    \n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 70, 70, 213], [215, 215, 253, 253, 388], [390, 390, 420, 420, 504], [506, 506, 563, 613, 1860]], "test": "untested"}
{"id": "stsfzr", "name": "Ray cast spheres", "author": "icylavah", "description": "Just some ray casting with spheres. Probably not that physically accurate.", "tags": ["raycasting"], "likes": 7, "viewed": 276, "published": 3, "date": "1650487372", "time_retrieved": "2024-07-30T16:52:33.443359", "image_code": "#define MAX_BOUNCE_COUNT 4\n#define SAMPLE_COUNT 32\n#define SENSOR_OFFSET 0.1\n#define SENSOR_SCALE (SENSOR_OFFSET * 0.3)\n#define MAX_DISTANCE 1e12\n\n#define UP   vec3(0.0, 1.0, 0.0)\n#define ZERO vec3(0.0, 0.0, 0.0)\n#define ONE  vec3(1.0, 1.0, 1.0)\n\nfloat randomUnit(inout uint state) {\n    state = xorshift32(state);\n    return mod(float(state), 16777216.0) / 16777216.0;\n}\n\nvec3 randomvec3(inout uint state) {\n    return normalize(vec3(\n        randomUnit(state) * 2.0 - 1.0,\n        randomUnit(state) * 2.0 - 1.0,\n        randomUnit(state) * 2.0 - 1.0\n    ));\n}\n\nstruct Material {\n    vec3 reflectColor;\n    vec3 emitColor;\n    float roughness;\n    float fresnel;\n};\n\nstruct Sphere {\n    Material m;\n    vec3 p; // Position\n    float r; // Radius\n};\n\nSphere spheres[] = Sphere[](\n    Sphere(\n        Material(\n            vec3(0.2, 0.2, 0.2),\n            ZERO,\n            0.6,\n            0.5\n        ),\n        vec3(-0.2, -0.2, 0.0),\n        0.5\n    ),\n    Sphere(\n        Material(\n            vec3(0.05, 0.05, 0.05),\n            vec3(0.5, 0.1, 0.1) * 10.0,\n            0.2,\n            0.8\n        ),\n        vec3(1.5, 0.0, 1.0),\n        0.2\n    ),\n    Sphere(\n        Material(\n            vec3(0.4, 0.1, 0.1),\n            ZERO,\n            0.3,\n            0.9\n        ),\n        vec3(-1.1, -0.45, 1.5),\n        0.3\n    ),\n    \n    Sphere(\n        Material(\n            vec3(0.5, 0.5, 0.5),\n            ZERO,\n            0.8,\n            0.1\n        ),\n        vec3(1.0, -0.6, 0.5),\n        0.3\n    ),\n    \n    // Wall\n    Sphere(\n        Material(\n            vec3(0.01, 0.01, 0.01),\n            ZERO,\n            0.9,\n            0.0\n        ),\n        vec3(0.0, 0.0, -1000),\n        900.0\n    ),\n    \n    // FLOOR\n    Sphere(\n        Material(\n            vec3(0.7, 0.7, 0.7),\n            ZERO, //vec3(0.01, 0.01, 0.01),\n            0.9,\n            0.1\n        ),\n        vec3(0.0, -10001.0, 0.0),\n        10000.0\n    ),\n    \n    // SKY\n    Sphere(\n        Material(\n            ZERO, // vec3(0.5, 0.5, 0.5),\n            vec3(0.7, 0.4, 0.8) * 100000.0,\n            0.0,\n            0.0\n        ),\n        vec3(0.0, 10000000.0, 0.0),\n        9999000.0\n    )\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rngState = vec4touint(texture(iChannel0, fragCoord.xy / iResolution.xy));\n    \n    vec3 cameraP = vec3(0.0, -0.5, 5.0);\n    vec3 cameraZ = normalize(-cameraP);\n    vec3 cameraX = normalize(cross(cameraZ, UP));\n    vec3 cameraY = normalize(cross(cameraX, cameraZ));\n    \n    vec3 finalColor = ZERO;\n    \n    for(int sampleI = 0; sampleI < SAMPLE_COUNT; sampleI++) {\n        vec2 rngPix = vec2(randomUnit(rngState) - 0.5, randomUnit(rngState) - 0.5);\n        vec2 uv = (fragCoord + rngPix - iResolution.xy / 2.0) / (iResolution.y / 2.0);\n        vec3 sensorP = cameraP + cameraZ * SENSOR_OFFSET + (cameraX * uv.x + cameraY * uv.y) * SENSOR_SCALE;\n        vec3 sensorN = normalize(sensorP - cameraP);\n    \n        vec3 rayP = sensorP;\n        vec3 rayN = sensorN;\n        vec3 color = ZERO;\n        vec3 colorMute = ONE;\n        float travelDistance = 0.0;\n        for(int bounceI = 0; bounceI < MAX_BOUNCE_COUNT; bounceI++) {\n            float minDistance = MAX_DISTANCE;\n            Sphere minSphere;\n            \n            for(int i = 0; i < spheres.length(); i++) {\n                Sphere s = spheres[i];\n                float a = dot(rayN, rayN);\n                float b = 2.0 * dot(rayN, rayP - s.p);\n                float c = dot(s.p, s.p) + dot(rayP, rayP) + -2.0 * dot(s.p, rayP) - s.r * s.r;\n\n                float d = b * b - 4.0 * a * c;\n                if (d <= 0.0) continue;\n\n                float t = (-b - sqrt(d)) / (2.0 * a);\n                if (t <= 0.0) continue;\n\n                if (t < minDistance) {\n                    minDistance = t;\n                    minSphere = s;\n                }\n            }\n            if (minDistance == MAX_DISTANCE) break;\n\n            Material mat = minSphere.m;\n            vec3 p = rayP + rayN * minDistance;\n            vec3 n = (p - minSphere.p) / minSphere.r;\n            \n            travelDistance += minDistance;\n            float attenuation = 1.0 / (1.0 + 0.05 * travelDistance + 0.01 * travelDistance * travelDistance);\n            \n            float cosineLaw = dot(n, -rayN);\n            if (cosineLaw < 0.0) cosineLaw = 0.0;\n            \n            color += mat.emitColor * colorMute * attenuation * cosineLaw;\n            \n            colorMute *= mat.reflectColor * cosineLaw;\n            if (colorMute.r < 1e-6 && colorMute.g < 1e-6 && colorMute.b < 1e-6) break;\n            \n            rayP = p;\n            vec3 rvec = randomvec3(rngState);\n            if (dot(n, rvec) < 0.0) rvec = -rvec;\n            rayN = normalize(mix(reflect(rayN, n), rvec, mat.roughness * mix(1.0, cosineLaw, mat.fresnel)));\n        }\n        finalColor += color;\n    }\n    \n    fragColor = vec4(pow(finalColor / float(SAMPLE_COUNT), vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint state = vec4touint(texture(iChannel0, fragCoord.xy / iResolution.xy));\n    state ^= vec4touint(texture(iChannel1, fragCoord.xy / iResolution.xy));\n    state ^= xorshift32(state);\n    fragColor = vec4(\n        float(state & 0xffu) / 255.0,\n        float((state >> 8) & 0xffu) / 255.0,\n        float((state >> 16) & 0xffu) / 255.0,\n        float((state >> 24) & 0xffu) / 255.0\n    );\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://en.wikipedia.org/wiki/Xorshift#Example_implementation\nuint xorshift32(uint state)\n{\n\tstate ^= state << 13;\n\tstate ^= state >> 17;\n\tstate ^= state << 5;\n\treturn state;\n}\n\nuint vec4touint(vec4 v) {\n    uint i = 0u;\n    i += uint(v.x * 255.0 + 0.5);\n    i += uint(v.y * 255.0 + 0.5) << 8;\n    i += uint(v.z * 255.0 + 0.5) << 16;\n    i += uint(v.w * 255.0 + 0.5) << 24;\n    return i;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 283, 283, 371], [373, 373, 408, 408, 561], [2171, 2171, 2226, 2226, 4949]], "test": "untested"}
{"id": "ftsfzn", "name": "Simple Torus Grid", "author": "SnoopethDuckDuck", "description": "testing more effects, nothing special", "tags": ["e"], "likes": 16, "viewed": 310, "published": 3, "date": "1650469774", "time_retrieved": "2024-07-30T16:52:34.363898", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float t = 0.1 * iTime;\n    vec3 ro = vec3(2., 3. * cos(t), -3. * sin(t));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 ip = floor(p) + 0.5;\n    vec3 fp = p - ip;\n    \n    float h = h21(vec2(ip.x, h21(ip.yz)));\n   \n    float o = 2. * pi * h;\n    fp.xz*= Rot(o + 0.25 * iTime + 0.25 * pi * cc(1., o + 0.5 * iTime));\n    fp.xy*= Rot(o + 0.25 * iTime + 0.25 * pi * cc(1., o + 0.5 * iTime + 0.5 * pi) + 0.5 * pi);\n  \n    float r1 = 0.1 + 0.2 * h - 0.15 * exp(-0.5 * length(p-getRo()));\n    float r2 = min(0.1, r1);\n    float d1 = length(fp.xz) - r1;\n    float d = length(vec2(d1,fp.y)) - r2;\n   \n   // float d = mlength(fp) - 0.1 - 0.15 * h;\n    return 0.4 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    if(d<MAX_DIST) {\n\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        float fres = pow(1. + dot(rd, n), 5.);\n        fres = 1. - fres;\n        float k = 0.08;\n        fres = smoothstep(-k, k,-0.9 + fres);\n        fres = 1. - exp(-3. * fres + 1.5 * dif);\n        col = mix(col, vec3(0), fres);\n        vec3 e = vec3(0.5);\n        vec3 c = pal(n.y, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        col *= c;\n    }\n    \n    vec3 ip = floor(p) + 0.5;\n    vec3 fp = p - ip;\n    \n    float h = h21(vec2(ip.x, h21(ip.yz)));\n    \n    vec3 col2 = vec3(1);\n    float o = 2. * pi / 3.;\n    float t = iTime + h * pi * 2.;\n    vec3 a = 0.9 + 0.1 * thc(2., vec3(t-o,o,t+o));\n    //vec3(0.75,0.9,1.)\n    \n    col2 = mix(col2, a, exp(-thc(4., 0.125 * pi * h + iTime - 0.1 * p.y)));\n    \n    float m2= exp(-0.1 * dot(p, r)) * exp(-0.5 * dot(p, normalize(vec3(1,2,3))));\n    vec3 col3 = vec3(0.5 * dot(rd, n));// vec3(dot(normalize(r), normalize(p)));\n    col2 = mix(col3, col2, 1.-exp(-0.5 * length(p)));\n   // col = mix(col, vec3(0), 1.-m2);\n   // col2 *= m2;\n    \n    float m = exp(-0.2 * length(p));\n    m = clamp(m, 0., 1.);\n    col = mix(col2, col, m);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 768], [770, 770, 793, 793, 1342], [1344, 1344, 1387, 1387, 1694], [1696, 1696, 1720, 1720, 1910], [1912, 1912, 1962, 1962, 2153], [2155, 2155, 2212, 2212, 4025]], "test": "untested"}
{"id": "stffzn", "name": "Mono-Rings", "author": "hjd3481", "description": "Simple monochrome-rings effect. Similar to some of Lee Wagstaff's work and others'. Change density with NUM_RINGS. Fill screen with \"BORDER 0\". Try different videos / textures. Change contrast and lum calculation to balance image.", "tags": ["halftone", "monochrome"], "likes": 3, "viewed": 336, "published": 3, "date": "1650466267", "time_retrieved": "2024-07-30T16:52:35.116884", "image_code": "\n//Enable to show the refactored version as per the comments\n#define FabriceNeyret2 0\n\n#if !FabriceNeyret2 //////////////////////////////////////////////////////////////\n\n//My original 'long hand' version.\n\n#define BORDER 1\n#define PI \t\t3.1415926535897932384626433832795\n#define NUM_RINGS 33.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;   \n     \n    //rings \n    vec2 radialUV = (fragCoord-(0.5*iResolution.xy))/iResolution.y*2.0;\n    float d = length(radialUV);   \n    vec2 vecp = normalize(radialUV.xy);        \n    float circ = acos( vecp.y ) / PI; //0 to PI\n    \n    vec2 maskuv = vec2( abs(sin((d*NUM_RINGS*PI)-0.5)) , 0.1 );\n    float mask = maskuv.x;\n\n    //get a greyscale image from the rgb video\n    vec3 tex = texture( iChannel0, uv ).rgb;\n    float lum = 0.5*((tex.r*0.8)+(tex.g*1.2));\n    \n    //contrast / levels\n    lum = smoothstep( 0.10, 0.7, lum );\n    float threshold = mix( 0.05, 0.985, lum );\n    \n    mask = smoothstep( threshold+0.01, threshold-0.01, mask );\n    \n#if BORDER\n    mask = clamp( mask + smoothstep( 0.999, 1.0, d ), 0.0, 1.0 );\n#endif//BORDER\n    \n    //monochrome\n    vec3 col = vec3(mask);\n    \n    //pop-art 1\n    //col = mix( vec3(0.1,0.4,.8), vec3(1,.9,.5), mask );\n\n    //visualize lum\n    //col = vec3(threshold);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n#else //////////////////////////////////////////////////////////////\n\n// An amazing job by  https://www.shadertoy.com/user/FabriceNeyret2 \n// Compreses the shader into a handful of lines and adds antialiasing.\n// Not as easy to follow the process though :)\n\n#define S smoothstep\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, \n          t = texture( iChannel0, u/R ).rg;\n          \n    O = length(u+u - R)/R.yyyy;\n    \n    O = S( 1e2, -1e2, ( abs( sin( O*103.6 - .5 ) ) - .05 - .935 * S( .1, .7, t.r * .4 + t.g * .6) ) * R.y )\n      + S( 3./R.y, 0., 1.-O );\n}\n\n\n#endif //////////////////////////////////////////////////////////////", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stffzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tByDy", "name": "mackjam_af", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 4, "viewed": 318, "published": 3, "date": "1650463892", "time_retrieved": "2024-07-30T16:52:36.043407", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*75.1+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,20.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p;\n  float stpcube = PI*2./40.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(10.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  pcc.xz *= r2d(iTime);\n  pcc.yz *= r2d(.5*iTime);\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2;\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 ro = vec3(0.,-5.,-5.);\n  vec3 ta = vec3(0.,25.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  uv *= r2d(-iTime*.5);\n  uv = abs(uv);\n  uv -= vec2(.2+uv.y, 0.);\n  uv *= r2d(.1*iTime);\n  //uv = abs(uv);\n float stp = .1*length(uv);\n  uv = floor(uv/stp)*stp;\n  \n  uv -= vec2(.25);\n  //uv *= r2d(FFTI(.1)*10.);\n // uv = abs(uv);\n  \n  vec3 col = rdr(uv);\n  \n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime);\n  col = abs(col);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28782, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tByDy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "7lSyDy", "name": "mackjam_ae", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "techno", "jam", "zefrevision"], "likes": 3, "viewed": 287, "published": 3, "date": "1650463881", "time_retrieved": "2024-07-30T16:52:36.935023", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n#define iTime iTime*.5\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*.75+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./20.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,20.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p;\n  float stpcube = PI*2./40.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(10.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  pcc.xz *= r2d(iTime);\n  pcc.yz *= r2d(.5*iTime);\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 10.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2;\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 ro = vec3(0.,-5.,-5.);\n  vec3 ta = vec3(0.,25.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  float stp = .05*length(uv);\n  uv = floor(uv/stp)*stp;\n  uv *= r2d(-iTime*.5);\n  uv = abs(uv);\n  uv -= vec2(.1);\n  uv *= r2d(.1*iTime);\n  uv = abs(uv);\n    uv -= vec2(.25);\n  uv *= r2d(FFTI(.1)*10.);\n  uv = abs(uv);\n  \n  vec3 col = rdr(uv);\n  \n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n  col.xy *= r2d(iTime);\n  col = abs(col);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28781, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSyDy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "7tXBzr", "name": "Polarized Polaroids", "author": "fyisic123", "description": "Still learning with small steps at a time.  Trying out polarized UV.", "tags": ["colors", "flower", "hue", "trippy", "polar", "shimmer", "psy", "polaroid", "polarized", "himom"], "likes": 14, "viewed": 643, "published": 3, "date": "1650461522", "time_retrieved": "2024-07-30T16:52:37.782757", "image_code": "#define TAU 6.28318530718\n#define PI 3.14159265359\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n\n\n#define MORPH_SPEED 0.4\n#define SHIMMER_TWIST 4.\n#define SHIMMER_ARMS 6.\n#define SHIMMER_SCALE 0.1\n#define SHIMMER_INTENSITY 2.5\n#define SHIMMER_SPEED 0.8\n#define SHIMMER_SHARPNESS -0.5\n#define SHIMMER_HUE_SHIFT 0.05\n#define LAYER_COUNT 6.\n#define SPIRAL_ARMS 12.\n#define SPIRAL_SPEED 0.5\n#define TWIST 6.\n#define HUE_SHIFT_SPEED -0.2\n \n\nfloat XOR(float a, float b)\n{\n   return a*(1.-b) + b*(1. -a);\n}\n\n mat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y;\n    uv *= Rot(iTime *-.1);\n    \n    float angle = atan(uv.x, uv.y) / TAU +.5;\n    float dist = length(uv) ;\n    float p1 , p2 = 0.;\n    float spiralSpeed = iTime * SPIRAL_SPEED;\n    float morphPhase = abs(sin(iTime * MORPH_SPEED));\n    float armedAngle = angle * SPIRAL_ARMS;\n    float twistedDist = dist * TWIST; \n            \n    for (float i = 0.; i <1.; i += 1. / LAYER_COUNT)   // Get polaroids\n    {\n        \n        float a = fract(armedAngle + (twistedDist * i));\n        float b = min(a, 1. -a);\n        float c = fract((dist * 5.) - spiralSpeed + i);\n        float d = min(c, 1. - c);        \n        float e = b  * .5  -d * mix(1., dist, morphPhase);\n        float alpha = 0.2 + (0.8 * i);\n        p1 = max(p1 , smoothstep(0.15 , 0.16 , e) * alpha);\n        p2 = max(p2, smoothstep(0.12 , 0.14 , e) * alpha);                \n        \n    }                    \n    float p = XOR(p1, p2); // darken inner part\n                \n    // poor mans shimmer        \n    float a = fract(angle * SHIMMER_ARMS + (dist * SHIMMER_TWIST) - (iTime * SHIMMER_SPEED));\n    float b = min(a, 1. -a);\n    float shimmer = SHIMMER_INTENSITY * smoothstep(SHIMMER_SCALE, SHIMMER_SCALE * SHIMMER_SHARPNESS , b * dist ) * smoothstep(0.0, 0.2, dist);\n    p *= (1. +(shimmer * p1));\n    \n    \n    \n    \n\n    vec3 col = hue((shimmer * SHIMMER_HUE_SHIFT ) + -angle + dist +  (iTime * HUE_SHIFT_SPEED)) * p;\n    \n    \n    // Debugs\n    //col = vec3(max(max(col.r, col.g), col.b)) + angle;  // Angle\n    //col = vec3(max(max(col.r, col.g), col.b)) + dist;  // Dist\n    //col += shimmer;  // shimmer\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 495, 495, 529], [532, 532, 551, 551, 613], [617, 617, 674, 674, 2366]], "test": "untested"}
{"id": "stXBRr", "name": "Spring Mass System", "author": "lasoy", "description": "Spring Mass System test", "tags": ["physics", "spring"], "likes": 12, "viewed": 434, "published": 3, "date": "1650459126", "time_retrieved": "2024-07-30T16:52:38.568655", "image_code": "#define P_COLOR 1.0\n#define DC_COLOR 2.0\n#define AC_COLOR 3.0\n#define BOUNDS_COLOR 4.0\n\nvec2 getInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));\n    info.xy = info.xy * 2. - 1.;\n    \n    return info.xy;\n}\n\nvec2 opU( vec2 d1, float d2, float material )\n{\n    return (d1.x<d2) ? d1 : vec2(d2, material);\n}\n\nvec2 map(vec2 p){\n    vec2 d = vec2(99999.9, 0);\n    for(int i = 0;i < P_COUNT;i ++) {\n       d = opU(d, sdCircle(p - getInfo(i), R), P_COLOR);\n    }\n\n    for(int i = 0;i < DC_COUNT;i ++) {\n      int a = int(dc[i][0]);\n      int b = int(dc[i][1]);\n      d = opU(d, sdSegment(p, getInfo(a).xy,  getInfo(b).xy), DC_COLOR);\n    }\n    \n    for(int i = 0;i < AC_COUNT;i ++) {\n      AC info = ac[i];\n      d = opU(d, sdSegment(p, getInfo(info.a).xy,  getInfo(info.b).xy), AC_COLOR);\n      d = opU(d, sdSegment(p, getInfo(info.b).xy,  getInfo(info.c).xy), AC_COLOR);\n    }\n    \n    d = opU(d, sdSegment(p, vec2(-1, -1), vec2(-1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(-1, 1), vec2(1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, 1), vec2(1, -1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, -1), vec2(1, 1)), BOUNDS_COLOR);\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float w = length(fwidth(uv)) * 5.0;\n    \n    vec2 d = map(uv);\n    float c = smoothstep(0.0, w, abs(d.x));\n    vec3 col = vec3(1.0-c);\n    if (d.y == P_COLOR) {\n      col *= vec3(.3, .9, .6);\n    } else if (d.y == DC_COLOR) {\n      col *= vec3(.3, .6, .9);\n    } else if (d.y == AC_COLOR) {\n      col *= vec3(.6, .9, .3);\n    } else if (d.y == BOUNDS_COLOR) {\n      col *= vec3(.5, .5, .5);\n    }\n\n    col = mix(col, vec3(1, 1, .95), c/4.0);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.141592653589793\n#define R .04\n#define STEP 0.1\nfloat friction = 0.9;\n\nstruct AC {\n    int a;\n    int b;\n    int c;\n    float angle;\n    float stiffness;\n};\n\n#define P_COUNT 16\nconst vec2 pos[P_COUNT] = vec2[P_COUNT](\n    vec2(0.5,0.85),\n    vec2(0.6172747223702044,0.79352347027881),\n    vec2(0.6462391868272735,0.6666218599065528),\n    vec2(0.5650825608676338,0.5648546698146371),\n    vec2(0.4349174391323663,0.5648546698146371),\n    vec2(0.35376081317272645,0.6666218599065528),\n    vec2(0.3827252776297955,0.79352347027881),\n    vec2(0.2,0.9),\n    vec2(0.28,0.9),\n    vec2(0.4,0.6),\n    vec2(0.47000000000000003,0.6),\n    vec2(0.54,0.6),\n    vec2(0.6100000000000001,0.6),\n    vec2(0.68,0.6),\n    vec2(0.75,0.6),\n    vec2(0.8200000000000001,0.6)\n);\n\n#define DC_COUNT 21\nconst vec4 dc[DC_COUNT] = vec4[DC_COUNT](\n    vec4(0,1,0.1301651217352674,0.5),\n    vec4(0,2,0.23454944474040898,0.5),\n    vec4(1,2,0.13016512173526748,0.5),\n    vec4(1,3,0.23454944474040895,0.5),\n    vec4(2,3,0.1301651217352674,0.5),\n    vec4(2,4,0.23454944474040895,0.5),\n    vec4(3,4,0.13016512173526745,0.5),\n    vec4(3,5,0.23454944474040898,0.5),\n    vec4(4,5,0.13016512173526745,0.5),\n    vec4(4,6,0.23454944474040898,0.5),\n    vec4(5,6,0.13016512173526748,0.5),\n    vec4(5,0,0.23454944474040898,0.5),\n    vec4(6,0,0.13016512173526745,0.5),\n    vec4(6,1,0.2345494447404089,0.5),\n    vec4(7,8,0.08000000000000002,0.5),\n    vec4(9,10,0.07,0.5),\n    vec4(10,11,0.07,0.5),\n    vec4(11,12,0.07000000000000006,0.5),\n    vec4(12,13,0.06999999999999995,0.5),\n    vec4(13,14,0.06999999999999995,0.5),\n    vec4(14,15,0.07000000000000006,0.5)\n);\n\n#define AC_COUNT 7\nconst AC ac[AC_COUNT] = AC[AC_COUNT](\n    AC(0,1,2,2.2439947525641384,0.9),\n    AC(1,2,3,2.243994752564138,0.9),\n    AC(2,3,4,2.243994752564138,0.9),\n    AC(3,4,5,2.2439947525641384,0.9),\n    AC(4,5,6,2.243994752564138,0.9),\n    AC(5,6,0,2.243994752564138,0.9),\n    AC(6,0,1,2.2439947525641375,0.9)\n);\n\n#define PC_COUNT 3\nconst vec3 pc[PC_COUNT] = vec3[PC_COUNT](\n    vec3(7,0.2,0.9),\n    vec3(9,0.4,0.6),\n    vec3(15,0.8200000000000001,0.6)\n);\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n", "buffer_a_code": "vec4 getPInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));    \n    return info;\n}\n\nvoid bounds(inout vec4 info) {\n    float min = R/2.0;\n    float max = 1.0 - R/2.0;\n\n    if (info.x < min) {\n        info.x = min;\n    } else if (info.x > max) {\n        info.x = max;\n    }\n\n    if (info.y < min) {\n        info.y = min;\n    } else if (info.y > max) {\n        info.y = max;\n    }\n}\n\nvoid relaxDC(int index, inout vec4 color) {\n  for(int i = 0;i < DC_COUNT;i ++) {\n    vec4 info = dc[i];\n    int a = int(info[0]);\n    int b = int(info[1]);\n    float dist = info[2];\n    float stiffness = info[3];\n\n    if (a == index || b == index) {\n      vec2 d;\n      if(a == index) {\n        d = color.xy - getPInfo(b).xy;\n      } else {\n        d = getPInfo(a).xy - color.xy;\n      }\n      d = getPInfo(a).xy - getPInfo(b).xy;\n      float m = dot(d, d);\n      d *=((dist*dist - m)/m)*stiffness*0.5;\n      if (a == index) {\n        color.xy += d;\n      } else if(b == index) {\n        color.xy -= d;\n      }\n    }\n  }\n}\n\nvoid relaxPC(int index, inout vec4 color) {\n  for(int i = 0;i < PC_COUNT;i ++) {\n    vec3 info = pc[i];\n    if (int(info.x) == index) {\n      color.xy = info.yz;\n    }\n  }\n}\n\nvoid rotate(inout vec2 pos, vec2 origin, float angle) {\n  vec2 offset = pos - origin;\n  float c = cos(angle);\n  float s = sin(angle);\n  pos.x = origin.x + offset.x * c - offset.y * s;\n  pos.y = origin.y + offset.x * s + offset.y * c;\n}\n\nvoid relaxAC(int index, inout vec4 color) {\n  for(int i = 0;i < AC_COUNT;i ++) {\n    AC info = ac[i];\n    if (info.a == index || info.b == index || info.c == index) {\n      vec2 aPos;\n      vec2 bPos;\n      vec2 cPos;\n      if (info.a == index) {\n        aPos = color.xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = getPInfo(info.c).xy;\n      } else if (info.b == index) {\n        aPos = getPInfo(info.a).xy;\n        bPos = color.xy;\n        cPos = getPInfo(info.c).xy;\n      } else {\n        aPos = getPInfo(info.a).xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = color.xy;\n      }\n      vec2 l = aPos-bPos;\n      vec2 r = cPos-bPos;\n\n      float diff = atan(l.x * r.y - l.y * r.x, dot(l,r)) - info.angle;\n      \n      if (diff <= -PI)\n        diff += 2.0 * PI;\n      else if (diff >= PI)\n        diff -= 2.0 * PI;\n\n      diff *= STEP * info.stiffness;\n      rotate(aPos, bPos, diff);\n      rotate(cPos, bPos, -diff);\n      rotate(bPos, aPos, diff);\n      rotate(bPos, cPos, -diff);\n      if (info.a == index) {\n        color.xy = aPos;\n      } else if(info.b == index) {\n        color.xy = bPos;\n      } else if(info.c == index) {\n        color.xy = cPos;\n      }   \n    }\n  }\n}\n\nvoid relaxMouse(int index, inout vec4 color) {\n  if (iMouse.z > 0.) {\n    vec2 target = getPInfo(index).xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x = (mouse.x - 0.5)*iResolution.x/iResolution.y + 0.5;\n    float l = dot(mouse - target, mouse - target);\n\n    if (l < R*R) {\n      color.xy = mouse;\n    }\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord;\n    int col = int(uv.x);\n    int row = int(uv.y);\n    \n    col/=1;\n \n    if (col >= P_COUNT || row > 0) {\n        return;\n    }\n\n    vec4 color = getPInfo(col);\n    \n    if (iFrame == 0) {\n        color.xy = pos[col];\n        color.zw = color.xy;\n    } else {\n        vec2 v = color.xy - color.zw;\n        v *= friction;\n        vec2 g = vec2((sin(iTime*1.))*0.01, (cos(iTime*1.5))*0.01);\n        v += g;\n        \n        color.zw = color.xy;\n        color.xy += v;\n        \n        relaxAC(col, color);\n        relaxDC(col, color);\n        relaxMouse(col, color);\n        relaxPC(col, color);\n        bounds(color);\n    }\n    fragColor = color;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 300, 300, 350], [352, 352, 369, 369, 1217], [1219, 1219, 1276, 1276, 1825]], "test": "untested"}
{"id": "ft2cWK", "name": "FBM Caves", "author": "sdfgeoff", "description": "Fly through a cave. Probably my most intricate-looking cave yet.", "tags": ["game", "cave", "flythrough"], "likes": 2, "viewed": 146, "published": 3, "date": "1650438721", "time_retrieved": "2024-07-30T16:52:39.619845", "image_code": "/*\nI recently watched IQ's video on his landscape painting with math,\nand thought some about his tree placement method. I realized that\nif I could use those trees - along with their randomness, to revisit\nmy favourite CG theme: caves. \nAfter a bit of a walk outside and a think about how that would look\nimplementation wise, I then had a bit of a look around to see if anyone\nhad sone something similar. Of course someone has, and of course\nit's IQ, with his FBM Terrain article: https://iquilezles.org/articles/fbmsdf/\n\nSo here we are with a cave rendered using a similar method.\nThere are some cool places to explore in the cave - you can find some large\ncaverns, you can find closed in tunnels. Have a fly around with keyboard/mouse.\n\n\tControls:\n\t\tESDF \t- strafe forwards/backwares\n\t\tTG \t\t- strafe up/down\n\t\tArrows \t- Point the camera\n\t\tWR \t\t- roll the camera view\n\n\nI'd love to do some more stuff with lighting, but my laptop is melting\nalready (intel integrated graphics: 17FPS). If anyone knows any performance\ntweaks to make this run better, I'd love to see them.\n\nThis version uses only subtractive spheres. I'd be very curious to see\nwhat it would look like if the noise layers alternated add/subtract.\nI'd also be interested to try a rounded cube as a primitive.\nThe noise could be used to shuffle the bounds, rotate them and alter \nthe corner roundness etc. I think this would result in a wider\nvariety of cavern shapes.\n\n*/\n\n\n#define WORLD_TEX iChannel0\n#define BUFFER_STATE iChannel1\n#define BUFFER_HUD iChannel2\n\n// Coloration\nconst vec3 FOG_COLOR = vec3(1.0, 0.9, 0.8);\nconst vec3 SURFACE_COLOR = vec3(0.3, 0.3, 0.4);\nconst vec3 UNDERSIDE_COLOR = vec3(0.1, 0.1, 0.1);\n\n\nconst float FOG_OVERBLOOM = 1.5; // Gives the impression of light as opposed to fog.\nconst float FOG_DISTANCE = 8.0; // point at which fog completely blocks view.\n\n\n\n// Trace Parameters\nconst int MAX_STEPS = 120;\nconst float DRAW_DISTANCE = 8.0; // Note that this can be shorter than FOG_DISTANCE because of the FOG_OVERBLOOM\n\n\n/// Raymarch by the distance field each step until the step count or\n/// the maximum distance is reached.\nvec4 raymarch(vec3 start_point, vec3 direction, int steps, float max_dist) {\n    vec3 position = start_point;\n    \n    float dist = 0.0;\n    \n    int i = 0;\n    for (i=0; i<steps; i++) {\n        float df = map(position, SURFACE_MAP_NOISE_ITERATIONS);\n        \n        float threshold = 0.001 * dist;\n        float step_size = df;\n        \n        if ((df < threshold)) {\n            return vec4(position, dist / max_dist);\n        }\n        if  (dist > max_dist) {\n            return vec4(position, 1.0);\n        }\n        dist += step_size;\n        position += direction * step_size;\n    }\n    return vec4(position, dist/max_dist);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Render our geometry\n    mat4 camera_transform = quat_to_transform(\n        read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION),\n        read_data(BUFFER_STATE, ADDR_CAMERA_POSITION).xyz\n    );\n    vec3 start_point = camera_transform[3].xyz;\n    vec3 direction = normalize(vec3(uv * LENS, 1.0));\n    direction = (camera_transform * vec4(direction, 0.0)).xyz;\n    \n    vec4 data = raymarch(start_point, direction, MAX_STEPS, DRAW_DISTANCE);\n    \n    vec3 surface_normal = calc_normal(data.xyz, NORMAL_MAP_NOISE_ITERATIONS);\n    vec3 approx_normal = calc_normal(data.xyz, AO_NORMAL_ITERATIONS);\n    \n    \n    float surface_occlusion = dot(approx_normal, surface_normal);\n\n       \n    \n    \n    vec3 col = vec3(1.0);\n    \n    // Base Color\n    vec3 base_color = mix(UNDERSIDE_COLOR, SURFACE_COLOR, surface_normal.y + surface_normal.x * surface_normal.z);\n    vec4 surface_texture = texture(iChannel0, data.xz + data.y * 0.1);    \n    base_color = mix(base_color, surface_texture.rgb, 0.5);\n    \n    col = base_color;\n    \n    // Diffuse\n    float diffuse_lighting = 0.5; // The light comes from everywhere!\n    col *= diffuse_lighting;\n    \n    // AO\n    col *= vec3(surface_occlusion * 0.5 + 0.5);\n\n    // Specular\n    // Effectively we do a one-step march in the direction of reflection to figure out\n    // how open the space is. More steps would improve this, but one gives good enough results\n    float metalness = surface_texture.b * 2.0;\n    float reflection_strength = metalness + 1.0;\n    \n    vec3 reflect_direction = reflect(direction, surface_normal);\n    float SPECULAR_SAMPLE_DISTANCE = 0.5; \n    float reflect_openness = clamp(1.0 + map(data.xyz + reflect_direction * SPECULAR_SAMPLE_DISTANCE, AO_NORMAL_ITERATIONS) / SPECULAR_SAMPLE_DISTANCE, 0.0, 1.0);\n    float reflect_frenel = pow(clamp(1.0 + dot(surface_normal, direction), 0.0, 0.5) * 2.0, reflection_strength); // Clamp gets rid of fireflies\n    reflect_frenel = mix(0.5, reflect_frenel, metalness);\n    float specular = clamp(reflect_frenel * reflect_openness, 0.0, 1.0);\n    specular = specular * surface_occlusion; // Close in occlusion can also prevent reflection\n    \n    specular = pow(specular, reflection_strength) * 1.5;\n    col += specular * base_color;\n    \n    // Fog\n    float fog = pow(data.a * DRAW_DISTANCE / FOG_DISTANCE, 0.5) * FOG_OVERBLOOM;//pow(dist, 2.0);\n    col = mix(col, FOG_COLOR, fog);\n    \n    // Vignette\n    float vignette = 1.1 - dot(uv, uv) * 0.2;\n    col = mix(col, vec3(0.0), 1.0 - vignette);\n    \n    // Hud\n    vec4 hud = texture(BUFFER_HUD, raw_uv);\n    col = mix(col, col*0.3 + hud.rgb, hud.a);\n    \n    //col = vec3(metalness);\n        \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// STATE: manages moving the camera\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_KEYBOARD iChannel1\n\n\n// const vec3 START_POSITION = vec3(4.096, 11.424, 3.139);\n// const vec4 START_QUATERNION = vec4(0.033, 0.762, 0.289, -0.577);\n\nconst vec3 START_POSITION = vec3(6.807, -16.891, 5.612);\nconst vec4 START_QUATERNION = vec4(-0.117, -0.391, 0.486, -0.771);\n\nconst vec2 MOUSE_SENSITIVITY = vec2(-0.2, 0.2);\n\n// Flight dynamics\nconst float LIN_ACCELERATION = 5.0;\nconst float LIN_DRAG = 5.0;\nconst float ANG_ACCELERATION = 10.0;\nconst float ANG_DRAG = 10.0;\n\n\n// What keys to use for controls\nconst int KEY_LEFT = 83;\nconst int KEY_UP   = 84;\nconst int KEY_RIGHT = 70;\nconst int KEY_DOWN = 71;\nconst int KEY_FORWARD = 69;\nconst int KEY_BACKWARD = 68;\n\nconst int KEY_TILT_UP = 38;\nconst int KEY_TILT_DOWN = 40;\nconst int KEY_PAN_LEFT = 37;\nconst int KEY_PAN_RIGHT = 39;\nconst int KEY_ROLL_LEFT = 87;\nconst int KEY_ROLL_RIGHT = 82;\n\n\n// Return the state of a key\nfloat get_key(int key_code) {\n    return texelFetch(BUFFER_KEYBOARD, ivec2(key_code,0), 0).x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 address = ivec2(fragCoord);\n    \n    if (address == ADDR_CAMERA_POSITION) {\n        // Move the camera based on keypress\n    \tvec4 camera_position = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n        \n        if (iTime < 0.1) {\n            camera_position = vec4(START_POSITION, 0.0);\n        }\n        \n        float distance_field = physics_sdf(camera_position.xyz);\n        float penetration_distance = -(distance_field - PHYSICS_RADIUS);\n        \n        if (penetration_distance > 0.0) {\n            vec3 normal = physics_normal(camera_position.xyz);\n            camera_position.xyz += normal * penetration_distance;\n        }\n        \n        \n        vec3 translation = read_data(BUFFER_STATE, ADDR_CAMERA_LIN_VELOCITY).xyz;\n        \n        // Convert to local coordinate system\n        mat4 orientation = quat_to_transform(\n            read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION),\n            vec3(0.0)\n        );\n        translation = (orientation * vec4(translation, 0.0)).xyz;\n        translation *= iTimeDelta;\n        \n        camera_position.xyz += translation;\n        fragColor = camera_position;\n        return;\n    }\n    \n    \n    if (address == ADDR_CAMERA_ORIENTATION) {\n        // Rotate the camera based on keypress\n        vec4 camera_orientation = read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION);\n        \n        if (iTime < 0.1) {\n            camera_orientation = START_QUATERNION;\n        }\n        \n        vec4 velocity = read_data(BUFFER_STATE, ADDR_CAMERA_ANG_VELOCITY);\n        velocity *= iTimeDelta;\n        \n        \n        \n        vec4 pan = quat_from_axis_angle(vec3(0.0, 1.0, 0.0), velocity.x);\n        vec4 tilt = quat_from_axis_angle(vec3(1.0, 0.0, 0.0), velocity.y);\n        vec4 roll = quat_from_axis_angle(vec3(0.0, 0.0, 1.0), velocity.z);\n        \n        \n        camera_orientation = quat_mul(pan, camera_orientation); \n        camera_orientation = quat_mul(tilt, camera_orientation); \n        camera_orientation = quat_mul(roll, camera_orientation); \n        \n        fragColor = camera_orientation;\n        return;\n    }\n    if (address == ADDR_CAMERA_ANG_VELOCITY) {\n        vec4 velocity = read_data(BUFFER_STATE, ADDR_CAMERA_ANG_VELOCITY);\n        vec4 mouse_delta_data = read_data(BUFFER_STATE, ADDR_MOUSE_DELTA_STATE);\n        vec2 mouse_delta = iMouse.xy - mouse_delta_data.xy;\n        \n        vec3 acceleration = vec3(\n            get_key(KEY_PAN_LEFT) - get_key(KEY_PAN_RIGHT),\n            get_key(KEY_TILT_UP) - get_key(KEY_TILT_DOWN),\n            get_key(KEY_ROLL_RIGHT) - get_key(KEY_ROLL_LEFT)\n        );\n        if (mouse_delta_data.z > 0.0) {\n            acceleration.xy += mouse_delta * MOUSE_SENSITIVITY;\n        }\n        acceleration *= ANG_ACCELERATION;\n        velocity.xyz += acceleration * iTimeDelta;\n        \n        vec4 drag = velocity * ANG_DRAG;\n        velocity -= drag * iTimeDelta;\n        \n        fragColor = velocity;\n        return;\n    }\n    if (address == ADDR_CAMERA_LIN_VELOCITY) {\n        vec4 velocity = read_data(BUFFER_STATE, ADDR_CAMERA_LIN_VELOCITY);\n        \n        vec3 acceleration = vec3(\n            get_key(KEY_RIGHT) - get_key(KEY_LEFT),\n            get_key(KEY_UP) - get_key(KEY_DOWN),\n            get_key(KEY_FORWARD) - get_key(KEY_BACKWARD)\n        ) * LIN_ACCELERATION;\n        velocity.xyz += acceleration * iTimeDelta;\n        \n        vec4 drag = velocity * LIN_DRAG;\n        velocity -= drag * iTimeDelta;\n        \n        fragColor = velocity;\n        return;\n    }\n    if (address == ADDR_MOUSE_DELTA_STATE) {\n        fragColor = iMouse;\n    }\n}\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const ivec2 ADDR_CAMERA_POSITION = ivec2(0,0);\nconst ivec2 ADDR_CAMERA_ORIENTATION = ivec2(0,1);\nconst ivec2 ADDR_CAMERA_ANG_VELOCITY = ivec2(0,2);\nconst ivec2 ADDR_CAMERA_LIN_VELOCITY = ivec2(0,3);\nconst ivec2 ADDR_MOUSE_DELTA_STATE = ivec2(0,4);\n\nconst float LENS = 0.5;\nconst float PHYSICS_RADIUS = 0.05;\n\nconst int PHYSICS_MAP_NOISE_ITERATIONS = 2;\nconst int PHYSICS_NORMAL_NOISE_ITERATIONS = 2;\n\nconst int SURFACE_MAP_NOISE_ITERATIONS = 4;\nconst int NORMAL_MAP_NOISE_ITERATIONS = 5;\nconst int AO_NORMAL_ITERATIONS = 1;\n\n\n// --------------------- EXTERNAL FUNCTIONS --------------------------\n\n// 1 out, 3 in...\n// Taken from https://www.shadertoy.com/view/4djSRW\n// Used under MIT\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat baseShape(vec3 viewpoint, vec3 shapeCenter, float scale) {\n    return scale * 1.0 - length(viewpoint - shapeCenter);\n}\n\n\nfloat randBaseShape(vec3 viewpoint, float density, ivec3 shapeCenter) {\n    vec3 center = vec3(shapeCenter);\n    return baseShape(viewpoint, center, hash13(center * 1000.0) * density);\n}\n\n\nfloat ma(float a, float b) {\n    return smax(a, b, 0.1);\n}\n\n\nfloat mi(float a, float b) {\n    return smin(a, b, 0.1);\n    //return min(a, b);\n}\n\n\nfloat layer(vec3 viewpoint, float density) {\n\n    ivec3 center = ivec3(floor(viewpoint));\n    return ma(ma(ma(randBaseShape(viewpoint,density,center+ivec3(0,0,0)),\n                       randBaseShape(viewpoint,density,center+ivec3(0,0,1))),\n                   ma(randBaseShape(viewpoint,density,center+ivec3(0,1,0)),\n                       randBaseShape(viewpoint,density,center+ivec3(0,1,1)))),\n               ma(ma(randBaseShape(viewpoint,density,center+ivec3(1,0,0)),\n                       randBaseShape(viewpoint,density,center+ivec3(1,0,1))),\n                   ma(randBaseShape(viewpoint,density,center+ivec3(1,1,0)),\n                       randBaseShape(viewpoint,density,center+ivec3(1,1,1)))));\n}\n\n\n\n\n\n\nfloat map(vec3 viewpoint, int iter) {\n\n    mat4 m = mat4(\n\t\tvec4(0.6373087, -0.0796581,  0.7664804, 0.0),\n  \t\tvec4(0.2670984,  0.9558195, -0.1227499, 0.0),\n  \t\tvec4(-0.7228389,  0.2829553,  0.6304286, 0.0),\n        vec4(0.3, 0.2, 0.2, 0.0)\n    );\n    \n    float sdf = layer(viewpoint, 0.8);\n    float scale = 1.0;\n\n    for (int i=0; i< iter; i++) {\n        viewpoint = (m * vec4(viewpoint, 1.0)).xyz;\n        scale *= 3.142;\n        \n        float carve_depth = 0.1 / scale;\n        float blend_radius = 0.1 / scale;\n        \n        // Because we are always doing a max to join our new sdf, we\n        // know that the sdf will only ever get larger by increasing iterations.\n        // We also know that it will only ever increase in distance by maxval\n        // so if our current distance to the surface is >> carve_depth, then theres\n        // no point doing more iterations\n        // This gives ~10fps on my machine.\n        if (sdf > carve_depth * 2.0) {\n            break;\n        }\n        \n        float maxval = sdf + carve_depth;\n        float new_sdf = layer(viewpoint * scale, 0.8) / scale;\n        new_sdf = smin(maxval, new_sdf, blend_radius);\n        sdf = smax(sdf, new_sdf, blend_radius);\n        \n        \n        \n    }\n    return sdf;\n}\n\n\nconst float NORMAL_SAMPLE_SIZE = 0.0005;\n\nvec3 calc_normal(vec3 sample_point, int iter) {\n    const float h = NORMAL_SAMPLE_SIZE; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    \n    vec3 normal = normalize(\n\t\tk.xyy * map( sample_point + k.xyy*h, iter ) + \n\t\tk.yyx * map( sample_point + k.yyx*h, iter ) + \n\t\tk.yxy * map( sample_point + k.yxy*h, iter ) + \n\t\tk.xxx * map( sample_point + k.xxx*h, iter ) );\n    normal = normal.xyz;\n    return normal;\n}\n\n\nfloat physics_sdf(vec3 position) {\n    return map(position, PHYSICS_MAP_NOISE_ITERATIONS);\n}\n\nvec3 physics_normal(vec3 position) {\n    return calc_normal(position, PHYSICS_NORMAL_NOISE_ITERATIONS);\n}\n\n\n\n// Fetch a single pixe from a buffer\nvec4 read_data(sampler2D buffer, ivec2 address){\n    return texelFetch(buffer, address, 0);\n}\n\n\n// Create a quaternion from axis-angle notation\nvec4 quat_from_axis_angle(vec3 axis, float angle) {\n    float factor = sin(angle) / 2.0;\n    float w = cos(angle) / 2.0;\n    return normalize(vec4(axis*factor, w));\n}\n\n// Convert a quaternion into a transformation matrix\nmat4 quat_to_transform(vec4 quat, vec3 translation) {\n    vec4 q = quat;\n    vec4 q2 = quat * quat;\n    \n \treturn mat4(\n        1.0 - 2.0*(q2.y + q2.z), 2.0*(q.x*q.y - q.z*q.w), 2.0*(q.x*q.z + q.y*q.w), 0.0,\n    \t2.0*(q.x*q.y + q.z*q.w), 1.0 - 2.0*(q2.x + q2.z), 2.0*(q.y*q.z - q.x*q.w), 0.0,\n    \t2.0*(q.x*q.z - q.y*q.w), 2.0*(q.y*q.z + q.x*q.w),1.0 - 2.0*(q2.x + q2.y), 0.0,\n        translation, 0.0\n    );\n}\n\n// Multiply two quaternions\nvec4 quat_mul(vec4 a, vec4 b) {\n \treturn vec4(\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,\n        a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,\n        a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,\n        a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z\n    );   \n}", "buffer_b_code": "// HUD: Draws the heads up display\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_FONT iChannel1\n\nconst vec3 HUD_COLOR = vec3(0.0, 0.8, 1.0);\nconst float HUD_LINE_SIZE = 0.005;\nconst float HUD_BORDER_OFFSET = 0.08;\n\n\nvec4 hud(vec2 uv) {\n    vec4 cam_ang_velocity = read_data(BUFFER_STATE, ADDR_CAMERA_ANG_VELOCITY);\n\n    float aspect = iResolution.x / iResolution.y;\n    float borders = step(0.0, HUD_LINE_SIZE - abs((aspect - HUD_BORDER_OFFSET) - abs(uv.x)));\n    borders += step(0.0, HUD_LINE_SIZE - abs(1.0 - HUD_BORDER_OFFSET - abs(uv.y)));\n    \n    float reticle = step(abs(0.03 - length(uv + cam_ang_velocity.xy * vec2(0.2, -0.2))), HUD_LINE_SIZE);\n    \n    float hud = borders + reticle;\n    \n    hud = clamp(hud, 0.0, 0.5);\n    \n    return vec4(HUD_COLOR,hud);\n}\n\n\n\nvec4 sampleIntChar(int number, vec2 coords) {\n    return texture(BUFFER_FONT, (coords + vec2(float(number), -4.0)) / 16.0);\n}\n\n\nfloat drawInt(int number, vec2 coords, int digits) {\n    vec2 arr = coords * vec2(digits, 1.0);\n    int digitId = digits - int(ceil(arr.x));\n    float digitBase = (pow(10.0, float(digitId)));\n    number = int(floor(float(number) / digitBase)) % 10;\n    \n    float sdf = sampleIntChar(number, fract(arr)).x;\n    float edge = smoothstep(0.1, 0.9, sdf);\n    \n    return sdf;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 uv = raw_uv;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    fragColor = hud(uv);\n    \n    if (uv.y < -1.0 + HUD_BORDER_OFFSET) {\n        // There is almost certainly a more effecient way to do this\n        vec2 textuv = raw_uv * vec2(1.0/4.2, 1.0) / HUD_BORDER_OFFSET * 2.0;\n        float texBuff = 0.0;\n        vec4 camera_position = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n        textuv.x -= HUD_BORDER_OFFSET * 3.0;\n        texBuff += drawInt(int(abs(camera_position.x * 1000.0)), clamp(textuv, 0.0, 1.0), 7); \n        textuv.x -= HUD_BORDER_OFFSET * 15.0;\n        \n        texBuff += drawInt(int(abs(camera_position.y * 1000.0)), clamp(textuv, 0.0, 1.0), 7); \n        textuv.x -= HUD_BORDER_OFFSET * 15.0;\n        \n        texBuff += drawInt(int(abs(camera_position.z * 1000.0)), clamp(textuv, 0.0, 1.0), 7); \n        textuv.x -= HUD_BORDER_OFFSET * 15.0;\n        \n        fragColor = mix(fragColor, texBuff * vec4(0.0, 0.8, 1.0, 1.0), texBuff);\n    }\n}", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2cWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2013, 2119, 2195, 2195, 2753], [2758, 2758, 2815, 2865, 5714]], "test": "untested"}
{"id": "Nt2cDd", "name": "noise box", "author": "jorge2017a2", "description": "noise box", "tags": ["2d", "noise", "box", "noisebox"], "likes": 2, "viewed": 194, "published": 3, "date": "1650418376", "time_retrieved": "2024-07-30T16:52:40.385797", "image_code": "//por jorge2017a2\n//19-abril-2020\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n// http://patriciogonzalezvivo.com\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 HacerVariosCuadros(vec2 uv, int xmax, int ymax, vec3 colOut)\n{  vec2 res=vec2(9999.9,-1.0); \n   vec2 pos;\n   \n   for(int j=0;j<ymax;j++)\n   for(int i=0;i<xmax;i++) \n   {\n        pos=vec2(0.0+float(i)*2.0,float(j)*2.0);\n        float d1= sdBox(uv-pos, vec2(1.0,1.0));   \n         res=opU2(res, vec2(d1,i+1+j));\n   }\n   vec3 colI= getColor(int( res.y));\n   vec3 col= DrawFigBorde(colI, colOut,res.x );\n   return col;\n}\n\nvec3 HacerVariosCuadrosv0(vec2 uv, int xmax, int ymax, vec3 colOut)\n{  float res=9999.9; \n   vec2 pos;\n   \n   for(int i=0;i<xmax;i++) \n   {    pos=vec2(0.0+float(i)*2.0,0.0);\n        float d1= sdBox(uv-pos, vec2(1.0,1.0));   \n        res=unionSDF(res, d1);\n   }\n   vec3 col= DrawFigBorde(vec3(0.0), colOut,res );\n   return col;\n}\n\nvec3 HacerCuadro(vec2 uv, vec2 pos, vec3 colOut)\n{   float d1= sdBox(uv-pos, vec2(1.0,1.0));\n    vec3 col= DrawFigBorde(vec3(0.5), colOut,d1 );\n    return col;\n}\n\nvec3 HacerCuadroCol(vec2 uv, vec2 pos, vec3 colIn,  vec3 colOut)\n{   float d1= sdBox(uv-pos, vec2(1.0,1.0));\n    vec3 col= DrawFigBorde(colIn, colOut,d1 );\n    return col;\n}\n\n\nvec3 HacerCuadroRnd(vec2 uv,vec3 colOut)\n{   vec2 pos;\n    uv=floor(uv/2.0+vec2(iTime));\n    float pnx= noise(uv+iTime)*5.0;\n    float pny= noise(uv+iTime)*4.0;\n    uv=vec2(floor(pnx), (pny));\n    vec3 col= HacerCuadro(uv,vec2(0.0),colOut);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(1.5,0.05);\n    float esc=10.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(0.8);\n    uv0.x+=10.0;\n    uv0.y+=2.0;\n    col=HacerCuadroCol(uv0, vec2(0.0,2.0),vec3(0.2), col);\n    col=HacerCuadroCol(uv0, vec2(2.0,2.0),vec3(0.3),col);\n    col=HacerCuadroCol(uv0, vec2(4.0,2.0),vec3(0.4),col);\n    col=HacerCuadroCol(uv0, vec2(6.0,2.0),vec3(0.5),col);\n    col=HacerCuadroCol(uv0, vec2(8.0,2.0),vec3(0.6),col);\n    \n    col= HacerVariosCuadros(uv-vec2(-10.0,2.0), 5, 4, col);\n    col= HacerCuadroRnd(uv,col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "vec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i]; }\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2cDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 384, 384, 458], [550, 550, 597, 597, 624], [625, 625, 668, 668, 695], [696, 696, 744, 744, 772], [778, 778, 840, 840, 970], [972, 972, 1053, 1053, 1181], [1183, 1183, 1250, 1250, 1604], [1606, 1606, 1675, 1675, 1935], [1937, 1937, 1987, 1987, 2098], [2100, 2100, 2166, 2166, 2273], [2276, 2276, 2318, 2318, 2534], [2536, 2536, 2593, 2593, 3268]], "test": "untested"}
{"id": "ft2cDd", "name": "basic math graph", "author": "jorge2017a2", "description": "basic math graph", "tags": ["2d", "math", "graph", "formula", "basicmathgraph"], "likes": 4, "viewed": 332, "published": 3, "date": "1650417500", "time_retrieved": "2024-07-30T16:52:41.211589", "image_code": "//por jorge2017a2\n//19-abril-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n//https://graphtoy.com/\n// http://patriciogonzalezvivo.com\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec3 GraficarPlot(vec2 p, vec3 colOut)\n{   float t=iTime*5.0;\n    float x=p.x;\n    \n    float fx1=4. + 4.*smoothstep(0.0,0.7,sin(x+t));\n    float y1=p.y+fx1;\n    float y2=p.y+fx1+0.2;\n    float yg0= differenceSDF(y1,y2);\n    float fxy1=yg0;\n    \n    float fx2=3.0*sin(x)/x;\n    y1=p.y+fx2;\n    y2=p.y+fx2+0.2;\n    float yg1= differenceSDF(y1,y2);\n    \n    float fx3= 2.0*noise(vec2(3.*x+t,1.0))+fx2;\n    y1=p.y+fx3;\n    y2=p.y+fx3+0.2;\n    float yg2= differenceSDF(y1,y2);\n    \n    float fx5= (t + floor(x-t))/2. - 5.0;\n    float fx6= sin(fx5) - 5.;\n    y1=p.y+fx6;\n    y2=p.y+fx6+0.2;\n    float yg6= differenceSDF(y1,y2);\n    \n    //linea horizontal\n    float fx7=2.0;\n    y1=p.y+fx7;\n    y2=p.y+fx7+0.1;\n    float yg7= differenceSDF(y1,y2);\n    \n    //linea vertical\n    float fx8=0.0;\n    y1=p.x+fx8;\n    y2=p.x+fx8+0.1;\n    float yg8= differenceSDF(y1,y2);\n    \n   \n    vec3 col;\n    col=colOut;\n    col= DrawFigBorde(vec3(0.0), col, yg7); //linea hor\n    col= DrawFigBorde(vec3(0.0), col, yg8); //linea vert\n    \n    col= DrawFigBorde(vec3(0.2,0.2,1.0), col, yg0);\n    col= DrawFigBorde(vec3(0.7,0.1,0.2), col, yg1); //cafe\n    col= DrawFigBorde(vec3(0.5,0.9,0.2), col, yg2);\n    col= DrawFigBorde(vec3(0.5,0.9,0.2), col, yg6);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n    col= GraficarPlot(uv-vec2(0.0,6.0), col)    ;\n    \n  \n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2cDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 375, 411, 411, 456], [462, 462, 509, 509, 536], [537, 537, 580, 580, 607], [608, 608, 656, 656, 684], [688, 688, 750, 750, 880], [883, 883, 923, 923, 2138], [2141, 2141, 2198, 2198, 2520]], "test": "untested"}
{"id": "fljcDd", "name": "test noise n1", "author": "jorge2017a2", "description": "test noise n1", "tags": ["2d", "noise", "testnoisen1"], "likes": 4, "viewed": 179, "published": 3, "date": "1650417154", "time_retrieved": "2024-07-30T16:52:42.043365", "image_code": "//por jorge2017a2\n//---19-abril-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n// http://patriciogonzalezvivo.com\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\n\nvec3 HacerVariosCuadros(vec2 uv, int xmax, int ymax, vec3 colOut)\n{\n   vec2 res=vec2(9999.9,-1.0); \n   vec2 pos;\n   \n   for(int j=0;j<ymax;j++)\n   for(int i=0;i<xmax;i++) \n   {\n        pos=vec2(0.0+float(i)*2.0,float(j)*2.0);\n        float d1= sdBox(uv-pos, vec2(1.0,1.0));   \n         res=opU2(res, vec2(d1,i+1+j));\n   }\n   vec3 colI= getColor(int( res.y));\n   vec3 col= DrawFigBorde(colI, colOut,res.x );\n   return col;\n}\n\n\nvec3 HacerCuadro(vec2 uv, vec2 pos, vec3 colOut)\n{   float d1= sdBox(uv-pos, vec2(1.0,1.0));\n    vec3 col= DrawFigBorde(vec3(0.5), colOut,d1 );\n    return col;\n}\n\n\nvec3 HacerCuadroCol(vec2 uv, vec2 pos, vec3 colIn,  vec3 colOut)\n{\n    float d1= sdBox(uv-pos, vec2(1.0,1.0));\n    vec3 col= DrawFigBorde(colIn, colOut,d1 );\n    return col;\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 HacerCuadroRnd(vec2 uv,vec3 colOut,vec2 fc)\n{ vec2 pos;\n    float pnx= noise(uv+iTime)*5.0;\n    float pny= noise(uv+iTime)*4.0;\n    uv=vec2(floor(pnx), (pny));\n    vec3 col= HacerCuadro(uv,vec2(0.0),colOut);\n    return col;\n}\n\nvec3 HacerCuadroRndv2(vec2 uv,vec3 colOut)\n{   vec2 pos;\n    float pnx= noise(uv-iTime)*5.0;\n    float pny= noise(uv-iTime)*4.0;\n    uv=vec2(floor(pnx), (pny));\n    vec3 col= HacerCuadroCol(uv, vec2(0.0), vec3(0.5,0.0,1.0), colOut);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv-=vec2(1.5,0.05);\n    float esc=10.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(0.8);\n    uv0.x+=10.0;\n    uv0.y+=2.0;\n    \n    col=HacerCuadroCol(uv0, vec2(0.0,2.0),vec3(0.2), col);\n    col=HacerCuadroCol(uv0, vec2(2.0,2.0),vec3(0.3),col);\n    col=HacerCuadroCol(uv0, vec2(4.0,2.0),vec3(0.4),col);\n    col=HacerCuadroCol(uv0, vec2(6.0,2.0),vec3(0.5),col);\n    col=HacerCuadroCol(uv0, vec2(8.0,2.0),vec3(0.6),col);\n    \n    col= HacerVariosCuadros(uv-vec2(-10.0,2.0), 5, 4, col);\n    col= HacerCuadroRnd(uv,col,fragCoord);\n    col= HacerCuadroRndv2(uv-vec2(2.0,2.0),col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "vec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}\n\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 391, 427, 427, 472], [478, 478, 525, 525, 552], [553, 553, 596, 596, 623], [624, 624, 672, 672, 700], [702, 702, 764, 764, 894], [896, 896, 977, 977, 1105], [1108, 1108, 1145, 1145, 1219], [1223, 1223, 1290, 1290, 1646], [1649, 1649, 1699, 1699, 1810], [1813, 1813, 1879, 1879, 1988], [1990, 1990, 2010, 2010, 2085], [2087, 2087, 2137, 2137, 2317], [2319, 2319, 2363, 2363, 2569], [2573, 2573, 2630, 2630, 3378]], "test": "untested"}
{"id": "fl2cDt", "name": "reflecty pistons", "author": "SnoopethDuckDuck", "description": "wasnt super proud of this when i made it sos didnt upload - fog looks quite nice though", "tags": ["e"], "likes": 3, "viewed": 147, "published": 3, "date": "1650408955", "time_retrieved": "2024-07-30T16:52:42.794357", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p.xz = abs(p.xz)-s.xz;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    vec2 ipos = floor(p.xz) + 0.5;\n    vec2 fpos = p.xz - ipos;\n   \n    float m = -cc(2., ipos.x + h21(ipos) * pi + iTime);\n    p.y += 0.5 * m;\n    p.y += 0.1 * length(p.xz);\n   \n    float d = sdBox(vec3(fpos.x,p.y,fpos.y), vec3(0.1)) \n            - 0.3 - 0.1 * m;\n    return 0.6 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        vec3 c1 = texture(iChannel0, 0.5 + 0.5 * p.xy).rgb;\n        vec3 c2 = texture(iChannel0, 0.5 + 0.5 * p.yz).rgb;\n        vec3 c3 = texture(iChannel0, 0.5 + 0.5 * p.zx).rgb;\n        vec3 n2 = abs(n);\n        r = abs(0.5 + 0.5 * r);\n        vec3 c = r.z * c1 + r.x * c2 + r.y * c3;\n        \n        \n        \n        float fres = 1.-pow(1. + dot(rd, n), 1. + 5. * dIn);\n        vec3 e = vec3(0.5);\n        vec3 col2 = pal(-0.33, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        \n        col *= c;\n        \n        col = mix(col2, col, fres);\n        \n        \n    }\n    vec3 e = vec3(0.5);\n    vec3 col2 = pal(-0.33, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    col = mix(col2, col, exp(-0.1 * length(p.xz)));\n    col = mix(col2, col, clamp(p.y + 1.5 + cos(0.2 * p.z + iTime), 0., 1.));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2cDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 559], [561, 561, 575, 575, 725], [727, 727, 750, 750, 1037], [1039, 1039, 1082, 1082, 1389], [1391, 1391, 1415, 1415, 1605], [1607, 1607, 1657, 1657, 1848], [1850, 1850, 1907, 1907, 3440]], "test": "untested"}
{"id": "NtjyDt", "name": "First sound with sync", "author": "curiouspers", "description": "First attempt at making sound with sync\nThanks to this tutorial https://youtu.be/CqDrw0l0tas", "tags": ["sound"], "likes": 2, "viewed": 225, "published": 3, "date": "1650403248", "time_retrieved": "2024-07-30T16:52:43.664032", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    int samp;\n    mainSound(samp, iTime); \n\n    float d= 1.-length(uv)*2.;\n    float v = 1.-VISUALIZATION_PX.w+0.3;\n    float d1 = smoothstep(0.3,0.31,d*(v/1.3))-0.0;\n    d1 += smoothstep(0.2,0.31,d*(v/1.3))-0.0;\n    vec3 col = vec3(1.-d*v+d1)*vec3(0.580,0.580,0.580);\n    mainSound( samp,iTime); \n    fragColor = VISUALIZATION_PX;//vec4(col,1.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define THICK_BASS 1\nvec4 VISUALIZATION_PX = vec4(0.0);\n    \n#define Tau (2.*3.1415926)\n\n#define FM(fc, fm, iom) sin(Tau*fract((fc)*t) + (iom)*sin(Tau*fract((fm)*t)))\n\nvec2 mainSound( int samp, float t )\n{\n    vec2 sig = vec2(0);\n    \n    t = t*1.0;\n    t = mod(t, Tau*32.);\n    sig += FM(20., 2., 5.0); // thick bass\n    //sig += FM(20., 5., 5.0) * smoothstep(0.,8.0,t); // thicker bass\n    sig += FM(20., 1., 5.0); \n    sig = mix(sig, sig+FM(21., 1., 5.0*fract(t/8.)), smoothstep(0.66,1.,fract(t/1.))); \n    sig = mix(sig, sig+FM(21., 1., 10.0*fract(t/2.)), smoothstep(0.75,1.,fract(t/2.)));\n    sig = mix(sig, sig+FM(21., 1., 10.0*fract(t/16.)), smoothstep(0.75,1.,fract(t/4.)));\n     \n    // Set our pixel value to be accessible from outside\n    vec2 col = clamp(smoothstep(0.9,0.91,abs(sig/1.)),0.,1.);\n    VISUALIZATION_PX = vec4(col.x,col.y,col.x,(fract(t/1.)+fract(t/2.)+fract(t/4.)+col.x)/4.);\n    return sig*1.;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 502]], "test": "untested"}
{"id": "7tByW3", "name": "Landscape Attempt #8394872983", "author": "cra_manning_w", "description": "Practice, based on IQ's recent video about their terrain with trees. Tried to keep my code really organized and well-commented (locally I have it as a series of files, using VSCode's \"shadertoy\" plugin). Lots of half-implemented stuff in here.", "tags": ["raymarch", "landscape"], "likes": 3, "viewed": 179, "published": 3, "date": "1650398096", "time_retrieved": "2024-07-30T16:52:44.663360", "image_code": "\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n//Animate a property over time; useful for visualizing different settings.\n#define TIME_LERP(a, b, speed) mix(a, b, 0.5 + (0.5 * sin(iTime * speed)))\n\n\n////////////////////////\n//    Vector Math     //\n////////////////////////\n\n//Note: using Y-up,  Z-forward, X-right (left-handed).\n\nstruct Basis\n{\n    vec3 forward, right, up;\n};\n\n//Makes a vector-basis, given a Z direction and the world \"up\" axis.\nBasis makeBasis(vec3 forward)\n{\n    vec3 right = cross(vec3(0, 1, 0), forward);\n    vec3 up = cross(forward, right);\n    return Basis(forward, right, up);\n}\n\n\n///////////////////////\n//    Randomness     //\n///////////////////////\n\n// A modified version of this: https://www.shadertoy.com/view/4djSRW\n\n//Hash 1D from 1D-3D data\nfloat hashTo1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hashTo1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hashTo1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Hash 2D from 1D-3D data\nvec2 hashTo2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Hash 3D from 1D-3D data\nvec3 hashTo3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hashTo3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hashTo3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//Hash 4D from 1D-4D data\nvec4 hashTo4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\nvec4 hashTo4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\nvec4 hashTo4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hashTo4(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n////////////////////////////\n//   Terrain Parameters   //\n////////////////////////////\n\n//Attempt to make the scale of the terrain similar to real terrains,\n//    so that we can treat units like meters.\n#define TERR_SCALE 1.0/2000.0\n#define TERR_HEIGHT 1800.0\n\n//An exponent that reduces the grassiness of the surface.\n#define TERR_GRASS_THRESHOLD 13.0\n\n#define TERR_NOISE_SEED 1.7253789\n\n//This originally started as an attempt at making a cliff, like in IQ's video.\n//What I ended up making was a pair of plateaus at two different heights.\n//The second value must be larger than the first.\n#define TERR_PLATEAU_A (590.0 / TERR_HEIGHT) /* The magic number is in meters */\n#define TERR_PLATEAU_B (725.0 / TERR_HEIGHT)\n\n//The change from one noise octave to the next. Sometimes called \"persistence\".\n#define OCTAVE_SCALING 2.0\n\n\n//////////////////////////////////////////\n//   Terrain Noise Octave definitions   //\n//////////////////////////////////////////\n\n//The terrain uses octave noise.\nstruct NoiseOctave\n{\n    //Scales and rotates the input position before plugging it into the noise function.\n    //Scaling is a core part of octave noise.\n    //Rotation helps eliminate axis-aligned bias.\n    mat2 transform;\n\n    //The importance of this octave. Should change inversely with the octave's scale.\n    float weight;\n};\n\n#define OCTAVE_SCALE(i) (pow(OCTAVE_SCALING, float(i)))\n#define OCTAVE_WEIGHT(i) (pow(1.0/OCTAVE_SCALING, float(i)))\n\n//Each octave needs to be scaled, and should also be rotated.\n//2D rotation matrices can be made easily with pythagorean triples;\n//    here we use (5, 12, 13).\n#define OCTAVE_MAT (                                 \\\n    /* Rotation matrix: */                           \\\n    mat2(12.0/13.0, 5.0/13.0,                        \\\n         -5.0/13.0, 12.0/13.0) *                     \\\n    /* Scale matrix: */                              \\\n    mat2(OCTAVE_SCALING, 0.0, 0.0, OCTAVE_SCALING)   \\\n)\n#define OCTAVE_MAT2 (OCTAVE_MAT * OCTAVE_MAT)\n#define OCTAVE_MAT4 (OCTAVE_MAT2 * OCTAVE_MAT2)\n#define OCTAVE_MAT8 (OCTAVE_MAT4 * OCTAVE_MAT4)\n\n\n#define N_OCTAVES 14\nconst NoiseOctave OCTAVES[N_OCTAVES] = NoiseOctave[N_OCTAVES](\n    NoiseOctave(mat2(1.0, 0.0, 0.0, 1.0), OCTAVE_WEIGHT(0)),\n    NoiseOctave(OCTAVE_MAT,\n                OCTAVE_WEIGHT(1)),\n    NoiseOctave(OCTAVE_MAT2,\n                OCTAVE_WEIGHT(2)),\n    NoiseOctave(OCTAVE_MAT2 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(3)),\n    NoiseOctave(OCTAVE_MAT4,\n                OCTAVE_WEIGHT(4)),\n    NoiseOctave(OCTAVE_MAT4 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(5)),\n    NoiseOctave(OCTAVE_MAT4 * OCTAVE_MAT2,\n                OCTAVE_WEIGHT(6)),\n    NoiseOctave(OCTAVE_MAT4 * OCTAVE_MAT2 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(7)),\n    NoiseOctave(OCTAVE_MAT8,\n                OCTAVE_WEIGHT(8)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(9)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT2,\n                OCTAVE_WEIGHT(10)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT2 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(11)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT4,\n                OCTAVE_WEIGHT(12)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT4 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(13))\n);\n\n//Gets the noise value (no derivative) at a point on the terrain's surface,\n//    for the given noise octave.\nfloat terrainNoiseOctaveValue(NoiseOctave octave, vec2 pos)\n{\n    //Simple value noise!\n\n    //First, transform the position for this octave.\n    pos *= TERR_SCALE;\n    pos = octave.transform * pos;\n\n    //Get the four corners of the grid cell surrounding this position.\n    vec2 gridPos = pos,\n         gridMin = floor(gridPos),\n         gridMax = gridMin + 1.0;\n\n    //Assign a randomized value to each corner.\n    vec4 gridMinMax = vec4(gridMin, gridMax);\n    float v00 = hashTo1(vec3(gridMinMax.xy, TERR_NOISE_SEED)),\n          v10 = hashTo1(vec3(gridMinMax.zy, TERR_NOISE_SEED)),\n          v01 = hashTo1(vec3(gridMinMax.xw, TERR_NOISE_SEED)),\n          v11 = hashTo1(vec3(gridMinMax.zw, TERR_NOISE_SEED));\n\n    //Interpolate.\n    //Normally this would look like:\n    /*\n        vec2 t = gridPos - gridMin;\n        t = smoothstep(0.0, 1.0, t);\n        return mix(mix(v00, v10, t.x),\n                   mix(v01, v11, t.x),\n                   t.y);\n    */\n    //To attempt to figure out analytical derivatives, here is that same expression\n    //    written out as plain, differentiable math operations.\n    //It seems to be wrong though.\n    /*\n        mix(a, b, t) = a + ((b-a) * t)\n        t(p) = (-3*p*p*p) + (2*p*p)\n        noise(p)   = (v00 + ((v10 - v00) * t.x)) +\n                     ( ((v01 + ((v11 - v01) * t.x)) - (v00 + ((v10 - v00) * t.x))) * t.y )\n                   = v00 + (t.x * v10) + (t.x * -v00) +\n                     (t.y * (v01 + (t.x * v11) + (t.x * -v01))) +\n                     (t.y * -(v00 + (t.x * v10) + (t.x * -v00)))\n                   = v00 +\n                     t.x * (v10 - v00) +\n                     t.y * (v01 - v00) +\n                     (t.x * t.y) + (v11 + v10 - v01 - v00)\n                   = v00 +\n                     ((-3 * p.x^3) + (2 * p.x^2)) * (v10 - v00) +\n                     ((-3 * p.y^3) + (2 * p.y^3)) * (v01 - v00) +\n                     ((-3 * p.x^3) + (2 * p.x^2)) * ((-3 * p.y^3) + (2 * p.y^2)) * (v11 + v10 - v01 - v00)\n                   = v00 +\n                     (p.x^3 * (v10 - v00) * -3) +\n                     (p.x^2 * (v10 - v00) * 2) +\n                     (p.y^3 * (v01 - v00) * -3) +\n                     (p.y^2 * (v01 - v00) * 2) +\n                     ((v11 + v10 - v01 - v00) *\n                      ((9 * p.x^3 * p.y^3) + (4 * p.x^2 * p.y^2) +\n                       (-6 * p.x^3 * p.y^2) + (-6 * p.x^2 * p.y^3)))\n                   = v00 +\n                     (p.x^3 * (v10 - v00) * -3) +\n                     (p.x^2 * (v10 - v00) * 2) +\n                     (p.y^3 * (v01 - v00) * -3) +\n                     (p.y^2 * (v01 - v00) * 2) +\n                     (p.x^3 * p.y^3 * (v11 + v10 - v01 - v00) * 9) +\n                     (p.x^2 * p.y^2 * (v11 + v10 - v01 - v00) * 4) +\n                     (p.x^3 * p.y^2 * (v11 + v10 - v01 - v00) * -6) +\n                     (p.x^2 * p.y^3 * (v11 + v10 - v01 - v00) * -6)\n          => noise'dx = (p.x^2 * (v10 - v00) * (-3 * 3)) +\n                        (p.x * (v10 - v00) * (2 * 2)) +\n                        (p.x^2 * p.y^3 * (v11 + v10 - v01 - v00) * (9 * 3)) +\n                        (p.x * p.y^2 * (v11 + v10 - v01 - v00) * (4 * 2)) +\n                        (p.x^2 * p.y^2 * (v11 + v10 - v01 - v00) * (3 * -6)) +\n                        (p.x * p.y^3 * (v11 + v10 - v01 - v00) * (2 * -6))\n          => noise'dy = (p.y^2 * (v01 - v00) * (-3 * 3)) +\n                        (p.y * (v01 - v00) * (2 * 2)) +\n                        (p.y^2 * p.x^3 * (v11 + v10 - v01 - v00) * (3 * 9)) +\n                        (p.y * p.x^2 * (v11 + v10 - v01 - v00) * (2 * 4)) +\n                        (p.y * p.x^3 * (v11 + v10 - v01 - v00) * (2 * -6)) +\n                        (p.y^2 * p.x^2 * (v11 + v10 - v01 - v00) * (3 * -6))\n    */\n    if (true)\n    {\n        vec2 t = gridPos - gridMin;\n        t = smoothstep(0.0, 1.0, t);\n        return mix(mix(v00, v10, t.x),\n                   mix(v01, v11, t.x),\n                   t.y);\n    }\n    else\n    {\n        vec2 p = gridPos - gridMin;\n        vec2 p2 = p * p,\n             p3 = p2 * p;\n        return v00 +\n               (p3.x * (v10 - v00) * -3.0) +\n               (p2.x * (v10 - v00) * 2.0) +\n               (p3.y * (v01 - v00) * -3.0) +\n               (p2.y * (v01 - v00) * 2.0) +\n               (p3.x * p3.y * (v11 + v10 - v01 - v00) * 9.0) +\n               (p2.x * p2.y * (v11 + v10 - v01 - v00) * 4.0) +\n               (p3.x * p2.y * (v11 + v10 - v01 - v00) * -6.0) +\n               (p2.x * p3.y * (v11 + v10 - v01 - v00) * -6.0);\n    }\n}\n\n//Alternative noise function that uses polynomial noise, based on IQ's video.\n//I don't know how to calculate the analytical derivative for this.\nfloat terrainNoiseOctaveValue_POLY(NoiseOctave octave, vec2 pos)\n{\n    //Split the world into a grid.\n    //Each grid cell has a different polynomial function,\n    //    whose parameters are based on the 4 corners.\n    //This setup makes the corners/edges of the cells line up with their neighbors,\n    //    and also provides a nice analytic derivative.\n\n    //First, transform the position for this octave.\n    pos *= TERR_SCALE;\n    pos = octave.transform * pos;\n\n    //Compute the parameters of the four corners.\n    vec2 gridPos = pos,\n         gridMin = floor(gridPos),\n         gridMax = gridMin + 1.0;\n    vec4 gridMinMax = vec4(gridMin, gridMax);\n    float paramMinXMinY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.xy, TERR_NOISE_SEED))),\n          paramMaxXMinY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.zy, TERR_NOISE_SEED))),\n          paramMinXMaxY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.xw, TERR_NOISE_SEED))),\n          paramMaxXMaxY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.zw, TERR_NOISE_SEED)));\n\n    //Compute the polynomial.\n    vec2 t = gridPos - gridMin;\n    t = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t));\n    return paramMinXMinY +\n           (t.x * (paramMaxXMinY - paramMinXMinY)) +\n           (t.y * (paramMinXMaxY - paramMinXMinY)) +\n           (t.x * t.y * (paramMinXMinY + paramMaxXMaxY - paramMinXMaxY - paramMaxXMinY));\n}\n\n////////////////////////////////\n//   Terrain Data Functions   //\n////////////////////////////////\n\n//Calculates the terrain height at a given horiziontal position.\nfloat terrainHeight(vec2 horzPos)\n{\n    //Compute the octave noise.\n    float value = 0.0,\n          maxValue = 0.0;\n    for (int i = 0; i < N_OCTAVES; ++i)\n    {\n        NoiseOctave octave = OCTAVES[i];\n        value += (octave.weight * terrainNoiseOctaveValue(octave, horzPos));\n        maxValue += octave.weight;\n    }\n    value /= maxValue;\n\n    //Create the two plateaus by using smoothstep() on the height values between them.\n    //This pushes the height values towards either end.\n    if (value >= TERR_PLATEAU_A && value <= TERR_PLATEAU_B)\n    {\n        float cliffT = smoothstep(TERR_PLATEAU_A, TERR_PLATEAU_B, value);\n        value = mix(TERR_PLATEAU_A, TERR_PLATEAU_B, cliffT);\n    }\n\n    //TODO: How did IQ make those cliffs exactly?\n\n    return TERR_HEIGHT * value;\n}\n\n//Estimates how close a point is to the terrain.\n//If the value is <= 0, you can interpret that as a collision.\n//As the distance gets larger, the quality of the estimation gets worse.\nfloat terrainDist(vec3 pos)\n{\n    //Check the distance from this point to the terrain's heightmap directly below it.\n    //This distance estimation works well when close to the terrain.\n    //When far from the terrain, the point may be closer to a hill or sheer cliff\n    //    than to the spot directly below it,\n    //    but at that point the estimate isn't useful anyway.\n\n    //Don't forget to use signed distance,\n    //    a.k.a. the output should be negative when below the terrain.\n\n    return pos.y - terrainHeight(pos.xz);\n}\n\nvec3 terrainNormal(vec2 horzPos)\n{\n    /*\n        Here's the implementation for analytic derivatives:\n            float derivX = ...;\n            float derivZ = ...;\n            return normalize(-vec3(derivX, -1, derivZ));\n    */\n\n    //Use finite differences, which works OK when you can't figure out an analytic derivative.\n    //TODO: Why does setting the epsilon to be smaller seem to create a much worse result?\n    #define TERR_NORMAL_EPSILON 0.1\n    vec2 offset2 = vec2(TERR_NORMAL_EPSILON, 0.0);\n\n    return normalize(vec3(\n        terrainHeight(horzPos - offset2.xy) -\n           terrainHeight(horzPos + offset2.xy),\n        2.0 * TERR_NORMAL_EPSILON,\n        terrainHeight(horzPos - offset2.yx) -\n           terrainHeight(horzPos + offset2.yx)\n    ));\n}\nvec3 terrainNormal(vec3 pos) { return terrainNormal(pos.xz); }\n\n//Determines how grassy or rocky a part of the terrain's surface is.\nfloat terrainGrassiness(vec3 pos, vec3 normal)\n{\n    float grassiness = normal.y;\n    grassiness = pow(grassiness, TERR_GRASS_THRESHOLD);\n    grassiness = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, grassiness));\n    return grassiness;\n}\n\n\n////////////////////\n//   Raymarching  //\n////////////////////\n\n//Codes for what surface was hit.\n#define HIT_SKY 0\n#define HIT_TERRAIN 1\n#define HIT_TREES 2\n\nstruct RayQuality\n{\n    //How far the ray moves each step, when close to its source.\n    float initialInterval;\n    //How much coarser the ray gets as it moves away from its source.\n    float intervalIncrement;\n\n    //TODO: Define the target range of the ray, compute the required number of march iterations, then cap it at the below value.\n\n    //How many iterations of the raymarcher to run.\n    int nIterations;\n\n    //TODO: Quality flag for \"shadow mode\", a.k.a. ignore trees, terrain normals, and some octaves.\n};\n\nstruct RayHit\n{\n    int code; //See the HIT_[X] tokens defined above.\n    vec3 pos; //Not defined if hitting sky.\n    float dist; //Not well-defined if hitting sky.\n\n    //Estimates the closest the ray got to the terrain during its travel.\n    float minTerrainDist;\n\n    //Data that's only given if the terrain was hit:\n    vec3 terrainNormal;\n    float terrainGrassiness;\n\n    //Channels of debug data for visualization.\n    vec4 debug;\n};\n\nRayHit marchRay(vec3 rayPos, vec3 rayDir, RayQuality quality)\n{\n    float totalDist = 0.0;\n\n    //If the ray starts above the terrain, jump to the 'ceiling' of the heightmap.\n    if (rayPos.y > TERR_HEIGHT)\n    {\n        if (rayDir.y >= 0.0)\n        {\n            return RayHit(HIT_SKY, rayPos, 0.0,\n                          rayPos.y - terrainHeight(rayPos.xz),\n                          vec3(0.0), 0.0, vec4(0.0));\n        }\n        else\n        {\n            float intersectT = (TERR_HEIGHT - rayPos.y) / rayDir.y;\n            rayPos += rayDir * intersectT;\n            totalDist += intersectT;\n        }\n    }\n\n    float stepDist = quality.initialInterval;\n    float minTerrainDist = 9999999.0;\n    float previousStepTerrainDist = 9999999.0;\n    for (int i = 0; i < quality.nIterations; ++i)\n    {\n        //Check for collisions at the current position.\n\n        //If the ray is above the terrain and heading further upwards,\n        //    don't bother with collision-testing anymore.\n        if ((rayDir.y > 0.0) && (rayPos.y > TERR_HEIGHT))\n        {\n            return RayHit(HIT_SKY, rayPos, totalDist, minTerrainDist,\n                          vec3(0, 0, 0), 0.0, vec4(0));\n        }\n\n        //Estimate distance to the terrain with the point's elevation.\n        //This estimation is less accurate when the point is far away from the terrain,\n        //    but in that case the value isn't important anyway.\n        float terrHeight = terrainHeight(rayPos.xz);\n        float terrainDist = rayPos.y - terrHeight;\n        if (terrainDist <= 0.0)\n        {\n            //The ray is most likely underneath the terrain now.\n            //Approximate the point of collision by finding the intersection\n            //    between the last ray step and a line running along the terrain's surface.\n            float backwardsStepScale = 1.0 - (-previousStepTerrainDist / (terrainDist - previousStepTerrainDist));\n            float backwardsStep = backwardsStepScale * (stepDist - quality.intervalIncrement);\n            rayPos -= backwardsStep * rayDir;\n            totalDist -= backwardsStep;\n\n            minTerrainDist = 0.0;\n            vec3 normal = terrainNormal(rayPos);\n            float grassiness = terrainGrassiness(rayPos, normal);\n            return RayHit(HIT_TERRAIN, rayPos, totalDist, minTerrainDist,\n                          normal, grassiness,\n                          //Debug data:\n                          vec4(backwardsStep, terrainDist, 0.0, 0.0));\n        }\n        minTerrainDist = min(terrainDist, minTerrainDist);\n\n        //March the ray forward.\n        rayPos += rayDir * stepDist;\n        totalDist += stepDist;\n        stepDist += quality.intervalIncrement;\n        previousStepTerrainDist = terrainDist;\n    }\n\n    //Nothing concrete was hit, so we \"hit\" sky.\n    return RayHit(HIT_SKY, rayPos, totalDist, minTerrainDist, vec3(0, 0, 0), 0.0,\n                  //Debug data:\n                  vec4(0));\n}\n\n\n/////////////\n//   Sun   //\n/////////////\n\nstruct SunState\n{\n    vec3 brightness;\n    vec3 towardsSun;\n};\n\nSunState sunCurrentState()\n{\n    //TODO: Animated day/night thing\n    return SunState(vec3(1.0, 0.95, 0.9), normalize(vec3(1, 0.5, 1)));\n}\n\n\n///////////////\n//  Shadows  //\n///////////////\n\n#define SHADOW_RAY_QUALITY RayQuality(2.5, 0.3, 100)\n#define SHADOW_START_AHEAD 5.3\n\n//Gets a 0-1 value indicating how much light reaches the given position.\nfloat castShadow(vec3 surfacePos, SunState sun)\n{\n    RayHit hit = marchRay(surfacePos + (sun.towardsSun * SHADOW_START_AHEAD),\n                          sun.towardsSun,\n                          SHADOW_RAY_QUALITY);\n\n    //TODO: Use the 'minTerrainDist' term for soft shadows.\n    return (hit.code == HIT_SKY) ? 1.0 : 0.0;\n}\n\n\n//////////////////\n//   Lighting   //\n//////////////////\n\n#define LIGHT_AMBIENT vec3(0.85, 0.76, 0.5)\n\n#define FOG_ATTEN (-0.0006 * vec3(1, 2, 4.0))\n#define FOG_BRIGHTNESS 0.775\n//TODO: Add height-based fog\n\n#define TERR_COLOR_ROCK vec3(0.43, 0.33, 0.31)\n#define TERR_COLOR_GRASS vec3(0.18, 0.39, 0.19)\nvec3 lightTerrain(RayHit hit, SunState sun)\n{\n    vec3 albedo = mix(TERR_COLOR_ROCK, TERR_COLOR_GRASS, hit.terrainGrassiness);\n    float diffuse = max(0.0, dot(hit.terrainNormal, sun.towardsSun));\n\n    //TODO: Specular\n\n    vec3 fogDensity = vec3(1.0 - exp(hit.dist * FOG_ATTEN));\n\n    float shadow = diffuse * castShadow(hit.pos, sun); //TODO: Fix the mixture of diffuse, shadow, and ambient.\n    vec3 shadowColor = min(vec3(shadow), LIGHT_AMBIENT);\n\n    vec3 surfaceColor = albedo * sun.brightness * shadowColor;\n    return mix(surfaceColor, vec3(FOG_BRIGHTNESS), fogDensity);\n}\n\n#define SKY_COLOR_HORIZON vec3(0.435, 0.65, 1.0)\n#define SKY_COLOR_ZENITH vec3(0.05, 0.25, 0.775)\nvec3 lightSky(vec3 camPos, vec3 camRayDir, SunState state)\n{\n    float zenithT = smoothstep(0.0, 1.0, max(0.0, camRayDir.y));\n    vec3 baseColor = mix(SKY_COLOR_HORIZON, SKY_COLOR_ZENITH, zenithT);\n\n    //TODO: Clouds.\n\n    return baseColor;\n}\n\n\n////////////////////////////////////\n//    Camera Definitions/math     //\n////////////////////////////////////\n\n#define CAM_FOV_SCALE 1.0\n\nstruct CamState\n{\n    vec3 pos, forward;\n    float fovScale;\n};\n\n//Gets the direction of a ray starting at the camera\n//    and passing through the given point on the screen.\nvec3 camRay(CamState state, vec2 uv)\n{\n    Basis basis = makeBasis(state.forward);\n    vec3 offset = ((1.0/state.fovScale) * basis.forward)\n                     + (mix(-basis.right, basis.right, uv.x))\n                     + (mix(-basis.up, basis.up, uv.y));\n    return normalize(offset);\n}\n\n\n//////////////////////////////////\n//    Camera Animation Math     //\n//////////////////////////////////\n\nstruct CamKeyframe\n{\n    vec2 horzPos;\n    float heightOffset;\n\n    //Heading/yaw is given as 0-1.\n    //Pitch is given as a value which is put into the view direction before normalization.\n    float headingT, pitchForce;\n\n    float fovScale;\n};\nCamKeyframe interpolateCamOrientation(CamKeyframe a, CamKeyframe b, float t)\n{\n    //TODO: Use different interpolation curves for each kind of data. E.x:\n    //    * Pitch should spend most of its time around 0\n    //    * Heading should check for wraparound angle being smaller\n\n    return CamKeyframe(\n        mix(a.horzPos, b.horzPos, t),\n        mix(a.heightOffset, b.heightOffset, t),\n        mix(a.headingT, b.headingT, t),\n        mix(a.pitchForce, b.pitchForce, t),\n        mix(a.fovScale, b.fovScale, t)\n    );\n}\n//Converts camera keyframe data into a state.\nCamState computeCamState(CamKeyframe keyframe)\n{\n    vec3 pos = vec3(keyframe.horzPos.x,\n                    terrainHeight(keyframe.horzPos) + keyframe.heightOffset,\n                    keyframe.horzPos.y);\n\n    float headingRad = keyframe.headingT * (2.0 * 3.14159265);\n    vec3 forward = normalize(vec3(cos(headingRad),\n                                  keyframe.pitchForce,\n                                  sin(headingRad)));\n\n    return CamState(pos, forward, keyframe.fovScale);\n}\n\n\n//////////////////////////////////\n//    Camera Animation Keys     //\n//////////////////////////////////\n\nconst CamKeyframe CAM_KEYFRAMES[] = CamKeyframe[](\n    CamKeyframe(vec2(42.55 * -80.0), 35.5,\n                0.255, -0.05,\n                1.0)\n);\n\nCamState camCurrentState(float time)\n{\n    CamKeyframe key = CAM_KEYFRAMES[0];\n    //key.headingT += iTime * 0.1;\n    return computeCamState(key);\n}\n\n\n\n/////////////////////////\n//   Post-processing   //\n/////////////////////////\n\nvec3 postProcess(vec3 computedColor, vec3 camRayDir)\n{\n    //TODO: Try smoothstep to increase vibrance/contrast.\n    //TODO: Add a glow near the sun direction, to simulate a lens.\n\n    return computedColor;\n}\n\n\n////////////////////\n//    Samples     //\n////////////////////\n\n//High-quality, for show:\n//#define MAIN_RAY_QUALITY RayQuality(0.2, 0.002, 900)\n//Low-quality, for testing:\n#define MAIN_RAY_QUALITY RayQuality(0.4, 0.008, 450)\n\n//Affects the number of samples used for anti-aliasing.\n//Larger values improve quality but kill performance.\n//A value of 1 means \"no AA\", and a value of 0 effectively disables rendering.\n#define AA_SAMPLES 1\n\n//Computes a single pixel sample.\n//Antialiasing can use multiple such samples.\nvec3 sampleColor(CamState camera, SunState sun, vec2 uv)\n{\n    vec3 rayDir = camRay(camera, uv);\n    RayHit hit = marchRay(camera.pos, rayDir, MAIN_RAY_QUALITY);\n    if (hit.code == HIT_TERRAIN)\n        return lightTerrain(hit, sun);\n    else if (hit.code == HIT_SKY)\n        return lightSky(camera.pos, rayDir, sun);\n    else if (hit.code == HIT_TREES)\n        return vec3(1, 0, 0);\n    else\n        return vec3(1, 0, 1); //Unknown surface! Return 'error' color.\n}\n\n//Computes the color for a pixel, including anti-aliasing.\n//Takes aspect-ratio-corrected UV data (a.k.a. at least one axis has a different range than 0-1).\nvec3 pixelColor(CamState camera, SunState sun,\n                vec2 uvScreenMin, vec2 uvScreenMax,\n                vec2 uvAspected, vec2 screenResolution)\n{\n    //SSAA: Render multiple times per-pixel, with subpixel offsets,\n    //    and average them together.\n    vec3 sampleSum = vec3(0.0);\n\n    //This pixel covers some amount of UV space.\n    vec2 uvCoverage = (uvScreenMax - uvScreenMin) / screenResolution; //Note that we'd expect uvCoverage.x == uvCoverage.y\n    vec2 uvCoverageMin = uvAspected - (uvCoverage / 2.0),\n         uvCoverageMax = uvCoverageMin + uvCoverage;\n\n    //Take regular samples across this UV pixel.\n    for (int x = 0; x < AA_SAMPLES; ++x)\n    {\n        float tX = (float(x) + 0.5) / float(AA_SAMPLES);\n        for (int y = 0; y < AA_SAMPLES; ++y)\n        {\n            float tY = (float(y) + 0.5) / float(AA_SAMPLES);\n\n            vec2 uvSample = mix(uvCoverageMin, uvCoverageMax, vec2(tX, tY));\n            sampleSum += sampleColor(camera, sun, uvSample);\n        }\n    }\n    vec3 rawColor = sampleSum / float(AA_SAMPLES * AA_SAMPLES);\n\n    return postProcess(rawColor, camRay(camera, uvAspected));\n}\n\n\n\n//////////////\n//   main   //\n//////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get screen UV coordinates.\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //Correct for aspect ratio by stretching UV's horizontally.\n    float aspect = iResolution.x / iResolution.y;\n    float uvExtraWidth = aspect - 1.0,\n          uvHorzPadding = uvExtraWidth / 2.0;\n    vec2 uvMin = vec2(-uvHorzPadding, 0.0),\n         uvMax = vec2(1.0 + uvHorzPadding, 1.0);\n    vec2 uvAspected = mix(uvMin, uvMax, uv);\n\n    //Get camera data.\n    CamState camera = camCurrentState(iTime);\n    vec3 rayDir = camRay(camera, uvAspected);\n\n    //Debug outputs:\n    {\n        //DEBUG: Output screen data.\n        if (false)\n        {\n            fragColor = vec4(uvAspected, 0.0, 1.0);\n            return;\n        }\n\n        //DEBUG: Output terrain-related data.\n        if (false)\n        {\n            vec3 testPos = camera.pos + vec3(uvAspected*30.0, 0.0).xzy;\n            float testDist = terrainDist(testPos) / TERR_HEIGHT;\n\n            fragColor = vec4(testDist, testDist, testDist, 1.0);\n            return;\n        }\n\n        //DEBUG: Output camera/ray data.\n        if (false)\n        {\n            Basis basis = makeBasis(camera.forward);\n            fragColor = vec4(basis.up, 1.0);\n            return;\n        }\n\n        //DEBUG: Raymarching collision data.\n        if (false)\n        {\n            RayHit hit = marchRay(camera.pos, rayDir, MAIN_RAY_QUALITY);\n            if (hit.code == HIT_TERRAIN)\n            {\n                //Color based on hit distance.\n                float strength = hit.dist / 550.0;\n                strength = max(0.35, strength);\n                fragColor = vec4(strength * 0.2, strength, 0.0, 1.0);\n\n                //Color based on estimated distance to the terrain.\n                fragColor = vec4(vec3(hit.minTerrainDist / 5.0), 1.0);\n\n                //Color based on debug visualization data.\n                fragColor = vec4(hit.debug.xy * vec2(1.0, -1.0),\n                                 0.0, 1.0);\n\n                //Color based on surface normal.\n                fragColor = vec4(abs(hit.terrainNormal), 1.0);\n\n                //Color based on finite-differences math.\n                vec2 posXMin = vec2(hit.pos.x - TERR_NORMAL_EPSILON, hit.pos.z),\n                     posXMax = vec2(hit.pos.x + TERR_NORMAL_EPSILON, hit.pos.z),\n                     posZMin = vec2(hit.pos.x, hit.pos.z - TERR_NORMAL_EPSILON),\n                     posZMax = vec2(hit.pos.x, hit.pos.z + TERR_NORMAL_EPSILON);\n                float heightXMin = terrainHeight(posXMin),\n                      heightXMax = terrainHeight(posXMax),\n                      heightZMin = terrainHeight(posZMin),\n                      heightZMax = terrainHeight(posZMax);\n                float heightY = 2.0 * TERR_NORMAL_EPSILON;\n                vec2 change2D = vec2(heightXMin - heightXMax,\n                                     heightZMin - heightZMax);\n                vec3 dir = vec3(change2D.x, heightY, change2D.y);\n                vec3 norm = normalize(dir);\n                vec2 heightsXLinearized = pow(-vec2(heightXMin, heightXMax) / TERR_HEIGHT,\n                                              vec2(4.0));\n                vec2 change2DLinearized = pow(abs(change2D), vec2(0.2));\n                fragColor.rgb = vec3(sign(norm.xz), fract(hit.pos.x));\n\n                //Color based on height.\n                fragColor.rgb = vec3(terrainHeight(hit.pos.xz) / TERR_HEIGHT);\n            }\n            else if (hit.code == HIT_SKY)\n            {\n                float strength = hit.minTerrainDist / 100.0;\n                fragColor = vec4(0.0, 0.0, strength, 1.0);\n            }\n            else\n            {\n                //Uh-oh, what are we looking at??\n                fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n            }\n\n            return;\n        }\n    }\n\n    //The actual logic used for coloring the scene:\n    if (true)\n    {\n        fragColor.rgb = pixelColor(camera, sunCurrentState(),\n                                   uvMin, uvMax, uvAspected,\n                                   iResolution.xy);\n        fragColor.a = 1.0;\n        return;\n    }\n\n    //DEBUG: Fallback, return noise to indicate \"you forgot to return anything\".\n    fragColor = vec4(hashTo3(uv * 3999.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tByW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 472, 503, 503, 628], [774, 800, 824, 824, 909], [910, 910, 933, 933, 1050], [1051, 1051, 1075, 1075, 1178], [1180, 1206, 1229, 1229, 1358], [1359, 1359, 1381, 1381, 1515], [1516, 1516, 1539, 1539, 1658], [1660, 1686, 1709, 1709, 1842], [1843, 1843, 1865, 1865, 2001], [2002, 2002, 2025, 2025, 2149], [2151, 2177, 2200, 2200, 2348], [2349, 2349, 2371, 2371, 2520], [2521, 2521, 2543, 2543, 2692], [2693, 2693, 2716, 2716, 2850], [6078, 6188, 6249, 6329, 10700], [10702, 10848, 10914, 11256, 12198], [12300, 12365, 12400, 12432, 13146], [13148, 13333, 13362, 13823, 13868], [13870, 13870, 13904, 14286, 14633], [14634, 14634, 14664, 14664, 14696], [14698, 14767, 14815, 14815, 15002], [16126, 16126, 16189, 16189, 19065], [19175, 19175, 19203, 19240, 19313], [19450, 19523, 19572, 19572, 19848], [20154, 20154, 20199, 20199, 20734], [20834, 20834, 20894, 20894, 21077], [21284, 21394, 21432, 21432, 21684], [22039, 22039, 22117, 22317, 22560], [22561, 22607, 22655, 22655, 23093], [23351, 23351, 23389, 23389, 23499], [23582, 23582, 23636, 23761, 23790], [24231, 24311, 24369, 24369, 24776], [26116, 26116, 26173, 26206, 30374]], "test": "untested"}
{"id": "7lByWt", "name": "paint brush", "author": "FabriceNeyret2", "description": "just a test", "tags": ["paintbrush"], "likes": 22, "viewed": 733, "published": 3, "date": "1650390006", "time_retrieved": "2024-07-30T16:52:45.414352", "image_code": "#define S(v)        smoothstep(.8,-.8, v )\n//#define fwidth(v) length(vec2(dFdx(v),dFdy(v)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    U = vec2( atan(U.y,U.x)/3.14, length(U)-.7 );   // ring coords\n    O-=O;\n    \n    float s = texture(iChannel0,2.* U.yy , .5 ).r,  // profile of brush hair thickness\n          v = u.y > floor(R.y/2.)\n                ? 1.*U.x - s                        // brush start\n                : -6.*(U.x+.2) - s;                 // brush end\n                \n    O += S( -v / fwidth(v) );                       // brush mask in whole polar field\n    v  = S( ( abs(U.y)-.2 ) / fwidth(U.y) );        // ring mask\n  //  O =  1. - O * v;                              // just brush mask\n    O = mix( vec4(1), vec4(1,0,0,1)*s, O*v );       // color scheme\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lByWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 132, 132, 839]], "test": "untested"}
{"id": "NlByWd", "name": "Simple Balls 23425", "author": "SnoopethDuckDuck", "description": "testing effects", "tags": ["e"], "likes": 4, "viewed": 235, "published": 3, "date": "1650380159", "time_retrieved": "2024-07-30T16:52:46.168336", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float t = 0.1 * iTime;\n    vec3 ro = vec3(2., 3. * cos(t), -3. * sin(t));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\n// messy \nfloat GetDist(vec3 p) {\n    vec3 i = floor(p);\n    \n    float k = mod(i.x + i.y + i.z, 2.);\n    \n    \n    p = fract(p)-0.5;\n    float r = 0.05 + 0.2 * h21(vec2(i.x, h21(i.yz)));\n    \n    float d = sdBox(p, vec3(r)) - 0.01; \n   // if (k == 0.)\n        d = length(p) - r;\n    \n    return 0.5 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        col = mix(vec3(0.5 + 0.5 * n), col, 0.5 + 0.5 * r);\n        //col *= 0.5 + 0.5 * n.y;\n        float fres = pow(1. + dot(rd, n), 5.);\n        col = mix(vec3(1), col, 0.5 - 0.5 * fres);\n        \n        \n        col *= 1.-exp(-8. * dIn);\n        \n        vec3 e = vec3(0.5);\n        vec3 col2 = pal(1. * length(p) - 0. * iTime, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        col = mix(col2, col, 0.1 * clamp(exp(5. * length(p -pExit)), 0., 10.));\n        \n    }\n    \n    col *= exp(-0.15 * length(p));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlByWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 768], [770, 780, 803, 803, 1076], [1078, 1078, 1121, 1121, 1428], [1430, 1430, 1454, 1454, 1644], [1646, 1646, 1696, 1696, 1887], [1889, 1889, 1946, 1946, 3206]], "test": "untested"}
{"id": "ft2czK", "name": "Fluid flow simulation", "author": "skal", "description": "Experimenting at 60fps with incompressible-fluid flow simulation. What a time to be alive!\n\nThere's various options to activate on the 'common' buffer.\nPress keys 1, 2, or 3 for visualizing velocity field, pressure or divergence.\n", "tags": ["simulation", "fluid", "vortex", "airfoil", "incompressible", "incompressible", "stokes", "naviers"], "likes": 26, "viewed": 811, "published": 3, "date": "1650377452", "time_retrieved": "2024-07-30T16:52:47.322251", "image_code": "//   Viscous incompressible fluid solver.\n//\n// Buffer A/D contains {vx, vy, color1, color2}\n// Buffer A is the advected fields U*\n// Buffer B contains the divergence ∇.U*\n// Buffer C contains the last solved pressure (re-used)\n//\n// Press '1' to show velocity field, \n//       '2' for the pressure,\n//       '3' for the divergence\n// Otherwise the tracers are shown.\n// Use the mouse to change the obstacle position.\n//\n// C++ equivalent code: https://github.com/skal65535/flow_sim\n//\n// The solver in 'Buffer C' has code for various number of iterations\n// of the Jacobi steps. There's a #define to switch in the Common code.\n// Lower number of steps will struggle to cancel the divergence.\n//\n// Heavily inspired by Robert's Schuetze (@trirop)'s shader:223\n//   https://www.shadertoy.com/view/MdSczK\n// and follow-up by @ultraviolet:\n//   https://www.shadertoy.com/view/4lScRG\n//\n// Created by Pascal Massimino [skal] (2022)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// distance from p to segment [p1-p2]\nfloat SegmentDistance(vec2 p, vec2 p1, vec2 p2) {\n  vec2 dir = p2 - p1;\n  float d2 = dot(dir, dir);\n  float d3 = dot(dir, p - p1) / d2;\n  float frac = clamp(d3, 0.0, 1.0);\n  return length(p - p1 - frac * dir);\n}\n\n#define KEY(K) (texelFetch(iChannel3, ivec2((K), 0), 0).x > 0.5)\n\nvoid mainImage(out vec4 fragColor, in vec2 pos) {\n  if (KEY(49)) show_what = 1;\n  if (KEY(50)) show_what = 2;\n  if (KEY(51)) show_what = 3;\n\n  if (IsObstacle(iMouse.xy, pos)) {      // draw the obstacle\n    fragColor = vec4(0.3, 0.7, 0.3, 1.0);\n    return;\n  }\n\n  if (show_what == 2) {  // pressure\n    vec3 p = texture(iChannel1, pos / iResolution.xy).www;\n    fragColor = vec4(fract(p * 0.5) - step(fract(p * 4.), vec3(.05)), 1.0);\n  } else if (show_what == 1) {  // visualize velocity field\n    vec2 p0 = floor(pos / kCell) * kCell;\n    vec2 p1 = p0 + vec2(0.5 * kCell);\n    vec2 p2 = p1 + kVelocityUnit * texture(iChannel0, p1 / iResolution.xy).xy;\n    float d = 1. - smoothstep(0., 2.0, SegmentDistance(pos, p1, p2));\n    fragColor = vec4(d, d, d, 1.0);\n  } else if (show_what == 3) {  // show divergence\n    vec4 t = texture(iChannel2, pos / iResolution.xy);\n    fragColor = vec4(0.5 - 2.3 * t.www, 1.0);\n  } else if (show_what == 0) {  // show tracers\n    vec4 t = texture(iChannel0, pos / iResolution.xy);\n    fragColor = vec4(mix(vec3(0.7, 0.8, 0.9) * t.z, vec3(1., 1., 0.), t.w), 1.0);\n  }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Advects U->U* using the previous velocity field in BufD.\n// bufA will contains advected {vx, vy, color1/2}\n//\n// Created by Pascal Massimino [skal] (2022)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec4 Advect(vec2 p) { // using 4-order Runge-Kutta\n  vec2 norm = 1. / iResolution.xy;\n  p *= norm;\n  vec2 H = dt * norm;\n  vec2 k1 = H * texture(iChannel0, p           ).xy;\n#if (RUNGE_KUTTA == 4)\n  vec2 k2 = H * texture(iChannel0, p - 0.5 * k1).xy;\n  vec2 k3 = H * texture(iChannel0, p - 0.5 * k2).xy;\n  vec2 k4 = H * texture(iChannel0, p -       k3).xy;\n  vec2 dp = (0.5 * (k1 + k4) + k2 + k3) / 3.0;\n#elif (RUNGE_KUTTA == 2)\n  vec2 k2 = H * texture(iChannel0, p - 0.5 * k1).xy;\n  vec2 dp = k2;\n#else  // RUNGE_KUTTA == 1\n  vec2 dp = k1;\n#endif\nreturn texture(iChannel0, p - dp);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos) {\n  vec4 src = Advect(pos);  // advect backward\n  vec2 v = src.xy;   // velocity\n  vec2 c = src.zw;   // color\n  // force some boundary conditions\n\n  // initial field\n  if (iFrame <= 1){\n    v = vec2(Vo, 0.0);\n    c.x = step(sin(242.223 * sin(pos.x * 320.231 + pos.y * 13.92)), -0.4);\n    c.y = 0.;\n  }\n  // in/out flow from left to right\n  if (pos.x < 2. || pos.x >= iResolution.x - 2.) {\n    v = vec2(Vo, 0.0);\n  }\n  // rough canal\n  if (pos.y < 2. || pos.y >= iResolution.y - 2.) {\n    v = vec2(0.0, 0.0);\n  }\n  if (pos.x < 5.) {  // some tracer injection\n    c.x = 1. - step(cos(pos.y * 0.3), .2) * step(fract(iTime * 0.5), 0.99);\n  }\n  if (IsObstacle(iMouse.xy, pos.xy)) {\n    v = vec2(0., .0);\n    c.x = 0.;\n    c.y = step(sin(pos.y / 2.), .9);  // color tracers from obstacle\n  }\n  fragColor = vec4(v, c);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Computes D = K.∇.U*   [with K=-dt/(2.rho.dx)]\n//\n// Created by Pascal Massimino [skal] (2022)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Divergence(vec2 p) {\n  vec2 norm = 1. / iResolution.xy;\n  vec2 P = p * norm;\n  vec2 dx = vec2(norm.x,     0.);\n  vec2 dy = vec2(    0., norm.y);  \n  float dv_dx = texture(iChannel0, P + dx).x\n              - texture(iChannel0, P - dx).x;\n  float dv_dy = texture(iChannel0, P + dy).y\n              - texture(iChannel0, P - dy).y;\n  return -0.5 * (dv_dx + dv_dy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 pos) {\n  fragColor = vec4(0., 0., 0., Divergence(pos));\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Compute pressure for Laplacian equation ∇²P = ∇.U*\n//\n// The Jacobi method would iterate on the array\n//   p_i,j = 1/4 * (div_i,j + p_i+2,j + p_i-2,j + p_i,j+2 + p_i,j-2)\n// But since we work in-place in BufferC, this is more a Gauss-Seidel method!\n//\n// Created by Pascal Massimino [skal] (2022)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define DIV(X, Y) texture(iChannel0, (pos + vec2(X, Y)) * norm).w\n#define P(X, Y)   texture(iChannel1, (pos + vec2(X, Y)) * norm).w  // re-use buf C\n\nvoid mainImage(out vec4 fragColor, in vec2 pos) {\n  vec2 norm = 1. / iResolution.xy;\n#if (KERNEL == 29)\n  float div = 0.;\n  div +=            1. * DIV(  0,-14);\n  div +=           14. * DIV( -1,-13);\n  div +=            4. * DIV(  0,-13);\n  div +=           14. * DIV(  1,-13);\n  div +=           91. * DIV( -2,-12);\n  div +=           52. * DIV( -1,-12);\n  div +=          212. * DIV(  0,-12);\n  div +=           52. * DIV(  1,-12);\n  div +=           91. * DIV(  2,-12);\n  div +=          364. * DIV( -3,-11);\n  div +=          312. * DIV( -2,-11);\n  div +=         1466. * DIV( -1,-11);\n  div +=          740. * DIV(  0,-11);\n  div +=         1466. * DIV(  1,-11);\n  div +=          312. * DIV(  2,-11);\n  div +=          364. * DIV(  3,-11);\n  div +=         1001. * DIV( -4,-10);\n  div +=         1144. * DIV( -3,-10);\n  div +=         6152. * DIV( -2,-10);\n  div +=         4760. * DIV( -1,-10);\n  div +=        10841. * DIV(  0,-10);\n  div +=         4760. * DIV(  1,-10);\n  div +=         6152. * DIV(  2,-10);\n  div +=         1144. * DIV(  3,-10);\n  div +=         1001. * DIV(  4,-10);\n  div +=         2002. * DIV( -5, -9);\n  div +=         2860. * DIV( -4, -9);\n  div +=        17534. * DIV( -3, -9);\n  div +=        18392. * DIV( -2, -9);\n  div +=        48356. * DIV( -1, -9);\n  div +=        33104. * DIV(  0, -9);\n  div +=        48356. * DIV(  1, -9);\n  div +=        18392. * DIV(  2, -9);\n  div +=        17534. * DIV(  3, -9);\n  div +=         2860. * DIV(  4, -9);\n  div +=         2002. * DIV(  5, -9);\n  div +=         3003. * DIV( -6, -8);\n  div +=         5148. * DIV( -5, -8);\n  div +=        35948. * DIV( -4, -8);\n  div +=        47740. * DIV( -3, -8);\n  div +=       144851. * DIV( -2, -8);\n  div +=       137168. * DIV( -1, -8);\n  div +=       231888. * DIV(  0, -8);\n  div +=       137168. * DIV(  1, -8);\n  div +=       144851. * DIV(  2, -8);\n  div +=        47740. * DIV(  3, -8);\n  div +=        35948. * DIV(  4, -8);\n  div +=         5148. * DIV(  5, -8);\n  div +=         3003. * DIV(  6, -8);\n  div +=         3432. * DIV( -7, -7);\n  div +=         6864. * DIV( -6, -7);\n  div +=        54714. * DIV( -5, -7);\n  div +=        88044. * DIV( -4, -7);\n  div +=       307942. * DIV( -3, -7);\n  div +=       376104. * DIV( -2, -7);\n  div +=       744652. * DIV( -1, -7);\n  div +=       620112. * DIV(  0, -7);\n  div +=       744652. * DIV(  1, -7);\n  div +=       376104. * DIV(  2, -7);\n  div +=       307942. * DIV(  3, -7);\n  div +=        88044. * DIV(  4, -7);\n  div +=        54714. * DIV(  5, -7);\n  div +=         6864. * DIV(  6, -7);\n  div +=         3432. * DIV(  7, -7);\n  div +=         3003. * DIV( -8, -6);\n  div +=         6864. * DIV( -7, -6);\n  div +=        62832. * DIV( -6, -6);\n  div +=       118800. * DIV( -5, -6);\n  div +=       479097. * DIV( -4, -6);\n  div +=       719880. * DIV( -3, -6);\n  div +=      1673336. * DIV( -2, -6);\n  div +=      1845224. * DIV( -1, -6);\n  div +=      2622481. * DIV(  0, -6);\n  div +=      1845224. * DIV(  1, -6);\n  div +=      1673336. * DIV(  2, -6);\n  div +=       719880. * DIV(  3, -6);\n  div +=       479097. * DIV(  4, -6);\n  div +=       118800. * DIV(  5, -6);\n  div +=        62832. * DIV(  6, -6);\n  div +=         6864. * DIV(  7, -6);\n  div +=         3003. * DIV(  8, -6);\n  div +=         2002. * DIV( -9, -5);\n  div +=         5148. * DIV( -8, -5);\n  div +=        54714. * DIV( -7, -5);\n  div +=       118800. * DIV( -6, -5);\n  div +=       554232. * DIV( -5, -5);\n  div +=       989664. * DIV( -4, -5);\n  div +=      2696420. * DIV( -3, -5);\n  div +=      3752136. * DIV( -2, -5);\n  div +=      6439522. * DIV( -1, -5);\n  div +=      6179364. * DIV(  0, -5);\n  div +=      6439522. * DIV(  1, -5);\n  div +=      3752136. * DIV(  2, -5);\n  div +=      2696420. * DIV(  3, -5);\n  div +=       989664. * DIV(  4, -5);\n  div +=       554232. * DIV(  5, -5);\n  div +=       118800. * DIV(  6, -5);\n  div +=        54714. * DIV(  7, -5);\n  div +=         5148. * DIV(  8, -5);\n  div +=         2002. * DIV(  9, -5);\n  div +=         1001. * DIV(-10, -4);\n  div +=         2860. * DIV( -9, -4);\n  div +=        35948. * DIV( -8, -4);\n  div +=        88044. * DIV( -7, -4);\n  div +=       479097. * DIV( -6, -4);\n  div +=       989664. * DIV( -5, -4);\n  div +=      3156832. * DIV( -4, -4);\n  div +=      5324000. * DIV( -3, -4);\n  div +=     11031091. * DIV( -2, -4);\n  div +=     13981364. * DIV( -1, -4);\n  div +=     18233940. * DIV(  0, -4);\n  div +=     13981364. * DIV(  1, -4);\n  div +=     11031091. * DIV(  2, -4);\n  div +=      5324000. * DIV(  3, -4);\n  div +=      3156832. * DIV(  4, -4);\n  div +=       989664. * DIV(  5, -4);\n  div +=       479097. * DIV(  6, -4);\n  div +=        88044. * DIV(  7, -4);\n  div +=        35948. * DIV(  8, -4);\n  div +=         2860. * DIV(  9, -4);\n  div +=         1001. * DIV( 10, -4);\n  div +=          364. * DIV(-11, -3);\n  div +=         1144. * DIV(-10, -3);\n  div +=        17534. * DIV( -9, -3);\n  div +=        47740. * DIV( -8, -3);\n  div +=       307942. * DIV( -7, -3);\n  div +=       719880. * DIV( -6, -3);\n  div +=      2696420. * DIV( -5, -3);\n  div +=      5324000. * DIV( -4, -3);\n  div +=     13195432. * DIV( -3, -3);\n  div +=     21066864. * DIV( -2, -3);\n  div +=     35250918. * DIV( -1, -3);\n  div +=     38793668. * DIV(  0, -3);\n  div +=     35250918. * DIV(  1, -3);\n  div +=     21066864. * DIV(  2, -3);\n  div +=     13195432. * DIV(  3, -3);\n  div +=      5324000. * DIV(  4, -3);\n  div +=      2696420. * DIV(  5, -3);\n  div +=       719880. * DIV(  6, -3);\n  div +=       307942. * DIV(  7, -3);\n  div +=        47740. * DIV(  8, -3);\n  div +=        17534. * DIV(  9, -3);\n  div +=         1144. * DIV( 10, -3);\n  div +=          364. * DIV( 11, -3);\n  div +=           91. * DIV(-12, -2);\n  div +=          312. * DIV(-11, -2);\n  div +=         6152. * DIV(-10, -2);\n  div +=        18392. * DIV( -9, -2);\n  div +=       144851. * DIV( -8, -2);\n  div +=       376104. * DIV( -7, -2);\n  div +=      1673336. * DIV( -6, -2);\n  div +=      3752136. * DIV( -5, -2);\n  div +=     11031091. * DIV( -4, -2);\n  div +=     21066864. * DIV( -3, -2);\n  div +=     44114320. * DIV( -2, -2);\n  div +=     67161776. * DIV( -1, -2);\n  div +=     91488921. * DIV(  0, -2);\n  div +=     67161776. * DIV(  1, -2);\n  div +=     44114320. * DIV(  2, -2);\n  div +=     21066864. * DIV(  3, -2);\n  div +=     11031091. * DIV(  4, -2);\n  div +=      3752136. * DIV(  5, -2);\n  div +=      1673336. * DIV(  6, -2);\n  div +=       376104. * DIV(  7, -2);\n  div +=       144851. * DIV(  8, -2);\n  div +=        18392. * DIV(  9, -2);\n  div +=         6152. * DIV( 10, -2);\n  div +=          312. * DIV( 11, -2);\n  div +=           91. * DIV( 12, -2);\n  div +=           14. * DIV(-13, -1);\n  div +=           52. * DIV(-12, -1);\n  div +=         1466. * DIV(-11, -1);\n  div +=         4760. * DIV(-10, -1);\n  div +=        48356. * DIV( -9, -1);\n  div +=       137168. * DIV( -8, -1);\n  div +=       744652. * DIV( -7, -1);\n  div +=      1845224. * DIV( -6, -1);\n  div +=      6439522. * DIV( -5, -1);\n  div +=     13981364. * DIV( -4, -1);\n  div +=     35250918. * DIV( -3, -1);\n  div +=     67161776. * DIV( -2, -1);\n  div +=    130000120. * DIV( -1, -1);\n  div +=    192838464. * DIV(  0, -1);\n  div +=    130000120. * DIV(  1, -1);\n  div +=     67161776. * DIV(  2, -1);\n  div +=     35250918. * DIV(  3, -1);\n  div +=     13981364. * DIV(  4, -1);\n  div +=      6439522. * DIV(  5, -1);\n  div +=      1845224. * DIV(  6, -1);\n  div +=       744652. * DIV(  7, -1);\n  div +=       137168. * DIV(  8, -1);\n  div +=        48356. * DIV(  9, -1);\n  div +=         4760. * DIV( 10, -1);\n  div +=         1466. * DIV( 11, -1);\n  div +=           52. * DIV( 12, -1);\n  div +=           14. * DIV( 13, -1);\n  div +=            1. * DIV(-14,  0);\n  div +=            4. * DIV(-13,  0);\n  div +=          212. * DIV(-12,  0);\n  div +=          740. * DIV(-11,  0);\n  div +=        10841. * DIV(-10,  0);\n  div +=        33104. * DIV( -9,  0);\n  div +=       231888. * DIV( -8,  0);\n  div +=       620112. * DIV( -7,  0);\n  div +=      2622481. * DIV( -6,  0);\n  div +=      6179364. * DIV( -5,  0);\n  div +=     18233940. * DIV( -4,  0);\n  div +=     38793668. * DIV( -3,  0);\n  div +=     91488921. * DIV( -2,  0);\n  div +=    192838464. * DIV( -1,  0);\n  div +=    461273920. * DIV(  0,  0);\n  div +=    192838464. * DIV(  1,  0);\n  div +=     91488921. * DIV(  2,  0);\n  div +=     38793668. * DIV(  3,  0);\n  div +=     18233940. * DIV(  4,  0);\n  div +=      6179364. * DIV(  5,  0);\n  div +=      2622481. * DIV(  6,  0);\n  div +=       620112. * DIV(  7,  0);\n  div +=       231888. * DIV(  8,  0);\n  div +=        33104. * DIV(  9,  0);\n  div +=        10841. * DIV( 10,  0);\n  div +=          740. * DIV( 11,  0);\n  div +=          212. * DIV( 12,  0);\n  div +=            4. * DIV( 13,  0);\n  div +=            1. * DIV( 14,  0);\n  div +=           14. * DIV(-13,  1);\n  div +=           52. * DIV(-12,  1);\n  div +=         1466. * DIV(-11,  1);\n  div +=         4760. * DIV(-10,  1);\n  div +=        48356. * DIV( -9,  1);\n  div +=       137168. * DIV( -8,  1);\n  div +=       744652. * DIV( -7,  1);\n  div +=      1845224. * DIV( -6,  1);\n  div +=      6439522. * DIV( -5,  1);\n  div +=     13981364. * DIV( -4,  1);\n  div +=     35250918. * DIV( -3,  1);\n  div +=     67161776. * DIV( -2,  1);\n  div +=    130000120. * DIV( -1,  1);\n  div +=    192838464. * DIV(  0,  1);\n  div +=    130000120. * DIV(  1,  1);\n  div +=     67161776. * DIV(  2,  1);\n  div +=     35250918. * DIV(  3,  1);\n  div +=     13981364. * DIV(  4,  1);\n  div +=      6439522. * DIV(  5,  1);\n  div +=      1845224. * DIV(  6,  1);\n  div +=       744652. * DIV(  7,  1);\n  div +=       137168. * DIV(  8,  1);\n  div +=        48356. * DIV(  9,  1);\n  div +=         4760. * DIV( 10,  1);\n  div +=         1466. * DIV( 11,  1);\n  div +=           52. * DIV( 12,  1);\n  div +=           14. * DIV( 13,  1);\n  div +=           91. * DIV(-12,  2);\n  div +=          312. * DIV(-11,  2);\n  div +=         6152. * DIV(-10,  2);\n  div +=        18392. * DIV( -9,  2);\n  div +=       144851. * DIV( -8,  2);\n  div +=       376104. * DIV( -7,  2);\n  div +=      1673336. * DIV( -6,  2);\n  div +=      3752136. * DIV( -5,  2);\n  div +=     11031091. * DIV( -4,  2);\n  div +=     21066864. * DIV( -3,  2);\n  div +=     44114320. * DIV( -2,  2);\n  div +=     67161776. * DIV( -1,  2);\n  div +=     91488921. * DIV(  0,  2);\n  div +=     67161776. * DIV(  1,  2);\n  div +=     44114320. * DIV(  2,  2);\n  div +=     21066864. * DIV(  3,  2);\n  div +=     11031091. * DIV(  4,  2);\n  div +=      3752136. * DIV(  5,  2);\n  div +=      1673336. * DIV(  6,  2);\n  div +=       376104. * DIV(  7,  2);\n  div +=       144851. * DIV(  8,  2);\n  div +=        18392. * DIV(  9,  2);\n  div +=         6152. * DIV( 10,  2);\n  div +=          312. * DIV( 11,  2);\n  div +=           91. * DIV( 12,  2);\n  div +=          364. * DIV(-11,  3);\n  div +=         1144. * DIV(-10,  3);\n  div +=        17534. * DIV( -9,  3);\n  div +=        47740. * DIV( -8,  3);\n  div +=       307942. * DIV( -7,  3);\n  div +=       719880. * DIV( -6,  3);\n  div +=      2696420. * DIV( -5,  3);\n  div +=      5324000. * DIV( -4,  3);\n  div +=     13195432. * DIV( -3,  3);\n  div +=     21066864. * DIV( -2,  3);\n  div +=     35250918. * DIV( -1,  3);\n  div +=     38793668. * DIV(  0,  3);\n  div +=     35250918. * DIV(  1,  3);\n  div +=     21066864. * DIV(  2,  3);\n  div +=     13195432. * DIV(  3,  3);\n  div +=      5324000. * DIV(  4,  3);\n  div +=      2696420. * DIV(  5,  3);\n  div +=       719880. * DIV(  6,  3);\n  div +=       307942. * DIV(  7,  3);\n  div +=        47740. * DIV(  8,  3);\n  div +=        17534. * DIV(  9,  3);\n  div +=         1144. * DIV( 10,  3);\n  div +=          364. * DIV( 11,  3);\n  div +=         1001. * DIV(-10,  4);\n  div +=         2860. * DIV( -9,  4);\n  div +=        35948. * DIV( -8,  4);\n  div +=        88044. * DIV( -7,  4);\n  div +=       479097. * DIV( -6,  4);\n  div +=       989664. * DIV( -5,  4);\n  div +=      3156832. * DIV( -4,  4);\n  div +=      5324000. * DIV( -3,  4);\n  div +=     11031091. * DIV( -2,  4);\n  div +=     13981364. * DIV( -1,  4);\n  div +=     18233940. * DIV(  0,  4);\n  div +=     13981364. * DIV(  1,  4);\n  div +=     11031091. * DIV(  2,  4);\n  div +=      5324000. * DIV(  3,  4);\n  div +=      3156832. * DIV(  4,  4);\n  div +=       989664. * DIV(  5,  4);\n  div +=       479097. * DIV(  6,  4);\n  div +=        88044. * DIV(  7,  4);\n  div +=        35948. * DIV(  8,  4);\n  div +=         2860. * DIV(  9,  4);\n  div +=         1001. * DIV( 10,  4);\n  div +=         2002. * DIV( -9,  5);\n  div +=         5148. * DIV( -8,  5);\n  div +=        54714. * DIV( -7,  5);\n  div +=       118800. * DIV( -6,  5);\n  div +=       554232. * DIV( -5,  5);\n  div +=       989664. * DIV( -4,  5);\n  div +=      2696420. * DIV( -3,  5);\n  div +=      3752136. * DIV( -2,  5);\n  div +=      6439522. * DIV( -1,  5);\n  div +=      6179364. * DIV(  0,  5);\n  div +=      6439522. * DIV(  1,  5);\n  div +=      3752136. * DIV(  2,  5);\n  div +=      2696420. * DIV(  3,  5);\n  div +=       989664. * DIV(  4,  5);\n  div +=       554232. * DIV(  5,  5);\n  div +=       118800. * DIV(  6,  5);\n  div +=        54714. * DIV(  7,  5);\n  div +=         5148. * DIV(  8,  5);\n  div +=         2002. * DIV(  9,  5);\n  div +=         3003. * DIV( -8,  6);\n  div +=         6864. * DIV( -7,  6);\n  div +=        62832. * DIV( -6,  6);\n  div +=       118800. * DIV( -5,  6);\n  div +=       479097. * DIV( -4,  6);\n  div +=       719880. * DIV( -3,  6);\n  div +=      1673336. * DIV( -2,  6);\n  div +=      1845224. * DIV( -1,  6);\n  div +=      2622481. * DIV(  0,  6);\n  div +=      1845224. * DIV(  1,  6);\n  div +=      1673336. * DIV(  2,  6);\n  div +=       719880. * DIV(  3,  6);\n  div +=       479097. * DIV(  4,  6);\n  div +=       118800. * DIV(  5,  6);\n  div +=        62832. * DIV(  6,  6);\n  div +=         6864. * DIV(  7,  6);\n  div +=         3003. * DIV(  8,  6);\n  div +=         3432. * DIV( -7,  7);\n  div +=         6864. * DIV( -6,  7);\n  div +=        54714. * DIV( -5,  7);\n  div +=        88044. * DIV( -4,  7);\n  div +=       307942. * DIV( -3,  7);\n  div +=       376104. * DIV( -2,  7);\n  div +=       744652. * DIV( -1,  7);\n  div +=       620112. * DIV(  0,  7);\n  div +=       744652. * DIV(  1,  7);\n  div +=       376104. * DIV(  2,  7);\n  div +=       307942. * DIV(  3,  7);\n  div +=        88044. * DIV(  4,  7);\n  div +=        54714. * DIV(  5,  7);\n  div +=         6864. * DIV(  6,  7);\n  div +=         3432. * DIV(  7,  7);\n  div +=         3003. * DIV( -6,  8);\n  div +=         5148. * DIV( -5,  8);\n  div +=        35948. * DIV( -4,  8);\n  div +=        47740. * DIV( -3,  8);\n  div +=       144851. * DIV( -2,  8);\n  div +=       137168. * DIV( -1,  8);\n  div +=       231888. * DIV(  0,  8);\n  div +=       137168. * DIV(  1,  8);\n  div +=       144851. * DIV(  2,  8);\n  div +=        47740. * DIV(  3,  8);\n  div +=        35948. * DIV(  4,  8);\n  div +=         5148. * DIV(  5,  8);\n  div +=         3003. * DIV(  6,  8);\n  div +=         2002. * DIV( -5,  9);\n  div +=         2860. * DIV( -4,  9);\n  div +=        17534. * DIV( -3,  9);\n  div +=        18392. * DIV( -2,  9);\n  div +=        48356. * DIV( -1,  9);\n  div +=        33104. * DIV(  0,  9);\n  div +=        48356. * DIV(  1,  9);\n  div +=        18392. * DIV(  2,  9);\n  div +=        17534. * DIV(  3,  9);\n  div +=         2860. * DIV(  4,  9);\n  div +=         2002. * DIV(  5,  9);\n  div +=         1001. * DIV( -4, 10);\n  div +=         1144. * DIV( -3, 10);\n  div +=         6152. * DIV( -2, 10);\n  div +=         4760. * DIV( -1, 10);\n  div +=        10841. * DIV(  0, 10);\n  div +=         4760. * DIV(  1, 10);\n  div +=         6152. * DIV(  2, 10);\n  div +=         1144. * DIV(  3, 10);\n  div +=         1001. * DIV(  4, 10);\n  div +=          364. * DIV( -3, 11);\n  div +=          312. * DIV( -2, 11);\n  div +=         1466. * DIV( -1, 11);\n  div +=          740. * DIV(  0, 11);\n  div +=         1466. * DIV(  1, 11);\n  div +=          312. * DIV(  2, 11);\n  div +=          364. * DIV(  3, 11);\n  div +=           91. * DIV( -2, 12);\n  div +=           52. * DIV( -1, 12);\n  div +=          212. * DIV(  0, 12);\n  div +=           52. * DIV(  1, 12);\n  div +=           91. * DIV(  2, 12);\n  div +=           14. * DIV( -1, 13);\n  div +=            4. * DIV(  0, 13);\n  div +=           14. * DIV(  1, 13);\n  div +=            1. * DIV(  0, 14);\n  div /= 1073741824.;\n  float p = 0.;\n  p +=            1. * P(  0,-15);\n  p +=           15. * P( -1,-14);\n  p +=           15. * P(  1,-14);\n  p +=          105. * P( -2,-13);\n  p +=          225. * P(  0,-13);\n  p +=          105. * P(  2,-13);\n  p +=          455. * P( -3,-12);\n  p +=         1575. * P( -1,-12);\n  p +=         1575. * P(  1,-12);\n  p +=          455. * P(  3,-12);\n  p +=         1365. * P( -4,-11);\n  p +=         6825. * P( -2,-11);\n  p +=        11025. * P(  0,-11);\n  p +=         6825. * P(  2,-11);\n  p +=         1365. * P(  4,-11);\n  p +=         3003. * P( -5,-10);\n  p +=        20475. * P( -3,-10);\n  p +=        47775. * P( -1,-10);\n  p +=        47775. * P(  1,-10);\n  p +=        20475. * P(  3,-10);\n  p +=         3003. * P(  5,-10);\n  p +=         5005. * P( -6, -9);\n  p +=        45045. * P( -4, -9);\n  p +=       143325. * P( -2, -9);\n  p +=       207025. * P(  0, -9);\n  p +=       143325. * P(  2, -9);\n  p +=        45045. * P(  4, -9);\n  p +=         5005. * P(  6, -9);\n  p +=         6435. * P( -7, -8);\n  p +=        75075. * P( -5, -8);\n  p +=       315315. * P( -3, -8);\n  p +=       621075. * P( -1, -8);\n  p +=       621075. * P(  1, -8);\n  p +=       315315. * P(  3, -8);\n  p +=        75075. * P(  5, -8);\n  p +=         6435. * P(  7, -8);\n  p +=         6435. * P( -8, -7);\n  p +=        96525. * P( -6, -7);\n  p +=       525525. * P( -4, -7);\n  p +=      1366365. * P( -2, -7);\n  p +=      1863225. * P(  0, -7);\n  p +=      1366365. * P(  2, -7);\n  p +=       525525. * P(  4, -7);\n  p +=        96525. * P(  6, -7);\n  p +=         6435. * P(  8, -7);\n  p +=         5005. * P( -9, -6);\n  p +=        96525. * P( -7, -6);\n  p +=       675675. * P( -5, -6);\n  p +=      2277275. * P( -3, -6);\n  p +=      4099095. * P( -1, -6);\n  p +=      4099095. * P(  1, -6);\n  p +=      2277275. * P(  3, -6);\n  p +=       675675. * P(  5, -6);\n  p +=        96525. * P(  7, -6);\n  p +=         5005. * P(  9, -6);\n  p +=         3003. * P(-10, -5);\n  p +=        75075. * P( -8, -5);\n  p +=       675675. * P( -6, -5);\n  p +=      2927925. * P( -4, -5);\n  p +=      6831825. * P( -2, -5);\n  p +=      9018009. * P(  0, -5);\n  p +=      6831825. * P(  2, -5);\n  p +=      2927925. * P(  4, -5);\n  p +=       675675. * P(  6, -5);\n  p +=        75075. * P(  8, -5);\n  p +=         3003. * P( 10, -5);\n  p +=         1365. * P(-11, -4);\n  p +=        45045. * P( -9, -4);\n  p +=       525525. * P( -7, -4);\n  p +=      2927925. * P( -5, -4);\n  p +=      8783775. * P( -3, -4);\n  p +=     15030015. * P( -1, -4);\n  p +=     15030015. * P(  1, -4);\n  p +=      8783775. * P(  3, -4);\n  p +=      2927925. * P(  5, -4);\n  p +=       525525. * P(  7, -4);\n  p +=        45045. * P(  9, -4);\n  p +=         1365. * P( 11, -4);\n  p +=          455. * P(-12, -3);\n  p +=        20475. * P(-10, -3);\n  p +=       315315. * P( -8, -3);\n  p +=      2277275. * P( -6, -3);\n  p +=      8783775. * P( -4, -3);\n  p +=     19324305. * P( -2, -3);\n  p +=     25050025. * P(  0, -3);\n  p +=     19324305. * P(  2, -3);\n  p +=      8783775. * P(  4, -3);\n  p +=      2277275. * P(  6, -3);\n  p +=       315315. * P(  8, -3);\n  p +=        20475. * P( 10, -3);\n  p +=          455. * P( 12, -3);\n  p +=          105. * P(-13, -2);\n  p +=         6825. * P(-11, -2);\n  p +=       143325. * P( -9, -2);\n  p +=      1366365. * P( -7, -2);\n  p +=      6831825. * P( -5, -2);\n  p +=     19324305. * P( -3, -2);\n  p +=     32207175. * P( -1, -2);\n  p +=     32207175. * P(  1, -2);\n  p +=     19324305. * P(  3, -2);\n  p +=      6831825. * P(  5, -2);\n  p +=      1366365. * P(  7, -2);\n  p +=       143325. * P(  9, -2);\n  p +=         6825. * P( 11, -2);\n  p +=          105. * P( 13, -2);\n  p +=           15. * P(-14, -1);\n  p +=         1575. * P(-12, -1);\n  p +=        47775. * P(-10, -1);\n  p +=       621075. * P( -8, -1);\n  p +=      4099095. * P( -6, -1);\n  p +=     15030015. * P( -4, -1);\n  p +=     32207175. * P( -2, -1);\n  p +=     41409225. * P(  0, -1);\n  p +=     32207175. * P(  2, -1);\n  p +=     15030015. * P(  4, -1);\n  p +=      4099095. * P(  6, -1);\n  p +=       621075. * P(  8, -1);\n  p +=        47775. * P( 10, -1);\n  p +=         1575. * P( 12, -1);\n  p +=           15. * P( 14, -1);\n  p +=            1. * P(-15,  0);\n  p +=          225. * P(-13,  0);\n  p +=        11025. * P(-11,  0);\n  p +=       207025. * P( -9,  0);\n  p +=      1863225. * P( -7,  0);\n  p +=      9018009. * P( -5,  0);\n  p +=     25050025. * P( -3,  0);\n  p +=     41409225. * P( -1,  0);\n  p +=     41409225. * P(  1,  0);\n  p +=     25050025. * P(  3,  0);\n  p +=      9018009. * P(  5,  0);\n  p +=      1863225. * P(  7,  0);\n  p +=       207025. * P(  9,  0);\n  p +=        11025. * P( 11,  0);\n  p +=          225. * P( 13,  0);\n  p +=            1. * P( 15,  0);\n  p +=           15. * P(-14,  1);\n  p +=         1575. * P(-12,  1);\n  p +=        47775. * P(-10,  1);\n  p +=       621075. * P( -8,  1);\n  p +=      4099095. * P( -6,  1);\n  p +=     15030015. * P( -4,  1);\n  p +=     32207175. * P( -2,  1);\n  p +=     41409225. * P(  0,  1);\n  p +=     32207175. * P(  2,  1);\n  p +=     15030015. * P(  4,  1);\n  p +=      4099095. * P(  6,  1);\n  p +=       621075. * P(  8,  1);\n  p +=        47775. * P( 10,  1);\n  p +=         1575. * P( 12,  1);\n  p +=           15. * P( 14,  1);\n  p +=          105. * P(-13,  2);\n  p +=         6825. * P(-11,  2);\n  p +=       143325. * P( -9,  2);\n  p +=      1366365. * P( -7,  2);\n  p +=      6831825. * P( -5,  2);\n  p +=     19324305. * P( -3,  2);\n  p +=     32207175. * P( -1,  2);\n  p +=     32207175. * P(  1,  2);\n  p +=     19324305. * P(  3,  2);\n  p +=      6831825. * P(  5,  2);\n  p +=      1366365. * P(  7,  2);\n  p +=       143325. * P(  9,  2);\n  p +=         6825. * P( 11,  2);\n  p +=          105. * P( 13,  2);\n  p +=          455. * P(-12,  3);\n  p +=        20475. * P(-10,  3);\n  p +=       315315. * P( -8,  3);\n  p +=      2277275. * P( -6,  3);\n  p +=      8783775. * P( -4,  3);\n  p +=     19324305. * P( -2,  3);\n  p +=     25050025. * P(  0,  3);\n  p +=     19324305. * P(  2,  3);\n  p +=      8783775. * P(  4,  3);\n  p +=      2277275. * P(  6,  3);\n  p +=       315315. * P(  8,  3);\n  p +=        20475. * P( 10,  3);\n  p +=          455. * P( 12,  3);\n  p +=         1365. * P(-11,  4);\n  p +=        45045. * P( -9,  4);\n  p +=       525525. * P( -7,  4);\n  p +=      2927925. * P( -5,  4);\n  p +=      8783775. * P( -3,  4);\n  p +=     15030015. * P( -1,  4);\n  p +=     15030015. * P(  1,  4);\n  p +=      8783775. * P(  3,  4);\n  p +=      2927925. * P(  5,  4);\n  p +=       525525. * P(  7,  4);\n  p +=        45045. * P(  9,  4);\n  p +=         1365. * P( 11,  4);\n  p +=         3003. * P(-10,  5);\n  p +=        75075. * P( -8,  5);\n  p +=       675675. * P( -6,  5);\n  p +=      2927925. * P( -4,  5);\n  p +=      6831825. * P( -2,  5);\n  p +=      9018009. * P(  0,  5);\n  p +=      6831825. * P(  2,  5);\n  p +=      2927925. * P(  4,  5);\n  p +=       675675. * P(  6,  5);\n  p +=        75075. * P(  8,  5);\n  p +=         3003. * P( 10,  5);\n  p +=         5005. * P( -9,  6);\n  p +=        96525. * P( -7,  6);\n  p +=       675675. * P( -5,  6);\n  p +=      2277275. * P( -3,  6);\n  p +=      4099095. * P( -1,  6);\n  p +=      4099095. * P(  1,  6);\n  p +=      2277275. * P(  3,  6);\n  p +=       675675. * P(  5,  6);\n  p +=        96525. * P(  7,  6);\n  p +=         5005. * P(  9,  6);\n  p +=         6435. * P( -8,  7);\n  p +=        96525. * P( -6,  7);\n  p +=       525525. * P( -4,  7);\n  p +=      1366365. * P( -2,  7);\n  p +=      1863225. * P(  0,  7);\n  p +=      1366365. * P(  2,  7);\n  p +=       525525. * P(  4,  7);\n  p +=        96525. * P(  6,  7);\n  p +=         6435. * P(  8,  7);\n  p +=         6435. * P( -7,  8);\n  p +=        75075. * P( -5,  8);\n  p +=       315315. * P( -3,  8);\n  p +=       621075. * P( -1,  8);\n  p +=       621075. * P(  1,  8);\n  p +=       315315. * P(  3,  8);\n  p +=        75075. * P(  5,  8);\n  p +=         6435. * P(  7,  8);\n  p +=         5005. * P( -6,  9);\n  p +=        45045. * P( -4,  9);\n  p +=       143325. * P( -2,  9);\n  p +=       207025. * P(  0,  9);\n  p +=       143325. * P(  2,  9);\n  p +=        45045. * P(  4,  9);\n  p +=         5005. * P(  6,  9);\n  p +=         3003. * P( -5, 10);\n  p +=        20475. * P( -3, 10);\n  p +=        47775. * P( -1, 10);\n  p +=        47775. * P(  1, 10);\n  p +=        20475. * P(  3, 10);\n  p +=         3003. * P(  5, 10);\n  p +=         1365. * P( -4, 11);\n  p +=         6825. * P( -2, 11);\n  p +=        11025. * P(  0, 11);\n  p +=         6825. * P(  2, 11);\n  p +=         1365. * P(  4, 11);\n  p +=          455. * P( -3, 12);\n  p +=         1575. * P( -1, 12);\n  p +=         1575. * P(  1, 12);\n  p +=          455. * P(  3, 12);\n  p +=          105. * P( -2, 13);\n  p +=          225. * P(  0, 13);\n  p +=          105. * P(  2, 13);\n  p +=           15. * P( -1, 14);\n  p +=           15. * P(  1, 14);\n  p +=            1. * P(  0, 15);\n  p /= 1073741824.;\n#elif (KERNEL == 11)\n  // This versions uses 11x11 kernel only\n  float div = 0.;\n  div +=            1. * DIV(  0, -5);\n  div +=            5. * DIV( -1, -4);\n  div +=            4. * DIV(  0, -4);\n  div +=            5. * DIV(  1, -4);\n  div +=           10. * DIV( -2, -3);\n  div +=           16. * DIV( -1, -3);\n  div +=           41. * DIV(  0, -3);\n  div +=           16. * DIV(  1, -3);\n  div +=           10. * DIV(  2, -3);\n  div +=           10. * DIV( -3, -2);\n  div +=           24. * DIV( -2, -2);\n  div +=           98. * DIV( -1, -2);\n  div +=          128. * DIV(  0, -2);\n  div +=           98. * DIV(  1, -2);\n  div +=           24. * DIV(  2, -2);\n  div +=           10. * DIV(  3, -2);\n  div +=            5. * DIV( -4, -1);\n  div +=           16. * DIV( -3, -1);\n  div +=           98. * DIV( -2, -1);\n  div +=          224. * DIV( -1, -1);\n  div +=          500. * DIV(  0, -1);\n  div +=          224. * DIV(  1, -1);\n  div +=           98. * DIV(  2, -1);\n  div +=           16. * DIV(  3, -1);\n  div +=            5. * DIV(  4, -1);\n  div +=            1. * DIV( -5,  0);\n  div +=            4. * DIV( -4,  0);\n  div +=           41. * DIV( -3,  0);\n  div +=          128. * DIV( -2,  0);\n  div +=          500. * DIV( -1,  0);\n  div +=         1424. * DIV(  0,  0);\n  div +=          500. * DIV(  1,  0);\n  div +=          128. * DIV(  2,  0);\n  div +=           41. * DIV(  3,  0);\n  div +=            4. * DIV(  4,  0);\n  div +=            1. * DIV(  5,  0);\n  div +=            5. * DIV( -4,  1);\n  div +=           16. * DIV( -3,  1);\n  div +=           98. * DIV( -2,  1);\n  div +=          224. * DIV( -1,  1);\n  div +=          500. * DIV(  0,  1);\n  div +=          224. * DIV(  1,  1);\n  div +=           98. * DIV(  2,  1);\n  div +=           16. * DIV(  3,  1);\n  div +=            5. * DIV(  4,  1);\n  div +=           10. * DIV( -3,  2);\n  div +=           24. * DIV( -2,  2);\n  div +=           98. * DIV( -1,  2);\n  div +=          128. * DIV(  0,  2);\n  div +=           98. * DIV(  1,  2);\n  div +=           24. * DIV(  2,  2);\n  div +=           10. * DIV(  3,  2);\n  div +=           10. * DIV( -2,  3);\n  div +=           16. * DIV( -1,  3);\n  div +=           41. * DIV(  0,  3);\n  div +=           16. * DIV(  1,  3);\n  div +=           10. * DIV(  2,  3);\n  div +=            5. * DIV( -1,  4);\n  div +=            4. * DIV(  0,  4);\n  div +=            5. * DIV(  1,  4);\n  div +=            1. * DIV(  0,  5);\n  div /= 4096.;\n  float p = 0.;\n  p +=            1. * P(  0, -6);\n  p +=            6. * P( -1, -5);\n  p +=            6. * P(  1, -5);\n  p +=           15. * P( -2, -4);\n  p +=           36. * P(  0, -4);\n  p +=           15. * P(  2, -4);\n  p +=           20. * P( -3, -3);\n  p +=           90. * P( -1, -3);\n  p +=           90. * P(  1, -3);\n  p +=           20. * P(  3, -3);\n  p +=           15. * P( -4, -2);\n  p +=          120. * P( -2, -2);\n  p +=          225. * P(  0, -2);\n  p +=          120. * P(  2, -2);\n  p +=           15. * P(  4, -2);\n  p +=            6. * P( -5, -1);\n  p +=           90. * P( -3, -1);\n  p +=          300. * P( -1, -1);\n  p +=          300. * P(  1, -1);\n  p +=           90. * P(  3, -1);\n  p +=            6. * P(  5, -1);\n  p +=            1. * P( -6,  0);\n  p +=           36. * P( -4,  0);\n  p +=          225. * P( -2,  0);\n  p +=          400. * P(  0,  0);\n  p +=          225. * P(  2,  0);\n  p +=           36. * P(  4,  0);\n  p +=            1. * P(  6,  0);\n  p +=            6. * P( -5,  1);\n  p +=           90. * P( -3,  1);\n  p +=          300. * P( -1,  1);\n  p +=          300. * P(  1,  1);\n  p +=           90. * P(  3,  1);\n  p +=            6. * P(  5,  1);\n  p +=           15. * P( -4,  2);\n  p +=          120. * P( -2,  2);\n  p +=          225. * P(  0,  2);\n  p +=          120. * P(  2,  2);\n  p +=           15. * P(  4,  2);\n  p +=           20. * P( -3,  3);\n  p +=           90. * P( -1,  3);\n  p +=           90. * P(  1,  3);\n  p +=           20. * P(  3,  3);\n  p +=           15. * P( -2,  4);\n  p +=           36. * P(  0,  4);\n  p +=           15. * P(  2,  4);\n  p +=            6. * P( -1,  5);\n  p +=            6. * P(  1,  5);\n  p +=            1. * P(  0,  6);\n  p /= 4096.;\n#elif (KERNEL == 7)  // eventually a 7x7 version\n  float div = 0.;\n  div +=            1. * DIV(  0, -3);\n  div +=            3. * DIV( -1, -2);\n  div +=            4. * DIV(  0, -2);\n  div +=            3. * DIV(  1, -2);\n  div +=            3. * DIV( -2, -1);\n  div +=            8. * DIV( -1, -1);\n  div +=           25. * DIV(  0, -1);\n  div +=            8. * DIV(  1, -1);\n  div +=            3. * DIV(  2, -1);\n  div +=            1. * DIV( -3,  0);\n  div +=            4. * DIV( -2,  0);\n  div +=           25. * DIV( -1,  0);\n  div +=           80. * DIV(  0,  0);\n  div +=           25. * DIV(  1,  0);\n  div +=            4. * DIV(  2,  0);\n  div +=            1. * DIV(  3,  0);\n  div +=            3. * DIV( -2,  1);\n  div +=            8. * DIV( -1,  1);\n  div +=           25. * DIV(  0,  1);\n  div +=            8. * DIV(  1,  1);\n  div +=            3. * DIV(  2,  1);\n  div +=            3. * DIV( -1,  2);\n  div +=            4. * DIV(  0,  2);\n  div +=            3. * DIV(  1,  2);\n  div +=            1. * DIV(  0,  3);\n  div /= 256.;\n  float p = 0.;\n  p +=            1. * P(  0, -4);\n  p +=            4. * P( -1, -3);\n  p +=            4. * P(  1, -3);\n  p +=            6. * P( -2, -2);\n  p +=           16. * P(  0, -2);\n  p +=            6. * P(  2, -2);\n  p +=            4. * P( -3, -1);\n  p +=           24. * P( -1, -1);\n  p +=           24. * P(  1, -1);\n  p +=            4. * P(  3, -1);\n  p +=            1. * P( -4,  0);\n  p +=           16. * P( -2,  0);\n  p +=           36. * P(  0,  0);\n  p +=           16. * P(  2,  0);\n  p +=            1. * P(  4,  0);\n  p +=            4. * P( -3,  1);\n  p +=           24. * P( -1,  1);\n  p +=           24. * P(  1,  1);\n  p +=            4. * P(  3,  1);\n  p +=            6. * P( -2,  2);\n  p +=           16. * P(  0,  2);\n  p +=            6. * P(  2,  2);\n  p +=            4. * P( -1,  3);\n  p +=            4. * P(  1,  3);\n  p +=            1. * P(  0,  4);\n  p /= 256.;\n#elif (KERNEL == 3)\n  float div = 0.;\n  div +=            1. * DIV(  0, -1);\n  div +=            1. * DIV( -1,  0);\n  div +=            4. * DIV(  0,  0);\n  div +=            1. * DIV(  1,  0);\n  div +=            1. * DIV(  0,  1);\n  div /= 16.;\n  float p = 0.;\n  p +=            1. * P(  0, -2);\n  p +=            2. * P( -1, -1);\n  p +=            2. * P(  1, -1);\n  p +=            1. * P( -2,  0);\n  p +=            4. * P(  0,  0);\n  p +=            1. * P(  2,  0);\n  p +=            2. * P( -1,  1);\n  p +=            2. * P(  1,  1);\n  p +=            1. * P(  0,  2);\n  p /= 16.;\n#endif\n  fragColor = vec4(0., 0., 0., div + p);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Compute pressure gradient and subtracts to velocity\n// bufD = bufA - ∇(bufC) - nu.∇²(bufA) = new velocity\n//\n// Created by Pascal Massimino [skal] (2022)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 fragColor, in vec2 p) {\n  vec2 norm = 1. / iResolution.xy;\n  p *= norm;\n  vec2 dx = vec2(norm.x,     0.);\n  vec2 dy = vec2(    0., norm.y);\n  // compute grad(p) and subtract to velocity field\n  float gx = texture(iChannel0, p + dx).w\n           - texture(iChannel0, p - dx).w;\n  float gy = texture(iChannel0, p + dy).w\n           - texture(iChannel0, p - dy).w;\n  vec4 v = texture(iChannel1, p);\n  v.xy -= 0.5 * vec2(gx, gy);\n  // diffusion\n  vec2 laplacian = 4. * v.xy - (\n     texture(iChannel1, p + dx).xy + texture(iChannel1, p - dx).xy +\n     texture(iChannel1, p - dy).xy + texture(iChannel1, p - dy).xy);\n  v.xy += nu * laplacian;\n  fragColor = v;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Some constants.\n//\n// Created by Pascal Massimino [skal] (2022)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float dt = 1.0;     // step\nconst float Vo = 1.5;     // initial / typical velocity\nconst float nu = 0.0001;  // viscosity\n\nconst bool use_airfoil = true;    // balls or airfoil\n\n#define KERNEL 11 // kernel size for pressure solver: 29, 11, 7 or 3!\n#define RUNGE_KUTTA 4 // order: 4 (classic), 2 (midpoint) or 1 (Euler)\n\n// 0 = tracers, 1 = velocity, 2 = pressure, 3 = divergence\nint show_what = 0;\n\n// airfoil characteristics\nconst float FoilCamber = 0.3;   // higher = more bent\nconst float FoilSize = 120.;\nconst float FoilAlpha = 25.;   // angle of attack in degrees\n\nconst float kRadius = 12.;  // ball radius\n\nbool IsObstacle(vec2 mouse, vec2 pos) {\n  if (length(mouse) < 0.01) mouse = vec2(100., 180.);\n  pos = mouse - pos;\n\n  if (!use_airfoil) {    // array of balls:\n    return (length(vec2(pos.x, fract(abs(pos.y) / 50.) * 50.)) < kRadius);\n  }\n  // Airfoil profile following more or less NACA formulae\n  // see: https://en.wikipedia.org/wiki/NACA_airfoil#Equation_for_a_symmetrical_4-digit_NACA_airfoil\n  float alpha = 3.1415 * (180. + FoilAlpha) / 180.;  // angle of attack\n  mat2 M = mat2(cos(alpha), sin(alpha), -sin(alpha), cos(alpha)) / FoilSize;\n  pos = M * pos;\n  float x = pos.x, x2 = x * x;\n  if (x < 0. || x > 1.) return false;\n  // mor or le\n  // mean camber line\n  float xm = x * (1. - x) * FoilCamber;\n  // thickness\n  float th = 0.2969 * sqrt(x) - 0.1260 * x - 0.3516 * x2 + 0.2843 * x * x2 - 0.1036 * x2 * x2;\n  float y = pos.y - xm;\n  return abs(y) < th;\n}\n\n// For velocity field display:\nconst float kCell = 40.;\nconst float kVelocityUnit = 20.;\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2czK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1018, 1056, 1105, 1105, 1267], [1335, 1335, 1384, 1384, 2436]], "test": "untested"}
{"id": "sljcDc", "name": "Buitfull Planet", "author": "MrNissenDK", "description": "I have worked on making my Perlin noise interpolation better.\nMade a planet out of it", "tags": ["noise", "perlin", "rainbow", "colorfull"], "likes": 2, "viewed": 231, "published": 3, "date": "1650367558", "time_retrieved": "2024-07-30T16:52:48.184944", "image_code": "float seed = 437585453.123;\nfloat PI = 3.141592653589793;\nfloat res = 5.;\n\n\nvec3  water         = vec3(        0. ,        0. ,        1.  );\n\nfloat sandLevel     = 0.5;\nvec3  sand          = vec3( 229./255. , 223./255. , 136./255.  );\n\n\nfloat grassLevel    = 0.53;\nvec3  grass         = vec3(   0./255. , 154./255. ,  23./255.  );\n\n\nfloat mountainLevel = 0.69;\nvec3  mountain      = vec3(         .7,         .7,         .7 );\n\n\nfloat snowLevel     = 0.79;\nvec3  snow          = vec3(        1. ,        1. ,        1.  );\n\n\nfloat hash21(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec2 (127.1, 351.7));\n  return fract(sin(f)*a);\n}\n\nvec2 hash2(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  p = vec2(dot (p, vec2 (127.1, 351.7)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p)*a);\n}\n\nvec3 hash23(vec2 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec3 p3 = vec3(dot (p, vec2 (127.1, 351.7)), dot (p, vec2 (261.5, 183.3)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p3)*a);\n}\n\nvec2 hash32(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec2 p2 = vec2(dot (p, vec3 (127.1, 351.7, 251.45)), dot (p, vec3 (261.5, 183.3, 376.89)));\n  return fract(sin(p2)*a);\n}\nfloat hash31(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec3 (127.1, 351.7, 251.45));\n  return fract(sin(f)*a);\n}\n\n\nfloat ease(float t)\n{\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\nvec2 ease(vec2 t)\n{\n  return vec2(ease(t.x), ease(t.y));\n}\nvec3 ease(vec3 t)\n{\n  return vec3(ease(t.x), ease(t.y), ease(t.z));\n}\nvec4 ease(vec4 t)\n{\n  return vec4(ease(t.x), ease(t.y), ease(t.z), ease(t.w));\n}\n\nfloat noise(vec2 point){\n    vec2 fr = ease(fract(point));\n    vec2 hi = ceil(point);\n    vec2 lo = floor(point);\n    \n    return mix(\n        mix(\n            hash21(lo), \n            hash21(vec2(hi.x , lo.y)), \n            fr.x\n        ), \n        mix(\n            hash21(vec2(lo.x , hi.y)),\n            hash21(hi),\n            fr.x\n        ), \n        fr.y\n    );\n}\n\nfloat noise(vec3 point){\n    vec3 fr = ease(fract(point));\n    vec3 hi = ceil(point);\n    vec3 lo = floor(point);\n    \n    return mix(\n        mix(\n            mix(\n                hash31(lo), \n                hash31(vec3(hi.x , lo.yz)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.y, lo.z)),\n                hash31(vec3(hi.xy, lo.z)),\n                fr.x\n            ), \n            fr.y\n        ),\n        mix(\n            mix(\n                hash31(vec3(lo.xy, hi.z)), \n                hash31(vec3(hi.x , lo.y, hi.z)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.yz)),\n                hash31(hi),\n                fr.x\n            ), \n            fr.y\n        ),\n        fr.z\n    );\n}\n\nfloat octal(vec3 uv, int octaves, float persistence)\n{\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.;\n    for(int i=0;i<octaves;i++) {\n        total += noise(uv * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total/maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n   \n    float radius = 1.;\n    vec2 R = iResolution.xy;\n    \n\t\n    float mag = dot(uv,uv);\n    if( mag > 1.0 ){\n    \tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n    }\n    \n    \n    vec3 norm = vec3( uv, sqrt( 1.0 - mag ));\n    \n    float time = iTime;\n    float s = atan( norm.z, norm.x ) / (PI * 2.);\n    float t = asin( norm.y ) / PI;\n    float h = octal(\n        vec3(s * 5. +time, t * 5. + time * .075, 0. ),\n        8,\n        .5\n    );\n    vec3                   col = water;\n    if(h >     sandLevel ) col = sand;\n    if(h >    grassLevel ) col = grass;\n    if(h > mountainLevel ) col = mountain;\n    if(h >     snowLevel ) col = snow;\n    fragColor = vec4( vec3(col * h), 1. );\n    \n    \n    \n    vec3 lightDir = normalize( vec3( -1, -0.3, 1.0 ));\n    float mflight = max(dot( norm, lightDir), 0.0);\n    fragColor.rgb *= mflight;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljcDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[526, 526, 549, 549, 699], [701, 701, 722, 722, 900], [902, 902, 923, 923, 1138], [1140, 1140, 1161, 1161, 1364], [1365, 1365, 1387, 1387, 1545], [1548, 1548, 1569, 1569, 1620], [1621, 1621, 1640, 1640, 1679], [1680, 1680, 1699, 1699, 1749], [1750, 1750, 1769, 1769, 1830], [1832, 1832, 1856, 1856, 2200], [2202, 2202, 2226, 2226, 2988], [2990, 2990, 3044, 3044, 3371], [3373, 3373, 3430, 3430, 4355]], "test": "untested"}
{"id": "7t2yDc", "name": "avoid lighting creases", "author": "jcyuan", "description": "the trick in https://www.shadertoy.com/view/7l3GDS\navoid those creases created by mixing SDFs for glowing effects.\nany other ways? share please!", "tags": ["2d", "light", "creases"], "likes": 2, "viewed": 201, "published": 3, "date": "1650363822", "time_retrieved": "2024-07-30T16:52:48.951894", "image_code": "const float eps = 1e-10;\n\nfloat way1(vec2 p) {\n    float d = length(p - vec2(0., .1)) - .1;\n    \n    d = min(d, length(p - vec2(0., -.1)) - .1);\n    \n    float l = 1. / max(d - .015, eps);\n    \n    return pow(l * .012, 1.3);\n}\n\nfloat way2(vec2 p) {\n    float l = 0.;\n    \n    float d = length(p - vec2(0., .1)) - .1;\n    l = 1. / max(d - .015, eps);\n    \n    d = max(0., length(p - vec2(0., -.1)) - .1);\n    l += 1. / max(d - .015, eps);\n    \n    return pow(l * .012, 1.3) * .5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const vec2 splitUv = vec2(2., 1.);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float line = abs(uv.x - .5);\n    float id = step(.5, uv.x);\n    \n    uv = fract(uv * splitUv) * 2.;\n    uv -= 1.;\n    uv.x *= (iResolution.x * .5 / iResolution.y);\n    \n    float c1 = way1(uv);\n    float c2 = way2(uv);\n    \n    vec3 col = mix(c1, c2, id) * vec3(1., .8, .41);\n    \n    float w = fwidth(line);\n    col += (1. - smoothstep(0., w, line)) * vec3(.01);\n    \n    col = 1. - exp(-col);\n    col = pow(col, vec3(.454545));\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2yDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 226], [228, 228, 248, 248, 480], [482, 482, 537, 537, 1092]], "test": "untested"}
{"id": "sljcWc", "name": "Rainbow noise", "author": "MrNissenDK", "description": "I have worked on making my Perlin noise interpolation better.\nAnd made this out of it.", "tags": ["noise", "perlin", "rainbow", "colorfull"], "likes": 3, "viewed": 243, "published": 3, "date": "1650361318", "time_retrieved": "2024-07-30T16:52:50.065915", "image_code": "float seed = 437585.453123;\nfloat PI = 3.141592653589793;\nfloat res = 10.; // how many sqrs along the x axes\n\nfloat hash21(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec2 (127.1, 351.7));\n  return fract(sin(f)*a);\n}\n\nvec2 hash2(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  p = vec2(dot (p, vec2 (127.1, 351.7)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p)*a);\n}\n\nvec3 hash23(vec2 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec3 p3 = vec3(dot (p, vec2 (127.1, 351.7)), dot (p, vec2 (261.5, 183.3)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p3)*a);\n}\n\nvec2 hash32(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec2 p2 = vec2(dot (p, vec3 (127.1, 351.7, 251.45)), dot (p, vec3 (261.5, 183.3, 376.89)));\n  return fract(sin(p2)*a);\n}\nfloat hash31(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec3 (127.1, 351.7, 251.45));\n  return fract(sin(f)*a);\n}\n\n//6t5-15t4+10t3\nfloat ease(float t)\n{\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\nvec2 ease(vec2 t)\n{\n  return vec2(ease(t.x), ease(t.y));\n}\nvec3 ease(vec3 t)\n{\n  return vec3(ease(t.x), ease(t.y), ease(t.z));\n}\nvec4 ease(vec4 t)\n{\n  return vec4(ease(t.x), ease(t.y), ease(t.z), ease(t.w));\n}\n\nfloat noise(vec2 point){\n    vec2 fr = ease(fract(point));\n    vec2 hi = ceil(point);\n    vec2 lo = floor(point);\n    \n    return mix(\n        mix(\n            hash21(lo), \n            hash21(vec2(hi.x , lo.y)), \n            fr.x\n        ), \n        mix(\n            hash21(vec2(lo.x , hi.y)),\n            hash21(hi),\n            fr.x\n        ), \n        fr.y\n    );\n}\n\nfloat noise(vec3 point){\n    vec3 fr = ease(fract(point));\n    vec3 hi = ceil(point);\n    vec3 lo = floor(point);\n    \n    return mix(\n        mix(\n            mix(\n                hash31(lo), \n                hash31(vec3(hi.x , lo.yz)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.y, lo.z)),\n                hash31(vec3(hi.xy, lo.z)),\n                fr.x\n            ), \n            fr.y\n        ),\n        mix(\n            mix(\n                hash31(vec3(lo.xy, hi.z)), \n                hash31(vec3(hi.x , lo.y, hi.z)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.yz)),\n                hash31(hi),\n                fr.x\n            ), \n            fr.y\n        ),\n        fr.z\n    );\n}\n\nfloat octal(vec3 uv, int octaves, float persistence)\n{\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += noise(uv * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total/maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    \n    /*vec3 col = vec3(\n        (\n            noise(uv)\n          + noise(uv * 2.) * .5\n          + noise(uv * 4.) * .25\n          + noise(uv * 8.) * .125\n        ) / 1.875\n    );*/\n\n    float r = octal(vec3(uv, iTime / 10. + 501.), 8, .5);\n    float g = octal(vec3(uv + 19171., iTime / 10. + 51.), 8, .5);\n    float b = octal(vec3(uv - 55001., iTime / 10. + 5001.), 8, .5);\n    \n    vec3 col = vec3(r,g,b);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljcWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 133, 133, 283], [285, 285, 306, 306, 484], [486, 486, 507, 507, 722], [724, 724, 745, 745, 948], [949, 949, 971, 971, 1129], [1131, 1147, 1168, 1168, 1219], [1220, 1220, 1239, 1239, 1278], [1279, 1279, 1298, 1298, 1348], [1349, 1349, 1368, 1368, 1429], [1431, 1431, 1455, 1455, 1799], [1801, 1801, 1825, 1825, 2587], [2589, 2589, 2643, 2643, 3015], [3017, 3017, 3074, 3124, 3671]], "test": "untested"}
{"id": "7tSyDy", "name": "mackjam_ad", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 4, "viewed": 624, "published": 3, "date": "1650357743", "time_retrieved": "2024-07-30T16:52:51.201878", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n#define FFTI(a) iTime \n//texture(texFFTIntegrated, a).x\n#define FFTS(a) (texture(iChannel1, vec2(a, 0.)).x*1.)\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define iTime iTime*.5\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n  vec3 op = p;\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*.75+p.y*.1))*1.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.05)*20.+iTime*85.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./12.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,20.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p;\n  float stpcube = PI*2./40.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  float repyc = .5;\n  float radb = mix(10.,20.,sin(repyc)*.5+.5);\n  pcube -= vec3(0.,0.,radb);\n\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  vec3 pcc = op-vec3(0.,55.,0.);\n  pcc.xz *= r2d(iTime);\n  pcc.yz *= r2d(.5*iTime);\n  acc = _min(acc, vec2(_cucube(pcc-vec3(0.,15.,0.), vec3(1.), vec3(.01)), -5.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 10.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2;\n\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 ro = vec3(0.,-5.,-5.);\n  vec3 ta = vec3(0.,25.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n/*  \n  uv *= r2d(-iTime);\n  uv = abs(uv);\n  uv -= vec2(.1);\n  uv *= r2d(.1*iTime);\n // uv = abs(uv);\n    uv -= vec2(.25);\n  uv *= r2d(FFTI(.1)*10.);\n  uv = abs(uv);\n  */\n  vec3 col = rdr(uv);\n  \n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col = pow(col, vec3(1.45));\n  //col *= vec3(199, 242, 58)/255.;\n  float beat = 1./8.;\n  col += (mod(iTime, beat)/beat)*sat(FFTS(.1)*col)*45.;\n  col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .5);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28780, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSyDy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "stSyDy", "name": "mackjam_ac", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 1, "viewed": 378, "published": 3, "date": "1650357740", "time_retrieved": "2024-07-30T16:52:52.045622", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*.75+p.y*.1))*5.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.1)*50.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./12.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,20.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p;\n  float stpcube = PI*2./40.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  pcube -= vec3(0.,0.,rad);\n  float repyc = .5;\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2;\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 ro = vec3(0.,-5.,-5.);\n  vec3 ta = vec3(0.,25.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  \n  uv *= r2d(iTime);\n  uv = abs(uv);\n  uv -= vec2(.1);\n  uv *= r2d(iTime);\n  uv = abs(uv);\n  vec3 col = rdr(uv);\n  \n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col = pow(col, vec3(1.45));\n  col *= vec3(199, 242, 58)/255.;\n  \n  col = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).xyz, .75);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28779, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSyDy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 455, 455, 568]], "test": "untested"}
{"id": "sl2yW3", "name": "[Revision 2022] Blob & Grid", "author": "totetmatt", "description": "My entry for the Revision 2022 Shader showdown Quarter final with Blackle.\nMost Epic Quarter , thanks all !", "tags": ["revision"], "likes": 23, "viewed": 488, "published": 3, "date": "1650348675", "time_retrieved": "2024-07-30T16:52:53.029990", "image_code": "/*\n\nGreetings \nAll Revision participants\nAll Live Shader coders\n\nIn particular Gaz and Kamoshika that I heavly based the code on their work :D \n\n*/\n\n// I CERTIFY ITS NOT A BOT\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat diam(vec2 p,float s){\n   p = abs(p);\n   return (p.x+p.y-s)*inversesqrt(3.);\n     \n}\nfloat smin(float a,float b,float r){\n    float k = max(0.,r-abs(a-b));\n  return min(a,b) -k*k*.25/r;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float bpm = (iTime*60./130.*2.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    bpm = floor(bpm)+pow(fract(bpm),.5);\n\n    vec3 col = vec3(.1);\n    vec3 p,d = normalize(vec3(uv,1.));\n  \n    for(float i=0.,g=0.,e;i++<99.;){\n    \n      p = d*g;\n      p.z -=5.;\n       \n      vec3 gp = p;\n      gp.xy *=rot(gp.z*.1);\n      gp.y =-abs(gp.y);\n      gp.y +=1.;\n \n     \n      float dd,c=20./3.141592;\n  \n      gp.xz = vec2(log(dd=length(gp.xz)),atan(p.x,p.z))*c;\n                                            // Here I struggle during live \n                                            // as I was doing p.y (which is to do torus)\n                                            // Rather than atan(p.x,p.y) to have proper log polar\n      gp.y/=dd/=c;\n      gp.y +=sin(gp.x)*.5;\n      gp.xz = fract(gp.xz+iTime)-.5;\n     \n      for(float j=0.;j<4.;j++){ \n        gp.xzy = abs(gp.xzy)-vec3(.1,.01,.1);\n         gp.xz *=rot(-.785);\n      }\n      float ha_grid = dd*.8*min(diam(gp.xy,.01),diam(gp.zy,.01));\n           // You're a variable Harry\n    \n    \n      float f = ha_grid;\n    \n      float blob = length(p)-.5;\n      float gy = dot(sin(p*4.),cos(p.zxy*2.))*.1;\n      for(float j=0.;j<16.;j++){ \n           vec3 off = vec3(cos(j),tan(bpm+j),sin(j*3.33))+gy;\n            blob = smin(blob,length(p-off)-.125,.25); \n      }\n    \n      f= smin(f,blob,.5);\n      g+=e=max(.001,f);;\n      col+= mix(vec3(1.,.2,sin(p.z+bpm)*.5+.5),vec3(.5,sin(p.z)*.5+.5,.9),fract(2.*i*i*e))*.25/exp(i*i*e);\n    \n   }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2yW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 195, 195, 242], [243, 243, 270, 270, 332], [333, 333, 369, 369, 438], [440, 440, 497, 497, 2106]], "test": "untested"}
{"id": "ftjcWc", "name": "zeglo", "author": "lomateron", "description": "name sounds like the image", "tags": ["fractal"], "likes": 9, "viewed": 254, "published": 3, "date": "1650338218", "time_retrieved": "2024-07-30T16:52:53.791953", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 v = u;\n    u = u/dot(u,u);\n    \n    float pi = 3.1415926535897932384626433832795;\n    \n    for(float i = .5; i <3.; ++i)\n    {\n        float e = -1.;\n        float f = 1.;\n        u = vec2(atan(u.y,u.x),length(u));\n        u+= vec2(0,-1.4);\n        u = cos(u.x*e-vec2(0,pi*.5))*pow(u.y,e);\n        u = vec2(atan(u.y,u.x),length(u));\n        u = cos(u.x*f-vec2(0,pi*.5))*pow(u.y,f);\n        u+= v;\n    }\n\tfragColor = vec4(2./(2.+length(u)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjcWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 567]], "test": "untested"}
{"id": "ft2yWc", "name": "Columnas opRevolution-v2", "author": "jorge2017a2", "description": "Columnas v3 opRevolution", "tags": ["columnasv3oprevolution"], "likes": 6, "viewed": 197, "published": 3, "date": "1650337459", "time_retrieved": "2024-07-30T16:52:54.647665", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n\n//Columnas v3 opRevolution --18-abril-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions2d/\n//https://iquilezles.org/articles/distfunctions/\n\n\n//gest, 2024-03-04\n#define TF_ROUND(d, R) (length(max(d, 0.)) - (R))\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-(S), R)\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h ) {\n\treturn TF_BOX_ROUND(p, vec2(0, h), mix(r1, r2, p.y/h));\n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n/*\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n*/\nfloat ficuraPostev2(vec2 p)\n{  float r1,r2,h;\n    p=vec2(p.y, p.x)-vec2(0.0+6.0,0.0);\n    float d0= sdBox( p-vec2(0.7,2.2),vec2(0.5,3.5) );\n    r1=0.5;r2=0.5;h=4.5; \n    float d1= sdUnevenCapsule( p,r1,r2, h );\n    r1=0.5;r2=0.5;h=3.5; \n    float d2= sdUnevenCapsule( p-vec2(-1.0,0.5),r1,r2, h );    \n    float res= Union(d0, d1);\n    res= Union(res, d2);\n    return res;\n}\n\nfloat figuraPosteUnion(vec2 p)\n{   float d0= ficuraPostev2(p);\n    float d1= sdBox( p-vec2(2.25,-1.0),vec2(0.5,7.5) );\n    float d3= ficuraPostev2(vec2(p.x,-p.y-3.0));\n    float res=Union(d0, d1);\n    res=Union(res, d3);   \n    return res;\n}\n// iq formula\nvec2 opRevolution( in vec3 p, float w )\n{  return vec2( length(p.xz) - w, p.y ); }\n\n\nvec2 figuraPoste3d(vec3 p)\n{   p.y-=11.5;\n    vec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    vec2 qrev=opRevolution(p,0.5);\n    float d1= figuraPosteUnion(qrev);\n    float d2=sdCylinderXZ( p, vec2(4.0,6.0)  );\n    res =opU2(res, vec2(d1,100.0));\n    return res;\n}\n\nvec2 cuatroPostes(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    p.x=abs(p.x)-15.0;\n    p.z=abs(p.z)-10.0;\n    vec2  re1= figuraPoste3d(p);\n    res =opU2(res, re1);    \n    return res;\n}\n\nvec2 piramideEncima(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    vec2 q=vec2(p.x, -p.y);\n    float d1= sdTriangleIsosceles(q-vec2(0.0,-22.0), vec2(15.0,8.5) );\n    float d2= sdTriangleIsosceles(q-vec2(0.0,-19.0), vec2(12.0,6.0) );\n    float d3= sdBox( p-vec3(0.0,20.0,0.0), vec3(16.0,8.0,15.0) );\n    d1= Difference(d1, d2);\n    d1=Intersect(d1,d3);\n    res =opU2(res, vec2(d1,102.0));\n    return res;\n}\n\nvec2 TdoJunto(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    vec2 re2= cuatroPostes(p);\n    res =opU2(res, re2);\n    \n    vec2 re3= piramideEncima(p-vec3(0.0,5.0,0.0));\n    res =opU2(res, re3);\n return res;\n}   \n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,57.0));\n    p.x= opRep1D( p.x, 50.0 );\n    p.z= opRep1D( p.z, 40.0 );\n    vec2 re1= TdoJunto(p);\n    res =opU2(res, re1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,2.0,1.0); }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==57) {return pattern( p.xz );}\n if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t=mod(iTime*10.0,1000.0);\n \tlight_pos1= vec3(-10.0, 50.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0,-35.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(-30.0+abs(30.0*sin(iTime*0.25))));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1)  //6 \n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2yWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 500, 500, 559], [867, 867, 899, 899, 983], [984, 984, 1023, 1023, 1118], [1119, 1119, 1158, 1158, 1253], [1254, 1254, 1293, 1293, 1388], [1390, 1434, 1478, 1478, 1505], [1506, 1506, 1546, 1546, 1573], [1574, 1574, 1619, 1619, 1647], [1648, 1686, 1722, 1722, 1767], [1769, 1794, 1828, 1828, 1924], [1925, 1925, 1959, 1959, 2050], [2051, 2051, 2085, 2085, 2176], [2177, 2177, 2211, 2211, 2302], [2305, 2305, 2356, 2356, 2664], [2666, 2666, 2703, 2703, 2777], [2779, 3087, 3116, 3116, 3460], [3462, 3462, 3494, 3494, 3703], [3704, 3718, 3759, 3759, 3800], [3803, 3803, 3831, 3831, 4065], [4067, 4067, 4094, 4094, 4262], [4264, 4264, 4293, 4293, 4678], [4680, 4680, 4703, 4703, 4897], [4902, 4902, 4927, 4927, 5185], [5187, 5187, 5211, 5211, 5373], [5375, 5375, 5423, 5423, 5702], [5704, 5704, 5748, 5748, 6069], [6071, 6071, 6108, 6108, 6365], [6367, 6367, 6457, 6457, 7417], [7419, 7419, 7468, 7468, 7674], [7676, 7676, 7708, 7708, 7905], [7907, 7955, 7983, 7983, 8171], [8173, 8173, 8243, 8243, 8455], [8457, 8457, 8484, 8484, 8573], [8575, 8575, 8633, 8633, 8681], [8683, 8683, 8706, 8706, 8818], [8820, 8820, 8851, 8851, 9471], [9473, 9473, 9530, 9530, 10021]], "test": "untested"}
{"id": "ftjcD3", "name": "4 col grad", "author": "aferriss", "description": "quick n dirty four color gradient", "tags": ["gradient"], "likes": 1, "viewed": 234, "published": 3, "date": "1650332185", "time_retrieved": "2024-07-30T16:52:55.492407", "image_code": "vec3 grad(vec3 color1, vec3 color2, vec3 color3, vec3 color4, vec2 uv){\n    return mix(mix(color1, color2, smoothstep(0.0, 1.0, uv.y)),  mix(color3, color4, uv.y), smoothstep(0.0, 1.0,uv.x));\n    //return mix(mix(color1, color2,  uv.y),  mix(color3, color4, uv.y),uv.x);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    vec3 col = grad(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1), vec3(1, 1, 0), uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 71, 71, 273], [275, 275, 332, 382, 566]], "test": "untested"}
{"id": "NtjyD3", "name": "Electric field demo", "author": "RayWorld", "description": "for electrostatics", "tags": ["physics", "electrostatics", "electricfield"], "likes": 3, "viewed": 247, "published": 3, "date": "1650329707", "time_retrieved": "2024-07-30T16:52:56.265340", "image_code": "vec3 hsv_to_rgb(float H, float S, float V) {\n    float C = (V/100.0)*(S/100.0);\n    float X = C * (1.0 - abs(mod(H / 60.0 , 2.0) - 1.0));\n    float m = (V/100.0)- C;\n    vec3 O = vec3(0.0);\n    if(0.0 <= H && H < 60.0) O = vec3(C,X,0.0);\n    if(60.0 <= H && H < 120.0) O = vec3(X,C,0.0);\n    if(120.0 <= H && H < 180.0) O = vec3(0.0,C,X);\n    if(180.0 <= H && H < 240.0) O = vec3(0.0,X,C);\n    if(240.0 <= H && H < 300.0) O = vec3(X,0.0,C);\n    if(300.0 <= H && H < 360.0) O = vec3(C,0.0,X);\n    O += vec3(m);\n    return O;\n}\n// modify this list: vec3(uv x, uv y, charge)\nvec3[] charges = vec3[](vec3(0.25, 0.5, 1.0),vec3(0.75,0.5,-1.0));\n\nvec2 coloumbsLaw(vec2 measure) {\n    int l = charges.length();\n    vec2 sum = vec2(0.0);\n    for(int i = 0; i<l; i++) {\n        vec2 offset = measure - charges[i].xy;\n        float sqMag = dot(offset, offset);\n        if (sqMag <= 0.000001) return vec2(0.0);\n        sum += charges[i].z * offset / sqMag;\n    }\n    return sum;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // calculate force at pixel\n    vec2 direction = coloumbsLaw(uv);\n    //default color\n    vec3 col = vec3(0.0);\n    if (direction != vec2(0.0)) {\n        col = hsv_to_rgb(mod(degrees(atan(direction.y, direction.x))+360.0,360.0), 100.0 / (1.0 + exp(3.0-length(direction))), 100.0);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 525], [640, 640, 672, 672, 968], [969, 969, 1026, 1076, 1464]], "test": "untested"}
{"id": "slByD3", "name": "Fork Reflect Re anush 013", "author": "anush", "description": "A raytracer to go along with a blog post about reflection, refraction, total internal reflection and fresnel.\nDrag mouse for orbit camera.\nPlay with #define parameters.\nhttp://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-inte", "tags": ["reflection", "refraction", "raytrace", "fresnel", "tir"], "likes": 3, "viewed": 309, "published": 3, "date": "1650313076", "time_retrieved": "2024-07-30T16:52:57.424241", "image_code": "/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.001 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 2.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1 // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL   1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA          1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_d_inputs": [], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slByD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1634, 1744, 1766, 1766, 1899], [1901, 2132, 2234, 2259, 4471], [4473, 4605, 4679, 4753, 5771], [5773, 5991, 6076, 6076, 6465], [6467, 6530, 6658, 6658, 7077], [7079, 7142, 7200, 7200, 8549], [8551, 8614, 8643, 8643, 8729], [8731, 8794, 8897, 8915, 9725], [9727, 9790, 9867, 9867, 10550], [10552, 10615, 10671, 10923, 11258], [11260, 11323, 11388, 11504, 13436], [13438, 13501, 13559, 13559, 15854], [15856, 15919, 15976, 16009, 18369]], "test": "untested"}
{"id": "NtSyDc", "name": "Ship in an Icy vista", "author": "mrange", "description": "CC0: Ship in an Icy vista\nBeen tinkering with this for a few days. Some aliasing still remains on the icy shore line but perhaps someone has some good ideas on how to reduce it. ", "tags": ["3d"], "likes": 19, "viewed": 344, "published": 3, "date": "1650302857", "time_retrieved": "2024-07-30T16:52:58.345778", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 sunPos     = 1E7*vec3(1.0,0.25,-1.0);\nconst vec3 skyDir     = normalize(vec3(-1.0,0.25,1.0));\nconst vec4 moonDim    = vec4(1E5*vec3(-0.2175,0.1525,-1.0), 9000.0);\nconst vec3 sunDir     = normalize(sunPos);\nconst vec3 sunCol0    = HSV2RGB(vec3(0.15, 0.66, 1.0));\nconst vec3 sunCol1    = HSV2RGB(vec3(0.5*0.15, 0.95, 1.0));\nconst vec3 skyCol     = HSV2RGB(vec3(0.6, 0.6, 0.6)); \nconst vec3 morningDir = normalize(vec3(0.65,0.4,-1.0));\nconst float speed     = 0.3;\n\nconst float iceHeightFactor = -0.0125;\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat noise_xx(vec2 p) {\n  vec2 n = fract(floor(p)*0.5)*2.0;\n  p = fract(p);\n  p = mix(p, 1.0 - p, n);\n  return texture(iChannel0, p).x;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n  float ik = 1.0/k;\n  float p = ik*(pos.y - 0.5*ik)/3.0;\n  float q = 0.25*ik*ik*pos.x;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n      pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n      2.0*cos(atan(r,q)/3.0)*sqrt(p);\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat vesica(vec2 p, vec2 sz) {\n  // Based of vesica by IQ: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// License: Unknown, author: Shane, found: https://www.shadertoy.com/view/Mld3Rn\nvec3 voronoi(vec2 p) {\n  vec2 op = p;\n  vec2 g = floor(p), o; p -= g;\n  vec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n  vec2 mp;\n\n  for(int y = -1; y <= 1; y++) {\n    for(int x = -1; x <= 1; x++) {\n      o = vec2(x, y);\n      o += hash2(g + o) - p;\n            \n      d.z = dot(o, o); \n            \n      d.y = max(d.x, min(d.y, d.z));\n      if (d.z < d.x) {\n        d.x = d.z;\n        mp = op+o;\n      }\n      d.x = min(d.x, d.z); \n                       \n    }\n  }\n \n  return vec3(max(d.y/1.2 - d.x*1.-0., 0.), mp);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 srd = toSpherical(rd.xzy);\n  vec3 col = vec3(0.0);\n\n  float morningd = clamp(dot(morningDir,rd), 0.0, 1.0 );\n  float sund = clamp(dot(sunDir,rd), 0.0, 1.0 );\n\n  vec2 mi = raySphere(ro, rd, moonDim);\n\n  float sy = max(-(srd.y-PI/2.0), 0.0);\n  sy = exp(-5.*sy);\n  col += hsv2rgb(vec3(0.6, mix(0.8, 0.5, sy), sy));\n\n  const float sh = 0.15;\n  col += 8.0*sunCol0*pow(sund, 1000.0);\n  col += 1.0*sunCol1*pow(sund, 100.0);\n  col += 2.0*HSV2RGB(vec3(sh, 0.66, 1.0))*pow(morningd, 2000000.0);\n\n  vec3 mpos = ro + mi.x*rd; \n  vec3 mnor = normalize(mpos-moonDim.xyz);\n  vec3 mref = reflect(rd, mnor);\n  vec3 mld  = normalize(sunPos - mpos);  \n  float mdif= pow(max(dot(mnor,mld), 0.0), 2.0);\n  float mspe= pow(max(dot(mnor,mld), 0.0), 5.0);\n  vec3 mcol = vec3(0.005);\n  mcol += 0.9*mspe;\n  mcol += 0.5*mdif;\n  col += mcol*tanh_approx(0.0005*max((mi.y - mi.x), 0.0));\n\n  return col;\n}\n\nfloat iceHeight(vec2 p, float aa) {\n  vec2 vp = p;\n  float vz = 1.0;\n\n  float gh = 0.0;\n  float hh = 0.0;\n\n  // Recursive voronois\n  {\n    vec3 c = voronoi(vp);\n    gh = (0.125*max(abs(c.y+8.0*sin(0.025*c.z)+2.0*sin(0.1*c.z))-mix(10.0, 30.0, 0.0*smoothstep(-0.5, 0.5, cos(0.01*c.z))), 0.));\n    hh = smoothstep(-aa, aa, c.x-2.0*aa*smoothstep(1.0, 0.75, gh));\n    if (gh > 0.75) {\n      return iceHeightFactor*tanh_approx(hh+0.5*(gh-0.75));\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0 + c.yz;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-3.0*aa*smoothstep(1.0, 0.5, gh));\n    if (gh > 0.5) {\n      return 0.75*iceHeightFactor*hh;\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0 + c.yz;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-2.0*aa*smoothstep(0.9, 0.25, gh));\n    if (gh > 0.25) {\n      return 0.5*iceHeightFactor*hh;\n    }\n  }\n  \n  return 0.0;\n}\n\nvec3 iceNormal(vec2 p, float aa, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(eps, 0);\n  \n  vec3 n;\n  n.x = iceHeight(p + e.xy, aa) - iceHeight(p - e.xy, aa);\n  n.y = 2.0*e.x;\n  n.z = iceHeight(p + e.yx, aa) - iceHeight(p - e.yx, aa);\n  \n  return normalize(n);\n}\n\nvec4 iceColor(vec3 ro, vec3 rd, vec3 pos, float t, float aa) {\n  vec2 pp = pos.xz;\n  float haa = 0.125*t*aa;\n  float height  = iceHeight(pp, haa);\n  vec3 nor      = iceNormal(pp, haa, 1.0*haa);\n  vec3 ref      = reflect(rd, nor);\n  float fre = 1.0+dot(nor, rd);\n  fre *= fre;\n  fre *= fre;\n  fre *= fre;\n\n  float dif0    = max(dot(nor, sunDir), 0.0);\n  float spe0    = pow(max(dot(ref, sunDir), 0.0), 10.0);\n  float dif1    = max(dot(nor, skyDir), 0.0);\n\n//  dif = sqrt(dif);\n  vec3 col = vec3(0.0);\n  col += 3.0*dif0;\n  col += 4.0*fre*spe0;\n  col += 4.0*dif1*skyCol;\n  return vec4(col, smoothstep(0.3*iceHeightFactor, 0.6*iceHeightFactor, height));\n}\n\nfloat seaHeight(vec2 p) {\n  float lo = noise_xx(0.0025*p);\n  lo *= lo;\n  float hi = noise_xx(0.025*p);\n  hi *= hi;\n  return -0.01*hi*mix(0.5, 1.0, lo);\n}\n\n\nvec3 seaNormal(vec2 p, float eps) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(eps, 0);\n  \n  vec3 n;\n  n.x = seaHeight(p + e.xy) - seaHeight(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = seaHeight(p + e.yx) - seaHeight(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 shipColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, float aa) {\n  const float ys = -6.0+0.3;\n  vec2 pp   = pos.xz;\n\n  vec2 sp = pp;\n  vec2 spo = vec2(0.0, -27.0-speed*TIME);\n  sp -= spo;\n\n  vec3 ppp = vec3(spo.x, ys, spo.y);\n  float ss = length(pos - ppp);\n  vec3 pnor= normalize(ro-ppp);\n  vec4 ppl = vec4(pnor, -dot(ppp, pnor));\n  float pd = rayPlane(ro, rd, ppl);\n  vec3 plp = ro + pd*rd-ppp;\n\n  const vec3 pup = normalize(vec3(0.0, 1.0, 0.0));\n  vec3 pxx = normalize(cross(pnor, pup));\n  vec3 pyy = normalize(cross(pnor, pxx));\n  vec2 pp2 = vec2(dot(pxx, plp), dot(pyy, plp));\n  float ld = length(pp2);\n\n  float pm = -dot(ppp, nor);\n\n  vec2 sbp = sp;\n  sbp -= vec2(0.0, -0.4);\n\n  vec2 spp = sp;\n  spp -= vec2(0.0, 0.3);\n\n  float sd = vesica(sp, vec2(0.1, 1.0)*0.5);\n  float gd = length(sp);\n  float sbd = parabola(sbp, 110.0);\n  float spd = parabola(spp, 110.0);\n  sbd = abs(sbd)-0.0071;\n\n  float wrnd = smoothstep(-2.5, 0.5, sin(10.0*sbp.y)*sin(13.0*sbp.y+5.0*sbp.x));\n  float sbfo = smoothstep(13.0, 0.0, sp.y)*wrnd;\n  float spfo = smoothstep(4.0, 0.0, sp.y)*wrnd;\n\n  vec3 col = vec3(0.0);\n  const vec3 seaCol = HSV2RGB(vec3(0.45, 0.5, 0.1)); \n  vec3 shCol = vec3(mix(0.8,0.3, smoothstep(0.0, 1.0, cos(20.0*sqrt(2.0)*sp.y+1.0)*cos(20.0*sp.y))));\n  col  = mix(col, shCol, smoothstep(aa, -aa, sd));\n  col += smoothstep(aa, -aa, sbd*sbfo)*sbfo;\n  col += 0.5*smoothstep(aa, -aa, spd*spfo)*spfo;\n  float ff = smoothstep(0.5, 1.0, sin(TAU*TIME+1.0)*sin(TAU*sqrt(2.0)*TIME+2.0)*sin(TAU*sqrt(3.0)*TIME+3.0));\n  col += 3.0*seaCol*exp(-mix(0.25, 0.275, ff)*gd);\n  col += 1.0*exp(-mix(10.0, 20.0, ff)*ld);\n\n  return col;  \n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  const float ys = -6.0;\n  float tb = (ys-ro.y)/rd.y;\n  \n  if (tb < 0.0) {\n    return skyCol;\n  }\n\n  vec3 pos  = ro +  tb*rd;\n  vec3 npos = ro +  tb*nrd;\n  float baa = length(pos.xz - npos.xz);\n  \n  vec3 nor = seaNormal(pos.xz, baa);\n  vec3 ref = reflect(rd, nor);\n  vec3 rskyCol = skyColor(ro, ref);\n  vec4 iceCol  = iceColor(ro, rd, pos, tb, baa);\n  float fre = 1.0+dot(nor, rd);\n  fre *= fre;\n  fre *= fre;\n\n  vec3 col = HSV2RGB(vec3(0.45, 0.5, 0.1));\n  col += shipColor(ro, rd, pos, nor, baa);\n  col += fre*rskyCol;\n  col = mix(col, iceCol.xyz, iceCol.w);\n  \n  col = mix(skyCol, col, exp(-0.0125*max(tb-60.0, 0.0)));\n\n  return col;\n}\n\nvec3 color(vec2 p, vec2 q) {\n  float z = -speed*TIME;\n  vec3 ro   = vec3(0.0, 0.0, z);\n  vec3 dro  = normalize(vec3(0.0, -0.1, -1.0));\n\n  vec2 np   = vec2(p+2.0/RESOLUTION.y);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = cross(ww, uu);\n  const float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd= normalize(np.x*uu + np.y*vv + rdd*ww);;\n    \n  vec3 col = render(ro, rd, nrd);\n\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2.*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;  \n  vec3 col = color(p, q);\n  fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define RESOLUTION iResolution\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n#define BLUR\n#if defined(BLUR)\n  const int c = 3;\n\n  vec2 pq = q;\n\n  \n  vec2 aa = 4.0/RESOLUTION.xy;\n  vec2 start = pq-float(c)*aa;\n  vec3 bcol = vec3(0.0); \n  for (int y = -c; y <= c; ++y) {\n    vec2 pp = start;\n    for (int x = -c; x <= c; ++x) {\n      vec4 fcol = texture(iChannel1, pp);\n      fcol *= fcol;\n      bcol += fcol.xyz;\n      pp.x += aa.x;\n    }\n    start.y += aa.y;\n  }\n  \n  bcol /= float((2*c+1)*(2*c+1));\n  float l = max(max(bcol.x, bcol.y), bcol.z);\n  bcol *= smoothstep(0.2, 1.0, l);\n  \n  vec4 pcol = texture(iChannel0, q);\n  vec3 col = pcol.xyz;\n  col = aces_approx(col);\n  col += 0.25*bcol;\n  col = sRGB(col);\n#else\n  vec4 bcol = texture(iChannel1, q);\n  bcol *= bcol;\n  float l = max(max(bcol.x, bcol.y), bcol.z);\n  \n  vec4 pcol = texture(iChannel0,q);\n  vec3 col = pcol.xyz;\n  col = aces_approx(col);\n  col += 0.25*bcol.xyz*smoothstep(0.2, 1.0, l);\n  col = sRGB(col);\n#endif\n\n  fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 117]], "test": "untested"}
{"id": "flBcWc", "name": "grazing", "author": "blackle", "description": "4k exegfx entry for revision 2022", "tags": ["4kexegfx"], "likes": 32, "viewed": 799, "published": 3, "date": "1650302411", "time_retrieved": "2024-07-30T16:52:59.361063", "image_code": "//old code to match transfer function used by exrdisplay\n// GOTO BUFFER A TO ENABLE THE PUMPJACS (SLOW COMPILATION)\n\n#if 0\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat knee (float x, float f)\n{\n    return log (x * f + 1.) / f;\n}\n\nvec3 gamma (vec3 h, float exposure)\n{\n    //\n    // Conversion from half to unsigned char pixel data,\n    // with gamma correction.  The conversion is the same\n    // as in the exrdisplay program's ImageView class,\n    // except with defog, kneeLow, and kneeHigh fixed\n    // at 0.0, 0.0, and 5.0 respectively.\n    //\n    float m = pow (\n        2.f, clamp (exposure + 2.47393f, -20.f, 20.f));\n\n    vec3 x = max (h * m, 0.);\n\n    if (x.x > 1.) x.x = 1. + knee (x.x - 1., 0.184874f);\n    if (x.y > 1.) x.y = 1. + knee (x.y - 1., 0.184874f);\n    if (x.z > 1.) x.z = 1. + knee (x.z - 1., 0.184874f);\n\n    return (clamp (\n        pow (x, vec3(.4545f)) * 84.66f, 0.f, 255.f))/255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfragColor /= fragColor.w;\n    fragColor.xyz = gamma(fragColor.xyz,-1.);\n\t//fragColor *= 1.0 - dot(uv,uv)*0.5; //vingetting lol\n    //fragColor = log(fragColor+1.);\n\t//fragColor = smoothstep(0.09,0.99,sqrt(fragColor))+.02; //colour grading\n\t//fragColor += hash(uv.x,uv.y)*.015;\n}\n#else\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfragColor /= fragColor.w*4.; //\"film grain\"\n\tfragColor *= 1.0 - dot(uv,uv)*0.5; //vingetting lol\n\tfragColor = smoothstep(-0.2,1.2,sqrt(fragColor)); //colour grading\n    //fragColor.xyz*=mat3(1.7,-.2,-.4,-.3,1.4,-.1,-.1,-.1,1.2);\n\t//fragColor += hash(uv.x,uv.y)*.015;\n}\n#endif", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//define this for an extremely slow compile time\n//#define PUMPJACKS\n\n//uncomment for fun\n//#define COWS\n\n\n//axis rotation functions. maybe there's a better way\nvec3 xy(vec3 p,float r){p.xy*=mat2(cos(r),sin(r),-sin(r),cos(r));return p;}\nvec3 yz(vec3 p,float r){p.yz*=mat2(cos(r),sin(r),-sin(r),cos(r));return p;}\nvec3 xz(vec3 p,float r){p.xz*=mat2(cos(r),sin(r),-sin(r),cos(r));return p;}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n//fancy repetition to make the dictionary compressor happy :3\nfloat mx(vec2 p) {\n    return max(p.x,p.y);\n}\nfloat mx(vec3 p) {\n    return max(p.x,mx(p.yz));\n}\nfloat mx(vec4 p) {\n    return max(p.x,mx(p.yzw));\n}\n#define cn(p) (length(max(p,0.)) + min(0.,mx(p)))\n#define bx(p,d) cn(abs(p)-(d/2.))\n#define tr(p,r) (asin(sin((p)*r))/r)\n\nfloat hex(vec2 p, vec3 rad) {\n    vec3 p2 = vec3(.81,-.4,-.4)*p.y + vec3(0,-.71,.71)*p.x;\n    return bx(p2,vec3(rad));\n}\n\nfloat feature(vec3 p, float d, float w, float t) {\n    float body = cn(p.xy-vec2(-t,d)/2.); // main body or nothing\n    float perp = bx(p.xy,vec2(t,w)); // perpendicular beam\n    float supp = cn(vec3(p.x,abs(p.yz))-vec3(-t,mix(w,d,.3),t)/2.); // supporting beam\n    return smin(min(supp,body),perp,t/2.)-0.0100;\n}\n\n//d.x = I extrusion depth, d.yz = body dimensions\n//dp = depth of webbing\n//t = I extrusion thickness\n//y = greeble dimension\n//o = 45deg cut offset\nfloat obj(vec3 p, vec3 d, float dp, float t, float y, float o) {\n    float body = -smin(-bx(p.yz,d.yz),(o+p.y-p.z)*.71,0.0500);\n    return feature(vec3(body,abs(p.x),y),dp,d.x,t);\n}\n\n\nfloat walking_beam(vec3 p) {\n    float d = length(p.yz);\n    p.z -= .15;\n    vec3 p2 = p;\n    p2.y=abs(p2.y+2.3)-2.3;\n    float bearing = bx(vec2(length(p2.yz),p2.x),vec2(0.1600,0.7000))-0.0200;\n    p2.z+=mx(-abs(p2.xy))*.4;\n    bearing = min(bearing, bx(p2,vec3(0.4000,0.7000,0.2000))-0.0200);\n    //bearing = min(bearing, bx(p+vec3(0,4.6,mx(-abs(p.xy))*.4),vec3(0.4000,0.7000,0.2000))-0.0200);\n    bearing=-smin(abs(p.x)-0.1000,-bearing,0.0100);\n    \n    p.z -= .80;\n    float beam = obj(p,vec3(0.5000,10.,1.2),\n        0.02,0.02,abs(abs(p.y)-.7)-.5,4.8);\n    \n    p.y -= 4.5;\n    float headsh = -smin(-abs(p.z+1.+p.y*.2)+3.,-max(d-6., -p.y),0.1000); //todo: make head better with better greebles\n    //feature(vec3(head,abs(abs(p.x)-0.3600),0.),0.1000,0.02,0.02);\n    float head=cn(vec2(headsh,abs(abs(p.x)-0.3600)))-0.02;\n    head=min(head,cn(vec3(abs(headsh+0.0500),abs(p.x)-0.4200,-tr(p.z-0.5000,2.8))))-0.02;\n    p.y -= .4;\n    p.z = abs(p.z)-.4;\n    head=min(head,bx(vec2(length(p.yz),p.x),vec2(0.0800,1.0000))-0.0100);\n    p.z-=3.2;p.y-=0.0500;\n    head=-smin(-head,length(p.yz)-0.1000,0.0200);\n    return min(min(bearing, beam),head);\n\n}\n\n// float ladder(vec3 p) {\n//     return obj(p,vec3(0.0700,10.5,.4),\n//         -0.0800,0.02,tr(p.y,10.),1e4);\n// }\n\nfloat ladder_all(vec3 p) {\n    vec3 p2 = p.yzx;\n    p-=vec3(0,0.3000,2.);\n    p=vec3(length(p.xy)-0.3500,atan(p.x,p.y)/3.2,p.z);\n    return min(obj(p2,vec3(0.0700,10.5,.4),\n        -0.0800,0.02,tr(p2.y,10.),1e4),\n        obj(p,vec3(0.0700,1.5,8.),\n        -0.1700,0.02,min(abs(tr(p.y,10.)),abs(tr(p.z,3.))),1e4));\n    // return obj(p2,vec3(0.0700,10.5,.4),\n    //     -0.0800,0.02,tr(p2.y,10.),1e4);\n    // return obj(p,vec3(0.0700,1.5,8.),\n    //     -0.1700,0.02,min(abs(tr(p.y,10.)),abs(tr(p.z,3.))),1e4);\n}\n\n// float ladder_all(vec3 p) {\n//     float l = ladder(p.yzx);\n//     float c = cage(p);\n//     return min(c,l);\n// }\n\nfloat chonker(vec3 p) {\n    p.y-=2.7;\n    p.z-=2.02;\n    return obj(p,vec3(1.5,3.,2.3),\n        1.3,0.02,abs(tr(p.y,4.3))-0.1400,1.6);\n}\n\nfloat base(vec3 p) {\n    p.z -= 0.3800;\n    float front = obj(p.yxz-vec3(-3.9,0,0),vec3(0.3600,2.9,0.9500),\n        0.02,0.02,p.y,1e4);\n    p.x=abs(p.x);\n    p.xy-=vec2(0.5500, 1.);\n    float sides = obj(p.xyz,vec3(0.3300,9.3,0.900),\n        0.02,0.02,p.y-1.,1e4);\n    return min(front,sides);\n}\n\nfloat legs(vec3 p) {\n    vec3 p2 = p;\n    vec3 p3 = p;\n    p.x = abs(p.x)-.77;\n    p.y -= -2.93;\n    p.z -= 5.5;\n    p.y -= p.z*.22;\n    p.x -= p.z*-.11;\n    float leg = obj(p,vec3(0.3000,0.3600,9.2),\n        0.02,0.02,p.y,1e4);\n    p2.y -= 0.2;\n    p2.z -= 6.4;\n    p2=yz(p2,.45);\n    float otherleg = obj(p2,vec3(0.3000,0.3600,8.2),\n        0.02,0.02,p2.z,1e4);\n    p3.z-=10.17;p3.y-=-1.7;\n    float base = bx(p3,vec3(0.8000,0.8000,0.06))-0.0100;\n    //todo: bearing between beam and legs\n    float oz = p3.z;\n    p3=yz(p3,.78);\n    p3.z-=0.1000;p3.x=abs(abs(p3.x)-0.1500)-0.1500;\n    float bearing=max(-oz,bx(p3,vec3(0.1000,0.6000,0.6000)))-0.0100;\n    return min(min(min(base,bearing),otherleg),leg);\n}\n\n// float back_bench(vec3 p) {\n//     //float k = length(vec2(length(p.xz-vec2(.5,1.6))-0.2000,p.y-6.1))-0.0150; //random ring for visual interest\n//     float ox = p.x;\n//     p.x = abs(p.x)-.5;\n//     p.y -= 5.;\n//     p.z -= 1.8;\n//     p.y=-abs(p.y);\n//     p.yz-=min(dot(p.yz,vec2(-.4,.85))*2.,0.)*vec2(-.4,.85);\n//     float b = bx(p,vec3(0.2000,2.3,0.02));\n//     p.z-=0.0500;p.y=abs(p.y)-0.7000;p.y=abs(p.y)-0.2000;p.x+=0.4000;\n//     b = min(b, bx(p,vec3(1.,0.2000,0.02)) );\n//     //p.x-=0.4000;\n//     //vec2 crds = vec2(length(p.xy),p.z+0.0200);\n//     //b = min(b, bx(crds,vec2(0.0200,0.1200)) );\n//     return b-0.0100;\n//     //return min(b-0.0100,k);\n// }\nfloat fence(vec3 p) {\n    float oy = p.y;\n    p.z -= 1.1; p.y -= 2.;p.xy=abs(p.xy);p.z*=-1.;\n    vec3 crds = vec3(bx(p.xy,vec2(4.4,10.)),atan(p.x,p.y)*4.3,p.z);\n    float rep =-mx(-abs(tr(p,vec3(2.1,2.53,8.))));\n    return obj(crds, vec3(0.0500, 50., 2.3), -0.1500, 0.02, rep,oy*.2);\n}\n\nfloat gearbx(vec3 p) {\n    p.yz -= vec2(3.4,4.1);\n    //return bx(p,vec3(1.4,3.,2.));\n    float b = cn(vec2(hex(p.yz,vec3(1)),abs(p.x)-.5))-0.1000;\n    b = smin(bx(vec2(length(p.yz),p.x),vec2(0.4000,2.2)),b,0.6000);\n    p.z -= -.83;\n    float c = bx(p,vec3(1.2, 1.6, 0.0800))-0.0500;\n    p.y -= 1.;\n    p.z -= .5;\n    p.x-=0.0500;\n    b = smin(b, cn(vec2(hex(p.yz,vec3(.5)),abs(p.x)-.3))-0.1000, 0.2000);\n    b = smin(bx(vec2(length(p.yz),p.x),vec2(0.2500,1.3))-0.0500,b,0.3000);\n    b = smin(b,c,0.4000);\n    //b = -smin(-b,abs(p.z),0.0200);\n    //p.z-=.6;\n    //b = -smin(-b,abs(p.z),0.0200);\n    vec3 p2 = p,p3=p;\n    p.y=abs(p.y)-.4;\n    p.x = abs(p.x)-0.1300;\n    b = -smin(-b,length(p.yx)-0.0500,0.0200);\n    p2.x-=.7;\n    p2=yz(p2,-.9);\n    p2.y-=1.;\n    b = min(b, cn(vec2(hex(p2.yz,vec3(.5-p2.y*.2,1.8,1.8))-.2,abs(p2.x)-.15))-0.0100);\n    p3.y-=1.0;\n    p3.z+=1.6;\n    p3.x+=.1;\n    b = min(b, cn(vec2(length(p3.yz)-.35+sin(atan(p3.y,p3.z)*20.)*.01,abs(p3.x)-.55))-0.05);\n    b = min(b, max(p3.z,length(abs(p3.xy)-vec2(.55,.3))-.1));\n    return b;\n}\n//https://twitter.com/AmigaBeanbag/status/1510713873799786503\nfloat tex(vec3 x) {\n  return dot(vec3(.3),sin(mat3(sin(x*32.),sin(x.zxy*43.),sin(x.yzx*52.))*vec3(3.)));\n}\n\nfloat counterweights(vec3 p, float ang) {\n    p.yz -= vec2(3.4,4.1);\n    p.x = abs(p.x)-1.2;\n    p=yz(p,ang);\n    float oy = p.y;\n    float oz = p.z;\n    p.z=abs(p.z);\n    float l = length(p.yz);\n    float cw = -smin(-2.-p.y, -(l-3.5), 0.4000);\n    cw = -smin(-cw,-abs(p.z-1.3)+.84, 0.4000);\n    cw = cn(vec2(cw, abs(p.x)-0.1500))-0.0400;\n    vec3 p3 = p;\n    p3.yz = tr(p3.yz,3.95);\n    cw = -smin(length(p3.yz)-0.1000,-cw,0.0100);\n    vec3 p2 = p;\n    p2.y = abs(p.y+1.)-1.;\n    float b2 = bx(vec2(length(p2.yz)-0.3500,p.x-0.0500),vec2(0.2200,.45))-0.0200;\n    b2 = min(b2,bx(vec2(length(p2.yz),p.x),vec2(0.2900,.5))-0.0200);\n    p.y+=1.6;\n    float b = obj(p, vec3(0.3000, 4., .7), 0.3000-0.06, 0.1000,  tr(p.y, 2.), 2.1);\n    p.z = oz-.8;\n    p.y-=.7;\n    b = -smin(length(p.yz)-0.5500, -b, 0.0600);\n    b = smin(b, b2, 0.2000);\n    b=-smin(abs(oy),-b,0.0500);\n    return min(b, cw);\n}\n\n\n\nfloat equalizer(vec3 p) {\n    p.yx=p.xy;\n    float bearing=bx(vec2(length(p.xz),p.y),vec2(0.6000,0.0900))-0.0200;\n    p.z-=.5;\n    p.y=-abs(p.y);\n    float oz=p.z;\n    float eq = smin(obj(p,vec3(0.2500,3.5,.8),\n        0.02,0.02,-p.y-.5,1.5), bearing,0.0500);\n    p.z -= 2.8;\n    p.y += 1.7;\n    float arm = obj(p.yxz,vec3(0.2500,.4,6.9),\n        0.02,0.02,p.x,1e4);\n    p.z -= 3.1;\n    arm = min(arm,bx(p,.4)-0.0100);\n    arm = -smin(-arm,abs(p.z),0.0300);\n    return min(max((-.45-oz<0.?.08:.02)-eq,arm),eq);\n}\n\n\nfloat wireline(vec3 p, float bz) {\n    p -= vec3(0,-7.8,10.5);\n    float carrierz = -16.+bz;\n    float polish = max(length(p.xy)-0.0300,-0.5000-carrierz+p.z);\n    float carrier = bx(vec2(length(p.xy),p.z-carrierz),vec2(0.3000,0.2000));\n    p.x = abs(p.x)-0.2700;\n    float bridle = max(length(p.xy)-0.0300,max(p.z,carrierz-p.z));\n    p.z=abs(p.z-carrierz-0.1000)-0.1000;\n    carrier=smin(carrier, bx(vec2(length(p.xy),p.z),vec2(0.2000,0.1000)),0.2000);\n    return min(carrier-0.0100,min(bridle,polish));\n}\n\nvec2 poop(vec2 a, vec2 b, float d1, float d3) {\n    float d2 = length(b-a);\n    float p = (d1*d1+d2*d2-d3*d3)/d2/2.;\n    float o = sqrt(d1*d1-p*p);\n    return a + mat4x2(-p,-o,o,-p,p,o,-o,p)*vec4(a,b)/d2;\n}\n\nfloat scene(vec3 p) {\n    //p += tex(p*2.5)*.001;\n    p += sin(p).yzx*.01;\n    p -= sin(p).zxy*.01;\n    p += sin(p*3.).yzx*.001;\n    p -= sin(p*3.).zxy*.001;\n    vec2 id = round(p.xy/60.)*60.;\n    p.xy -= id;\n#ifdef PUMPJACKS\n    float ang = sin(dot(id,vec2(5e4,3e3)))*2e3+2.;\n    p=xy(p,sin(ang)*.1);\n    p.xy+=fract(ang)*8.-4.;\n    vec2 sprocket = vec2(3.4,4.1) - vec2(cos(ang),sin(ang))*2.1;\n    vec2 bearing = poop(vec2(-1.8,10.5500), sprocket, 4.6,6.4);\n    vec2 cable = mix(bearing,vec2(-1.8,10.5500),2.32);\n    vec2 rel = bearing-vec2(-1.8,10.5500);\n    vec2 rel2 = sprocket-bearing;\n    float ang2 = atan(-rel.y,rel.x);\n    float ang3 = -atan(rel2.x,rel2.y);\n\n    //return min(walking_beam(p), ladder_all(yz(p,.1)-vec3(0.8000,1.,-6.)));\n    float pumpjack = base(p);\n    pumpjack = min(pumpjack, chonker(p));\n    pumpjack=min(pumpjack,ladder_all(yz(p*vec3(1,-1,1),.2)-vec3(1.,4.3,4.75))); //todo: flip inside ladder_all..?\n    vec3 pbeam = (p-vec3(0,vec2(-1.8,10.5500)))*vec3(1,-1,1);\n    pbeam=yz(pbeam,ang2);\n    pumpjack=min(pumpjack,walking_beam(pbeam));\n    pumpjack=min(pumpjack,legs(p));\n    // pumpjack=min(pumpjack,back_bench(p));\n    pumpjack=min(pumpjack,fence(p));\n    pumpjack=min(pumpjack,gearbx(p));\n    vec3 epos = p-vec3(0.,bearing);\n    epos = yz(epos,ang3);\n    pumpjack=min(pumpjack,counterweights(p, ang));\n    pumpjack=min(pumpjack,equalizer(epos));\n    return min(pumpjack,wireline(p,cable.y));\n    \n    /*debugging for linkage positions\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,sprocket))-.2);\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,bearing))-.2);\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,vec2(-1.8,10.5500)))-.2);\n    pumpjack = min(pumpjack, length(p-vec3(sign(p.x)*2.,vec2(3.4,4.1)))-.2);\n    */\n#else\n    return length(p);\n#endif\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\n//todo: replace with smaller hashfunc\nfloat hash(float a, float b) {\n    // return fract(100.*fract(sin(a) * 1e4) + fract(sin(b) * 1e4))*2.-1.;\n    // return fract(sin(a*12.9898+b*4.1414) * 43758.5453)*2.-1.;\n    int x = floatBitsToInt(a/7.);//^floatBitsToInt(a+.1);\n    int y = floatBitsToInt(b/7.);//^floatBitsToInt(b+.1);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat rnd1,rnd2,rnd3;\nfloat blades(vec2 p,float o) {\n    // p.x -= (floor(p.x/40.)+.5)*40.;\n    // float id = pow(floor(sqrt(abs(p.x*40.))),2.);\n    // id = sign(p.x)*(id+sqrt(id))/40.;\n    float id = (floor(p.x*1.8)+.5)/1.8;\n    p.x -= id;\n    //p.x = sgn*(p.x*4.-sign(p.x)*(id+sqrt(id)))/4.;\n\n    rnd1 =fract(sin(id*777.+o)*1e5);\n    rnd2 =fract(sin(id*999.+o)*1e4);\n    rnd3 =fract(sin(id*555.+o)*1e3);\n    p.x += pow(p.y,2.)*(pow(rnd2,3.)*sign(rnd1-.5))*2.;\n    return bx(p,vec2(.004-p.y*.02,.5-pow(rnd3,2.)*.5))-.005;\n}\nvec2 blades_norm(vec2 p,float o) {\n    mat2 k = mat2(p,p)-mat2(0.0001);\n    return normalize(blades(p,o) - vec2(blades(k[0],o), blades(k[1],o)));\n}\n\nvec3 pixel_color( vec2 uv )\n{\n    //uv /=1.5;\n    //uv-=vec2(-.0,.5);\n    vec3 cam = normalize(vec3(1.1,uv));\n    vec3 init = vec3(-25,0,1.7);\n    cam=xz(cam,-.19);\n    //init=xz(init,-.1);\n    cam=xy(cam,.81);\n    init=xy(init,.73);\n    // init.y-=-1.;\n    //cam = vec3(1,0,0);\n    //uv.x=-uv.x;\n    //init = vec3(-10,uv*15.);\n    \n    vec3 p = init;\n    bool hit = false;\n    int i;\n    for (i=0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-7;\n        p += dist*cam;\n        //cam = normalize(cam+tex(p*.05)*dist*vec3(0,0,0.00005));\n        if(length(p-init)>550.)break;\n    }\n    float warp = cos(cam.z*10.+cam.x*5.)*.1;\n    float tnear = (.25-init.z+warp) / cam.z;\n    float tfar = (-init.z+warp) / cam.z;\n    vec3 dir = normalize(vec3(-1,-1,1));\n    vec3 n = norm(p);\n    bool gnd = false;\n    float atten = 1.;\n    \n    //float oz = 0.;\n    if (tnear > 0.) {\n        float bbscale = .01;\n        float dx = length(cam.xy)*tnear;\n        float at = atan(cam.x,cam.y);\n        for (int pl = 0; pl < 150; pl++) {\n            int bbid = int(ceil(dx/bbscale)) + pl;\n            float bbx = float(bbid)*bbscale;\n            float off =  fract(sin(bbx*668.)*500.)*500.-250.;\n            float tt = (bbx-dx)/length(cam.xy);\n            vec2 crds = vec2(at*bbx+off,.25+cam.z*tt);\n            //t += tt;\n            vec3 p2 = init+cam*(tnear+tt);\n            //blheight = cos(p2.x*.5)*cos(p2.y*.5)*.5+.5;\n            if (blades(crds,off)>tnear*.0001) continue;\n            if ((tnear+tt) < length(p-init) || !hit) {\n                p = p2;\n                //todo: better normal calc\n                //this is so hilariously silly idk why it works\n                vec2 bn = blades_norm(crds,off);\n                n = normalize(vec3(-cam.xy,(fract(rnd2*1e4)*8.-4.)*crds.y)+(bn.x+rnd2*2.-1.)*vec3(cam.y,-cam.x,0));\n                atten *= crds.y/.25;\n                hit = true;\n                gnd = true;\n                //oz=length(p.xy-init.xy);\n            }\n            break;\n        }\n        if (tfar<length(p-init) || !hit) {\n            p = init+cam*tfar;\n            n = vec3(0,0,1);\n            hit = true;\n            gnd = true;\n            atten = .01;\n        }\n    }\n    vec3 op = p;\n    //if (!hit) return vec3(.86,1.35,2.44);\n    float cloud = tex(cam*.1+cam.z)*.015;\n    if (!hit) return mix(vec3(.4,1.5,2.8),vec3(4.3,5.9,6.6),pow(1.-smoothstep(-0.1,1.1,cam.z-cloud),10.));//*smoothstep(100.,400.,length(p-init));\n    vec3 r = reflect(cam, n);\n    vec3 h = normalize(cam-dir);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1))*smoothstep(-.5,.5,scene(p+n*.5))*smoothstep(-1.,1.,scene(p+n));\n\n    // vec3 ground = vec3(.04,.05,.01);\n    // vec3 sky = vec3(.04,.04,.045);\n    // float fres=1.-abs(dot(cam,n))*.98;\n\n    float sunnordt = max(0.,dot(dir,n));\n    float sunnordtr = max(0.,-dot(dir,n));\n    float sunrefdt = dot(n,h);//*.5+.5;\n    float ggx = .05/(0.99+cos(sunrefdt*2.92));\n    //float roug = step(0.,tex(p.xy*.05));\n    //float ggx = mix(.05/(0.99+cos(sunrefdt*2.92)),.1/(0.96 + cos(sunrefdt*2.7)),roug);\n\n    \n    // vec3 skydiff = mix(ground,sky,n.z*.5+.5)*sqrt(ao);\n    // vec3 sundiff = sunnordt*vec3(5);\n    \n    vec3 skyspec = mix(mix(vec3(0),vec3(.05,.05,.01),smoothstep(-1.1,-.7,n.z)),vec3(.04,.045,.045),smoothstep(-.6,.6,r.z))*sqrt(ao);\n    vec3 sunspec = ggx*sqrt(sunnordt)*.3*vec3(2.2,1.8,1.5);//ggx approximation\n    \n    \n    init = p;\n    p += dir*.001;\n    float minn = 1e4;\n    for (int j = 0; j < 60; j++) {\n        float dist = scene(p);\n        minn=min(minn,dist/length(p-init));\n        if (dist < 0.0001) {minn=0.; break;}\n        p += dist*dir;\n        if(length(p-init)>50.)break;\n    }\n\n    minn = pow(max(minn,0.),.1);\n    vec3 col = (sunspec*minn+skyspec)\n#ifdef COWS\n    *(step(0.1, tex(op*.03))*5.+.25)\n#endif\n    ;\n    \n    vec3 grasscol = rnd3<.5?vec3(.52,.57,.1):vec3(0.322,0.137,0.137);\n    //this grass material has no physical basis\n    if (gnd) col = grasscol*mix(.01,(sunnordt*5.+sunnordtr*.5+ggx*2.)*minn+.4,atten*ao*(minn*.5+.5));//minn*vec3(.1,.2,.05);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfloat sd = float(iFrame);\n\tsd = hash(sd, hash(uv.x,uv.y));\n\tvec2 h2 = tan(vec2(hash(sd, 6.7), hash(sd, 3.6)))*.8;\n\tvec2 uv2 = uv + h2/iResolution.y;//*(iFrame%3==2?2.5:1.);\n\tfragColor += vec4(pixel_color(uv2), 1);//*(iFrame%3==2?-1.:1.);\n\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBcWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftBcWc", "name": "Object Maker", "author": "blackle", "description": "an SDF I used in my 4k exegfx demo \"grazing\"", "tags": ["sdf"], "likes": 14, "viewed": 460, "published": 3, "date": "1650301646", "time_retrieved": "2024-07-30T16:53:00.098092", "image_code": "// the \"obj\" function is one I made to allow me to quickly generate shapes for the pumpjacks in my 4k exegfx demo \"grazing\"\n// can be used to make I-beams with internal supports, steel objects with ridges, and ladders\n\n\n//fancy repetition to make the dictionary compressor happy :3\nfloat mx(vec2 p) {\n    return max(p.x,p.y);\n}\nfloat mx(vec3 p) {\n    return max(p.x,mx(p.yz));\n}\nfloat mx(vec4 p) {\n    return max(p.x,mx(p.yzw));\n}\n#define corner(p) (length(max(p,0.)) + min(0.,mx(p)))\n#define box(p,d) corner(abs(p)-(d/2.))\n//todo: make tri less..... like this\n#define tri(p,r) (asin(sin((p)*r))/r)\n\nfloat hex(vec2 p, vec3 rad) {\n    vec3 p2 = vec3(.81,-.4,-.4)*p.y + vec3(0,-.71,.71)*p.x;\n    return box(p2,vec3(rad));\n}\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat feature(vec3 p, float d, float w, float t) {\n    float body = corner(p.xy-vec2(-t,d)/2.); // main body or nothing\n    float perp = box(p.xy,vec2(t,w)); // perpendicular beam\n    float supp = corner(vec3(p.x,abs(p.yz))-vec3(-t,mix(w,d,.3),t)/2.); // supporting beam\n    return smin(min(supp,body),perp,t/2.)-0.0100;\n}\n\n//d.x = I extrusion depth, d.yz = body dimensions\n//dp = depth of webbing\n//t = I extrusion thickness\n//y = greeble dimension\n//o = 45deg cut offset\nfloat obj(vec3 p, vec3 d, float dp, float t, float y, float o) {\n    float body = -smin(-box(p.yz,d.yz),(o+p.y-p.z)*.71,0.0500);\n    return feature(vec3(body,abs(p.x),y),dp,d.x,t);\n}\n\nfloat scene(vec3 p) {\n    p.z -= .5;\n    float o1 = obj(p, vec3(.2,2.,.3), .01, .01, p.y, 1e4);\n    p.z += .5;\n    float o2 = obj(p, vec3(.2,1.5,.3), .16, .01, p.z, .7);\n    p.z += .5;\n    float o3 = obj(p, vec3(.05,2.,.3), -.1, .01, tri(p.y,12.), 1e4);\n    return min(min(o1,o2),o3);\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.0001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    vec3 atten = vec3(1);\n    vec3 first = vec3(0);\n    bool hit = false;\n    for (int i = 0; i < 150; i++) {\n        float dist = scene(p);\n        //hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>10.) break;\n        if (dist*dist < 1e-6) {\n            vec3 n = norm(p);\n            float fres = 1. - pow(abs(dot(cam,n)),.5)*.98;\n            cam = reflect(cam,n);\n            atten *= vec3(.9) * fres * smoothstep(-.04,.02,scene(p+cam*.02));\n            p += n*.01;\n            if (!hit) {\n                hit = true;\n                first = n;\n            }\n        }\n    }\n    fragColor.xyz = sqrt(atten * length(sin(cam*2.)*.4+.6) );\n    return;\n    /*\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    float spec = length(sin(r*3.5)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.04,.02,scene(p+r*.02));\n    vec3 col = vec3(.4,.1,.1)*pow(spec,2.) + pow(spec,8.);\n    float bgdot = length(sin(cam*2.)*.4+.6)/2.;\n    vec3 bg = vec3(.95,.95,.9) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = sqrt(smoothstep(.1,1.2,sqrt(fragColor)) * (1.- dot(uv,uv)*.5));*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBcWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 282, 300, 300, 327], [328, 328, 346, 346, 378], [379, 379, 397, 397, 430], [600, 600, 629, 629, 721], [722, 722, 761, 761, 831], [833, 833, 883, 883, 1155], [1157, 1306, 1370, 1370, 1488], [1490, 1490, 1511, 1511, 1777], [1779, 1779, 1798, 1798, 1913], [1915, 1915, 1953, 1953, 2015], [2017, 2017, 2074, 2074, 3766]], "test": "untested"}
{"id": "7lBcWy", "name": "mackjam_ab", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 5, "viewed": 447, "published": 3, "date": "1650301307", "time_retrieved": "2024-07-30T16:53:00.899948", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime \n//texture(texFFTIntegrated, a).x\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  p.xz *= r2d(.5*sin(.1*p.y));\n  p.xz += vec2(sin(iTime), cos(iTime*.75+p.y*.1))*5.;\n  float rad = 20.;\n  vec3 pdart = p+vec3(0.,FFTI(.1)*50.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./12.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  float rada = mix(10.,20.,sin(idda)*.5+.5);\n  pdart -= vec3(0.,45.,rada);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p;\n  float stpcube = PI*2./40.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  pcube -= vec3(0.,0.,rad);\n  float repyc = .5;\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.1+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2;\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 ro = vec3(0.,-5.,-5.);\n  vec3 ta = vec3(0.,25.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  \n  vec3 col = rdr(uv);\n  \n  col *= 1.-sat(length(uv));\n  //col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  col *= vec3(199, 242, 58)/255.;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 28778, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBcWy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[509, 509, 536, 536, 581], [583, 583, 612, 612, 669], [671, 671, 690, 690, 747], [749, 749, 767, 767, 2007], [2009, 2009, 2040, 2040, 2165], [2167, 2167, 2198, 2198, 2307], [2323, 2323, 2364, 2364, 2724], [2726, 2726, 2745, 2745, 3292], [3294, 3294, 3351, 3351, 3609]], "test": "untested"}
{"id": "stBcWy", "name": "mackjam_aa", "author": "z0rg", "description": "Done during revision 2020 Mack's DJ set", "tags": ["fractal", "revision", "techno", "jam"], "likes": 1, "viewed": 261, "published": 3, "date": "1650301294", "time_retrieved": "2024-07-30T16:53:04.489351", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFTI(a) iTime\n//texture(texFFTIntegrated, a).x\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(10000.,-1.);\n  \n  acc = _min(acc, vec2(length(p+vec3(0.,0.,-15.))-1., 0.));\n \n  float rad = mix(10.,20.,sin(p.y)*.5+.5);\n  vec3 pdart = p+vec3(0.,FFTI(.1)*5.,0.);\n  float adart = atan(pdart.z, pdart.x);\n  float stpdart = PI*2./12.;\n  float sector = mod(adart+stpdart*.5,stpdart)-stpdart*.5;\n  pdart.xz = vec2(sin(sector), cos(sector))*length(pdart.xz);\n  float repyd = 15.;\n  float idda = floor((pdart.y+repyd*.5)/repyd);\n//  pdart.xz *= r2d(idda);\n  pdart -= vec3(0.,45.,rad);\n  pdart.y = mod(pdart.y+repyd*.5,repyd)-repyd*.5;\n  float dart = _cube(pdart, vec2(.1,5.).xxy);\n  acc = _min(acc, vec2(length(pdart-vec3(0.,0.,-5.))-0.25,-1.));\n  \n  acc = _min(acc, vec2(dart, 0.));\n  \n  vec3 pcube = p;\n  float stpcube = PI*2./40.;\n  float sectorcube = mod(adart+stpcube*.5,stpcube)-stpcube*.5;\n  pcube.xz = vec2(sin(sectorcube), cos(sectorcube))*length(pcube.xz);\n  pcube -= vec3(0.,0.,rad);\n  float repyc = .5;\n  pcube.y = mod(pcube.y+repyc*.5,repyc)-repyc*.5;\n  acc = _min(acc, vec2(_cube(pcube, vec3(.5,.2,2.)), 1.));\n  \n  float tunnel = -(length(p.xz)-rad);\n  acc = _min(acc, vec2(tunnel, 0.));\n  \n  return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)); \n}\nvec3 accLight;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accLight = vec3(0.);\n  vec3 p  = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(p, ro), res.y);\n    if (res.y < 0.)\n      accLight += (vec3(172, 38, 235)/255.)*0.5+vec3(sin(distance(p, ro)*1.+iTime)*.5+.5, .5, .1)*(1.-sat(res.x/5.5))*.2;\n    p+=rd*res.x*.5;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 background = vec3(212, 140, 32)/255.;\n  vec3 col = background;\n  \n  vec3 ro = vec3(0.,-5.,-5.);\n  vec3 ta = vec3(0.,25.,0.);\n  vec3 rd = normalize(ta-ro);\n  \n  rd = getCam(rd, uv);\n\n  float depth = 150.;\n  vec3 res = trace(ro, rd, 128);\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = n*.5+.5;\n    \n    col = (vec3(23, 24, 51)/255.)*sat(dot(normalize(vec3(n.x, -1., n.z)), n));\n  }\n  col += accLight;\n  col = mix(col, vec3(0.), 1.-sat(exp(-depth*depth*0.0001)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.xx;\n  \n  \n  vec3 col = rdr(uv);\n  \n  col *= 1.-sat(length(uv));\n  col = mix(col, vec3(199, 242, 58)/255., 1.-pow(sat(length(col)),8.));\n  \n\tfragColor = vec4(col.zxy, 1.);\n}", "image_inputs": [{"id": 28777, "src": "https://soundcloud.com/instinktlab/juri-heidemann-snura-original?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBcWy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[508, 508, 535, 535, 580], [582, 582, 611, 611, 668], [670, 670, 689, 689, 746], [748, 748, 766, 766, 1898], [1900, 1900, 1931, 1931, 2056], [2058, 2058, 2089, 2089, 2198], [2214, 2214, 2255, 2255, 2615], [2617, 2617, 2636, 2636, 3183], [3185, 3185, 3242, 3242, 3471]], "test": "untested"}
{"id": "st2cDV", "name": "Digital doughnut", "author": "me_123", "description": "A bright domo of game of life on a torus. Includes motion blur, and bloom.", "tags": ["torus", "motionblur", "bloom", "mapping", "life", "gol"], "likes": 15, "viewed": 310, "published": 3, "date": "1650292864", "time_retrieved": "2024-07-30T16:53:05.736018", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec4 c = texelFetch(iChannel1, ivec2(fragCoord), 0); //original image before bloom\n    fragColor = (texelFetch(iChannel0, ivec2(fragCoord), 0)+c*0.5); //mix original image with bloom \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//buffer A: game of life, and camera state\nint get(in ivec2 p) { //get GOL pixel\n    ivec2 rp = (p-ivec2(1, 0));\n    \n    //the oposite edges are joind, resulting in a torus \n    if (rp.x > int(res.x)) rp.x = 0;\n    if (rp.x < 0) rp.x = int(res.x);\n    if (rp.y > int(res.y)) rp.y = 0;\n    if (rp.y < 0) rp.y = int(res.y);\n    \n    \n    return int(texelFetch(iChannel0, ivec2(rp)+ivec2(1, 0), 0).x);\n}\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\nfloat hash1(in float p) {\n    p = fract(p*0.1031);\n    p *= p+33.33;\n    p *= p+p;\n    return fract(p);\n}\nfloat n(in float p) { //1D noise\n    float f = floor(p);\n    return mix(hash1(f), hash1(f+1.), fract(p));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec4 old = texelFetch(iChannel0, fc, 0);\n    if (fc == ivec2(0)) {\n        float y = (((iMouse.y)/(iResolution.y))*3.14)+0.01;\n        float ty = 3.1415*(cos(iTime+n(iTime))+1.0)*0.5;\n        fragColor = vec4(iMouse.z > 0.0 ? vec3(\n            iMouse.x*0.01,\n            y,\n            y*0.1\n        ) : vec3((iTime*3.0)+sin(iTime*2.0+n(iTime*0.5))*2., ty, ty*0.5)\n        , 0);\n    }\n    if (fc == ivec2(0, 1)) {\n        fragColor = texelFetch(iChannel0, ivec2(0, fc.y-1), 0);\n    }\n    if (fc.x < 1 || fc.x > int(res.x)+1 || fc.y > int(res.y)) return;\n    fragColor = old;\n    \n    if (iFrame < 10) { //init\n    \n        //lots of gliders\n        fc = (fc-ivec2(1, 0))%6;\n        if (fc == ivec2(0, 0)) fragColor.x = 1.;\n        if (fc == ivec2(1, 0)) fragColor.x = 1.;\n        if (fc == ivec2(2, 0)) fragColor.x = 1.;\n        if (fc == ivec2(2, 1)) fragColor.x = 1.;\n        if (fc == ivec2(1, 2)) fragColor.x = 1.;\n        return;\n    } else {\n        #if JUSTGLIDERS\n        #else\n        if (hash(fragCoord+iTime) < 0.000001) {\n            fragColor = vec4(1.-fragColor.x, 0, 0, 0);\n            return;\n        }\n        #endif\n        int sum = get(fc+ivec2(-1, -1))+\n                  get(fc+ivec2(-1, 0))+\n                  get(fc+ivec2(-1, 1))+\n\n                  get(fc+ivec2(0, -1))+\n                  get(fc+ivec2(0, 1))+\n                  \n                  get(fc+ivec2(1, -1))+\n                  get(fc+ivec2(1, 0))+\n                  get(fc+ivec2(1, 1));\n\n        bool s = false;;\n        bool o = bool(float((sum-3) == 0) + float(sum-2 == 0) * old);\n        \n        if (o) {\n           fragColor = vec4(o, 0, 0, 0);\n        } else {\n           fragColor = vec4(0, old.y + 1.0, 0, 0);\n        }\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BLOOM 1\n#define JUSTGLIDERS 0\nconst vec2 res = vec2(3, 1)*64.0;", "buffer_b_code": "//Buffer B: render scene pre bloom\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\nvec2 hash2(in vec2 p) {\n    vec3 p3 = fract(p.xyx*vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat nh(in vec3 p3) {\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\nfloat noise(in vec3 p) {\n    vec3 c = floor(p);\n    vec3 f = fract(p);\n    return mix( \n                mix(\n                    mix( nh(c+vec3(0, 0, 0)), nh(c+vec3(1, 0, 0)), f.x), \n                    mix( nh(c+vec3(0, 1, 0)), nh(c+vec3(1, 1, 0)), f.x), \n                f.y),   \n                mix(\n                    mix( nh(c+vec3(0, 0, 1)), nh(c+vec3(1, 0, 1)), f.x), \n                    mix( nh(c+vec3(0, 1, 1)), nh(c+vec3(1, 1, 1)), f.x), \n                f.y), \n            f.z); \n}\nfloat fbm(in vec3 p) {\n    float v = 0.0;\n    for (int i = 0; i < 5; i += 1) {\n        float s = float(1<<i);\n        v += noise(p*s)/s;\n    }\n    return v;\n}\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd, in int i) \n{\n    vec2 uv = ((fragCoord.xy+(hash2(fragCoord+float(i))-0.5))/iResolution.xy)-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float y = (((iMouse.y)/(iResolution.y))*3.14)+0.01;\n    \n    //linear interplate from old camera inputs to current camera inputs by a random factor for motion blur\n    vec3 an = mix(texelFetch(iChannel0, ivec2(0, 0), 0).xyz,\n                  texelFetch(iChannel0, ivec2(0, 1), 0).xyz,\n                  hash(fragCoord+iTime+float(i)*0.1));\n    //calculate camera position from poler coords\n    ro = vec3(\n        cos(an.x)*sin(an.y),\n        sin(an.x)*sin(an.y),\n        cos(an.y)\n    )*3.0;\n    \n    //get ray direction twords the center\n    vec3 cam_z = normalize(-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 0, 1), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.1 * cam_z);\n    \n    //camera xz rototion\n    mat2 r = mat2(cos(an.z), -sin(an.z), sin(an.z), cos(an.z));\n    rd.xz *= r;\n    ro.xz *= r;\n}\n\n//torus intersection and normal by Iq\nfloat tor( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)*0.5;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0*0.3333333); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0*0.3333333); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        return t;\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n}\n\nvec3 torNormal( in vec3 pos, vec2 tor )\n{\n    return normalize( pos*(dot(pos,pos)-tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\nvec3 sky(in vec3 rd) {\n    return (vec3(0.0, 0.5, 0.3)*pow(fbm(1.0+rd*4.), 4.0));\n}\nconst vec2 t = vec2(1 ,0.4);\nvec4 getColor(in vec3 ro, in vec3 rd) {\n    float d = tor(ro, rd, t); //depth to torus\n    if (d < 0.0) { //calculate sky\n        vec3 s = sky(rd);\n        return vec4(0);\n    }\n    vec3 p = ro+rd*d; //position on torus\n    vec3 n = torNormal(p, t); //normal\n    vec3 op = p; //untransformed position on torus\n    \n    p /= vec2(t.x+t.y, t.y).xxy; //normalize coords between -1, 1\n    \n    //toroidal and poloidal coordinates from point on surface\n    float y = (((length(vec2(length(vec2(n.x, n.y))-1.0, n.z)))));\n    if (p.z < 0.0) y = -y;\n    if (length(op.xy) < t.x) {\n        y = -(y)-2.8;\n    }\n    vec2 z = (vec2((atan(p.x, p.y)+3.141592653589793)*0.15915494309189535, ((y+4.13)*0.18)))*res;\n    \n    //map game of life from buffer A to torus\n    vec4 o = texelFetch(iChannel0, ivec2(ceil(z))+ivec2(1, 0), 0);\n    vec3 c = mix(vec3((-dot(rd, n))*0.25), vec3(0.2, 0.2, 1)*10., o.x);\n    if (o.x == 0.0) c += (30.-min(30., o.y))*vec3(1.0, 0.2, 0.2)*0.1;\n    return vec4(c, o.x > 0.0 || o.y < 10.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec3 rd;\n\tvec3 ro;\n    \n    //AA and motion blur sampling\n    for (int i = 0; i < 10; i += 1) {\n        Camera(fragCoord, ro, rd, i);\n        vec4 c = getColor(ro ,rd);\n        fragColor += vec4(c);\n    }\n    fragColor *= 0.1;\n    fragColor = max(fragColor, 0.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Buffer C: bloom X\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    #if BLOOM\n    vec3 b = vec3(0);\n    int r = int(iResolution.x/20.);\n    float rr = 1./float(r);\n    for (int x = -r; x < r; x += 1) {\n        vec4 s = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(x, 0), 0);\n        if (s.w > 0.0) {\n            float ss = 1.-abs(float(x)*rr);\n            b += (s.xyz*ss*ss)*0.1;\n        }\n    }\n    fragColor = vec4((b)*rr*10., 1);\n    #endif\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Buffer D: bloom y\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    #if BLOOM\n    vec3 b = vec3(0);\n    int r = int(iResolution.x/20.);\n    float rr = 1./float(r);\n    for (int x = -r; x < r; x += 1) {\n        vec4 s = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0, x), 0);\n        if (s.w > 0.0) {\n            float ss = 1.-abs(float(x)*rr);\n            b += (s.xyz*ss*ss)*0.1;\n        }\n    }\n    fragColor = vec4((b)*rr*10., 1);\n    #endif\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2cDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 249]], "test": "untested"}
{"id": "7ljyDK", "name": "Ghosts of Numbers 2", "author": "tomachi", "description": "tried to use a triple buffer to smooth the flicker. not sure it worked.", "tags": ["gyroid"], "likes": 0, "viewed": 206, "published": 3, "date": "1650280617", "time_retrieved": "2024-07-30T16:53:07.135277", "image_code": "// Fork of https://www.shadertoy.com/view/Wd2GzV\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor =texelFetch(iChannel0,ivec2(fragCoord),0) + texelFetch(iChannel1,ivec2(fragCoord),0) + texelFetch(iChannel2,ivec2(fragCoord),0);\n  // fragColor = vec4(0.999333)* texelFetch(iChannel0,ivec2(fragCoord),0) * texelFetch(iChannel1,ivec2(fragCoord),0)+ texelFetch(iChannel2,ivec2(fragCoord),0);\n  //  fragColor = texelFetch(iChannel1,ivec2(fragCoord),1) ;\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define useAA false\n#define S smoothstep\n#define T iTime *0.25\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat anisotropicAA(vec3 p) {\n    p *= -10.+ T; // # TIME\n    vec3 p2 = p  *  -9.9 + T ; // # 10 ms TIME anisotropic anti-alias!\n    vec3 p3 = p  *  -9.8 + T ; // # 20 ms TIME anisotropic anti-alias!\n    return (dot(sin(p), cos(p.zxy)) +  dot(sin(p2), cos(p.zxy)) +  dot(sin(p3), cos(p.zxy)) );\n}\nfloat sdGyroid(vec3 p) {\n    if( useAA == true) { return anisotropicAA(p); } \n    p *= -20.+ T; // # TIME\n    return dot(sin(p), cos(p.zxy)) ;\n}\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    float gyroid = sdGyroid(p);\n    return dot(box, gyroid);\n    return gyroid;\n    return box;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0),1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = n * vec3(dif);\n    }\n    \n   // col = pow(col, vec3(.3));\t// gamma correction\n//\n   // fragColor += texelFetch(iChannel1,ivec2(fragCoord),0) +  vec4(col,1.0);\n\n    //fragColor =  texelFetch(iChannel1,ivec2(fragCoord),0) + texelFetch(iChannel2,ivec2(fragCoord),0) + vec4(col,1.0);\n    fragColor = vec4(col,1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define useAA false\n#define S smoothstep\n#define T (iTime *0.25) + .0001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat anisotropicAA(vec3 p) {\n    p *= -10.+ T; // # TIME\n    vec3 p2 = p  *  -9.9 + T ; // # 10 ms TIME anisotropic anti-alias!\n    vec3 p3 = p  *  -9.8 + T ; // # 20 ms TIME anisotropic anti-alias!\n    return (dot(sin(p), cos(p.zxy)) +  dot(sin(p2), cos(p.zxy)) +  dot(sin(p3), cos(p.zxy)) );\n}\nfloat sdGyroid(vec3 p) {\n   // if( useAA == true) { return anisotropicAA(p); } \n    p *= -20.+ T; // # TIME\n    return dot(sin(p), cos(p.zxy)) ;\n}\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    float gyroid = sdGyroid(p);\n    return dot(box, gyroid);\n    return gyroid;\n    return box;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0),1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = n * vec3(dif);\n    }\n    \n   // col = pow(col, vec3(.3));\t// gamma correction\n//\n   // fragColor += texelFetch(iChannel1,ivec2(fragCoord),1) +  vec4(col,1.0);\n\n   // fragColor = texelFetch(iChannel0,ivec2(fragCoord),0) + texelFetch(iChannel2,ivec2(fragCoord),0) +  vec4(col,1.0);\n    fragColor = vec4(col,1.0);\n\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define useAA false\n#define S smoothstep\n#define T (iTime *0.25) + .0002\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat anisotropicAA(vec3 p) {\n    p *= -10.+ T; // # TIME\n    vec3 p2 = p  *  -9.9 + T ; // # 10 ms TIME anisotropic anti-alias!\n    vec3 p3 = p  *  -9.8 + T ; // # 20 ms TIME anisotropic anti-alias!\n    return (dot(sin(p), cos(p.zxy)) +  dot(sin(p2), cos(p.zxy)) +  dot(sin(p3), cos(p.zxy)) );\n}\nfloat sdGyroid(vec3 p) {\n   // if( useAA == true) { return anisotropicAA(p); } \n    p *= -20.+ T; // # TIME\n    return dot(sin(p), cos(p.zxy)) ;\n}\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    float gyroid = sdGyroid(p);\n    return dot(box, gyroid);\n    return gyroid;\n    return box;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0),1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = n * vec3(dif);\n    }\n    \n   // col = pow(col, vec3(.3));\t// gamma correction\n//\n   // fragColor += texelFetch(iChannel1,ivec2(fragCoord),1) +  vec4(col,1.0);\n\n   // fragColor = texelFetch(iChannel0,ivec2(fragCoord),0) + texelFetch(iChannel1,ivec2(fragCoord),0) +  vec4(col,0);\n    fragColor = vec4(col,1.0);\n\n}\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 107, 107, 473]], "test": "untested"}
{"id": "7ljyWK", "name": "Newb2", "author": "7wingfly", "description": "Basically the same as Newb1 but I figured some stuff out about using the mouse (please click and drag)\n\nNewb1: https://www.shadertoy.com/view/7tByWK", "tags": ["newb"], "likes": 0, "viewed": 214, "published": 3, "date": "1650274233", "time_retrieved": "2024-07-30T16:53:07.942119", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p - iMouse.xy / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * sin(vec3(0,2,4) + iTime / 2.);\n    \n    float r = 0.4 + 0.1 * cos(atan(-p.x + 2., q.y / 2.) * 60.0 + 20.0 * -q.x + ((length(iMouse) / 50.) * 2.));\n\n    float r1 = 0.2 + 0.1 * cos(atan(-p.x + 2., -p.y / 2.) * 5.0 + 20.0 * -q.x + iTime * 2.);\n    float r2 = 0.4 + 0.1 * cos(atan(-p.x + 4., -q.y / 2.) * 10.0 + 20.0 * -q.x + iTime * 4.);\n    float r3 = 0.6 + 0.1 * cos(atan(-p.x + 6., -q.y / 2.) * 20.0 + 20.0 * -q.x + iTime * 6.);\n    \n    col /= smoothstep(r / 100., r, length(q)) / .2;\n\n    col.x /= smoothstep(r1 / 100., r1, length(q)) / .2;\n    col.y /= smoothstep(r2 / 100., r2, length(q)) / .2;\n    col.z /= smoothstep(r3 / 100., r3, length(q)) / .2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 964]], "test": "untested"}
{"id": "ftjyDK", "name": "Sparkly Things", "author": "oneshade", "description": ".", "tags": ["star", "lights", "sparkle"], "likes": 63, "viewed": 1397, "published": 3, "date": "1650259686", "time_retrieved": "2024-07-30T16:53:08.992311", "image_code": "float Hash31(in vec3 p) {\n     return fract(937.276 * cos(836.826 * p.x + 263.736 * p.y + 374.723 * p.z + 637.839));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float time = iTime * 2.0;\n    vec3 color = vec3(0.0);\n\n    for (float i=-3.0; i <= 3.0; i += 1.25) {\n        for (float j=-2.0; j <= 2.0; j += 1.25) {\n            vec2 p = uv;\n\n            float freq = fract(643.376 * cos(264.863 * i + 136.937)) + 1.0;\n            vec2 pos = 5.0 * vec2(i, j) + vec2(sin(freq * (iTime + 10.0 * j) - i), freq * iTime);\n            pos.y = mod(pos.y + 15.0, 30.0) - 15.0;\n            pos.x *= 0.1 * pos.y + 1.0;\n            p -= 0.2 * pos;\n\n            float an = mod(atan(p.y, p.x) + 6.2831 / 3.0, 6.2831 / 6.0) - 6.2831 / 3.0;\n            p = vec2(cos(an), sin(an)) * length(p);\n\n            float sec = floor(time);\n            float frac = fract(time);\n            float flicker = mix(Hash31(vec3(i, j, sec)), Hash31(vec3(i, j, sec + 1.0)), frac);\n\n            float rad = 25.0 + 20.0 * flicker;\n            float br = 250.0 * pow(1.0 / max(10.0, rad * (sqrt(abs(p.x)) + sqrt(abs(p.y))) + 0.9), 2.5);\n            float rand = fract(847.384 * cos(483.846 * i + 737.487 * j + 264.836));\n            if (rand > 0.5) color += mix(vec3(br, 0.4 * br, 0.0), vec3(1.0), br);\n            else color += mix(vec3(0.0, 0.0, 0.6 * br), vec3(1.0), br);\n\n            color *= 0.955 + 0.1 * flicker;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 118], [120, 120, 175, 175, 1523]], "test": "untested"}
{"id": "7lSyDV", "name": "Iterative SDF for any Function", "author": "Spi3lot", "description": "Feel free to use this implementation in your own code but please give credit to me if you do so - I had to do a lot of analysis on this algorithm (which is also the reason for the many comments) for all these optimizations to be found.", "tags": ["sdf", "distance", "de", "field", "function", "iterative", "iteration", "all", "signed", "any", "arbitrary", "estimate"], "likes": 8, "viewed": 285, "published": 3, "date": "1650244523", "time_retrieved": "2024-07-30T16:53:10.048488", "image_code": "/********************************************************\n\nI don't know if this algorithm is new (probably not),\nbut if it is\n    or you use my implementation\n    or any modified version of it,\n[PLEASE GIVE CREDIT TO ME] FOR DEVELOPING THE ALGORITHM\n\nFollow-up: https://www.shadertoy.com/view/flGcWz\n\n********************************************************/\n\n\n\n\n\n// CONSTANTS\n#define E cosh(1.0) + sinh(1.0)\n#define PI acos(-1.0)\n\n// SDF SETTINGS\n#define MAX_SDF_ITERATIONS (iTime * 5.)\n\n#define FAST\n\n\nfloat f(float x)\n{\n    //return sin(x + iTime) + sin(x - iTime);\n    return 15.0 * (sin(x * 2.0) + sin(1.1 * (x + PI * 0.5)));  // Rather steep function - good example\n    //return tan(x);  // Good example for the limits of this algorithm - the SDF for tan(x) takes a lot of iterations for it to converge because tan(x) is so steep\n}\n\n// WITH COMMENTS (scroll down a bit for version without comments)\nfloat sdf_by_Spi3lot(vec2 p)\n{\n    float y0 = f(p.x);\n    float minDist = p.y - y0;\n    \n    // Above function -> 1.0\n    // Exactly on function -> 0.0\n    // Below function -> -1.0\n    float sgn = sign(minDist);\n\n    // Make minDist non-negative (probably faster than abs because I already have the sign)\n    minDist *= sgn;\n\n    // i=1 and not i=0 (at the start of the loop)\n    //     because I count the first minDist initialization as the first iteration\n    //   AND\n    // Using < and not <=\n    //     because when i == MAX_SDF_ITERATIONS then dx == minDist and\n    //     when dx (>)= minDist then the distance can only be >= the current minDist\n    //     which means we can prune this iteration where i == MAX_SDF_ITERATIONS\n    for (float i = 1.; i < MAX_SDF_ITERATIONS; i++)\n    {\n        float dx = minDist * i / MAX_SDF_ITERATIONS;\n\n        float xL = p.x - dx;\n        float yL = f(xL);\n\n        float xR = p.x + dx;\n        float yR = f(xR);\n\n        float distL, distR, mini;\n        \n        // THE PRUNING SECTION CAN BE COMMENTED OUT\n        // BECAUSE THE PERFORMANCE IS WORSE THAN WITHOUT IT\n\n        /* (put/remove character between * and / for commenting out) -> * /\n        // vvvvvvvvvv PRUNING vvvvvvvvvv\n        bool pruneL = (yL < y0);  // Distance to left must be greater than p.y-y0 -> PRUNE\n        bool pruneR = (yR < y0);  // Distance to right must be greater than p.y-y0 -> PRUNE\n\n        if (pruneL && pruneR)\n        {\n            continue;  // Nothing changed\n        }\n\n        else if (pruneL)\n        {\n            distR = distance(p, vec2(xR, yR));\n            mini = distR;  // Minimum for sure\n        }\n        \n        else if (pruneR)\n        {\n            distL = distance(p, vec2(xL, yL));\n            mini = distL;  // Minimum for sure\n        }\n        \n        else\n        // ^^^^^^^^^^^^ PRUNING ^^^^^^^^^^^^\n        /* */\n        {\n            distL = distance(p, vec2(xL, yL));\n            distR = distance(p, vec2(xR, yR));\n\n            mini = min(distL, distR);\n        }\n        \n\n        if (mini < minDist)\n        {\n        #ifndef FAST\n            // Resetting i - The crucial difference which slows down everything by A LOT\n            // but also increases the speed of convergence of the minDist by quite a bit.\n\n            // BUT the total amount of iterations will still increase by such a big amount\n            // that this \"(actually not) optimized\" method where i is reset\n            // becomes COMPLETELY USELESS compared to the FAST one where i is NOT reset\n            i = 1.;\n        #endif\n        \n            // The algorithm works very well even without resetting i (resetting i whenever\n            // a smaller minDist was found) -> because when minDist gets updated, dx will\n            // get smaller which means p.x+dx will be closer to p.x and when i is reset\n            // we get closer and closer to p.x everytime we find a new and smaller distance,\n            // but as we get closer to p.x, the distance from p to the function\n            // approaches p.y-f(p.x) which is exactly what we DO NOT want\n            // since we could just scrap the iteration part\n            // and just return p.y-f(p.x) if this was what we wanted.\n            minDist = mini;\n        }\n    }\n\n    return sgn * minDist;\n}\n\n\n// WITHOUT COMMENTS AND UNNECESSARY CODE (scroll up a bit for version with comments)\n// copy/paste ready (name of function can be changed of course,\n// but if you remove my name please give credit to me in a comment or so)\nfloat sdf_by_Spi3lot_pure_no_comments(vec2 p)\n{\n    float y0 = f(p.x);\n    float minDist = p.y - y0;\n    float sgn = sign(minDist);\n    minDist *= sgn;\n\n    for (float i = 1.; i < MAX_SDF_ITERATIONS; i++)\n    {\n        float dx = minDist * i / MAX_SDF_ITERATIONS;\n\n        float xL = p.x - dx;\n        float yL = f(xL);\n\n        float xR = p.x + dx;\n        float yR = f(xR);\n\n        float distL = distance(p, vec2(xL, yL));\n        float distR = distance(p, vec2(xR, yR));\n        float mini = min(distL, distR);\n        \n        minDist = min(minDist, mini);\n    }\n\n    return sgn * minDist;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 pos = 100.0 * (uv - vec2(0.0, 0.5));\n    float dist = sdf_by_Spi3lot(pos);\n    vec3 col = vec3(abs(dist));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 522, 568, 837], [839, 905, 935, 935, 4203], [4206, 4429, 4476, 4476, 5025], [5029, 5029, 5086, 5136, 5354]], "test": "untested"}
{"id": "7lByDK", "name": "Mountainy Stuff", "author": "SnoopethDuckDuck", "description": "just playing with textures", "tags": ["e"], "likes": 11, "viewed": 336, "published": 3, "date": "1650240019", "time_retrieved": "2024-07-30T16:53:10.992963", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    //was 0.15\n    float t = 0.04 * iTime;\n    float r = 3.4;\n    vec3 ro = vec3(r * cos(t), 1.58, r * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat test(vec2 uv) {\n    float t;\n    float m = 1.;\n    for (int i = 0; i < 6; i++) {\n        t += m * texture(iChannel0, uv)[i % 3];\n        m *= 0.3;\n        uv *= 3.;\n    }\n    return t;\n}\n\nfloat GetDist(vec3 p) {\n    float d = p.y;\n\n    vec2 uv = 0.02 * p.xz;\n    float t = test(uv);\n    d -= t;\n    // falloff from center gives feeling of roundness like a planet\n    // looks worse?\n    d += 0.025 * (length(p.xz) - 1.);\n    return 0.5 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,1.15,0), 4.); //was vec3(0), 1.\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    vec3 e = vec3(0.5);\n    vec3 col2 = pal(-0.15, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    \n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {     \n        vec3 n = GetNormal(p);\n        \n        float dif = dot(n, normalize(vec3(0,1.5,3)))*.6+.4;\n        col = vec3(dif);\n        \n        vec3 c = texture(iChannel0, p.xz).rgb;\n      //  col *= c;\n        col *= p.y-0.25;\n        vec2 uv = 0.02 * p.xz;\n        float t = test(uv);\n        col *= t;\n        vec3 e = vec3(0.5);\n        col *= pal(1.15 + t, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        \n        float fres = pow(1. + dot(rd, n), 1.);\n        col = mix(col, col2, 0.04 * fres);\n        \n        float sc = 0.25;\n        \n        vec3 c1 = texture(iChannel1, sc * (0.5 + 0.5 * p.xy)).rgb;\n        vec3 c2 = texture(iChannel1, sc * (0.5 + 0.5 * p.yz)).rgb;\n        vec3 c3 = texture(iChannel1, sc * (0.5 + 0.5 * p.zx)).rgb;\n        \n        n = abs(n);\n        vec3 c4 = n.z * c1 + n.x * c2 + n.y * c3;\n        col *= c4 * 1.3;\n        \n    }\n    \n    // I like \n    col *= 0.82 + 0.18 * thc(1.,30. * p.y) * exp(-0.2 * p.y);\n    \n    col = mix(col, col2, 1.-exp(-0.05 * length(p.xz)));\n    vec3 col3 = pow(col, vec3(.4545));\t// gamma correction\n    col = col3;\n    //col = mix(col, col3, step(fract(10. * uv.x), 0.1));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xy;\n\n    float sc = 14. + 0.25 * cos(3.5 * uv.x + iTime);\n    vec2 ipos = floor(sc * uv) + 0.;\n    vec2 fpos = fract(sc * uv) - 0.;\n       \n    // m determines what new cell the old cell lies in\n    // 3 -> small\n    // 0 -> tl big, 2 -> tr big, 4 -> bl big, 1 -> br big\n    float m = mod(2. * ipos.x - ipos.y, 5.);\n    \n    // id = 2 if small cell, id = 1 if big cell (used to make outlines same size)\n    float id = 2.;\n    vec2 o = vec2(0);\n    \n    if (m != 3.) { fpos *= 0.5;  id = 1.; }    \n    if (m == 2.)      o = vec2(1,0); // top right\n    else if (m == 4.) o = vec2(0,1); // bottom left\n    else if (m == 1.) o = vec2(1);   // bottom right\n    \n    // if in big cell, halve fpos + translate\n    fpos += 0.5 * o - 0.5;\n    ipos -= o;\n    \n    float h = 2. * pi * h21(ipos);\n    \n    float c = cos(h + pi * id + iTime);    \n    float d = mix(mlength(fpos), length(fpos), 0.5 + 0.5 * c);\n    \n    float k = 20. / iResolution.y;\n    float s = 1. - smoothstep(-k, k, -d + 0.5 - (0.1 + 0.05 * c) * id);// - length(fpos);\n\n    vec3 e = vec3(0.5);\n    vec3 col = s * pal(h + 0.05 * iTime, e, e, e, 0.5 * vec3(0., 0.33, 0.66));\n    col += 0.14;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lByDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 806], [808, 808, 829, 829, 1000], [1002, 1002, 1025, 1025, 1256], [1258, 1258, 1301, 1301, 1608], [1610, 1610, 1634, 1634, 1824], [1826, 1826, 1876, 1876, 2067], [2069, 2069, 2126, 2126, 3654]], "test": "untested"}
{"id": "7tByWK", "name": "Newb1", "author": "7wingfly", "description": "I am a newb. This is my first shader.", "tags": ["newb"], "likes": 2, "viewed": 188, "published": 3, "date": "1650223702", "time_retrieved": "2024-07-30T16:53:11.814765", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p - vec2(0.5, 0.5);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * sin(vec3(0,2,4) + iTime / 2.);\n    \n    float r = 0.4 + 0.1 * cos(atan(-p.x + 2., -p.y / 2.) * 60.0 + 20.0 * -q.x + iTime * 2.);\n\n    float r1 = 0.2 + 0.1 * cos(atan(-p.x + 2., -p.y / 2.) * 5.0 + 20.0 * -q.x + iTime * 2.);\n    float r2 = 0.4 + 0.1 * cos(atan(-p.x + 4., -q.y / 2.) * 10.0 + 20.0 * -q.x + iTime * 4.);\n    float r3 = 0.6 + 0.1 * cos(atan(-p.x + 6., -q.y / 2.) * 20.0 + 20.0 * -q.x + iTime * 6.);\n    \n    col /= smoothstep(r / 100., r, length(q)) / .2;\n\n    col.x /= smoothstep(r1 / 100., r1, length(q)) / .2;\n    col.y /= smoothstep(r2 / 100., r2, length(q)) / .2;\n    col.z /= smoothstep(r3 / 100., r3, length(q)) / .2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tByWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 934]], "test": "untested"}
{"id": "NlScRy", "name": "Revised Reality", "author": "dean_the_coder", "description": "4Kb Executable Graphics compo presented at Revision 2022.\n\n(Written for appearance and compression, not performance.)", "tags": ["3d", "raymarching", "4k", "demoscene", "4kb", "cineshader"], "likes": 30, "viewed": 4446, "published": 3, "date": "1650211304", "time_retrieved": "2024-07-30T16:53:13.119278", "image_code": "// 'Revised Reality' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NlScRy\n// https://demozoo.org/graphics/307496/\n// https://www.pouet.net/prod.php?which=91388\n//\n// Entered into the Revision 2022 4Kb Executable Graphics compo.\n// (First ever compo entry!)\n//\n// Processed using GLSL Shader Shrinker, and compressed into an exe\n// with Crinkler.\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n#define LIGHT_RGB\tvec3(1.2, 1., 1.)\n#define SPOT_RGB\tvec3(1.56, 1.1, 1.)\n#define SKY_RGB\tvec3(.45, .4, .35) * .05\n#define ISLE_RGB\tvec3(1, 1.4, 0)\n#define R\tiResolution\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b)\t{ float h_ = a; if (h_ < h.x) h = vec2(h_, b); }\n#define MN(a)\td = min(d, a)\n#define Z0\tmin(1., 0.)\n\nvec3 g;\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nbool intPlane(vec3 ro, vec3 rd, out float t) {\n\tfloat z = -rd.z;\n\tt = (ro.z - 6.) / z;\n\treturn t >= 0. && abs(z) > 1e-4;\n}\n\nmat2 rot(float a) {\n\t// Thanks Fabrice.\n\treturn mat2(cos(a + vec4(0, 11, 33, 0)));\n}\n\nfloat opRep(float p, float c) {\n\tfloat c2 = c * .5;\n\treturn mod(p + c2, c) - c2;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nvec3 rayDir(vec2 uv) {\n\tvec3 f = vec3(.034, .15325, 0.9876),\n\t     r = vec3(0.9994, 0, -0.0344);\n\treturn normalize(f * 1.1 + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat pie(vec3 q, float t, float r, float a){\n    vec2 p = q.xy,\n         c = vec2(sin(t), cos(t));\n    p *= rot(a * -6.28);\n    p.x = abs(p.x);\n    float l = length(p),\n          m = length(p-c*clamp(dot(p,c),0.0,r)),\n          d = max(l - r,m*sign(c.y*p.x-c.x*p.y));\n    return max(d, r - l - 0.2);\n}\n\nfloat logo(vec3 p) {\n\tp.y += .05;\n\tp.z += .2;\n\tp.xz *= rot(0.2);\n\tp.yz *= mat2(cos(.8 + vec4(0, 11, 33, 0)));\n\n\t// Inner circle.\n\tfloat l = length(p.xy),\n\t      d = abs(l - .3) - .1;\n\tMN(pie(p, .4, .55, .625));\n\n\t// Middle circle.\n\tMN(abs(l - .8) - .05);\n\tMN(pie(p, 1., .85, .05));\n\tMN(pie(p, 1., .85, .4));\n\tMN(pie(p, .6, .85, .8));\n\tMN(pie(p, .3, .72, .4));\n\n\t// Outer circle.\n\tMN(abs(l - 1.2) - .052);\n\tMN(pie(p, .6, 1.25, .7));\n\tMN(pie(p, .07, 1.3, .63));\n\tMN(pie(p, .2, 1.25, .5));\n\n\t// Crop depth.\n\treturn smin(d - 0.01, abs(p.z) - .08, -.04) - .002 * n31(p * 40.);\n}\n\nfloat rip(vec2 p) { return 0.07 * pow(S(0.4, 0.05, length(p * vec2(1, 1.4))), 3.0); }\n\nfloat exit(vec3 p) {\n\tp.x += 0.2;\n\tvec3 q = p;\n\n\t// E\n\tfloat f = box(q, vec3(0.06, 0.14, 0.1));\n\tq.x -= 0.03;\n\tq.y = abs(q.y) - 0.05;\n\tf = max(f, -box(q, vec3(0.06, 0.04, 1.)));\n\n\t// X\n\tq = p;\n\tq.x -= .16;\n\tq.xy = abs(q.xy);\n\tq.xy *= rot(-0.4);\n\tf = min(f, box(q, vec3(0.02, 0.15, 0.1)));\n\n\t// I\n\tq = p;\n\tq.x -= .15 * 2.;\n\tf = min(f, box(q, vec3(0.02, 0.15, 0.1)));\n\n\t// T\n\tq.x -= .14;\n\tf = min(f, box(q, vec3(0.02, 0.15, 0.1)));\n\tq.y -= 0.13;\n\tf = min(f, box(q, vec3(0.06, 0.04, 0.1)));\n\treturn max(f, abs(p.y) - 0.12);\n}\n\nfloat bolt(vec3 p, vec3 b, float m) {\n\tp.x -= m;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);\n\treturn length(p - b * h) - 0.009;\n}\n\nvec2 map(vec3 p) {\n\t// Screen.\n\tfloat d,\n\t      f = sin(length(p.xy * rot(-0.2) * vec2(15, 55)));\n\tf *= S(2., .5, abs(p.x)) * S(.7, .3, abs(p.y - .1));\n\tf *= .3 + .7 * S(0., .5, p.y);\n\tf *= .0024;\n\tf += rip(p.xy - vec2(-1.15, 0.3));\n\tf += rip(p.xy - vec2(-.72, 0.21));\n\tf += rip(p.xy - vec2(.75, -0.1));\n\tf += rip(p.xy - vec2(1.2, -0.15));\n\tvec2 h = vec2(box(p, vec3(1.8, .9, .1 + f)), 1);\n\n\t// Screen frame.\n\tminH(max(box(p, vec3(1.85, .95, .15)), -box(p, vec3(1.8, .9, 1))), 5);\n\n\t// Logo\n\td = logo(p);\n\tg.x += .0025 / (.11 + d * d * d * d);\n\tminH(smin(d, h.x, .03), 2);\n\n\t// Stage top.\n\tminH(box(p + vec3(0, 1.2, -1), vec3(3, .05, 1)), 5);\n\n\t// Stage bottom.\n\tminH(box(p + vec3(0, 2.2, -1), vec3(2.8, 1, .9)) - .02, 6);\n\n\t// Hall.\n\td = -box(p - vec3(0, 2.15, 0), vec3(12. + sin(p.z * 10.) * .01, 4. + .005 * n31(p * 50.), 19));\n\n\t// Steps.\n\tfloat ns = 0.0002 * n31(p * vec3(1, 300, 1)) + 0.008;\n\tfor (float i = .1; i < .7; i += .1)\n\t\tMN(box(p + vec3(0, 1.2 + i, i - 1.), vec3(.6, .05, 1)) - ns);\n\n\t// Screen stand.\n\tvec3 q = p;\n\tq.x = abs(abs(q.x) - 1.5) - .1;\n\tq.y++;\n\tq.z--;\n\tMN(box(q, vec3(.001, 1, .01)) - .03);\n\tminH(d, -1);\n\n\t// Stage speakers.\n\tq = p;\n\tq.x = abs(q.x);\n\tq -= vec3(2.5, -1.1, .5);\n\tq.xz *= mat2(cos(.5 + vec4(0, 11, 33, 0)));\n\tf = q.z;\n\tq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n\tf = max(box(q, vec3(.3, .2, .2)), -f - .15);\n\tf = smin(f, -box(q + vec3(0.39, -0.14, 0), vec3(.1, 0.02, .06)), -0.02);\n\tns = n31(p * 200.);\n\tminH(f - .01 - ns * 0.0005, 7);\n\n\t// Seats.\n\tif (p.z < 0.0) {\n\t\tq = p;\n\t\tq.x = abs(q.x) - 2.;\n\t\tq.x = abs(q.x) - .4;\n\t\tq.x = abs(q.x) - .4;\n\t\tq.x = abs(q.x) - .2;\n\t\tq.y += 1.8 - .3 * S(2.9, 8.8, trunc((p.z + .2) / -.6));\n\t\tq.z = opRep(q.z, .6);\n\t\tq.z += 0.04 * S(0.0, 0.2, p.y + 1.64);\n\t\tq.z += .12 * cos(q.x * 4.5) - 0.23125;\n\t\tf = box(q - vec3(.14, .2, .14), vec3(.05, .01, .12));\n\t\tf = min(box(q, vec3(.16 - .08 * S(0.28, 0.65, q.y), .45, .005)), f);\n\t\tf += .0006 * ns;\n\t\tf = max(p.z + 1., min(f, box(q - vec3(.14, .05, .14), vec3(.01, .14, .12))) - .02);\n\t\tminH(f * 0.9, 3);\n\n\t\t// Cup holders.\n\t\tq = p;\n\t\tq.x = abs(q.x) - 0.85;\n\t\tq.y += 1.58 - 0.33 * S(2.9, 8.8, trunc(p.z / -.6));\n\t\tq.z = opRep(q.z + 0.3, .6);\n\t\tf = abs(length(q.xz) - 0.05) - 0.002;\n\t\tf = smin(f, (abs(q.y) - 0.02), -0.006);\n\t\tminH(max(p.z + 1., f), 7);\n\t}\n\n\t// Lights.\n\tq = p;\n\tq.x = abs(abs(q.x) - 5.) - 2.5;\n\tq.y -= 6.2;\n\tq.z = opRep(q.z + 2., 8.);\n\tf = length(q - vec3(0, .2, 0)) - .3;\n\tg.x += .002 / (.001 + f * f);\n\tminH(f, 4);\n\n\t// Dolby speakers.\n\tq = p;\n\tq.z = opRep(p.z, 3.2);\n\tq.x = abs(q.x);\n\tq -= vec3(11.9, 4, 1);\n\tf = cos(q.y) * 0.2 + q.y * 0.1;\n\tf += sin(q.y * 50.) * 0.006;\n\tf = box(q, vec3(f * step(q.x, 0.0), .6, .5)) - 0.1;\n\tminH(f, 8);\n\n\t// Isle lights.\n\tq = p;\n\tq.x = abs(q.x);\n\tq += vec3(-0.71, 1.95, 1.85);\n\tq.z = abs(q.z) - .5;\n\tq.z = abs(q.z) - .25;\n\tf = box(q, vec3(0.005, .1, 0.03));\n\tg.y += .000004 / (.0001 + f * f);\n\tminH(f, 9);\n\tif (p.z > 10.0) {\n\t\t// EXITs.\n\t\tq = p;\n\t\tq.y += 0.8;\n\t\tq.z -= 18.8;\n\t\tf = exit(q - vec3(10.4 * sign(p.x), 1.3, 0)); // EXIT words.\n\t\tg.z += .00004 / (.00001 + f * f);\n\t\tminH(f, 9);\n\t\tq.x = abs(q.x) - 10.4;\n\t\tf = box(q, vec3(0.9, 0.95, .1)); // Frame\n\t\tf = min(f, box(q - vec3(0, 1.3, 0), vec3(.4, .15, .05))); // EXIT box.\n\t\tq.yz += 0.1;\n\t\tminH(max(f - 0.02, -box(q, vec3(0.8, 1, 0.2))), 8); // Cut-out.\n\t\tq.x = abs(q.x) - 0.4;\n\t\tq.z -= 0.12;\n\t\tminH(box(q, vec3(0.39, 1, 0.01)), 10); // Doors.\n\t\tq.z += 0.05;\n\t\tf = box(q, vec3(0.32, .01, 0.0));\n\t\tf = min(f, box(q - vec3(0.32, 0.04, 0.05), vec3(0.01, .04, 0.0)));\n\t\tminH(f - 0.03, 7); // Push-bar.\n\t}\n\telse {\n\t\t// Lightning.\n\t\tf = fbm(p * 8.) * .2;\n\t\td = bolt(p + vec3(.71, .75, 1.85), vec3(-1, -2, 1), f);\n\t\tMN(bolt(p + vec3(-.8, .7, .8), vec3(0, -1.2, -0.1), f));\n\t\tminH(d, 11);\n\t\tg.x += (1. + 3. * S(0.07, .0, abs(p.y + 1.0))) * .00005 / (.001 + d * d);\n\t}\n\n\treturn h;\n}\n\nvec3 N(vec3 p) {\n\tfloat h = dot(p, p) * .01;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).x;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .05,\n\t      mxt = length(p - vec3(1, 1, -3.6));\n\tvec3 ld = normalize(vec3(1, 1, -3.6) - p);\n\tfor (float i = Z0; i < 50.; i++) {\n\t\td = map(t * ld + p).x;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.02, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p).x / h); }\n\nfloat fog(float d) { return exp(d * -.0035) + 0.1; }\n\nvec3 plasma(vec2 p) {\n\tvec2 c = p + .5 * sin(34. / vec2(3, 5));\n\treturn vec3(sin((sin(p.x * 4.) + sin(sqrt(50. * dot(c, c) + 35.))) * 3.141 - vec2(0, 11)) * .4 + .5, .7);\n}\n\nvec3 flr(vec3 c, vec3 p, inout vec3 n) {\n\tif (p.y > -1.84) return c;\n\tc = vec3(.01, .02, .1) + S(.2, .5, fbm(p * 10.)) * vec3(.1, .2, .1);\n\tp.x = abs(p.x);\n\tif (p.x > 0.715 && p.z < -.82) c = vec3(.01);\n\telse if (p.x > 0.7 && p.z < -.8) {\n\t\tc = vec3(.5);\n\t\tn = mix(n, vec3(0, 1, 0), 0.8);\n\t}\n\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, vec2 h) {\n\tfloat f;\n\tvec2 spe = vec2(10, 1);\n\tvec3 q,\n\t     ld = normalize(vec3(1, 1, -3.6) - p),\n\t     c = vec3(.45, .4, .35) * (.05 + .95 * step(p.y, 6.13)); // Darken ceiling.\n\t// Ceiling grid.\n\tif (min2(fract((p.xz + vec2(0, .5)) * 1.)) < 0.05) c += 0.01;\n\n\t// Colorize walls.\n\tc *= mix(vec3(1, .13, .13), vec3(1), step(abs(p.x), 11.95) * step(p.z, 18.9));\n\n\t// Floor pattern.\n\tc = flr(c, p, n);\n\tif (h.y == 3.) {\n\t\t// Chairs.\n\t\tc = vec3(.6, .07, .01);\n\t\tq = p;\n\t\tq.z += 1.5;\n\t\tq.x = abs(abs(q.x) - 2.) - .8;\n\t\tc += vec3(.48, 0, 0) * SPOT_RGB * S(.6, .5, length(q.xz));\n\t\tspe *= 0.5;\n\t}\n\telse if (h.y > 0.) {\n\t\tif (h.y == 1.) spe = vec2(200, 1);\n\n\t\t// plasma/white logo\n\t\tf = h.y - 1.;\n\t\tif (h.y == 2.) f -= S(-.5 + .3 * n31(p * 10.), -.1, p.z);\n\t\tc = mix(plasma(p.xy), vec3(.85), f);\n\n\t\t// Stage upper.\n\t\tif (h.y == 5.) {\n\t\t\tc *= .005;\n\t\t\tif (n.y >= .99) c += n31(p * 4.6);\n\t\t}\n\n\t\t// Stage lower.\n\t\tif (h.y == 6.) c = vec3(.234, .24, .12) * S(0., .1, fract(p.y * 12.));\n\n\t\t// Stage speakers.\n\t\tif (h.y == 7.) {\n\t\t\tc = vec3(.1);\n\t\t\tspe = vec2(1, 10);\n\t\t}\n\n\t\t// Dolby speakers.\n\t\tif (h.y == 8.) {\n\t\t\tc = vec3(.1 - n31(p * 20.) * 0.03);\n\t\t\tspe = vec2(20, 1);\n\t\t}\n\n\t\tif (h.y == 9.) c = ISLE_RGB;\n\t\tif (h.y == 10.) c = vec3(.3, 0.3, 0.4);\n\t\tif (h.y == 11.) return vec3(.9, .9, 1.);\n\t}\n\n\telse c += S(3., 1.5, length(p)) * S(.2, -.4, p.z) * plasma(p.xz * .4); // Plasma glow onto stage.\n\t// Ceiling light cones.\n\tfloat t;\n\tintPlane(ro, rd, t);\n\tif (t < length(p - ro)) {\n\t\tvec2 q = (ro + rd * t).xy;\n\t\tq.x = abs(abs(q.x) - 5.) - 2.5;\n\t\tq.y -= 6.;\n\t\tf = (S(1., 0., abs(q.x * 1.5) + q.y * .15) + S(1., 0., abs(q.x * 3.))) * S(-3.8, 4., q.y) * S(0.2, 0., q.y);\n\n\t\t// Dust.\n\t\tq *= 3.;\n\t\tvec2 u = floor(q);\n\t\tq = fract(q) - 0.5;\n\t\tq += n31(u.xyy) * 0.4;\n\t\tf += S(0.05 * n31(floor(p * 10.)), 0.0, length(q)) * f;\n\t\tc += SPOT_RGB * f;\n\t}\n    \n    // Darken near camera.\n\tc *= S(-5., -1., p.z);\n\tc *= 0.3 + 0.7 * S(22.1, 19.0, length(p));\n    \n    float _ao = mix(aof(p, n, .2), aof(p, n, 2.), .7);\n    float\n          l1 = sat(.1 + .9 * dot(ld, n)) * (.2 + .8 * shadow(p)),\n          l2 = sat(.1 + .9 * dot(ld * vec3(-1, 1, -1), n)) * .3,\n          l = l1 + (l2 + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y);\n    l *= (1. - S(.7, 1., 1. + dot(rd, n)) * .4);\n\treturn l * _ao * c * LIGHT_RGB;\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(-.2, -.9, -5.8), ro = p;\n\tg = vec3(0);\n\tvec2 h;\n\tfor (float i = Z0; i < 135.; i++) {\n\t\th = map(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\tp += h.x * rd;\n\t}\n\n\tvec3 gg = g.x * SPOT_RGB + g.y * ISLE_RGB + g.z * vec3(.1, 1, .1);\n\treturn mix(SKY_RGB, gg + lights(p, ro, rd, N(p), h), fog(dot(p, p)));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 uv) {\n\tvec2 v = uv.xy / R.xy;\n\tuv = (uv - .5 * R.xy) / R.y;\n\tvec3 c = scene(rayDir(uv));\n\tif (fwidth(c.r) > 0.05) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tc += scene(rayDir(uv + vec2(dx - 0.5, 0) / R.xy));\n\t\tc /= 3.;\n\t}\n\n\tc *= pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(sat(c), vec3(.6)), 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlScRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[942, 942, 961, 961, 1302], [1304, 1304, 1323, 1323, 1455], [1457, 1457, 1496, 1496, 1578], [1580, 1580, 1600, 1600, 1624], [1626, 1626, 1646, 1646, 1680], [1682, 1682, 1728, 1728, 1804], [1806, 1806, 1825, 1845, 1890], [1892, 1892, 1923, 1923, 1974], [1976, 1976, 2003, 2003, 2074], [2076, 2076, 2098, 2098, 2234], [2236, 2236, 2281, 2281, 2538], [2540, 2540, 2560, 2560, 3113], [3115, 3115, 3134, 3134, 3200], [3202, 3202, 3222, 3222, 3724], [3726, 3726, 3763, 3763, 3862], [3864, 3864, 3882, 3894, 7669], [7671, 7671, 7687, 7687, 7915], [7917, 7917, 7939, 7939, 8236], [8238, 8238, 8274, 8274, 8310], [8312, 8312, 8332, 8332, 8364], [8366, 8366, 8387, 8387, 8538], [8540, 8540, 8580, 8580, 8845], [8847, 8847, 8902, 8902, 11182], [11184, 11184, 11205, 11205, 11512], [11514, 11514, 11559, 11559, 11881]], "test": "untested"}
{"id": "NtjcDG", "name": "SDF collision", "author": "jcyuan", "description": "SDF collision", "tags": ["collision", "sdf"], "likes": 20, "viewed": 469, "published": 3, "date": "1650210675", "time_retrieved": "2024-07-30T16:53:13.942077", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float w = length(fwidth(uv));\n    \n    float d = map(uv);\n    float c = smoothstep(-w, w, abs(d));\n\n    vec3 col = vec3(c);\n    \n    vec4 buf = texture(iChannel0, uv);\n    vec2 bp = buf.xy;\n    \n    float ball = length(uv - bp) - BALL_R;\n    ball = smoothstep(-w, w, abs(ball));\n    \n    col *= ball;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float ia = BALL_INIT_ANGLE * 3.1415926536 / 180.;\nconst vec2 ip = BALL_INIT_POS;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 d = texture(iChannel0, uv);\n    \n    if (d.z == 0.) {\n        d.zw = vec2(cos(ia), sin(ia)) * .5 + .5;\n        d.xy = ip;\n    } else {\n        vec2 v = d.zw * 2. - 1.;\n        vec2 p = d.xy;\n        p += v * iTimeDelta * MOVE_SPEED;\n        \n        float dist = map(p);\n        if (dist > -BALL_R) {\n            p -= (dist + BALL_R) * v;\n            \n            vec2 n = nrm(p);\n            vec2 o = reflect(v, n);\n            \n            d.zw = o * .5 + .5;\n        }\n        \n        d.xy = p;\n    }\n    \n    fragColor = d;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Header: Enable access to inputs from Common tab (Author: https://www.shadertoy.com/view/ttf3R4)\n#if __LINE__ < 17\n    #define _ST_TAB_COMMON\n#endif\n#ifdef _ST_TAB_COMMON\n    uniform float iTime;\n#endif\n// End header\n\n// ------------------------------------------------------------\n// all SDF functions are from IQ's site\n\n#define BALL_R .05\n#define BALL_INIT_POS vec2(0., .3)\n#define BALL_INIT_ANGLE 75.\n\n#define MOVE_SPEED 2.2\n\nfloat box(vec2 p, vec2 s) {\n    vec2 bd = abs(p) - s;\n    return length(max(bd, 0.)) + min(max(bd.x, bd.y), 0.);\n}\n\nfloat star(vec2 p, float r, float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1,p),0.0) * k1;\n    p -= 2.0 * max(dot(k2,p),0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0, 1);\n    float h = clamp( dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\nfloat moon(vec2 p, float d, float ra, float rb) {\n    p.y = abs(p.y);\n    float a = (ra * ra - rb * rb + d * d) / (2. * d);\n    float b = sqrt(max(ra * ra - a * a, 0.));\n    if (d * (p.x * b - p.y * a) > d * d * max(b - p.y, 0.))\n        return length(p - vec2(a, b));\n    return max((length(p) - ra), -(length(p - vec2(d, 0)) - rb));\n}\n\nfloat map(vec2 p) {\n    float d = 0.;\n    \n    vec4 r = vec4(.0, .5, .2, .3);\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x  = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p) - vec2(1.6, .9) + r.x;\n    d = min(max(q.x, q.y), 0.) + length(max(q, 0.)) - r.x;\n    \n    float c = length(p) - .2;\n    \n    float cs = cos(iTime), ss = sin(iTime);\n    mat2 rot1 = mat2(cs, -ss, ss, cs);\n    mat2 rot2 = mat2(cs, ss, -ss, cs);\n    \n    vec2 cp = abs(rot1 * (p - vec2(-.85, .45)));\n    c = min(c, length(cp - min(cp.x + cp.y, .25) * .5) - .025);\n    \n    c = min(c, box(rot1 * (p - vec2(-.85, -.45)), vec2(.1, .2)));\n    \n    c = min(c, star(rot2 * (p - vec2(.85, .45)), .18, .38));\n    \n    c = min(c, moon(rot2 * (p - vec2(.85, -.45)), .05, .18, .14));\n    \n    d = max(-c, d);\n    \n    return d;\n}\n\nvec2 nrm(vec2 p) {\n    const vec2 eps = vec2(.5773, -.5773);\n    vec2 n = eps.xx * map(p + .001 * eps.xx);\n    n += eps.yy * map(p + .001 * eps.yy);\n    n += eps.yx * map(p + .001 * eps.yx);\n    n += eps.xy * map(p + .001 * eps.xy);\n    return normalize(n);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjcDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 468]], "test": "untested"}
{"id": "Nt2yWy", "name": "Plane + Buffer test", "author": "SnoopethDuckDuck", "description": "just chucked an old 2d shader onto a plane, not sure how to remove the bugs - maybe buffer A isnt continuous enough\n\n(accidentally made this private)", "tags": ["e"], "likes": 6, "viewed": 215, "published": 3, "date": "1650209325", "time_retrieved": "2024-07-30T16:53:15.067069", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = 0.2 * iTime;\n    float r = 3.4;\n    vec3 ro = vec3(r * cos(t), 1.8, r * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float d = p.y;\n    float h = 0.08;\n    float c = length(texture(iChannel0, 0.5 + 0.5 * p.xz).rgb);\n    float x = 1.;//0.5 + 0.5 * ths(10., pi * 3.5 + 0.25 * iTime);\n    d -= x * thc(4., 1. * (p.x - p.z) + iTime) * h * c;\n    d += x * h * thc(4., p.x - p.z + iTime);\n    return 0.1 * d; // seems buggy whatever value i put here\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 5.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        vec3 c = texture(iChannel0, 0.5 + 0.5 * p.xz).rgb;\n        col = c;\n        //col *= 0.8 + 0.2 * step(cos(200. * p.x + p.z * 200.), 0.);\n        //col *= clamp(exp(2.-4. * mlength(p.xz)), 0., 1.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.15 * iTime;\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xy;\n    vec2 ouv = uv;\n    uv.y += 0.12 * time;\n    //time += uv.x * 4.;\n    float sc = 10.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float h = h21(ipos);\n    float h2 = 2. * pi * h21(ipos + 2.);\n    \n    vec2 p = fract(fpos - 4. * thc(2., vec2(h2, 2. * pi * h) + time)) - 0.5;\n        \n    float d = length(p);\n    float k = 1. + h;\n    float s = smoothstep(-k, k, -d + 0.2);\n    \n    vec2 pw = vec2(5. + 4. * thc(20., 8. * d + h2 + time));\n    vec2 b = pow(1. - 4. * fpos * fpos, pw);\n    \n    vec3 e = vec3(1.5);\n    // 50% chance of having white in it, .5+.5*cos gives white to some of it\n    float cp = step(0.5 + 0.5 * step(h, 0.5) * cos(8. * d), 0.5);\n    vec3 col = pal(h2 + 0.25 * d, e, e, e, cp * vec3(0.,0.33,0.66));\n    col *= b.x * b.y * s; // * step(h21(ipos + 1.), 0.5); \n    col += 0.03;\n    \n    col *= smoothstep(-0.01, 0.01, -mlength(ouv) + 0.2);\n    //col *= step(mlength(uv), 10.);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2yWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 784], [786, 786, 809, 809, 1142], [1144, 1144, 1187, 1187, 1494], [1496, 1496, 1520, 1520, 1710], [1712, 1712, 1762, 1762, 1953], [1955, 1955, 2012, 2012, 2982]], "test": "untested"}
{"id": "sl2yRt", "name": "TP4 - Source thermale montagne", "author": "Nordine", "description": "TP 3 + 4 + 5\nTexturing & Animation & Terrain", "tags": ["sun", "moon", "texturing", "snow", "mount", "sunsetthermalsource"], "likes": 1, "viewed": 196, "published": 3, "date": "1650207466", "time_retrieved": "2024-07-30T16:53:15.891864", "image_code": "// Texturing\n// Eric Galin\n\nconst int Steps = 600;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\nconst float k = 8.0;\n\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\nvec3 c;\nfloat s;\n};\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r,int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Terrain -----------------------------------------------------------------------------------------------\n\nfloat Terrasement(vec2 p, vec2 c, float h,float ri, float re)\n\n{\n    float d = length(p-c);\n    float m;\n    if(d<ri)\n    {\n        m=0.0;\n    }\n    else if(d>re)\n    {\n        m=1.0;\n    }\n    else\n    {\n        m = smoothstep(ri,re,d);\n    }\n    return mix(5.0f,h,m);\n}\n\nfloat plateau(float h, float e, float a)\n{\n    if(h<a)\n    {\n        return h;\n    }\n    if(h>e+a)\n    {\n        return h;\n    }\n    else\n    {\n        float u= (h-e)/((e+a)-e);\n        h = e+a*u;\n        return h;\n    }\n\n}\n\nfloat Ridge(float n)\n{\n    return 1.0-2.0*abs(n);\n\n}\n\nfloat fbm(vec2 p, float l, int o, float a)\n{\n    float t=0.0;\n    for(int i=0;i<o;i=i+1)\n    {\n        t += a * Noise(p/l);\n        a*=0.5;\n        l*=0.5;\n    }\n    return 50.0+Ridge(t);\n\n    \n}\n\n\n\nfloat hetefdmbridge(vec2 p , float l, float a, int r, float amin, float amax)\n{\n    float t = a * Ridge(10.0);\n    for(int i = 1; i<10; i = i+1)\n    {\n        a*= 0.5;\n        l*=0.5;\n        float att = smoothstep(amin,amax,t);\n        t+= att*a*Ridge(10.0);\n    }\n    return t;\n}\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain( in vec2 p )\n{\n    float h = fbm(p,100.0,4,150.0);\n    return Terrasement(p.xy,vec2(0.0,0.0), h,100.0,260.0);\n\n} \n\n\nV Difference(V a,V b)\n{\n    if (a.v>-b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(-b.v,b.i);\n    }\n}\n\n\n// Implicit surface defining the terrain\n// p : Point\n\nV ImplicitTerrain(in vec3 p)\n{\n    float z = Terrain( p.xy );\n    float h = p.z - z; \n    V ret;\n    ret.v = h;\n    if(z>-90.0)\n    {\n        ret.i = 2;\n    }\n    else\n    {\n        ret.i = 1;\n    }\n    return ret;\n}\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n  V u;\n  u = Union(\n      Union(\n      Difference(\n      ImplicitTerrain(p),\n      Sphere(p,vec3(0.0,0.0,0.0),90.0,0)),\n      Sphere(p,vec3(0.0,1000.0,(cos(iTime)*400.0-250.0)),65.0,3)),\n      Sphere(p,vec3(0.0,-1000.0,(-cos(iTime)*400.0-250.0)),65.0,4));\n\n  return u;\n}\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v/k);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  if(cos(iTime)<-0.5)\n  {\n       d.z *= cos(iTime)*-2.0-1.0;\n      return mix(vec3(0.22,d.z*100.0*0.3,0.4),vec3(0.0,0.0,d.z*0.4), d.z*0.5+0.5);\n  } \n  d.z = cos(iTime)*(d.z*-4.0 +1.3);\n  return vec3(d.z*1.0,d.z*0.607,d.z*0.4);\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(0.0, 0.0, 3000.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,1.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nT Texture0(in vec3 p)\n{\n  return T( mix(vec3(0.52,0.75,0.91),vec3(0.0,1.0,1.0),Fbm(p/50.0)),0.0);\n  \n}\n\nT Texture1(in vec3 p)\n{\n   return T( mix(vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),Fbm(p/50.0)),0.0);\n}\n\nT Texture2(in vec3 p)\n{\n  return T(vec3(1.0,1.0,1.0),0.0);\n}\n\nT Texture3(in vec3 p)\n{\n    vec3 f = vec3(1.0,1.0,0.094);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = f + (Noise(p)*c/2.0);\n    return T(d,0.0);       \n}\n\nT Texture4(in vec3 p)\n{\n    vec3 f = mix(vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),Fbm(p/50.0));\n    vec3 c = vec3(0.5,0.5,0.5);\n    vec3 d = f + (Noise(p)*c/2.0);\n    return T(d,0.0);            \n}\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    if (vp.i==0){\n        \n        return Texture0(p);\n    }\n    else if (vp.i==1)\n    {\n        return Texture1(p);\n    }\n    else if (vp.i==2)\n    {\n        return Texture2(p);\n    }\n    else if (vp.i==3)\n    {\n        return Texture3(p);\n    }\n    else if (vp.i==4)\n    {\n        return Texture4(p);\n    }\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,0.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(500.0, 500.0, 500.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    T tex=Color(p,n);\n\n    // Ambient color\n    vec3 ambient = 0.5*tex.c;\n        \n    // Shadow computation\n    float s = Shadow(p+0.01*n,n,l);\n\n// Phong diffuse\n    vec3 diffuse = 0.5  * clamp(dot(n, l),0.0,1.0) * tex.c;\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.s * pow(clamp(dot(r,l),0.0,1.0),28.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + s * (diffuse + specular);\n    return c;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 2000.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "// Texturing and noise \n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\n\nfloat Fbm(in vec3 p)\n{\n    return Noise(p)/2.0+Noise(p*2.0)/4.0+Noise(p*4.0)/8.0+Noise(p*8.0)/16.0;\n}\n\n\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(1000.0,0.0,200.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2yRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 498, 542, 542, 577], [580, 580, 598, 598, 693], [695, 800, 825, 825, 932], [1042, 1042, 1106, 1106, 1313], [1315, 1315, 1357, 1357, 1538], [1540, 1540, 1562, 1562, 1592], [1594, 1594, 1638, 1638, 1789], [1793, 1793, 1872, 1872, 2074], [2076, 2128, 2156, 2156, 2254], [2258, 2258, 2281, 2281, 2390], [2448, 2448, 2478, 2478, 2664], [2666, 2712, 2730, 2730, 3001], [3110, 3150, 3181, 3181, 3424], [3426, 3556, 3621, 3621, 4030], [4032, 4073, 4098, 4098, 4327], [4330, 4349, 4377, 4395, 4656], [4760, 4760, 4783, 4783, 4862], [4864, 4864, 4887, 4887, 4961], [4963, 4963, 4986, 4986, 5023], [5025, 5025, 5048, 5048, 5179], [5181, 5181, 5204, 5204, 5373], [5375, 5422, 5452, 5452, 5784], [5786, 5849, 5885, 5885, 6008], [6010, 6091, 6127, 6147, 6685], [7003, 7098, 7137, 7162, 7586], [7589, 7598, 7645, 7674, 8376]], "test": "untested"}
{"id": "slByDG", "name": "9_10_norm", "author": "tomoe", "description": "sample code\nε-neighborhood in L^p-norm distance", "tags": ["ch9"], "likes": 0, "viewed": 231, "published": 3, "date": "1650199109", "time_retrieved": "2024-07-30T16:53:16.791459", "image_code": "//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\nfloat kyoto(vec3 p){\n    float scale = 1.0;\n    return scale * (abs(p.x) + abs(p.y) + abs(p.z));\n}\nfloat shogi(vec3 p){\n    float scale =1.;\n    return scale * max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\nfloat euc(vec3 p){\n    float scale = 1.0;\n    return scale * length(p);\n}\nfloat length_(vec3 p){\n    float time = iTime * 0.2;\n    float v0, v1;\n    if (int(time) % 3 == 0){\n        v0 = euc(p);\n        v1 = shogi(p);\n    } else if (int(time) % 3 == 1){\n        v0 = shogi(p);\n        v1 = kyoto(p);\n    } else {\n        v0 = kyoto(p);\n        v1 = euc(p);\n    }\n    return mix(v0, v1, smoothstep(0.25, 0.75, fract(time)));\n}\nfloat length2(vec3 p){\n    p = abs(p);\n    float d = 4.0 * sin(0.5 * iTime) + 5.0;\n    return pow(pow(p.x, d) + pow(p.y, d) + pow(p.z, d), 1.0 / d);\n}\nfloat sphereSDF(vec3 p){\n    return length2(p) - 0.5;\n}\nfloat sceneSDF(vec3 p){\n    return sphereSDF(p);\n}\n\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 t = vec3(iTime * 0.3);\n    vec3 cPos = euler(vec3(0.0, 0.0, 2.0), t);\n    vec3 cDir = euler(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = euler(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    \n    float targetDepth = 1.0;\n    \n    vec3 lDir = euler(vec3(0.0, 0.0, 1.0), t);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = ray / length2(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slByDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 12, 39, 39, 115], [116, 116, 143, 143, 182], [183, 183, 210, 210, 253], [254, 254, 281, 281, 320], [321, 321, 348, 348, 397], [398, 408, 428, 428, 506], [507, 507, 527, 527, 609], [610, 610, 628, 628, 683], [684, 684, 706, 706, 1035], [1036, 1036, 1058, 1058, 1186], [1187, 1187, 1211, 1211, 1242], [1243, 1243, 1266, 1266, 1293], [1295, 1295, 1316, 1316, 1598], [1599, 1599, 1653, 1653, 2586]], "test": "untested"}
{"id": "7tByDG", "name": "9_9_dist", "author": "tomoe", "description": "sample code\nε-neighborhood in Manhattan/Euclid/Chessboard distance", "tags": ["ch9"], "likes": 1, "viewed": 227, "published": 3, "date": "1650199091", "time_retrieved": "2024-07-30T16:53:17.671107", "image_code": "//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\nfloat kyoto(vec3 p){\n    return abs(p.x) + abs(p.y) + abs(p.z);\n}\nfloat shogi(vec3 p){\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\nfloat euc(vec3 p){\n    return length(p);\n}\nfloat length2(vec3 p){\n    float t = iTime * 0.2;\n    float[3] v;\n    v[0] = euc(p);\n    v[1] = shogi(p);\n    v[2] = kyoto(p);\n    return mix(v[int(t) % 3], v[(int(t) + 1) % 3], smoothstep(0.25, 0.75, fract(t)));\n}\nfloat sphereSDF(vec3 p){\n    return length2(p) - 0.5;\n}\nfloat sceneSDF(vec3 p){\n    return sphereSDF(p);\n}\n\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 t = vec3(iTime * 0.3);\n    vec3 cPos = euler(vec3(0.0, 0.0, 2.0), t);\n    vec3 cDir = euler(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = euler(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    \n    float targetDepth = 1.0;\n    \n    vec3 lDir = euler(vec3(0.0, 0.0, 1.0), t);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = ray / length2(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tByDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 12, 39, 39, 115], [116, 116, 143, 143, 182], [183, 183, 210, 210, 253], [254, 254, 281, 281, 320], [321, 321, 348, 348, 397], [398, 408, 428, 428, 473], [474, 474, 494, 494, 547], [548, 548, 566, 566, 590], [806, 806, 830, 830, 861], [862, 862, 885, 885, 912], [914, 914, 935, 935, 1217], [1218, 1218, 1272, 1272, 2205]], "test": "untested"}
{"id": "stByDG", "name": "9_8_truncation", "author": "tomoe", "description": "sample code\nsize-variable octahedron ∩ cube", "tags": ["ch9"], "likes": 1, "viewed": 200, "published": 3, "date": "1650199072", "time_retrieved": "2024-07-30T16:53:18.408137", "image_code": "//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\nfloat sphereSDF(vec3 p, vec3 c, float r){\n    return length(p - c) - r;\n}\nfloat planeSDF(vec3 p, vec3 n, float s){\n    return dot(normalize(n), p) - s;\n}\nfloat octaSDF(vec3 p, float s){\n    return planeSDF(abs(p), vec3(1.0), s);\n}\nfloat boxSDF(vec3 p, vec3 c, vec3 d, float s){\n    p = abs(p - c);\n    return length(max(p - d, vec3(0.0))) + min(max(max(p.x - d.x, p.y - d.y), p.z - d.z), 0.0) - s;\n}\nfloat sceneSDF(vec3 p){\n    vec3 v = vec3(0.5); \n    float s = mix(1.0 / 3.0, 1.0, 0.5 * sin(iTime) + 0.5);\n    // s = 1.0;    //cube\n    // s = (sqrt(2.0) + 1.0) / 3.0;    //truncated cube\n    // s = 2.0 / 3.0;  //cuboctahedron\n    // s = 0.5;    //truncated octahedron\n    // s = 1.0 / 3.0;  //octahedron\n    float d1 = octaSDF(p,  s * length(v));\n    float d2 = boxSDF(p, vec3(0.0), v, 0.0);\n    return max(d1, d2);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 t = vec3(iTime * 0.3);\n    vec3 cPos = euler(vec3(0.0, 0.0, 2.0), t);\n    vec3 cDir = euler(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = euler(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    \n    float targetDepth = 1.0;\n    \n    vec3 lDir = euler(vec3(0.0, 0.0, 1.0), t);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stByDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 12, 39, 39, 115], [116, 116, 143, 143, 182], [183, 183, 210, 210, 253], [254, 254, 281, 281, 320], [321, 321, 348, 348, 397], [398, 408, 449, 449, 481], [482, 482, 522, 522, 561], [562, 562, 593, 593, 638], [639, 639, 685, 685, 807], [808, 808, 831, 831, 1228], [1229, 1229, 1250, 1250, 1532], [1534, 1534, 1588, 1588, 2517]], "test": "untested"}
{"id": "7lSyDG", "name": "9_7_octahedron", "author": "tomoe", "description": "sample code", "tags": ["ch9"], "likes": 1, "viewed": 218, "published": 3, "date": "1650199051", "time_retrieved": "2024-07-30T16:53:19.146163", "image_code": "//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\nfloat smin(float d1, float d2, float r){\n    float c = clamp(0.5 + (d2 - d1) * (0.5 / r), 0.0, 1.0);\n    return mix(d2, d1, c) - r * c * (1.0 - c);\n}\nfloat sphereSDF(vec3 p, vec3 c, float r){\n    return length(p - c) - r;\n}\nfloat planeSDF(vec3 p, vec3 n, float s){\n    return dot(normalize(n), p) - s;\n}\nfloat octaSDF(vec3 p, float s){\n    return planeSDF(abs(p), vec3(1.0), s);\n}\nfloat sceneSDF(vec3 p){\n    float t = 0.3 + 0.2 * sin(iTime);\n    float d1 = octaSDF(p, 0.5);\n    float d2 = sphereSDF(abs(p), vec3(t), 0.1);\n    return smin(d1, d2, 0.1);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 t = vec3(iTime * 0.3);\n    vec3 cPos = euler(vec3(0.0, 0.0, 2.0), t);\n    vec3 cDir = euler(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = euler(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    \n    float targetDepth = 1.0;\n    \n    vec3 lDir = euler(vec3(0.0, 0.0, 1.0), t);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 12, 39, 39, 115], [116, 116, 143, 143, 182], [183, 183, 210, 210, 253], [254, 254, 281, 281, 320], [321, 321, 348, 348, 397], [398, 408, 448, 448, 557], [558, 558, 599, 599, 631], [632, 632, 672, 672, 711], [712, 712, 743, 743, 788], [789, 789, 812, 812, 962], [963, 963, 984, 984, 1266], [1268, 1268, 1322, 1322, 2251]], "test": "untested"}
{"id": "slSyDG", "name": "9_6_repeat", "author": "tomoe", "description": "sample code", "tags": ["ch9"], "likes": 3, "viewed": 292, "published": 3, "date": "1650199040", "time_retrieved": "2024-07-30T16:53:19.923086", "image_code": "//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\n\nfloat sphereSDF(vec3 p, vec3 c, float s){\n    return sqrt(dot(p - c, p - c)) - s;\n}\n\nfloat sceneSDF(vec3 p){\n    vec3 center = vec3(0.);\n    float scale = 0.1;\n    return sphereSDF(fract(p+0.5)-0.5, center, scale);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize (vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 t = vec3(iTime * 0.1);\n    vec3 cPos = euler(vec3(0.0, 0.0,.5), t);\n    vec3 cDir = euler(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = euler(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n\n    float targetDepth = 1.0;\n\n    vec3 lDir = vec3(1.0);\n\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = cPos;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 12, 39, 39, 115], [116, 116, 143, 143, 182], [183, 183, 210, 210, 253], [254, 254, 281, 281, 320], [321, 321, 348, 348, 397], [409, 409, 450, 450, 492], [494, 494, 517, 517, 625], [626, 626, 647, 647, 930], [932, 932, 986, 986, 1871]], "test": "untested"}
{"id": "slBcWG", "name": "9_4_solidTexturing", "author": "tomoe", "description": "sample code", "tags": ["ch9"], "likes": 3, "viewed": 195, "published": 3, "date": "1650198979", "time_retrieved": "2024-07-30T16:53:20.669596", "image_code": "//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n//begin pnoise\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat gtable3(vec3 lattice, vec3 p){\n    uvec3 n = floatBitsToUint(lattice);\n    uint ind = uhash33(n).x >> 28;\n    float u = ind < 8u ? p.x : p.y;\n    float v = ind < 4u ? p.y : ind == 12u || ind == 14u ? p.x : p.z;\n    return ((ind & 1u) == 0u? u: -u) + ((ind & 2u) == 0u? v : -v);\n}\nfloat pnoise31(vec3 p){\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for (int k = 0; k < 2; k++ ){\n        for (int j = 0; j < 2; j++ ){\n            for (int i = 0; i < 2; i++){\n                v[i+2*j+4*k] = gtable3(n + vec3(i, j, k), f - vec3(i, j, k)) * 0.70710678;\n            }\n            \n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for (int i = 0; i < 2; i++){\n        w[i] = mix(mix(v[4*i], v[4*i+1], f[0]), mix(v[4*i+2], v[4*i+3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n//end pnoise\nfloat sphereSDF(vec3 p){\n    return length(p) - 1.0;\n}\nfloat sceneSDF(vec3 p){\n    return sphereSDF(p);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float t = iTime * 0.3;\n    vec3 cPos = rotY(vec3(0.0, 0.0, 2.0), t);\n    vec3 cDir = rotY(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = rotY(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    vec3 lDir = rotY(vec3(1.0), t);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = normalize(ray);\n    bool hit = false;\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            float text = pnoise31(10.0 * rPos);\n            fragColor.rgb = (diff + amb) * vec3(text);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 12, 39, 39, 115], [116, 116, 143, 143, 182], [183, 183, 210, 210, 253], [254, 254, 281, 281, 320], [321, 321, 348, 348, 397], [538, 538, 559, 559, 658], [659, 659, 682, 682, 795], [796, 796, 819, 819, 920], [921, 921, 943, 943, 1026], [1027, 1027, 1048, 1048, 1134], [1135, 1135, 1156, 1156, 1242], [1243, 1243, 1263, 1263, 1345], [1346, 1346, 1366, 1366, 1448], [1449, 1475, 1511, 1511, 1811], [2184, 2184, 2220, 2220, 2469], [3045, 3058, 3082, 3082, 3112], [3113, 3113, 3136, 3136, 3163], [3164, 3164, 3185, 3185, 3467], [3469, 3469, 3523, 3523, 4461]], "test": "untested"}
{"id": "stBcWG", "name": "9_3_smoothMin", "author": "tomoe", "description": "sample code\nsmooth minimum with different radiuses", "tags": ["ch9"], "likes": 2, "viewed": 210, "published": 3, "date": "1650198966", "time_retrieved": "2024-07-30T16:53:21.484417", "image_code": "float sphereSDF(vec3 p, vec3 cent, float rad){\n    return distance(p, cent) - rad;\n}\nfloat smin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\nreturn mix(b, a, h) - k * h * (1.0 - h); \n}\nfloat sceneSDF(vec3 p){\n    float[3] smallS, bigS;\n    for(int i = 0; i < 3; i ++ ){\n        smallS[i] = sphereSDF(p, vec3(float(i - 1), sin(iTime), 0.0), 0.3);\n        bigS[i] = sphereSDF(p, vec3(float(i - 1), 0.0, 0.0), 0.4);\n    }\n    float cap = smin(smallS[0], bigS[0], 0.1);\n    float cup = smin(smallS[1], bigS[1], 0.3);\n    float minus = smin(smallS[2], bigS[2], 0.5);\n    return min(min(cap, cup), minus);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n\n    vec3 lDir = vec3(0.0, 0.0, 1.0);\n\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = cPos + ray;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 84], [85, 85, 123, 123, 223], [641, 641, 662, 662, 950], [951, 951, 1005, 1005, 1835]], "test": "untested"}
{"id": "7lScWG", "name": "9_2_morphing", "author": "tomoe", "description": "sample code\nlerp of SDFs", "tags": ["ch9"], "likes": 1, "viewed": 190, "published": 3, "date": "1650198939", "time_retrieved": "2024-07-30T16:53:22.355090", "image_code": "const float PI = 3.14159265359;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\nfloat sphereSDF(vec3 p, vec3 cent, float rad){\n    return length(p - cent) - rad;\n}\nfloat sceneSDF(vec3 p){\n    float t = 0.5* iTime;\n    p = euler(p, vec3(t));\n    float d1 = 1.0;\n    for (float i = 0.0; i < 6.0; i++){\n        vec3 cent = vec3(cos(PI * i / 3.0), sin(PI * i / 3.0), 0.0);\n        d1 = min(d1, sphereSDF(p, cent, 0.2));\n    }\n    float d2 = sphereSDF(p, vec3(0.0), 1.);\n    return mix(d1, d2, abs(mod(t, 2.0) - 1.0));\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cPos = vec3(0.0, 0.0, 2.5);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    vec3 lDir = vec3(0.0, 0.0, 1.0);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    \n    vec3 rPos = cPos + ray;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lScWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 44, 71, 71, 147], [148, 148, 175, 175, 214], [215, 215, 242, 242, 285], [286, 286, 313, 313, 352], [353, 353, 380, 380, 429], [430, 440, 486, 486, 523], [524, 524, 547, 547, 875], [876, 876, 897, 897, 1185], [1187, 1187, 1241, 1241, 2088]], "test": "untested"}
{"id": "slScWG", "name": "9_1_boolOp2d", "author": "tomoe", "description": "sample code\ncontour of the union/intersection/complement of SDFs", "tags": ["ch9"], "likes": 1, "viewed": 189, "published": 3, "date": "1650198920", "time_retrieved": "2024-07-30T16:53:23.256679", "image_code": "const float PI = 3.14159265359;\nfloat rectSDF(vec2 p, vec2 c, vec2 d){\n    p = abs(p - c);\n    return length(max(p - d, vec2(0.0))) + min(max(p.x - d.x, p.y - d.y), 0.0);\n}\nfloat circleSDF(vec2 p, vec2 c, float r){\n    return length(p - c) - r;\n}\nvec3 contour(float v, float interval){\n    return abs(v) < 0.01 ? vec3(0.0):\n    mod(v, interval) < 0.01 ? vec3(1.0):\n    mix(vec3(0, 0, 1), vec3(1, 0, 0), atan(v) / PI + 0.5);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ iResolution.yy;\n    float v1 = circleSDF(pos, vec2(0.2), 0.4);\n    float v2 = rectSDF(pos, vec2(-0.2), vec2(0.4));\n    float v = int(iTime) % 3 == 0 ? max(v1, v2):\n        int(iTime)% 3 == 1 ? min(v1, v2):\n        max(v1, -v2);\n    fragColor = vec4(contour(v, 0.1), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slScWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 70, 70, 172], [173, 173, 214, 214, 246], [247, 247, 285, 285, 425], [426, 426, 480, 480, 807]], "test": "untested"}
{"id": "7tScWG", "name": "9_0_boolOp3d", "author": "tomoe", "description": "sample code\n(left) intersection (center) union (right) complement", "tags": ["ch9"], "likes": 1, "viewed": 143, "published": 3, "date": "1650198827", "time_retrieved": "2024-07-30T16:53:29.093074", "image_code": "float sphereSDF(vec3 p, vec3 c, float r){\n    return length(p - c) - r;\n}\nfloat sceneSDF(vec3 p){\n    float[3] smallS, bigS;\n    for (int i = 0; i < 3; i++){\n        smallS[i] = sphereSDF(p, vec3(float(i - 1), sin(iTime), 0.0), 0.3);\n        bigS[i] = sphereSDF(p, vec3(float(i - 1), 0.0, 0.0), 0.5);\n    }\n    float cap = max(smallS[0], bigS[0]);\n    float cup = min(smallS[1], bigS[1]);\n    float minus = max(smallS[2], -bigS[2]);\n    return min(min(cap, cup), minus);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, -1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    vec3 lDir = vec3(0.0, 0.0, 1.0);\n\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    \n    vec3 rPos = cPos + ray;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tScWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 73], [473, 473, 494, 494, 781], [782, 782, 836, 836, 1678]], "test": "untested"}
{"id": "slByWG", "name": "8_8_box", "author": "tomoe", "description": "sample code", "tags": ["ch8"], "likes": 1, "viewed": 178, "published": 3, "date": "1650198734", "time_retrieved": "2024-07-30T16:53:30.253970", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.2831853;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\nfloat boxSDF(vec3 p, vec3 c, vec3 d, float t){\n    p = abs(p - c);\n    return length(max(p - d, vec3(0.0))) + min(max(max(p.x - d.x, p.y - d.y), p.z - d.z), 0.0) - t;\n}\n\nfloat sceneSDF(vec3 p){\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 scale = vec3(0.5);\n    float thickness = 0.1;\n    return boxSDF(p, center, scale, thickness);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 t = vec3(iTime * 0.5);\n    vec3 cPos = euler(vec3(0.0, 0.0, 2.0), t);\n    vec3 cDir = euler(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = euler(vec3(0.0, 1.0, 0.0), t);\n    vec3 lDir = euler(vec3(0.0, 0.0, 1.0), t);\n    vec3 cSide = cross(cDir, cUp);\n\n    float targetDepth = 1.0;\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lDir), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slByWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 73, 100, 100, 176], [177, 177, 204, 204, 243], [244, 244, 271, 271, 314], [315, 315, 342, 342, 381], [382, 382, 409, 409, 458], [459, 469, 515, 515, 637], [639, 639, 662, 662, 806], [807, 807, 828, 828, 1110], [1112, 1112, 1166, 1166, 2086]], "test": "untested"}
{"id": "7tByWG", "name": "8_7_rotSphere", "author": "tomoe", "description": "sample code", "tags": ["ch8"], "likes": 1, "viewed": 162, "published": 3, "date": "1650198689", "time_retrieved": "2024-07-30T16:53:31.034882", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.2831853;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t){\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\nfloat sphereSDF(vec3 p, vec3 c, float r){\n    return length(p - c) - r;\n}\n\nfloat sceneSDF(vec3 p){\n    vec3 cent = rotY(vec3(0.0, 0.0, - 0.5), iTime);\n    float scale = 0.3;\n    return sphereSDF(p, cent, scale);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    \n    float targetDepth = 1.0;\n    \n    vec3 lDir = rotY(vec3(0.0, 0.0, 1.0), iTime);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = normalize(ray);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(lDir, gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tByWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 73, 100, 100, 176], [177, 177, 204, 204, 243], [244, 244, 271, 271, 314], [315, 315, 342, 342, 381], [382, 382, 409, 409, 458], [459, 469, 510, 510, 542], [544, 544, 567, 567, 682], [683, 683, 704, 704, 986], [988, 988, 1042, 1042, 1901]], "test": "untested"}
{"id": "stByWG", "name": "8_6_sphere", "author": "tomoe", "description": "sample code", "tags": ["ch8"], "likes": 2, "viewed": 176, "published": 3, "date": "1650198649", "time_retrieved": "2024-07-30T16:53:31.805821", "image_code": "float sphereSDF(vec3 p){\n    return length(p) - 1.0;\n}\nfloat sceneSDF(vec3 p){\n    return sphereSDF(p);\n}\nvec3 gradSDF(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d))\n    ));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    \n    float targetDepth = 1.0;\n    \n    vec3 lPos = vec3(2.0);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = normalize(ray);\n    \n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < 50; i ++ ){\n        if (sceneSDF(rPos) > 0.001){\n            rPos += sceneSDF(rPos) * ray;\n        } else {\n            float amb = 0.1;\n            float diff = 0.9 * max(dot(normalize(lPos - rPos), gradSDF(rPos)), 0.0);\n            vec3 col = vec3(0.0, 1.0, 1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stByWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 54], [55, 55, 78, 78, 105], [106, 106, 127, 127, 409], [410, 410, 464, 464, 1323]], "test": "untested"}
{"id": "stSyWG", "name": "8_5_raymarching", "author": "tomoe", "description": "sample code\nraymarching diagram, ray direction is parametrized by the mouse position\nblue line: ray, red point: reference point, yellow circle: neighborhood", "tags": ["ch8"], "likes": 2, "viewed": 199, "published": 3, "date": "1650198608", "time_retrieved": "2024-07-30T16:53:32.794178", "image_code": "float circleSDF(vec2 p, vec2 c, float r){\n    return length(p - c) - r;\n}\nfloat contour(float v){\n    return step(abs(v), 0.002);\n}\nfloat point(vec2 p, vec2 c){\n    return step(length(p-c), 0.01);\n}\nfloat line(vec2 p, vec2 c, vec2 d){\n    return step(abs(dot(p - c, vec2(-d.y, d.x))), 0.002);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ iResolution.yy;\n    vec2 cPos = vec2(-0.5, 0.0);    //camera position\n    vec2 oPos = vec2(1.0, 0.0); //object position\n    vec2 ray = oPos - cPos;\n    ray.y +=  2.0 * iMouse.y / iResolution.y - 1.0;\n    ray = normalize(ray);\n    float rad = 0.8;\n    vec2 rPos = cPos;\n    fragColor.rgb = contour(circleSDF(pos, oPos, rad)) * vec3(1);    //draw circle of object\n    fragColor.rgb += line(pos, cPos, ray) * vec3(0,0,1);  //draw line\n    for (int i = 0; i < 50; i++){\n        fragColor.rgb += point(pos, rPos) * vec3(1.0, 0.0, 0.0);  //plot ray position\n        float dist = circleSDF(rPos, oPos, rad);\n        if (dist < 0.01){\n            break;\n        }\n        fragColor.rgb += contour(circleSDF(pos, rPos, dist)) * vec3(0.5, 0.5, 0.0);     //draw circle with radius of SDF value\n        rPos += dist * ray;\n        if (rPos.x > oPos.x + rad){\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 73], [74, 74, 97, 97, 131], [132, 132, 160, 160, 198], [199, 199, 234, 234, 294], [295, 295, 349, 349, 1309]], "test": "untested"}
{"id": "NlBcDy", "name": "8_4_normalMapping", "author": "tomoe", "description": "sample code", "tags": ["ch8"], "likes": 4, "viewed": 225, "published": 3, "date": "1650198568", "time_retrieved": "2024-07-30T16:53:33.684797", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.2831853;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\n//end rot\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//start vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n//start processing noise\nfloat base21(vec2 p){\n    return vnoise21(p) - 0.5;\n}\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * base21(freq * p);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 3; i++){\n        val = fbm21(p + g * vec2(cos(TAU * val), sin(TAU * val)), 0.5);\n    }\n    return val;\n}\n//end processing noise\nvec2 grad2(vec2 uv){\n    uv += 0.3 * iTime;\n    float d = 0.001;\n    return 0.5 * (vec2(\n        warp21(uv + vec2(d, 0.0), 1.0)\n             - warp21(uv - vec2(d, 0.0), 1.0),\n            warp21(uv + vec2(0.0, d), 1.0) - warp21(uv - vec2(0.0, d), 1.0)\n        )) / d;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cPos = vec3(0.0, 0.0, 0.0);\n    float t = -0.25 * PI;\n    vec3 cDir = rotX(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = rotX(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth - cPos;\n    ray = normalize(ray);\n    vec3 groundNormal = vec3(0.0, 1.0, 0.0);\n    float groundHeight = 1.5;\n    vec3 lPos = vec3(0.,0.,0.);\n    if (dot(ray, groundNormal) < 0.0){\n        vec3 hit = cPos - ray * groundHeight / dot(ray, groundNormal);\n        groundNormal.zx += grad2(hit.zx);\n        groundNormal = normalize(groundNormal);\n        float diff = max(dot(normalize(lPos - hit), groundNormal), 0.0);\n        diff *= 1.5;\n        diff /= pow(length(lPos - hit), 1.5) ;\n        fragColor = vec4(diff);\n    } else {\n        fragColor = vec4(0.0);\n    }  \n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 73, 100, 100, 176], [177, 177, 204, 204, 243], [244, 244, 271, 271, 314], [315, 315, 342, 342, 381], [522, 522, 543, 543, 642], [643, 643, 666, 666, 779], [780, 780, 803, 803, 904], [905, 905, 927, 927, 1010], [1011, 1011, 1032, 1032, 1118], [1119, 1119, 1140, 1140, 1226], [1227, 1227, 1247, 1247, 1329], [1330, 1330, 1350, 1350, 1432], [1803, 1841, 1862, 1862, 1894], [1895, 1895, 1924, 1924, 2136], [2137, 2137, 2167, 2167, 2317], [2318, 2341, 2361, 2361, 2609], [2610, 2610, 2664, 2664, 3623]], "test": "untested"}
{"id": "flBcDy", "name": "8_3_noiseTexturing", "author": "tomoe", "description": "sample code", "tags": ["ch8"], "likes": 5, "viewed": 178, "published": 3, "date": "1650198549", "time_retrieved": "2024-07-30T16:53:34.507597", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.2831853;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\n//end rot\n//begin hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n){\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n){\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p){\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p){\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n\n//begin vnoise\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    float[4] v;\n    for (int j = 0; j < 2; j ++){\n        for (int i = 0; i < 2; i++){\n            v[i+2*j] = hash21(n + vec2(i, j));\n        }\n    }\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\n//end vnoise\n//begin processing noise\nfloat base21(vec2 p){\n    return vnoise21(p) - 0.5;\n}\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * base21(freq * p);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for (int i = 0; i < 3; i++){\n        val = fbm21(p + g * vec2(cos(TAU * val), sin(TAU * val)), 0.5);\n    }\n    return val;\n}\n//end processing noise\n//begin cnoise\nfloat fdist31(vec3 p){\n    vec3 n = floor(p + 0.5);\n    float dist = sqrt(3.0);\n    for(float k = 0.0; k <= 2.0; k ++ ){\n            vec3 glid;\n            glid.z = n.z + sign(mod(k, 2.0) - 0.5) * ceil(k * 0.5);\n            if (abs(glid.z - p.z) - 0.5 > dist){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ){\n            glid.y = n.y + sign(mod(j, 2.0) - 0.5) * ceil(j * 0.5);\n            if (abs(glid.y - p.y) - 0.5 > dist){\n                continue;\n            }\n            for(float i = -1.0; i <= 1.0; i ++ ){\n                glid.x = n.x + i;\n                vec3 jitter = hash33(glid) - 0.5;\n                dist = min(dist, length(glid + jitter - p));\n            }\n        }\n    }\n    return dist;\n}\n//end cnoise\nfloat text(vec2 st){\n    float time = 0.3 * iTime;\n    float v0 = warp21(st + time, 1.0);\n    float v1 = fdist31(vec3(st + time, time));\n    time = abs(mod(time, 2.0) - 1.0);\n    return mix(v0, v1, smoothstep(0.25, 0.75, time));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cPos = vec3(0.0, 0.0, 0.0);\n    float t = -0.25 * PI;\n    vec3 cDir = rotX(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = rotX(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth - cPos;\n    ray = normalize(ray);\n    vec3 groundNormal = vec3(0.0, 1.0, 0.0);\n    float groundHeight = 1.5;\n    vec3 lPos = vec3(0.,0.,0.);\n    if (dot(ray, groundNormal) < 0.0){\n        vec3 hit = cPos - ray * groundHeight / dot(ray, groundNormal);\n        float diff = max(dot(normalize(lPos - hit), groundNormal), 0.0);\n        diff *= 1.2;\n        diff = pow(diff, 0.8);\n        fragColor.rgb = vec3(diff * text(hit.zx));\n    } else {\n        fragColor.rgb = vec3(0.0);\n    }  \n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 73, 100, 100, 176], [177, 177, 204, 204, 243], [244, 244, 271, 271, 314], [315, 315, 342, 342, 381], [522, 522, 543, 543, 642], [643, 643, 666, 666, 779], [780, 780, 803, 803, 904], [905, 905, 927, 927, 1010], [1011, 1011, 1032, 1032, 1118], [1119, 1119, 1140, 1140, 1226], [1227, 1227, 1247, 1247, 1329], [1330, 1330, 1350, 1350, 1432], [1803, 1841, 1862, 1862, 1894], [1895, 1895, 1924, 1924, 2136], [2137, 2137, 2167, 2167, 2317], [2318, 2356, 2378, 2378, 3102], [3103, 3116, 3136, 3136, 3346], [3347, 3347, 3401, 3401, 4277]], "test": "untested"}
{"id": "NtBcDy", "name": "8_2_lighting", "author": "tomoe", "description": "sample code\nlight intensity is parametrized by the mouse position", "tags": ["ch8"], "likes": 2, "viewed": 143, "published": 3, "date": "1650198492", "time_retrieved": "2024-07-30T16:53:35.244627", "image_code": "const float PI = 3.14159265359;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\n//end rot\nfloat text(vec2 st){\n    return mod(floor(st.s) + floor(st.t), 2.0);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cPos = vec3(0.0, 0.0, 0.0);\n    float t = -0.25 * PI;\n    vec3 cDir = rotX(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = rotX(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth - cPos;\n    ray = normalize(ray);\n    vec3 groundNormal = vec3(0.0, 1.0, 0.0);\n    float groundHeight = 1.0;\n    vec3 lPos = vec3(0.,0.,0.);\n    if (dot(ray, groundNormal) < 0.0){\n        vec3 hit = cPos - ray * groundHeight / dot(ray, groundNormal);\n        float diff = max(dot(normalize(lPos - hit), groundNormal), 0.0);\n        diff *= 0.5 + iMouse.y/iResolution.y;\n        diff = pow(diff, 0.5 + iMouse.x/iResolution.x);\n        fragColor.rgb = vec3(diff * text(hit.zx));\n    } else {\n        fragColor.rgb = vec3(0.0);\n    }  \n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 44, 71, 71, 147], [148, 148, 175, 175, 214], [215, 215, 242, 242, 285], [286, 286, 313, 313, 352], [353, 363, 383, 383, 433], [434, 434, 488, 488, 1414]], "test": "untested"}
{"id": "ftBcDy", "name": "8_1_texMapping", "author": "tomoe", "description": "sample code\nthe camera direction is parametrized by the mouse position\n", "tags": ["ch8"], "likes": 1, "viewed": 170, "published": 3, "date": "1650198436", "time_retrieved": "2024-07-30T16:53:35.981656", "image_code": "const float PI = 3.14159265359;\n//begin rot\nvec2 rot2(vec2 p, float t){\n    return vec2(cos(t) * p.x -sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t){\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t){\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t){\n    return vec3(rot2(p.xy, t), p.z);\n}\n//end rot\nfloat text(vec2 st){\n    return mod(floor(st.s) + floor(st.t), 2.0);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cPos = vec3(0.0, 0.0, 0.0);\n    float t = -0.5 * PI * (iMouse.y / iResolution.y);\n    vec3 cDir = rotX(vec3(0.0, 0.0, - 1.0), t);\n    vec3 cUp = rotX(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth - cPos;\n    ray = normalize(ray);\n    vec3 groundNormal = vec3(0.0, 1.0, 0.0);\n    float groundHeight = 1.0 + (iMouse.x / iResolution.x);\n    if (dot(ray, groundNormal) < 0.0){\n        vec3 hit = cPos - ray * groundHeight / dot(ray, groundNormal);\n        fragColor.rgb = vec3(text(hit.zx));\n    } else {\n        fragColor.rgb = vec3(0.0);\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 44, 71, 71, 147], [148, 148, 175, 175, 214], [215, 215, 242, 242, 285], [286, 286, 313, 313, 352], [353, 363, 383, 383, 433], [434, 434, 488, 488, 1255]], "test": "untested"}
{"id": "NlScDy", "name": "8_0_silhouette", "author": "tomoe", "description": "sample code\nsilhouette of the horizon\n", "tags": ["ch8"], "likes": 0, "viewed": 142, "published": 3, "date": "1650198372", "time_retrieved": "2024-07-30T16:53:36.820413", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cPos = vec3(0.0, 0.0, 0.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 groundNormal = vec3(0.0, 1.0, 0.0);\n    if (dot(ray, groundNormal) < 0.0){\n        fragColor.rgb = vec3(1.0);\n    } else {\n        fragColor.rgb = vec3(0.0);\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlScDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 577]], "test": "untested"}
{"id": "7tSyWy", "name": "Egg shape", "author": "SanderVanhove", "description": "This is a simple egg shape example.", "tags": ["shape"], "likes": 2, "viewed": 190, "published": 3, "date": "1650189206", "time_retrieved": "2024-07-30T16:53:37.654185", "image_code": "#define PI                3.141592654\n\n/*\nEgg shape\n\nEquation from this paper: https://nyjp07.com/index_egg_E.html\n*/\nfloat egg(vec2 uv, float a, float b_ratio) {\n\tfloat feather = .005;\n\tfloat x = uv.x;\n\t\n\tif (x < 0.) return 0.;\n\tif (x > a) return 0.;\n\t\n\tfloat b = a * b_ratio;\n\tfloat c = a - b;\n\t\n\tfloat up = sqrt(c - 2. * x + sqrt(4. * b * x + pow(c, 2.)));\n\tfloat y = up / sqrt(2.) * sqrt(x);\n\t\n\treturn 1. - (smoothstep(y - feather, y + feather, uv.y) + smoothstep(y - feather, y + feather, -uv.y));\n}\n\nvec2 rotate2D(vec2 uv, float angle) {\n\tuv -= .5;\n\tuv = mat2(vec2(cos(angle), -sin(angle)), vec2(sin(angle), cos(angle))) * uv;\n\tuv += .5;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Position and rotation\n    p = rotate2D(p, PI * -.5);\n    p.x -= .5;\n\n    // Make egg shape\n    vec3 egg_shape = vec3(egg(p, 1., .7));\n\n    // Output to screen\n    fragColor = vec4(egg_shape,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 118, 162, 162, 504], [506, 506, 543, 543, 657], [659, 659, 716, 716, 1034]], "test": "untested"}
{"id": "NlByDy", "name": "RayMarching Planet", "author": "Decycle", "description": "A raymarching planet. ", "tags": ["raymarching"], "likes": 0, "viewed": 216, "published": 3, "date": "1650176545", "time_retrieved": "2024-07-30T16:53:38.475987", "image_code": "const int MAX_STEPS = 256;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 1000.0;\nconst vec3 PLANET_COLOR = vec3(118., 89., 89.) / 255.;\nconst vec3 SEA_COLOR = vec3(115., 168., 245.) / 255.;\n\nstruct RayMarch {\n    float totalDist;\n    float currentDist;\n    int steps;\n};\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\nfloat displacement(vec3 p) {\n    float d = 0.0;\n    d += noise(p) * 0.8;\n    d += noise(p * 2.0) * 0.4;\n    d += noise(p * 4.0) * 0.2;\n    d += noise(p * 8.0) * 0.1;\n    \n    return d - 0.75;\n}\n\nfloat sphereSDF(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat planetSDF(vec3 p)\n{\n    float planet = sphereSDF(p, vec3(0.), 10.);\n    return planet + displacement(p);\n}\n\nfloat seaSDF(vec3 p)\n{\n    return sphereSDF(p, vec3(0.), 10.);\n}\n\nRayMarch planet_ray_march(vec3 ro, vec3 rd)\n{\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d;\n        float sdf = planetSDF(p);\n        if(abs(sdf) < MIN_DIST || abs(sdf) > MAX_DIST)\n        {\n            return RayMarch(d, sdf, i);\n        }\n        d += sdf * 0.707107;\n    }\n    return RayMarch(d, MAX_DIST, MAX_STEPS);\n}\n\nRayMarch sea_ray_march(vec3 ro, vec3 rd)\n{\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d;\n        float sdf = seaSDF(p);\n        if(sdf < MIN_DIST || sdf > MAX_DIST)\n        {\n            return RayMarch(d, sdf, i);\n        }\n        d += sdf;\n}\nreturn RayMarch(d, MAX_DIST, MAX_STEPS);\n}\n\n\nvec3 rotateY(vec3 p, float angle)\n{\n    mat3 ry = mat3(\n    cos(angle), 0., sin(angle),\n    0., 1., 0.,\n    -sin(angle), 0, cos(angle)\n    );\n\n    return ry * p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //rotate the camera\n    float theta = iTime / 10.;\n    \n    vec3 ro = vec3(25. * sin(theta), 0., -25. * cos(theta) );\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    vec3 rd = vec3(vec2(uv.x, uv.y / iResolution.x * iResolution.y), 1.);\n    \n    rd = rotateY(rd, theta);\n    \n    //find the distance between the camera and the planet / sea\n    RayMarch planet = planet_ray_march(ro, rd);\n    RayMarch sea = sea_ray_march(ro, rd);\n\n    vec3 planetColor = step(planet.currentDist, MIN_DIST) * PLANET_COLOR;\n    \n    vec3 planetHighlight = vec3(step(30., float(planet.steps)));\n\n    //planetColor += planetHighlight;\n\n    vec3 seaColor = step(sea.currentDist, MIN_DIST) * SEA_COLOR;\n    vec3 seaDepth = vec3(sea.totalDist - planet.totalDist) * step(sea.currentDist, MIN_DIST);\n\n    seaColor += seaDepth * 0.5;\n\n    vec3 color = sea.totalDist < planet.totalDist ? seaColor : planetColor;\n    \n    //color = vec3(planet.totalDist - sea.totalDist);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlByDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 301, 301, 346], [347, 347, 367, 367, 412], [413, 413, 431, 431, 470], [472, 472, 492, 492, 983], [986, 986, 1014, 1014, 1179], [1181, 1181, 1223, 1223, 1255], [1257, 1257, 1282, 1282, 1369], [1371, 1371, 1393, 1393, 1435], [1437, 1437, 1482, 1482, 1807], [1809, 1809, 1851, 1851, 2144], [2147, 2147, 2182, 2182, 2310], [2313, 2313, 2370, 2394, 3374]], "test": "untested"}
{"id": "NtScDG", "name": "Texture Chaos", "author": "blackle", "description": "revision shader jam 2022", "tags": ["livecode"], "likes": 10, "viewed": 332, "published": 3, "date": "1650160782", "time_retrieved": "2024-07-30T16:53:39.226979", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 plane(vec3 cam, vec3 ini, vec3 o, vec3 n, vec3 tn) {\n  float t = dot(o-ini, n)/dot(n,cam);\n  vec3 p = (cam*t+ini)-o;\n  vec3 l1 = normalize(cross(n,tn));\n  vec3 l2 = normalize(cross(n,l1));\n  return vec3(dot(p,l1),dot(p,l2),t);\n}\n\n#define ro(r) mat2(cos(r),sin(r),-sin(r),cos(r))\nfloat bpm = 145.;\nfloat mul = 6.*60./145.;\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat fakefft(float k) {\nfloat mul = fract(sin(k*564.)*353.);\n    return pow(1.-k,3.) * (.5+.5*sin(iTime*2.*k*(4.4544+mul)))*1.5;\n}\n\n\nfloat love(vec2 p) {\n  //p.x=abs(p.x);\n  p.x = sqrt(p.x*p.x+.001);\n  p.y+=.1;\n  return linedist(p,vec2(.2,.2),vec2(-0.2,-.2))-.2;\n}\n\nvec4 tex(vec2 crds, int i) {\n  float pulse = iTime - floor(iTime*mul)/mul;\n  if(i%3==0)crds *= ro(iTime);\n  crds.x+=.5;\n  crds*=.6+pulse*.5;\n  if(abs(crds.y)>.5||abs(crds.x)>.5)return vec4(0);\n  if(i%3==0) return texture(iChannel1,crds+.5);\n  if(i%3==1) return texture(iChannel2,crds+.5);\n  if(i%3==2) return texture(iChannel3,crds+.5);\n  /*\n  if(i%6==4) return texture(texChecker,crds+.5);\n  if (length(crds)>.5)return vec4(0);\n  if(i%6==1) return texture(texRevision,crds+.5).xyzy;\n  //float d = linedist()\n  if (length(crds-vec2(.7,-.2))<.5)return vec4(0);\n  if (length(crds-vec2(-.7,-.2))<.5)return vec4(0);\n  if (length(crds-vec2(-.4,-.7))<.5)return vec4(0);\n  if (length(crds-vec2(.2,-.85))<.5)return vec4(0);\n  return texture(texDfox,crds+.5)*2.;*/\n}\n\nvec3 curve(float k) {\n  float t = iTime/9. + k;\n  float w = 1. + sin(floor(iTime)*45.)*.3;\n  return vec3(sin(t*w),cos(t*9.),sin(t*2.5))*4.;\n}\n\nvec2 delt(vec2 p) {\n  mat2 k = mat2(p,p)-mat2(0.001);\n  return normalize(love(p) - vec2(love(k[0]),love(k[1])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec4 last = texture(iChannel0,fragCoord.xy/iResolution.xy);\n\n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(-3,0,0);\n  \n  vec4 col = vec4(0);\n  float mt = 1e4;\n  for (int i = 0; i < 200; i++) {\n    vec3 org = curve(float(i)*3.14159/100.);\n    vec3 hit = plane(cam, init, org, normalize(-org), normalize(vec3(cos(vec2(-org.z,org.x)),0)));\n    if (hit.z > .8 && hit.z < mt) {\n      vec4 tx = tex(hit.xy,i);\n      if (tx.w > 0.5) { \n        col = tx;\n        \n      mt = hit.z;\n      }\n    }\n  }\n  \n\tfragColor = (mt>0.)?col:vec4(0);\n  //fragColor = mix(fragColor ,last,sin(iTime)*.4+.5);\n  fragColor = mix(fragColor, last*.9, 1.-clamp(fragColor.w,0.,1.));\n  //fragColor = mix(fragColor ,last,sin(iTime)*.4+.5);\n  \n  float sx = floor(fragCoord.x/iResolution.x*30.)/30.;\n  sx = abs(sx-.5)*2.;\n  if (fragCoord.y/iResolution.y < fakefft(sx)) fragColor=vec4(1);\n  \n  float pulse = iTime - floor(iTime*mul)/mul;\n  uv *= ro(cos(iTime*mul*3.1415)*.3);\n  uv.y += cos(iTime/2.*mul)*.1;\n  uv.x += sin(iTime/2.*mul)*.1;\n  uv *= (1.+pulse);\n  float lv = love(uv);\n  float edge = smoothstep(0.,-.1,lv);\n  vec3 n = normalize(vec3(edge,delt(uv)*(1.-edge)));\n  vec3 r = reflect(cam,n);\n  float spec=  length(sin(n*4.)*.5+.5)/sqrt(3.);\n  if (lv<0.)fragColor.xyz=vec3(.9,.1,.1)+pow(spec,10.)*3.;\n  \n}\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtScDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "7ljyzd", "name": "Revision 2022 jam entry", "author": "kostik1337", "description": "My shader for revision 2022 shader jam", "tags": ["revision", "jam"], "likes": 7, "viewed": 219, "published": 3, "date": "1650146251", "time_retrieved": "2024-07-30T16:53:39.982958", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(texture(iChannel0, uv).rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define INF (1e10)\n#define PI 3.14159265\n#define rep(p,s) (mod(p,s)-s/2.)\n#define rep2(p,s) (abs(rep(p,2.*s))-s/2.)\n#define time iTime\n\n#define mr(t) (mat2(cos(t), sin(t), -sin(t), cos(t)))\n\n// Don't know how to use integrated fft on shadertoy :(\nfloat ffti(float t) {return 0.;/*texture(iChannel0, vec2(t,0.)).r*/;}\nfloat ffts(float t) {return texture(iChannel0, vec2(t,0.)).r;}\n\nfloat box(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return max(p.x, max(p.y, p.z));\n}\n\nvec3 ct(vec3 p) {\n  if(p.x < p.y) p.xy = p.yx;\n  if(p.y < p.z) p.yz= p.zy;\n  if(p.x < p.y) p.xy = p.yx;\n  return p;\n}\n\nfloat hash(float t) {\n  return fract(sin(t * 3234.12345));\n}\n\nfloat glow = 0.;\n\nfloat map(vec3 op) {\n  op.z += 10.*time + 20.*ffti(.07);\n  float m = INF;\n  vec3 p = op;\n  p = 2.-abs(p);\n  \n  float off = 0.;\n  vec3 p1 = p;\n  for(float i=0.; i<1.; ++i) {\n    p1 += vec3(hash(i), hash(i+.17), hash(i+.21));\n    off += hash(dot(vec3(.17, .21, .92), floor(p1/6.)));\n    p1 *= 2.;\n  }\n  m = min(m, max(p.x, p.y) + 1. + off);\n  \n  p = op;\n  float wires = INF;\n  float t = time / 4.;\n  t = floor(t) + smoothstep(.8, 1., fract(t));\n  for(float i = 0.; i<3.;++i) {\n    p.xz *= mr(.22);\n    p.yz *= mr(.28);\n    p = rep2(p, vec3(130.) / exp2(i));\n    p.xz *= mr(.3);\n    p.yz *= mr(.13);\n    if(i == 2.) p.xz *= mr(t * .1);\n    p = abs(p)-1.2;\n    p = ct(abs(p));\n    wires = min(wires, length(p.yz)-.1);\n    \n    vec3 p1 = p;\n    p1.x = rep2(p1.x + time, 12.);\n    p1 = abs(p1)-.2;\n    p1.yz *= mr(3.*p1.x);\n    float m1 = max(abs(p1.s)-2., length(p1.yz)-.01);\n    wires = min(wires, m1);\n    glow += .01 / abs(m1+.003);\n  }\n  m = max(m, -wires+.3);\n  m = min(m, wires);\n  \n  p = op;\n  float zdiv = 8.;\n  float cz = floor(p.z/zdiv);\n  p.z = rep(p.z, zdiv);\n  float ang = hash(cz) * 2.*PI + time * (hash(cz+.111)*2.-1.);\n  p.xy -= 3.*vec2(cos(ang), sin(ang));\n  p1 = p;\n  float figure = INF;\n  p.xz *= mr(3.*time * mix(.3, .9, hash(cz+.1344)));\n  p.yz *= mr(3.*time * mix(.3, .9, hash(cz+.37887)));\n  if(hash(cz + .911) < .5) {\n    figure = box(p, vec3(.5));\n  } else {\n    p = abs(p);\n    figure = dot(p, normalize(vec3(1.))) - .4;\n  }\n  float h = hash(cz+1.221);\n  float pawah = min(1., ffts(h)*90.);\n  glow += mix(.001, .003, pawah) / abs(figure-mix(.01, .3, pawah));\n  m = min(m, figure);\n  \n  return m;\n}\n\nvec3 normal(vec3 p) {\n  vec2 E = vec2(0., .001);\n  return normalize(\n    vec3(map(p+E.yxx), map(p+E.xyx), map(p+E.xxy)) - map(p));\n}\n\nvec3 bg(vec3 n) {\n  vec2 uv = vec2(atan(n.x, n.z), atan(n.x, n.y));\n  return 1.*vec3(.5, .7, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  vec2 uv1 = uv;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 c = vec3(0.);\n  vec3 O = vec3(0.,0.,-3.), D = normalize(vec3(uv, 1.));\n  D.xz *= mr(.3);\n  D.yz *= mr(.1);\n  D.xy *= mr(time*.3 + .1*ffti(.09));\n  float d = 0., i;\n  vec3 p;\n  bool hit = false;\n  for(i=0.; i<64.;++i) {\n    p = O+D*d;\n    float m = map(p);\n    d += m;\n    if(m < .001 * d) {\n      hit = true;\n      break;\n    }\n  }\n  if(hit) {\n    vec3 n = normal(p);\n    vec3 col = vec3(1.);\n    vec3 bg = bg(D);\n    vec3 expVec = vec3(1., 1.3, 1.3);\n    vec3 cc = mix(bg, col, dot(n, vec3(0.,0.,-1.)) * exp(-d*expVec*.1));\n    cc += col * max(0., dot(abs(D), n)) * exp(-d*expVec*.1);\n    c += cc;\n    c = mix(c, vec3(0.), glow * exp(-d*.04));\n  } else {\n    c= bg(D);\n  }\n  \n  vec2 e = vec2(.003 + .003 * (sin(time)*.5+.5), .0);\n  vec3 prev = vec3(\n    texture(iChannel1, uv1-e).r,\n    texture(iChannel1, uv1).g,\n    texture(iChannel1, uv1+e).b\n  );\n  \n  float mad = 1.2*mix(.2, .1, sin(time)*.5+.5);\n  c -= .04/(smoothstep(.2, .0, prev)+mad);\n  c += .2 * smoothstep(.5, 1., prev);\n  c = max(c, vec3(0.));\n  \n  fragColor = vec4(c, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28771, "src": "https://soundcloud.com/mpl57/mixail-pilyavskij-live-2", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 154]], "test": "untested"}
{"id": "Nt2yRd", "name": "Mandelbulb - Spi3lot", "author": "Spi3lot", "description": "Mandelbulb", "tags": ["fractal", "mandelbrot", "anaglyph", "mandel", "bulb", "mandebulb"], "likes": 3, "viewed": 218, "published": 3, "date": "1650144984", "time_retrieved": "2024-07-30T16:53:40.888536", "image_code": "// CONSTANTS\n#define PI 3.1415926535\n\n// RAY MARCHING SETTINGS\n#define EPSILON 0.001\n#define MAX_STEPS 100\n\n// MANDELBULB SETTINGS\n#define POWER 2.0\n#define BAILOUT 2.0\n#define MAX_ITERATIONS 50\n\n// LIGHT SETTINGS\n#define LIGHT_ROTATION_SPEED 1.0\n#define LIGHT_ANGLE iTime * LIGHT_ROTATION_SPEED\n#define LIGHT 10.0 * vec3(cos(LIGHT_ANGLE), sin(LIGHT_ANGLE), -1)\n//#define LIGHT 100.0 * vec3(cos(iTime), 0, sin(iTime))\n\n// ZOOM\n#define ZOOM 1.0\n\n// FOV (leave as is for best results)\n#define FOVX 0.4 * PI / ZOOM\n#define FOVY FOVX * iResolution.y / iResolution.x\n\n// GLOW EFFECT\n#define GLOW_EFFECT\n\n// 3D ANAGLYPH (RED-CYAN)\n//#define ANAGLYPH\n#define ANAGLYPH_OFFSET vec3(0.05, 0.0, 0.0)\n\n\nfloat iterations = -1.0;\n\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat sdf(vec3 pos)\n{\n    vec3 z = pos;\n\tfloat dr = 1.0;\n    float r;\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n\t\tr = length(z);\n\n\t\tif (r > BAILOUT) {\n            iterations = float(i);\n            break;\n        }\n\n\t\t// convert to polar coordinates\n\t\tfloat theta = POWER * acos(z.z / r) - PI * 0.5;\n\t\tfloat phi = POWER * atan(z.y, z.x);\n\t\tdr = pow(r, POWER - 1.0) * POWER * dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, POWER);\n\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\n\treturn 0.5 * log(r) * r / dr;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    const float eps = 5.0;  // The larger, the better (for some reason)\n    const vec2 h = vec2(eps, 0);\n\n    vec3 a = vec3( sdf(p - h.xyy),\n                   sdf(p - h.yxy),\n                   sdf(p - h.yyx) );\n\n    vec3 b = vec3( sdf(p + h.xyy),\n                   sdf(p + h.yxy),\n                   sdf(p + h.yyx) );\n\n    return normalize(b - a);\n}\n\nvec3 GetLight(vec3 pos)\n{\n    return normalize(LIGHT - pos);\n}\n\n\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    rd = normalize(rd);\n    float minDist = 1.0 / 0.0;  // Used for glow effect\n    \n    // Marching to the Mandelbulb\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = sdf(ro);\n\n        if (dist < minDist)\n            minDist = dist;\n\n        if (dist <= EPSILON)\n        {\n            vec3 normal = GetNormal(ro);\n            vec3 ro2Light = GetLight(ro);\n            \n            float light = clamp(dot(normal, ro2Light), 0.0, 1.0);\n            float ambientExposure = 1.0;\n\n            ro -= rd * EPSILON * 2.0;\n\n            // Ambient Occlusion\n            //   Marching to the light source\n            //   and checking for collisions on the way\n            for (int j = 0; j < MAX_STEPS; j++)\n            {\n                float distLightSource = length(LIGHT - ro);\n                if (distLightSource <= EPSILON)\n                {\n                    ambientExposure = 1.0;\n                    break;\n                }\n\n                float distMandel = sdf(ro);\n                if (distMandel <= EPSILON)\n                {\n                    ambientExposure = 0.5;\n                    break;\n                }\n\n                ro += ro2Light * min(distLightSource, distMandel);\n            }\n\n            vec4 col = vec4(1);\n            //vec4 col = vec4(iterations);\n            //col = cos(col);\n\n            return light * ambientExposure * col;\n        }\n\n        ro += rd * dist;\n    }\n\n#ifdef GLOW_EFFECT\n    return vec4(1e-3 / minDist);  // Glow\n#else\n    return vec4(0.0, 0.0, 0.0, 1.0);\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 norm = uv - 0.5;\n    \n    vec2 fov = vec2(FOVX, FOVY);\n    vec3 ro = vec3(LIGHT.xy / 20.0, -4);\n    vec3 rd = vec3(norm * fov, 1.0);  //vec3 rd = vec3(norm * fov, ZOOM);\n    vec4 col;\n    \n#ifdef ANAGLYPH\n    vec4 red = vec4(1,0,0,1) * march(ro + ANAGLYPH_OFFSET, rd);\n    vec4 cyan = vec4(0,1,1,1) * march(ro - ANAGLYPH_OFFSET, rd);\n    col = red + cyan;\n#else\n    col = march(ro, rd);\n#endif\n\n    // Output to screen\n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2yRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[717, 843, 864, 864, 1458], [1460, 1460, 1484, 1484, 1837], [1839, 1839, 1864, 1864, 1901], [1905, 1905, 1935, 1935, 3470], [3473, 3473, 3530, 3580, 4127]], "test": "untested"}
{"id": "fljyRK", "name": "TP5-6 Montagne", "author": "valentinCuzin", "description": "p2003442", "tags": ["tp5tp6"], "likes": 0, "viewed": 142, "published": 3, "date": "1650129959", "time_retrieved": "2024-07-30T16:53:41.906814", "image_code": "// Texturing\n// Eric Galin\n\nconst float View = 2800.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\nconst int Steps = 400;      // Number of steps\n\n// Lipschitz constant\nconst float K=1.0;\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\n    vec3 c;\n    float s;\n};\n\nvec3 Translation(vec3 p, vec3 T){\n    return p - T;\n}\n\n// Terrain -----------------------------------------------------------------------------------------------\n\nfloat plateau(float h,float altE,float altA){\n    if((h<altE) || (h>altE+altA))return h;\n    float u=(h-altE)/((altE+altA)-altE);\n    float c= u*u;\n    return altE+altA*c;\n}\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain( in vec2 p )\n{\n\t//return 50.*sin(p.x/100.0)*cos(p.y/100.0);\n    //return Fbm(p,50.,30.0,1);\n    return 3.*TurbulenceRidge(p,500.,50.,7,-100.,100.);\n} \n\n// Implicit surface defining the terrain\n// p : Point\nV ImplicitTerrain(in vec3 p,int index)\n{\n    p = Translation(p,vec3(-1500.,900.,0.));//nécessaire pour eviter la symétrie de mon coté, en plus l'endroit est sympa\n    float z = Terrain( p.xy );\n    z = plateau(z,0.,70.);\n    float h = p.z - z; \n    return V(h/2., index);\n}\n\n// Water ------------------------------------------------------------------------------------------------\n\n// Water heightfield\n// x : Position in the plane\nfloat Water( in vec2 p ) {    \n    return 3.*Turbulence(p,200.,5.*cos(iTime*0.2)+20.,2,0.5*iTime) -90.0;\n} \n\n// Implicit surface defining the terrain\n// p : Point\n// index : texture index\nV ImplicitWater(in vec3 p, int index){\n\tfloat h = p.z - Water( p.xy );\n    return V(h,index);\n}\n\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Différence\n// a,b : les deux distance de la fonction SDF des deux object\nfloat Differance(float a, float b){\n    return max(a, -b);\n}\n\n//matrice de rotation\n// a : prend en paramÃ¨tre iTime\nmat2 Rotation(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Sphere \n// p : Point\n// c : Center \n// r : Radius\nV Sphere(vec3 p, vec3 c,float r, int index)\n{\n  return V(length(p-c)-r, index);\n}\n\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n//la boite\n// p : le point Ã  qui on calcul la distance Ã  la boite\n// S : l'espace entre deux plan de la boite\nfloat Boite(vec3 p, vec3 s){\n    vec3 q = abs(p)-s;\n    return length( max(q , 0.0))+ min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat cylinder (vec3 a, vec3 b, float r, vec3 p)\n{\n    float aq = dot((p-a),(b-a)/length(b-a));\n    float l = sqrt(dot(p-a,p-a)- aq*aq);\n    return l-r;\n}\n\n//DemicylindreFini\n// p : point\n// r : rayon\n// t : taille du cylindre\nfloat DemiCylindreFini(vec3 p, float r, float t)\n{\n    float cylindreInf = cylinder(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, t), r, p);\n    float demiCylindreInf1 = Differance(cylindreInf, Plane( p, vec3(-0.6, 0.0, -1.0) , vec3(0.0, 0.0, t+1.0))); \n    demiCylindreInf1 = Differance(demiCylindreInf1, Plane( p, vec3(0.6 ,0.0 ,-1.0) , vec3(0.0,0.0,t+1.0) ));\n    return demiCylindreInf1;\n    \n}\n\n//moulin\n// p : point\n// t : taille du moulin\nV Moulin(vec3 p, float t,int indexC, int indexP){\n    V Colone = V(DemiCylindreFini(p, 70.0, t),indexC);\n    vec3 ptr= Translation(p,vec3(0.,70.,200.));\n    ptr.xz = ptr.xz * Rotation(iTime);\n    ptr.yz = ptr.yz * Rotation(1.53);\n    float raccord = Boite(ptr,vec3(20.,20.,50.));\n    ptr = Translation(ptr,vec3(0.,0.,30.));\n    float pale1 = Boite(ptr,vec3(150.,30.,10.));\n    ptr.xy = ptr.xy * Rotation(1.53);\n    V pale = V(Union(raccord,Union(pale1, Boite(ptr,vec3(150.,30.,10.)))),indexP);\n    V moulin = Union(Colone, pale);\n    return moulin;\n}\n\nV Bateau(in vec3 p,int indexVoile){\n    V base=V(Boite(p,vec3(50.,27.,4.)),1);\n    p.xy = p.xy*Rotation(cos(iTime)/2.);\n    p = Translation(p,vec3(0.,0.,-30.));\n    V mat=V(Boite(p,vec3(3.,3.,25.)),1);\n    p = Translation(p,vec3(20.,0.,0.));\n    V voile=V(Differance( Boite(p,vec3(20.,2.,15.)) , Plane(p,vec3(-0.6,0.,-1.),vec3(0.0,0.,5.)) ),indexVoile);\n    return Union(base,Union(mat,voile));\n    }\n\n// Scene --------------------------------------------------------------------------\n\n// Potential field of the object\n// p : point\nV Object(vec3 p)\n{\n  V terrain = ImplicitTerrain(p,0);\n  V Limite = Sphere(p,vec3(0.0,0.0,0.0),800.0,0);\n  V surface = Intersection(terrain, Limite);\n  V Ocean = Intersection(ImplicitWater(p,3), Limite);\n  vec3 pt = Translation(p,vec3(320.,0.,0.));\n  pt.xy = pt.xy * Rotation(-1.0);\n  V moulin1 = Moulin(pt,290.,2,1);\n  pt = Translation(p,vec3(150.,250.,Ocean.v+p.z-5.));\n  pt = Translation(pt,vec3(55.*cos(iTime),100.*cos(iTime),0.));\n  V bateau = Bateau(pt,4);\n  moulin1.v = Differance(moulin1.v,terrain.v);\n  V u = Union(moulin1,Union(surface,Ocean));\n  u = Union(u,bateau);\n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n    float v = Object(p).v;\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v/K);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nT TextureRock(in vec3 p)\n{\n  return T(mix(vec3(0.92,0.91,0.90),vec3(0.74,0.72,0.72),Fbm(p/50.0)),0.0);   \n}\n\nint convert(float a){\n    if(a<0.0){\n        a= a-1.0;\n    }\n    return int(a);\n}\n\nT TextureDamier(in vec3 p, T a, T b){\n    p.y = p.y+Turbulence(p,150.,10.,13);\n    int x = convert(p.x/20.);//convertion en entier\n    int y = convert(p.y/20.);//correction partie entière des valeurs négatifs pour evité le cas de int(0.4)=int(-0.4)\n    int z = convert(p.z/20.);\n        if( (x+y+z)%2 == 0 ){//modulo 2 pour faire 2 cas: coordonées paire, coordonées impaire\n        return a;//couleur 1\n    }else{\n        return b;//couleur 2\n    }   \n}\n\nT TextureBois(in vec3 p, T a, T b, float E, float bruit){\n    p = p + Translation(p,vec3(460.,0.,360.));\n    //p.xz = p.xz * Rotation(iTime);\n    p.yz = p.yz * Rotation(1.53);\n    \n    p = p + bruit*Noise(p)*(p/E);//perturbation de p en fonction de l'indice bruit et de la longeur d'onde E\n    float d = length(p.xy/50.);//calcul de la distance pour créer les cercles\n    float v = 0.5*cos(d*E) + 1.0;//utilisation de cos pour interpoler les deux couleurs quand v=1 couleur a quand v= 0 couleur b\n    return T( (a.c*v + b.c*(1.0-v)), (a.s*v + b.s*(1.0-v)) );//vrai interpolation de la couleur mais aussi de l'indice spéculaire\n}\n\nT TextureWater(in vec3 p){\n  float eauSombre = smoothstep(-10.,15.,p.z);\n  return T(mix(vec3(0.16,0.29,0.37),TextureRock(p).c,eauSombre),1.);\n}\n\nT TextureBorder(in vec3 p)\n{\n    return T(vec3(0.2,0.2,0.2),1.);   \n}\n\nT TextureTerrain(in vec3 p){\n    float herbe,neige,roche;\n    p.z = p.z+Turbulence(p,100.,50.,1);\n    herbe = smoothstep(-9.0, 10.0, p.z);\n    neige = smoothstep(80., 200., p.z);\n    roche = smoothstep(30.,70.,p.z);\n    if(p.z > 100.) return T(mix(TextureBorder(p).c,vec3(1., 1., 1.), neige),0.);\n\n    if(p.z > -30. && p.z < 40.) return T(mix(vec3(0.8, 0.8, 0.6), vec3(0., 0.6, 0.), herbe),0.);\n    \n    if(p.z > 40. && p.z < 100.) return T(mix(vec3(0.,0.6,0.),TextureBorder(p).c, roche),0.);\n\n    if(p.z > -70. && p.z < -30.) return T(vec3(.8, 0.8, 0.6),0.);\n\n    if(p.z <= -70.) return TextureWater(p);\n}\n\n// Compute color \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= Object(p);\n    if (vp.i==0){\n        return TextureTerrain(p);\n    }\n    else if (vp.i==1){\n        return TextureBois(p, T(vec3(0.87, 0.72, 0.53),0.0), T(vec3(0.54, 0.27, 0.07),0.0), 6.0, 0.1);\n    }\n    else if (vp.i==2){\n        return TextureDamier(p,T(vec3(0.52,0.18,0.11),0.0),T(vec3(0.81,0.28,0.16),0.0));\n    }\n    else if (vp.i==3){\n        return TextureWater(p);\n    }\n    else if (vp.i==4){        \n        return T(vec3(0.9,0.1,0.2),0.);//juste du rouge couleur unie.\n    }\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tvec3 col;\n    int it;\n    bool b;\n    float t = SphereTrace( ro, rd, View,b , it);\n\tvec3 p = ro + t*rd;\n    V vp= Object(p);\n    vec3 n = ObjectNormal( p );\n\n\n    col = Color(p,n).c;\n    // Sky\n    if( b==false )\n    {\n        col = vec3(0.79,0.5,0.43) - rd.z*rd.z*2.5;\n    }\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n                   \n\n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col = 0.45*col+0.55*dif*vec3(0.35,0.35,0.35);\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \tfloat s=float(it)/float(Steps);\n\t\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    \t// Gamma with square root\n    \treturn vec4( sqrt(col), t );\n    }\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/5.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 3.14*2.0*1.5*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}", "image_inputs": [], "common_code": "// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat Ridge(in vec3 p){\n    return 1.-2.*abs(Noise(p));\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\nfloat Ridge(in vec2 p){\n    return 1.-2.*abs(Noise(p));\n}\n\nfloat Turbulence(in vec3 p,float longueurOnde ,float coef, int detail){// somme de bruits \n    float somme = coef*Noise(p/longueurOnde);\n    for(int i = 0; i<detail; i++){//boucle pour calculer la somme de bruit\n        coef = coef *0.5;\n        longueurOnde = longueurOnde *0.5;\n        somme = somme + coef*Noise(p/longueurOnde);\n    }\n    return somme;\n}\n\nfloat Turbulence(in vec2 p,float longueurOnde ,float coef, int detail, float temps){// somme de bruits vec2\n    float somme = coef*Noise(p/longueurOnde);;\n    for(int i = 0; i<detail; i++){//boucle pour calculer la somme de bruit\n        coef = coef *0.5;\n        longueurOnde = longueurOnde *0.4;\n        somme = somme + coef*Noise(p/longueurOnde+temps);\n    }\n    return somme;\n}\n\nfloat TurbulenceRidge(in vec2 p,float longueurOnde, float coef, int detail, float amin, float amax){//somme de ridge\n    float somme = coef*Ridge(p/longueurOnde);\n    for(int i=1;i<detail;i++){\n        coef *= 0.5;\n        longueurOnde *= 0.5;\n        float att=smoothstep(amin,amax,somme);\n        somme+= att*coef*Ridge(p/longueurOnde);\n    }\n    return somme;\n}\n\n\n// Fractal brownian motion with 4 frequencies\n// p : Point\nfloat Fbm(in vec3 p)\n{\n    return Noise(p)/2.0+Noise(p*2.0)/4.0+Noise(p*4.0)/8.0+Noise(p*8.0)/16.0;\n}\n\n// Camera\n// a: Rotation angle around z axis\n// ro : Ray origin\nmat3 Camera(float a, out vec3 ro)\n{\n\tfloat range=1350.0;\n    // Origin\n    ro = vec3(range*cos(a),range*sin(a),range/4.0);\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,50.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 443, 443, 463], [573, 573, 618, 618, 746], [748, 800, 828, 905, 963], [966, 1020, 1060, 1060, 1296], [1405, 1455, 1481, 1481, 1561], [1564, 1643, 1681, 1681, 1738], [1849, 1910, 1940, 1940, 1963], [1964, 1964, 1982, 1982, 2077], [2079, 2156, 2191, 2191, 2216], [2218, 2275, 2299, 2299, 2375], [2377, 2482, 2519, 2519, 2542], [2543, 2543, 2568, 2568, 2675], [2677, 2730, 2775, 2775, 2811], [2813, 2813, 2850, 2850, 2877], [2879, 2993, 3021, 3021, 3115], [3117, 3117, 3167, 3167, 3271], [3273, 3344, 3394, 3394, 3732], [3734, 3780, 3829, 3829, 4330], [4332, 4332, 4367, 4367, 4732], [4819, 4865, 4883, 4883, 5456], [5566, 5606, 5637, 5637, 5867], [5869, 5999, 6064, 6064, 6473], [6576, 6576, 6602, 6602, 6683], [6685, 6685, 6706, 6706, 6766], [6768, 6768, 6805, 6805, 7226], [7228, 7228, 7285, 7285, 7858], [7860, 7860, 7886, 7886, 8003], [8005, 8005, 8033, 8033, 8074], [8076, 8076, 8104, 8104, 8682], [8684, 8729, 8759, 8759, 9258], [9260, 9347, 9396, 9419, 10320], [10322, 10322, 10370, 10395, 10795], [10797, 10797, 10854, 10906, 11327]], "test": "untested"}
{"id": "Nl2yzt", "name": "Eggstruction", "author": "blackle", "description": "revision shader showdown 2022 semi-final", "tags": ["livecode"], "likes": 37, "viewed": 542, "published": 3, "date": "1650116687", "time_retrieved": "2024-07-30T16:53:42.688724", "image_code": "#define ro(r) mat2(cos(r),sin(r),-sin(r),cos(r))\n\nfloat box(vec3 p, vec3 d) {\n  p = abs(p)-d;\n  return length(max(p,0.))+min(0.,max(p.x,max(p.y,p.z)));\n}\n\nfloat beam(vec3 p) {\n  p.xy -= max(0.,dot(normalize(vec2(1.)),p.xy))*2.*normalize(vec2(1));\n  p.xy -= max(0.,dot(normalize(vec2(1,-1)),p.xy))*2.*normalize(vec2(1,-1));\n  p.x += .2;\n  vec3 p2 = p;\n  p2.y = abs(p2.y)-.2;\n  p.z = asin(sin(p.z*10.))/10.;\n  p.yz *= ro(radians(45.));\n  return min(length(p2.xy),length(p.xy))-.02;\n}\n\nfloat zip(float k) {\n  k += iTime;\n  float id = floor(k)+.5;\n  k -= id;\n  k = smoothstep(-.1,.1,k)+smoothstep(-.2,.2,k)-smoothstep(-.3,.3,k);\n  k+=id;\n  return k;\n}\n\nfloat o1, o2, o3;\nvec3 oop;\nfloat scene(vec3 p) {\n  p.xy *= ro(asin(sin(zip(.4)/2.))*.7);\n  o1 = beam(p);\n  o2 = beam(p.xzy);\n  o3 = box(p,vec3(.2))-.1;\n  o3 = min(o3,box(p-vec3(0,1,0),vec3(.2,.2,.4))-.1);\n  o3 = min(o3,box(p-vec3(0,-5,0),vec3(.2,.05,.2))-.1);\n  o3 = min(o3,box(p-vec3(0,0,.6),vec3(.2,.2,.05))-.1);\n  o2 = max(o2,p.y-.79);\n  o2 = max(o2,-p.y-5.);\n  o1 = max(o1,p.z-.48);\n  p.z+=.4;\n  float op = p.z;\n  p.y += 2.5 + asin(sin(zip(0.)));\n  o3  = min(o3, box(p,vec3(.2,.3,.1))-0.05);\n  \n  vec3 p2 = p;\n  p2.y=abs(p.y)-.1;\n  p.z+=.4 + max(0.,asin(sin(iTime)))*8.;\n  o3  = min(o3, box(p,vec3(.2,.3,.1))-0.05);\n  o3 = min(o3,max(max(op,-p.z),length(p2.xy)-.02));\n  p.z+=.4;\n  p.xy*=ro(iTime/3.);\n  oop = p;\n  p.z*=.8;\n  float e = length(p)-.25+smoothstep(-.5,.5,p.z)*.4-.2;\n  if (asin(sin(iTime/2. - 3.14159/4.)) < 0.) e = 1e5;\n  return min(min(o3,e),min(o1,o2));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p)-vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n\n  vec3 cam = normalize(vec3(1.+sin(zip(.3)/2.)*.5,uv));\n  float v = sin(zip(.7))*.3;\n  vec3 init = vec3(-6,-2.+v,-1.+cos(zip(2.)*2.)*.25);\n  \n  cam.xz*=ro(.3);\n  init.xz*=ro(.3);\n  \n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  bool trig = false;\n  for(int i = 0; i<50&&!hit;i++){ \n    dist = scene(p);\n    p+=cam*dist;\n    hit = dist*dist<1e-6;\n    if(!trig)trig=dist<0.03;\n    if(dist>1e4)break;\n  }\n  vec3 lp = oop;\n  bool io1 = dist==o1;\n  bool io2 = dist==o2;\n  bool io3 = dist==o3;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fact = length(sin(r*3.)*.5+.5)/sqrt(3.);\n  vec3 matcol = texture(iChannel0,clamp(lp.yz*1.8+vec2(0,.3)+.5,0.,1.)).xyz;\n  if(io1)matcol=vec3(.7,.2,.1);\n  if(io3)matcol=vec3(.05);\n  if(io2)matcol=vec3(.7,.6,.05);\n  vec3 col = matcol+pow(fact,7.)*2.;\n  fragColor.xyz=hit?sqrt(col):vec3(trig?0.:uv.y*.5+.5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//from https://www.shadertoy.com/view/4sKyRK\nfloat distanceToBottleCurve(vec2 point) {\n    return point.y-0.1*sin(point.x*2.5 + 0.6) + 0.05*sin(5.0*point.x) + 0.04*sin(7.5*point.x);\n}\nbool texturee(vec2 uv) {\n    float ang = atan(uv.y, uv.x);\n    float len = floor(length(uv)*10.0);\n    bool val = len == 2. || len == 6. || len == 9.;\n    if (len == 3. || len == 4. || len == 5. || len == 8. || len == 10.) {\n        val = distanceToBottleCurve(vec2(ang+len,0.0))*7.99 > cos(len*7.99);\n    }\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    //I would make a better revision logo but I am too tired :(\n    fragColor = vec4(1.0,91.0,188.0,1.0)/255.;\n    float rad1 = abs(floor(atan(uv.x,uv.y)/2.)*.04);\n    if (texturee(uv*2.5)) {\n        fragColor = vec4(255.0,214.0,0.0,1.0)/255.;\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2yzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 77, 77, 153], [155, 155, 175, 175, 481], [483, 483, 503, 503, 647], [677, 677, 698, 698, 1524], [1526, 1526, 1545, 1545, 1657], [1660, 1660, 1717, 1767, 2685]], "test": "untested"}
{"id": "stByzd", "name": "Ice sheet height field", "author": "mrange", "description": "CC0: Ice sheet height field experimentation\nWas tinkering with using recursive voronoi patterns to\ngenerate something that could pass for ice breaking up\ninto smaller blocks", "tags": ["2d", "height"], "likes": 26, "viewed": 437, "published": 3, "date": "1650107993", "time_retrieved": "2024-07-30T16:53:43.569369", "image_code": "// CC0: Ice sheet height field experimentation\n//  Was tinkering with using recursive voronoi patterns to\n//  generate something that could pass for ice breaking up\n//  into smaller blocks\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract (sin (p)*43758.5453123);\n}\n\n// From: https://www.shadertoy.com/view/MsScWz\n// Originally from: https://www.shadertoy.com/view/ldl3W8\nvec3 voronoi(vec2 x) {\n  vec2 n = floor(x);\n  vec2 f = fract(x);\n\n  vec2 mr;\n  vec2 mp;\n\n  float md = 8.0;\n  for(int j=-1; j<=1; ++j)\n  for(int i=-1; i<=1; ++i) {\n    vec2 g = vec2(float(i),float(j));\n    vec2 o = hash2(n + g);\n    vec2 r = g + o - f;\n    float d = dot(r,r);\n\n    if(d<md) {\n      md = d;\n      mr = r;\n      mp = x+r;\n    }\n  }\n\n  md = 8.0;\n  for(int j=-1; j<=1; ++j)\n  for(int i=-1; i<=1; ++i) {\n    vec2 g = vec2(float(i),float(j));\n    vec2 o = hash2(n + g);\n    vec2 r = g + o - f;\n\n    if(dot(mr-r,mr-r)>0.0001) // skip the same cell\n      md = min(md, dot(0.5*(mr+r), normalize(r-mr)));\n  }\n\n  return vec3(md, mp);\n}\n\nfloat height(vec2 p) {\n  vec2 vp = p;\n  float vz = 1.0;\n  \n  const float aa = 0.025;\n\n  float gh = 0.0;\n  float hh = 0.0;\n\n  const float hf = 0.025;\n\n  // Recursive voronois\n  {\n    vec3 c = voronoi(vp);\n    gh = tanh(max(abs(0.35*(c.y-2.0*sin(0.25*c.z)*cos(sqrt(0.1)*c.z)))-0.4, 0.));\n    hh = smoothstep(-aa, aa, c.x-2.0*aa*smoothstep(1.0, 0.75, gh));\n    if (gh > 0.75) {    \n      return hf*tanh(hh+1.0*(gh-0.75));\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-3.0*aa*smoothstep(1.0, 0.5, gh));\n    if (gh > 0.5) {\n      return 0.75*hf*hh;\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0;\n  }\n\n  {\n    vec3 c = voronoi(vp);\n    hh = hh*smoothstep(-aa, aa, vz*c.x-2.0*aa*smoothstep(0.9, 0.25, gh));\n    if (gh > 0.25) {\n      return 0.5*hf*hh;\n    }\n\n    vz *= 0.5;\n    vp = vp * 2.0;\n  }\n  \n  return 0.0;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float z = mix(0.2, 0.5, smoothstep(-0.5, 0.5, sin(0.5*TIME)));\n\n  vec2 ip = p;\n  ip /= z;\n  ip.y += 0.5*TIME;\n  float h = height(ip);\n  vec3 n  = normal(ip);\n \n  vec3 ro = vec3(0.0, -1.0, 0.0);\n  vec3 lp = vec3(1.0, -0.95, 1.5);\n  vec3 pp = vec3(p.x, h, p.y);;\n  vec3 rd = normalize(ro-pp);\n  vec3 ld = normalize(pp-lp);\n  vec3 ref= reflect(rd, n);\n  \n  float dif = max(dot(n, ld), 0.0)*tanh(200.0*h);\n  float spe = pow(max(dot(ref, ld), 0.0), 10.0);\n \n  vec3 col = vec3(0.);\n  col += dif;\n  col += spe;\n  \n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stByzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 308, 328, 328, 442], [444, 549, 571, 571, 1189], [1191, 1191, 1213, 1213, 2062], [2064, 2064, 2085, 2085, 2291], [2293, 2293, 2348, 2348, 3023]], "test": "untested"}
{"id": "flcXDl", "name": "[CrzClm] Cloud", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]\n", "tags": ["maptoy", "crazyclimbers"], "likes": 12, "viewed": 317, "published": 3, "date": "1650100750", "time_retrieved": "2024-07-30T16:53:44.517833", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 1.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n// https://www.iquilezles.org/articles/smoothvoronoi/\nfloat voronoiSmooth(vec3 p, float s)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    float res = 8.;\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    for(int l=-1; l<=1; l++)\n    {\n        vec3 b = vec3(j,k,l);\n        vec3 r = b-f+hash33(i+b);\n\n        float d = length( r );\n        res = fOpUnionSmooth( res, d, s );\n    }\n    return res;\n}\n\nfloat vFbm(vec3 p, float freq, float s)\n{\n    return (1.-voronoiSmooth(p*freq, s)) * .7 +\n        \t (1.-voronoiSmooth(p*freq*2., s*.5)) * .2 +\n        \t (1.-voronoiSmooth(p*freq*4., s*.25)) * .1;\n}\n\nfloat map(vec3 p){\n    vec3 q = p;\n    float ns = pow(voronoiSmooth(q*2.+vec3(0,0,iTime*.5), .85), 1.)*.3;\n    float ns2 = u2s(pow(vFbm(q*1.+vec3(0,0,iTime*.1), 8., .5), 1.))*.15;\n    float smoothness = .3;\n    float d = fOpUnionSmooth(sdEllipsoid(q, vec3(.5, .25, .5)), sdEllipsoid(q+vec3(sin(iTime), sin(iTime), cos(iTime))*.5, vec3(.5, .25, .5)), smoothness)+ns-ns2;\n    return d*.25;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n\n// Matcaps\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// iYOYi lib: start\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n#define atan2(y, x) ((abs(x) > abs(y)) ? PI*.5 - atan(x,y) : atan(y, x))\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\n\n// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n\tfloat total = 0.;\\\n\tfloat frequency = 1.;\\\n\tfloat amplitude = 1.;\\\n\tfloat maxValue = 0.;\\\n\tfor(int i=0;i<rep;i++) {\\\n\t\ttotal += nname(vec2(n.x * frequency, n.y * frequency)) * amplitude;\\\n\t\tmaxValue += amplitude;\\\n\t\tamplitude *= pers;\\\n\t\tfrequency *= 2.;\\\n        if(total<-1.)break;\\\n\t}\\\n\tres = total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\tfbm_base(gnoise, n, rep, pers);\n\treturn res;\n}\n\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n#define CYCLE 4.\n\nfloat swSin(float v){\n    return sin(v*TAU/CYCLE);\n}\nfloat swSqr(float v){\n    return -2.0*(step(0.5,fract(v/CYCLE))-0.5);\n}\nfloat swSaw(float v){\n    return fract(-v/CYCLE)*2.0-1.0;\n}\nfloat swTri(float v){\n    return asin(sin(v*TAU/CYCLE))*2./PI;\n}\n\nfloat uwSin(float v){\n    return s2u(swSin(v));\n}\nfloat uwSqr(float v){\n    return s2u(swSqr(v));\n}\nfloat uwSaw(float v){\n    return s2u(swSaw(v));\n}\nfloat uwTri(float v){\n    return s2u(swTri(v));\n}\n\nfloat uwQuadratic(float v){\n    return quadraticInOut(uwTri(v));\n}\nfloat uwCubic(float v){\n    return cubicInOut(uwTri(v));\n}\nfloat uwQuartic(float v){\n    return quarticInOut(uwTri(v));\n}\nfloat uwQintic(float v){\n    return qinticInOut(uwTri(v));\n}\nfloat uwExponential(float v){\n    return exponentialInOut(uwTri(v));\n}\nfloat uwCircular(float v){\n    return circularInOut(uwTri(v));\n}\nfloat uwElastic(float v){\n    return elasticInOut(uwTri(v));\n}\nfloat uwBack(float v){\n    return backInOut(uwTri(v));\n}\nfloat uwBounce(float v){\n    return bounceInOut(uwTri(v));\n}\n\nfloat swQuadratic(float v){\n    return u2s(uwQuadratic(v));\n}\nfloat swCubic(float v){\n    return u2s(uwCubic(v));\n}\nfloat swQuartic(float v){\n    return u2s(uwQuartic(v));\n}\nfloat swQintic(float v){\n    return u2s(uwQintic(v));\n}\nfloat swExponential(float v){\n    return u2s(uwExponential(v));\n}\nfloat swCircular(float v){\n    return u2s(uwCircular(v));\n}\nfloat swElastic(float v){\n    return u2s(uwElastic(v));\n}\nfloat swBack(float v){\n    return u2s(uwBack(v));\n}\nfloat swBounce(float v){\n    return u2s(uwBounce(v));\n}\n\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r){\n    //vec2 u = max(vec2(r + b,r + -a), vec2(0));\n\t//return min(-r, max (b, -a)) + length(u);\n\tr*=1.35;\n    a = -a;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return max( a, b ) + h*h*h*r*(1.0/6.0);\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// iYOYi lib: end\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 2.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n    if(length(n)<-1.)break;\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if(t<-1.)break;\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -.5, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-1,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(bool(CURVATURE)){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(METAL)){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(bool(RED_WAX)){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.05, 0.015, 0.0);\\\n                vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 290, 328, 328, 651], [653, 653, 694, 694, 850], [852, 852, 870, 870, 1241]], "test": "untested"}
{"id": "NlSyzd", "name": "Surface of Revolution", "author": "wyatt", "description": "Draw an SDF and make it turn. Like making pottery or something", "tags": ["sdf", "revolution"], "likes": 19, "viewed": 417, "published": 3, "date": "1650076627", "time_retrieved": "2024-07-30T16:53:45.293758", "image_code": "float map (vec3 p) {\n    vec2 u = vec2(length(p.xz),.5*p.y);\n    u = u*R.y*0.5+0.5*R;\n    return A(u).x/R.x-.001;\n    \n   \n}\n\nvec3 norm (vec3 p) {\n    vec3 e = vec3(1e-3,0,0);\n    return normalize(vec3(\n        map(p+e.xyz)-map(p-e.xyz),\n        map(p+e.zxy)-map(p-e.zxy),\n        map(p+e.yzx)-map(p-e.yzx)\n    ));\n}\n\nMain {\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,1));\n    vec3 p = vec3(0,0,-3);\n    p.yz *= ei(.75*sin(.5*iTime));\n    d.yz *= ei(.75*sin(.5*iTime));\n    Q = vec4(0);\n    for (float x = 0.; x < 180.; x++) {\n        float l = map(p);\n        p += d*l;\n        if (l < .002) Q.xyz = .5-.5*norm(p);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n    Q = A(U);\n    if (iFrame < 1) Q = vec4(length(U-.5*R));\n    \n    if (iMouse.z>0.) {\n        vec4 b = B(U);\n        Q = vec4(min(Q.x,segment(U,b.xy,b.zw)));\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat segment (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}", "buffer_b_code": "Main {\n    Q = B(U);\n    if (iMouse.z>0.) {\n        if (Q.x<R.x) {\n            Q = vec4(Q.zw,iMouse.xy);\n        }\n        else Q = iMouse.xyxy;\n    }\n    else Q = vec4(1e9);\n    if (Q.x<.5*R.x) Q.x = R.x-Q.x;\n    if (Q.z<.5*R.x) Q.z = R.x-Q.z;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 124], [126, 126, 146, 146, 316]], "test": "untested"}
{"id": "NtBczd", "name": "Tater @Revision Shader Jam", "author": "Tater", "description": "Can't be bothered to figure out the fft right now, I will add it later. ", "tags": ["raymarching", "revision", "jam", "shaderjam"], "likes": 13, "viewed": 367, "published": 3, "date": "1650071549", "time_retrieved": "2024-07-30T16:53:46.047742", "image_code": "#define STEPS 64.0\n#define MDIST 1500.0\n#define pi 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define time mod(iTime,300.)\nfloat h21(vec2 a){\n  return fract(sin(dot(a,vec2(12.9898,78.233)))*43644.45345);\n  \n}\nfloat dibox(vec3 p, vec3 b, vec3 rd){\n  vec3 dir = sign(rd)*b*0.5;\n  vec3 rc = (dir-p)/rd;\n  return min(rc.x,rc.z)+0.1;\n}\nfloat dibox2(vec3 p, vec3 b, vec3 rd){\n  vec3 dir = sign(rd)*b*0.5;\n  vec3 rc = (dir-p)/rd;\n  return (rc.z)+0.1;\n}\nfloat box(vec3 p, vec3 b){\n  vec3 q = abs(p)-b;\n  return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat lim(float p, float s, float lima, float limb){\n  return p-s*clamp(round(p/s),lima,limb);\n  \n}\nvec3 spiral(vec3 p, float R){\n  p.xz*=rot(p.y/R);\n  vec2 s = sign(p.xz);\n  p.xz=abs(p.xz)-R*0.5;\n  p.xz*=rot(time*pi/3.);\n  float poy = p.y;\n  p.y=0.;\n  p.yz*=rot(mix(0.,pi/4.,1./(R*0.5+1.5)))*-sign(s.x*s.y);\n  p.y=poy;\n  return p;\n}\nfloat torus(vec3 p, vec2 q){\n  return length(vec2(length(p.xz)-q.x,p.y))-q.y;\n  \n}\nfloat anim = 0.;\nvec3 rdo = vec3(0);\nvec3 glow = vec3(0);\nvec2 map(vec3 p){\n  vec3 rd2 = rdo;\n\n  float speed = 70.;\n  \n  float rotation = tanh(sin(time*2.)*2.)*0.002;\n   if(anim>0.5){\n  p.xy*=rot(p.z*rotation);\n  rd2.xy*=rot(p.z*rotation);\n  }\n  float rotation2 = tanh(cos(time*2.)*5.)*0.001;\n  if(anim>0.5)\n    rotation2 =0.0005;\n    p.zy*=rot(p.z*rotation2);\n    rd2.zy*=rot(p.z*rotation2);\n    vec3 po2 = p;\n\n  vec2 a = vec2(0);\n  p.z+=speed*time;\n    vec3 po = p;\n\n  float m2 =100.;\n  p.y+=m2/2.;\n  p.y = pmod(p.y,m2);\n  float bsize = 16.;\n  float m = 20.+anim*4.;\n  \n  vec2 id = floor(p.xz/m);\n  \n  p.xz = pmod(p.xz,m);\n  float sideBox = 12.;\n  //p.x = lim(p.x-m/2,m,-sideBox/2,sideBox/2);\n  \n  p.y+=tanh(sin(time+floor(h21(id)*pi*(8.-anim*4.)))*8.)*(40.+anim*30.);\n  a.x = box(p,vec3(bsize*0.5,4.+anim*8.,bsize*0.5))-0.3;\n  vec3 glowCol = vec3(0.8,0.7,0.2)*(64./STEPS)*0.8;\n  glowCol.xy*=rot(sin(time)*0.5+0.5+h21(id)*2.-1.);\n  glow+=exp(-a.x)*glowCol*0.1;\n  \n // if(abs(id.x)<sideBox/2+1) \n  a.x = min(a.x,dibox(p,vec3(m),rd2));\n // else\n  //a.x = min(a.x,dibox2(p,vec3(m),rd2));\n  \n  p = po2;\n  p.zy*=rot(pi/2.);\n  vec2 b = vec2(1);\n  //p.xy = abs(p.xy)-20;\n  //p.x = abs(p.x)-40;\n  p = spiral(p,110. /*+ texture(texFFTSmoothed,0.1).x*900*/);\n  p = spiral(p,10.);\n // p = spiral(p,15);\n  //p = spiral(p,8);\n\n  //p = spiral(p,10);\n  //p = spiral(p,5);\n\n  b.x = length(p.xz)-2.;\n  b.x*=0.7;\n  glow+=exp(-b.x)*vec3(0.8,0.7,0.2)*0.1;\n\n  a.x = min(a.x,b.x);\n  p = po;\n  float m3 = 40.;\n  float id3 = floor(p.z/m3);\n  p.z = pmod(p.z,m3);\n  b.x = torus(p.xzy,vec2(134./*+texture(texFFTSmoothed,mod(id3,3.)*0.1).x*1000.*/,5.));\n  \n  glow+=exp(-b.x)*glowCol*0.1;\n  \n\n  a.x = min(a.x,b.x);\n\n  return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1.);\n  \n  anim = sin(time*0.4)*0.5+0.5;\n  if(anim>0.7)\n    anim = 1.;\n    else anim = 0.;\n  \n  vec3 col = vec3(0);\n  vec3 ro = vec3(0,0,-10)*3.;\n  if(anim>0.9){\n    ro = vec3(0,40,-50)*8.;\n  }\n  vec3 lk = vec3(0,0,0);\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = normalize(f*(0.7)+uv.x*r+uv.y*cross(f,r));\n  rdo = rd;\n  vec3 p = ro;\n  vec2 d = vec2(0);\n  float rl = 0.;\n  float shad = 0.;\n  \n  for(float i = 0.; i <STEPS; i++){\n    p = ro+rd*rl;\n    d = map(p);\n    rl+=d.x;\n    if(rl>MDIST){\n      break;\n    }\n  }\n\n  //col = vec3(shad);\n  col+=glow*0.25;\n  \n  col = pow(col,vec3(0.45));\n    fragColor = vec4(col,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 196, 196, 263], [264, 264, 301, 301, 385], [386, 386, 424, 424, 500], [501, 501, 527, 527, 608], [609, 609, 661, 661, 708], [709, 709, 738, 738, 942], [943, 943, 971, 971, 1025], [1084, 1084, 1101, 1101, 2728], [2730, 2730, 2787, 2787, 3579]], "test": "untested"}
{"id": "NlBcRd", "name": "Jansen Blueprint", "author": "blackle", "description": "shader showdown 2022 quarterfinals\n\nUPDATE: added AA", "tags": ["straandbeast"], "likes": 71, "viewed": 1303, "published": 3, "date": "1650064767", "time_retrieved": "2024-07-30T16:53:47.261497", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//antialising\n#define AA_SAMPLES 1\n\nfloat t = 0.;\nfloat ot = 0.;\n#define ro(r) mat2(cos(r),-sin(r),sin(r),cos(r))\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat doodad(vec3 p, vec2 a, vec2 b, float s) {\n  s/=2.;\n  float wire = max(min(length(p.yz-a)-.04, length(p.yz-b)-.04),abs(p.x)-s-.04);\n  return min(max(linedist(p.yz,a,b)-.05,abs(abs(p.x)-s)-.02),wire);\n}\n\nvec2 poop(vec2 a, vec2 b, float d1, float d3, float side) {\n  float d2 = distance(a,b);\n  float p = (d1*d1+d2*d2-d3*d3)/d2/2.;\n  float o = side*sqrt(d1*d1-p*p);\n  return a + mat4x2(-p,-o,o,-p,p,o,-o,p)*vec4(a,b)/d2;\n}\n\nfloat scene(vec3 p) {\n  float dist = 1e4;\n  vec2 D = ro(ot*7.)*vec2(.15,0);\n  p.x-=0.025;\n  {\n  float side = 1.;\n  vec2 M = vec2(-.4*side,0);\n  vec2 a = poop(M,D,.4,.6,side);\n  vec2 b = poop(M,D,.4,.6,-side);\n  vec2 c = poop(M,a,.4,.5,side);\n  vec2 d = poop(b,c,.35,.4,side);\n  vec2 e = poop(b,d,.4,.6,side);\n  \n  dist = min(dist, doodad(p,D,a,.0));\n  dist = min(dist, doodad(p,M,a,.1));\n  dist = min(dist, doodad(p,D,b,.2));\n  dist = min(dist, doodad(p,M,b,.3));\n  dist = min(dist, doodad(p,b,d,.0));\n  dist = min(dist, doodad(p,M,c,.0));\n  dist = min(dist, doodad(p,c,d,.1));\n  dist = min(dist, doodad(p,b,e,.1));\n  dist = min(dist, doodad(p,c,a,.2));\n  dist = min(dist, doodad(p,d,e,.2));\n  }\n  p.x+=0.05;\n  {\n  float side = -1.;\n  vec2 M = vec2(-.4*side,0);\n  vec2 a = poop(M,D,.4,.6,side);\n  vec2 b = poop(M,D,.4,.6,-side);\n  vec2 c = poop(M,a,.4,.5,side);\n  vec2 d = poop(b,c,.35,.4,side);\n  vec2 e = poop(b,d,.4,.6,side);\n  \n  dist = min(dist, doodad(p,D,a,.0));\n  dist = min(dist, doodad(p,M,a,.1));\n  dist = min(dist, doodad(p,D,b,.2));\n  dist = min(dist, doodad(p,M,b,.3));\n  dist = min(dist, doodad(p,b,d,.0));\n  dist = min(dist, doodad(p,M,c,.0));\n  dist = min(dist, doodad(p,c,d,.1));\n  dist = min(dist, doodad(p,b,e,.1));\n  dist = min(dist, doodad(p,c,a,.2));\n  dist = min(dist, doodad(p,d,e,.2));\n  }\n  return dist;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\nfloat bpm = 127.;\n\nvec3 pixel_color(vec2 uv) {\n  \n  uv += texture(iChannel0,uv*2.).x*0.0025;\n  \n  float m = 2.*60./bpm;\n  float rng = floor(m*iTime)/m;\n  float w = iTime - rng;\n  t =rng + mix(pow( w,3.),w,.8);\n  ot =t ;\n  t += fract(cos(rng)*456.)*3.;\n  \n  vec3 cam = normalize(vec3(1.8+cos(rng*45.)*.5,uv));\n  vec3 init = vec3(-3,cos(rng*445.)*.3,-.2);\n  \n  float ry = sin(cos(rng*64.)*100.)*.3;\n  cam.xz*=ro(ry);\n  init.xz*=ro(ry);\n  float rz = t*.5 + cos(rng*64.)*100.;\n  cam.xy*=ro(rz);\n  init.xy*=ro(rz);\n  \n  vec3 p = init;\n  bool hit = false;\n  bool trig = false;\n  for (int i = 0; i < 50 && !hit; i++) {\n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    if (!trig) trig = dist<0.005;\n    p += cam*dist;\n  }\n  float v = 1.-dot(uv,uv)*.5;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fact = dot(cam,r);\n  vec2 grid = abs(asin(sin(uv*40.)));\n  float g =smoothstep(1.52,1.58,max(grid.x,grid.y));\n  float f = smoothstep(.8,.85,fact) + smoothstep(.4,.45,fact)*smoothstep(.5,1.,cos(uv.y*1000.));\n  vec3 fragColor = min(vec3(1),hit ? vec3(f) : vec3(trig?1.:g))*.8;\n  fragColor.xyz += texture(iChannel1,clamp(ro(ot)*(uv*6.+vec2(4.2,2))+.5,0.,1.)).xyz;\n  fragColor*=v;\n  return fragColor*fragColor;\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    for (int i = 0; i < AA_SAMPLES; i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n        fragColor += vec4(pixel_color(uv2), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//from https://www.shadertoy.com/view/4sKyRK\nfloat distanceToBottleCurve(vec2 point) {\n    return point.y-0.1*sin(point.x*2.5 + 0.6) + 0.05*sin(5.0*point.x) + 0.04*sin(7.5*point.x);\n}\nbool texturee(vec2 uv) {\n    float ang = atan(uv.y, uv.x);\n    float len = floor(length(uv)*10.0);\n    bool val = len == 2. || len == 6. || len == 9.;\n    if (len == 3. || len == 4. || len == 5. || len == 8. || len == 10.) {\n        val = distanceToBottleCurve(vec2(ang+len,0.0))*7.99 > cos(len*7.99);\n    }\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    //I would make a better revision logo but I am too tired :(\n    fragColor = vec4(1.0,91.0,188.0,1.0)/255.;\n    float rad1 = abs(floor(atan(uv.x,uv.y)/2.)*.04);\n    if (texturee(uv*2.5)) {\n        fragColor = vec4(255.0,214.0,0.0,1.0)/255.;\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBcRd.jpg", "access": "api", "license": "cc0-1.0", "functions": [[309, 309, 349, 349, 436], [438, 438, 485, 485, 644], [646, 646, 705, 705, 863], [865, 865, 886, 886, 2197], [2199, 2199, 2218, 2218, 2328], [2348, 2348, 2375, 2375, 3546], [3548, 3548, 3569, 3569, 3628], [3630, 3630, 3687, 3687, 3976]], "test": "untested"}
{"id": "NtBczt", "name": "tablecloth", "author": "gk_per", "description": "first shader", "tags": ["noob"], "likes": 0, "viewed": 147, "published": 3, "date": "1650060156", "time_retrieved": "2024-07-30T16:53:48.216943", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*tan(iTime+uv.yyx+vec3(0,4,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "7tjyzc", "name": "Color Automata", "author": "SnoopethDuckDuck", "description": "Press r to reset\n\nChange 0.4 * fragCoord in \"Image\" for zoom\n\nYou can make lots of interesting patterns with this one - this is just one example.\n\nBuffer B stolen from fork, and a few other things stolen from other places", "tags": ["feedback", "cellularautomata"], "likes": 11, "viewed": 243, "published": 3, "date": "1650049880", "time_retrieved": "2024-07-30T16:53:49.396788", "image_code": "vec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(0.4 * fragCoord), 0 ).rgb;\n    col += 0.5;\n    col *= 2.5 * col * col;\n    vec3 e = vec3(0.5);\n    vec3 col2 = pal(0.75 + 0.5 * length(col), col,  min(col,1.-col), e, 2.5 * col);\n    vec3 col3 = pal(-0.25 + 0.5 * length(col), col, min(col,1.-col), e, 0.6 * vec3(1));\n    col = mix(col, col2, step(0. * iResolution.x, fragCoord.x));\n    //col = mix(col, col3, step(fragCoord.x, 0.5 * iResolution.x));\n    \n    fragColor.rgb = vec3(col);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec3 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n   // return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n   return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        vec2 f = fragCoord + 0.01 * iTime; \n        float o = 0.01;\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        float s = step(abs(length(uv)-0.3), 0.005);\n        fragColor.rgb = (vec3(h21(f-o), h21(f), h21(f+o)) - 0.5);\n        return;\n    }\n    \n    // center cell\n    vec3 e = Cell(px); \n\n    // neighbour cells\n    vec3 t = Cell(px + ivec2(0,-1));\n    vec3 b = Cell(px + ivec2(0,1));\n    vec3 l = Cell(px + ivec2(-1,0));\n    vec3 r = Cell(px + ivec2(1,0));   \n\n    vec3 h = 0.5 * (l+r);\n    vec3 v = 0.5 * (t + b);  \n    vec3 k = max(h,v); // \"average\" of neighbours\n   // vec3 k = 0.5 *(h+v);\n    k = 0.25 * (l + r + t + b);\n    \n    // difference between center and average\n    vec3 j = e - k;\n\n\n    float a = 0.;\n    // try length(e), length(k), length(1.5 * j)\n    vec3 le = ((1.-a) + a * cos(3.14159 * e)) * length(e);//(length(e) > 0.5) ? length(e) : length(k);\n    vec3 se = sign(e);\n   \n    // e.g. 2., 2.5, higher values have less effect\n    // try changing sc with \"k = erot(...)\" commented out\n    float sc = 32.;\n    \n    e = erot(e, normalize(k), 3.14159/sc);\n    k = erot(k, normalize(e), 3.14159/(1.5*sc) + 0. *(j.x+j.y+j.z));\n    \n    // most important part. se lets it grow\n    // le * normalize() so e stays in -0.5,0.5 sphere\n    e = -0.005 * se + le * mix(normalize(k), normalize(e), 0.5 * normalize(j));\n    \n    //e = fract((e+0.4975)) - 0.5;\n    e = clamp(e,-0.5, 0.5);\n    \n    // weird box patterns\n    //e *= 100.;\n\n\tfragColor = vec4( e, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    else\n        fragColor.rgb = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 109], [111, 111, 168, 168, 650]], "test": "untested"}
{"id": "7tjyz3", "name": "Flag of Hungary", "author": "akoskovacs", "description": "Simple image of the flag of Hungary", "tags": ["flag", "image"], "likes": 0, "viewed": 160, "published": 3, "date": "1650039606", "time_retrieved": "2024-07-30T16:53:50.582618", "image_code": "const vec3 red = vec3(0.8, 0, 0);\nconst vec3 white = vec3(1, 1, 1);\nconst vec3 green = vec3(0, 0.7, 0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0, 0, 0); \n    if (uv.y <= 0.3333) {\n        col = green;\n    } else if (uv.y <= 0.66666) {\n        col = white;\n    } else {\n        col = red;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 162, 212, 482]], "test": "untested"}
{"id": "NtjcRc", "name": "the sad fate of sharpness in CG", "author": "FabriceNeyret2", "description": "on still image you can reach the maximum screen sharpness.\nBut if you want to allow free trans, rot, scal, persp, then antialiasing limit you to half resol.\nTop: image Bot: strips = 1 or 2 pix\nLeft: exact match. Mid: 1/2 pix offset.  Right: offs= fract(t)", "tags": ["aliasing", "nyquist", "sharpness", "shannon"], "likes": 6, "viewed": 439, "published": 3, "date": "1650030864", "time_retrieved": "2024-07-30T16:53:51.451295", "image_code": "// (channel, pos, offset, scaling )\n#define T(ch,u, ofs,s)  texture(ch,  ( (u)*s + ofs )   \\\n                                    / vec2( textureSize(ch,0) ) ) \n                                   \nvoid mainImage( out vec4 O, vec2 u )\n{\n    u.y = mod(u.y, 400.);\n    if ( u.y > 50. )                                // top: image\n        O =   u.x < 180. ? T(iChannel0, u, 0., 2.)                         // precise mapping to pixels\n            : u.x < 360. ? T(iChannel0, u-vec2(180,0),.5, 2. )             // offset = 1/2 pixel\n                         : T(iChannel0, u-vec2(360,0), fract(iTime), 2. ); // offset = fract(time)\n    else                                            // bottom: dense strips\n        O =   u.x < 180. ? T(iChannel1, u, 0., 1.)\n            : u.x < 360. ? T(iChannel1, u-vec2(180,0),.5, 1. )\n                         : T(iChannel1, u-vec2(360,0), fract(iTime), 1. ),\n         O = pow(O, vec4(1./2.2) );\n\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// strip texture.  one band of 1 pixel width black/white, one band of 2 pixel width black/white \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float x = u.x-.5;\n    O = vec4( u.y > 25. ? mod(x,2.) : step(2.,mod(x,4.) ) );\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 234, 234, 931]], "test": "untested"}
{"id": "7t2yzK", "name": "Volume Scattering by LinusDev", "author": "Pro_Coder", "description": "Volume Scattering in \"real time\"", "tags": ["volumescattering"], "likes": 2, "viewed": 309, "published": 3, "date": "1650021874", "time_retrieved": "2024-07-30T16:53:52.463588", "image_code": "\n\nfloat sdfBox(vec3 pos, vec3 center, vec3 size){\n    pos -= center;\n    vec3 d = abs(pos) - size*.5;\n    float m = (vmax(d));\n    return max(length(min(sign(d) + vec3(1.), 1.) * d), abs(m)) * sign(m);\n}\n\nfloat sdfSphere(vec3 pos, vec3 center, float r) {\n    pos -= center;\n    return length(pos) - r;\n}\n\nvoid mmin(inout float dis, float b, inout uint id, uint idB, uint ignoreId) {\n    if(dis < b || ignoreId == idB) return;\n    dis = b;\n    id = idB;\n}\n\nvoid mmin(inout float dis, float b, inout uint id, uint idB, uint ignoreId, uint inverseId) {\n    if(idB == inverseId) b = -b;\n    if(dis < b || ignoreId == idB) return;\n    dis = b;\n    id = idB;\n}\n\nstruct Ray {\n    vec3 o;//origin\n    vec3 d;//direction\n};\n\nstruct Hit {\n    vec3 pos;\n    float dis;\n    uint id;\n    vec3 color;  \n    Ray ray;\n};\n\n\n\n\nfloat getDistance(vec3 pos, out uint hitId, uint ignoreId){\n    float dis = RENDER_DISTANCE;\n    \n    mmin(dis, sdfSphere(pos, LIGHT_SOURCE_POSITION, LIGHT_SOURCE_RADIUS), hitId, LIGHT_SOURCE_ID, ignoreId);\n    mmin(dis, abs(pos.y+0.1)-0.1, hitId, 2u, ignoreId);\n    mmin(dis, sdfBox(pos, BOX_POSITION, BOX_SIZE), hitId, 3u, ignoreId);\n    mmin(dis, sdfBox(pos, VOLUME_POSITION, VOLUME_SIZE), hitId, 4u, ignoreId);\n    \n    return dis;\n}\n\nfloat getDistanceInVolume(vec3 pos, out uint hitId, uint ignoreId){\n    float dis = RENDER_DISTANCE;\n    \n    mmin(dis, sdfSphere(pos, LIGHT_SOURCE_POSITION, LIGHT_SOURCE_RADIUS), hitId, LIGHT_SOURCE_ID, ignoreId);\n    mmin(dis, abs(pos.y+0.1)-0.1, hitId, 2u, ignoreId);\n    mmin(dis, sdfBox(pos, BOX_POSITION, BOX_SIZE), hitId, 3u, ignoreId);\n    mmin(dis, sdfBox(pos, VOLUME_POSITION, VOLUME_SIZE), hitId, 4u, ignoreId, 4u);\n    \n    return dis;\n}\n\n//only for the getNormal function. Ignore the Volume, so that normal calculation for objects inside the \n//Volume work too.\nfloat getDistance(vec3 pos){\n    uint a;\n    return getDistance(pos, a, 4u);\n}\n\n\n\n\n/*\n * Normal function by Inigo Quilez: https://iquilezles.org/articles/normalsSDF/\n*/\nconst vec2 e = vec2(.01, 0);\nvec3 getNormal(vec3 p){\n \tfloat d = getDistance(p);\n    \n    vec3 n = d - vec3(getDistance(p - e.xyy), getDistance(p - e.yxy), getDistance(p - e.yyx));\n    return normalize(n);\n}\n\n\nconst vec3 colors[] = vec3[](\n            vec3(0.0),\n            vec3(1.),\n            vec3(.7, .1, 1.),\n            vec3(1., 0., .0)\n            );\nvec3 color(vec3 pos, uint id) {\n    return colors[id]/20.;\n}\n\n\n\nstruct Path {\n    vec3 pos;\n    vec3 dir;\n    float dis;\n    uint hitId;\n    vec3 multiply;\n    vec3 add;\n};\n\nvec3 attenuation(float dis, Path path) {\n    return exp(-(dis) * (ABSOPRTION_C(path.pos, path.dir) + SCATTERING_C(path.pos, path.dir)));\n}\n\nvec3 volumeLightMarch(vec3 inPos, out vec3 ligthDir) { \n    ligthDir = normalize(LIGHT_SOURCE_POSITION - inPos);\n    \n    \n    Path path = Path(inPos, ligthDir, 0.0, NO_HIT_ID, vec3(1.0), vec3(0.0));    \n    for(uint i = 0u; i < MAX_STEPS; i++){\n        #ifdef CONSTANT_ANT\n            float dis = getDistanceInVolume(path.pos, path.hitId, 0u);\n        #else\n            float dis = min(VOLUME_MAX_STEP_DISTANCE, getDistanceInVolume(path.pos, path.hitId, 0u));\n        #endif\n        \n        path.dis += dis;\n        path.pos = inPos + path.dir * path.dis;\n        \n        if(dis < MIN_DISTANCE){\n            //Processes\n            path.multiply *= attenuation(path.dis, path);\n            path.add += ADD_EMISSION(path.pos, path.dir) * path.dis * path.multiply;\n            \n            if(path.hitId == LIGHT_SOURCE_ID) {\n                return (LIGHT_SOURCE_LIGHT) * path.multiply + path.add;\n            } else if(path.hitId != 4u){\n                return vec3(0.);  \n            }\n            \n            \n            break;\n        }\n    }\n    \n    \n    vec3 pos = path.pos;\n    uint id = NO_HIT_ID;\n    float dis = 0.0;\n    \n    for(uint i = 0u; i < MAX_STEPS; i++){\n        float cdis = getDistance(pos, id, 4u);\n        dis += cdis;\n        \n        pos = path.pos + ligthDir * dis;\n        \n        if(cdis < MIN_DISTANCE){\n            if(id == LIGHT_SOURCE_ID) {\n                return (LIGHT_SOURCE_LIGHT) * path.multiply + path.add;\n            }\n            return vec3(0.);  \n        }\n        \n        if(dis > RENDER_DISTANCE) break;\n        \n    }\n    \n    return  vec3(0.,0., 0.);\n}\n\nPath volumeMarch(vec3 inPos, vec3 rayDir, float maxStep, uint ignoreId) {\n    Path path = Path(vec3(0.0), rayDir, MIN_DISTANCE*20., NO_HIT_ID, vec3(1.0), vec3(0.0));\n    path.pos = inPos + path.dir * path.dis;\n    vec3 atten = attenuation(path.dis, path);\n    path.multiply *= atten;\n    path.add += ADD_EMISSION(path.pos, path.dir) * path.dis * atten;   \n    \n    for(uint i = 0u; i < MAX_STEPS; i++){\n        float dis = min(maxStep, getDistanceInVolume(path.pos, path.hitId, ignoreId));\n        \n        path.dis += dis;\n        path.pos = inPos + path.dir * path.dis;\n        \n        //Processes\n        path.multiply *= attenuation(dis, path);\n        path.add += ADD_EMISSION(path.pos, path.dir) * dis*path.multiply;\n        vec3 lightDir;\n        vec3 light = volumeLightMarch(path.pos, lightDir);\n        path.add += light*henyeyGreenstein(HG_G, lightDir, path.dir)*dis*SCATTERING_C(path.pos, path.dir)*path.multiply;\n        \n        \n        if(dis < MIN_DISTANCE){\n            return path;\n        }\n    }\n    \n    return path;\n}\n\nvec3 lightMarch(vec3 inPos, uint ignoreId) {\n    if(ignoreId == NO_HIT_ID) return vec3(1.); //make light not apply to the sky\n    vec3 ligthDir = normalize(LIGHT_SOURCE_POSITION - inPos);\n    float lightIntensity = dot(getNormal(inPos), ligthDir);\n    \n    if(lightIntensity <= 0.0) return vec3(0.0);\n    \n    Path path = Path(vec3(0.), vec3(0.), 0., 0u, vec3(1.), vec3(0.0));\n    vec3 pos = inPos;\n    uint id = NO_HIT_ID;\n    float dis = 0.0;\n    \n    for(uint i = 0u; i < MAX_STEPS; i++){\n        float cdis = getDistance(pos, id, ignoreId);\n        dis += cdis;\n        \n        pos = inPos + ligthDir * dis;\n        \n        if(cdis < MIN_DISTANCE){\n            if(id == LIGHT_SOURCE_ID) {\n                return (LIGHT_SOURCE_LIGHT * (lightIntensity)) * path.multiply + path.add;\n            } else if(id == 4u) {\n                //return volumeLightMarch(pos, ligthDir);\n                #ifdef CONSTANT_ANTs\n                    path = volumeMarch(pos, ligthDir, 1000., ignoreId);\n                #else\n                    path = volumeMarch(pos, ligthDir, VOLUME_MAX_STEP_DISTANCE, ignoreId);\n                #endif\n                \n                if(path.hitId == LIGHT_SOURCE_ID) {\n                    return (LIGHT_SOURCE_LIGHT * (lightIntensity)) * path.multiply + path.add;\n                }else if(path.hitId != 4u) {\n                    return vec3(0.0);\n                }\n                \n                ignoreId = 4u;\n                dis += path.dis;\n                pos = inPos + ligthDir * dis;\n                continue;\n            }\n            \n            return vec3(0.0);\n           \n        }\n        \n        if(dis > RENDER_DISTANCE) break;\n        \n    }\n    \n    return vec3(0.0);\n}\n\nvec3 diffuse(vec3 pos, uint hitId, Path path) {\n    return color(pos, hitId) * lightMarch(pos, hitId) * path.multiply + path.add;\n}\n\nHit rayMarch(Ray r, uint ignoreId){\n    \n    Hit hit = Hit(r.o, 0.0, NO_HIT_ID, vec3(0.0), r);\n    Path path = Path(vec3(0.), vec3(0.), 0., 0u, vec3(1.), vec3(0.0));\n    \n    for(uint i = 0u; i < MAX_STEPS; i++){\n        float dis = getDistance(hit.pos, hit.id, ignoreId);\n        hit.dis += dis;\n        \n        hit.pos = r.o + r.d * hit.dis;\n        \n        if(dis < MIN_DISTANCE){\n        \n            if(hit.id == LIGHT_SOURCE_ID){\n                hit.color = LIGHT_SOURCE_LIGHT;\n                return hit;\n            } else if(hit.id == 4u) {\n                path = volumeMarch(hit.pos, r.d, VOLUME_MAX_STEP_DISTANCE, 0u);\n                \n                if(path.hitId != 4u) {\n                    if(path.hitId == LIGHT_SOURCE_ID){\n                        hit.color = LIGHT_SOURCE_LIGHT;\n                        return hit;\n                    }\n                    hit.color = diffuse(path.pos, path.hitId, path);\n                    return hit;\n                }\n                \n                ignoreId = 4u;\n                hit.dis += path.dis;\n                hit.pos = r.o + r.d * hit.dis;\n                continue;\n            }\n            \n            hit.color = diffuse(hit.pos, hit.id, path);\n        \n            return hit;\n        }\n        \n        if(hit.dis > RENDER_DISTANCE) break;\n        \n    }\n    \n    hit.id = NO_HIT_ID;\n    hit.color = diffuse(hit.pos, hit.id, path);\n    return hit;\n}\n\nRay calcRay(vec2 uv, sampler2D varChannel) {\n    vec4 camPosition = GET(varChannel, CAM_POS_TEXEL); //xyz = pos; w = distance to screen\n    vec4 viewDirection = GET(varChannel, VIEW_DIR_TEXEL);\n    \n    //calc ray Direction\n    vec3 screenXVector = cross(viewDirection.xyz, UP_VECTOR);\n    vec3 screenYVector = -cross(viewDirection.xyz, screenXVector);\n\n    vec3 rayDirection = normalize(viewDirection.xyz * camPosition.w\n                    + screenXVector * uv.x + screenYVector  * uv.y);\n                    \n    return Ray(camPosition.xyz, rayDirection);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5) / (iResolution.yy*.5);\n    Hit hit = rayMarch(calcRay(uv, iChannel1), 0u);  \n    fragColor = vec4(hit.color,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n *\n *\n * Volume Scattering\n *\n *\n */\n#define VOLUME_MAX_STEP_DISTANCE 0.05\n\n\n#define CONSTANT_ANT\n\n#ifdef CONSTANT_ANT\n    #define ABSOPRTION_C(POS, DIR) (vec3(0.1))\n    #define SCATTERING_C(POS, DIR) (vec3(0.5))\n    #define ADD_EMISSION(POS, DIR) (vec3(0.1))\n#else\n    #define ABSOPRTION_C(POS, DIR) (vec3(0.0))\n    #define SCATTERING_C(POS, DIR) (noise(iChannel0, POS*.15).rrr*1.5)\n    #define ADD_EMISSION(POS, DIR) (noise(iChannel0, POS*.15).rrr*.4)\n#endif\n\n\n\n#define HG_G 0.0\n\n\n/*\n *\n *\n * World Stuff\n *\n *\n */\n#define UP_VECTOR vec3(0., 1., 0.)\n\n#define CAM_START_POS vec3(0., 3., 4.)\n#define CAM_START_DIS_TO_SCREEN 1.\n#define CAM_START_LOOK_AT_POSITION vec3(0., 3., 0.)\n\n/*\n *\n *\n * Constants\n *\n *\n */\n#define PI 3.14\n#define NO_HIT_ID 0u\n#define RENDER_DISTANCE 100.0\n#define MIN_DISTANCE 0.001\n//#define MAX_STEPS 1000u\n//better max steps by @morimea\n#define MAX_STEPS (1000u+uint(1-min(iFrame+1,1)))\n\n#define BOX_POSITION vec3(sin(iTime), 5., 0.)\n#define BOX_SIZE vec3(0.5)\n\n#define VOLUME_POSITION vec3(0., 3., 0.)\n#define VOLUME_SIZE vec3(4., 5.8, 2.)\n\n//#define LIGHT_SOURCE_POSITION vec3(0., 3.*sin(iTime*.5+PI*.5) + 6., 0.)\n#define LIGHT_SOURCE_POSITION vec3(0., 9., 0.)\n#define LIGHT_SOURCE_RADIUS 0.0\n#define LIGHT_SOURCE_LIGHT (vec3(1., 1. , 1.)*20.)\n#define LIGHT_SOURCE_ID 1u\n\n/*\n *\n *\n * Vars\n *\n *\n */\n#define DO_SAVE(texel) (ivec2(fragCoord) == texel)\n#define GET(buffer, texel) (texelFetch(buffer, texel, 0))\n\n#define CAM_POS_TEXEL   ivec2(0, 0)\n#define VIEW_DIR_TEXEL  ivec2(0, 1)\n\n/*\n *\n *\n * Functions\n *\n *\n */\n \nfloat vmax(vec3 a){\n    return max(a.z, max(a.x, a.y));\n} \n\n//dirLight -> normalized direction to the light source\n//dirRefle -> the reflection direction we care about\nfloat henyeyGreenstein(float g, vec3 dirLight, vec3 dirRefle)\n{\n    return (1.0 - g * g) / (12.56637061436 * pow(1. + g * g - 2. * g * dot(-dirLight, dirRefle), 1.5));\n}\n\nvec4 noise(sampler2D tex, vec3 pos) {\n    return pow(textureLod(tex, pos.xz, 0.0) * textureLod(tex, pos.xy, 0.0) * textureLod(tex, pos.zy, 0.0), vec4(1.3));\n}\n\n\n\n\n\n", "buffer_b_code": "//Keyboard and storage buffer\n\n\n#define MOVE_SPEED 0.1\n\n//Keyboard\n#define NUMBER_OF_KEYS 256.\n#define IS_PRESSED 0.0\n#define ON_PRESS 0.5\n#define BUFFFER_PRESS 1.0\n\n#define KEY_TAB 10./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ENTER 14./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SHIFT 17./NUMBER_OF_KEYS - 1./512.\n#define KEY_CTRL 18./NUMBER_OF_KEYS - 1./512.\n#define KEY_ALT 19./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SPACE 33./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ARROW_LEFT 38./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_UP 39./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_RIGHT 40./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_DOWN 41./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_0 49./NUMBER_OF_KEYS - 1./512.\n#define KEY_1 50./NUMBER_OF_KEYS - 1./512.\n#define KEY_2 51./NUMBER_OF_KEYS - 1./512.\n#define KEY_3 52./NUMBER_OF_KEYS - 1./512.\n#define KEY_4 53./NUMBER_OF_KEYS - 1./512.\n#define KEY_5 54./NUMBER_OF_KEYS - 1./512.\n#define KEY_6 55./NUMBER_OF_KEYS - 1./512.\n#define KEY_7 56./NUMBER_OF_KEYS - 1./512.\n#define KEY_8 57./NUMBER_OF_KEYS - 1./512.\n#define KEY_9 58./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_NUMPAD_0 97./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_1 98./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_2 99./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_3 100./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_4 101./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_5 102./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_6 103./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_7 104./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_8 105./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_9 106./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_GREATER 61./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SS 64./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_A 66./NUMBER_OF_KEYS - 1./512.\n#define KEY_B 67./NUMBER_OF_KEYS - 1./512.\n#define KEY_C 68./NUMBER_OF_KEYS - 1./512.\n#define KEY_D 69./NUMBER_OF_KEYS - 1./512.\n#define KEY_E 70./NUMBER_OF_KEYS - 1./512.\n#define KEY_F 71./NUMBER_OF_KEYS - 1./512.\n#define KEY_G 72./NUMBER_OF_KEYS - 1./512.\n#define KEY_H 73./NUMBER_OF_KEYS - 1./512.\n#define KEY_I 74./NUMBER_OF_KEYS - 1./512.\n#define KEY_J 75./NUMBER_OF_KEYS - 1./512.\n#define KEY_K 76./NUMBER_OF_KEYS - 1./512.\n#define KEY_L 77./NUMBER_OF_KEYS - 1./512.\n#define KEY_M 78./NUMBER_OF_KEYS - 1./512.\n#define KEY_N 79./NUMBER_OF_KEYS - 1./512.\n#define KEY_O 80./NUMBER_OF_KEYS - 1./512.\n#define KEY_P 81./NUMBER_OF_KEYS - 1./512.\n#define KEY_Q 82./NUMBER_OF_KEYS - 1./512.\n#define KEY_R 83./NUMBER_OF_KEYS - 1./512.\n#define KEY_S 84./NUMBER_OF_KEYS - 1./512.\n#define KEY_T 85./NUMBER_OF_KEYS - 1./512.\n#define KEY_U 86./NUMBER_OF_KEYS - 1./512.\n#define KEY_V 87./NUMBER_OF_KEYS - 1./512.\n#define KEY_W 88./NUMBER_OF_KEYS - 1./512.\n#define KEY_X 89./NUMBER_OF_KEYS - 1./512.\n#define KEY_Y 90./NUMBER_OF_KEYS - 1./512.\n#define KEY_Z 91./NUMBER_OF_KEYS - 1./512.\n\n//example isKey(KEY_A, IS_PRESSED)\nbool isKey(float checkKey, float type, sampler2D channel){\n    return texture( channel, vec2(checkKey, type)).r > 0.0;\n}\n\n#define KEYBOARD_CHANNEL iChannel0\n#define BACK_BUFFER_CHANNEL iChannel1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n     \n    if(iFrame > 0) {\n        if(DO_SAVE(CAM_POS_TEXEL)){\n            vec4 pos = GET(BACK_BUFFER_CHANNEL, CAM_POS_TEXEL);\n            vec4 vdir = GET(BACK_BUFFER_CHANNEL, VIEW_DIR_TEXEL);\n            vec2 v = normalize(vdir.xz);\n            vec2 t = normalize(cross(UP_VECTOR, vdir.xyz)).xz;\n    \n            float speed = MOVE_SPEED;\n            \n            //move cam\n            if(isKey(KEY_W, IS_PRESSED, KEYBOARD_CHANNEL)){//forward\n                pos.xz += v * speed;\n            }\n            if(isKey(KEY_S, IS_PRESSED, KEYBOARD_CHANNEL)){//backward\n                pos.xz -= v * speed;\n            }\n            if(isKey(KEY_A, IS_PRESSED, KEYBOARD_CHANNEL)){//left\n                pos.xz += t * speed;\n            }\n            if(isKey(KEY_D, IS_PRESSED, KEYBOARD_CHANNEL)){//right\n                pos.xz -= t * speed;\n            }\n            if(isKey(KEY_SHIFT, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y -= 1.0 * speed;\n            }\n            if(isKey(KEY_SPACE, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y += 1.0 * speed;\n            }\n            \n            //Zoom\n            if(isKey(KEY_C, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 1.052631578947368;\n            }\n            if(isKey(KEY_X, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 0.95;\n            }\n            \n            fragColor = pos;\n            return;\n            \n        }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec4 viewDirection = GET(BACK_BUFFER_CHANNEL, VIEW_DIR_TEXEL);\n            \n            if(iMouse.z > 0.0){\n                float angleXZ = atan(viewDirection.x, viewDirection.z);\n                angleXZ -= ((iMouse.x-iResolution.x*.5)/iResolution.x)*PI*0.05; \n                viewDirection.xyz = normalize(vec3(sin(angleXZ), viewDirection.y, cos(angleXZ)));\n            }\n            fragColor = viewDirection;\n            return;    \n        }\n         \n    }else{\n         //initial values\n         if(DO_SAVE(CAM_POS_TEXEL)){\n            fragColor = vec4(CAM_START_POS, CAM_START_DIS_TO_SCREEN);\n\n         }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec3 viewDirection = normalize(CAM_START_LOOK_AT_POSITION - CAM_START_POS);\n            fragColor = vec4(viewDirection, 1.0);\n\n         }    \n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2yzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 49, 49, 203], [205, 205, 254, 254, 303], [305, 305, 382, 382, 454], [456, 456, 549, 549, 654], [809, 809, 868, 868, 1246], [1248, 1248, 1315, 1315, 1697], [1699, 1823, 1851, 1851, 1901], [2021, 2021, 2044, 2044, 2199], [2351, 2351, 2382, 2382, 2411], [2525, 2525, 2565, 2565, 2663], [2665, 2665, 2719, 2719, 4270], [4272, 4272, 4345, 4345, 5313], [5315, 5315, 5359, 5359, 7028], [7030, 7030, 7077, 7077, 7161], [7163, 7163, 7198, 7198, 8586], [8588, 8588, 8632, 8632, 9148], [9153, 9153, 9210, 9210, 9372]], "test": "untested"}
{"id": "Nl2cR3", "name": "Liquid Fuzz", "author": "tillmanjex", "description": "Undulating liquid. A little fuzzy.", "tags": ["abstract", "ambient", "liquid"], "likes": 3, "viewed": 289, "published": 3, "date": "1650021527", "time_retrieved": "2024-07-30T16:53:53.244502", "image_code": "// Modified version of: https://www.shadertoy.com/view/4sjXRG\n\nfloat ltime;\n\nfloat noise(vec2 p)\n{\n  return cos(p.x*1.5) * sin(p.y*(1.5 + sin(ltime/11.))) + .2; \n}\n\nmat2 rotate(float angle)\n{\n    return mat2(0.0, -2.0, sin(1.0), 0.0);\n  //return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\nfloat fbm(vec2 p)\n{\n  p *= 1.0;\n  float f = 0.0;\n  float amp = .5;\n  for( int i = 0; i < 3; i++) {\n    mat2 modify = rotate(ltime/50. * float(i*i));\n    f += amp*noise(p);\n    p = modify * p;\n    p *= 2.;\n    amp /= 2.2;\n  }\n  return f;\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n  q = vec2( fbm(p + vec2(1.)),\n\t    fbm(rotate(.1*ltime)*p + vec2(3.)));\n  r = vec2( fbm(rotate(.2)*q + vec2(0.)),\n\t    fbm(q + vec2(0.)));\n  return fbm(p + 1.*r);\n\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(0.7059, 0.1333, 0.1333, 2.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 3.0 - K.www);\n    return c.z - K.x * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), smoothstep(0.5, 0.9, c.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = fragCoord.xy / iResolution.xy;\n  ltime = iTime;\n  float ctime = iTime + fbm(p/8.)*40.;\n  float ftime = fract(ctime/6.);\n  ltime = floor(ctime/6.) + (1.-cos(ftime*3.1415)/2.);\n  ltime = ltime*6.;\n  vec2 q;\n  vec2 r;\n  float f = pattern(p, q, r);\n  vec3 col = hsv2rgb(vec3(q.x/10. + ltime/100. + .4, abs(r.y)*3. + .1, r.x + f));\n  float vig = 1. - pow(4.*(p.x - .5)*(p.x - .5), 10.);\n  vig *= 1. - pow(4.*(p.y - .5)*(p.y - .5), 10.);\n  fragColor = vec4(col*vig,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2cR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 98, 98, 163], [165, 165, 191, 191, 302], [305, 305, 324, 324, 543], [545, 545, 592, 592, 759], [761, 761, 783, 783, 977], [979, 979, 1036, 1036, 1513]], "test": "untested"}
{"id": "Nl2cDz", "name": "PathTracing Test", "author": "73begonia", "description": "origin: \n @reinder\nMy study project;", "tags": ["3d", "raymarching", "gi", "global", "pathtracing", "montecarlo"], "likes": 8, "viewed": 489, "published": 3, "date": "1650015945", "time_retrieved": "2024-07-30T16:53:53.999482", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*0.3\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\nconst float eps = 0.0001;\nvec4 lightSphere = vec4(0.);\n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec3 randomVec3(inout float seed)\n{\n    vec3 d;\n    do\n    {\n        d = 2.0f * vec3(hash1(seed), hash1(seed), hash1(seed)) - vec3(1, 1, 1);\n    } while (dot(d, d) > 1.0);\n    return normalize(d);\n}\n\nvec3 randomDirection(vec3 n, inout float seed)\n{\n  return normalize(randomVec3(seed) + n);\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nstruct Material\n{\n  vec3 normal;\n  vec3 color;\n  vec3 emissive;\n  float specularRate;\n  float roughness;\n};\n\nstruct HitResult\n{\n  bool isHit;\n  float distance;\n  vec3 hitPoint;\n  vec3 viewDir;\n  Material material;\n};\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere(vec3 ro, vec3 rd, vec4 sph)\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w * sph.w;\n  float h = b * b - c;\n  if (h < 0.0) return -1.0;\n\n  float s = sqrt(h);\n  float t1 = -b - s;\n  float t2 = -b + s;\n\n  return t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n  return obj.xyz;\n}\n\nfloat iPlane( vec3 ro, vec3 rd, in vec4 pla ) {\n  return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\nHitResult intersect( in vec3 ro, in vec3 rd) {\n  float mint = 1e20;\n  float t = -1.;\n  vec3 normal = vec3(0.);\n\n  HitResult result;\n\t\n  t = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 0., 1., 0.); result.material.color = WHITECOLOR;}\n      \n  t = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 0., 0.,-1.); result.material.color = WHITECOLOR;}\n      \n  t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 1., 0., 0.); result.material.color = GREENCOLOR;}\n      \n  t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( 0., -1., 0.); result.material.color = WHITECOLOR;}\n      \n  t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); \n  if( t>eps && t<mint ) \n      { mint = t; normal = vec3( -1., 0., 0.); result.material.color = REDCOLOR;}\n\n  t = iSphere( ro, rd, vec4( 1.5,1.0, 2.7, 1.0) ); \n  if( t>eps && t<mint ) \n  { \n    mint = t; \n    normal = nSphere( ro+mint*rd, vec4( 1.5,1.0, 2.7,1.0) ); \n    result.material.color = WHITECOLOR;\n    result.material.specularRate = 0.8;\n    result.material.roughness = 0.1;\n  }\n  \n  t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); \n  if( t>eps && t<mint ) \n  { \n    mint = t;\n    normal = nSphere( ro+mint*rd, vec4( 4.0,1.0, 4.0,1.0) ); \n    result.material.color = GREENCOLOR;\n    result.material.specularRate = 0.3;\n    result.material.roughness = 1.0;\n  }\n  \n  t = iSphere( ro, rd, lightSphere ); \n  if( t>eps && t<mint ) \n  { \n    mint = t;  \n    normal = nSphere( ro+mint*rd, lightSphere ); \n    result.material.color = LIGHTCOLOR; \n    result.material.emissive = vec3(1., 0.894, 0.768) * 20.;\n  }\n\t\t\t\t\t  \n  result.isHit = mint > eps && mint < 1e20 ? true : false;\n  \n  if(result.isHit)\n  {\n    result.distance = mint;\n    result.hitPoint = ro + rd * mint;\n    result.material.normal = normal;\n  }\n\n  return result;\t\t\t\t\t  \n}\n\nvec3 PathTracing(vec3 ro, vec3 rd, inout float seed)\n{\n  vec3 tcol = vec3(0.);\n  vec3 fcol = vec3(1.);\n\n  float p = 0.;\n  HitResult result;\n\n  for(int i = 0; i < 8; i++)\n  {\n    result = intersect(ro, rd);\n    if(!result.isHit)\n      return vec3(0);\n    \n    float r = hash1(seed);\n    p = 0.95;\n    if(r > p) \n        fcol = vec3(0.);\n\n    Ray randomRay;\n    randomRay.ro = result.hitPoint;\n    randomRay.rd = randomDirection(result.material.normal, seed);\n\n    float cosine = abs(dot(-rd, result.material.normal));\n\n    r = hash1(seed);\n    if(r < result.material.specularRate)\n    {\n      vec3 ref = normalize(reflect(rd, result.material.normal));\n      randomRay.rd = mix(ref, randomRay.rd, result.material.roughness);\n    }\n    \n    tcol += (fcol * result.material.emissive) * cosine;\n\n    fcol = fcol * result.material.color;\n    \n    rd = randomRay.rd;\n    ro = randomRay.ro;\n  }\n  return tcol / p;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 rt, in float cr)\n{\n    vec3 cw = normalize(rt - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n  p.x *= iResolution.x/iResolution.y;\n\n  float seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\n  \n  lightSphere = vec4(vec3(3.), 1.);\n  \n  vec2 of = -0.5 + vec2(hash1(seed), hash1(seed));\n  p = (2.0 * (fragCoord + of) - iResolution.xy) / iResolution.y;\n  \n  vec3 ro = vec3(2.78, 2.73, -8.00);\n  vec3 ta = vec3(2.78, 2.73,  0.00);\n  \n\n  mat3 ca = setCamera(ro, ta, 0.0);\n  vec3 rd = normalize(ca * vec3(p, 3.0));\n\n  vec3 col = vec3(0.);\n  vec3 tot = vec3(0.);\n\n  for( int a=0; a<16; a++ ) \n  {\n    col = PathTracing(ro, rd, seed);\n\n    tot += col;\n    \n    seed = mod( seed*1.1234567893490423, 13.);\n  }\n  tot /= float(16.);\n\n  tot = pow(clamp(tot, 0., 1.), vec3(0.45));\n  \n  vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n  tot = mix(lastFrameColor, tot, 1.0f / float(iFrame+1));\n\n  fragColor = vec4(tot, 1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2cDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 163]], "test": "untested"}
{"id": "stSyR3", "name": "Space war automata 2", "author": "SnoopethDuckDuck", "description": "press r to reset\n\ntheres a lot you can do with this: run 1 automata on each rgb channel then have a rock paper scissors interaction rule between the channels. I thought this one was cool", "tags": ["cellularautomata"], "likes": 6, "viewed": 254, "published": 3, "date": "1650006108", "time_retrieved": "2024-07-30T16:53:54.806324", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).rgb;\n\n    fragColor.rgb = vec3(col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n//#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvec3 Cell( in ivec2 p )\n{\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 px = ivec2( fragCoord );    \n\n    if (key_down(KEY_RESET) || iFrame==0) \n    {    \n        float d = length((fragCoord -.5* iResolution.xy ) / iResolution.y);\n        vec2 f = fragCoord + 0.001 * iTime;\n        vec3 g = vec3(h21(f), h21(f + 1.), h21(f - 1.));\n        fragColor.rgb = step(0.8, g);\n        return;\n    }\n        \n    // center cell\n    vec3 e = Cell(px); \n    \n    // neighbour cells\n    vec3 t = Cell(px + ivec2(0,-1));\n    vec3 b = Cell(px + ivec2(0,1));\n    vec3 l = Cell(px + ivec2(-1,0));\n    vec3 r = Cell(px + ivec2(1,0));   \n    \n    // \"average\" of neighbours\n    vec3 k = 0.5 * max(t + b, l + r);\n    \n    // difference between \"average\" and center\n    vec3 j = abs(e - k);\n    \n    for (int i = 0; i < 3; i++) {\n        if (e[i] < k[i] - 0.3)\n            e[i] = 1. * k[i] +  10000. * j[i] * e[i] * e[i] * e[i]; \n        else if (k[i] > 0.01 && e[i] > 0.46 && j[i] < 0.5)\n            e[i]= k[i] + 0.3 * j[i];      \n        else \n            e[i] = k[i];\n            e[i] -= 0.16 * j[i];\n            e[i] *= 0.99;\n    }    \n    \n    vec3 e2 = e;\n    for(int i = 0; i < 3; i++) {\n        if (e[(i+1)%3] < e[i]) {\n            //e2[(i-1)%3] += 0.01;\n            //e2[(i)%3] -= 0.05;// * fragCoord.x/iResolution.x;\n            //e2[(i+1)%3] -= 0.01;\n            \n            e2[i] = mix(e[i], e[(i+1)%3], 0.6);\n        }\n    }\n    e = e2;\n    //*/\n    e = clamp(e,0.,1.);\n     \n    fragColor = vec4( e, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]], "test": "untested"}
{"id": "7tfyRl", "name": "Audio Flight v2 (strobes)", "author": "byt3_m3chanic", "description": "Audio Flight 🚀 v2 - >> caution/strobing effects << - seriously in 46 seconds..\n> click and drag <\nmusic Boris Brejcha - Gravity\n(if audio doesn't start - stop, rewind and play)\n", "tags": ["audioflightv2"], "likes": 85, "viewed": 8948, "published": 3, "date": "1649988181", "time_retrieved": "2024-07-30T16:53:55.568287", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    AudioFlight 🚀 v2 - music Boris Brejcha - Gravity\n    4/14/22 | @byt3_m3chanic\n    \n    Path shader based around @Shane's stuff - he has a ton of amazing ones.\n    https://www.shadertoy.com/view/MlXSWX\n    \n    Music EQ based around @blackle's domain rep tricks\n    \n    Lots of fo\n\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI2         6.28318530718\n#define PI          3.14159265358\n\n#define MINDIST     .0001\n#define MAXDIST     125.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\nfloat sampleFreq(float freq) {\n    return texture(iChannel0, vec2(freq, 0.1)).x;\n}\n\n//http://mercury.sexy/hg_sdf/\nfloat pMod(inout float p, float size) {\n\tfloat c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\nvec2 pMod(inout vec2 p, float size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\nvec3 pMod(inout vec3 p, float size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.,\n          r = length(p),\n          c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\nfloat vmax(vec2 v) {\treturn max(v.x, v.y);\t\t\t\t\t\t}\nfloat vmax(vec3 v) {\treturn max(max(v.x, v.y), v.z);\t\t\t\t}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n//@iq\nfloat sdCap( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n// @Shane - https://www.shadertoy.com/view/MlXSWX\nvec2 path(in float z){ \n    vec2 p1 =vec2(2.35*sin(z * .125)+2.38*cos(z * .25), 3.5*cos(z * .0945));\n    vec2 p2 =vec2(3.2*sin(z * .19), 4.31*sin(z * .125)-2.38*cos(z * .115));\n    return (p1 - p2)*.3;\n}\n\n// globals\nfloat time,tm,travelSpeed;\n\n// globals and stuff\nfloat glow,iqd,flight,beams,gcolor,objglow,offWobble,boxsize;\nfloat ga,sa,slp;\nvec3 g_hp,s_hp;\nmat2 r4,r5;\n\nconst vec3 cxz = vec3(3.15,4.75,3.);\nconst float scale = 3.0;\n\nvec2 fragtail(vec3 pos) {\n    float ss=1.15;\n    float r = 1e5;\n    \n    for (int i = 0;i<2;i++) {\n        pos=abs(pos);\n        if ( pos.x- pos.y<0.) pos.yx = pos.xy;\n        if ( pos.x- pos.z<0.) pos.zx = pos.xz;\n        if ( pos.y- pos.z<0.) pos.zy = pos.yz;\n        \n        pos.x=scale * pos.x-cxz.x*(scale-1.);\n        pos.y=scale * pos.y-cxz.y*(scale-1.);\n        pos.z=scale * pos.z;\n        \n        if (pos.z>0.5*cxz.z*(scale-1.)) pos.z-=cxz.z*(scale-1.);\n\n        r = fBox2(pos.xy,vec2(5,1.5+.25*sin(pos.x*5.)))-.0015;\n        ss*=1./scale;\n    }\n\n    return vec2(r*ss,1.);\n}\n\n//@blackle domain rep https://www.shadertoy.com/view/Wl3fD2 \nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\nfloat ths= 13.25;\n// scene map\nvec2 map (in vec3 p, float sg) {\n  \n    vec2 res = vec2(100.,-1.);\n    float msize = 7.25;\n    \n    // set path(s) vector(s)\n    vec2 tun = p.xy - path(p.z);\n    vec3 q = vec3(tun,p.z);\n    vec3 o = vec3(tun+vec2(0.,.0),p.z+travelSpeed+4.25);\n   \n    vec3 s = q;\n\n    o.zx*=r5;\n    o.yz*=r4;\n    o = abs(o)-(offWobble*.25);\n    float obj = fBox(o,vec3(.15*offWobble))-.015;\n    if(obj<res.x ) {\n        res = vec2(obj,11.);\n        g_hp=o;\n    }\n    \n    // mods and vectors\n    float pid = floor((q.z+(msize/2.))/msize);\n    float trackmod = mod(pid,18.);\n    float deg = trackmod<12. ? trackmod<6. ? 4. : 6. : 10.;\n    pModPolar(q.xy,deg);\n    pModPolar(s.xy,deg*.5);\n    \n    vec3 r =s;\n    vec3 fs=s-vec3(2.85,0,0);\n    r = vec3(abs(r.x),abs(r.y),r.z);\n\n    // audio bards\n    fs.z*=2.;\n    vec2 center = floor(fs.xz) + .5;\n    vec2 neighbour = center + edge(fs.xz - center);\n\n    float chs = floor(center.y);\n    float bmod = mod(chs,16.);\n\n    float height = (sampleFreq(bmod*.0465));\n    height=smoothstep(.001,1.,height);\n    \n    ga=height;\n    float ids = pMod(s.z,msize);\n    vec3 qid = pMod(q,msize);\n    float ld = mod(ids,6.);\n    float lq = mod(ids,2.);    \n\n    iqd=qid.x;\n\n    float zprs= mod(chs, tm <8.? tm <4.? tm <4.? 2.: 2.: 5.: floor(height*1.45));\n\n    float d4a = length(r.xy-vec2(2.5,1.75))-.1;\n    float d4 =  length(r.xy-vec2(2.5,1.75))-.04+.027+.027*sin(r.z-time*4.5);\n    if(d4<res.x ) {\n        res = vec2(d4,12.);\n        g_hp=p;\n    }\n   \n    // fractal\n    vec2 d1 = fragtail(q);\n    d1.x = max(d1.x,-d4a);\n \n    s.z=abs(s.z);\n    float blt = sdCap(s-vec3(2.45,-.58,2.725),1.16 ,.015);\n    if(lq<2.) d1.x = min(blt,d1.x);\n    if(d1.x<res.x) {\n        res = d1.xy;\n        g_hp = p;\n    }\n    \n    float me =   fBox(fs-vec3(0,0,center.y),   vec3(.05,.150+height,.25));\n    float next = fBox(fs-vec3(0,0,neighbour.y),vec3(.05,.001+height,.25));\n    float dlt = min(me, next);\n    if(dlt<res.x) {\n        //float mid= zprs<4.? zprs<3.? zprs<2.? 3. : 4. : 4.  : 3.;\n        res = vec2(dlt,4.);//tm <8. ? mid : 4.);\n        g_hp = p;\n    }\n\n    if(sg==1.)beams += .0001/(.000003+d4*d4);\n    if(sg==1.&&lq<1.)flight += .00025/(.0000001+blt*blt);\n    if(sg==1.&&zprs<.1)glow += .00015/(.000002+dlt*dlt);\n    if(sg==1.&&tm<ths)objglow += .0005/(.0005+obj*obj);\n    \n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxstep, float sg){\n    float d =  0.,\n          m = -1.;\n        for(int i=0;i<maxstep;i++){\n            vec3 p = ro + rd * d;\n            vec2 t = map(p,sg);\n            if(abs(t.x)<d*MINDIST||d>MAXDIST)break;\n            d += i<42? t.x*.35 : t.x;\n            m  = t.y;\n        }\n    return vec2(d,m);\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MINDIST*t;\n    vec2 h = vec2(1,-1)*.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e,0.).x + \n        h.yyx*map( p + h.yyx*e,0.).x + \n        h.yxy*map( p + h.yxy*e,0.).x + \n        h.xxx*map( p + h.xxx*e,0.).x );\n}\n\n//iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    time = iTime;\n    tm = mod(time*.3, 18.);\n    travelSpeed = (time * 5.);\n    \n    offWobble = 1.5+1.15*sin(tm+time*.1);\n    \n    r4 =r2(time);\n    r5 =r2(time);\n    \n    // pixel screen coordinates\n    vec2 uv = (F.xy - R.xy*0.5)/max(R.x,R.y);\n    vec3 C = vec3(0.),\n         FC = vec3(.03);\n\n    float crop = clamp((-.05)+(T*.05),0.,.18);\n    if(uv.y<crop&&uv.y>-crop){\n    vec3 lp = vec3(0.,0.,0.-travelSpeed);\n    vec3 ro = vec3(0.,0,.15);\n\n    // mouse\n    float x = M.xy==vec2(0) || M.z<0. ? 0.:(M.y/R.y*1.-.5)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0.:-(M.x/R.x*2.-1.)*PI;\n\n    ro.zy*=r2(x);\n    \n    ro +=lp; \n\n    lp.xy += path(lp.z);\n    ro.xy += path(ro.z);\n\n    // set camera\n    vec3 f=normalize(lp-ro),\n         r=normalize(cross(vec3(0,1,0),f)),\n         u=normalize(cross(f,r)),\n         c=ro+f*.183,\n         i=c+uv.x*r+uv.y*u,\n        rd=i-ro;\n\n    // center tracking\n        rd.xy = r2( (.2*sin(time*.3))-path(lp.z).x/ 24. )*rd.xy;\n        rd.xz = r2( y-path(lp.z+1.).y/ 14. )*rd.xz;\n\n    // march\n    vec2 t = marcher(ro,rd, 164,1.);\n    float d = t.x,\n          m = t.y;\n    s_hp=g_hp;\n    \n    // if visible \n    if(d<MAXDIST)\n    {\n        vec3 p = ro+rd*d;\n\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(0,0,.25)-p;\n        lpos +=lp;\n        lpos.xy += path(lpos.z);\n        vec3 l = normalize(lpos);\n        \n        float diff = clamp(dot(n,l),.01,1.);\n\n        float spec = pow(max(dot(reflect(l,n),rd),.01),24.);\n\n        vec3 h = m==11.? vec3(.005): vec3(1.0);\n        if(m==3.||m==4.) h = vec3(.012);\n        if(tm>ths) {\n            C =(h * diff + spec);\n        } else {\n            if(m==3.||m==4.) C =(hsv2rgb(vec3(s_hp.z*.01,.8,.6))  * diff);\n        }\n        \n    } \n    \n    if(tm>ths) {\n        if(mod(T,.1)<.05)FC=vec3(.8);\n    }else{\n\n        C += abs(glow*.7)*hsv2rgb(vec3(s_hp.z*.01,.8,.6));\n        C += abs(objglow*.65)*vec3(1,1,1);\n    }\n    C = mix( C, FC, 1.-exp(-0.000075*t.x*t.x*t.x));\n    C += abs(beams*.65)*hsv2rgb(vec3(s_hp.z*.025,.8,.6));\n    C += abs(flight*.75)*vec3(.5,1,.2);\n    }\n    \n    \n    float px = 1./R.x;\n\n            \n    float d1 = fBox2(uv+vec2(-.485,.2675),vec2(.005))-.002;\n    d1=smoothstep(px,-px,d1);\n    C=mix(C,vec3(0.212,0.671,0.576),d1);\n    \n    d1 = fBox2(uv+vec2(-.465,.2675),vec2(.005))-.002;\n    d1=smoothstep(px,-px,d1);\n    C=mix(C,vec3(0.757,0.686,0.341),d1);\n    \n    d1 = fBox2(uv+vec2(-.445,.2675),vec2(.005))-.002;\n    d1=smoothstep(px,-px,d1);\n    C=mix(C,vec3(0.882,0.459,0.867),d1);\n    \n    C=pow(C, vec3(0.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [{"id": 28731, "src": "https://soundcloud.com/gustav-granath/boris-brejcha-gravity", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfyRl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[649, 649, 670, 670, 733], [734, 734, 764, 764, 816], [818, 848, 887, 887, 980], [981, 981, 1018, 1018, 1110], [1111, 1111, 1148, 1148, 1240], [1241, 1241, 1291, 1291, 1553], [1554, 1554, 1574, 1574, 1603], [1604, 1604, 1624, 1624, 1661], [1662, 1662, 1690, 1690, 1771], [1772, 1772, 1801, 1801, 1882], [1883, 1889, 1929, 1929, 1988], [1989, 2039, 2061, 2061, 2242], [2475, 2475, 2500, 2500, 3061], [3063, 3124, 3143, 3143, 3289], [3308, 3321, 3353, 3353, 5635], [5637, 5637, 5691, 5691, 5977], [5979, 5979, 6009, 6009, 6250], [6252, 6268, 6295, 6295, 6424], [6426, 6426, 6467, 6481, 9033]], "test": "untested"}
{"id": "NtScz3", "name": "splitVideos", "author": "Sergeindamix", "description": "Split screen of 3 different textures.", "tags": ["textures", "nyancat", "splitscreen", "fightingdude"], "likes": 0, "viewed": 233, "published": 3, "date": "1649983107", "time_retrieved": "2024-07-30T16:53:56.321274", "image_code": "#define t floor(iTime*140./60.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Variables\n    vec4 vid1 = texture(iChannel0, uv*vec2(.6,1));\n    vec4 vid2 = texture(iChannel1, uv*vec2(.6,1));\n    vec4 vid3 = texture(iChannel2, uv*vec2(1,1));\n    //Split Screen Effect \n    if(uv.x > sin(t)+.75){\n        fragColor = vid2;\n        }else if(uv.x < sin(t)+.25){\n            fragColor = vid1;  \n        }else\n            fragColor = vid3;\n    \n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtScz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 89, 139, 549]], "test": "untested"}
{"id": "st2czK", "name": "Triplanar Mapping Test 34234251", "author": "SnoopethDuckDuck", "description": "just watched half of this: https://www.youtube.com/watch?v=VaYyPTw0V84\nvery cool video, would recommend", "tags": ["e"], "likes": 16, "viewed": 379, "published": 3, "date": "1649976839", "time_retrieved": "2024-07-30T16:53:57.180975", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float t = -0.2 * iTime;\n    vec3 ro = 3.5 * vec3(cos(t), 0, sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float t = 3. * p.y + 4. * atan(p.x, p.z) + iTime;\n    vec2 o = 0.5 * vec2(cos(t), sin(t));\n    float d = length(p.xz + o) - exp(-1. * sabs(p.y));\n    //float d = length(p) - 1.5;length(p.xz) - 1.;sdBox(p, vec3(1.)) - 0.1;\n    return 0.1 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float sc = 4. * exp(-length(p.xz));\n        // p.xy * 0.5 + 0.5\n        vec3 c1 = texture(iChannel0, sc * p.xy).rgb;\n        vec3 c2 = texture(iChannel0, sc * p.yz).rgb;\n        vec3 c3 = texture(iChannel0, sc * p.zx).rgb;\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        vec3 n2 = sabs(n);\n        col *= 1.-(c1 * n2.z + c2 * n2.x + c3 * n2.y);\n        col = smoothstep(0.,1.,col);\n        \n        float fres = clamp(pow(1. + dot(rd, n), 5.), 0., 1.);\n        col += fres * exp(-thc(10.,60. * p.y)) * vec3(0.8,0.5,0.5);\n        \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2czK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 763], [765, 765, 788, 788, 1036], [1038, 1038, 1081, 1081, 1388], [1390, 1390, 1414, 1414, 1604], [1606, 1606, 1656, 1656, 1847], [1849, 1849, 1906, 1906, 2936]], "test": "untested"}
{"id": "ftjyzV", "name": "FIRE! in the brain", "author": "xenn", "description": "Displacement mapping with chromatic dispersion. The displacement vectors are supplied by an underlying dynamical system. Click to paint.", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 6, "viewed": 419, "published": 3, "date": "1649943493", "time_retrieved": "2024-07-30T16:53:58.232165", "image_code": "// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n\n#define Margins .0\n\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm2(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 0.0 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n    \n    \n    float noise = .9 + randomFloat()*.15;\n//  \tfragColor = vec4(ACESFilm(color*noise), 1.0);\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 frogColor;\n    vec4 frigColor;\n    vec3 col = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.1 * iResolution.y, .9, fragCoord) * .2\n        \t\t  + bloom(.2 * iResolution.y, .5, fragCoord) * .2;\n//    frogColor = vec4(ACESFilm(color*noise), 1.0);\n//    frigColor = mix(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0),(1.0 * abs(sin(iTime * .50))));\n        frogColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n        frigColor = min(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n\nfrogColor = mix(frigColor,frogColor,1.0-(0.999*(cos(iTime/3.14159265359))));\n// fragColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),440.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,50.0)*.85;\n    //spec=0.0;\n\tvec4 frugColor = texture(iChannel2,uv)*vec4(diff)+vec4(spec);\n    frugColor *= frogColor;\n    frugColor *= frogColor;\n    fragColor = frugColor;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n/*    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n*/    \n    vec4 u =    texture(iChannel2, fract(vUv));\n    vec4 u_n =  texture(iChannel2, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel2, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel2, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel2, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel2, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel2, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel2, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel2, fract(vUv+texel*se));\n    \n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n /*   vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n  */  \n     vec4 uv =    texture(iChannel2, fract(vUv));\n    vec4 uv_n =  texture(iChannel2, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel2, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel2, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel2, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel2, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel2, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel2, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel2, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n//    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n //   fragColor.xy += (0.000251*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n// displacement amount\n#define DISP_SCALE 3.0\n\n// chromatic dispersion samples\n#define SAMPLES 256\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH zw\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 231, 231, 371], [373, 373, 430, 430, 735], [808, 808, 828, 828, 907], [909, 909, 933, 933, 1073], [1076, 1076, 1099, 1099, 1147], [1153, 1153, 1188, 1188, 1327], [1328, 1328, 1385, 1385, 3420]], "test": "untested"}
{"id": "Nt2cRV", "name": "Triangle drama.", "author": "fyisic123", "description": "I take 2 rectangles, rotate one of them 45 degrees then remove the overlapping part to make what i think is pretty efficient star of triangles.", "tags": ["triangles", "hue", "trippy", "tiling"], "likes": 1, "viewed": 242, "published": 3, "date": "1649941017", "time_retrieved": "2024-07-30T16:53:59.065936", "image_code": "// Settings\n#define Side_Distortion 27.\n#define Zoom_Distortion_Frequency 8.\n#define Zoom_Distortion_Amount 0.5\n#define Zoom_Distortion_Speed 0.7\n#define Tile_Count 5.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy)/iResolution.y;\n    \n    \n    float screenLength = length(uv);\n    float uvDotP = dot(uv.x, uv.y);\n\n    \n    \n\n\n    uv *=Rot(iTime *.025); // camera rotation\n    uv *= Tile_Count;     \n    uv+= vec2(sin(iTime*.03), cos(iTime*.02)) * 5.;  // camera drift\n    \n    vec2 gv = fract(uv) -.5;\n    \n    vec2 ID = floor(uv);\n    \n    if (mod(ID.x, 2.) == 0.) // flip uv for mirrored effect\n        gv.x *= -1.;\n        \n    if (mod(ID.y, 2.) == 0.)\n        gv.y *= -1.;\n\n       \n    \n    \n    gv *= (Rot(uvDotP *  pow(screenLength, 3.) *  Side_Distortion)); //  side distortion\n    gv *= 1.0 + (Zoom_Distortion_Amount * sin(Zoom_Distortion_Frequency * screenLength + (iTime * Zoom_Distortion_Speed))); // zoom distortion\n\n    vec2 offs = vec2(cos(iTime * 0.123) * cos( iTime), sin(iTime * 0.5))*(0.6*abs(sin(iTime * 0.2))); // Some movement\n    \n    float p = 0.;\n    \n        \n    for(float i=1.; i > 0.; i -= 0.1)  // Get triangles\n    {                        \n        vec2 pos= gv + offs;\n        p = XOR(p,(getStar(pos *Rot (i + iTime * 0.23), i )* pow(smoothstep(0.0, 1., length(pos)), 1.2)));        \n         gv *= Rot( 0.4448 * sin( iTime * 0.1));//RM;  // rotates 25 degrees\n        \n    }\n     \n    \n    \n    \n    fragColor = vec4(hue(atan(gv.x, gv.y)*p)  * p,1.0);\n}", "image_inputs": [], "common_code": "#define PI 3.14159265359\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat getRect(vec2 uv, float size)\n{\n    return sign(length(max(abs(uv)-size,0.0)));\n}\n\n\nfloat getStar(vec2 uv, float size)\n{    \n    float s = 0.5 * size;\n    return (mod(getRect(uv, s ) + getRect(uv * Rot(radians(45.)), s), 2.)) ;\n}\n\n\nfloat XOR(float a, float b)\n{\n   return a*(1.-b) + b*(1. -a);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2cRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 228, 228, 1555]], "test": "untested"}
{"id": "NtjcRV", "name": "Fugu Egg", "author": "dr2", "description": "Fugu in fishbowl in non-Faberge egg - mousing advised", "tags": ["refraction", "water", "fish"], "likes": 18, "viewed": 277, "published": 3, "date": "1649939733", "time_retrieved": "2024-07-30T16:54:00.018389", "image_code": "// \"Fugu Egg\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Fugu in fishbowl in non-Faberge egg - mousing advised\n\n// Optics includes reflection, refraction, total internal reflection, Fresnel reflection\n\n/*\n  No. 7 in \"Egg\" series; others are listed in \"Nautilus Egg\" (7dj3Wz).\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0) \n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec4 SphFib (vec3 v, float n);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nfloat Fbm2 (vec2 p);\n\nvec3 qHit, ltDir, sphPos, fishPos, pFish, vuPos, eyeOff, hingSz;\nvec2 opCs;\nfloat dstFar, tCur, opPhs, shellRad, sphRad, sphHt, shHalf, fishSz, fishAng, rotDir,\n   bodyEx, spkEx, mthShp;\nint idObj;\nbool isSh;\nconst int idShell = 1, idHing = 2, idArm = 3, idSup = 4, idFlr = 5,\n   idBody = 11, idFinV = 12, idFinL = 13, idTail = 14, idMouth = 15, idEye = 16;\nconst float pi = 3.1415927, phi = 1.618034;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ShRad (vec3 p)\n{\n  return shellRad + 0.02 * (1. - p.y / length (p)) * cos (64. * atan (p.x, p.z));\n}\n\nfloat ExtObjDf (vec3 p)\n{  // (from \"Nautilus Egg\")\n  vec3 q;\n  float dMin, d, ds, r, y;\n  dMin = dstFar;\n  q = p;\n  q.y -= -0.1;\n  d = PrCylDf (q.xzy, 40., 0.1);\n  DMINQ (idFlr);\n  q = p;\n  q.y -= shellRad;\n  q.z -= - (shellRad - 0.1) - 2. * hingSz.z;\n  d = PrCapsDf (q.yzx, hingSz.y + 0.02, hingSz.x);\n  DMINQ (idHing);\n  q.yz = Rot2Cs (q.yz, opCs);\n  shHalf = sign (q.y);\n  q.y = abs (q.y);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.z -= (shellRad - 0.1) + 2. * hingSz.z;\n  r = ShRad (q);\n  ds = length (q) - r;\n  d = 0.9 * SmoothMax (abs (ds) - 0.05, -0.01 - q.y, 0.01);\n  DMINQ (idShell);\n  q.z -= - (shellRad - 0.1) - hingSz.z;\n  d = max (PrRoundBoxDf (q, vec3 (hingSz.xy, hingSz.z + 0.01) - 0.02, 0.02),\n     max (- ds, 0.05 - q.y));\n  DMINQ (idArm);\n  q = p;\n  q.y -= 0.5 * sphHt;\n  d = PrCylDf (q.xzy, 0.03, 0.5 * sphHt);\n  DMINQ (idSup);\n  return dMin;\n}\n\nfloat ExtObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExtObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExtObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExtObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 SpkShp ()\n{\n  vec4 f4;\n  vec3 uf;\n  float s;\n  f4 = SphFib (normalize (pFish + vec3 (0., 0., 0.1)), 2048.);\n  uf = f4.yzw;\n  s = smoothstep (0.95, 0.99, dot (uf, normalize (vec3 (0., 0.24, 1.))));\n  if (s == 0.) s = smoothstep (0.92, 0.99, dot (uf, normalize (vec3 (0., 0.35, -1.))));\n  if (s == 0.) s = smoothstep (0.9, 0.94, dot (uf, normalize ((eyeOff - vec3 (0., 0., -0.03)) *\n     vec3 (sign (uf.x), 1., 1.))));\n  if (s == 0.) s = smoothstep (0.97, 0.99, dot (uf, normalize (vec3 (sign (uf.x), 0., 0.25))));\n  if (s == 0.) s = smoothstep (0.97, 0.99, dot (uf, normalize (vec3 (0., sign (uf.y), -0.1))));\n  return vec2 (1. - s, f4.x);\n}\n\nfloat FishBodyDf ()\n{\n  vec3 p, q;\n  vec2 spk;\n  float spkLen, db, dt;\n  spk = SpkShp ();\n  spkLen = spk.x * (1. - smoothstep (0.001, 0.02, spk.y)) * (0.001 + 0.04 * spkEx);\n  p = pFish;\n  p.y -= -0.03 * bodyEx;\n  p.x *= 1. + 1.5 * (p.y + 0.2) * (p.y + 0.2);\n  p.xy *= 1. + 0.5 * smoothstep (0., 0.5, - p.z);\n  q = (p - vec3 (0., 0.2 + 0.025 * bodyEx, 0.5 * (p.y - 0.2) - 0.14)) * vec3 (1.4, 1.7, 0.6);\n  dt = PrSphDf (q, 0.4 - 0.2 * smoothstep (0., 1.5, 1.3 - p.z) + spkLen);\n  q = p * vec3 (1.2, 1.2, 1. + 0.5 * smoothstep (0., 0.5, - p.y - p.z));\n  db = PrSphDf (q, 0.37 + smoothstep (0., 1.7, - p.z) + 0.03 * bodyEx + spkLen);\n  q = pFish;\n  q.yz -= vec2 (0.1, 0.1);\n  q.xy *= vec2 (0.5, 1.) + vec2 (0.1, -0.4) * mthShp;\n  return SmoothMin (max (db, - PrCylDf (q, 0.02, 0.3)), dt, 0.05);\n}\n\nfloat FishMthDf ()\n{\n  vec3 p;\n  p = pFish;\n  p.yz -= vec2 (0.1, 0.34 + 0.02 * bodyEx - 2. * p.x * p.x);\n  p.xy *= vec2 (0.5 + 0.1 * mthShp, 1. - 0.5 * mthShp);\n  return PrCylAnDf (p, 0.015, 0.0015, 0.03);\n}\n\nfloat FishTailDf ()\n{\n  vec3 p;\n  float d, r, a;\n  p = pFish;\n  p.yz -= vec2 (0.11, -0.45);\n  p.xz = Rot2D (p.xz, 0.5 * cos (2. * tCur - 3. * p.y + 5. * p.z));\n  a = 0.003 * sin (32. * atan (p.y, p.z));\n  r = length (p.yz);\n  d = min (0.01 - 0.008 * smoothstep (0.15, 0.25, r) - abs (p.x -\n     a * smoothstep (0.04, 0.08, r)), 0.35 - 0.05 * p.y - 0.01 * cos (a * 1024.) - r);\n  d = - SmoothMin (abs (p.y) + 0.3 * p.z, SmoothMin (-0.3 * abs (p.y) - p.z, d, 0.02), 0.02);\n  return d;\n}\n\nfloat FishFinLDf ()\n{\n  vec3 p;\n  float d, r, a, t, w;\n  p = pFish;\n  t = 5. * tCur + 0.2 * sign (p.x);\n  p.x = abs (p.x) - 0.26 - 0.02 * bodyEx;\n  p.xz = Rot2D (p.xz, 0.4 * pi);\n  w = 0.15 * (1. - 0.15 * bodyEx) * (1. + 5. * length (p));\n  p.yz = Rot2D (p.yz, 0.2 + 0.5 * w * cos (t + 2. * atan (p.x, - p.y)) - 0.5 * pi);\n  p.xz = Rot2D (p.xz, 1.2 + 0.75 * bodyEx + w * sin (t - w) - 0.5 * pi);\n  a = atan (p.x, - p.y);\n  r = length (p.xy);\n  d = min (0.01 - 0.008 * smoothstep (0.2, 0.3, r) -\n     abs (p.z + 0.002 * sin (32. * a) * smoothstep (0.05, 0.08, r)),\n     0.4 - 0.15 * smoothstep (1., 3., abs (a)) - 0.01 * cos (32. * a) - r);\n  d = - SmoothMin (-0.2 * p.x + p.y, SmoothMin (p.x - 0.7 * p.y, d, 0.02), 0.02);\n  return d;\n}\n\nfloat FishFinVDf ()\n{\n  vec3 p;\n  float d, r, a, y;\n  p = pFish;\n  p.y = abs (p.y + 0.035 * bodyEx) - 0.035 * bodyEx - 0.26 - 0.02 * sign (p.y);\n  p.z -= -0.1;\n  y = smoothstep (0., 0.2, p.y);\n  p.z *= 1. - 0.3 * y * y;\n  a = - cos (4. * tCur + 5. * (- p.y + p.z)) * (0.1 - 0.3 * p.z);\n  p.xz = Rot2D (p.xz, a);\n  p.xy = Rot2D (p.xy, a);\n  a = 0.0025 * sin (32. * atan (p.y, p.z));\n  r = length (p.yz);\n  d = min (0.01 - 0.009 * smoothstep (0.1, 0.2, r) -\n     abs (p.x + a * smoothstep (0.04, 0.1, r)), 0.22 - 0.015 * cos (512. * a) - r);\n  d = - SmoothMin (p.y + 0.4 * p.z, SmoothMin (-0.4 * p.y - p.z, d, 0.02), 0.02);\n  return d;\n}\n\nfloat FishDf (vec3 p, float dMin)\n{  // (from \"Fibonacci's Fugu\" and \"Fugu Watching\")\n  float d, a, c;\n  p.xz *= rotDir;\n  c = cos (2. * tCur);\n  a = -0.5 * smoothstep (-0.2, 1.1, - p.z) * c;\n  p.xz = Rot2D (p.xz, 0.1 * c + a);\n  p.xy = Rot2D (p.xy, 0.5 * a);\n  pFish = p;\n  d = 0.3 * FishBodyDf ();\n  if (d < dMin) idObj = idBody;\n  dMin = min (dMin, d);\n  d = FishMthDf ();\n  if (abs (d) < dMin) idObj = idMouth;\n  dMin = SmoothMin (dMin, d, 0.01);\n  d = 0.6 * FishTailDf ();\n  if (d < dMin) idObj = idTail;\n  dMin = SmoothMin (dMin, d, 0.01);\n  d = 0.6 * FishFinLDf ();\n  if (d < dMin) idObj = idFinL;\n  dMin = SmoothMin (dMin, d, 0.01);\n  d = 0.7 * FishFinVDf ();\n  if (d < dMin) idObj = idFinV;\n  dMin = SmoothMin (dMin, d, 0.01);\n  p.x = abs (p.x);\n  d = PrSphDf (p - eyeOff, 0.13);\n  if (d < dMin) idObj = idEye;\n  dMin = SmoothMin (dMin, d, 0.02);\n  return dMin;\n}\n\nfloat IntObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= fishPos;\n  p.xz = Rot2D (p.xz, - fishAng);\n  dMin = dstFar / fishSz;\n  p /= fishSz;\n  if (! isSh) d = PrSphDf (p, 0.8);\n  dMin = (isSh || d < 0.1) ? FishDf (p, dMin) : d;\n  return fishSz * dMin;\n}\n\nfloat IntObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = IntObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 IntObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = IntObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 IntObjCol (vec3 p)\n{\n  vec4 col4;\n  vec3 ve;\n  vec2 spk;\n  float s;\n  col4 = mix (vec4 (0.9, 0.6, 0.8, 0.2), vec4 (0.9, 0.5, 0.5, 0.2), spkEx);\n  if (idObj == idBody) {\n    col4.rgb *= 1. - 0.5 * smoothstep (-0.2, 0.1, pFish.y);\n    spk = SpkShp ();\n    col4.rgb = mix (col4.rgb, vec3 (0.9, 0.7, 0.7), 0.5 * smoothstep (0., 0.01, spk.x) *\n       SmoothBump (0.25, 0.75, 0.1, mod (128. * atan (0.7 * pFish.x, pFish.y - 0.1) / pi, 1.)));\n    col4 = mix (col4, vec4 (0.9, 0.9, 0.95, 0.5), 0.5 * step (0.02, spk.x) * step (spk.y, 0.02));\n  } else if (idObj == idMouth) {\n    col4.rgb = mix (col4.rgb, vec3 (0.9, 0.7, 0.7), 0.5);\n  } else if (idObj == idFinV || idObj == idFinL) {\n    col4.rgb = mix (col4.rgb, vec3 (1.), 0.3 * smoothstep (0.4, 0.5, length (pFish)));\n  } else if (idObj == idTail) {\n    col4.rgb = mix (col4.rgb, vec3 (1.), 0.3 * smoothstep (0.6, 0.7, length (pFish)));\n  } else if (idObj == idEye) {\n    if (abs (pFish.y - eyeOff.y - 0.04) < 0.001 + 0.1 * SmoothBump (0.13, 0.87, 0.07,\n       mod (0.5 * tCur, 1.))) {\n      ve = eyeOff * vec3 (sign (pFish.x), 1., 1.) * fishSz;\n      ve.xz = Rot2D (ve.xz, fishAng) * rotDir;\n      ve += fishPos;\n      ve = RotToDir (normalize (vuPos - ve), vec3 (sign (pFish.x), 0., 0.), p - ve);\n      s = 0.8 * length (ve.yz) / fishSz;\n      col4 = (s > 0.05 + 0.03 * SmoothBump (0.25, 0.75, 0.25, mod (8. *\n         atan (ve.y, ve.z) / pi, 1.))) ? vec4 (1., 1., 1., 0.3) * (0.5 +\n         0.5 * smoothstep (0.07, 0.1, s)) : vec4 (0., 0.5, 0., -1.);\n    } else idObj = idBody;\n  }\n  return col4;\n}\n\nvec4 ExtObjCol ()\n{\n  vec4 col4;\n  float r, rr, s, y;\n  if (idObj == idShell) {\n    r = ShRad (qHit);\n    rr = length (qHit);\n    s = 0.;\n    if (rr > r) {\n      s = smoothstep (0.7, 0.8, cos (32. * asin (qHit.y / rr) + 8. * atan (qHit.z, qHit.x) *\n         shHalf));\n    } else if (qHit.y > 0.01) {\n      y = 1. - qHit.y / rr;\n      s = smoothstep (0.05, 0.1, y) * smoothstep (-0.2, 0.2, (r - shellRad) / (0.02 * y));\n    }\n    col4 = mix (vec4 (0.2, 0.3, 1., 0.2), vec4 (0.8, 0.8, 1., 0.1), s);\n  } else if (idObj == idHing) {\n    col4 = vec4 (0.1, 0.1, 0.5, 0.2) * (1. - 0.4 * SmoothBump (-0.04, 0.04, 0.02,\n       mod (4. * qHit.x / hingSz.x + 0.5, 1.) - 0.5));\n  } else if (idObj == idArm) {\n    col4 = vec4 (0.1, 0.1, 0.5, 0.2);\n  } else if (idObj == idSup) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.1);\n  } else if (idObj == idFlr) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.1) * (0.8 + 0.2 * Fbm2 (vec2 (0.5, 4.) * qHit.xz)) *\n       (1. - 0.5 * smoothstep (0., 15., length (qHit.xz) - 25.));\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p, qHitT;\n  float sh, d, h;\n  int idObjT;\n  isSh = true;\n  sh = 1.;\n  idObjT = idObj;\n  qHitT = qHit;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = min (ExtObjDf (p), IntObjDf (p));\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjT;\n  qHit = qHitT;\n  isSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat InSphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d;\n  b = dot (rd, ro);\n  d = b * b + rad * rad - dot (ro, ro);\n  return (d > 0.) ? - b - sqrt (d) : dstFar;\n}\n\nfloat OutSphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d;\n  b = dot (rd, ro);\n  d = b * b + rad * rad - dot (ro, ro);\n  return (d > 0.) ? - b + sqrt (d) : dstFar;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col; \n  vec2 w;\n  col = 0.5 * mix (vec3 (0.5, 0.5, 0.), vec3 (1., 0.9, 0.8) * (0.4 + 0.2 * rd.y), \n     Minv2 (smoothstep (0.05, 0.1, abs (sin (64. * atan (rd.zy,\n     vec2 (rd.x, length (rd.xz))))))));\n  if (rd.y > 0.) {\n    w = Rot2D (rd.xz / rd.y, 0.25 * pi);\n    col = mix (col, vec3 (0.9, 0.9, 1.), step (Maxv2 (abs (w)), 0.75) * smoothstep (0., 0.02,\n       0.45 - Maxv2 (abs (fract (6. * w + 0.5) - 0.5))));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, colR, row, rdt, rdo, vn, vnIn, vnOut, vnw;\n  float dstObj, dstSphIn, dstSphOut, dstObjInt, dstObjExt, watHt, dstWat, eta, s, sh, nDotL;\n  bool inWat, inWatAny, hitSph, needRefl, inShell;\n  hingSz = vec3 (1., 0.2, 0.4);\n  sphPos = vec3 (0., sphHt + sphRad, 0.);\n  eta = 1.3;\n  watHt = sphPos.y + 0.25 * sphRad;\n  bodyEx = SmoothBump (0.25, 0.75, 0.15, mod (0.4 * tCur, 1.));\n  spkEx = SmoothBump (0.65, 0.85, 0.05, mod (0.2 * tCur, 1.));\n  mthShp = sin (6. * tCur);\n  eyeOff = vec3 (0.13);\n  fishSz = 2.;\n  rotDir = 1.;\n  fishAng = 2. * pi * rotDir * fract (0.1 * tCur);\n  fishPos.xz = sphPos.xz + Rot2D (vec2 (sphRad - 1.7, 0.), fishAng);\n  fishPos.y = watHt - 0.7 - 0.3 * cos (1. * tCur);\n  if (rd.y == 0.) rd.y = 0.001;\n  isSh = false;\n  rdo = rd;\n  inWatAny = false;\n  dstObjExt = ExtObjRay (ro, rd);\n  dstObj = dstFar;\n  dstObjInt = dstFar;\n  dstSphIn = InSphHit (ro - sphPos, rd, sphRad);\n  hitSph = (dstSphIn < min (dstObjExt, dstFar));\n  if (hitSph) {\n    ro += dstSphIn * rd;\n    vnIn = (ro - sphPos) / sphRad;\n    inWat = false;\n    needRefl = false;\n    if (ro.y < watHt) {\n      inWat = true;\n      inWatAny = true;\n      rd = refract (rd, vnIn, 1. / eta);\n    }\n    dstObjInt = IntObjRay (ro, rd);\n    dstSphOut = OutSphHit (ro - sphPos, rd, sphRad);\n    dstWat = - (ro.y - watHt) / rd.y;\n    if (dstWat > 0. && dstWat < min (dstObjInt, dstSphOut)) {\n      ro += dstWat * rd;\n      s = 0.001 * sin (2. * pi * (2. * length (ro.xz) - tCur));\n      vnw.y = 1. - abs (s);\n      vnw.xz = - sign (s) * sqrt (1. - vnw.y * vnw.y) * normalize (ro.xz);\n      if (inWat) {\n        rdt = refract (rd, - vnw, eta);\n        inWat = (length (rdt) == 0.);\n        rd = (inWat) ? reflect (rd, - vnw) : rdt;\n      } else {\n        row = ro;\n        needRefl = true;\n        rd = refract (rd, vnw, 1. / eta);\n        inWat = true;\n        inWatAny = true;\n      }\n      dstObjInt = IntObjRay (ro, rd);\n      dstSphOut = OutSphHit (ro - sphPos, rd, sphRad);\n    }\n    if (dstSphOut < dstObjInt) {\n      ro += dstSphOut * rd;\n      if (inWat) {\n        vnOut = - (ro - sphPos) / sphRad;\n        rdt = refract (rd, vnOut, eta);\n        rd = (length (rdt) > 0.) ? rdt : reflect (rd, vnOut);\n      }\n    }\n    dstObjExt = ExtObjRay (ro, rd);\n  }\n  dstObj = min (dstObjInt, dstObjExt);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObjInt < dstObjExt) {\n      vn = IntObjNf (ro);\n      col4 = IntObjCol (ro);\n    } else {\n      vn = ExtObjNf (ro);\n      col4 = ExtObjCol ();\n    }\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (dstObjExt < dstObjInt) nDotL *= nDotL;\n      sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n      if (dstObjExt < dstObjInt && idObj == idFlr && InSphHit (qHit - sphPos, ltDir, 1.05 * sphRad) <\n         dstFar) sh = min (sh, 0.9);\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) +\n         0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rdo), 0.), 32.);\n      inShell = (length (qHit) < ShRad (qHit));\n      if (dstObjInt < dstObjExt || dstObjExt < dstObjInt && idObj == idShell && inShell)\n         col *= 0.1 + 0.9 * smoothstep (0.05, 0.3, opPhs);\n      if (dstObjExt < dstObjInt && idObj == idShell && ! inShell)\n         col += 0.1 * BgCol (reflect (rdo, vn));\n    } else {\n      col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rdo), 0.));\n    }\n  } else {\n    col = BgCol (rd);\n  }\n  if (inWatAny) col *= vec3 (0.9, 1., 0.9);\n  if (needRefl) {\n    ro = row;\n    rd = reflect (rdo, vnw);\n    dstObj = ExtObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ExtObjNf (ro);\n      col4 = ExtObjCol ();\n      colR = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    } else {\n      colR = BgCol (rd);\n    }\n    col = mix (col, colR, 0.03 + 0.97 * pow (1. - abs (dot (rdo, vnw)), 5.));\n  }\n  if (hitSph) {\n    colR = BgCol (reflect (rdo, vnIn));\n    col = mix (col, 1.5 * colR, 0.03 + 0.97 * pow (1. - abs (dot (rdo, vnIn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  opPhs = SmoothBump (0.25, 0.85, 0.15, mod (0.07 * tCur, 1.));\n  opCs = sin (0.4 * pi * opPhs + vec2 (0.5 * pi, 0.));\n  shellRad = 4.;\n  sphRad = 3.7;\n  sphHt = 0.8 * opPhs * shellRad;\n  az = pi;\n  el = -0.12 * pi;\n  zmFac = 4.8;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 2. * abs (az - pi);\n  } else {\n    az += 0.4 * pi * (2. * SmoothBump (0.25, 0.75, 0.24, fract (0.01 * tCur)) - 1.); \n  }\n  el = clamp (el, -0.4 * pi, 0.02 * pi);\n  az = clamp (az, 0.2 * pi, 1.8 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1.5 * shellRad, -35.);\n  ro.y = max (ro.y, 0.1);\n  vuPos = ro;\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec4 SphFib (vec3 v, float n)\n{   // (Keinert et al's inverse spherical Fibonacci mapping)\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vec4 (sqrt (ddMin), vfMin);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjcRV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1538, 1538, 1560, 1560, 1644], [1646, 1646, 1671, 1697, 2502], [2504, 2504, 2540, 2540, 2726], [2728, 2728, 2752, 2752, 3010], [3012, 3012, 3028, 3028, 3657], [3659, 3659, 3680, 3680, 4452], [4454, 4454, 4474, 4474, 4661], [4663, 4663, 4684, 4684, 5147], [5149, 5149, 5170, 5170, 5884], [5886, 5886, 5907, 5907, 6521], [6523, 6523, 6558, 6608, 7395], [7397, 7397, 7422, 7422, 7643], [7645, 7645, 7681, 7681, 7867], [7869, 7869, 7893, 7893, 8151], [8153, 8153, 8178, 8178, 9704], [9706, 9706, 9725, 9725, 10714], [10716, 10716, 10753, 10753, 11146], [11148, 11148, 11194, 11194, 11315], [11317, 11317, 11364, 11364, 11485], [11487, 11487, 11509, 11509, 11967], [11969, 11969, 12004, 12004, 16149], [16151, 16151, 16207, 16207, 17617], [17619, 17619, 17665, 17665, 17712], [17714, 17714, 17747, 17747, 17774], [17776, 17776, 17818, 17818, 17869], [17871, 17871, 17924, 17924, 17985], [17987, 17987, 18030, 18030, 18094], [18096, 18096, 18127, 18186, 19006], [19008, 19008, 19030, 19030, 19057], [19059, 19059, 19081, 19081, 19108], [19110, 19110, 19155, 19155, 19247], [19249, 19249, 19294, 19294, 19332], [19334, 19334, 19391, 19391, 19474], [19476, 19476, 19512, 19512, 19718], [19720, 19720, 19750, 19750, 19863], [19865, 19865, 19896, 19896, 19960], [19962, 19962, 20004, 20004, 20160], [20194, 20194, 20218, 20218, 20330], [20332, 20332, 20357, 20357, 20543], [20545, 20545, 20566, 20566, 20721]], "test": "untested"}
{"id": "7tBczK", "name": "分形3-2", "author": "yjx", "description": "mandelbrot", "tags": ["mandelbrot"], "likes": 1, "viewed": 209, "published": 3, "date": "1649918125", "time_retrieved": "2024-07-30T16:54:00.948901", "image_code": "float distancetoline(vec2 pos1,vec2 pos2,vec2 pos){\n    vec2 v1=pos1-pos;\n    vec2 v2=pos2-pos;\n    vec2 v3=pos1-pos2;\n    if(v1.x*v3.x+v1.y*v3.y>0. && v2.x*v3.x+v2.y*v3.y<0.){\n    return abs(v1.x*v2.y-v2.x*v1.y)/min(length(pos1-pos2),10000.);}\n    return 1.0;\n}//点到线段距离\n\nvec2 sq(vec2 z){\n    return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y);}//平方\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cof=4.;\n\n    vec2 uv=vec2(0.);\n    vec2 uv2=vec2(0.);\n    vec2 Mouse=cof*(iMouse.xy-iResolution.xy*vec2(.5))/iResolution.x;\n    vec2 c=cof*(fragCoord-iResolution.xy*vec2(.5))/iResolution.x;\n\n    float iterations=0.0;\n\n    for(int i=0;i<100;i++){\n    if(dot(uv,uv)<10000.0){\n        uv=sq(uv)+c;\n        iterations+=1.0;}}\n\n    vec4 mandel=vec4(iterations/100.0,iterations/100.0,iterations/100.0,1.0);\n    vec4 linecolor=vec4(0.953,0.761,0.071,1.);\n    for(int i=0;i<100;i++){\n        mandel=mix(linecolor,mandel,\n        smoothstep(0.000,0.003,distancetoline(uv2,sq(uv2)+Mouse,c))\n        );\n        uv2=sq(uv2)+Mouse;}\n    fragColor=mandel;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 262], [284, 284, 300, 300, 346], [360, 360, 417, 417, 1071]], "test": "untested"}
{"id": "fl2yzG", "name": "Qiqi, but Shadertoy (Genshin)", "author": "yuchengzhong", "description": "Source image by Mihoyo.", "tags": ["genshin", "qiqi"], "likes": 28, "viewed": 2542, "published": 3, "date": "1649917673", "time_retrieved": "2024-07-30T16:54:02.647360", "image_code": "//Source image by Mihoyo\n//ycz, 2022\n//qiqi\nvec3 ColorField(vec2 uv_0)\n{\nvec4 L0_0 = sin(30.000000 * (mat2x4(0.445747,0.296340,0.428775,-0.071432,-0.009347,0.259324,-0.430670,0.265612) * uv_0 + vec4(-0.381782,-0.410639,-0.190198,-0.492836)));\nvec4 L0_1 = sin(30.000000 * (mat2x4(-0.338774,0.330235,0.536333,0.504806,-0.460190,-0.257048,0.244802,-0.374851) * uv_0 + vec4(0.348226,0.263927,-0.016077,0.388172)));\nvec4 L0_2 = sin(30.000000 * (mat2x4(0.004388,-0.298345,-0.040943,0.006075,-0.326294,-0.313353,0.104311,0.234762) * uv_0 + vec4(0.183003,-0.257767,0.410004,-0.222712)));\nvec4 L0_3 = sin(30.000000 * (mat2x4(0.012449,0.263401,-0.200635,0.436979,-0.413953,-0.318762,-0.156850,0.323187) * uv_0 + vec4(-0.100951,-0.023290,0.228464,-0.162496)));\nvec4 L0_4 = sin(30.000000 * (mat2x4(-0.477653,0.026677,0.012841,0.276881,0.349548,-0.286371,0.242429,-0.192185) * uv_0 + vec4(-0.106609,0.488394,-0.259938,-0.183257)));\nvec4 L0_5 = sin(30.000000 * (mat2x4(0.455253,-0.376737,0.259236,-0.174216,0.127035,-0.061628,0.368589,-0.457176) * uv_0 + vec4(-0.495034,-0.141658,-0.444365,0.371846)));\nvec4 L0_6 = sin(30.000000 * (mat2x4(-0.302650,0.182830,0.429696,0.216265,0.345002,-0.187775,-0.106966,-0.344749) * uv_0 + vec4(0.129264,-0.461303,0.446963,0.270314)));\nvec4 L0_7 = sin(30.000000 * (mat2x4(0.256475,-0.038457,0.233228,0.168712,-0.186139,-0.372392,-0.011111,0.220954) * uv_0 + vec4(-0.351183,-0.253908,0.131965,-0.314097)));\nvec4 L0_8 = sin(30.000000 * (mat2x4(0.526252,0.185829,-0.068344,-0.489282,-0.226527,0.403059,-0.146455,-0.064964) * uv_0 + vec4(0.079259,-0.339344,0.170936,0.195305)));\nvec4 L0_9 = sin(30.000000 * (mat2x4(-0.074966,-0.067822,0.335583,-0.164646,-0.334723,0.237070,0.011160,-0.247433) * uv_0 + vec4(0.078463,-0.293665,0.229735,-0.467820)));\nvec4 L0_10 = sin(30.000000 * (mat2x4(-0.419511,-0.095070,0.458181,0.095512,0.251838,-0.493107,0.302853,0.165970) * uv_0 + vec4(-0.092606,-0.388284,-0.430225,0.086531)));\nvec4 L0_11 = sin(30.000000 * (mat2x4(-0.040349,-0.319587,-0.353860,0.457836,0.446664,0.037297,0.196616,0.190192) * uv_0 + vec4(-0.090011,0.250137,0.131779,0.041064)));\nvec4 L0_12 = sin(30.000000 * (mat2x4(0.377622,-0.274303,-0.441062,-0.516778,-0.360384,0.115744,0.267774,0.220325) * uv_0 + vec4(0.088311,-0.379357,-0.241704,-0.146864)));\nvec4 L0_13 = sin(30.000000 * (mat2x4(-0.280145,0.040146,-0.069149,-0.100729,-0.204474,-0.404539,-0.431906,0.139396) * uv_0 + vec4(-0.095044,-0.352506,-0.380515,-0.215504)));\nvec4 L0_14 = sin(30.000000 * (mat2x4(-0.347072,-0.369642,0.179103,0.182653,-0.114255,-0.184061,-0.083129,0.280161) * uv_0 + vec4(-0.319189,0.174975,0.391067,0.416473)));\nvec4 L0_15 = sin(30.000000 * (mat2x4(0.121313,0.311408,-0.193448,-0.400522,0.422744,0.376849,0.492501,-0.323580) * uv_0 + vec4(0.402111,-0.020740,0.061204,-0.457278)));\nvec4 L1_0 = sin((mat4(-0.119743,-0.131784,-0.241928,0.101566,0.263700,0.090009,-0.180295,0.255018,-0.122442,-0.129715,-0.158164,0.242469,-0.141584,0.141890,-0.167616,0.042271) * L0_0 + mat4(-0.167379,-0.308014,0.143848,0.295421,-0.135809,0.275706,-0.094581,-0.029843,0.144997,-0.060038,-0.433651,-0.240561,0.149416,-0.161057,0.012814,0.324611) * L0_1 + mat4(0.178288,-0.156944,0.069192,0.368987,0.127817,0.060898,0.280839,-0.033839,0.175329,-0.010869,-0.017285,0.168887,0.040290,-0.148710,0.269985,-0.051555) * L0_2 + mat4(-0.397332,0.070273,-0.323252,0.055317,-0.002083,-0.109124,-0.470246,0.273124,0.135595,0.150279,0.108144,0.103793,0.064805,-0.197874,0.266510,0.156097) * L0_3 + mat4(0.299031,-0.044911,-0.298669,0.412488,0.257290,0.060892,0.189431,0.111879,-0.129339,0.078766,0.152281,-0.183084,0.127266,0.466951,-0.077373,-0.095880) * L0_4 + mat4(-0.271951,-0.143509,-0.197955,-0.248481,0.025956,-0.123650,-0.268105,-0.087182,0.184834,-0.270705,-0.078501,0.162709,-0.069788,-0.078782,0.102894,-0.430854) * L0_5 + mat4(-0.043572,-0.024725,-0.413640,-0.018274,0.026694,-0.227589,-0.099066,-0.009009,0.225720,0.468949,0.267419,-0.221371,0.140157,-0.234433,-0.231714,0.034521) * L0_6 + mat4(-0.209353,0.382460,-0.211033,0.262643,0.321461,0.012607,0.157150,-0.144853,-0.193536,-0.087469,0.316146,0.096932,0.245359,-0.146377,0.282524,-0.004833) * L0_7 + mat4(-0.048564,0.082188,-0.215218,0.195701,-0.391263,-0.130717,-0.269609,0.358051,-0.091576,0.076333,0.041690,-0.003597,-0.244280,0.323837,-0.079644,0.120361) * L0_8 + mat4(-0.293755,-0.033534,-0.078694,-0.124846,0.067632,-0.100282,0.030437,0.091977,-0.021513,0.154746,-0.045402,0.067475,0.074829,-0.012743,0.044422,-0.259555) * L0_9 + mat4(-0.112213,0.029991,0.067074,0.106884,-0.366218,0.436334,-0.047674,-0.190808,0.000154,-0.146203,0.053882,-0.231946,-0.249156,-0.119572,-0.055930,0.130651) * L0_10 + mat4(0.196164,-0.282091,0.044528,0.097896,-0.068210,0.090420,0.006272,-0.127276,-0.119149,0.199802,0.051740,0.206780,-0.043280,0.024100,-0.367876,0.066388) * L0_11 + mat4(0.118385,-0.128975,-0.129136,-0.077159,-0.148426,0.111363,-0.014267,0.107661,-0.047630,0.004224,0.182675,-0.036966,0.246990,0.271294,0.129947,0.075879) * L0_12 + mat4(-0.145125,0.251213,-0.056815,-0.167216,-0.262517,0.061388,-0.045825,-0.147577,0.018533,-0.215854,-0.136881,-0.260376,-0.178146,0.229286,-0.062028,0.103085) * L0_13 + mat4(-0.363448,0.109464,-0.000168,-0.028226,-0.052161,-0.039212,0.096434,0.111129,0.004887,-0.295730,0.277975,-0.268472,-0.375574,-0.117299,0.164767,0.012188) * L0_14 + mat4(0.093755,-0.243463,0.275128,-0.170154,-0.328836,-0.108981,-0.115101,0.284349,0.230083,0.333221,0.297362,-0.093193,-0.106623,0.200033,-0.285010,0.351120) * L0_15 + vec4(0.374942,0.068544,-0.095049,0.133210)));\nvec4 L1_1 = sin((mat4(0.416174,0.108844,0.070741,-0.013145,0.321120,0.238452,-0.027940,-0.146975,-0.308700,0.439954,-0.210667,-0.101603,0.314582,0.250301,0.079617,0.216898) * L0_0 + mat4(-0.392228,0.133390,-0.173183,-0.254506,0.127397,-0.391347,0.107987,0.059874,0.030834,-0.092019,0.123606,0.131882,0.029764,0.122939,0.193484,0.243735) * L0_1 + mat4(-0.071708,-0.319634,-0.175777,-0.072369,0.186598,0.179411,-0.214177,0.183030,0.282592,-0.086091,-0.113992,0.248471,0.109031,-0.217722,-0.256816,-0.049481) * L0_2 + mat4(-0.018261,0.003002,0.108991,0.144017,-0.176640,-0.045818,-0.132960,-0.193334,-0.083005,0.135738,-0.065300,-0.158762,0.221387,-0.119003,0.093999,0.134972) * L0_3 + mat4(0.211317,0.225520,0.244739,0.071126,0.103330,-0.038883,0.486864,-0.155084,0.025225,-0.129109,-0.376452,-0.075228,-0.033240,-0.326263,-0.161677,0.321952) * L0_4 + mat4(0.234291,0.169846,0.304286,0.336990,0.251492,-0.213340,0.259700,0.035666,-0.047202,0.012702,-0.042122,-0.160810,-0.262567,0.562024,-0.243766,-0.294246) * L0_5 + mat4(-0.350731,0.180207,-0.132801,-0.220707,-0.194239,-0.082142,-0.002187,-0.016537,0.019630,0.170672,0.253676,-0.164191,-0.372436,0.120097,-0.101588,0.162012) * L0_6 + mat4(-0.311920,0.081778,0.028452,-0.106556,-0.246688,-0.283674,-0.122612,-0.457804,0.150725,-0.302952,-0.109730,-0.274521,0.138116,0.276502,0.364112,-0.085353) * L0_7 + mat4(0.064218,-0.042120,-0.191477,-0.241239,-0.145200,-0.117074,-0.032890,-0.105314,0.052347,0.112013,-0.382393,-0.184063,-0.059608,0.129443,0.120844,0.124121) * L0_8 + mat4(-0.062962,0.054364,-0.001888,0.201321,0.089419,0.152531,0.325041,0.239041,0.161179,0.152038,0.235864,-0.079095,0.039318,-0.212339,0.071636,-0.186029) * L0_9 + mat4(0.190211,-0.313305,-0.256024,-0.092914,0.123918,-0.645147,0.056064,0.246632,-0.365795,-0.176363,0.323223,0.136673,0.061113,-0.202992,-0.188852,0.080022) * L0_10 + mat4(0.335165,0.160424,0.370466,-0.076250,0.246627,-0.053416,0.186759,-0.221613,-0.083086,-0.311930,0.042976,0.042991,-0.376748,0.146102,-0.162559,-0.094149) * L0_11 + mat4(0.345043,-0.116795,0.074974,-0.168072,-0.188206,-0.033517,0.051044,-0.082491,0.063495,0.038349,-0.058473,0.162746,-0.124071,0.043234,-0.005702,0.162618) * L0_12 + mat4(-0.151620,0.008549,-0.052971,0.318200,-0.271901,0.200773,-0.250108,0.214654,-0.200740,-0.045644,-0.024623,-0.315782,0.317738,0.024025,0.104352,0.314840) * L0_13 + mat4(0.039077,0.151956,0.058422,0.174087,-0.277510,0.216461,0.299111,0.247729,0.235792,-0.012547,0.036203,-0.010311,0.077612,-0.045677,-0.314742,0.237047) * L0_14 + mat4(0.301944,0.254836,0.025927,0.031919,0.011200,0.168762,0.152396,-0.021122,-0.171294,0.095820,-0.285470,0.056785,0.050149,0.167235,-0.103618,0.024085) * L0_15 + vec4(0.088070,0.225287,0.113050,0.231221)));\nvec4 L1_2 = sin((mat4(0.056753,0.093393,0.034912,-0.049719,-0.154506,-0.033501,-0.054385,0.206688,0.472436,-0.083406,-0.486744,0.440574,-0.342527,0.023258,0.088796,0.267656) * L0_0 + mat4(0.090977,0.235386,0.438223,0.067289,-0.415425,0.285246,0.260872,-0.090098,-0.127958,0.173395,0.106704,0.223350,0.463907,0.269628,-0.010339,-0.237030) * L0_1 + mat4(0.116725,-0.112803,0.236550,-0.256111,-0.109990,0.263934,0.105761,0.083718,0.040008,0.189313,0.240085,0.115704,-0.075223,-0.092969,0.181232,-0.173177) * L0_2 + mat4(-0.382234,-0.161059,-0.172749,-0.151751,-0.182011,-0.159130,0.263203,0.033321,0.019694,0.162332,-0.300016,0.072597,-0.230210,0.294824,-0.263676,-0.119752) * L0_3 + mat4(0.201355,0.431370,0.202958,-0.450456,-0.069850,-0.025501,-0.132534,-0.012721,0.111273,0.008832,-0.052354,-0.016466,-0.312241,0.031781,0.054057,-0.226147) * L0_4 + mat4(-0.156210,0.164915,0.169946,0.074919,0.057486,0.176795,-0.044140,0.251694,-0.149434,-0.171925,-0.216763,-0.182451,-0.146412,-0.216705,-0.210467,-0.035693) * L0_5 + mat4(-0.090954,-0.161740,0.262728,0.112112,0.270613,-0.120942,0.119014,0.076794,0.223541,0.024312,-0.185331,0.167715,0.375279,-0.172806,0.355587,0.262670) * L0_6 + mat4(-0.240948,0.356309,0.192133,0.041741,-0.105407,-0.004059,-0.389599,-0.180390,-0.146616,0.014922,-0.134102,-0.104062,0.217720,-0.160227,-0.060432,0.334294) * L0_7 + mat4(-0.002410,-0.176605,-0.154124,0.085241,-0.129738,0.402126,-0.048842,-0.041482,0.108233,0.216205,-0.037570,0.203991,-0.083452,-0.350603,-0.057323,0.084282) * L0_8 + mat4(0.137188,0.114184,0.220220,0.227481,-0.220117,0.150531,0.049223,-0.122457,-0.032686,-0.036571,0.015259,0.018335,-0.163034,-0.056451,-0.009678,-0.170172) * L0_9 + mat4(-0.151079,0.172750,0.126625,0.006375,-0.410479,0.121506,-0.386000,0.378877,-0.017287,0.136948,0.336232,0.094879,-0.162352,0.320630,0.157392,-0.217134) * L0_10 + mat4(0.200971,0.132926,0.067941,-0.342582,-0.108565,0.089992,-0.023011,-0.068267,-0.030376,0.060913,0.047971,-0.124955,-0.145322,-0.218715,0.134819,-0.082562) * L0_11 + mat4(0.013297,0.293319,0.136876,-0.160665,0.199941,0.158111,-0.011518,0.210009,0.272777,-0.166394,0.009310,0.143152,0.225723,0.106092,-0.083140,0.059589) * L0_12 + mat4(-0.037035,0.350259,-0.161028,0.196458,-0.335524,-0.275242,-0.110125,0.282198,0.241572,0.019242,-0.316171,0.081572,-0.274479,-0.095814,0.133559,0.278998) * L0_13 + mat4(0.151072,0.180820,-0.201927,0.107326,-0.154550,-0.075004,0.095457,-0.013111,0.015226,-0.154720,0.087599,-0.044498,-0.238604,0.299053,-0.184489,-0.165183) * L0_14 + mat4(0.007882,-0.240596,0.442913,-0.140230,-0.213012,-0.085552,-0.269097,-0.163723,-0.131963,0.004610,-0.227834,-0.031000,0.083309,-0.221340,-0.252919,0.051838) * L0_15 + vec4(0.187464,0.122707,-0.179110,-0.032392)));\nvec4 L1_3 = sin((mat4(-0.024607,0.167358,-0.030407,0.303024,-0.058898,0.182313,0.080045,-0.158528,0.179777,0.263431,0.384778,0.114091,0.379839,0.154802,0.179318,0.226572) * L0_0 + mat4(-0.310437,0.094720,0.008504,0.419574,0.350810,-0.198281,0.252106,0.257014,-0.329132,0.161199,-0.179219,-0.149211,-0.314297,-0.106042,-0.179620,0.062185) * L0_1 + mat4(-0.173290,-0.052976,-0.306601,-0.095108,0.218403,0.246415,-0.040973,-0.003296,-0.214763,0.126656,0.244546,-0.038630,-0.121257,-0.258821,-0.312431,-0.099650) * L0_2 + mat4(0.113174,-0.097903,0.126649,0.117433,-0.445086,0.137007,0.332210,-0.437520,0.193382,0.135198,-0.264156,-0.090827,0.130941,0.130133,-0.065131,0.423936) * L0_3 + mat4(-0.209956,-0.186630,-0.253872,-0.221200,-0.278531,0.123090,-0.234953,-0.224268,0.192740,-0.157650,-0.142464,0.225931,-0.102263,0.353674,-0.145101,0.007213) * L0_4 + mat4(0.008134,-0.168757,-0.027437,0.274285,0.144798,-0.219409,-0.181127,0.083631,0.231025,0.001269,-0.215824,0.047918,0.008450,-0.039874,-0.041998,-0.206694) * L0_5 + mat4(-0.343825,-0.059460,0.208204,-0.374883,0.176431,-0.160806,-0.265035,-0.314232,-0.203743,-0.200567,0.107025,-0.228631,-0.290532,-0.171629,0.171348,0.160310) * L0_6 + mat4(0.133781,-0.128019,-0.046968,-0.339267,0.135668,0.443840,-0.088081,0.106834,0.158125,0.096732,0.044248,-0.205451,-0.120462,0.004650,0.152820,-0.222476) * L0_7 + mat4(0.135621,0.067686,-0.097783,-0.209943,0.112285,-0.298242,-0.088472,-0.101857,0.073249,0.320011,0.103772,-0.212388,0.132101,0.345263,-0.006181,-0.053078) * L0_8 + mat4(0.331290,-0.118219,0.286671,0.145644,-0.029583,0.220317,-0.077725,0.003955,-0.256007,0.334877,0.231125,0.064754,-0.144500,-0.152504,0.006045,0.102354) * L0_9 + mat4(0.041480,-0.212869,-0.069092,-0.056380,0.556177,0.325510,-0.129449,0.002863,-0.397487,0.301457,-0.326689,-0.252689,0.263050,0.318523,0.220567,0.175142) * L0_10 + mat4(-0.029096,-0.263276,0.025542,0.033583,-0.151591,-0.030382,0.112745,0.066517,0.045861,0.079602,0.136805,0.126841,-0.133556,0.231272,0.021290,-0.138937) * L0_11 + mat4(0.127344,-0.056107,-0.147759,0.292541,-0.127627,-0.028948,0.050792,0.131588,-0.221680,-0.001456,-0.092687,0.023267,-0.023976,0.035835,-0.009393,-0.170557) * L0_12 + mat4(0.012685,0.059552,-0.250571,0.064747,-0.006336,-0.258583,0.019132,0.153616,-0.016440,-0.104951,0.304923,-0.057970,-0.200023,-0.051179,0.324439,0.028716) * L0_13 + mat4(-0.048464,-0.036723,0.225946,-0.011334,-0.168863,-0.077729,0.160435,0.107364,0.192604,-0.183157,0.352434,0.118689,0.232334,-0.122940,0.133235,-0.200748) * L0_14 + mat4(-0.461382,0.130258,-0.176264,0.005930,-0.105321,-0.076385,0.028562,0.086936,0.230706,-0.229572,0.303522,-0.409382,0.150250,-0.127604,-0.006758,-0.016685) * L0_15 + vec4(-0.085553,0.031078,0.165341,0.133298)));\nvec4 L1_4 = sin((mat4(-0.237118,-0.015394,-0.040441,0.112466,0.296671,0.262847,-0.054586,0.138619,-0.090065,0.297337,0.054497,0.227548,0.129675,0.007466,0.102971,0.167556) * L0_0 + mat4(-0.186024,0.120268,0.329100,-0.129602,-0.088750,-0.049933,0.066254,-0.153960,-0.043894,0.329184,0.291224,0.050226,-0.068099,0.262583,-0.002879,0.141526) * L0_1 + mat4(-0.099639,-0.019696,0.240362,-0.067805,0.143170,-0.043732,0.397638,0.264414,0.104138,0.080855,0.132072,-0.044739,-0.106362,0.000531,0.210350,0.164550) * L0_2 + mat4(0.181675,-0.215615,0.062376,0.406616,0.005049,-0.172138,-0.006035,-0.070759,-0.203556,-0.136468,-0.059373,-0.048234,0.368034,0.378269,0.185054,0.199989) * L0_3 + mat4(-0.172086,-0.032739,-0.332660,-0.100983,-0.125159,-0.233547,0.013939,-0.013526,-0.186788,-0.238040,0.362746,-0.073297,-0.069270,-0.124571,-0.083715,0.314583) * L0_4 + mat4(-0.028909,0.048904,-0.090017,-0.208076,-0.237348,0.090939,-0.095397,-0.139013,0.074640,0.165883,-0.202822,0.333089,0.096814,-0.030437,0.217319,0.262853) * L0_5 + mat4(0.002385,-0.133511,-0.019995,0.123975,-0.078400,0.090724,0.098051,-0.270676,0.342990,0.139143,0.319224,0.026223,-0.142061,-0.293185,-0.194066,0.198662) * L0_6 + mat4(-0.032771,-0.221568,-0.160029,0.107382,0.281977,-0.433399,-0.073140,0.078622,0.110188,-0.093909,0.064928,-0.068832,0.160978,0.353664,0.113475,-0.148043) * L0_7 + mat4(0.033314,0.219546,-0.338176,0.138340,0.129197,-0.167031,-0.213564,-0.217515,-0.018574,-0.079262,0.053507,-0.118526,0.139721,0.057080,-0.063441,-0.074880) * L0_8 + mat4(-0.189037,0.235551,-0.368326,-0.153284,-0.034308,0.314891,-0.177626,-0.016809,0.054370,-0.006428,-0.061967,-0.291562,0.373968,0.112838,-0.100208,-0.093992) * L0_9 + mat4(0.039227,-0.048338,-0.336493,-0.178363,0.128061,-0.106668,-0.178787,-0.081151,-0.301454,-0.022466,0.254644,-0.028425,-0.013379,-0.166880,-0.104346,-0.205627) * L0_10 + mat4(0.327597,0.138995,-0.173164,-0.074657,0.100573,-0.069924,-0.006225,-0.059011,0.052373,0.207467,0.011746,0.198494,-0.366980,-0.188121,0.218358,0.362477) * L0_11 + mat4(0.238537,-0.105109,-0.192811,0.014553,-0.202253,-0.000752,-0.063418,-0.007066,-0.052391,-0.086604,-0.035139,0.041605,0.116853,0.035874,0.112071,-0.074762) * L0_12 + mat4(0.286406,-0.177575,0.184602,0.054910,0.043425,0.172308,-0.070245,0.081462,0.172810,-0.327990,0.278003,0.040289,0.179526,-0.152590,0.033318,-0.108508) * L0_13 + mat4(0.032704,-0.020675,-0.171893,-0.337126,-0.126631,0.039275,0.273573,-0.365276,0.073797,-0.113835,-0.011664,-0.065407,-0.260427,-0.255055,-0.199025,-0.136244) * L0_14 + mat4(0.063251,0.429194,0.174177,-0.052204,-0.436696,0.232254,-0.454708,-0.143566,0.442426,-0.296548,0.032605,0.225756,-0.096302,-0.135156,-0.449087,0.194948) * L0_15 + vec4(-0.003622,-0.054128,0.265337,-0.169907)));\nvec4 L1_5 = sin((mat4(-0.354217,0.205930,0.286439,0.179477,-0.078131,0.063160,-0.136965,-0.135289,-0.060236,0.251709,-0.048755,0.105108,-0.185804,0.257949,0.085608,-0.117750) * L0_0 + mat4(-0.288262,0.059009,-0.176378,-0.299424,-0.186302,-0.218562,0.257921,0.019879,0.053521,0.137119,0.218614,0.074288,-0.334817,0.371966,-0.285028,0.118665) * L0_1 + mat4(-0.176661,0.033740,0.040945,-0.092536,0.262975,-0.044405,-0.034444,-0.156596,-0.157624,0.016280,0.085695,0.066530,0.097087,0.038497,-0.267232,0.054996) * L0_2 + mat4(-0.203279,0.125958,-0.222709,-0.141748,0.219631,-0.334622,0.013505,0.057569,0.009167,-0.349448,0.143964,-0.433222,0.266560,0.104031,-0.268775,-0.145162) * L0_3 + mat4(-0.237673,0.147427,-0.028083,0.037558,0.229052,0.075485,0.340250,0.293199,0.121087,-0.208729,-0.092336,-0.113231,-0.101068,-0.320895,0.072759,-0.072143) * L0_4 + mat4(-0.266773,-0.209360,0.277995,0.090521,-0.266593,-0.078439,0.208560,-0.302579,-0.069293,0.277197,0.039446,0.221197,-0.153528,-0.298542,0.112985,-0.036355) * L0_5 + mat4(0.191471,-0.339175,-0.248312,-0.137700,-0.087396,-0.102528,-0.094078,0.200219,-0.074957,0.034026,0.038076,0.173566,0.037759,-0.156942,-0.427451,0.053682) * L0_6 + mat4(-0.093688,-0.008942,-0.232191,-0.147381,0.208735,0.288502,0.141338,-0.159715,0.034311,-0.378779,-0.095908,-0.233691,-0.077228,-0.242185,-0.068046,-0.290230) * L0_7 + mat4(-0.164970,-0.048264,-0.208531,0.352861,0.071290,0.054558,-0.174027,0.180372,-0.320418,-0.127573,0.000427,-0.071506,-0.182187,-0.094483,0.237727,0.069480) * L0_8 + mat4(0.143902,0.212963,-0.007292,-0.039049,0.106400,0.236739,0.240033,-0.058910,0.000614,-0.340166,-0.081872,0.358104,0.108598,0.326473,-0.198447,0.369694) * L0_9 + mat4(0.071856,0.062414,-0.197533,0.335012,0.140656,0.292118,0.305387,-0.081139,-0.270092,0.040816,0.261241,-0.181498,0.051825,0.081978,0.290542,-0.152749) * L0_10 + mat4(-0.066837,0.299174,-0.057780,-0.256386,0.065415,-0.068024,0.019409,0.296148,-0.129434,-0.097831,0.104934,0.117307,-0.323796,0.232510,0.206757,0.171159) * L0_11 + mat4(0.084883,0.397067,0.035143,0.048741,-0.099631,0.324026,-0.095368,-0.046524,0.091414,0.149207,-0.061584,0.045926,0.146642,-0.156290,-0.143073,0.231873) * L0_12 + mat4(0.191577,-0.158400,-0.144003,-0.439510,-0.298029,-0.143887,-0.170703,-0.104562,-0.405862,-0.129614,0.088684,0.224021,0.166291,0.094452,0.092045,-0.055730) * L0_13 + mat4(-0.023885,-0.186590,0.100459,-0.324129,-0.036061,0.172524,-0.033701,-0.239216,0.190723,-0.062352,0.136802,0.121070,-0.075491,0.123765,0.340825,-0.020729) * L0_14 + mat4(-0.000370,-0.079253,-0.007792,0.025974,-0.518447,0.303261,0.259251,0.198357,-0.206620,0.287349,0.254588,0.159178,0.275766,0.035194,0.064124,0.026842) * L0_15 + vec4(0.113541,-0.272608,0.135548,0.036757)));\nvec4 L1_6 = sin((mat4(0.189692,0.280526,-0.319127,0.081117,-0.295363,-0.145356,0.046071,-0.103001,-0.335539,0.340743,-0.110977,-0.326677,-0.313559,0.281230,-0.326700,-0.008860) * L0_0 + mat4(0.061970,0.400429,0.126500,-0.330317,-0.017165,0.160077,0.350640,0.133652,-0.285043,0.114965,0.471344,-0.119181,0.350447,0.005488,0.171541,-0.124670) * L0_1 + mat4(0.256543,0.200899,0.048642,-0.038775,-0.129947,0.393514,-0.047340,0.087150,-0.154710,0.069927,0.155552,-0.203937,0.319869,-0.247273,0.167229,0.052761) * L0_2 + mat4(-0.077176,-0.041218,-0.173672,0.138420,-0.286560,0.007698,-0.162574,0.130074,-0.060697,0.011154,-0.039729,0.141905,0.010618,-0.254436,0.232306,0.205446) * L0_3 + mat4(-0.005172,0.235959,0.269531,0.203869,-0.216904,-0.262498,0.171645,0.087135,0.224348,0.109242,-0.105346,0.057913,0.099081,-0.193366,0.036429,-0.156523) * L0_4 + mat4(-0.000131,-0.160151,-0.178946,0.255500,0.186722,-0.083505,-0.245309,0.090961,-0.355502,0.250194,-0.216465,0.267953,-0.510760,0.147638,-0.360144,-0.212544) * L0_5 + mat4(-0.069129,0.052902,-0.042690,0.213856,-0.124437,0.353869,0.156218,0.123476,-0.208148,0.118436,0.463602,0.240168,-0.047956,0.218871,-0.235386,-0.194885) * L0_6 + mat4(-0.191398,0.171018,-0.003995,0.083682,-0.280621,-0.284535,0.174685,0.186364,-0.133160,0.096112,0.051466,-0.322410,0.305908,-0.142342,0.054020,0.297840) * L0_7 + mat4(-0.358954,0.095232,0.110546,0.055381,0.146274,-0.181651,0.145771,-0.088418,-0.305532,0.260568,-0.047148,-0.049570,-0.251339,0.219999,-0.132852,0.089274) * L0_8 + mat4(0.239638,0.369713,0.084719,0.033064,-0.056893,0.268827,-0.030644,-0.067139,-0.069514,0.143442,0.141754,-0.107321,-0.037102,-0.012028,0.234321,-0.401324) * L0_9 + mat4(-0.084955,0.312694,0.204231,0.097264,0.547635,0.232523,-0.049707,-0.076546,-0.065117,-0.095367,0.322138,-0.238671,-0.195226,0.324988,-0.221057,0.023824) * L0_10 + mat4(-0.356140,-0.161542,-0.233836,-0.377283,0.013452,-0.004534,0.064823,-0.237075,0.032126,-0.082080,0.028355,-0.116609,0.119871,0.064290,0.324871,0.210073) * L0_11 + mat4(0.268901,-0.081083,0.289731,0.235344,-0.157728,0.222289,0.042092,0.258794,-0.123993,-0.272562,0.089070,0.066445,0.081195,-0.225389,-0.069337,0.222536) * L0_12 + mat4(0.185311,0.334549,-0.409530,-0.167367,0.250783,-0.238422,-0.008963,-0.021205,-0.474078,-0.014423,0.022184,-0.343744,0.130767,-0.053001,-0.186416,0.311588) * L0_13 + mat4(-0.020168,0.191739,-0.167937,0.049886,0.271208,0.324484,-0.024724,0.231463,-0.036223,-0.219361,0.250600,-0.317962,-0.066331,0.458955,0.011782,0.335311) * L0_14 + mat4(-0.030684,0.118026,-0.300712,0.005482,0.168243,0.115361,-0.250503,0.161389,0.104884,0.084030,-0.227616,0.303228,0.039056,-0.011855,-0.255455,-0.168459) * L0_15 + vec4(-0.114031,-0.159852,0.233517,0.082509)));\nvec4 L1_7 = sin((mat4(-0.009156,-0.132251,0.378724,-0.021896,-0.155237,0.155302,0.006847,0.065692,0.125602,-0.463635,0.448735,0.064045,-0.085666,0.099855,0.001719,0.344294) * L0_0 + mat4(0.186478,-0.375604,0.080630,-0.110491,0.323597,0.054411,-0.481314,0.333264,0.036220,0.308627,-0.165919,0.325577,-0.178769,0.043292,0.131537,0.153781) * L0_1 + mat4(0.200011,0.100488,0.240216,0.181413,-0.066449,-0.138411,0.009957,0.127758,0.111030,0.001397,0.063431,0.227687,0.245635,0.029199,0.024162,-0.293585) * L0_2 + mat4(-0.071188,0.003335,0.006642,0.064211,-0.001221,-0.340826,-0.216519,-0.129901,0.008190,-0.094989,0.172877,-0.159807,-0.298416,-0.024748,0.253990,0.254856) * L0_3 + mat4(-0.373351,-0.004575,-0.144947,0.008064,-0.142989,-0.325484,0.017636,-0.228507,0.207796,-0.029816,0.172400,0.148038,0.122251,0.016440,-0.107146,0.050899) * L0_4 + mat4(-0.086806,-0.130889,0.125068,0.143024,-0.186442,-0.047246,-0.025412,-0.157216,0.026207,0.078204,-0.066250,0.150699,-0.332222,-0.010297,-0.381904,0.176548) * L0_5 + mat4(0.033355,-0.114797,-0.141629,0.034156,-0.098837,-0.061544,-0.183744,0.097641,-0.482176,0.401787,-0.280975,-0.025607,0.020721,0.025280,0.148281,0.085954) * L0_6 + mat4(0.187469,-0.224279,-0.453188,0.202837,-0.087437,0.091491,0.144777,-0.153038,0.074587,-0.042291,-0.216021,0.107033,0.137980,-0.004138,0.169561,-0.226237) * L0_7 + mat4(0.254927,-0.110807,0.171191,0.407624,0.093497,-0.012031,-0.064156,0.030231,0.109903,0.109672,0.171147,0.212218,-0.169717,0.001878,0.151008,0.053886) * L0_8 + mat4(0.048714,-0.074271,-0.458728,0.168546,-0.026019,-0.129587,-0.145716,0.043301,0.240282,0.230857,-0.164160,-0.037199,0.045721,0.118528,-0.208513,0.167439) * L0_9 + mat4(0.106357,-0.055324,-0.358493,0.359895,0.103256,-0.303547,-0.101022,0.186728,-0.040057,0.409910,-0.057624,0.245272,-0.016096,-0.091501,0.078952,-0.102905) * L0_10 + mat4(0.227144,-0.198285,0.184285,0.186436,0.068475,0.266162,-0.154500,0.045478,0.292764,0.321224,0.142039,0.311291,0.073560,-0.061755,0.211411,0.061743) * L0_11 + mat4(-0.043133,0.199847,-0.084319,0.277948,-0.200631,-0.156978,-0.113788,-0.050849,-0.149122,0.041240,0.147433,0.135251,-0.069934,0.041953,-0.046646,0.077594) * L0_12 + mat4(-0.192160,-0.073408,0.021691,-0.269274,-0.280622,-0.071494,-0.078901,0.253124,0.415573,0.198610,0.328479,-0.066837,-0.279379,0.184736,0.007107,0.194758) * L0_13 + mat4(0.099623,0.027579,0.041840,-0.338467,0.370114,-0.226550,0.114443,-0.242249,-0.159549,-0.045941,0.208404,0.069772,0.129775,0.137710,0.180842,-0.148434) * L0_14 + mat4(-0.314899,-0.418366,-0.178476,-0.193309,0.059771,0.083572,-0.118597,-0.177729,-0.043425,-0.248867,0.560742,-0.531913,0.385780,-0.107250,-0.334735,-0.062112) * L0_15 + vec4(0.247918,0.297549,-0.146498,0.068152)));\nvec4 L1_8 = sin((mat4(0.201139,-0.213087,0.022345,-0.247664,0.190623,-0.066225,-0.153414,0.354093,0.124555,0.199022,-0.288101,-0.214761,-0.348285,-0.145205,0.030210,-0.156589) * L0_0 + mat4(-0.130903,0.442508,-0.043812,-0.255343,0.385802,0.087205,-0.057884,-0.044948,-0.077144,0.025924,-0.027234,0.152411,0.088758,-0.105982,-0.113374,0.095896) * L0_1 + mat4(-0.005535,0.091404,-0.102138,-0.128789,0.211841,-0.096335,-0.294915,0.064038,-0.272583,-0.064139,-0.078925,0.157420,0.129887,0.153491,0.076178,-0.175071) * L0_2 + mat4(-0.226961,0.116901,0.084050,0.133212,-0.273299,0.086779,-0.221828,0.001117,0.190816,-0.048647,-0.095648,0.237933,0.001410,0.333366,-0.052143,0.076022) * L0_3 + mat4(0.103223,-0.123674,-0.479036,-0.226056,0.167669,0.195627,-0.062581,0.071942,0.081207,-0.132259,0.161730,-0.280773,-0.178929,0.226011,0.277480,0.044386) * L0_4 + mat4(-0.249095,-0.106061,-0.074268,-0.114447,0.050906,-0.196641,-0.030098,-0.248648,-0.147504,-0.512768,0.007756,0.111013,-0.285192,-0.119190,-0.011417,-0.296660) * L0_5 + mat4(-0.038732,0.198135,0.079727,0.261591,0.152401,-0.048562,-0.146972,0.194186,0.360346,0.347882,0.221583,0.231730,-0.256747,0.118620,-0.204335,0.136758) * L0_6 + mat4(-0.085503,-0.149279,-0.231860,0.082125,0.278827,-0.375162,0.380897,-0.078933,0.104056,0.232416,-0.158447,0.072195,0.044905,-0.030565,-0.132218,-0.334365) * L0_7 + mat4(0.305600,-0.264857,-0.042078,0.135062,0.329226,0.549814,-0.011722,0.228104,-0.173314,-0.119151,0.091486,0.174970,-0.068324,0.154600,-0.347074,-0.107994) * L0_8 + mat4(-0.288273,0.220334,0.032936,-0.106796,-0.226857,-0.182508,0.027585,0.281370,0.261366,-0.026486,0.124453,-0.055064,0.085437,0.214773,0.127607,-0.177063) * L0_9 + mat4(-0.239876,-0.029840,-0.403972,0.001756,0.253166,0.064361,0.216837,-0.155168,0.006414,0.230886,-0.188917,0.135065,-0.016131,0.014231,0.098736,0.053888) * L0_10 + mat4(0.101544,-0.686077,0.152301,-0.078819,0.269475,-0.030478,-0.088352,-0.017771,-0.078629,-0.068279,-0.150269,-0.026750,-0.303000,0.162190,-0.315327,0.038861) * L0_11 + mat4(0.119773,0.144131,0.073178,-0.029769,-0.036690,-0.275254,0.002475,0.161820,-0.064372,0.035896,0.221187,0.146985,0.220144,0.167990,0.144383,0.253190) * L0_12 + mat4(-0.225423,-0.253996,-0.043871,-0.183476,-0.261408,0.420185,-0.186915,0.233387,0.420854,-0.197838,0.213716,-0.264141,-0.138830,-0.095265,-0.153838,0.172900) * L0_13 + mat4(0.128269,-0.206712,-0.255324,-0.159346,-0.079065,-0.070389,-0.215786,-0.029335,-0.139516,0.156742,-0.107016,-0.073410,0.144544,-0.039455,-0.191892,0.251248) * L0_14 + mat4(-0.401222,-0.102269,-0.329609,0.160450,0.105527,-0.258586,0.154456,0.150583,0.245919,0.031424,0.567535,0.201902,-0.164174,-0.238268,0.125131,0.218182) * L0_15 + vec4(0.168890,0.114928,-0.142292,0.243970)));\nvec4 L1_9 = sin((mat4(0.161765,-0.146131,-0.054624,-0.073218,-0.244629,-0.066669,-0.176603,0.069798,0.111551,-0.289296,0.301540,-0.213498,-0.184968,0.290191,-0.001385,0.001674) * L0_0 + mat4(-0.427454,-0.432649,-0.378311,0.452889,-0.070639,-0.214684,-0.195120,0.251142,-0.177832,-0.311644,0.008688,0.060940,-0.157132,-0.317334,-0.103247,-0.095762) * L0_1 + mat4(0.324688,0.001535,-0.188224,-0.252786,-0.030756,-0.187583,0.151166,0.264047,0.000044,-0.118322,-0.210471,0.149655,0.026067,0.067183,-0.034208,-0.226905) * L0_2 + mat4(-0.299429,0.047350,-0.141622,-0.146260,0.242182,-0.176440,-0.303294,-0.158329,0.138619,0.259480,0.201989,-0.249687,-0.310032,0.366895,0.012623,-0.156295) * L0_3 + mat4(-0.013188,0.266825,-0.289432,0.153805,-0.156335,0.050811,-0.064685,0.311363,0.264889,0.240591,0.093706,-0.120620,-0.215458,-0.134812,-0.059414,0.186668) * L0_4 + mat4(-0.526485,-0.045203,0.036577,-0.262214,-0.059562,-0.182380,-0.021441,-0.203418,-0.056384,0.031953,0.318540,-0.116389,-0.210412,0.193547,0.251379,-0.274216) * L0_5 + mat4(0.216427,-0.102463,-0.174538,-0.143002,0.022456,-0.095741,0.028732,0.054893,0.129898,0.330172,0.117010,0.058619,0.029006,0.445826,0.129589,-0.171095) * L0_6 + mat4(-0.190202,0.166138,-0.053370,0.129289,-0.389933,0.126714,0.153760,-0.059090,-0.087576,0.044141,0.188648,-0.263531,0.175928,0.069363,-0.180403,-0.034010) * L0_7 + mat4(-0.399953,-0.067816,-0.301174,-0.063924,-0.260172,-0.035665,0.075035,-0.073920,-0.053545,0.047951,0.027722,-0.167037,-0.124246,0.057304,-0.195901,-0.019745) * L0_8 + mat4(-0.160303,0.102490,-0.188737,0.129111,-0.179766,0.061706,0.159979,-0.008246,-0.020488,0.066503,0.110785,-0.019677,-0.107391,-0.221385,0.172484,-0.135028) * L0_9 + mat4(-0.065188,0.246538,0.163775,-0.032420,0.060172,0.184896,-0.148621,0.138658,-0.122624,-0.211214,0.142050,0.308997,-0.126832,-0.008051,-0.071130,0.035749) * L0_10 + mat4(-0.268229,0.043528,0.373766,0.032872,-0.031520,0.087094,0.127653,-0.113400,0.131441,-0.178441,0.156833,-0.013123,0.226346,-0.123557,-0.110252,0.152838) * L0_11 + mat4(0.000088,-0.052039,-0.063326,0.281797,-0.088599,0.080859,-0.146044,0.063079,-0.187623,-0.083045,-0.166529,-0.357796,-0.192387,0.089290,-0.376443,-0.214843) * L0_12 + mat4(-0.144450,-0.233545,-0.203986,-0.148013,0.164443,0.021318,-0.123940,0.182298,0.234983,-0.255652,0.194845,0.241473,-0.296098,-0.094030,0.046622,-0.252871) * L0_13 + mat4(-0.317333,0.129906,-0.107751,-0.241367,-0.397567,0.071458,-0.113617,-0.308880,-0.072173,-0.031779,-0.165478,0.002798,0.102387,-0.142744,-0.100842,0.024758) * L0_14 + mat4(0.009395,0.141683,0.220792,-0.068869,0.011427,0.184460,-0.065409,-0.478123,-0.001941,-0.427077,0.319551,0.580809,0.309884,0.086361,0.192772,-0.211098) * L0_15 + vec4(0.325929,-0.279012,-0.432531,0.269532)));\nvec4 L1_10 = sin((mat4(-0.104673,0.142456,-0.077163,0.310284,0.055908,-0.199753,-0.047923,-0.071409,-0.106217,0.256442,-0.029376,0.233671,-0.227656,0.081920,0.130247,0.138258) * L0_0 + mat4(0.049105,0.265921,0.197920,-0.241527,-0.178152,0.026008,-0.024687,-0.250946,0.280208,0.149618,-0.093795,-0.129501,0.098653,0.391356,0.270594,-0.044601) * L0_1 + mat4(0.066254,0.174986,-0.058623,-0.556483,0.109851,-0.082125,0.012320,-0.046466,0.175477,-0.217640,0.269705,0.107039,-0.172026,0.205369,0.151795,-0.115701) * L0_2 + mat4(-0.314675,0.037558,0.023293,0.522472,-0.140138,-0.309127,-0.013778,0.097788,-0.161363,0.087637,-0.275339,0.250026,-0.398800,0.269526,0.330411,0.167233) * L0_3 + mat4(0.008520,0.118312,-0.129840,0.183483,0.344354,-0.172879,0.142527,0.134492,-0.162687,-0.221012,-0.041303,-0.187141,-0.210588,0.230963,0.168072,-0.094816) * L0_4 + mat4(-0.214247,0.004814,0.031621,-0.113522,0.028399,-0.015663,-0.107205,0.205578,-0.220846,0.279652,0.264088,0.215167,-0.133245,0.028390,0.012212,0.125431) * L0_5 + mat4(-0.206092,-0.088849,0.090199,-0.158806,0.198375,-0.039664,0.091124,0.214744,0.312116,-0.144295,0.245609,-0.343064,-0.252459,0.010348,0.117083,0.229226) * L0_6 + mat4(-0.233980,0.130758,0.215338,0.265532,-0.302542,0.017094,0.148344,-0.001900,-0.211521,0.112972,0.024524,-0.085173,0.265902,0.129641,-0.016461,-0.223323) * L0_7 + mat4(-0.302198,0.100529,0.334436,0.131608,0.255224,-0.090975,-0.337239,-0.106436,-0.068001,-0.176200,0.101431,0.272326,-0.121227,-0.161166,-0.130238,-0.074588) * L0_8 + mat4(-0.153651,-0.168558,-0.208519,0.320823,0.140157,-0.006366,-0.240535,0.093494,0.286497,-0.213847,-0.110489,0.037161,-0.101204,0.192484,0.239568,-0.163075) * L0_9 + mat4(-0.181014,-0.187258,0.014507,0.124511,0.312382,-0.409297,0.139018,-0.077653,-0.107721,-0.045259,-0.082626,-0.004352,-0.257661,-0.225576,0.115842,0.263416) * L0_10 + mat4(-0.264719,-0.362051,-0.476281,-0.404076,0.209703,-0.055153,-0.147845,-0.188722,0.215441,0.209876,0.370921,0.134529,-0.010957,0.026387,-0.242558,0.170021) * L0_11 + mat4(-0.036523,-0.133636,-0.040631,-0.149039,0.011262,-0.176846,0.132153,0.104310,0.152087,0.213674,0.567243,0.061662,0.291131,0.272512,0.338117,0.038801) * L0_12 + mat4(-0.066352,0.025216,0.005291,0.023288,-0.184359,0.338808,0.214206,0.321780,-0.402066,0.084600,-0.199144,0.126558,-0.010509,0.161209,-0.045787,-0.106584) * L0_13 + mat4(-0.069849,-0.030990,0.050779,-0.039099,-0.175083,0.003977,-0.018019,0.178473,0.087922,0.073963,-0.165871,-0.052235,0.071238,-0.388380,-0.390648,-0.014094) * L0_14 + mat4(0.079833,0.013610,0.164195,-0.105410,0.088070,0.317622,0.053450,0.034165,-0.170461,0.219410,-0.255541,-0.378285,-0.093276,-0.077781,0.182764,-0.156602) * L0_15 + vec4(-0.131143,-0.165064,0.280231,-0.066894)));\nvec4 L1_11 = sin((mat4(-0.051910,-0.124792,0.135893,-0.190538,-0.021673,0.156936,-0.036955,0.156959,-0.159344,-0.106766,-0.191772,0.111969,0.225906,0.034357,-0.076596,0.381537) * L0_0 + mat4(0.117964,-0.033099,-0.352420,-0.017327,0.016437,-0.167246,-0.379497,0.022294,0.404790,-0.187449,-0.045013,0.043933,0.308623,0.158310,-0.148051,0.180428) * L0_1 + mat4(-0.468422,0.044930,0.109681,-0.319941,-0.201028,0.244931,0.149315,0.113282,-0.116417,0.064696,-0.086550,0.138604,-0.306334,-0.038759,-0.056239,-0.168904) * L0_2 + mat4(0.056881,-0.122652,0.274028,0.244210,-0.315778,0.158384,0.111951,-0.274163,0.030604,0.245814,0.116200,0.164697,0.085194,-0.342335,0.034528,-0.266461) * L0_3 + mat4(-0.154926,0.316581,-0.064503,0.165034,0.029225,0.081321,0.151948,-0.259693,-0.140993,0.076551,-0.004859,0.177703,0.010872,0.250811,-0.200298,-0.158007) * L0_4 + mat4(0.045954,0.144616,0.045939,-0.131015,0.165027,-0.174665,-0.082181,0.146504,-0.139107,0.018428,-0.191841,-0.059089,-0.139722,-0.268690,-0.426575,0.235706) * L0_5 + mat4(-0.098324,0.112982,0.253474,-0.299248,0.162432,-0.293130,0.036166,-0.213178,-0.098954,0.389355,0.235242,0.164827,0.078228,0.204534,-0.073635,-0.192091) * L0_6 + mat4(0.031494,-0.106194,-0.188931,-0.091511,0.565511,-0.098847,0.059838,-0.153506,0.223843,-0.012385,0.062374,0.048890,-0.087164,0.157139,-0.096425,0.234090) * L0_7 + mat4(-0.084022,0.322337,-0.159387,-0.043399,0.325966,0.017669,0.210227,-0.167587,0.202918,0.084870,0.115208,0.012595,0.058162,0.140831,-0.012660,0.055106) * L0_8 + mat4(0.150047,-0.030073,0.000437,-0.093120,0.070731,0.284825,0.289440,0.236252,0.019337,-0.147107,-0.217573,0.072004,0.134604,-0.294021,-0.142829,-0.032083) * L0_9 + mat4(-0.236088,-0.012790,-0.341639,-0.142926,-0.172031,0.331322,0.418749,-0.397367,0.074601,0.108208,0.069184,0.156735,-0.016983,-0.013521,-0.043196,0.014007) * L0_10 + mat4(0.091560,-0.083506,-0.146185,-0.223778,0.070827,-0.181660,-0.058082,-0.039999,0.213599,0.177501,-0.048691,-0.054609,-0.126130,-0.178724,0.232267,-0.001881) * L0_11 + mat4(-0.247465,-0.140584,0.008628,-0.014112,-0.175585,-0.290651,0.112213,0.032518,0.000784,0.360646,0.124766,0.131283,0.169308,-0.082485,0.002512,0.198921) * L0_12 + mat4(-0.408117,0.078215,0.284539,-0.287298,0.158294,0.179656,0.199330,0.194545,0.103120,-0.495920,-0.273166,-0.015688,-0.143707,0.176211,-0.153684,0.032881) * L0_13 + mat4(0.045530,-0.090344,-0.019912,-0.001214,-0.115024,0.117013,0.029308,-0.196421,0.135320,-0.199737,-0.107330,-0.149334,-0.216371,0.292340,0.030254,0.058187) * L0_14 + mat4(-0.420322,0.290755,-0.138433,0.455312,-0.324700,-0.126291,-0.041617,-0.122109,-0.207417,-0.202493,0.045058,0.451084,-0.194480,-0.006571,0.079389,-0.019719) * L0_15 + vec4(-0.102534,-0.062034,-0.291398,-0.237325)));\nvec4 L1_12 = sin((mat4(-0.088741,0.076892,-0.235371,-0.135427,0.137542,0.332339,-0.250971,-0.099871,-0.231720,-0.382974,-0.013556,-0.234869,-0.090073,0.108351,0.070960,-0.180351) * L0_0 + mat4(-0.129505,-0.142711,0.184251,0.118560,-0.013659,-0.094940,-0.124302,0.308710,0.217749,0.179227,-0.127882,-0.015797,-0.109726,-0.329954,-0.333083,0.267437) * L0_1 + mat4(-0.156570,-0.135110,0.246715,-0.028145,-0.028177,0.084757,-0.099439,0.012954,0.123726,-0.235061,-0.209827,0.043938,0.001605,-0.120968,-0.062409,-0.105973) * L0_2 + mat4(-0.351896,0.057046,-0.218303,-0.244219,-0.216958,-0.072306,-0.093254,0.224141,0.145384,0.010667,0.240266,-0.186605,-0.249086,-0.035648,0.078274,-0.307966) * L0_3 + mat4(0.104524,-0.079611,-0.292873,0.041763,0.021574,0.011765,-0.118043,-0.036248,-0.300806,-0.189776,0.015560,-0.016757,0.281014,-0.048487,0.167112,0.048433) * L0_4 + mat4(0.218921,0.151978,0.098561,0.044076,0.003916,-0.125944,0.037194,0.123020,-0.260729,0.218588,0.004416,0.267129,-0.545508,-0.252784,-0.190818,0.083641) * L0_5 + mat4(-0.256504,0.281594,-0.245077,0.129639,-0.268669,0.057609,-0.135501,0.172557,0.266250,-0.293685,0.134171,0.220464,0.185762,0.307006,-0.171773,-0.026925) * L0_6 + mat4(-0.001275,0.152429,-0.115550,0.215876,0.251159,0.013101,-0.220261,0.037203,0.072941,-0.126114,-0.106090,-0.181334,0.022411,0.208366,-0.064419,-0.197435) * L0_7 + mat4(-0.145745,-0.367416,-0.241711,0.040133,0.280128,0.106535,0.549448,-0.127827,-0.196767,-0.037368,0.106335,0.035068,-0.100901,-0.020838,0.139352,-0.081781) * L0_8 + mat4(-0.080581,-0.050550,0.021484,-0.215647,0.148731,-0.127950,-0.086835,-0.011578,-0.096158,-0.056989,-0.209224,-0.058526,0.001336,0.196038,-0.146017,0.224942) * L0_9 + mat4(-0.179565,0.193845,-0.245434,-0.098998,0.403672,0.300302,-0.119296,-0.003092,0.376798,0.011814,0.259784,-0.109260,-0.080237,-0.280971,0.170320,0.036643) * L0_10 + mat4(0.358557,0.237682,-0.091220,0.462570,0.149977,-0.294402,-0.176563,0.150974,0.167113,-0.106637,0.004154,-0.210651,0.143778,0.060733,0.257788,-0.207364) * L0_11 + mat4(0.292812,0.075209,-0.111542,0.226446,-0.174913,-0.095907,0.039024,0.163885,0.085490,-0.422640,-0.105476,-0.089138,0.057549,-0.058641,-0.047323,0.238114) * L0_12 + mat4(0.250176,0.007104,0.319357,-0.072033,-0.207643,0.195190,0.139743,-0.156453,-0.167369,0.221510,-0.089637,0.307436,0.368932,-0.214406,0.147982,-0.053232) * L0_13 + mat4(0.021133,0.027546,0.111649,-0.102744,0.116342,0.048036,-0.098551,-0.138884,-0.252252,-0.120384,-0.216024,-0.009133,0.072115,-0.096474,0.085320,-0.351455) * L0_14 + mat4(-0.414734,-0.334278,-0.273671,-0.240359,0.272832,-0.103789,0.007104,0.371367,-0.064819,-0.376521,0.497785,0.270261,-0.086077,0.190382,-0.152839,0.215178) * L0_15 + vec4(0.135097,0.071262,-0.374438,0.184642)));\nvec4 L1_13 = sin((mat4(-0.188568,0.113673,0.349267,0.410700,0.010490,-0.085940,0.178794,-0.086601,0.171112,0.314114,-0.182167,-0.531977,0.171744,-0.000580,0.004112,-0.183432) * L0_0 + mat4(-0.136964,0.463641,0.036968,-0.235856,-0.230576,-0.272634,-0.350618,0.136158,-0.058201,-0.189375,-0.240709,0.147060,-0.053093,-0.021954,0.195446,0.340386) * L0_1 + mat4(0.115692,0.005102,0.048646,-0.150035,0.035383,-0.076225,-0.202817,0.254787,0.036163,0.029240,0.047841,-0.080737,0.099012,-0.104153,0.213503,-0.107175) * L0_2 + mat4(0.062894,-0.098695,-0.171884,-0.018554,-0.070296,-0.264492,-0.169113,-0.154531,-0.233169,-0.165275,-0.186768,-0.180346,-0.229514,0.112569,0.113254,-0.159813) * L0_3 + mat4(-0.479012,-0.534709,0.107115,0.167743,-0.087708,-0.221522,0.286264,0.127538,-0.254828,0.129145,0.022777,-0.172646,-0.005943,-0.280033,-0.097344,-0.186473) * L0_4 + mat4(-0.154487,0.209554,-0.134772,0.123299,-0.100238,0.246914,0.119075,0.190430,-0.137326,-0.112927,0.249706,-0.329868,-0.415080,0.116157,-0.176394,-0.159092) * L0_5 + mat4(-0.055009,-0.030817,0.169108,-0.404672,-0.166253,0.138717,0.282844,0.050879,-0.068584,0.074808,0.165969,0.269958,0.153369,-0.017787,0.296128,0.119587) * L0_6 + mat4(0.010271,-0.232800,0.101592,-0.097532,-0.016151,0.336423,0.126102,0.018684,0.101141,0.303963,-0.052216,0.144047,-0.221299,0.122866,0.274097,-0.047089) * L0_7 + mat4(0.275743,-0.127507,-0.130163,0.038283,0.051325,-0.239992,-0.040762,0.185853,-0.202732,0.028559,0.083354,0.067308,0.257270,-0.076556,0.235599,-0.003934) * L0_8 + mat4(-0.222038,-0.015541,-0.325031,-0.070677,-0.116950,-0.190994,0.172159,-0.007145,-0.037209,-0.099757,0.096025,-0.120536,0.343855,-0.094033,-0.079295,-0.050518) * L0_9 + mat4(-0.335835,-0.280164,-0.106079,0.122037,0.292429,-0.306616,-0.044590,0.144752,-0.213534,-0.074204,0.269481,0.137554,-0.093052,0.035247,-0.162760,-0.270892) * L0_10 + mat4(-0.204664,0.049731,-0.002527,0.280316,0.095705,0.156758,0.170539,-0.023053,-0.096857,-0.329520,-0.223241,0.258867,0.115306,-0.006460,-0.084710,-0.207960) * L0_11 + mat4(-0.346537,-0.030286,0.183295,0.516883,0.146450,-0.129604,0.319837,-0.126814,0.324472,-0.114126,-0.175249,0.006391,-0.142016,0.028526,-0.456842,-0.063975) * L0_12 + mat4(0.296749,-0.296434,0.036178,0.036947,0.198615,-0.008035,-0.204828,-0.098969,-0.532697,0.116862,0.228336,-0.227484,0.009516,0.090186,0.009553,0.188188) * L0_13 + mat4(-0.195279,0.109523,0.066318,-0.045433,-0.317714,0.039079,0.085751,0.190948,0.070071,0.051804,-0.155125,0.072181,-0.043242,0.062056,-0.249121,0.009450) * L0_14 + mat4(-0.107834,0.129215,0.010284,-0.009336,-0.137044,0.217069,0.081081,-0.580694,-0.124928,0.442650,-0.086601,0.157120,0.137431,0.006847,-0.269452,-0.103140) * L0_15 + vec4(-0.028034,0.096283,-0.118533,-0.249784)));\nvec4 L1_14 = sin((mat4(-0.040084,-0.223069,0.098983,-0.217650,-0.260198,-0.056729,0.180261,-0.232629,0.111714,-0.193238,0.357893,0.512593,0.157053,-0.031949,0.292189,0.034549) * L0_0 + mat4(-0.085676,-0.018195,-0.142523,0.027570,-0.108631,-0.229652,-0.163252,-0.242699,0.179141,-0.131675,-0.183636,0.240505,0.079631,0.084317,-0.377650,0.372100) * L0_1 + mat4(0.162922,-0.192276,0.150769,-0.168266,-0.377841,0.006277,0.137380,-0.154951,-0.143707,0.140885,-0.095620,-0.215755,0.300183,-0.260244,-0.003479,0.227237) * L0_2 + mat4(0.229993,0.207490,-0.423442,-0.246859,0.124223,0.335435,0.047920,0.259237,-0.051765,0.256925,0.006523,-0.268671,-0.189101,0.283190,-0.092016,-0.077872) * L0_3 + mat4(-0.025569,0.399317,-0.103950,-0.110474,-0.006458,-0.141555,0.265507,-0.138085,0.236626,0.000482,-0.149969,-0.052111,0.168182,-0.024294,-0.240273,0.094237) * L0_4 + mat4(-0.194604,0.091263,0.053887,-0.245579,-0.208364,-0.296191,-0.085884,-0.147857,-0.041544,-0.032642,-0.089237,0.135961,0.144554,0.469583,0.336220,-0.094992) * L0_5 + mat4(0.072498,0.175057,-0.237734,0.215223,-0.101057,-0.022861,0.188538,-0.133558,0.094488,0.225878,0.148291,0.397156,0.088017,0.367130,-0.257467,-0.266885) * L0_6 + mat4(0.197032,-0.070797,-0.047549,0.056158,-0.045736,0.399168,0.278926,-0.089819,0.175299,0.089132,0.016181,-0.329608,-0.016758,0.136231,0.274087,-0.217299) * L0_7 + mat4(0.157015,0.436590,0.289868,-0.286877,-0.117135,-0.083850,0.050459,0.258854,0.182876,0.199651,0.160251,-0.106025,0.257519,0.026171,0.004820,-0.283074) * L0_8 + mat4(-0.164328,0.090033,-0.486577,-0.129892,-0.044864,-0.197346,0.207303,-0.280828,0.341652,0.142114,-0.154425,-0.254518,-0.160041,-0.042544,-0.087729,-0.047372) * L0_9 + mat4(-0.213411,0.351474,0.318470,-0.165817,-0.496577,0.044262,-0.308507,-0.380889,-0.068012,-0.174528,-0.233418,0.308713,-0.163958,0.162856,-0.035933,0.002805) * L0_10 + mat4(-0.439055,-0.103465,0.083955,0.283029,0.293596,0.000598,-0.062030,0.137401,-0.038656,0.199562,0.140782,0.054410,0.232523,0.019476,-0.307636,0.298226) * L0_11 + mat4(0.043717,-0.203571,-0.281584,-0.058616,-0.015372,-0.081228,0.066135,0.212079,0.277591,-0.114981,0.095819,0.209405,-0.054957,-0.011498,-0.215733,0.189410) * L0_12 + mat4(0.058649,-0.346544,-0.021633,0.012893,0.350112,0.376522,-0.231418,0.133345,-0.052770,0.419683,0.284916,0.378974,0.218816,0.172845,0.201529,-0.334267) * L0_13 + mat4(-0.141325,-0.186863,-0.003556,-0.447618,0.074885,-0.133482,-0.026880,-0.271398,-0.112222,-0.096014,-0.094942,-0.068453,0.031151,-0.276171,-0.187486,-0.046431) * L0_14 + mat4(-0.158893,-0.321314,0.218087,-0.108904,0.126954,-0.318348,-0.390927,-0.075351,0.374606,0.407384,-0.439982,-0.228444,-0.066259,-0.090490,0.169168,0.097166) * L0_15 + vec4(0.328107,-0.270558,0.126213,0.065555)));\nvec4 L1_15 = sin((mat4(-0.011232,-0.136726,0.071660,0.289342,-0.256371,0.122451,-0.050977,0.050353,0.350926,-0.519231,0.083856,-0.300756,-0.177319,0.052163,0.083934,0.051391) * L0_0 + mat4(-0.220097,0.040091,-0.179398,0.021051,0.158126,0.089695,-0.005113,-0.044121,-0.218220,0.068461,-0.034633,0.070083,0.201008,0.312049,0.491995,-0.298710) * L0_1 + mat4(-0.071949,-0.051560,0.079326,0.085032,-0.118037,0.199798,-0.196768,0.052921,-0.350853,0.131616,0.234313,-0.063931,0.217926,-0.259740,-0.073173,0.058473) * L0_2 + mat4(0.000036,-0.034544,0.270049,0.102076,0.157203,-0.004073,0.059259,0.242508,0.045620,-0.010534,0.071463,-0.063576,0.004724,-0.258564,-0.217244,0.099840) * L0_3 + mat4(-0.158666,0.259460,0.094896,0.012662,0.185997,0.022971,-0.103353,-0.117255,-0.057339,-0.274226,0.064043,0.147210,0.315571,0.075217,0.068094,0.165600) * L0_4 + mat4(0.134673,0.102524,-0.163631,0.161407,-0.018227,-0.202850,0.269067,-0.010199,0.093000,-0.005875,0.053247,0.018073,-0.326311,-0.170387,-0.291588,0.059854) * L0_5 + mat4(-0.021356,0.105534,-0.158613,0.469519,0.160070,-0.250779,-0.142109,0.087234,-0.183210,-0.386844,0.280642,-0.199843,-0.328031,0.023028,-0.518139,-0.104585) * L0_6 + mat4(0.085411,0.142590,-0.023867,0.092811,-0.209399,-0.001913,-0.391485,-0.259951,0.306883,-0.181027,0.292663,-0.286381,-0.095809,-0.013812,0.351743,-0.055082) * L0_7 + mat4(0.193817,0.003796,-0.048956,0.081265,0.415449,-0.169165,0.241959,0.025799,-0.066336,0.157511,0.023214,0.185400,-0.060496,-0.196519,-0.059600,-0.054377) * L0_8 + mat4(0.056994,-0.133484,-0.186219,-0.139606,0.055161,0.323394,0.107777,0.110929,-0.002891,0.146408,-0.052260,-0.192501,0.133110,-0.156287,-0.168537,-0.227332) * L0_9 + mat4(0.148918,0.044797,-0.081763,0.247841,0.034140,-0.089549,0.444844,0.007657,-0.101066,0.017504,-0.115449,0.208432,0.026253,0.221539,0.014028,0.244712) * L0_10 + mat4(0.321080,-0.094053,-0.590681,-0.500722,0.035807,0.052693,0.255818,0.053286,0.200556,0.024733,0.200138,0.170383,-0.324190,0.145480,-0.130996,-0.212535) * L0_11 + mat4(0.089641,0.083287,0.044704,-0.383189,-0.255183,0.041516,0.044839,0.041093,0.298402,-0.162119,0.176715,-0.169536,0.187198,-0.211205,0.125938,-0.162395) * L0_12 + mat4(0.067341,0.174785,-0.086028,-0.039593,-0.300038,-0.288001,0.192503,0.213789,0.280139,0.239750,0.140084,-0.182253,0.056511,0.392687,0.176024,0.067987) * L0_13 + mat4(-0.110857,-0.107194,0.144461,-0.187423,-0.083670,0.257516,-0.052861,-0.317382,0.173148,0.047626,0.189354,-0.237461,-0.152278,0.236699,0.017188,0.092097) * L0_14 + mat4(-0.328136,-0.072812,0.158513,-0.047912,0.428035,0.031718,-0.138910,-0.318805,-0.101176,-0.578809,0.404802,-0.423893,-0.029760,0.026286,0.003960,-0.229396) * L0_15 + vec4(-0.282553,0.202950,-0.026665,-0.079213)));\nvec4 L2_0 = sin((mat4(-0.306863,0.333076,0.007080,-0.016950,0.117605,0.210507,0.435586,-0.417058,0.015237,0.023985,0.195465,-0.129533,0.295098,-0.205899,0.247968,0.221851) * L1_0 + mat4(0.059705,0.505358,-0.396071,0.041556,0.150449,0.311984,0.183175,-0.043577,-0.176740,0.199305,0.048025,0.068925,0.222945,-0.219812,0.050160,0.089438) * L1_1 + mat4(-0.226382,-0.109945,-0.486229,0.150430,0.188170,-0.081040,-0.248525,0.265689,0.309593,0.341451,-0.159713,0.167169,-0.139189,0.175354,0.254168,-0.083568) * L1_2 + mat4(-0.295681,0.419148,-0.019131,-0.229519,-0.143235,-0.232099,-0.269642,0.376494,0.194198,0.219336,-0.122728,0.259946,-0.372479,0.257936,-0.321397,0.152925) * L1_3 + mat4(-0.026410,-0.192275,-0.247299,0.325718,-0.046531,0.443291,-0.202670,-0.025342,-0.221628,-0.087299,0.184860,-0.080747,0.312623,-0.156756,-0.283875,0.122705) * L1_4 + mat4(0.141426,-0.216607,0.061335,0.119192,-0.101580,-0.139169,0.138718,0.474522,0.085831,-0.244365,0.277677,0.197267,0.025335,-0.133692,0.163992,0.041078) * L1_5 + mat4(-0.221372,0.214856,0.434978,-0.129524,-0.049079,0.062979,-0.038474,-0.007065,0.092362,-0.200577,0.068046,0.128522,-0.323599,0.039941,-0.129582,-0.293955) * L1_6 + mat4(-0.014849,-0.310231,0.053737,-0.166526,0.106837,0.126524,0.038685,0.137307,-0.464127,0.063238,0.104518,-0.072728,0.192956,-0.255720,0.025947,-0.053878) * L1_7 + mat4(-0.316715,-0.015936,-0.211026,0.235838,0.099049,0.402035,-0.043892,0.356416,-0.164849,-0.303892,0.266805,0.027462,0.119405,-0.186258,0.043525,-0.046871) * L1_8 + mat4(0.025512,0.023073,-0.187906,-0.079745,0.270889,0.332470,-0.224343,0.353482,0.331086,0.131111,-0.000660,-0.236182,-0.033850,0.339885,0.174287,0.028834) * L1_9 + mat4(0.190474,0.259137,0.113673,-0.099173,-0.118023,0.052818,0.237965,-0.133560,-0.049048,0.054601,0.161880,0.272315,0.024707,0.310414,0.156493,-0.192130) * L1_10 + mat4(-0.402621,0.139487,-0.041676,-0.019544,0.062150,-0.108459,0.134841,0.161990,-0.005572,-0.101444,0.302457,-0.229976,0.143722,-0.180451,-0.198428,-0.072187) * L1_11 + mat4(-0.210582,-0.294585,-0.312720,0.150549,0.136083,-0.288475,0.155214,-0.093588,-0.223245,0.063196,0.393882,-0.347041,0.126972,-0.310721,-0.230544,0.686760) * L1_12 + mat4(-0.070296,0.027577,-0.085362,-0.205819,-0.383978,0.029289,-0.122678,0.154207,-0.284638,0.231717,0.014290,0.245213,-0.307003,0.224716,0.312509,-0.011459) * L1_13 + mat4(0.370502,-0.177248,0.161796,0.557788,-0.325010,-0.216810,-0.269625,-0.040194,-0.071812,0.236360,-0.361266,-0.078993,0.051555,-0.205771,-0.208908,0.217586) * L1_14 + mat4(0.006215,0.046815,0.089187,0.368069,0.159927,0.189001,0.311242,0.251783,-0.173799,0.113567,0.150095,-0.372193,0.026437,0.392444,-0.062011,-0.185922) * L1_15 + vec4(-0.124918,-0.005153,-0.273935,0.348413)));\nvec4 L2_1 = sin((mat4(-0.464728,0.279885,-0.126676,0.099543,-0.054555,0.438472,-0.264297,-0.312082,0.349744,0.247951,0.042191,-0.247992,0.083494,0.147241,0.396048,0.116118) * L1_0 + mat4(-0.135530,0.042887,-0.068368,-0.143745,-0.379674,-0.285827,0.031101,-0.010537,0.094063,0.066422,0.321040,-0.220803,0.278389,0.285020,-0.192181,-0.043654) * L1_1 + mat4(-0.085713,0.101682,-0.080938,0.344870,-0.040705,0.354630,-0.332031,0.056781,-0.277503,0.019840,-0.064119,0.213863,0.003042,0.145485,-0.081606,-0.133947) * L1_2 + mat4(-0.087068,0.223336,0.339747,0.002731,-0.279035,0.005438,-0.251623,-0.139602,0.051098,0.041321,-0.019078,-0.274379,0.273383,0.222558,0.183000,0.001919) * L1_3 + mat4(0.339718,-0.086481,-0.147273,-0.290728,-0.257741,-0.030102,0.097233,-0.179656,0.341058,0.283196,-0.162047,0.254404,0.253183,0.201517,0.021439,0.072131) * L1_4 + mat4(0.077964,-0.272277,-0.226054,0.099093,-0.097848,-0.044186,-0.186967,-0.010630,-0.302296,0.139884,-0.003020,-0.063015,-0.118093,-0.475606,0.275355,0.000516) * L1_5 + mat4(0.084024,-0.343871,0.192209,0.322461,0.299016,0.068778,-0.076532,0.225028,0.148014,0.188366,-0.056027,-0.141424,0.051914,-0.016042,0.258750,-0.053882) * L1_6 + mat4(0.201096,0.208694,0.095218,0.091174,0.421375,-0.156514,-0.068991,0.099307,0.418109,-0.317397,-0.121062,-0.189561,-0.039204,-0.423791,0.015671,-0.061510) * L1_7 + mat4(0.190790,-0.362598,0.514423,0.074991,0.337507,-0.269287,0.090548,0.227616,0.095135,0.292492,-0.293041,-0.264791,-0.001259,0.090247,0.310111,-0.237115) * L1_8 + mat4(0.247453,-0.122989,-0.154174,0.162781,0.002090,0.005101,-0.073831,0.174278,0.151769,-0.069285,-0.167829,-0.465980,-0.010069,-0.054600,-0.185684,0.026448) * L1_9 + mat4(-0.017614,0.155728,0.050888,-0.199031,-0.144459,-0.227543,0.055455,-0.081247,0.011435,-0.192408,0.465499,-0.176706,0.071244,-0.159585,0.075986,-0.168537) * L1_10 + mat4(0.408788,0.037631,0.042408,-0.133630,-0.028007,-0.286115,0.178415,0.031860,-0.131323,-0.170177,-0.226113,-0.271547,0.075645,-0.001496,-0.100090,0.003360) * L1_11 + mat4(-0.366663,0.129687,-0.129504,-0.763882,-0.107347,0.096269,0.184276,-0.317915,0.062307,0.457015,0.000903,-0.239882,0.023340,-0.091419,0.233396,-0.190226) * L1_12 + mat4(-0.010622,0.022877,0.051391,-0.099116,0.021875,-0.206804,0.145520,-0.282374,-0.098832,-0.353330,-0.353700,-0.137292,0.023631,-0.267774,0.419477,0.095121) * L1_13 + mat4(-0.094873,-0.370513,-0.236209,0.076758,-0.205653,-0.130486,-0.095548,0.025341,0.232493,-0.236823,-0.110901,0.016801,-0.251382,-0.281435,-0.090201,0.155642) * L1_14 + mat4(-0.238008,-0.168916,0.105794,-0.031620,-0.135263,0.099708,0.129069,0.093712,-0.099364,0.114947,-0.268111,0.077769,0.045778,0.229263,0.211999,0.533842) * L1_15 + vec4(0.048488,-0.002556,0.158857,0.261568)));\nvec4 L2_2 = sin((mat4(-0.295533,-0.130572,0.319974,0.348207,-0.315996,-0.027883,-0.205029,-0.270351,0.009934,-0.338792,-0.016164,-0.123357,-0.038833,0.057258,0.076715,0.165487) * L1_0 + mat4(-0.197599,-0.058123,0.260023,0.320636,0.102828,0.040342,-0.095307,-0.048503,0.056892,0.214243,0.297276,0.104970,0.092323,-0.144998,0.251787,0.101800) * L1_1 + mat4(-0.491746,-0.043737,-0.295903,0.336357,0.369124,-0.012769,-0.106771,-0.344523,-0.133658,0.062673,-0.027694,0.064248,-0.360512,0.215694,-0.016752,0.079222) * L1_2 + mat4(0.056106,-0.135734,-0.242092,0.361109,0.392500,-0.122822,0.344244,-0.236645,-0.180691,0.185852,-0.022714,-0.036638,0.191604,-0.106479,-0.002681,-0.115557) * L1_3 + mat4(-0.120991,-0.009595,-0.245672,0.064950,0.280601,0.043776,-0.092329,0.020694,0.055382,-0.152904,0.051968,-0.200224,-0.177537,-0.232234,-0.375333,-0.172062) * L1_4 + mat4(-0.030477,-0.188547,-0.416542,-0.060889,-0.149250,0.145976,0.040814,-0.015146,0.102169,-0.220561,0.106245,-0.331563,-0.141186,-0.263663,-0.122486,0.010506) * L1_5 + mat4(0.321225,0.051391,-0.077176,-0.319928,-0.286163,0.322663,-0.222191,-0.029440,0.139520,-0.293211,-0.040828,-0.120536,-0.244376,-0.099242,0.093624,-0.183554) * L1_6 + mat4(-0.019766,0.406697,0.255015,0.037396,0.412794,0.222365,0.031868,-0.122565,-0.109173,-0.255845,0.124252,0.140149,-0.119725,0.014304,0.065214,-0.304094) * L1_7 + mat4(-0.423983,-0.289894,-0.070427,0.109574,-0.220876,-0.002171,-0.124155,0.098756,-0.313977,-0.172871,-0.199346,-0.112259,-0.149356,-0.336240,0.084407,0.074913) * L1_8 + mat4(0.057237,-0.175659,-0.066593,0.278450,-0.029057,0.429328,-0.087761,0.034964,-0.224627,-0.316788,0.071636,0.128093,-0.384977,0.073358,0.309136,-0.043784) * L1_9 + mat4(0.231583,0.025414,-0.162210,0.145584,-0.131376,0.220839,-0.143851,0.310170,0.175448,-0.331451,-0.149214,0.089644,-0.453230,-0.057648,0.106982,-0.355989) * L1_10 + mat4(-0.093290,0.098688,0.385697,0.222167,-0.143995,0.294849,-0.135025,-0.126261,-0.181389,-0.098031,-0.169286,-0.006143,0.364737,-0.023267,-0.126385,-0.293060) * L1_11 + mat4(0.091892,-0.115176,0.293517,0.352873,-0.253242,0.296051,-0.455530,0.147652,-0.244347,-0.077404,0.248874,0.081683,-0.160095,0.072866,0.089504,0.279112) * L1_12 + mat4(-0.049770,-0.013883,-0.257352,0.253592,-0.145373,0.037012,0.381146,0.195295,0.039461,0.228973,0.226431,0.318988,-0.012029,-0.064963,-0.096284,-0.251130) * L1_13 + mat4(0.383873,-0.059619,-0.198931,-0.042937,0.131744,0.038348,0.295814,0.113289,-0.100246,0.225588,0.113387,-0.188013,-0.126722,-0.288781,0.002551,-0.154929) * L1_14 + mat4(-0.324908,-0.169279,0.099406,0.261832,0.156988,0.085365,0.505699,0.090743,0.432178,0.199381,0.320139,0.148646,-0.270144,-0.015328,-0.221950,-0.215609) * L1_15 + vec4(0.431112,-0.204057,0.280998,-0.090021)));\nvec4 L2_3 = sin((mat4(0.097413,0.224938,0.379815,0.255731,-0.005317,0.009194,-0.147920,-0.182304,-0.238723,0.083228,0.190623,-0.455718,0.018135,-0.214717,0.083791,0.000262) * L1_0 + mat4(-0.031756,0.343116,0.126916,0.439276,0.218453,0.053282,0.464574,-0.035331,-0.116119,0.163478,-0.207418,-0.102668,0.350969,-0.050752,0.146185,0.116509) * L1_1 + mat4(-0.050811,0.123449,-0.008865,0.193581,-0.096174,-0.136845,-0.040750,-0.337782,0.089744,-0.102251,0.423709,0.116064,-0.038846,0.033688,0.122605,-0.120592) * L1_2 + mat4(0.141292,-0.291740,-0.129385,-0.215739,0.112192,0.130929,-0.051398,-0.227241,0.319204,0.081298,0.256559,0.071065,-0.165507,-0.159553,0.409917,0.142102) * L1_3 + mat4(-0.274837,-0.298446,-0.437107,-0.621632,-0.275394,0.311225,0.017299,0.098209,-0.040137,0.351409,0.173512,0.218862,-0.098744,-0.319288,-0.005096,0.285032) * L1_4 + mat4(-0.062241,-0.151398,0.056696,-0.021125,-0.099359,-0.160040,-0.159487,0.258928,0.362014,-0.213998,0.002230,-0.318222,-0.197849,-0.023406,-0.267132,0.124843) * L1_5 + mat4(-0.185281,0.187995,0.192586,0.058831,0.391709,0.094214,-0.176223,-0.055597,0.250592,0.035665,-0.224914,0.239390,-0.258757,-0.007208,-0.414731,-0.232921) * L1_6 + mat4(-0.031615,-0.359479,-0.075549,-0.121291,-0.361919,0.131772,0.055727,-0.370034,-0.059786,-0.126422,0.298817,0.184167,0.231901,-0.172705,0.199265,0.048264) * L1_7 + mat4(-0.492217,-0.188728,0.175821,0.052024,-0.085509,-0.185564,-0.317695,0.017608,-0.295594,0.235800,-0.042213,0.016033,-0.061205,-0.027214,-0.001474,-0.134103) * L1_8 + mat4(-0.131074,-0.022437,-0.329174,0.223602,0.343440,0.079545,0.073270,0.153387,-0.469252,0.269747,0.349085,-0.120705,-0.036435,0.232823,-0.267057,-0.118481) * L1_9 + mat4(0.059814,0.279913,-0.110957,0.240849,0.045363,-0.123804,-0.157974,-0.133252,0.096407,0.106535,-0.232715,-0.077583,0.107751,-0.176302,-0.051834,-0.157626) * L1_10 + mat4(0.193446,-0.119233,0.126653,-0.236326,-0.219873,0.204194,-0.146580,0.178571,-0.344494,0.223284,-0.145651,-0.176081,0.156725,0.094262,-0.209362,-0.360648) * L1_11 + mat4(-0.219603,-0.116013,0.511092,-0.364272,-0.124126,-0.068068,0.505094,-0.189339,0.299325,0.017023,-0.134475,0.420692,-0.185231,-0.099324,0.309785,0.034782) * L1_12 + mat4(-0.081462,-0.235754,0.132223,-0.160875,0.327365,-0.130524,0.124290,0.354513,-0.220235,0.192006,-0.264840,-0.224629,0.245980,-0.161845,-0.043579,0.130248) * L1_13 + mat4(-0.302006,0.061029,-0.004415,-0.191748,-0.073099,0.092826,0.251311,0.238040,0.077459,0.108304,0.001908,-0.249059,0.103061,-0.086632,-0.039411,0.419405) * L1_14 + mat4(-0.173205,-0.159151,0.256634,-0.060963,0.250244,-0.079449,0.110766,-0.266915,-0.178388,0.295531,0.132436,0.350838,0.146793,-0.213252,-0.164651,-0.038567) * L1_15 + vec4(-0.148116,-0.103679,0.053284,0.065486)));\nvec4 L2_4 = sin((mat4(0.025085,-0.252827,0.144829,0.225309,0.008752,-0.129897,-0.056288,-0.252092,-0.404600,-0.135204,-0.078602,-0.008583,0.271222,0.286925,0.023216,-0.168827) * L1_0 + mat4(-0.176229,0.212246,0.005903,-0.371666,0.004978,0.254881,0.248563,-0.172140,-0.078529,0.014828,0.073929,0.093852,-0.107114,-0.186068,0.246539,-0.249950) * L1_1 + mat4(-0.160549,-0.240675,0.012578,-0.179491,0.208909,0.177699,-0.126862,-0.090866,0.434656,0.252257,0.221041,-0.337001,-0.036518,-0.177813,-0.139524,0.338589) * L1_2 + mat4(-0.287652,0.033496,0.387809,-0.257254,-0.059629,0.289174,-0.224796,-0.304310,0.197761,0.040712,-0.163521,-0.374022,0.069767,-0.211144,-0.202395,-0.151026) * L1_3 + mat4(-0.201539,-0.011625,-0.210978,-0.138909,0.080999,-0.179671,0.279533,-0.160278,0.351165,-0.119207,0.050812,0.124690,-0.008354,-0.359554,0.156229,0.154566) * L1_4 + mat4(-0.408596,-0.313501,-0.093963,0.368058,-0.023950,-0.305505,-0.321971,-0.069089,-0.209807,0.292178,0.215118,-0.103681,-0.281043,-0.068387,0.059357,0.152467) * L1_5 + mat4(0.199865,0.399758,0.327608,-0.323642,-0.376207,-0.282494,0.037418,-0.015668,0.128651,-0.114139,-0.232061,-0.037121,0.333824,-0.182607,0.280958,0.206725) * L1_6 + mat4(-0.102438,-0.008312,-0.222817,-0.144841,0.150426,-0.188134,-0.027444,-0.029448,0.111790,-0.093630,-0.185966,-0.054623,-0.078849,-0.128874,0.254817,-0.315902) * L1_7 + mat4(-0.076537,0.215723,-0.159454,0.057327,-0.029292,-0.290860,0.195301,-0.364339,0.120162,0.075868,-0.245307,-0.324620,-0.105152,0.326386,-0.037960,-0.200894) * L1_8 + mat4(0.018577,-0.044066,-0.130782,0.151454,0.317845,-0.170056,0.283979,0.010244,0.103687,-0.033696,-0.550054,-0.218835,-0.154967,0.352859,0.290508,-0.118930) * L1_9 + mat4(-0.358593,-0.044321,-0.169956,-0.129718,0.011982,0.117325,-0.040285,-0.155885,0.210460,0.194657,0.290223,-0.187856,-0.061976,-0.255314,0.266878,0.337343) * L1_10 + mat4(-0.144200,0.284904,0.172396,0.113905,-0.067320,-0.376923,-0.026656,0.015212,-0.193281,-0.337362,-0.086055,-0.192485,0.171843,-0.029861,-0.019942,0.001918) * L1_11 + mat4(0.248973,0.241528,-0.232960,-0.076245,0.385249,0.093319,0.252866,0.094338,0.099207,-0.305920,-0.487928,-0.295495,-0.282270,0.207917,0.013624,0.113027) * L1_12 + mat4(-0.032319,0.173831,-0.043306,-0.353357,-0.241722,0.025467,0.070207,-0.095089,0.282012,-0.045794,-0.074330,0.381354,-0.092785,-0.156754,-0.265775,0.062512) * L1_13 + mat4(0.387341,-0.266022,0.169053,0.097462,0.374837,-0.308779,0.165057,-0.183281,0.368631,0.477069,0.350286,0.221234,0.140366,0.163351,-0.038615,0.107596) * L1_14 + mat4(-0.127214,0.000069,0.134779,0.010403,-0.013480,0.335336,-0.091507,-0.207358,-0.204351,-0.078552,0.252107,-0.247500,0.444731,0.117764,0.319269,0.153550) * L1_15 + vec4(0.435297,0.397509,0.164119,-0.322453)));\nvec4 L2_5 = sin((mat4(0.306307,-0.046781,-0.064381,-0.284488,0.079175,-0.063032,0.437658,0.168593,0.174575,-0.380336,-0.304324,-0.121532,-0.324657,-0.099645,0.099179,-0.176635) * L1_0 + mat4(0.024170,-0.039173,-0.433004,-0.167520,-0.113875,-0.168127,0.079613,-0.165566,-0.070657,0.266491,-0.382549,0.139259,0.355429,-0.450096,-0.008161,0.410936) * L1_1 + mat4(0.252165,0.010225,-0.003489,-0.313813,-0.036684,0.381275,0.308806,-0.022231,0.086980,0.141741,0.330636,-0.315793,0.324717,0.024862,-0.147252,-0.279670) * L1_2 + mat4(0.293925,0.037590,0.152832,0.195386,-0.074780,-0.097899,-0.232188,0.302889,0.097181,0.050304,-0.069122,0.382320,-0.212581,0.183151,-0.254196,0.218219) * L1_3 + mat4(-0.113904,-0.164056,0.083921,-0.045341,-0.076915,-0.378351,0.119268,-0.265143,0.188027,-0.355922,-0.209303,-0.333392,0.010816,-0.115315,-0.330718,0.143088) * L1_4 + mat4(0.227643,-0.081690,0.069314,-0.072869,0.026621,0.051388,0.030583,0.172601,-0.331898,-0.305432,-0.237786,-0.017835,-0.110944,0.029577,0.223441,-0.072794) * L1_5 + mat4(-0.086724,-0.212663,-0.433593,0.394152,0.009698,0.056835,-0.085448,0.233500,-0.102449,-0.121326,-0.023338,-0.116383,-0.103911,0.079960,-0.221381,0.084815) * L1_6 + mat4(0.299925,-0.056216,-0.329385,0.165425,-0.347790,-0.386045,-0.161390,-0.208627,0.285501,0.080075,-0.204419,-0.323944,0.029683,-0.195035,-0.372414,-0.078007) * L1_7 + mat4(0.161103,0.520219,-0.387208,-0.200203,-0.386089,-0.003620,-0.058628,0.074671,0.286108,0.052632,-0.162627,0.408061,-0.168493,-0.019857,-0.379806,0.310761) * L1_8 + mat4(0.306122,0.521894,-0.281859,-0.357572,-0.125491,-0.246162,0.224009,-0.147165,-0.408230,-0.031089,0.341235,-0.019149,0.034895,0.268983,0.071745,-0.080380) * L1_9 + mat4(0.167998,-0.277320,0.331302,0.157710,-0.126656,0.011045,0.434854,0.023161,0.133795,-0.140662,-0.124857,0.195927,0.032556,0.204651,-0.034673,0.132827) * L1_10 + mat4(-0.141007,-0.354968,0.041963,0.382091,0.312828,0.031805,0.252197,-0.233616,-0.036734,0.076675,0.395324,-0.217903,0.053342,-0.595028,0.240167,0.333896) * L1_11 + mat4(-0.070576,-0.176802,0.281999,-0.006846,-0.283925,-0.042291,0.129058,-0.231483,0.050166,-0.510656,0.141672,0.072778,0.143781,0.411559,-0.097128,0.228748) * L1_12 + mat4(0.266992,-0.045367,0.206308,0.118246,-0.064937,0.197268,0.076399,0.038327,-0.124043,0.170405,0.151710,-0.147244,0.125737,0.302439,-0.004626,-0.334103) * L1_13 + mat4(0.029752,-0.411656,0.015421,0.104035,0.292687,0.050946,-0.156499,0.147711,0.430543,0.342659,-0.406434,0.387621,0.142914,-0.202663,-0.158914,-0.108862) * L1_14 + mat4(-0.036447,0.322546,-0.149372,0.011559,-0.072637,0.028907,-0.371807,-0.248182,-0.040379,-0.147725,0.062082,-0.060490,-0.358201,-0.237296,-0.010326,0.093165) * L1_15 + vec4(0.318271,-0.234940,0.306822,-0.148355)));\nvec4 L2_6 = sin((mat4(-0.171960,-0.135553,0.422785,0.103363,0.026656,0.558846,0.110044,-0.224574,0.098486,0.120729,0.341430,-0.085548,0.042015,0.130122,-0.119479,0.020721) * L1_0 + mat4(0.139019,0.121754,0.017867,0.043998,0.144441,0.017100,0.407272,-0.352925,0.005916,-0.055225,-0.118068,0.429952,-0.015714,0.376007,0.131783,0.085164) * L1_1 + mat4(0.046610,-0.163689,-0.122027,-0.293967,0.172278,0.332231,-0.109513,-0.268391,0.393703,-0.338954,-0.149145,0.074216,-0.124768,-0.116742,0.018914,-0.138734) * L1_2 + mat4(0.271830,-0.042452,-0.008708,-0.024924,-0.393264,-0.219014,0.280717,-0.200978,0.087588,-0.233659,-0.192793,-0.148401,0.385310,-0.040962,0.111275,0.280526) * L1_3 + mat4(-0.212153,0.010990,-0.226765,-0.387033,0.329844,-0.008266,0.177202,-0.181069,-0.024638,-0.086881,0.002901,-0.075645,0.181235,0.143172,0.209077,0.118471) * L1_4 + mat4(0.035448,-0.267116,-0.145909,0.094967,0.088642,0.021777,0.386006,-0.078736,-0.311815,-0.188622,0.236975,0.203603,0.331338,0.193278,-0.061056,0.057007) * L1_5 + mat4(-0.110499,0.132261,-0.051384,0.421879,0.289240,-0.144908,0.071186,-0.267459,0.002651,0.058256,0.233384,0.126633,-0.043422,0.455738,-0.261122,-0.145102) * L1_6 + mat4(0.149497,0.039721,0.058856,0.268391,0.020912,0.083678,-0.293709,0.317631,-0.031772,-0.154040,0.035523,-0.260189,-0.111681,0.311337,0.216214,0.219173) * L1_7 + mat4(-0.445259,-0.258919,-0.204208,0.172417,0.005156,-0.238633,-0.086517,0.161454,0.256920,0.250360,-0.167848,-0.591610,0.259611,0.138702,0.255044,0.203233) * L1_8 + mat4(0.258529,-0.276839,-0.374036,0.058067,-0.140458,-0.009193,0.179141,-0.112007,-0.352054,-0.030622,-0.015201,0.202571,-0.125061,0.231908,-0.003982,0.086313) * L1_9 + mat4(0.218456,0.152384,-0.082172,0.076958,-0.081886,0.182755,-0.062531,0.358865,-0.399624,0.227364,-0.082467,-0.059345,-0.145494,-0.209378,0.274072,0.038099) * L1_10 + mat4(0.326137,-0.379727,-0.429496,0.423928,0.165196,0.347679,-0.291481,0.385168,0.097983,-0.089544,0.001896,0.293412,-0.118389,0.392183,-0.005312,-0.242632) * L1_11 + mat4(0.294043,-0.278480,-0.012495,0.163421,0.302600,-0.077233,-0.142148,-0.004321,-0.079854,-0.133765,0.250272,-0.150522,-0.320808,-0.159068,-0.214662,0.192943) * L1_12 + mat4(-0.068358,-0.271221,0.280941,-0.427008,0.171832,-0.220193,-0.338682,-0.367301,-0.002917,-0.186385,-0.036781,-0.189506,0.372981,0.012826,-0.311179,0.079194) * L1_13 + mat4(-0.392638,-0.014842,0.300279,0.406222,0.217041,0.015810,0.242707,-0.302650,0.080860,0.162923,0.357067,0.179975,-0.334528,-0.008978,-0.318293,0.088669) * L1_14 + mat4(-0.301597,-0.328316,0.213169,0.058729,0.147898,0.180733,-0.211028,0.013822,0.234553,-0.078445,0.028347,-0.086548,-0.180696,-0.059337,-0.086929,-0.204587) * L1_15 + vec4(-0.230670,-0.327282,0.035063,-0.354880)));\nvec4 L2_7 = sin((mat4(0.180080,-0.135056,0.574114,0.129517,0.159529,-0.093276,0.131372,-0.026638,0.341524,-0.138585,0.019437,-0.110408,0.085212,0.002722,0.192502,0.061977) * L1_0 + mat4(-0.024014,-0.018950,0.143778,0.357566,0.152036,-0.324161,-0.269364,-0.171636,-0.088288,0.236864,0.041058,0.228151,0.026852,0.118566,0.260746,-0.535941) * L1_1 + mat4(0.125082,-0.037995,0.117940,0.000893,-0.075766,-0.061975,0.340676,-0.373205,0.151142,-0.125274,0.171289,-0.278326,0.193001,-0.183700,-0.252951,-0.216287) * L1_2 + mat4(0.039770,0.284137,-0.086250,0.044685,-0.337338,0.427937,0.130387,-0.301461,-0.243700,0.359646,-0.055495,0.177007,-0.046961,0.295137,-0.018447,-0.199108) * L1_3 + mat4(0.112744,0.139212,-0.191658,-0.135121,0.288374,-0.444609,0.104590,0.328267,-0.216506,0.014225,0.350415,-0.082934,-0.409980,0.186271,0.379060,-0.130224) * L1_4 + mat4(0.195487,0.173108,-0.199482,0.127559,-0.180327,0.048287,-0.076299,0.230651,0.147992,-0.298134,0.087639,0.155508,0.385600,0.129074,-0.412062,-0.257850) * L1_5 + mat4(0.377046,-0.265061,-0.169376,0.008871,-0.248500,0.221130,-0.044658,-0.168827,-0.176420,0.145768,-0.043515,0.152061,0.312200,0.080533,0.029544,0.289721) * L1_6 + mat4(0.167405,-0.070888,0.069264,0.193087,-0.085535,-0.280133,-0.053892,0.032770,-0.115852,0.359855,0.348654,-0.176346,-0.053591,0.179621,-0.319415,0.366880) * L1_7 + mat4(0.296501,-0.169784,0.012082,0.062397,0.243472,-0.267946,-0.369427,-0.191078,0.014755,-0.036528,0.457389,0.188635,0.427510,-0.084237,0.127908,0.104220) * L1_8 + mat4(0.100237,-0.255829,-0.228658,0.196736,0.318630,-0.332662,-0.062385,-0.096573,0.357030,0.470198,0.385583,0.395800,0.054704,0.065898,-0.326747,0.014084) * L1_9 + mat4(-0.063556,0.178874,-0.063442,-0.073387,-0.266878,0.434454,0.384079,-0.273696,-0.013746,-0.195755,-0.332221,0.184946,-0.021953,-0.064399,0.099100,0.215556) * L1_10 + mat4(-0.114052,0.446539,0.145055,0.095762,-0.097529,-0.110010,-0.297558,-0.294267,0.103883,0.411793,0.243779,-0.373432,-0.304196,0.498425,0.077095,0.477323) * L1_11 + mat4(0.385898,0.292650,-0.431094,-0.021108,0.336101,-0.032694,-0.054824,-0.242683,0.141010,-0.262187,0.021723,-0.398166,-0.243008,0.036265,0.085028,0.443410) * L1_12 + mat4(0.216376,-0.164828,0.323360,-0.208961,0.053169,-0.221599,0.045127,0.188312,-0.123865,-0.095661,-0.195778,-0.272405,-0.010023,0.091422,0.146873,-0.386573) * L1_13 + mat4(0.291228,0.168838,-0.239355,0.470900,-0.432801,-0.079723,0.086603,0.052675,-0.063070,0.053704,-0.120283,-0.383720,-0.001582,0.124663,-0.133563,0.015836) * L1_14 + mat4(0.261176,0.299293,0.149382,0.149082,-0.110908,-0.239811,-0.150267,0.048834,0.115599,0.195052,0.068554,0.031489,0.037926,0.039880,0.089279,0.192487) * L1_15 + vec4(-0.175785,-0.065661,0.021522,-0.022181)));\nvec4 L2_8 = sin((mat4(0.205073,0.280980,-0.010013,-0.252193,0.148460,-0.046614,0.095935,-0.135531,-0.172951,0.219520,-0.233723,-0.145568,-0.244886,-0.093784,-0.023059,0.008257) * L1_0 + mat4(0.065184,0.164212,-0.085179,0.188130,-0.003239,-0.349511,-0.096025,0.157357,0.186658,-0.146350,0.009743,-0.307403,0.019172,-0.299177,0.124170,0.195009) * L1_1 + mat4(-0.035260,-0.397121,0.366740,0.159430,-0.197975,-0.043034,0.325902,0.464799,-0.154488,0.102586,-0.112909,-0.217873,-0.411246,-0.013624,0.014955,0.336961) * L1_2 + mat4(-0.016091,0.425248,-0.209896,-0.428277,-0.274256,-0.091821,-0.251629,0.080346,0.138461,-0.174628,0.232267,0.144119,0.348044,-0.103504,0.055255,0.224442) * L1_3 + mat4(0.284103,-0.398515,-0.226694,-0.221938,0.224635,-0.198965,-0.344164,-0.010982,0.149878,0.078724,-0.183611,0.027784,0.095207,0.004126,-0.028955,0.084690) * L1_4 + mat4(0.003749,-0.185729,-0.148878,0.024061,0.263238,-0.196604,-0.016971,0.164052,0.163092,0.093031,-0.352221,0.302399,0.310311,0.039410,-0.183974,-0.186677) * L1_5 + mat4(-0.045588,0.111385,-0.612269,-0.186498,-0.343147,-0.241030,0.315772,-0.257410,0.348140,0.192262,-0.193518,0.266191,0.068571,0.006479,-0.084137,0.272130) * L1_6 + mat4(-0.101203,0.021914,0.122071,0.127554,0.046501,0.284752,-0.078145,0.228135,-0.320298,0.212947,0.325825,-0.054182,-0.174462,-0.063193,-0.050846,-0.246390) * L1_7 + mat4(-0.239210,0.188769,-0.143874,-0.095947,0.064763,0.212128,-0.167969,0.115989,0.326619,0.326907,0.016639,0.295692,0.241034,-0.088580,0.222758,-0.044182) * L1_8 + mat4(0.211108,-0.065339,-0.009411,-0.405190,-0.432988,-0.207839,-0.344879,-0.348253,0.438472,0.340175,-0.207143,0.070590,0.251657,0.329592,-0.380197,-0.461371) * L1_9 + mat4(0.325585,-0.210680,-0.410543,-0.366312,-0.005360,0.259585,-0.044807,-0.214487,0.065651,0.063213,-0.017215,-0.175987,-0.105375,-0.004202,-0.174688,-0.088840) * L1_10 + mat4(-0.063145,0.367353,-0.243451,-0.293746,-0.150703,0.134148,-0.400792,-0.053641,-0.555880,-0.468590,0.307950,0.326219,0.081345,-0.070440,-0.075033,0.234545) * L1_11 + mat4(0.262148,0.082427,-0.326367,-0.186806,-0.350513,-0.135284,0.172257,-0.053618,0.278887,-0.189825,0.029468,0.301299,-0.222609,0.187740,0.271905,-0.374931) * L1_12 + mat4(0.064830,-0.233861,0.071541,0.049673,-0.046413,-0.257892,-0.290449,0.426212,-0.314688,-0.022734,0.080016,-0.035334,0.063317,-0.271025,-0.415747,-0.119260) * L1_13 + mat4(0.157974,-0.037221,0.281330,-0.167915,-0.456739,-0.121306,-0.265793,0.288529,0.041362,-0.352081,-0.325321,-0.162523,0.102490,0.034681,-0.176653,0.374990) * L1_14 + mat4(-0.168944,0.287557,0.335867,0.300579,-0.258821,-0.317270,0.317881,0.293171,-0.090513,0.122035,-0.031399,-0.159259,0.201412,-0.127161,0.127737,0.103919) * L1_15 + vec4(0.444638,-0.297125,0.354053,-0.258405)));\nvec4 L2_9 = sin((mat4(-0.028894,0.166192,0.473282,-0.634082,0.066249,-0.432502,-0.108664,0.059004,-0.041008,0.166445,0.370159,0.112660,-0.418892,0.029475,-0.037798,0.100037) * L1_0 + mat4(0.009394,0.011221,0.274336,0.070109,0.301398,0.351179,0.078756,0.238522,0.035080,0.239576,0.048059,-0.076702,-0.180611,0.093546,-0.263791,-0.080559) * L1_1 + mat4(-0.207856,-0.123630,-0.337847,-0.147172,-0.245724,-0.127770,-0.221541,-0.167206,0.271037,0.032406,-0.017453,-0.197894,-0.136497,0.009487,0.241383,0.462617) * L1_2 + mat4(-0.192771,-0.417823,-0.359292,-0.140487,-0.391996,-0.272043,0.008839,0.025145,0.218602,-0.145515,0.073439,0.023145,-0.036194,-0.113463,0.202634,0.159738) * L1_3 + mat4(-0.325285,0.331488,-0.162546,0.388907,0.042444,-0.007916,0.038495,0.004964,-0.275490,-0.206876,0.317875,-0.249120,0.282110,-0.162700,-0.024791,0.049206) * L1_4 + mat4(-0.193943,0.414895,0.188138,-0.256480,-0.234493,0.404556,-0.240076,0.295523,0.111763,0.312182,0.196630,0.179515,0.276722,-0.191145,-0.027672,0.248097) * L1_5 + mat4(-0.076342,-0.116629,0.546241,-0.269624,-0.158816,-0.147709,0.146662,0.512852,-0.537390,0.267076,0.011162,-0.271918,-0.060605,-0.028511,-0.000957,0.036563) * L1_6 + mat4(-0.007047,-0.402985,0.072555,0.218162,-0.051185,0.010670,-0.076222,-0.064705,-0.421224,0.016763,0.323959,-0.024090,-0.271209,-0.284206,0.226809,0.139605) * L1_7 + mat4(-0.215258,0.111510,0.221297,0.212464,-0.198535,-0.404014,-0.079506,-0.036240,0.074014,0.430044,0.094705,0.404331,0.265114,0.176885,-0.084048,0.327537) * L1_8 + mat4(0.423341,0.049844,0.243881,-0.127172,0.035128,0.302126,0.427491,-0.102054,0.228595,0.029637,-0.016329,0.310024,-0.004445,-0.008473,0.046688,-0.461645) * L1_9 + mat4(0.113129,0.006275,-0.063648,0.077845,-0.286892,-0.030377,-0.098824,-0.088332,-0.163232,0.059182,-0.058386,0.247597,-0.043853,0.178631,0.053388,0.345105) * L1_10 + mat4(-0.258110,0.173216,-0.031232,0.193018,0.142797,0.331585,0.013688,-0.449001,0.072895,0.003965,0.067636,0.202472,-0.137528,0.070112,-0.028695,-0.300587) * L1_11 + mat4(-0.064412,0.051161,-0.016222,-0.220317,-0.262796,0.201596,0.029503,0.334053,0.149409,-0.043181,0.025176,-0.054467,-0.482198,0.230400,-0.019816,0.001798) * L1_12 + mat4(0.189052,-0.223605,0.331235,-0.070060,0.097368,0.161063,-0.009912,0.204656,0.356948,0.245154,0.424698,0.091185,0.156821,0.405837,-0.249948,0.331086) * L1_13 + mat4(0.052164,-0.370452,-0.186869,0.256527,0.039460,-0.112858,0.196387,-0.371729,-0.096030,-0.058581,-0.184723,-0.382221,-0.207317,0.239750,0.302313,0.043861) * L1_14 + mat4(-0.193117,-0.197564,0.091302,0.361245,-0.085436,-0.278286,0.130280,0.104949,-0.210119,0.164083,-0.246377,-0.327804,-0.146107,-0.264848,0.194333,-0.476790) * L1_15 + vec4(0.067432,0.156177,-0.091577,-0.123336)));\nvec4 L2_10 = sin((mat4(-0.197145,0.258114,-0.122039,-0.155669,0.360038,-0.152834,0.163549,-0.140672,0.086303,0.187390,-0.109100,-0.153571,-0.103452,0.044352,0.304556,0.019489) * L1_0 + mat4(-0.073698,0.061794,0.272731,-0.144927,0.422103,0.378496,0.149037,-0.296953,-0.228220,-0.498214,0.206756,0.202476,-0.312654,-0.077542,-0.374153,-0.016895) * L1_1 + mat4(0.314138,-0.231078,0.070451,-0.049930,0.087745,0.076995,-0.031062,-0.444320,-0.002798,-0.381750,-0.079980,-0.035269,-0.058737,-0.034429,-0.124018,0.083524) * L1_2 + mat4(-0.115927,0.331599,-0.052802,0.070932,-0.302957,-0.256901,-0.189152,0.284035,-0.217440,0.211451,0.118331,0.182791,-0.211437,-0.247958,0.127839,-0.014681) * L1_3 + mat4(-0.355424,-0.104227,0.209299,-0.025996,-0.033368,0.070167,-0.251391,0.342610,-0.051762,0.478770,-0.154760,-0.316295,-0.163557,-0.311271,0.178024,-0.039627) * L1_4 + mat4(0.037461,-0.036246,0.224585,0.141033,0.130686,0.231623,-0.035962,0.325023,-0.170374,-0.020131,-0.247932,-0.161762,-0.005092,-0.289359,-0.034198,0.050621) * L1_5 + mat4(0.192748,-0.011499,-0.304426,0.196967,-0.093860,-0.261125,-0.067298,-0.310929,0.301547,-0.085373,-0.058824,0.240829,-0.161688,-0.009407,0.148109,-0.167291) * L1_6 + mat4(0.351549,0.208184,0.258909,-0.287498,-0.121915,-0.033304,-0.092052,-0.271277,-0.152435,0.014592,-0.002761,-0.058836,-0.222453,-0.130066,-0.211913,0.109301) * L1_7 + mat4(0.186384,-0.279044,0.013223,-0.151672,-0.153368,0.167711,-0.086734,0.291709,-0.086807,0.191681,0.384080,0.105421,-0.000413,-0.167479,0.253025,0.237009) * L1_8 + mat4(-0.272570,-0.414676,0.028494,-0.286015,-0.001278,0.234521,0.057950,-0.238398,-0.185899,0.124809,0.305375,0.064908,0.258768,-0.427522,-0.174467,0.000017) * L1_9 + mat4(0.359790,-0.209303,-0.120064,-0.176395,-0.025859,-0.113408,-0.143881,0.134937,0.117613,0.049942,-0.073291,-0.200376,-0.230343,-0.127231,0.052522,-0.088546) * L1_10 + mat4(0.088692,-0.212113,0.415929,-0.023312,0.028832,-0.345859,-0.566114,-0.203553,0.247344,0.343971,-0.020218,-0.150379,0.261545,-0.165647,-0.389124,0.207647) * L1_11 + mat4(0.486170,0.412084,-0.135831,0.236858,-0.230617,0.156462,0.487958,-0.173574,-0.087921,0.248398,-0.000950,0.181908,-0.167504,-0.096105,0.358026,0.429935) * L1_12 + mat4(0.014776,0.120396,0.311786,-0.323264,0.111368,-0.224288,0.077099,-0.359272,-0.150990,0.080774,0.022140,-0.114242,-0.346023,-0.173491,-0.328426,0.120703) * L1_13 + mat4(-0.121614,-0.256553,0.099940,-0.191578,-0.204192,0.037824,0.308149,0.401353,0.151559,0.102541,0.116437,0.132880,0.453133,0.090018,-0.055086,0.197012) * L1_14 + mat4(0.142742,0.173422,0.001745,0.134497,0.051857,0.250346,-0.128323,0.222108,0.224530,0.386382,-0.159898,-0.224232,-0.309412,-0.157061,0.216687,0.069819) * L1_15 + vec4(0.045286,-0.260937,0.094481,-0.240436)));\nvec4 L2_11 = sin((mat4(-0.230708,0.387705,0.051538,0.000606,0.260520,-0.465463,-0.357438,0.198371,-0.417618,0.262619,-0.410673,0.314554,-0.137551,-0.248858,0.026761,-0.078684) * L1_0 + mat4(-0.082316,-0.119290,0.109225,-0.082120,0.083760,-0.143001,0.047164,0.166629,0.131050,-0.155478,0.139486,0.216745,0.073243,-0.414053,0.130067,-0.001333) * L1_1 + mat4(0.273260,-0.033656,0.077441,0.311864,-0.047886,0.112735,-0.231963,0.380134,0.058414,-0.287428,-0.343619,0.061976,-0.039035,-0.241486,-0.146692,0.041575) * L1_2 + mat4(-0.178529,-0.217456,-0.116781,-0.252802,0.106747,-0.141125,0.194585,-0.110760,-0.309224,0.247689,0.129598,-0.190843,-0.183590,-0.340925,0.343008,-0.030790) * L1_3 + mat4(0.413033,-0.200806,-0.046459,-0.277387,-0.237908,0.078066,0.427592,0.022268,0.242358,-0.112020,-0.062010,-0.175240,-0.264577,0.353534,-0.010266,-0.012209) * L1_4 + mat4(-0.160820,-0.191849,-0.222028,-0.151249,-0.237413,-0.344221,-0.220805,-0.326669,-0.474007,-0.074924,0.002438,-0.263567,0.097149,-0.103186,0.091941,-0.281196) * L1_5 + mat4(-0.250660,-0.155865,0.374174,-0.039479,-0.015113,-0.033892,0.270353,0.300061,-0.167213,-0.256681,-0.161414,0.049393,0.219874,-0.154946,-0.190821,0.098593) * L1_6 + mat4(-0.085703,0.156003,0.193599,0.308201,0.211223,0.050869,0.167134,0.280252,-0.370876,0.101423,0.009195,-0.380661,0.020176,-0.222157,0.035773,-0.050291) * L1_7 + mat4(0.239992,0.126571,-0.292866,-0.234717,-0.153795,-0.484132,0.456018,-0.039543,0.198213,0.399165,0.231507,0.182840,-0.082835,-0.164583,0.026554,0.374947) * L1_8 + mat4(0.172260,-0.030602,-0.357084,-0.297407,0.476033,-0.106971,0.374926,0.056756,-0.314047,0.371363,0.162280,0.453072,0.133623,-0.356486,-0.328519,0.187736) * L1_9 + mat4(-0.028886,-0.353597,-0.061085,0.210511,0.123097,-0.180033,0.027945,-0.055271,0.032257,-0.118458,-0.005219,0.220485,0.262769,-0.133547,0.263085,-0.072497) * L1_10 + mat4(-0.056372,0.075844,-0.081915,-0.320740,0.237977,-0.561991,-0.024116,-0.026851,-0.049706,-0.085976,-0.122076,-0.560496,0.003476,-0.120364,-0.268780,-0.049053) * L1_11 + mat4(-0.050645,-0.295264,-0.441353,-0.002814,-0.491424,-0.122500,-0.096113,0.090043,0.306305,-0.004989,-0.305317,0.263694,0.339967,0.111815,0.194025,0.344575) * L1_12 + mat4(-0.267875,-0.321008,-0.058321,-0.460693,-0.202307,-0.039887,0.048164,0.294537,-0.055249,0.036107,-0.279525,0.052621,-0.248033,0.091471,0.050156,-0.211022) * L1_13 + mat4(0.054886,0.107707,-0.115017,-0.123725,-0.025198,0.308121,0.173667,-0.333141,-0.253943,0.152589,-0.275690,0.048531,0.221745,0.013330,-0.210677,-0.289897) * L1_14 + mat4(-0.120986,0.145881,0.162958,0.043838,-0.034099,0.008026,0.148437,-0.021148,-0.383826,-0.188437,-0.345123,-0.172620,-0.152487,-0.393924,0.556708,-0.357662) * L1_15 + vec4(0.207825,0.027630,0.150907,0.260587)));\nvec4 L2_12 = sin((mat4(-0.392956,-0.019723,0.007623,-0.110048,0.151570,0.030569,0.297691,-0.099603,0.171165,0.168167,-0.122805,-0.163933,-0.356332,0.168072,0.316755,0.062635) * L1_0 + mat4(-0.184256,0.244572,0.313692,0.187517,0.133923,0.284424,-0.104243,-0.244919,0.304000,0.291163,0.127779,0.179186,0.187610,0.268521,-0.499181,0.036076) * L1_1 + mat4(-0.460133,0.270509,-0.218593,0.099714,-0.252340,0.333578,-0.102541,0.232018,0.285879,0.245644,0.163846,0.130179,-0.544156,-0.178962,-0.036412,-0.491465) * L1_2 + mat4(-0.301904,-0.346529,-0.080613,-0.262800,-0.325221,0.014893,-0.108655,0.002826,-0.018372,-0.109234,-0.188722,0.225395,-0.224909,-0.273577,-0.033551,0.137458) * L1_3 + mat4(-0.174049,0.401237,0.208391,0.150023,0.096217,-0.347283,0.270928,-0.173504,-0.285039,0.058504,-0.303230,-0.518718,-0.400163,-0.490952,0.268519,-0.167507) * L1_4 + mat4(0.341475,0.138333,0.166340,-0.075858,-0.033883,-0.081133,0.034937,0.137340,0.167053,-0.462814,0.056949,-0.315652,0.150790,-0.055981,-0.050987,-0.112877) * L1_5 + mat4(-0.098977,-0.254210,0.272896,0.312261,-0.267535,-0.070350,-0.084917,0.108451,-0.030907,0.289920,0.098985,-0.349423,0.177431,0.328114,0.017217,-0.152329) * L1_6 + mat4(0.026913,0.011831,0.239096,0.095028,0.169087,-0.085831,0.265110,-0.196262,-0.125023,-0.194679,0.249172,0.106824,0.285119,-0.355151,0.169646,0.115323) * L1_7 + mat4(-0.177107,0.355662,0.174267,-0.095478,0.161990,0.000512,-0.071904,-0.407625,-0.055409,-0.363822,0.045986,0.182091,0.033824,-0.073008,-0.094737,-0.206263) * L1_8 + mat4(0.104246,0.072148,-0.198365,0.096142,0.258179,-0.138843,0.051207,-0.040614,0.366072,0.016818,0.207019,-0.229272,-0.270571,-0.030432,-0.135104,-0.295573) * L1_9 + mat4(-0.134399,0.367211,0.025380,-0.285429,0.491128,0.263993,0.030125,0.208936,-0.156628,0.086489,0.405839,0.174182,-0.089690,0.133732,0.062273,0.039088) * L1_10 + mat4(0.167212,0.158538,0.065822,0.268084,-0.402786,-0.050671,-0.342813,0.100250,-0.048667,0.356294,0.393742,-0.277855,-0.306413,-0.067928,-0.033400,-0.283975) * L1_11 + mat4(0.210934,-0.005192,-0.050895,0.153857,0.132025,-0.426970,-0.633370,-0.403293,0.194854,-0.318767,-0.031681,-0.085336,0.185456,0.100741,-0.449862,-0.144368) * L1_12 + mat4(-0.146007,0.125684,-0.087205,0.220318,-0.301811,-0.050439,-0.416549,-0.229130,-0.133869,0.097438,-0.064001,0.020966,0.378467,0.160781,-0.085309,0.132233) * L1_13 + mat4(-0.327177,-0.316649,0.055848,-0.133963,-0.037191,-0.084615,0.340476,-0.025990,-0.394953,0.024963,-0.137088,0.333816,-0.246412,0.071876,0.229482,-0.040889) * L1_14 + mat4(0.038414,-0.202012,-0.081186,0.046251,0.180461,0.265352,-0.168961,0.322832,-0.413151,-0.242416,0.141021,-0.066851,0.093083,-0.274706,-0.297600,0.134081) * L1_15 + vec4(0.082272,0.154463,-0.095323,0.166029)));\nvec4 L2_13 = sin((mat4(0.127424,-0.246994,-0.157289,0.069722,0.009922,-0.159363,0.234015,-0.213260,0.084905,0.300046,-0.063930,0.313391,0.023947,-0.063714,0.116415,0.274874) * L1_0 + mat4(0.197647,0.238341,0.178664,0.103809,-0.189061,-0.292580,-0.263613,0.066922,-0.048571,-0.247768,0.086673,-0.007764,-0.107535,0.132906,-0.319185,-0.006058) * L1_1 + mat4(-0.290348,-0.333279,-0.293377,0.147957,0.143179,0.211268,-0.018525,-0.100927,-0.317757,0.063104,0.213139,-0.325548,0.291564,-0.470734,-0.195482,-0.186810) * L1_2 + mat4(0.254424,0.047520,-0.076239,0.303045,-0.021595,0.084185,-0.170537,0.102083,-0.041395,-0.243337,0.312941,0.154247,-0.206729,0.015445,-0.302149,0.278909) * L1_3 + mat4(0.274494,-0.082544,-0.198397,-0.131440,0.246813,-0.459622,-0.257283,0.132186,-0.110484,-0.168887,0.004841,0.161850,0.179344,0.335096,-0.286568,-0.052261) * L1_4 + mat4(-0.117778,-0.026540,-0.355039,-0.174195,0.287893,0.183410,-0.164001,-0.338507,0.360213,0.230749,0.111042,0.274117,-0.206000,0.138701,-0.074819,-0.169195) * L1_5 + mat4(-0.426164,-0.170387,-0.403848,-0.356345,0.205464,-0.451754,0.101708,0.032284,-0.002696,0.053451,0.203343,0.260880,0.255912,0.186876,0.061228,-0.212271) * L1_6 + mat4(0.014555,0.208621,-0.204731,0.187859,0.511012,0.227338,-0.343560,-0.102202,-0.128425,-0.092789,-0.012081,0.263138,-0.068038,0.098014,-0.301903,0.080994) * L1_7 + mat4(0.051079,0.225137,-0.215224,-0.269389,0.139796,-0.036541,-0.106698,-0.312060,0.051749,0.118437,-0.175027,-0.131036,0.247141,0.062885,0.297287,0.039687) * L1_8 + mat4(0.149673,0.488436,0.202895,-0.141010,0.397024,-0.017475,-0.230087,-0.017067,0.066583,0.437694,-0.259156,-0.289937,0.159139,0.220515,0.236660,-0.068481) * L1_9 + mat4(-0.015435,0.071191,-0.052850,0.069559,-0.091576,-0.198881,-0.090127,-0.340797,0.054372,0.184105,-0.144424,0.218203,0.105484,0.111221,-0.056055,-0.475919) * L1_10 + mat4(0.055525,0.379708,-0.265042,-0.231469,0.211777,0.334407,-0.059592,0.234668,0.300346,-0.277947,-0.439706,-0.217081,0.054369,-0.294281,-0.144727,-0.215722) * L1_11 + mat4(0.151662,0.130623,0.203753,-0.109377,0.242135,0.191875,-0.174414,-0.076168,0.027475,-0.245080,0.201341,0.517001,-0.319642,0.191384,-0.150685,0.064236) * L1_12 + mat4(0.076201,0.296601,0.244519,-0.376208,-0.141246,-0.332176,0.030828,0.064983,-0.094585,-0.063722,0.003149,-0.177150,-0.329386,0.247197,-0.021692,0.133853) * L1_13 + mat4(-0.092331,0.292594,0.260925,-0.039889,0.568618,-0.080815,-0.271458,0.157414,-0.147934,0.020030,-0.147368,0.212642,-0.073637,0.189312,0.135811,-0.349111) * L1_14 + mat4(-0.053811,0.192782,0.289131,0.280791,0.232422,-0.181788,0.242252,0.186101,0.296670,-0.293391,0.222640,-0.028563,-0.284199,0.036823,0.144218,0.074209) * L1_15 + vec4(0.224648,-0.146345,0.234288,0.002274)));\nvec4 L2_14 = sin((mat4(0.095310,0.320384,-0.340738,0.043329,0.335235,0.163833,0.075831,-0.234047,0.255818,0.106083,-0.170187,0.128629,-0.333751,0.072370,0.421832,-0.059925) * L1_0 + mat4(0.280235,-0.443282,-0.018588,0.032106,0.116942,0.521160,0.126608,-0.142649,0.084721,-0.192947,0.311611,0.129366,-0.182296,-0.337163,0.061370,-0.225484) * L1_1 + mat4(0.100798,0.383263,0.393968,-0.341758,-0.130698,-0.000658,-0.056357,0.346108,0.039863,0.178142,-0.423506,0.484791,0.252889,0.329147,0.099777,-0.318819) * L1_2 + mat4(0.348892,0.155304,-0.422008,-0.281095,0.044213,-0.220549,0.211787,0.109178,0.191203,0.002253,-0.379128,0.185875,0.073105,-0.103404,-0.272757,0.128233) * L1_3 + mat4(0.262065,-0.441763,0.184949,0.105046,-0.264359,0.206620,0.042948,0.149076,-0.137671,-0.169727,0.314870,-0.118255,0.170549,-0.209146,0.012331,0.198242) * L1_4 + mat4(-0.320903,-0.022697,0.276748,-0.048508,0.324992,0.181575,0.045391,-0.138665,0.015647,0.117245,0.070710,-0.188335,-0.273238,0.047968,0.363380,0.492974) * L1_5 + mat4(0.051781,0.321144,0.264956,-0.491624,0.327903,-0.002867,0.015646,-0.222618,-0.452927,0.133282,-0.198560,0.289938,0.037123,0.188253,0.229736,-0.267327) * L1_6 + mat4(0.231212,-0.322915,0.238414,-0.329611,-0.088546,0.163178,-0.274459,0.117797,0.145330,-0.059781,0.073211,-0.247919,0.298213,-0.090641,0.469649,-0.427549) * L1_7 + mat4(0.351976,-0.146933,0.071481,-0.000586,-0.155129,0.281289,-0.106135,0.019194,0.074764,0.021848,0.059954,0.400801,-0.362284,0.363253,-0.377095,-0.026969) * L1_8 + mat4(0.171625,0.138718,-0.050986,-0.103354,0.250805,-0.152954,-0.162599,0.133543,0.223442,-0.204443,0.322673,0.098250,-0.065201,0.100492,0.047648,0.109126) * L1_9 + mat4(0.183417,-0.204093,0.066298,0.303801,0.162604,0.186597,-0.439811,-0.208382,-0.222477,-0.054927,0.204022,-0.284454,-0.219205,0.308121,-0.155278,-0.320036) * L1_10 + mat4(0.444859,0.421133,0.096389,-0.310769,-0.042757,0.344530,-0.216943,-0.094422,0.199725,0.224924,-0.034781,0.287207,-0.137469,0.144092,-0.091921,-0.005002) * L1_11 + mat4(0.199214,-0.043391,-0.121280,-0.219182,-0.197363,0.015852,0.147744,0.191862,-0.125099,-0.225730,0.240572,-0.122758,-0.046381,-0.392444,-0.306706,0.046608) * L1_12 + mat4(0.098001,-0.084687,0.226991,0.250397,-0.091354,-0.302318,-0.290954,0.424675,-0.025000,-0.245718,0.153352,-0.196092,-0.177053,-0.118070,-0.053755,0.386767) * L1_13 + mat4(-0.187126,-0.019269,-0.361126,0.047701,-0.268565,0.371976,-0.341845,0.318238,0.189750,0.011708,0.155546,-0.313719,0.259103,0.200213,-0.278725,-0.247653) * L1_14 + mat4(-0.000323,-0.093001,0.136897,0.062943,-0.212269,0.011998,0.226819,0.211185,0.212522,0.125976,-0.029891,-0.291604,0.021153,0.256318,0.206068,-0.061279) * L1_15 + vec4(-0.180101,0.177870,0.270218,0.349756)));\nvec4 L2_15 = sin((mat4(0.043751,-0.185294,-0.041767,0.281231,0.282367,0.029404,-0.212497,-0.159614,-0.081906,0.260393,0.265404,0.243637,-0.139681,0.041732,-0.095959,-0.228723) * L1_0 + mat4(0.252458,-0.070461,0.339087,0.155251,0.072511,-0.357248,-0.174183,0.203754,-0.294345,-0.204778,-0.135492,-0.109079,0.241156,-0.184775,0.272254,0.038947) * L1_1 + mat4(-0.438487,0.196058,0.299612,-0.283953,0.318745,0.418671,0.201799,-0.153909,0.105511,0.379070,-0.182090,-0.174452,-0.039876,-0.183575,-0.494379,-0.137844) * L1_2 + mat4(0.288010,0.117495,-0.182067,-0.092264,0.163542,-0.158375,-0.002122,-0.333022,0.133353,0.008640,0.166332,-0.162713,-0.271199,0.098794,0.125965,-0.322105) * L1_3 + mat4(0.010818,0.080303,-0.215402,0.196053,-0.059307,-0.026352,-0.006610,-0.041821,0.126131,0.290900,0.290019,0.299889,0.251928,-0.047715,-0.026313,0.106456) * L1_4 + mat4(0.278059,0.018980,-0.049832,-0.047395,-0.197532,-0.235384,-0.281423,-0.213157,-0.006866,-0.082023,-0.191415,0.139264,0.134078,-0.122573,-0.049573,-0.078958) * L1_5 + mat4(-0.032072,0.103929,0.360372,0.186532,-0.401361,0.139883,0.062097,-0.453817,0.152257,-0.091936,-0.389928,-0.042106,-0.349685,-0.351175,0.162543,0.114881) * L1_6 + mat4(-0.303769,0.198805,0.300439,0.020862,0.065063,-0.017278,0.145341,-0.016497,0.086305,-0.029848,-0.241701,0.405991,0.259418,0.223495,-0.139616,-0.461586) * L1_7 + mat4(0.156683,-0.106082,-0.169166,-0.053559,-0.187073,0.222943,0.003795,-0.131018,0.200010,-0.006500,-0.128717,0.069818,0.189960,0.189844,-0.187844,-0.204988) * L1_8 + mat4(0.109682,0.269751,0.068964,0.252863,-0.086205,-0.354909,0.227383,0.029096,0.037231,0.072352,0.302258,-0.262432,0.114252,-0.271399,-0.287988,0.008494) * L1_9 + mat4(-0.231247,-0.208714,-0.116357,0.028936,0.168493,-0.162758,-0.042119,0.152771,0.356339,0.000191,-0.169055,0.191581,0.053220,-0.107874,0.251062,-0.306282) * L1_10 + mat4(0.308958,-0.551571,0.137202,0.122884,0.405275,0.112705,-0.180430,0.032645,-0.055122,-0.252778,-0.276409,-0.156192,-0.398440,0.085997,-0.053766,-0.268974) * L1_11 + mat4(-0.349602,-0.015523,0.164358,-0.485121,0.218454,-0.157225,-0.069221,0.292068,-0.233583,0.085386,-0.011458,0.300561,0.245065,0.223732,-0.060916,-0.339210) * L1_12 + mat4(0.010208,-0.299215,0.147882,-0.189802,-0.379674,-0.190112,0.133632,0.462025,-0.175625,-0.134550,0.036495,-0.002751,-0.147175,0.317759,0.228094,0.146420) * L1_13 + mat4(-0.048134,0.181598,-0.200056,0.023293,0.077015,0.101039,-0.275833,-0.017244,-0.005855,0.021410,0.161966,-0.170406,-0.161984,0.003937,0.155983,0.230702) * L1_14 + mat4(0.174166,-0.260426,-0.269008,-0.033085,0.063991,-0.289858,-0.017363,0.199030,0.472545,0.190166,-0.161916,0.063713,-0.158719,0.270034,-0.267076,-0.111619) * L1_15 + vec4(-0.248078,-0.132878,0.258892,0.162931)));\nvec4 L3_0 = sin((mat4(-0.467974,-0.254309,0.201264,-0.167279,0.473451,-0.039013,0.022023,0.088152,-0.159037,-0.351976,0.232349,0.131595,0.114380,0.004002,-0.145213,-0.272881) * L2_0 + mat4(-0.195288,0.119037,-0.142836,0.397162,-0.099344,0.223941,0.051049,-0.083043,-0.024011,0.260374,0.053063,0.069572,-0.261877,-0.150015,0.169452,0.538274) * L2_1 + mat4(-0.218961,-0.204251,0.389756,-0.323571,0.007873,-0.205710,0.294395,0.161771,0.216707,-0.277133,0.154818,-0.250703,0.349531,-0.379031,0.135533,-0.263418) * L2_2 + mat4(-0.343789,0.277971,-0.110016,0.127912,-0.276504,0.097066,-0.003647,0.184543,0.074093,-0.261339,-0.198757,-0.202567,0.071841,-0.074398,0.302846,-0.169164) * L2_3 + mat4(-0.439858,-0.078149,0.483876,-0.191824,0.038198,0.117003,-0.277986,-0.210311,-0.108872,-0.004504,-0.168990,-0.088268,-0.130032,-0.164516,-0.021633,-0.331051) * L2_4 + mat4(0.166981,0.316341,-0.088055,0.274947,-0.363424,-0.054671,0.404078,0.141039,-0.240092,-0.010421,-0.379909,-0.118380,0.102545,-0.410629,0.362584,0.093954) * L2_5 + mat4(-0.058229,0.159457,0.002737,0.239649,-0.412548,-0.173802,-0.229848,0.074264,0.221437,0.182384,0.059756,-0.075621,0.083085,-0.041494,0.235870,0.002159) * L2_6 + mat4(0.332410,0.166287,0.360880,0.292954,0.223635,0.117027,0.242368,0.046982,-0.342345,-0.323339,0.189328,-0.211269,-0.224541,0.142732,0.224359,0.401852) * L2_7 + mat4(0.262680,0.178057,0.135548,0.161651,0.081364,0.050114,-0.040456,-0.081736,-0.001942,0.257116,0.185894,0.427088,0.068980,0.315505,-0.156008,-0.228491) * L2_8 + mat4(-0.109957,0.214203,0.123320,-0.189219,0.246744,0.056355,-0.198931,0.029954,0.371619,-0.098232,0.192548,-0.427194,0.071778,0.000456,-0.361099,-0.012615) * L2_9 + mat4(-0.229230,-0.255185,-0.035331,0.217956,0.212823,0.247764,0.139675,-0.191405,0.476710,-0.393666,0.249060,-0.007831,-0.182339,0.141309,-0.176681,-0.218598) * L2_10 + mat4(-0.263928,0.428594,0.317486,0.451092,-0.158982,-0.222579,0.321662,-0.050587,-0.434862,0.172275,0.030945,-0.516938,-0.033998,-0.115464,-0.170788,0.081889) * L2_11 + mat4(-0.185420,-0.167812,0.163388,-0.222515,-0.489359,0.061940,-0.078047,-0.132829,-0.170564,-0.261902,-0.054246,0.032262,0.295280,0.150827,0.204171,-0.080321) * L2_12 + mat4(0.164173,0.016531,-0.050549,0.282222,-0.068963,-0.097274,-0.018373,0.341673,-0.041818,-0.380621,-0.113680,-0.105624,0.099792,-0.130709,0.037153,-0.193085) * L2_13 + mat4(0.501518,-0.172986,0.276939,0.196002,0.224238,0.015101,-0.293525,0.041001,-0.304177,0.142469,-0.133677,0.325396,-0.570155,-0.126142,0.031075,-0.252613) * L2_14 + mat4(0.505652,0.106492,0.007862,0.256172,0.314437,-0.404041,-0.228522,0.186511,-0.116061,-0.306166,-0.136007,-0.049551,0.108488,0.222123,-0.243228,-0.146789) * L2_15 + vec4(0.329714,0.334642,0.008740,0.065435)));\nvec4 L3_1 = sin((mat4(0.119282,0.148640,0.021721,0.145672,0.441330,-0.483630,-0.008250,0.230952,-0.234912,0.125820,0.446217,-0.351249,-0.230379,0.038457,0.136486,-0.137163) * L2_0 + mat4(-0.061528,-0.394391,0.145106,-0.027066,-0.191542,-0.153378,0.154072,0.008832,-0.216860,-0.079241,0.301546,-0.082357,-0.025445,0.029477,-0.011662,0.182839) * L2_1 + mat4(0.070850,0.321535,-0.085168,-0.313024,0.203822,-0.321725,-0.198844,0.095949,0.222645,0.268238,0.278735,0.212279,-0.139911,-0.197351,0.187180,-0.321220) * L2_2 + mat4(0.012333,-0.012287,-0.332310,0.101987,-0.055217,0.078146,-0.156546,-0.186105,-0.180602,-0.210941,-0.249058,-0.120386,-0.037785,-0.000043,-0.354699,0.054432) * L2_3 + mat4(0.005502,-0.316032,0.261980,0.395512,0.092934,-0.180575,-0.448369,-0.163696,0.161481,0.439641,-0.126366,0.035634,-0.407366,-0.104010,0.084197,0.350336) * L2_4 + mat4(-0.227252,-0.107457,0.203338,-0.320230,-0.101607,-0.051463,-0.138290,0.284526,0.169090,-0.040948,0.055080,-0.615014,-0.436765,0.152770,0.440745,0.090293) * L2_5 + mat4(0.583274,-0.304329,-0.152727,-0.307128,0.283158,0.069164,0.270170,0.394417,0.226010,-0.095079,-0.136353,0.299656,0.272195,0.427241,0.105585,-0.075529) * L2_6 + mat4(-0.163889,-0.313451,-0.066041,0.103416,0.215292,-0.133574,0.210677,0.147874,-0.202933,-0.296106,-0.082550,0.559544,0.098110,0.396906,0.118276,0.204636) * L2_7 + mat4(0.262176,0.260895,0.041036,-0.243035,0.458071,0.388318,0.526622,0.223726,-0.354360,-0.220785,0.100103,0.025860,0.334477,-0.080285,-0.213937,0.321823) * L2_8 + mat4(0.175386,0.397446,-0.427710,-0.356989,0.000180,-0.080730,-0.511551,0.331692,0.153134,0.041425,-0.386226,-0.195964,-0.180823,0.028163,-0.139019,0.178166) * L2_9 + mat4(0.209343,-0.112612,0.079665,-0.063853,-0.062352,-0.457944,-0.059889,0.086781,-0.187481,0.123424,-0.323515,0.156038,0.188865,-0.096108,0.241804,-0.173829) * L2_10 + mat4(-0.225169,-0.089940,0.084911,0.363229,0.686188,0.251137,0.263669,0.069760,-0.218858,-0.204969,-0.063207,-0.097017,0.139453,-0.083515,0.297740,-0.062635) * L2_11 + mat4(-0.169734,0.209972,0.087988,-0.160971,0.248478,0.526119,0.095175,-0.122675,0.213116,0.007984,0.166606,0.338926,-0.091186,-0.251720,0.178456,-0.212181) * L2_12 + mat4(0.198766,-0.129872,-0.094485,-0.034368,-0.045183,0.245544,0.249838,-0.263735,-0.178972,-0.023292,0.289471,0.152997,-0.239733,-0.313066,0.214148,-0.209021) * L2_13 + mat4(-0.070886,0.283980,-0.003046,0.212879,0.283964,0.400229,0.085974,0.132855,-0.002489,0.125447,0.243175,0.105750,-0.091417,-0.169434,-0.015732,-0.041701) * L2_14 + mat4(0.204283,-0.305351,0.070513,0.075400,-0.061415,-0.289925,-0.107573,0.524291,-0.426746,-0.354801,-0.056867,-0.341757,-0.142638,0.184519,-0.262444,-0.400567) * L2_15 + vec4(-0.103971,0.037317,0.110373,-0.063933)));\nvec4 L3_2 = sin((mat4(0.096902,0.103273,0.237249,-0.105761,0.088470,-0.468647,-0.163784,0.296861,-0.388809,-0.052001,-0.023017,-0.348007,0.321152,0.099066,0.045039,-0.239245) * L2_0 + mat4(-0.124603,0.067053,-0.162039,0.012182,-0.009749,-0.029748,-0.084937,0.189362,0.183889,-0.368902,-0.174449,0.002170,-0.138305,0.085380,0.459131,-0.160353) * L2_1 + mat4(-0.253859,-0.091248,-0.220052,-0.332486,0.133316,0.318507,-0.060475,-0.065639,0.131224,-0.166076,0.015762,0.186155,-0.278373,-0.443409,-0.202759,0.137118) * L2_2 + mat4(0.178642,0.222814,0.072398,0.009434,-0.089641,0.237336,0.022304,-0.379188,0.027387,0.307145,0.265069,0.002436,0.075286,-0.030126,-0.021893,0.026765) * L2_3 + mat4(-0.349616,0.049310,0.042158,-0.069336,0.121387,0.188337,0.257964,0.017971,0.095936,0.183890,0.094735,0.170673,-0.118429,-0.098793,-0.134869,0.368580) * L2_4 + mat4(0.236482,-0.041663,0.115181,-0.237138,0.043501,-0.292057,0.295637,-0.158045,-0.255991,-0.038867,-0.189707,-0.365949,0.037617,-0.235452,0.219400,-0.265641) * L2_5 + mat4(0.114424,-0.106372,-0.190266,-0.130048,-0.226994,-0.011623,-0.153987,-0.001782,0.296073,-0.080871,0.004681,0.316425,-0.042607,0.466960,0.102414,-0.462045) * L2_6 + mat4(-0.467988,-0.184888,0.171567,-0.269182,0.209728,0.177171,0.002432,-0.114510,0.190707,0.132801,0.416259,0.153254,-0.208138,0.044777,0.321261,-0.060453) * L2_7 + mat4(0.337216,-0.439440,0.111836,-0.144017,0.118228,0.021223,0.268084,0.264349,0.252133,-0.280913,-0.237293,-0.520479,-0.248294,0.015266,0.040175,0.299084) * L2_8 + mat4(0.193634,-0.147831,-0.234350,-0.158945,0.106642,-0.017935,-0.019265,-0.173127,-0.268660,-0.205981,0.087703,0.372489,0.036809,-0.176974,-0.132772,-0.239875) * L2_9 + mat4(0.582617,-0.138450,0.414816,-0.025645,-0.078818,0.236104,-0.056872,0.043232,0.218855,0.436957,-0.036934,0.492985,0.073567,0.127826,-0.209979,-0.099665) * L2_10 + mat4(0.215618,-0.260017,0.238531,-0.301997,-0.224514,0.469696,0.127996,0.154189,-0.073435,-0.468852,-0.367418,0.100315,0.210532,0.167802,0.401011,0.026867) * L2_11 + mat4(-0.168557,-0.055753,0.138653,0.167050,-0.260051,0.230602,-0.035323,-0.061075,-0.447398,0.157325,-0.558380,0.141296,0.009696,0.700994,0.278331,-0.017287) * L2_12 + mat4(-0.292431,-0.157561,0.077704,-0.225057,0.078691,0.140266,0.369130,0.045931,0.086576,0.383361,-0.126464,-0.430733,0.039251,0.184152,-0.098362,0.101463) * L2_13 + mat4(-0.325544,-0.372943,-0.380784,-0.043148,0.190569,-0.432077,0.268920,0.015739,0.061639,0.075045,-0.006896,-0.313054,-0.170718,-0.041494,0.394965,-0.117429) * L2_14 + mat4(-0.355359,-0.115182,0.224738,0.064764,-0.063394,0.039533,0.372051,-0.194393,0.254590,-0.102731,-0.073943,-0.042743,-0.071418,-0.079467,0.195193,0.394443) * L2_15 + vec4(0.434552,-0.029906,0.183716,0.038406)));\nvec4 L3_3 = sin((mat4(0.005653,0.047077,0.234680,0.028980,-0.071598,-0.305663,0.257527,0.373913,0.138425,0.174051,-0.173006,-0.253585,-0.257949,-0.134720,0.043260,0.184046) * L2_0 + mat4(-0.118862,-0.044784,0.372003,0.237515,-0.211235,-0.292960,-0.046056,-0.271480,-0.467238,-0.200690,-0.136275,-0.585545,0.232022,0.066384,0.420821,0.049529) * L2_1 + mat4(-0.270010,0.129717,-0.098633,-0.040989,-0.143998,0.275585,-0.070353,0.215593,-0.003612,-0.330120,0.266809,-0.077582,-0.264586,0.237496,0.503545,-0.107793) * L2_2 + mat4(0.221684,-0.429458,0.058051,0.022973,0.225825,-0.159582,0.068967,-0.278330,-0.209355,-0.139728,0.147829,0.275949,0.428761,-0.261424,-0.044400,-0.080616) * L2_3 + mat4(-0.010246,-0.034872,0.469835,0.274936,0.433044,-0.123841,-0.093378,-0.186473,-0.030457,-0.005085,0.326296,0.315501,-0.044539,-0.084913,0.150654,-0.213689) * L2_4 + mat4(0.142371,0.269993,-0.475205,0.372388,0.086730,0.163944,0.282645,0.394404,-0.310318,-0.205287,-0.112542,0.045810,0.003203,0.111446,-0.033046,0.245631) * L2_5 + mat4(-0.081366,-0.196501,0.656695,0.428432,0.172539,-0.069226,-0.010379,-0.112417,-0.278515,0.064100,-0.038219,0.207111,-0.142679,0.118324,-0.241679,0.254469) * L2_6 + mat4(0.035179,0.205450,0.199303,-0.327203,-0.341382,0.332432,-0.007972,-0.217525,-0.360621,-0.177508,-0.173313,0.242739,-0.035059,-0.233448,0.175653,-0.277055) * L2_7 + mat4(-0.322792,-0.097606,0.055199,-0.280928,-0.387329,0.247025,-0.020737,0.243815,0.225927,-0.328676,-0.094652,-0.388253,0.059768,-0.075098,-0.052520,0.278246) * L2_8 + mat4(0.268795,-0.279988,0.397655,-0.281864,0.090282,0.132156,0.094759,0.219863,0.113566,0.195501,0.248768,-0.164430,0.038553,-0.154668,0.313080,-0.003294) * L2_9 + mat4(0.425053,0.381220,-0.303261,0.198823,0.096772,0.134233,0.146124,-0.087812,-0.110815,0.022443,-0.104752,-0.042135,0.305757,-0.107702,-0.353259,0.132526) * L2_10 + mat4(0.006926,0.362457,-0.377903,0.184388,0.067872,0.015340,0.230184,-0.081552,-0.100771,-0.166668,-0.051554,0.201603,0.192895,-0.204060,-0.270540,-0.074509) * L2_11 + mat4(-0.089718,-0.046422,0.040459,-0.129234,-0.008677,-0.377975,0.097307,0.340487,0.143259,-0.199374,-0.370770,-0.165995,0.044816,0.107812,0.294783,0.367579) * L2_12 + mat4(-0.272098,-0.018348,-0.279657,-0.077659,-0.534880,0.104693,0.138447,0.196168,-0.185023,-0.114369,0.078403,-0.218876,0.089371,-0.422132,-0.055490,-0.338210) * L2_13 + mat4(-0.241649,-0.111838,0.055813,-0.077394,0.132779,0.236225,-0.521566,0.275700,0.239617,-0.303740,0.266743,-0.183320,-0.060126,0.169696,-0.177333,-0.187858) * L2_14 + mat4(0.072071,0.406748,0.054008,0.238046,-0.129384,-0.147208,0.180204,-0.055454,-0.065386,0.035933,0.388994,0.310250,0.037479,-0.119739,0.024678,-0.071150) * L2_15 + vec4(0.053968,-0.042716,-0.071149,0.002689)));\nvec4 L3_4 = sin((mat4(0.073728,0.383048,0.252135,-0.267613,-0.122540,-0.262383,-0.304676,-0.151633,0.180710,0.137352,0.401909,0.175220,-0.161248,0.390979,-0.183403,0.285058) * L2_0 + mat4(0.084762,0.017714,-0.226655,0.094800,0.159919,-0.038465,-0.218491,-0.232401,0.246701,0.071788,0.082046,0.101797,0.196655,0.235803,0.015130,-0.370176) * L2_1 + mat4(0.058824,-0.383323,-0.206080,0.207150,-0.202541,-0.003459,0.496897,0.038997,-0.359863,0.144326,-0.283632,0.444014,-0.301741,0.309939,-0.087161,-0.292071) * L2_2 + mat4(-0.102901,-0.357131,-0.311142,0.065663,-0.314788,-0.031805,0.043304,-0.315713,-0.085882,-0.303883,-0.213316,0.093728,0.055709,0.146626,-0.261800,-0.247851) * L2_3 + mat4(-0.139629,-0.016228,-0.193187,-0.306861,0.291471,0.064811,-0.083326,0.234706,0.237696,0.160971,0.090011,0.169218,0.509521,-0.139556,-0.140087,0.105152) * L2_4 + mat4(-0.020638,0.060479,-0.040149,0.101458,0.031766,0.300387,0.124557,-0.239745,-0.204707,-0.248911,-0.442372,-0.199471,0.082502,-0.159636,0.393489,-0.408250) * L2_5 + mat4(0.315954,-0.119953,-0.141626,-0.491619,-0.059713,0.220627,0.059329,-0.028075,0.129281,-0.026431,-0.139991,0.205518,0.297134,0.013168,0.188250,-0.275177) * L2_6 + mat4(0.024572,-0.289094,-0.440474,-0.326950,-0.096126,0.077250,-0.180799,0.002721,-0.358907,-0.114601,-0.121739,0.077592,-0.181318,0.179577,-0.030117,0.338863) * L2_7 + mat4(-0.032366,-0.292376,-0.213465,0.225254,-0.197230,-0.326494,-0.138373,-0.207398,0.058208,-0.044719,0.066523,-0.334452,-0.110104,-0.441077,0.056782,0.079135) * L2_8 + mat4(-0.268376,-0.351280,0.145566,-0.011054,0.112793,-0.198263,-0.419938,0.064276,-0.035540,0.016685,0.339000,0.185674,-0.180215,0.188580,0.306264,-0.103662) * L2_9 + mat4(0.205925,0.025254,0.251209,0.157358,0.151393,-0.178419,0.172337,-0.066285,0.081779,-0.000788,-0.200707,0.200492,-0.242552,0.177861,-0.235364,0.205316) * L2_10 + mat4(-0.066965,0.500133,-0.094527,0.199269,0.022316,-0.205253,-0.014798,0.364281,0.241001,-0.027330,0.132882,0.384070,-0.138749,0.197743,0.194592,0.121912) * L2_11 + mat4(0.201228,-0.069873,-0.275986,-0.302644,0.303054,-0.120360,-0.285298,-0.248798,-0.119604,-0.189636,-0.007272,0.308564,0.050652,0.296266,-0.323392,-0.336392) * L2_12 + mat4(0.039727,-0.307520,-0.019753,0.040694,0.454153,0.234048,0.036227,-0.170954,0.301682,-0.036389,-0.248603,0.055200,-0.002829,0.234476,0.358151,0.262114) * L2_13 + mat4(-0.218116,-0.216663,-0.036019,0.301698,0.005512,0.131258,0.092381,0.199176,-0.269376,0.047685,-0.320004,-0.479224,0.257757,-0.140593,-0.313778,0.020712) * L2_14 + mat4(0.051074,0.244436,-0.370992,0.051490,-0.198566,0.326970,0.242447,0.243818,0.045386,-0.155357,0.354384,0.185989,-0.136694,0.076109,-0.094491,-0.059877) * L2_15 + vec4(-0.336995,0.180515,0.099964,0.316070)));\nvec4 L3_5 = sin((mat4(0.283969,0.153004,-0.007828,0.003957,-0.123009,0.030773,-0.130578,-0.221948,0.067571,-0.157316,0.085758,0.195079,-0.115214,0.215771,-0.131503,-0.113933) * L2_0 + mat4(-0.407876,0.269299,0.126379,0.348124,0.003703,-0.205540,0.189542,-0.175911,-0.192892,-0.179637,0.106422,-0.104428,-0.442483,0.197792,-0.313607,0.250935) * L2_1 + mat4(-0.232213,0.233994,-0.415349,0.176248,-0.248058,0.315092,0.396918,0.115466,-0.027701,-0.474872,-0.242266,0.103710,-0.049355,-0.056925,-0.008788,-0.092809) * L2_2 + mat4(0.101670,0.008726,-0.253300,0.045004,0.273386,-0.096474,-0.241210,-0.401113,0.010860,-0.137890,0.085283,-0.091027,0.031906,-0.218149,-0.212128,-0.056692) * L2_3 + mat4(-0.174728,-0.518381,-0.293220,0.189652,0.226498,0.542437,-0.105717,0.204599,-0.278562,-0.156302,0.369187,0.515116,0.181417,0.106070,0.178879,0.380722) * L2_4 + mat4(-0.276101,0.006129,0.168379,0.078139,0.014428,-0.215618,0.171269,0.269605,0.064898,-0.165369,0.365256,-0.088991,0.299870,0.018461,-0.013922,0.416729) * L2_5 + mat4(0.015387,-0.188827,-0.047374,-0.031482,0.324988,-0.192014,-0.022538,0.117299,0.181518,0.428341,-0.436838,-0.032701,-0.163792,0.123344,0.397927,0.021362) * L2_6 + mat4(0.111269,-0.119324,-0.067604,0.319553,0.337757,0.011799,0.228574,0.111120,-0.200561,-0.022062,-0.206409,0.013645,0.214190,0.283749,-0.058382,0.293641) * L2_7 + mat4(-0.227953,0.177704,-0.085880,-0.100079,-0.060905,0.511188,0.054071,0.230277,-0.060162,-0.093181,0.279591,0.314168,0.133138,0.140088,0.026094,-0.080405) * L2_8 + mat4(-0.067248,0.043677,0.329101,0.351730,0.000208,0.122469,0.147577,0.342636,0.009257,-0.254845,-0.031833,0.355351,0.065184,0.225646,0.073437,0.143516) * L2_9 + mat4(0.058885,0.330629,0.345353,-0.190890,-0.274100,-0.318820,0.414350,-0.171462,-0.161116,-0.165986,0.148302,0.080830,0.064144,0.467185,0.149380,-0.033478) * L2_10 + mat4(0.121837,-0.142493,-0.061526,0.007999,-0.513232,0.174390,0.482120,0.039401,0.068211,-0.220415,0.140389,0.184830,0.215502,0.339186,-0.140735,0.124066) * L2_11 + mat4(0.146997,-0.131734,0.245392,0.032222,0.147826,0.140864,-0.123721,0.055721,0.308282,0.108678,0.188783,0.026616,0.295121,0.090530,-0.246285,0.088617) * L2_12 + mat4(-0.426421,0.023349,0.133780,-0.146217,0.387202,-0.090095,-0.271788,0.177785,0.214846,0.056495,0.162881,-0.195980,-0.157251,0.120534,-0.310690,-0.226453) * L2_13 + mat4(0.239773,-0.147816,0.002936,-0.267962,-0.102610,-0.203274,-0.052479,0.399001,0.232881,0.212653,0.454864,0.100234,-0.270498,-0.323221,0.035683,-0.225333) * L2_14 + mat4(-0.263035,-0.069317,0.201824,0.009682,-0.176458,-0.112827,-0.233068,0.233400,0.234148,0.171734,-0.212093,-0.257557,-0.349651,0.096471,0.088069,0.234355) * L2_15 + vec4(0.317210,0.053380,-0.078293,0.247707)));\nvec4 L3_6 = sin((mat4(-0.094020,0.440949,-0.020846,-0.323484,0.238471,-0.162907,-0.128925,0.294744,0.133181,0.115221,-0.039952,0.146118,-0.131185,-0.250350,0.180002,-0.323697) * L2_0 + mat4(-0.140682,-0.155639,0.273951,0.377176,-0.172901,0.114196,-0.348749,0.085302,0.233121,0.633720,0.196663,0.039427,-0.205951,-0.022117,-0.050080,0.240674) * L2_1 + mat4(0.146340,0.003847,0.172375,0.211635,0.237859,0.042729,-0.037990,-0.151877,0.258588,0.185007,-0.228122,-0.169522,0.126631,-0.242111,0.343336,0.358372) * L2_2 + mat4(-0.283527,0.139849,-0.405469,-0.326211,0.425880,0.400108,0.060670,0.124865,-0.304265,0.203426,0.472717,0.195380,0.284826,-0.305410,-0.130177,0.192609) * L2_3 + mat4(-0.559590,0.328681,-0.018518,-0.170899,0.070700,0.040288,-0.095018,0.304144,0.152922,0.252889,-0.425884,0.005270,0.018878,-0.104865,0.151802,-0.232237) * L2_4 + mat4(0.159178,-0.412902,-0.301967,0.030009,-0.190171,-0.085371,0.160330,0.066447,0.098738,-0.064557,-0.209689,-0.074824,0.357513,-0.131468,0.244969,-0.177200) * L2_5 + mat4(0.206378,0.012153,-0.078253,0.067841,0.106752,0.258813,-0.165930,-0.037049,0.095619,-0.387138,-0.172938,-0.249489,-0.199000,-0.064960,0.173802,0.064115) * L2_6 + mat4(0.154495,-0.212359,-0.058514,-0.415356,-0.432184,-0.060232,0.127486,0.309668,-0.372411,0.058938,-0.199957,0.314582,0.269643,0.158930,0.440996,-0.012965) * L2_7 + mat4(0.330411,-0.033373,-0.082554,0.056456,-0.069722,0.209713,-0.014757,0.058181,0.161018,-0.025191,-0.189336,0.292001,-0.103919,0.072277,-0.258370,-0.132619) * L2_8 + mat4(-0.266066,-0.125387,0.405565,-0.112589,0.005649,-0.328604,-0.031449,-0.362170,0.252415,0.157136,-0.104816,-0.041999,0.185180,-0.140396,0.254097,-0.198041) * L2_9 + mat4(-0.073695,-0.350096,-0.069116,0.395517,-0.080159,0.033245,0.400541,-0.305501,0.298911,-0.190038,-0.210328,0.268393,0.004446,0.153497,-0.525442,-0.364493) * L2_10 + mat4(-0.253117,-0.127826,0.097799,-0.107416,0.132029,-0.012372,0.407931,0.203261,0.424965,0.212474,0.245518,-0.253309,-0.353002,0.063732,0.383959,0.126630) * L2_11 + mat4(0.224186,0.199293,0.382673,-0.400100,0.120447,0.167804,-0.231092,-0.046338,0.263271,0.258082,-0.187052,-0.136324,-0.276771,0.228075,0.303458,0.155294) * L2_12 + mat4(0.439890,0.096419,-0.274613,-0.136077,-0.022004,-0.057598,-0.358315,0.408733,-0.196105,0.079304,0.129887,-0.080835,-0.217208,-0.055234,0.086845,0.104600) * L2_13 + mat4(0.057613,-0.061827,0.097220,0.383194,-0.095944,-0.108746,-0.021606,-0.084599,0.009109,0.044072,0.314307,-0.095670,-0.172160,-0.015513,-0.109218,-0.200014) * L2_14 + mat4(0.194832,0.259978,-0.067358,0.030221,-0.382522,0.020156,0.173523,-0.002962,0.177228,-0.209985,0.153951,0.469379,-0.228600,-0.315041,-0.158195,0.300390) * L2_15 + vec4(-0.360109,0.126839,-0.306089,-0.203024)));\nvec4 L3_7 = sin((mat4(0.111733,-0.324507,0.127419,-0.216179,-0.293512,-0.107796,-0.238254,0.024000,0.237700,-0.195183,0.089410,0.283303,-0.226834,0.078344,0.222959,-0.193934) * L2_0 + mat4(0.279763,0.365632,0.217845,-0.074972,-0.018496,-0.198722,-0.329041,0.006702,-0.181859,-0.118727,0.087027,-0.334253,0.225149,-0.214173,0.496592,-0.393204) * L2_1 + mat4(0.113410,-0.071599,-0.012786,-0.176811,0.070396,0.353473,-0.184214,-0.242531,-0.288005,0.413587,0.359693,-0.024090,0.217178,-0.441819,-0.502344,0.085883) * L2_2 + mat4(-0.228397,0.062319,-0.430346,0.202536,-0.084222,0.237512,0.053504,-0.094457,-0.049904,0.035873,-0.229521,-0.067792,-0.167454,-0.019102,0.008348,-0.486691) * L2_3 + mat4(-0.293185,0.238801,-0.197805,-0.122324,0.215467,0.290168,-0.092572,0.372965,0.077602,-0.172596,0.103511,-0.456653,0.038321,-0.272611,-0.171611,0.342139) * L2_4 + mat4(0.059268,0.029607,0.461733,-0.190947,0.270616,0.261880,-0.283179,0.239502,0.072004,0.254511,0.230495,-0.009689,0.407839,-0.129042,0.109923,0.345008) * L2_5 + mat4(-0.069445,0.107035,0.175274,0.076233,0.077131,-0.510795,-0.436006,-0.235646,0.263431,-0.321178,-0.296397,-0.187466,-0.188726,-0.295540,0.074039,0.157561) * L2_6 + mat4(-0.061806,0.356083,-0.075248,0.442348,-0.199351,0.222490,0.189714,0.412654,-0.032539,-0.087985,-0.280218,0.255461,0.132902,-0.077892,-0.142889,-0.345621) * L2_7 + mat4(-0.214483,0.006337,0.153812,-0.044606,-0.233424,-0.283289,0.468322,-0.182021,0.057716,0.062919,0.303233,-0.267125,0.108375,-0.096020,-0.213999,-0.299476) * L2_8 + mat4(-0.354083,-0.266875,-0.020858,-0.066916,0.068411,-0.182643,-0.120101,0.179492,0.001079,0.379613,0.046637,0.109263,0.027291,-0.071534,0.094878,-0.105706) * L2_9 + mat4(0.249823,0.018417,-0.128934,-0.121376,-0.001689,-0.017189,-0.138104,0.244697,-0.218231,0.321398,0.205443,0.572365,0.309471,-0.255493,-0.020002,-0.178693) * L2_10 + mat4(0.385886,0.333216,0.216259,-0.186134,-0.299305,-0.377875,-0.423408,0.474274,0.487707,0.066839,-0.172054,-0.180019,-0.249244,0.017830,-0.133664,-0.121401) * L2_11 + mat4(-0.027009,-0.259342,0.211443,-0.234351,0.461552,0.028593,0.199854,-0.094354,-0.139038,-0.382127,0.107054,0.492895,-0.018192,-0.299923,-0.031889,-0.122950) * L2_12 + mat4(-0.079959,-0.144871,-0.045802,-0.013804,0.110290,0.087303,-0.329334,-0.161123,-0.112424,0.366722,-0.152483,0.006645,-0.284573,-0.060902,0.381731,-0.028930) * L2_13 + mat4(0.130811,0.014338,-0.122504,0.193097,-0.246409,0.284613,-0.088965,-0.258037,-0.042239,0.274151,0.466341,-0.036101,-0.174824,-0.041442,0.147769,-0.039448) * L2_14 + mat4(-0.069845,-0.384488,0.088649,0.268442,0.132955,-0.097836,-0.016820,-0.346503,0.311273,-0.068300,0.183269,0.128049,-0.037298,-0.255902,-0.101686,0.042008) * L2_15 + vec4(0.108399,0.170290,0.264926,-0.143629)));\nvec4 L3_8 = sin((mat4(-0.106331,-0.117066,-0.110503,-0.159768,-0.625123,0.285979,-0.067217,-0.253808,0.433470,-0.329527,0.044218,-0.284134,-0.024247,0.367456,-0.351609,-0.330513) * L2_0 + mat4(-0.024368,0.412517,0.272780,0.005247,-0.100107,-0.116010,-0.054953,-0.303858,-0.106559,-0.188570,0.032591,-0.005515,-0.324278,0.076115,0.195997,-0.135575) * L2_1 + mat4(0.102031,0.008699,-0.340563,-0.294966,-0.170272,-0.328723,-0.297724,-0.010350,0.046714,0.311407,0.131398,0.155279,0.301676,0.295927,-0.182500,0.230726) * L2_2 + mat4(-0.337050,-0.274613,-0.342135,-0.210070,-0.080086,0.094995,-0.212754,-0.099124,0.051994,0.006430,-0.010003,-0.061626,0.202435,0.015828,-0.250773,-0.085338) * L2_3 + mat4(-0.228664,0.000049,-0.153354,0.154427,0.044354,0.315470,0.286929,-0.096290,-0.541204,0.173588,0.017926,-0.020670,0.362821,0.116315,0.134403,0.057687) * L2_4 + mat4(-0.075986,-0.355849,-0.266829,-0.074251,-0.248295,0.139300,0.357641,0.174746,0.481764,-0.318313,-0.118236,0.112759,-0.284291,-0.058952,-0.005208,-0.145331) * L2_5 + mat4(0.257033,-0.108765,0.439507,0.084948,-0.327704,0.019312,-0.045365,0.155956,-0.369818,0.197589,-0.263135,0.052642,-0.256654,-0.235274,0.339402,0.053535) * L2_6 + mat4(0.104028,0.357240,-0.059101,-0.024195,-0.030385,-0.196117,-0.190606,-0.005243,0.107427,0.205705,0.045949,-0.494756,0.105686,-0.263780,0.271030,0.004508) * L2_7 + mat4(0.057668,-0.134802,0.223778,0.079310,-0.203960,0.309503,0.310914,0.002565,-0.306899,0.307361,-0.092805,0.083720,0.338813,0.213179,0.161576,-0.427389) * L2_8 + mat4(0.175476,0.102378,0.246543,-0.020419,-0.203735,0.215112,0.115407,0.228194,0.382216,-0.007077,0.093793,-0.273212,-0.232827,0.007611,-0.118979,-0.263112) * L2_9 + mat4(0.025831,0.059540,-0.196409,0.295069,0.125350,0.332863,-0.312763,-0.005850,0.137511,0.187493,0.286824,0.301713,0.366449,0.495456,-0.519597,-0.144621) * L2_10 + mat4(0.174260,0.132259,-0.049102,-0.187225,0.129750,-0.101170,0.243468,-0.388852,0.147797,0.591599,0.318878,-0.061668,0.146755,0.434685,-0.061975,-0.182284) * L2_11 + mat4(-0.117703,0.097177,-0.152396,-0.026303,0.210430,0.200920,-0.483032,0.305836,0.170629,0.295568,0.166249,0.208379,-0.303545,-0.239812,0.184032,0.267427) * L2_12 + mat4(0.204794,0.132683,-0.177305,-0.386429,0.055913,-0.258778,-0.007477,0.190219,-0.047149,-0.231652,0.006878,-0.407436,-0.142433,-0.082363,0.246601,0.295997) * L2_13 + mat4(0.030333,0.102663,-0.201397,0.330777,-0.179096,0.022539,-0.127852,0.290827,-0.234892,0.270609,0.230495,-0.083734,0.306142,-0.008510,-0.114672,-0.045914) * L2_14 + mat4(-0.061208,-0.221418,-0.356816,-0.316106,-0.002966,-0.176735,0.197865,-0.111090,0.166166,-0.127389,-0.140697,0.096183,-0.094168,0.093741,-0.107713,-0.115170) * L2_15 + vec4(0.118854,-0.303674,-0.109521,0.071708)));\nvec4 L3_9 = sin((mat4(-0.076492,-0.215370,-0.622814,0.233590,0.311848,0.177383,0.277885,0.038759,-0.236208,-0.031383,-0.122938,-0.269091,0.165007,0.110191,-0.262729,-0.129866) * L2_0 + mat4(0.148175,-0.366625,-0.128752,0.189760,-0.226566,0.461537,0.349514,-0.023039,0.071032,0.076042,0.220582,0.018047,-0.323496,-0.054674,-0.106429,-0.096118) * L2_1 + mat4(0.269377,-0.085027,-0.035864,0.095759,-0.323064,-0.525800,-0.489349,0.396886,0.094618,0.094517,0.312256,-0.099477,-0.325933,-0.316465,0.403559,0.006864) * L2_2 + mat4(-0.068977,0.023715,0.197087,-0.397863,0.148633,-0.218072,-0.094996,-0.003429,0.367211,-0.133421,-0.122539,0.142445,-0.013745,0.035638,-0.141964,0.030258) * L2_3 + mat4(-0.026308,0.239253,-0.112449,0.113665,0.289347,-0.276372,0.380519,-0.051042,-0.269224,-0.304204,0.425294,-0.066877,-0.030402,0.259185,-0.054620,0.374212) * L2_4 + mat4(-0.090150,-0.109832,0.349818,-0.136750,0.056950,-0.196408,-0.154625,0.092121,0.162503,-0.086004,-0.130810,0.262016,0.026191,0.033289,0.386181,-0.077060) * L2_5 + mat4(-0.105589,-0.265544,0.108200,-0.122128,-0.242631,0.075842,-0.144715,-0.010677,0.427058,0.241676,-0.285223,-0.128777,0.095713,0.120172,-0.065777,-0.254428) * L2_6 + mat4(0.116695,0.200737,0.337127,0.139341,0.244687,-0.266795,-0.167732,-0.262942,-0.146791,0.163883,0.062909,0.208369,-0.046404,0.093213,-0.137577,0.385431) * L2_7 + mat4(0.035325,-0.406419,0.117443,0.404298,-0.330701,-0.068617,-0.384932,-0.045185,-0.610668,0.008723,0.183282,0.334221,-0.244978,0.057170,-0.297947,-0.396286) * L2_8 + mat4(-0.000419,-0.176823,-0.314747,0.082434,0.373339,-0.091201,-0.345242,-0.147269,0.079701,-0.041350,-0.265501,-0.325489,0.314152,-0.119435,0.201146,-0.290955) * L2_9 + mat4(-0.271544,0.103563,0.031178,-0.318483,-0.248907,0.126727,0.082619,0.026893,0.279804,-0.234420,0.368791,0.123803,0.033186,0.032783,-0.107688,-0.040303) * L2_10 + mat4(-0.152161,-0.144067,-0.115275,0.132431,-0.314940,-0.408168,0.349340,0.168125,0.113051,-0.115238,-0.305279,-0.263034,0.113655,-0.441239,-0.244057,0.536312) * L2_11 + mat4(0.124408,-0.017038,0.176055,0.033594,0.388301,0.078604,0.409507,-0.042522,-0.161134,-0.393053,-0.023152,-0.014213,0.074696,0.106740,0.122484,0.074237) * L2_12 + mat4(0.164911,0.199491,0.212075,0.052370,0.393767,-0.279892,0.173376,0.247594,-0.041461,0.383083,0.074182,0.027102,-0.267956,-0.254441,0.105306,-0.197938) * L2_13 + mat4(-0.231764,0.031250,0.009945,-0.115612,0.423424,0.180056,0.219360,-0.302825,-0.207506,0.208365,0.177771,-0.183918,0.112097,-0.075396,-0.099824,-0.293885) * L2_14 + mat4(0.058572,0.292276,0.051796,0.313706,0.222158,0.230990,0.088082,0.343171,-0.056332,-0.186763,-0.099701,0.161938,-0.174204,-0.074601,-0.291099,0.156436) * L2_15 + vec4(0.230468,-0.001126,0.462244,0.213565)));\nvec4 L3_10 = sin((mat4(0.300608,0.131539,-0.285385,0.338917,-0.128358,-0.138700,-0.084924,-0.100802,0.213709,-0.372568,-0.294930,0.221875,-0.144697,0.375472,-0.449956,-0.221943) * L2_0 + mat4(0.027112,0.020580,0.333412,0.011114,-0.129530,0.011263,0.199893,0.045589,-0.101708,-0.335026,0.364231,0.128547,0.399883,0.219139,-0.046665,0.033340) * L2_1 + mat4(0.176333,0.218990,0.132714,0.086014,0.023470,-0.153542,-0.069556,0.249464,0.149385,-0.084498,0.171459,0.283993,0.281555,-0.175456,-0.507874,0.466385) * L2_2 + mat4(0.209453,0.153199,0.475092,0.322631,0.178798,-0.285879,-0.086668,-0.030035,-0.093124,0.080065,-0.439758,-0.427094,0.188895,-0.001542,-0.161007,-0.142668) * L2_3 + mat4(0.415571,0.133062,0.268142,-0.081376,0.175829,0.199984,0.336447,0.228409,-0.163809,0.265897,0.259851,0.166090,-0.299263,0.411201,-0.147952,0.045773) * L2_4 + mat4(-0.070536,0.127464,0.050002,-0.227771,-0.280795,-0.199763,-0.048888,-0.021550,0.258517,0.214218,-0.349894,0.072939,0.036301,0.017776,0.347180,-0.257276) * L2_5 + mat4(0.085928,0.020248,0.201209,0.312380,0.171813,0.278092,-0.471529,0.147332,0.152331,-0.254655,0.009711,0.198481,0.211699,0.153094,0.196826,-0.195481) * L2_6 + mat4(-0.099983,0.139856,0.019821,-0.086107,0.065938,0.231685,0.420055,0.150473,-0.214298,-0.012888,-0.339800,-0.073802,-0.436203,-0.108986,0.284536,-0.270880) * L2_7 + mat4(0.002157,-0.273213,0.108445,0.001173,0.241380,0.260182,0.021366,-0.095286,0.279474,0.034968,0.038556,-0.060897,0.328848,0.115180,-0.251265,-0.309497) * L2_8 + mat4(-0.230587,-0.072275,0.386742,-0.281913,0.153489,0.119568,-0.134395,-0.219148,0.085999,0.265425,-0.067957,0.157166,-0.230015,0.197570,-0.292522,0.195017) * L2_9 + mat4(0.084170,-0.184116,-0.286708,0.027700,0.050412,-0.003061,-0.074081,-0.256407,0.154128,0.117379,-0.170732,-0.044522,-0.236858,-0.405591,0.242721,0.246331) * L2_10 + mat4(-0.073296,-0.173429,0.410652,0.255021,-0.476449,-0.337886,-0.325707,-0.024552,-0.412806,-0.033389,-0.273486,0.069182,0.209749,0.385948,-0.190238,0.085659) * L2_11 + mat4(0.030913,-0.059257,0.095640,0.281276,0.003887,-0.131163,0.007398,-0.223253,-0.119478,-0.237816,-0.069804,0.083595,-0.147407,-0.227997,-0.081781,-0.017598) * L2_12 + mat4(0.436387,0.044805,0.370902,-0.053324,-0.136209,-0.190895,0.190555,0.013128,-0.360807,0.111209,0.184293,0.320653,-0.422320,-0.284641,0.185590,0.016290) * L2_13 + mat4(0.449512,-0.173754,0.288565,-0.297720,0.314977,0.068346,0.097575,0.044522,-0.069641,0.018839,-0.079556,-0.050958,0.091725,-0.446561,-0.240195,-0.059654) * L2_14 + mat4(0.081566,0.378924,0.265348,0.106142,-0.192569,0.032599,0.176111,0.470378,0.349525,0.234894,0.162622,-0.079115,-0.080955,-0.185856,-0.491511,-0.381835) * L2_15 + vec4(0.321263,-0.131219,-0.012280,-0.247292)));\nvec4 L3_11 = sin((mat4(-0.208231,-0.045008,0.094882,0.100258,-0.375743,-0.224811,-0.013434,0.088999,0.183303,0.392088,0.032058,0.022857,-0.237166,0.053264,0.298961,0.414437) * L2_0 + mat4(0.074966,-0.124836,0.086021,0.066528,0.135008,0.123243,-0.226972,0.139293,-0.037669,0.352461,-0.294284,-0.241508,0.116729,0.070781,0.356239,-0.229723) * L2_1 + mat4(0.191618,-0.205343,0.093333,0.185807,-0.208623,-0.014581,0.043870,0.087026,-0.056154,0.107695,0.133528,0.076600,-0.191647,0.539764,-0.084566,-0.215014) * L2_2 + mat4(0.173452,-0.101340,0.056772,0.461176,-0.092268,-0.190919,0.308406,-0.407566,-0.336351,-0.033063,-0.100352,0.139466,0.109442,0.207392,0.231394,-0.458003) * L2_3 + mat4(0.133255,-0.132940,0.017659,-0.050884,-0.115679,0.125921,0.017160,-0.057104,0.111404,-0.241709,-0.102616,-0.028111,0.260803,-0.004076,-0.173626,-0.097707) * L2_4 + mat4(-0.277256,-0.448898,0.099491,-0.279407,-0.092299,0.048171,0.095452,0.046521,0.060513,0.101041,-0.088755,0.021173,-0.049026,-0.051245,0.334764,-0.279573) * L2_5 + mat4(-0.417017,-0.217080,-0.014082,0.021466,0.309308,0.157646,-0.040550,0.326129,0.015246,-0.089795,-0.146735,0.042348,-0.316297,0.179284,-0.352430,-0.007829) * L2_6 + mat4(-0.176921,-0.156035,0.023053,0.222704,0.002864,0.404367,-0.095381,-0.237973,-0.215270,-0.146687,0.160135,-0.498615,0.359722,-0.028833,0.078709,-0.178386) * L2_7 + mat4(0.170761,-0.035620,-0.081583,-0.285740,-0.403219,0.363247,-0.090489,0.326908,-0.185519,-0.136243,0.204872,-0.238389,-0.069793,0.174191,0.163129,-0.152236) * L2_8 + mat4(0.020874,0.059331,-0.050839,-0.014744,-0.180608,0.172105,0.070815,-0.090842,-0.404894,-0.347673,-0.168769,-0.255585,-0.010100,-0.215179,-0.165925,0.087136) * L2_9 + mat4(0.007038,-0.055309,-0.473737,-0.080444,-0.415673,0.430800,0.241288,0.097134,0.171317,-0.169132,0.032751,0.493370,0.026577,0.081529,-0.173495,-0.472288) * L2_10 + mat4(0.231860,0.130695,-0.463666,-0.095649,-0.031825,-0.409173,-0.004443,0.102611,-0.323482,0.055630,-0.112350,0.163054,0.147827,-0.086551,-0.229047,0.027901) * L2_11 + mat4(-0.022569,0.165131,0.027978,0.162537,-0.407112,0.021326,0.129505,0.263530,-0.119377,-0.065806,-0.078333,-0.377584,-0.026215,-0.144583,-0.210172,-0.223000) * L2_12 + mat4(0.107347,0.071561,0.145321,0.237800,0.057996,-0.281336,-0.275418,0.134599,-0.406106,0.071266,0.058297,0.121585,-0.093659,-0.153792,0.034833,0.451141) * L2_13 + mat4(0.391898,-0.096793,0.026984,-0.436583,0.132429,0.253607,0.373609,-0.104941,-0.350244,0.113454,0.082325,-0.177819,-0.020748,-0.140629,0.251725,-0.370311) * L2_14 + mat4(-0.335542,0.418955,0.412349,0.315916,-0.280814,0.162580,-0.043227,0.366499,0.027274,0.369279,-0.313663,0.100720,0.103883,0.227983,0.227630,-0.072379) * L2_15 + vec4(0.158865,-0.325489,0.010225,-0.135380)));\nvec4 L3_12 = sin((mat4(0.148765,0.349300,-0.368942,-0.106058,-0.147162,0.043506,0.366315,-0.155247,0.354517,-0.106859,-0.278390,0.366041,0.117612,0.180477,0.083525,0.357671) * L2_0 + mat4(-0.121643,-0.150317,0.155974,0.031759,-0.120698,0.069428,0.026994,0.206549,0.394795,-0.395779,0.006316,-0.111551,-0.271415,0.031072,0.061352,0.068265) * L2_1 + mat4(0.090364,-0.301330,-0.042248,-0.057569,0.119196,-0.190377,0.113135,0.064301,0.172411,-0.303017,0.287466,-0.315902,0.002426,0.185484,-0.132702,-0.337337) * L2_2 + mat4(-0.017085,-0.283376,-0.253433,-0.186357,-0.139541,-0.093514,0.056700,-0.140039,-0.014098,-0.356246,0.033900,0.171898,-0.043948,0.094049,-0.416911,0.053824) * L2_3 + mat4(-0.130732,0.104318,0.460070,0.049831,0.137250,-0.026059,0.038819,0.177240,-0.054347,-0.178693,-0.226941,0.020086,0.112499,-0.026887,-0.230124,-0.305568) * L2_4 + mat4(-0.115530,0.143013,0.197750,0.037729,-0.067483,0.485973,-0.356487,-0.377522,0.091909,-0.050900,0.219361,-0.202191,0.076233,-0.402013,-0.377436,0.281837) * L2_5 + mat4(0.274245,-0.119163,-0.070581,-0.067211,-0.315692,0.362675,0.065518,-0.118422,0.218307,-0.391870,0.412346,0.214434,0.052805,-0.176298,-0.514560,0.271709) * L2_6 + mat4(0.301927,0.102036,-0.216488,0.051445,0.060491,0.114326,-0.354757,-0.452768,0.056727,0.046308,0.222049,0.091473,0.463968,-0.150571,-0.508196,0.283215) * L2_7 + mat4(-0.276501,0.267857,-0.399145,-0.015392,-0.281838,0.070345,0.034361,-0.226412,-0.330079,-0.091745,-0.267625,-0.088177,0.223661,-0.151716,0.006455,0.385663) * L2_8 + mat4(-0.248571,0.186827,0.233247,0.180150,-0.364336,-0.304523,0.170577,0.216864,0.347909,0.159562,-0.144116,-0.413506,0.330540,0.133896,-0.175884,0.211922) * L2_9 + mat4(0.017125,0.224028,-0.359208,0.056657,0.345034,0.107907,0.305502,0.110339,0.308789,-0.095259,-0.029172,0.063634,-0.301474,-0.018561,0.125797,-0.020492) * L2_10 + mat4(0.053281,0.148306,0.077111,-0.040789,0.352988,-0.022185,0.461015,0.208028,0.105250,0.280960,-0.273061,-0.042976,0.252772,-0.176295,0.409663,-0.443024) * L2_11 + mat4(-0.272483,-0.111867,-0.362484,0.127073,-0.039572,-0.045602,0.103906,-0.536135,-0.372345,0.047398,-0.294292,0.458970,0.016768,-0.275540,0.562044,-0.276917) * L2_12 + mat4(-0.284451,0.003301,0.240339,-0.183779,0.015055,-0.092715,-0.039857,-0.087816,-0.123423,0.200028,0.334114,-0.058459,-0.232229,-0.059340,0.317806,-0.012276) * L2_13 + mat4(0.057657,-0.084283,-0.202007,0.282523,-0.378713,-0.028955,0.320411,-0.216644,0.161017,0.132964,0.398886,-0.211378,-0.342156,0.183215,-0.003894,0.066779) * L2_14 + mat4(-0.261526,-0.008051,0.049403,0.272953,0.042614,0.150972,0.369369,0.266161,0.143647,0.206515,0.256482,-0.129646,-0.054091,0.015957,0.145658,-0.473158) * L2_15 + vec4(0.246498,-0.225155,-0.251125,0.134524)));\nvec4 L3_13 = sin((mat4(0.330705,0.034564,0.168753,-0.156358,-0.140363,0.343994,-0.270113,-0.235490,0.206252,-0.332984,0.155534,0.175471,-0.396240,-0.125149,0.175657,-0.171175) * L2_0 + mat4(-0.044940,-0.320176,0.419766,0.040545,-0.258968,0.132541,0.398011,-0.102142,0.240619,0.251448,-0.391663,0.194475,0.136714,0.139828,-0.043077,0.157938) * L2_1 + mat4(-0.293206,0.006112,-0.031827,0.121365,-0.100198,0.244399,-0.261533,-0.185798,0.256768,-0.434458,0.199492,-0.000748,-0.134123,-0.433997,-0.141368,-0.162665) * L2_2 + mat4(-0.288263,0.144095,-0.049675,0.028081,0.475682,0.174082,0.235187,-0.025025,0.190528,0.242630,0.201515,-0.374781,-0.108548,0.123269,0.079188,-0.473846) * L2_3 + mat4(-0.158826,0.081918,0.208609,-0.040398,0.182426,0.071981,-0.175197,-0.318472,0.320240,0.278952,0.028302,-0.317919,-0.353676,0.241477,-0.371450,0.207957) * L2_4 + mat4(-0.080514,-0.128512,0.015107,-0.123357,-0.186109,-0.388665,-0.076965,0.076268,-0.064251,-0.155755,0.094604,0.310324,0.444094,-0.066244,0.235443,0.176513) * L2_5 + mat4(0.029928,0.006424,-0.009777,-0.139717,0.019829,0.289967,-0.108432,0.476294,-0.001953,0.019253,-0.048721,-0.167858,-0.143451,0.187725,-0.383490,0.094424) * L2_6 + mat4(-0.262115,0.150738,0.011348,-0.271291,0.440844,0.031523,-0.258771,0.031267,0.133815,0.256920,-0.164725,0.098899,0.085626,0.030458,0.123823,-0.552861) * L2_7 + mat4(-0.133169,-0.046721,0.261891,-0.331135,-0.067229,0.235425,-0.097987,-0.387757,-0.010520,0.247808,0.421660,-0.033975,-0.061696,-0.144708,0.151943,-0.252211) * L2_8 + mat4(0.128034,0.215589,-0.170341,0.071089,0.072097,-0.267982,-0.039055,-0.060775,0.163839,0.063511,0.193935,-0.191341,0.294501,0.061025,-0.287105,-0.249301) * L2_9 + mat4(-0.020980,0.153635,-0.130344,0.304363,0.042543,0.255839,0.339626,-0.032224,0.128224,0.302130,0.208319,0.173686,-0.020417,0.104202,0.084066,0.300527) * L2_10 + mat4(-0.012253,-0.216177,0.286641,0.169258,0.397684,-0.095476,0.335238,-0.317819,-0.346944,0.065586,-0.025887,-0.107368,0.214407,-0.074480,-0.227247,-0.160195) * L2_11 + mat4(-0.239785,-0.064536,0.108656,-0.318137,-0.360355,-0.424710,-0.256238,-0.303592,0.173544,-0.351609,0.276107,0.159236,0.059091,-0.108121,0.178026,-0.116598) * L2_12 + mat4(0.210096,-0.306983,0.016590,-0.021800,-0.189817,-0.160939,-0.455284,0.196624,-0.289338,-0.300820,-0.053900,-0.291306,-0.008110,-0.117460,0.138471,-0.026857) * L2_13 + mat4(-0.191679,0.263891,0.157647,-0.036167,0.137922,-0.257846,-0.046231,-0.102129,-0.061312,0.224662,0.121010,-0.006850,-0.084922,-0.020903,0.266140,-0.361006) * L2_14 + mat4(0.196435,0.356300,0.052278,0.102001,-0.288055,0.236859,-0.002426,0.011769,-0.203277,0.397040,-0.100175,0.082895,-0.115268,-0.210941,0.167474,0.046255) * L2_15 + vec4(-0.045057,0.003256,-0.117999,0.096091)));\nvec4 L3_14 = sin((mat4(0.463087,0.037379,0.283202,-0.479268,-0.158195,-0.034035,0.302696,-0.052857,-0.350589,0.025598,0.085742,0.126112,-0.037702,0.242519,0.152142,0.071161) * L2_0 + mat4(0.138878,-0.109180,0.128621,-0.233298,-0.103064,-0.032213,-0.406971,-0.009040,-0.297519,-0.253130,0.051543,-0.054801,-0.029029,-0.175787,-0.304697,-0.030509) * L2_1 + mat4(0.137486,0.018067,0.195324,-0.419410,0.262357,0.032726,-0.135339,-0.069547,0.236102,-0.131410,0.137756,-0.323589,-0.051451,0.175097,0.187454,-0.244274) * L2_2 + mat4(-0.160128,0.336216,-0.031164,0.162239,-0.332525,-0.187021,-0.557607,-0.265448,-0.123999,0.114451,0.416485,0.088082,-0.294852,0.048233,-0.184537,-0.134040) * L2_3 + mat4(-0.287077,0.465158,0.267627,-0.022543,-0.223547,0.194760,0.279079,-0.228883,-0.116930,-0.053845,-0.163997,-0.386652,-0.072520,0.030586,-0.024772,0.308807) * L2_4 + mat4(-0.173147,0.216980,-0.240044,0.129771,-0.345454,0.040379,-0.225101,-0.319083,0.160185,0.065803,-0.360749,0.192778,-0.392088,0.111048,-0.224180,0.062133) * L2_5 + mat4(0.105941,0.388543,-0.319079,-0.091605,0.483748,-0.108258,-0.232512,-0.009125,0.058176,0.047368,-0.073049,-0.362651,-0.018106,-0.147971,-0.132541,-0.084264) * L2_6 + mat4(0.140216,-0.284964,-0.139025,0.200552,0.098786,-0.052541,0.170165,0.290868,0.073836,-0.012321,0.009073,0.043396,0.229835,-0.128540,-0.152374,0.002538) * L2_7 + mat4(0.266675,0.052643,0.064717,-0.138581,0.577522,-0.143911,0.402337,0.039086,-0.135731,0.278327,-0.407398,-0.389165,0.022273,0.021153,-0.333794,0.201941) * L2_8 + mat4(0.048529,-0.197773,-0.165624,-0.381605,-0.080327,0.133682,0.335206,0.227242,-0.055197,-0.540720,-0.054875,0.019314,-0.285001,0.077836,0.109531,0.432203) * L2_9 + mat4(-0.034535,-0.020053,-0.122018,-0.004608,0.183854,0.181087,-0.379411,0.480880,-0.400697,0.039219,0.232419,0.020971,-0.029754,0.462024,0.318772,-0.070135) * L2_10 + mat4(0.245910,-0.320626,-0.117587,-0.084497,0.406141,-0.566175,0.341494,-0.379026,-0.110891,0.469740,0.022227,0.089788,-0.053414,-0.283744,-0.245980,0.367856) * L2_11 + mat4(0.103137,-0.220615,0.337090,0.155291,0.042169,-0.245054,-0.019303,-0.133170,0.241443,-0.200238,0.314802,-0.060431,0.164848,0.093495,0.244254,-0.113091) * L2_12 + mat4(-0.032494,-0.167873,-0.246306,-0.024821,0.026181,0.300492,0.295511,0.058826,0.156211,0.212792,0.307643,-0.348192,0.238001,-0.127244,-0.241727,0.083598) * L2_13 + mat4(-0.237912,0.578962,0.021682,-0.085329,0.029386,-0.074555,-0.161926,0.006092,-0.005805,-0.050372,0.107216,-0.103098,-0.177627,-0.208982,-0.196975,0.046125) * L2_14 + mat4(-0.239679,0.266216,0.157257,-0.283008,0.076363,-0.000384,0.176863,-0.189010,-0.154958,0.155721,-0.137522,-0.255738,-0.114167,-0.302396,-0.314117,-0.179521) * L2_15 + vec4(0.247183,0.158586,0.307387,-0.051307)));\nvec4 L3_15 = sin((mat4(-0.273622,0.443921,-0.047934,-0.172147,-0.190170,0.003922,0.002436,0.030905,-0.421844,-0.319241,0.341480,-0.195187,0.058145,-0.051963,0.122601,0.248430) * L2_0 + mat4(0.327191,0.000350,0.014591,-0.240074,0.448045,-0.012336,-0.089231,-0.159339,-0.059713,0.054421,0.275593,0.037501,-0.318984,0.048547,-0.041361,-0.282477) * L2_1 + mat4(0.108552,0.140764,0.055617,-0.051283,-0.137058,0.338600,-0.245433,0.139636,0.044630,-0.068870,0.122791,-0.185695,-0.422423,0.306909,-0.076963,-0.077215) * L2_2 + mat4(0.069458,-0.017378,-0.141628,0.218725,-0.042214,0.235375,-0.088107,0.327374,-0.162527,-0.241126,0.038756,-0.049381,-0.264673,-0.188514,-0.262991,-0.286215) * L2_3 + mat4(-0.080035,-0.163412,0.292123,0.250292,0.169602,0.352787,0.273932,0.125359,-0.515135,-0.318062,-0.068784,0.371619,0.053123,0.094806,0.471997,0.440391) * L2_4 + mat4(-0.240385,-0.124941,0.185749,0.094108,0.230869,-0.082533,-0.458566,-0.148340,-0.005882,0.131171,-0.191396,0.209187,0.068947,0.068908,-0.251506,-0.285877) * L2_5 + mat4(-0.169357,-0.302354,-0.187100,-0.102570,-0.436595,-0.076189,0.303474,0.277429,-0.369819,0.126924,0.146973,0.130273,0.346195,0.299697,-0.040215,0.123034) * L2_6 + mat4(-0.161224,-0.030022,-0.054632,-0.295365,0.260446,-0.197673,-0.187792,-0.282914,0.305665,-0.110118,0.305281,0.043958,0.148079,-0.198976,0.288372,-0.086180) * L2_7 + mat4(0.351987,-0.280610,0.241966,0.379874,0.210676,0.190358,-0.183048,-0.130043,-0.250872,0.344666,-0.012862,-0.300529,-0.007996,-0.045902,0.225450,0.042033) * L2_8 + mat4(-0.213888,0.251246,-0.355126,0.282248,0.083323,0.054692,-0.269625,0.257632,0.394471,0.596068,0.084005,0.156657,-0.374385,-0.335361,0.137056,0.316975) * L2_9 + mat4(-0.102406,0.000130,-0.146045,0.208434,-0.028273,-0.015576,-0.088362,0.229617,0.267072,-0.346879,-0.273506,0.081135,0.291806,0.197337,-0.169158,0.193675) * L2_10 + mat4(-0.291225,-0.341732,-0.224728,0.289728,-0.384046,-0.363333,-0.116671,0.297094,-0.146797,0.260208,-0.105566,-0.073779,0.033955,-0.152486,-0.136846,0.087862) * L2_11 + mat4(0.321157,-0.070568,-0.038351,0.028565,-0.097798,-0.182828,-0.216379,0.348890,0.006368,-0.225068,-0.261217,0.098414,0.046062,0.322860,-0.023431,0.038125) * L2_12 + mat4(-0.073324,0.264915,0.198289,-0.094573,0.022603,0.373926,0.303659,0.249923,-0.269301,-0.179504,-0.268952,0.288854,0.147012,-0.233989,-0.245190,0.093450) * L2_13 + mat4(0.182744,0.137483,0.172525,-0.062212,0.062224,-0.364325,0.161772,-0.373234,0.068892,0.068826,-0.351191,0.014761,-0.314842,-0.118500,0.043635,0.138472) * L2_14 + mat4(-0.048960,-0.275399,-0.060979,-0.429846,-0.424845,-0.377697,-0.207270,-0.061241,0.430962,0.014004,0.209797,-0.002879,-0.213139,-0.102751,0.165497,0.205686) * L2_15 + vec4(-0.069832,0.253080,0.502410,0.110656)));\nvec4 L4_0 = sin((mat4(-0.200265,-0.160056,-0.350889,-0.078360,0.287504,0.027265,-0.388824,-0.021068,-0.196717,0.485416,0.169413,0.360689,-0.417959,-0.267046,-0.022526,-0.224278) * L3_0 + mat4(0.565523,0.376980,-0.116654,-0.068573,0.128722,0.008870,-0.335833,0.206862,0.228921,0.106618,0.143993,0.451954,0.148427,-0.171270,0.375548,-0.078524) * L3_1 + mat4(0.001880,0.307871,-0.245492,0.284967,0.038904,0.048081,-0.053699,-0.164309,0.305684,-0.152911,0.258314,-0.254069,0.367627,-0.079306,-0.141310,0.225533) * L3_2 + mat4(0.158054,-0.131936,-0.363729,0.147859,0.370476,-0.455037,-0.443083,0.055928,0.367381,0.288165,-0.110994,-0.170378,0.329960,0.413924,0.008239,-0.138680) * L3_3 + mat4(0.250218,-0.035090,0.011629,-0.328156,0.036661,0.074008,0.029761,-0.158436,-0.095469,0.023709,0.031733,-0.225317,0.105762,-0.122920,0.241543,0.269268) * L3_4 + mat4(-0.221442,0.070970,-0.440048,0.397587,0.201290,0.039092,-0.086236,0.010287,0.130542,-0.160737,-0.286147,-0.229197,0.052398,0.367356,0.278335,-0.139504) * L3_5 + mat4(-0.210803,0.024928,-0.149784,-0.225691,0.311591,0.152095,-0.051416,0.287196,-0.195120,0.299550,-0.128970,0.238301,0.168862,0.370105,-0.034318,-0.344557) * L3_6 + mat4(0.365256,0.349632,-0.046298,0.074801,0.187643,-0.256862,0.520728,0.092553,0.026302,0.003826,-0.215114,-0.237098,-0.129472,-0.319153,0.238564,0.128627) * L3_7 + mat4(-0.311424,-0.348316,0.360072,-0.180072,0.208836,-0.127698,0.314901,0.214041,-0.197653,0.158132,-0.105086,-0.446519,0.293628,0.168920,-0.027506,0.096874) * L3_8 + mat4(0.383937,-0.271918,0.142309,-0.296572,-0.321406,-0.259763,-0.056048,-0.420936,0.453246,-0.185217,0.209508,0.065044,0.035610,-0.199084,0.316231,-0.092693) * L3_9 + mat4(-0.054253,-0.092457,-0.141379,-0.024956,-0.272038,-0.003681,0.056258,-0.129563,0.228702,0.538392,-0.035740,-0.249896,-0.000791,-0.393401,0.237922,0.229224) * L3_10 + mat4(-0.258832,-0.233523,-0.044637,-0.109440,0.411520,0.001597,-0.026855,0.328021,-0.153804,-0.088417,0.434294,-0.131825,0.139471,-0.051784,0.266511,0.186942) * L3_11 + mat4(-0.306601,-0.106667,0.161473,-0.192284,-0.197105,-0.370653,0.325371,-0.330859,0.207138,-0.141647,-0.183223,0.330151,0.343789,0.021107,-0.002237,-0.317416) * L3_12 + mat4(0.239191,0.264935,-0.316579,0.356153,0.168181,0.153639,-0.134705,-0.155186,-0.390737,-0.178617,-0.119342,-0.207745,0.167465,0.160066,-0.427336,0.301373) * L3_13 + mat4(-0.119567,-0.467802,-0.148017,-0.401436,-0.301262,0.238613,0.042324,-0.273900,-0.154488,0.443610,0.348902,0.492161,0.042584,-0.061600,-0.444613,-0.091439) * L3_14 + mat4(0.305214,0.165152,0.158262,0.217387,0.382485,0.347591,0.031714,0.272331,-0.191682,-0.194220,0.315449,0.648228,0.366717,-0.200889,-0.221575,-0.160743) * L3_15 + vec4(-0.101681,-0.011468,-0.015817,-0.242140)));\nvec4 L4_1 = sin((mat4(-0.188713,0.127263,0.380892,0.017285,-0.036413,-0.078668,0.202894,-0.465103,-0.224567,-0.217671,0.013416,-0.231454,0.460679,-0.190716,-0.358257,0.353141) * L3_0 + mat4(-0.056696,0.056561,-0.061633,-0.072465,-0.076357,-0.307051,-0.357119,-0.052310,0.509217,0.148994,0.070363,0.043777,-0.463589,0.290282,-0.125218,0.329682) * L3_1 + mat4(-0.301862,0.047249,0.013431,0.022333,0.017409,0.164040,0.178635,0.125064,0.147761,-0.322584,0.154016,-0.279931,0.319249,0.189656,0.001716,-0.547410) * L3_2 + mat4(-0.471793,0.114174,-0.110762,-0.132357,0.211610,0.004589,-0.107095,-0.141662,-0.044667,-0.163540,0.262880,-0.355773,-0.431018,0.213866,0.336819,0.040856) * L3_3 + mat4(-0.002789,-0.224258,0.253243,-0.345406,-0.289940,-0.114017,0.457470,-0.270958,-0.387870,-0.251898,0.020230,-0.042692,-0.093430,0.117730,0.400766,-0.331940) * L3_4 + mat4(-0.107952,0.178058,-0.460594,0.144745,-0.227377,0.406346,-0.061458,-0.461864,-0.097926,0.272396,0.325095,-0.001038,0.130154,0.324821,0.096813,-0.020761) * L3_5 + mat4(-0.405973,0.382483,0.204686,0.279802,0.237990,-0.279520,-0.093982,0.051891,0.234043,-0.307749,0.161030,-0.177467,0.107774,-0.062922,-0.161057,-0.148626) * L3_6 + mat4(0.515936,0.243690,-0.159332,-0.479466,-0.001440,-0.170857,-0.186844,-0.091973,-0.157907,0.433640,-0.153934,-0.091770,-0.177013,-0.233523,-0.472270,-0.190782) * L3_7 + mat4(0.358368,-0.035722,-0.173420,-0.359507,-0.359714,-0.323769,-0.302565,0.134204,-0.404027,-0.232770,-0.058953,-0.032810,-0.065992,0.156374,-0.284266,-0.238697) * L3_8 + mat4(-0.043608,-0.369168,0.104731,-0.256441,-0.583258,-0.077291,-0.345287,-0.177057,-0.540892,-0.324089,-0.351636,-0.124115,0.185777,-0.585441,0.212523,0.099780) * L3_9 + mat4(-0.326698,-0.322926,0.018651,-0.044718,-0.211751,0.075036,-0.123249,-0.012903,0.515420,0.288451,-0.277238,-0.008360,-0.279964,-0.414562,0.001726,-0.218832) * L3_10 + mat4(0.248445,0.097948,0.247211,-0.107882,-0.189978,0.176899,-0.009063,-0.207017,0.130973,0.321090,-0.117157,-0.012945,-0.221273,-0.177759,0.193125,-0.043088) * L3_11 + mat4(0.155014,0.560475,-0.093146,0.068084,-0.149281,-0.277198,-0.267482,-0.242055,-0.103706,0.038473,-0.008747,-0.337604,-0.199880,-0.012986,-0.299308,-0.177703) * L3_12 + mat4(0.241382,-0.256538,0.510916,-0.041563,0.236621,-0.455052,-0.107912,0.025390,0.071604,-0.377740,0.359775,0.383047,-0.197949,-0.121089,-0.039722,0.169883) * L3_13 + mat4(-0.036760,0.164901,-0.333896,-0.025444,0.156963,0.144901,0.089275,-0.252169,-0.293627,0.293061,-0.077084,-0.210878,-0.261717,0.308452,-0.137018,-0.193823) * L3_14 + mat4(-0.087024,-0.364022,-0.103725,-0.042195,0.575517,0.086201,-0.174573,0.014444,-0.221401,0.469941,0.116662,-0.027390,-0.356594,0.022839,-0.237627,-0.096024) * L3_15 + vec4(0.011286,-0.057297,0.015384,-0.052755)));\nvec4 L4_2 = sin((mat4(-0.409647,-0.121944,-0.507794,0.117565,-0.279927,0.351770,0.161051,0.075390,0.122799,0.104420,0.519579,-0.602042,0.400823,0.059665,-0.223780,-0.428285) * L3_0 + mat4(-0.148436,0.254498,-0.056641,-0.147082,-0.154242,0.395116,-0.145405,-0.238202,0.319733,0.149654,-0.192557,0.234734,0.248800,-0.030032,-0.232613,-0.014096) * L3_1 + mat4(0.143398,-0.015659,-0.220661,0.336930,-0.253150,-0.094784,0.024762,-0.270848,-0.157293,-0.085179,-0.014842,-0.199730,0.172521,-0.413808,-0.095138,0.315970) * L3_2 + mat4(-0.392628,0.303550,0.104147,0.078863,-0.090904,-0.163846,0.255820,0.033289,0.309305,-0.275229,-0.014463,0.026323,0.224214,0.316694,0.256574,-0.312121) * L3_3 + mat4(-0.476657,-0.207784,-0.057978,-0.008337,-0.185768,0.131828,0.263567,0.189272,-0.246951,0.226045,0.034431,-0.170168,-0.196903,0.581385,0.026235,0.188456) * L3_4 + mat4(-0.320677,0.019466,-0.434042,0.254348,0.146355,-0.002200,-0.126997,-0.164475,-0.064778,0.202020,0.347944,-0.015113,0.549084,0.270133,0.036315,0.226352) * L3_5 + mat4(-0.106033,0.337231,0.004714,0.127912,0.007630,-0.010205,-0.102496,0.168794,-0.034452,0.208946,0.037669,0.130087,0.232649,-0.297160,-0.057885,0.043879) * L3_6 + mat4(-0.021833,-0.229175,0.034824,-0.080311,-0.092426,0.250385,-0.103838,-0.390162,0.081360,-0.108866,0.258192,-0.249993,0.030333,-0.196122,0.054800,-0.313354) * L3_7 + mat4(-0.164332,0.151424,-0.005128,-0.069570,-0.120317,-0.200613,-0.526108,-0.023142,0.157695,0.142280,0.470685,0.014073,-0.313625,-0.208710,-0.220556,-0.192125) * L3_8 + mat4(-0.198707,0.213265,-0.031727,-0.039987,-0.038594,0.101722,0.020933,-0.270842,0.325595,0.292205,0.370951,-0.135392,0.247797,-0.127581,0.133337,0.060444) * L3_9 + mat4(0.372308,0.457047,0.263434,0.248038,0.128292,0.045382,-0.367322,0.096850,-0.152830,-0.163809,0.377648,0.009911,0.457801,-0.194163,0.271801,0.285695) * L3_10 + mat4(0.184132,0.149514,0.130477,0.206457,0.120147,0.624916,-0.223177,-0.338866,-0.021154,-0.613878,0.250816,-0.071177,-0.310982,0.019344,-0.083078,0.260943) * L3_11 + mat4(0.063037,-0.171184,-0.190519,0.119060,0.357443,-0.039438,0.019470,0.338722,0.060928,0.062011,-0.072601,-0.161375,-0.167733,0.172246,0.128221,0.135943) * L3_12 + mat4(-0.227799,0.289058,-0.277723,-0.030847,-0.306210,0.200680,-0.154115,0.250673,-0.420920,0.125762,-0.304717,0.385874,-0.024227,0.407479,0.469848,-0.090370) * L3_13 + mat4(0.294281,0.391950,0.478186,0.330288,0.001833,-0.062355,-0.108389,-0.103537,0.135064,0.440502,-0.483358,0.188270,0.338925,0.232687,0.341446,-0.109910) * L3_14 + mat4(-0.074665,-0.065779,-0.361279,-0.350832,-0.069030,0.191231,-0.706131,0.194712,0.531130,-0.395327,-0.222260,0.029214,-0.339291,0.448796,-0.185844,0.045349) * L3_15 + vec4(-0.122354,0.216900,-0.178518,-0.142355)));\nvec4 L4_3 = sin((mat4(-0.088514,0.038057,-0.310593,0.265267,0.103077,-0.264172,-0.482216,-0.176495,-0.238603,-0.186347,-0.051617,-0.171923,0.119490,-0.415397,0.118447,-0.046493) * L3_0 + mat4(0.177616,0.226460,-0.604319,-0.215116,0.277700,-0.054158,-0.176535,0.298853,-0.017825,0.287090,-0.053121,0.250304,0.291469,0.353358,-0.251531,-0.139258) * L3_1 + mat4(-0.240787,0.454970,-0.292933,0.183390,-0.011019,-0.215423,0.018470,0.249676,0.309362,-0.280641,-0.209385,-0.043397,-0.027710,0.158301,-0.060073,0.013991) * L3_2 + mat4(-0.201746,-0.156726,0.443397,0.186577,0.037978,0.267480,0.189395,0.119681,-0.142872,-0.226046,0.528585,-0.328865,0.164270,0.053463,-0.174477,-0.180002) * L3_3 + mat4(-0.220760,0.180552,0.313700,0.030984,0.111457,-0.087628,0.231676,-0.397584,-0.067553,-0.460760,-0.133278,-0.015378,0.338083,0.326064,0.283782,-0.056356) * L3_4 + mat4(-0.259360,0.077371,-0.160789,0.347991,-0.114996,-0.236619,0.441607,-0.193737,-0.153349,0.529277,0.182153,0.075388,-0.171499,0.208527,-0.586736,-0.004939) * L3_5 + mat4(0.359273,0.010936,0.230870,-0.030172,0.093152,-0.163376,-0.140334,-0.273805,-0.008159,-0.105715,0.331439,-0.526191,-0.257477,-0.219649,0.093896,0.115233) * L3_6 + mat4(-0.160090,0.085523,-0.287533,0.401280,-0.109131,0.354601,-0.030228,-0.347899,0.166597,-0.304044,-0.381914,-0.087367,0.412690,-0.017465,0.130226,0.033596) * L3_7 + mat4(-0.140984,-0.368956,0.292288,0.172252,0.148435,0.091420,0.057280,-0.390667,-0.176852,0.382113,-0.113955,0.155734,-0.105691,0.009712,0.216284,0.176479) * L3_8 + mat4(-0.212566,0.062497,-0.112610,-0.259790,0.002142,-0.162932,-0.344828,0.237071,-0.100329,-0.028906,-0.219282,-0.251558,-0.261009,0.248396,-0.492310,-0.160870) * L3_9 + mat4(0.199100,0.334280,-0.447778,0.150756,0.066074,0.035002,-0.373408,0.230068,0.149920,0.351792,0.472373,0.094719,-0.121235,-0.180507,-0.190764,0.356158) * L3_10 + mat4(-0.080745,0.050328,0.165776,-0.320650,-0.037054,-0.448458,0.224210,-0.534980,0.056182,0.309339,-0.150011,0.175129,0.289194,-0.131975,0.352806,-0.265137) * L3_11 + mat4(-0.007168,0.470584,-0.160185,0.130222,0.141620,-0.125097,-0.195547,0.227603,0.142179,0.164204,-0.484655,-0.304967,0.272708,0.124010,0.144972,0.289388) * L3_12 + mat4(0.266700,0.150945,0.212011,0.442853,-0.114414,-0.027140,-0.327058,0.086667,-0.286914,-0.201008,0.259443,-0.077052,-0.508653,0.112997,0.450980,0.153012) * L3_13 + mat4(-0.251193,-0.111706,-0.349168,0.156713,-0.219981,-0.073118,-0.020290,-0.117225,0.210958,-0.552534,0.422535,-0.432034,0.168553,0.124280,-0.064403,-0.091008) * L3_14 + mat4(0.034696,0.017325,0.272241,-0.063195,-0.120988,0.408088,-0.486619,-0.011762,-0.119233,0.013809,-0.169661,-0.311928,-0.168052,0.014934,0.319807,-0.234771) * L3_15 + vec4(-0.422722,0.122311,-0.102113,-0.386578)));\nvec4 L4_4 = sin((mat4(-0.605234,-0.370968,0.158224,-0.100563,-0.293419,0.308618,0.379122,0.183284,0.160328,0.091903,0.083011,-0.017848,0.000477,-0.220592,-0.215122,0.153369) * L3_0 + mat4(-0.103914,0.173575,-0.461391,-0.047694,0.296507,-0.007294,0.074134,-0.089527,-0.091441,-0.379417,0.056363,0.062198,-0.088040,0.149742,-0.100076,0.052423) * L3_1 + mat4(0.133311,-0.052065,0.200942,-0.143970,0.143771,-0.233548,0.253061,-0.043453,0.346470,-0.018683,-0.115064,0.664250,-0.064399,0.464243,-0.018672,0.091163) * L3_2 + mat4(-0.550501,0.255083,0.337393,0.019628,-0.169383,-0.004148,0.496936,0.117106,0.499855,-0.182803,0.007754,-0.304890,0.170984,0.413546,-0.549676,-0.203247) * L3_3 + mat4(0.174239,-0.226233,0.092278,-0.146191,0.085249,-0.008323,0.000278,-0.099052,0.187796,0.227923,0.104052,-0.252083,-0.237792,0.136007,0.211953,-0.071615) * L3_4 + mat4(-0.537475,-0.662815,0.170003,-0.342460,-0.404755,0.254045,-0.470842,0.122314,-0.005365,0.152218,0.303419,0.149308,-0.106990,-0.182409,0.188124,0.036742) * L3_5 + mat4(-0.391770,-0.175115,0.238411,-0.395168,0.304729,-0.483592,0.019624,-0.333413,-0.233632,-0.231801,-0.110921,-0.568000,-0.208832,-0.062788,-0.321633,0.130095) * L3_6 + mat4(0.107620,0.088908,0.122129,-0.069336,-0.133993,-0.017722,-0.107472,0.167414,-0.326648,-0.533852,0.010563,-0.013287,-0.330771,-0.229639,-0.548162,-0.367593) * L3_7 + mat4(0.099915,0.000136,0.102563,0.175415,-0.059394,0.434644,-0.401100,0.102845,-0.338665,0.055471,0.035989,0.011686,0.107132,0.219698,-0.342457,0.008007) * L3_8 + mat4(-0.110537,0.225143,0.375329,0.368116,0.459767,0.138583,0.011040,0.215812,-0.031409,0.400430,-0.120885,0.282477,0.346076,0.352571,-0.331487,0.346785) * L3_9 + mat4(-0.362645,-0.121992,-0.209189,0.445838,-0.075840,-0.387460,-0.092979,-0.074396,0.583447,-0.067650,-0.236609,-0.398057,-0.047368,0.127630,0.254961,0.023713) * L3_10 + mat4(-0.148286,-0.125860,-0.133414,0.063738,-0.358157,-0.295912,-0.046471,-0.240684,-0.171078,-0.132328,0.352811,0.138343,-0.138973,-0.235080,0.297750,0.283757) * L3_11 + mat4(0.321029,-0.073641,0.378439,0.120436,0.141586,0.084388,-0.390438,0.139805,-0.050170,-0.207437,-0.259693,-0.244835,0.295638,-0.168160,-0.427760,0.104951) * L3_12 + mat4(0.348273,0.286436,-0.287723,0.077948,-0.450976,-0.258700,0.236085,0.219069,-0.115520,-0.421781,0.185649,-0.067236,0.245137,0.253690,-0.272489,0.133593) * L3_13 + mat4(-0.101593,-0.508288,0.042342,0.118255,0.221795,-0.013742,0.255890,0.132086,-0.063536,-0.213757,0.070643,0.267042,0.078072,-0.171968,0.064148,-0.163240) * L3_14 + mat4(0.111312,-0.021812,-0.072573,-0.173530,-0.173673,-0.068593,0.094025,-0.487314,-0.182742,-0.166827,0.275767,0.244719,0.079958,0.236646,-0.127359,0.168229) * L3_15 + vec4(-0.200038,-0.119628,-0.147216,0.169274)));\nvec4 L4_5 = sin((mat4(0.182450,-0.253235,-0.234669,0.479662,0.276525,0.068885,0.372792,0.248505,-0.537589,-0.355444,0.418565,0.079759,0.096092,-0.174405,-0.232316,-0.061796) * L3_0 + mat4(0.058299,0.226400,0.140861,0.119562,-0.106659,-0.429892,0.576890,-0.076075,-0.419019,0.292105,-0.361903,0.343881,0.104631,0.514026,0.236976,-0.096217) * L3_1 + mat4(0.145553,0.364194,0.112226,-0.194345,-0.105601,0.008646,0.253425,-0.297600,-0.170793,0.066787,0.230314,0.393305,-0.122820,0.144169,-0.208203,-0.533369) * L3_2 + mat4(0.220983,0.182223,0.127680,-0.297721,0.407488,0.306108,-0.107531,0.124805,-0.236363,0.204201,-0.085730,0.178534,0.201928,0.060254,0.178592,-0.073266) * L3_3 + mat4(-0.171852,-0.480050,-0.223183,-0.049527,0.062747,-0.325657,-0.014883,-0.102867,0.097403,0.112705,0.188524,-0.271207,-0.140532,0.115183,0.003833,-0.462168) * L3_4 + mat4(-0.044705,0.191463,0.021309,-0.260168,0.044449,-0.005303,-0.092027,-0.260194,0.049834,-0.300938,0.070911,-0.232125,-0.275237,-0.217718,-0.287750,0.337765) * L3_5 + mat4(0.125967,-0.156183,-0.090263,0.064686,0.184576,-0.441092,0.044072,-0.207273,-0.216867,0.053324,0.301401,-0.123689,0.126370,-0.128303,0.253600,0.238735) * L3_6 + mat4(0.349534,0.227886,-0.365186,-0.047667,-0.082042,0.266649,0.117327,-0.103871,0.352212,-0.311454,-0.448122,0.025651,0.121954,0.269083,0.551758,0.217169) * L3_7 + mat4(-0.210857,0.039315,0.107340,0.068863,-0.123405,0.127908,-0.269470,-0.018242,-0.401825,0.289552,-0.131066,-0.165442,-0.113416,0.441969,0.198731,0.247012) * L3_8 + mat4(0.055641,0.005711,-0.434493,-0.539279,0.260929,-0.104656,-0.044432,-0.148262,0.055482,-0.426385,0.063209,-0.496000,-0.416083,0.058012,-0.038006,0.388633) * L3_9 + mat4(0.287422,-0.283907,0.216743,0.602432,-0.151677,-0.089932,0.120824,0.034647,0.151950,0.309288,-0.031169,0.353150,0.257834,0.155479,-0.017256,-0.254178) * L3_10 + mat4(0.053434,0.504702,-0.080388,0.333373,0.184208,-0.254742,-0.363045,-0.061846,0.190874,-0.140687,0.054591,-0.227859,-0.268701,-0.219960,-0.287013,-0.195424) * L3_11 + mat4(0.003494,0.109209,0.443778,-0.319453,-0.213004,-0.416700,0.132719,0.028782,0.187502,0.158500,-0.194615,-0.083071,0.470852,0.250837,0.277144,0.108337) * L3_12 + mat4(0.129280,0.317057,-0.088530,-0.241143,-0.192374,-0.227630,0.444476,-0.002028,0.281482,-0.127692,-0.138720,0.386331,0.307640,0.128931,-0.010550,-0.494431) * L3_13 + mat4(-0.284027,0.355437,0.394300,0.015402,0.184275,0.058792,-0.076450,-0.087977,-0.276808,-0.112728,0.041992,-0.327322,-0.272866,0.197202,-0.229853,-0.150009) * L3_14 + mat4(0.158707,-0.372103,0.244870,-0.011706,-0.354971,-0.146797,-0.016751,0.224760,-0.211449,0.109969,-0.104096,-0.146576,0.074843,0.055391,-0.086827,0.212348) * L3_15 + vec4(-0.200806,0.458351,-0.411787,-0.369769)));\nvec4 L4_6 = sin((mat4(-0.090298,0.061241,-0.447737,-0.291322,0.289760,-0.099213,0.026344,-0.071842,-0.003703,0.065881,-0.520376,0.147736,0.145511,-0.389257,-0.358254,0.259239) * L3_0 + mat4(-0.374335,-0.162861,0.351695,-0.094698,0.175894,0.196118,0.242870,0.092057,-0.350302,0.351061,0.145070,-0.254803,0.225944,0.141825,-0.116691,0.337500) * L3_1 + mat4(0.024923,0.619254,0.222506,0.139272,0.401322,0.258966,-0.342090,-0.032814,-0.352859,0.313764,0.145817,0.496467,-0.360064,-0.146041,0.328733,0.037657) * L3_2 + mat4(0.299304,0.197882,0.314179,0.484946,-0.434568,-0.400369,0.188213,0.034289,-0.053895,-0.111439,0.387552,0.230329,-0.347049,-0.088244,-0.074574,0.493039) * L3_3 + mat4(0.215498,0.117990,-0.043964,0.181455,-0.054416,0.455183,-0.012348,0.140597,0.430444,-0.137417,-0.082190,0.435868,0.144837,-0.093824,-0.029390,0.199661) * L3_4 + mat4(0.281437,-0.025136,0.082281,0.244685,0.183729,0.055179,0.205875,0.015506,-0.196691,0.103676,0.229677,-0.045623,-0.030503,-0.427319,-0.209534,0.262160) * L3_5 + mat4(-0.184522,-0.407077,0.204220,-0.114767,-0.527864,0.196179,0.156647,0.226064,0.164546,-0.043500,-0.030390,0.057445,0.201432,-0.118199,0.130655,0.131241) * L3_6 + mat4(-0.216870,0.191450,-0.176961,0.176711,-0.079838,-0.013320,-0.033902,-0.128022,-0.076421,0.274182,-0.478996,-0.046229,-0.111311,-0.289602,0.664177,-0.270801) * L3_7 + mat4(0.133121,-0.477816,0.275091,-0.175572,-0.397265,0.218503,0.083868,-0.350052,0.203317,0.399586,0.102820,0.172140,-0.277532,-0.240614,0.380583,0.286443) * L3_8 + mat4(0.372661,0.546882,0.089616,-0.012017,0.383534,0.331997,0.279181,0.005730,-0.229516,-0.246015,-0.102308,0.169588,0.239638,0.067443,-0.019846,0.213316) * L3_9 + mat4(0.186136,-0.072284,-0.094466,0.134731,0.063926,0.318336,-0.680270,0.017718,0.278850,-0.243575,-0.249269,0.193956,0.312321,0.447597,-0.192216,0.247098) * L3_10 + mat4(0.118321,-0.040963,-0.057890,0.209367,0.084689,0.014819,0.014424,0.121008,-0.159952,-0.226522,-0.014918,-0.014582,-0.218475,0.464411,0.283811,0.273164) * L3_11 + mat4(-0.076976,-0.154910,0.156802,0.463445,-0.247833,0.005378,0.458029,0.125778,-0.098280,0.243617,-0.325356,0.190430,-0.075691,0.036701,0.098875,-0.022978) * L3_12 + mat4(-0.069230,-0.365666,0.121139,-0.237181,-0.133694,0.506832,-0.223498,0.350960,0.062053,-0.132872,-0.054590,-0.412590,-0.022612,-0.195493,0.277318,0.367333) * L3_13 + mat4(-0.113074,-0.024363,-0.344649,0.272333,0.348859,-0.467052,0.441280,0.109112,0.115619,-0.667121,0.152176,-0.228632,0.294551,-0.118610,0.040012,0.064453) * L3_14 + mat4(-0.035894,0.158915,0.038187,-0.116700,-0.220455,-0.089802,-0.045438,0.038365,-0.195798,-0.177120,0.246337,-0.420174,0.027726,0.145364,0.013886,-0.330751) * L3_15 + vec4(-0.169395,0.332333,-0.399957,-0.060619)));\nvec4 L4_7 = sin((mat4(0.345519,-0.149038,-0.312137,-0.034793,0.526549,0.194266,-0.348659,-0.190593,-0.158642,-0.292260,0.575675,-0.063815,-0.154520,0.187269,0.147056,-0.035912) * L3_0 + mat4(-0.183670,-0.272578,0.232618,0.148740,-0.203084,0.337998,-0.076945,-0.179571,0.144880,0.055965,0.110840,0.031521,-0.074999,0.026037,0.157252,0.165411) * L3_1 + mat4(-0.098000,0.363557,0.264205,0.266408,-0.116381,-0.159823,0.334036,-0.089523,0.202984,-0.279126,-0.322982,0.348941,-0.157629,-0.187136,0.289304,0.402254) * L3_2 + mat4(-0.230368,0.023074,0.171791,-0.354746,-0.008070,0.423707,0.042313,0.105749,0.320577,0.286697,-0.093640,-0.313834,0.077741,-0.249956,0.243399,-0.379643) * L3_3 + mat4(0.119411,0.106840,-0.399052,-0.151449,-0.027018,0.388360,-0.339401,0.097769,-0.254960,0.096466,-0.037304,-0.106743,-0.255026,-0.113907,0.452066,0.007410) * L3_4 + mat4(-0.349211,0.068058,0.147954,0.036489,0.013628,0.182490,-0.058570,0.231713,0.264044,-0.067361,0.228711,-0.067535,-0.361898,0.614089,0.178890,-0.519216) * L3_5 + mat4(0.193797,0.230024,0.336528,-0.068716,-0.436320,0.283096,0.045671,0.018646,0.364519,-0.391799,0.261480,0.151119,-0.301799,0.120961,0.030737,0.112432) * L3_6 + mat4(-0.255176,0.144225,-0.043002,-0.202077,0.223451,0.122442,0.001639,-0.131788,-0.013593,0.215555,0.163260,-0.052559,-0.027526,-0.436851,0.315483,0.046029) * L3_7 + mat4(0.297239,-0.153714,-0.289326,-0.057038,0.040316,-0.036827,0.107656,0.015399,-0.205092,0.189285,-0.001740,-0.278934,0.260629,-0.203004,-0.215441,-0.106068) * L3_8 + mat4(-0.441507,-0.297647,0.155544,-0.112550,-0.291828,0.404152,0.057389,0.115847,-0.028237,-0.132783,0.272299,-0.341374,0.139137,-0.121328,-0.520735,0.128238) * L3_9 + mat4(0.199779,0.431908,-0.081731,0.100296,0.206267,-0.169604,-0.140732,0.014408,-0.238618,-0.066347,0.318162,0.258225,0.043238,0.188509,-0.233031,0.083908) * L3_10 + mat4(0.277770,0.291406,-0.325653,0.137263,0.091941,-0.288792,-0.095532,0.037861,0.113442,-0.038193,0.346110,-0.115748,-0.273547,0.269052,0.221870,0.415133) * L3_11 + mat4(0.106206,-0.126663,0.015879,-0.094180,0.122471,-0.176773,-0.173209,0.181319,0.006549,-0.100734,-0.325854,-0.143778,0.253907,-0.229232,-0.133457,0.312797) * L3_12 + mat4(0.287056,0.428444,-0.198008,0.060088,0.258065,-0.091627,0.106115,0.095413,0.317308,0.121396,-0.077074,0.049298,-0.300396,0.061603,-0.394308,-0.099239) * L3_13 + mat4(0.091382,0.409724,0.008367,-0.267895,0.296971,-0.061678,-0.089233,0.047349,0.500833,-0.129083,-0.363283,-0.256058,0.156975,-0.175590,0.207353,-0.045487) * L3_14 + mat4(0.252409,-0.278388,0.211467,0.250846,-0.163116,-0.241826,0.528319,0.014474,0.018347,0.360691,-0.128269,-0.246506,-0.281511,-0.260743,0.052758,0.075231) * L3_15 + vec4(0.022038,0.352343,-0.261780,0.059208)));\nvec4 L4_8 = sin((mat4(-0.122974,0.223606,-0.061097,0.154262,-0.144799,-0.092377,-0.194348,-0.180598,-0.088497,-0.480478,0.643841,0.086678,-0.089514,0.310106,-0.345169,0.006917) * L3_0 + mat4(-0.230907,0.228699,-0.130462,-0.174849,0.524233,0.112528,-0.262236,-0.009270,-0.180642,-0.159651,-0.170425,-0.021727,0.295056,-0.389104,0.303391,0.056433) * L3_1 + mat4(-0.004810,0.388397,0.025347,-0.370266,0.077715,0.307052,-0.014210,-0.357621,-0.152561,-0.484433,-0.603468,0.129213,0.071487,0.115140,-0.096634,-0.049265) * L3_2 + mat4(0.157275,-0.002838,-0.439251,0.262550,0.330611,0.227641,0.178573,0.023603,0.107430,0.291058,-0.297155,-0.258503,0.130838,0.143689,-0.002895,-0.140645) * L3_3 + mat4(0.074171,-0.331153,-0.063133,0.243457,-0.308850,0.216617,0.007953,0.475470,-0.199720,-0.315647,0.269900,0.123024,0.526748,-0.014215,0.435636,0.362839) * L3_4 + mat4(-0.453312,-0.062938,0.256393,0.281982,-0.080931,-0.203511,0.195324,-0.301434,0.309506,0.350873,-0.023461,0.204059,-0.091453,0.287533,-0.337461,-0.013395) * L3_5 + mat4(0.422460,0.325952,0.380630,0.056159,0.202471,-0.347125,0.081044,-0.321859,0.267636,-0.071940,-0.089769,-0.074556,-0.022148,0.057369,0.105202,-0.221442) * L3_6 + mat4(-0.304566,-0.073716,0.228504,0.018249,-0.154506,-0.050475,-0.073890,-0.080494,0.466938,0.490531,-0.300817,-0.124266,-0.252824,0.055631,0.393541,0.500787) * L3_7 + mat4(-0.288483,-0.213047,0.060279,0.096422,-0.064716,-0.324456,0.134236,0.335901,0.183280,-0.843823,0.111422,-0.115375,-0.032173,-0.373534,-0.073929,0.278155) * L3_8 + mat4(0.237932,0.211805,-0.153915,0.052785,0.260383,-0.191684,0.267354,0.140537,-0.371451,0.256582,0.438460,0.330928,-0.311254,0.214755,0.175478,0.582242) * L3_9 + mat4(-0.096803,-0.463820,-0.115571,-0.082473,0.285645,0.052120,-0.115102,0.131742,-0.065773,-0.686572,-0.024700,0.425185,-0.691785,-0.301644,0.290538,-0.267109) * L3_10 + mat4(0.388898,0.113584,0.174091,0.131454,-0.385854,-0.136738,0.091881,-0.089970,0.066345,-0.236745,-0.123189,-0.125747,0.262001,0.017564,0.131633,-0.379885) * L3_11 + mat4(-0.089604,-0.071838,0.253114,-0.037288,0.211394,0.220946,0.142881,0.303157,0.017479,-0.458769,-0.018168,-0.223288,-0.037245,-0.028174,0.398856,-0.048738) * L3_12 + mat4(0.271583,-0.267807,0.134014,-0.123026,-0.229702,0.185642,0.285691,0.048055,0.289918,0.001905,-0.385376,0.260220,0.520959,0.028871,0.064118,-0.135951) * L3_13 + mat4(-0.073405,-0.450240,0.125883,-0.014653,0.084830,0.121421,0.063655,-0.179815,-0.257443,0.282914,0.118323,0.275649,0.020497,0.292326,0.195832,-0.244027) * L3_14 + mat4(-0.329596,0.352308,-0.148097,-0.161475,-0.003286,0.155167,0.243995,0.158234,-0.240331,0.242501,0.380411,0.091764,-0.056403,0.153660,0.211464,-0.111450) * L3_15 + vec4(-0.289213,-0.048339,0.192608,0.307249)));\nvec4 L4_9 = sin((mat4(-0.169255,0.227554,-0.193065,0.261282,-0.039959,-0.507646,0.166756,0.031020,0.502664,0.000972,-0.207344,-0.305450,-0.184408,-0.412242,-0.239389,-0.126831) * L3_0 + mat4(0.010748,-0.062562,-0.183220,-0.064276,-0.012162,-0.521628,0.312213,-0.191660,0.105440,0.188318,-0.101648,0.445055,-0.255096,-0.353067,-0.329937,-0.024591) * L3_1 + mat4(-0.215448,-0.120600,-0.059743,-0.043172,0.330059,-0.322241,0.129470,0.065415,-0.311943,-0.244989,-0.055025,-0.092902,0.322717,-0.102398,0.244042,-0.030496) * L3_2 + mat4(0.178421,-0.114154,-0.254847,0.201175,0.098489,0.136649,-0.407680,-0.195268,-0.331100,-0.065233,-0.216783,0.236733,-0.017610,0.266815,-0.192298,0.040208) * L3_3 + mat4(0.382277,-0.406310,0.406036,-0.027988,-0.495891,-0.148999,-0.148000,0.377965,-0.000598,0.290821,-0.060855,0.008434,-0.263226,-0.205632,0.343367,0.335325) * L3_4 + mat4(0.311615,-0.190137,-0.079140,-0.032069,-0.172450,-0.183253,-0.094463,-0.108375,0.142358,0.161541,-0.358350,0.254459,-0.036095,-0.144237,0.022431,-0.291743) * L3_5 + mat4(0.060672,-0.254044,-0.034840,-0.065686,-0.657944,-0.174601,-0.229269,-0.112462,0.018120,0.078003,0.177118,-0.407089,0.334801,0.286611,-0.070417,0.234339) * L3_6 + mat4(-0.105668,0.315052,-0.159705,-0.015009,-0.269515,0.448036,-0.170910,-0.237535,-0.310825,0.188822,0.123340,-0.347520,-0.151870,0.155800,0.319371,0.422729) * L3_7 + mat4(0.365387,-0.000724,0.350204,0.171990,-0.002713,-0.140831,-0.046141,0.009972,-0.487367,-0.170077,-0.312506,0.006044,-0.216251,0.201335,0.268031,0.160953) * L3_8 + mat4(-0.137742,-0.160442,0.304523,-0.226648,0.310404,0.008484,0.164294,0.323420,0.313105,0.316621,-0.018885,-0.092749,-0.073526,0.366293,0.209620,-0.035788) * L3_9 + mat4(0.076752,0.165449,0.249781,0.127731,-0.217598,0.071763,-0.259692,-0.374828,-0.425332,-0.314780,0.100339,0.021125,-0.177001,0.508897,-0.243063,0.122720) * L3_10 + mat4(0.062102,0.262232,-0.139979,-0.187330,-0.481861,0.185586,-0.441442,0.161946,-0.289177,-0.031646,0.015720,-0.059625,-0.183060,-0.226783,0.113208,0.047094) * L3_11 + mat4(-0.396218,0.258587,0.051709,0.124388,-0.119924,-0.014425,-0.023145,-0.039076,0.363895,-0.053682,-0.326072,-0.079328,-0.061462,0.220379,0.091159,-0.282060) * L3_12 + mat4(-0.132182,-0.108798,0.123193,-0.086420,0.115274,0.179630,-0.088305,0.008366,0.089901,-0.358845,-0.133376,0.346265,0.019295,-0.143406,0.091026,-0.339139) * L3_13 + mat4(-0.316928,-0.166440,0.009015,0.083050,-0.157598,0.347252,0.050921,-0.416866,-0.004874,0.609565,-0.419129,-0.067067,-0.157197,0.381820,-0.129340,0.294440) * L3_14 + mat4(-0.042922,0.643717,0.019940,-0.441791,0.070200,0.335848,-0.036929,-0.259102,-0.157174,0.123164,0.233712,0.311097,-0.346026,-0.345511,0.035458,-0.467748) * L3_15 + vec4(-0.274883,-0.029033,0.097093,0.051113)));\nvec4 L4_10 = sin((mat4(0.180230,0.009102,0.131773,-0.186206,0.458760,0.194844,-0.061233,-0.203342,0.057079,-0.243295,0.411521,0.126577,0.334312,0.003132,0.303251,-0.465747) * L3_0 + mat4(-0.118580,-0.188330,0.450286,-0.023192,-0.146929,-0.292068,-0.284067,-0.294570,0.113612,-0.045447,-0.084276,-0.380553,-0.169864,0.173154,0.178143,0.207420) * L3_1 + mat4(0.022386,-0.175948,0.188944,0.247656,-0.336350,0.146716,0.039404,-0.185101,0.298402,0.323481,-0.204946,-0.182657,-0.005476,-0.137177,0.129459,-0.351410) * L3_2 + mat4(-0.150334,-0.226242,0.117787,-0.301637,-0.063312,0.078292,0.170743,-0.274394,0.181018,-0.044078,-0.434705,0.329419,0.409230,0.056649,0.159961,0.146039) * L3_3 + mat4(0.003358,0.242822,0.126261,0.221948,0.259545,-0.422855,0.274729,-0.233216,0.138859,-0.242946,0.103147,-0.184058,-0.097337,-0.248584,-0.180242,0.029713) * L3_4 + mat4(0.203722,-0.140914,0.056331,-0.301042,-0.075287,0.377008,0.295656,0.033685,-0.233212,-0.088075,-0.175673,0.216280,-0.145890,0.084041,-0.135567,-0.374792) * L3_5 + mat4(-0.196545,-0.104795,0.224230,-0.332455,0.296157,-0.162798,0.122506,0.014433,-0.105784,0.015634,-0.161362,0.064115,0.301769,0.335434,0.390578,-0.085473) * L3_6 + mat4(0.068800,-0.360956,-0.327238,-0.095150,-0.264213,-0.364412,0.282510,-0.187265,0.084854,-0.054910,0.317748,-0.211403,-0.383472,-0.362985,-0.342858,0.095301) * L3_7 + mat4(-0.324191,-0.025078,-0.372935,0.235315,0.413296,-0.289847,-0.622750,0.112158,-0.161118,0.273380,-0.070799,0.014344,0.148957,-0.366300,0.134164,-0.372774) * L3_8 + mat4(-0.118276,0.475822,0.215684,-0.051239,-0.012916,0.208382,0.291613,0.060621,-0.357854,-0.404525,0.085785,0.139306,0.116362,0.244447,-0.316928,0.288511) * L3_9 + mat4(-0.293200,-0.050082,0.094147,-0.379016,-0.206769,0.153366,0.022095,-0.099748,0.438956,0.220847,0.182788,-0.217793,0.234502,-0.063754,-0.320343,0.307087) * L3_10 + mat4(0.127516,0.021081,0.577384,0.254093,0.161764,-0.266188,-0.143957,0.028366,-0.049531,0.036684,0.296875,-0.207851,-0.348078,0.251751,-0.571764,-0.237955) * L3_11 + mat4(-0.677909,0.057811,-0.415713,0.056076,0.016578,0.208681,-0.142069,-0.087516,0.093687,0.087863,0.164955,-0.575163,0.227750,-0.277681,-0.002825,0.143706) * L3_12 + mat4(0.158944,0.105551,0.054230,0.055648,-0.097968,0.112647,0.169566,-0.013992,-0.376723,-0.108424,-0.165871,0.018788,0.386517,-0.557158,0.064512,-0.266890) * L3_13 + mat4(0.348538,-0.218463,0.227680,0.169154,0.054098,0.124666,0.218954,0.229903,0.194314,0.118024,0.284904,0.083042,-0.573928,-0.023970,0.246623,-0.421792) * L3_14 + mat4(0.093316,-0.165615,0.214131,-0.048245,0.408727,-0.271917,0.159394,0.126974,-0.231485,0.415929,0.142351,-0.207722,-0.443005,-0.331643,0.254006,-0.230342) * L3_15 + vec4(-0.147279,-0.140341,0.522473,0.224735)));\nvec4 L4_11 = sin((mat4(0.080630,0.310569,0.252620,-0.471557,-0.187263,-0.277941,-0.428158,-0.005633,-0.252914,-0.420828,0.569893,0.139531,-0.203506,0.198720,0.351497,0.278781) * L3_0 + mat4(-0.400296,0.126652,0.110163,0.003578,0.113685,-0.155266,0.130216,-0.217436,0.458588,0.416630,0.149396,-0.052923,0.159181,0.007163,-0.154182,0.164689) * L3_1 + mat4(-0.470732,-0.121629,-0.023718,0.234578,-0.231738,0.123861,0.173843,-0.251286,0.486376,-0.606083,0.067251,-0.392289,0.218054,-0.458963,0.070373,-0.205288) * L3_2 + mat4(0.224426,-0.138060,-0.504814,-0.166082,0.630198,0.225574,-0.035177,0.167509,0.214869,-0.081447,0.235316,-0.240317,-0.451168,-0.094870,-0.451966,0.355704) * L3_3 + mat4(-0.080768,0.208485,0.295340,0.112566,-0.346657,0.193305,-0.264418,-0.378849,0.093096,0.215753,-0.360086,0.230421,0.064409,-0.081039,0.370600,0.053470) * L3_4 + mat4(-0.183799,0.226262,-0.232281,0.355785,-0.107654,0.122168,0.204069,-0.338038,-0.077232,-0.051799,0.115361,0.138092,0.027707,-0.236258,-0.286777,0.250751) * L3_5 + mat4(-0.103557,0.152133,0.074018,-0.045480,0.046850,-0.142016,0.046547,-0.051771,0.084629,-0.070323,0.495963,-0.323171,0.152137,-0.062262,-0.166209,0.319519) * L3_6 + mat4(0.242334,-0.305721,0.214949,-0.273859,-0.058392,-0.081053,-0.551391,-0.198412,0.454669,-0.129267,-0.003897,0.188390,-0.153831,0.072846,0.081706,-0.160447) * L3_7 + mat4(0.016977,0.351532,-0.005710,0.211494,-0.316020,0.063237,0.059741,-0.123126,0.362243,-0.192887,0.417372,-0.040186,-0.381512,-0.328730,-0.097172,-0.015751) * L3_8 + mat4(-0.250201,0.010826,0.274346,0.206914,0.323708,0.232869,0.268243,0.198316,0.097311,-0.333044,-0.369613,0.317385,0.273455,-0.028975,-0.179044,-0.315213) * L3_9 + mat4(-0.090452,0.052306,-0.148010,0.099365,0.045453,-0.247293,0.127595,-0.190024,0.229074,-0.086748,-0.289653,0.335749,-0.176192,-0.162141,0.245888,-0.081223) * L3_10 + mat4(0.004673,-0.099464,-0.354269,0.238931,0.077483,-0.389540,-0.121868,0.285334,0.392148,0.111226,-0.245764,-0.147319,-0.389965,0.457217,0.466901,0.248936) * L3_11 + mat4(0.406137,0.411448,-0.099588,0.030523,0.381892,-0.258850,0.028394,-0.270209,0.011474,-0.500866,0.294301,-0.413148,-0.296115,-0.336984,0.145933,-0.198868) * L3_12 + mat4(-0.376123,-0.197368,-0.061570,-0.475825,-0.120899,-0.137810,0.181365,-0.439611,0.019838,0.324568,-0.170441,-0.062860,-0.229043,0.239656,0.133415,-0.344332) * L3_13 + mat4(0.240818,-0.117201,0.419170,0.151961,0.002234,-0.328677,-0.209477,-0.270743,-0.004732,0.401076,0.507872,-0.089716,-0.434399,0.252968,0.414478,0.089788) * L3_14 + mat4(-0.475595,0.016490,-0.130161,0.010731,0.178235,0.227589,-0.036285,0.366485,-0.054417,0.008849,-0.139076,0.259412,-0.115329,0.091375,0.394690,0.028379) * L3_15 + vec4(-0.020192,-0.343473,0.094966,-0.028596)));\nvec4 L4_12 = sin((mat4(0.392884,0.192094,0.290826,0.525855,0.341284,-0.200647,-0.533312,0.262893,0.086012,0.145833,-0.184895,0.234099,0.266090,0.290143,-0.207785,-0.003578) * L3_0 + mat4(0.251062,-0.286789,0.449424,0.221171,0.068352,0.040454,0.046871,0.017130,-0.356605,0.567067,0.007453,0.064185,-0.170585,0.201233,-0.076092,0.117757) * L3_1 + mat4(0.518558,0.129590,-0.296222,0.210028,-0.035934,0.050560,0.195025,0.274898,0.371618,0.001929,0.072429,0.313625,0.450773,-0.191635,-0.121201,-0.073219) * L3_2 + mat4(-0.215137,-0.259236,0.383672,0.607033,0.309598,0.257582,-0.172833,0.162857,-0.115386,-0.100913,0.423481,0.139797,0.229894,-0.399610,0.357129,0.326553) * L3_3 + mat4(0.054576,0.284838,-0.269859,-0.146487,0.164452,0.025202,-0.592751,0.124740,-0.234752,-0.293239,-0.126217,-0.348484,0.227746,-0.412822,-0.371506,-0.063895) * L3_4 + mat4(-0.058210,0.274662,-0.245916,-0.155954,0.124242,-0.291549,0.259708,0.096216,-0.102441,0.219159,0.014447,-0.211164,-0.539069,0.070961,-0.098619,0.045889) * L3_5 + mat4(-0.095255,0.008907,0.350784,0.149020,-0.099720,0.268806,0.184856,0.081148,-0.207371,-0.254671,0.401782,-0.178712,0.007192,-0.284504,0.449207,0.012895) * L3_6 + mat4(0.359566,0.360378,0.090902,0.527699,0.322010,-0.415820,-0.365446,0.089754,0.012310,0.202702,0.176469,0.179671,-0.037398,0.437989,0.324345,-0.136719) * L3_7 + mat4(-0.387113,0.488831,-0.569949,0.130213,-0.120533,-0.250647,0.419975,0.108981,-0.033801,0.252042,-0.162189,0.111282,-0.153152,0.231814,-0.397450,0.016981) * L3_8 + mat4(-0.155647,0.659792,-0.305036,-0.521864,0.220417,-0.341022,-0.267500,0.252203,0.399138,-0.338859,-0.080828,0.157529,0.124280,0.119979,0.135193,0.323624) * L3_9 + mat4(0.333713,0.110058,0.187358,-0.308347,0.134999,-0.033188,-0.469720,0.048792,-0.270742,-0.106629,-0.543728,-0.405882,-0.205243,-0.200775,0.219630,0.190472) * L3_10 + mat4(-0.206174,0.125303,-0.221571,-0.307830,-0.046824,0.063340,0.278980,0.447363,0.482044,0.059729,0.285528,-0.156926,0.092752,-0.332164,0.124242,0.075193) * L3_11 + mat4(0.252805,0.284203,-0.013330,0.306489,0.113105,0.445141,0.347139,0.232531,0.239806,-0.021413,0.219884,-0.212732,-0.178884,0.281737,0.180155,0.457207) * L3_12 + mat4(0.150451,0.250517,0.051781,-0.466764,0.543324,0.020384,0.072207,0.074023,0.212961,0.160555,0.361844,0.221347,-0.054660,-0.031004,-0.527000,0.084655) * L3_13 + mat4(0.008132,0.267367,0.058855,0.246129,-0.341919,0.482013,-0.234437,-0.697304,-0.489615,0.161103,-0.385094,-0.050307,-0.016152,0.134466,0.009053,-0.162068) * L3_14 + mat4(-0.419723,-0.256589,-0.368262,-0.109111,-0.245151,-0.072796,0.036497,-0.370389,0.060291,-0.006200,-0.240236,0.074913,0.227097,0.121844,-0.089433,-0.021287) * L3_15 + vec4(-0.053811,0.088963,0.017077,0.082423)));\nvec4 L4_13 = sin((mat4(0.229094,0.056802,-0.300909,0.507464,-0.047736,0.165333,0.215453,-0.108960,0.207426,-0.099749,-0.127603,-0.052971,0.035424,0.082637,-0.172802,0.204173) * L3_0 + mat4(0.275952,0.030633,0.006533,-0.392271,0.224033,-0.425213,0.073528,-0.153078,-0.173950,0.330926,-0.059307,0.297229,-0.056801,0.312403,-0.175167,-0.481828) * L3_1 + mat4(0.338427,-0.322215,0.269086,0.118121,0.041231,-0.317383,-0.109894,0.180322,0.076216,-0.320869,-0.142997,-0.462284,-0.269903,0.027173,0.339246,-0.116166) * L3_2 + mat4(0.121453,-0.255602,0.356435,-0.391546,-0.182433,-0.183128,0.126951,-0.095758,0.053463,-0.140496,0.006842,-0.308063,0.191385,-0.365307,0.126787,0.259746) * L3_3 + mat4(-0.107273,-0.320549,-0.144531,-0.352447,0.173645,-0.347746,-0.341751,0.273121,-0.214172,-0.143450,-0.141897,0.086385,0.398942,-0.208715,0.300009,0.151390) * L3_4 + mat4(0.191079,0.254870,-0.113964,0.216591,0.247885,-0.390100,0.295158,-0.411640,-0.232628,0.106382,0.194543,0.275924,0.200510,0.261602,0.148413,-0.295604) * L3_5 + mat4(0.073277,-0.269153,-0.028779,-0.261213,-0.068463,-0.103563,0.405825,0.121222,-0.186137,0.165941,-0.159649,-0.472269,-0.384295,-0.065510,0.210539,-0.159136) * L3_6 + mat4(0.016883,0.236835,0.189344,0.062156,-0.195309,0.032219,-0.350482,0.173077,0.069289,-0.112947,-0.350504,-0.243753,-0.333132,0.109588,-0.030545,0.136848) * L3_7 + mat4(-0.404626,0.015340,0.420601,0.101048,-0.344015,-0.018473,-0.071472,-0.390050,-0.093255,-0.241480,-0.042370,0.007082,0.553064,-0.008333,-0.237361,0.185591) * L3_8 + mat4(0.198509,-0.269177,0.166295,0.127352,-0.240519,0.318454,0.105014,0.333447,0.061457,-0.094172,0.026877,0.164997,-0.503365,0.352961,-0.317317,0.049601) * L3_9 + mat4(-0.390900,0.001178,-0.336369,0.041582,-0.229943,0.309658,-0.138481,-0.151217,-0.326888,0.310256,0.299506,0.335880,-0.117535,0.155518,-0.117692,0.541623) * L3_10 + mat4(-0.214290,-0.053788,-0.335531,-0.381496,-0.111799,0.247121,-0.203807,0.562857,0.071138,-0.046093,0.136755,-0.359485,-0.401056,0.007279,-0.120693,0.037636) * L3_11 + mat4(-0.026538,0.192067,-0.587125,0.041254,0.018791,0.187827,-0.218553,0.112894,0.196459,-0.247404,-0.049275,0.392387,-0.167930,-0.019632,0.175606,0.120948) * L3_12 + mat4(-0.036084,0.279351,-0.074379,0.285730,-0.237051,0.303610,-0.211572,-0.317218,0.027137,-0.539514,0.194616,0.130978,0.239172,-0.219935,0.455488,-0.222769) * L3_13 + mat4(0.153902,0.181444,-0.292528,0.086177,-0.115737,0.217090,-0.224973,0.336957,0.297979,0.103962,-0.604411,-0.309035,-0.008100,-0.083381,0.259696,0.167133) * L3_14 + mat4(0.254443,-0.090863,-0.410040,-0.009883,0.060859,-0.200451,0.336241,-0.447381,0.187394,0.105178,0.156587,-0.169002,-0.223605,-0.325060,0.350821,0.033160) * L3_15 + vec4(0.220735,-0.025172,0.323608,-0.250999)));\nvec4 L4_14 = sin((mat4(-0.137188,-0.173684,-0.286672,-0.045879,-0.313693,0.077495,0.003256,-0.077154,-0.252913,0.321928,0.187097,0.044393,-0.299149,-0.230567,-0.423837,-0.034407) * L3_0 + mat4(-0.031710,0.042646,0.157573,-0.165196,0.130850,-0.257900,0.172345,-0.318871,0.194652,-0.346851,-0.222906,0.149768,0.307514,0.415093,-0.276754,-0.234689) * L3_1 + mat4(0.069892,-0.045653,-0.199000,0.217882,-0.241710,-0.280028,-0.099604,-0.359470,0.312465,0.180961,-0.355538,-0.179779,-0.299415,-0.170930,0.477994,-0.019154) * L3_2 + mat4(0.223427,0.023879,0.038204,0.062475,-0.374491,-0.079930,-0.175561,-0.065299,-0.047938,-0.161675,0.286000,-0.243517,-0.217238,-0.409576,0.102882,-0.273806) * L3_3 + mat4(-0.026239,0.121157,0.108819,-0.184611,0.034260,0.281588,0.080144,0.325734,0.050949,0.533704,-0.053501,-0.025203,-0.007268,0.172099,-0.090011,0.255713) * L3_4 + mat4(0.107993,-0.335898,0.113061,0.475109,-0.193461,-0.081870,0.116651,0.128288,-0.056505,0.025576,0.392244,-0.056038,-0.115135,-0.314274,0.064084,-0.195470) * L3_5 + mat4(0.343766,0.340402,-0.062892,0.125094,0.187986,-0.288592,-0.344313,0.272355,0.309913,0.148085,0.159621,-0.017882,-0.084556,0.063056,-0.111321,0.338304) * L3_6 + mat4(0.145347,-0.115137,0.094460,-0.467092,-0.019269,0.020602,0.390871,-0.394773,0.190587,0.261268,-0.256466,0.176545,0.371496,-0.042160,0.296540,-0.023360) * L3_7 + mat4(0.263955,0.626264,0.162346,-0.165958,0.078315,0.257622,0.467513,-0.024319,0.134620,-0.028397,0.019462,0.338062,-0.333704,0.015798,-0.058436,0.439143) * L3_8 + mat4(0.251428,-0.392300,-0.044347,0.285148,0.033677,-0.199884,-0.075192,-0.116653,-0.149340,0.000718,-0.186558,-0.044256,-0.222903,-0.032876,0.305363,-0.178890) * L3_9 + mat4(-0.442338,0.041772,-0.278086,0.159641,-0.046262,0.397118,-0.318160,-0.244845,-0.099262,0.145525,0.265760,-0.128934,0.114189,0.112116,-0.139327,-0.264845) * L3_10 + mat4(-0.100801,-0.145162,0.052315,-0.063603,-0.016827,0.124276,-0.168423,-0.312082,0.113932,0.464162,-0.109709,-0.050811,0.066994,-0.219326,0.255581,0.087631) * L3_11 + mat4(-0.096783,0.102257,0.179153,-0.296013,-0.171386,-0.263118,0.067219,-0.457326,0.048993,0.216229,0.079662,-0.159039,-0.214954,0.015200,-0.511274,-0.044306) * L3_12 + mat4(-0.053751,-0.239041,0.252572,0.005207,0.115055,0.306740,-0.124384,0.171103,-0.053277,0.185788,0.018670,0.156226,0.417761,-0.168922,-0.006932,0.014264) * L3_13 + mat4(-0.183520,0.245614,-0.004579,0.203334,0.028889,0.225866,0.425459,0.123495,-0.158077,0.444711,0.068313,-0.242760,0.294167,-0.557567,0.038200,-0.069898) * L3_14 + mat4(-0.162072,-0.037755,0.042067,-0.072842,0.249699,-0.257901,-0.019000,0.116895,0.065695,0.193988,-0.414112,0.271423,-0.159707,0.114927,0.189026,-0.241806) * L3_15 + vec4(-0.007179,-0.280414,-0.237283,-0.166395)));\nvec4 L4_15 = sin((mat4(0.174772,0.070342,0.255182,-0.079982,0.058795,0.393212,0.204615,0.473870,-0.116136,-0.107727,-0.380160,0.266568,0.157681,-0.213735,0.261293,0.334992) * L3_0 + mat4(-0.264948,0.159493,-0.286751,-0.349749,-0.243194,0.383639,-0.107814,0.167204,-0.168999,-0.597535,0.165649,0.463464,-0.010343,-0.299811,0.393578,-0.021929) * L3_1 + mat4(-0.040002,-0.059784,0.361966,-0.372013,0.336630,0.223276,0.037433,-0.133579,0.377414,-0.346704,-0.265119,-0.233825,0.063737,-0.348217,0.125069,-0.069348) * L3_2 + mat4(0.273287,0.414558,-0.149797,-0.106639,-0.383971,-0.149678,-0.462565,-0.035406,0.144064,-0.064726,-0.214536,-0.168123,0.447142,-0.359529,-0.004967,0.186252) * L3_3 + mat4(0.024301,0.009141,-0.307782,0.157413,-0.509073,0.048480,0.118659,-0.143708,-0.321223,-0.443785,-0.230107,-0.170328,-0.386558,-0.214458,-0.066237,-0.169206) * L3_4 + mat4(-0.171886,0.276748,0.207361,0.326824,-0.094974,0.111295,0.037725,-0.375548,-0.083492,0.114740,-0.042200,0.079228,-0.378027,0.212628,-0.049756,0.112861) * L3_5 + mat4(-0.007112,0.248092,-0.050172,0.260500,-0.163415,-0.557416,-0.043389,0.287152,0.121075,0.329707,-0.432532,-0.370579,0.059480,-0.044713,0.148559,0.310638) * L3_6 + mat4(-0.377278,-0.081054,-0.141769,-0.172312,0.309283,-0.512128,0.110486,-0.313116,0.170982,0.377799,0.021233,-0.139459,0.567576,0.121350,-0.236813,-0.627098) * L3_7 + mat4(-0.106421,-0.038075,0.102698,-0.178447,0.227342,0.406452,-0.102531,0.362327,0.172890,0.182954,0.300013,-0.258297,0.033823,0.559146,0.029206,-0.001299) * L3_8 + mat4(0.241815,0.217928,0.055499,0.174561,0.206250,-0.047867,-0.232468,-0.247937,-0.110052,-0.587849,-0.010860,0.021019,-0.010840,0.308448,-0.350487,0.139185) * L3_9 + mat4(0.105110,0.369719,-0.452577,-0.000756,0.052917,-0.014777,-0.059702,0.356929,0.060999,-0.280740,0.337020,-0.149764,0.042631,-0.440664,-0.051484,-0.179148) * L3_10 + mat4(-0.062742,0.307183,0.193195,-0.115497,0.495581,-0.469909,0.108692,-0.147699,-0.160891,0.323306,-0.048932,-0.216697,-0.304975,-0.050794,0.310784,0.267359) * L3_11 + mat4(-0.042974,0.242171,0.238796,0.308131,0.085627,-0.183585,-0.262731,-0.031187,0.078647,0.142863,0.221232,0.273812,-0.248062,0.012098,-0.149677,0.080672) * L3_12 + mat4(0.146611,0.198584,0.152317,0.054310,-0.001018,0.390917,-0.154243,-0.212515,-0.475748,-0.197932,0.188766,0.030110,0.083625,-0.398669,0.070252,-0.124291) * L3_13 + mat4(0.086270,0.420011,0.120622,-0.174590,-0.180891,0.032574,0.372401,-0.147753,-0.313853,0.207654,0.029593,0.101854,0.014734,0.133304,0.053026,-0.072609) * L3_14 + mat4(0.373394,-0.373134,0.517499,-0.221970,-0.034174,0.170204,-0.188507,0.402076,0.087266,0.072514,0.180350,0.194284,0.117774,-0.013906,-0.176469,0.304857) * L3_15 + vec4(0.181905,0.062041,0.009423,-0.037742)));\nvec4 L5_0 = sin((mat4(-0.179865,0.568100,-0.552161,0.325307,-0.139495,-0.118067,0.247087,0.238455,-0.224928,0.343301,0.696852,0.193755,-0.298745,0.057824,-0.081535,-0.170366) * L4_0 + mat4(0.115660,-0.471446,-0.261690,-0.106020,0.080078,-0.055368,0.163252,-0.453924,0.077833,-0.012884,0.411971,-0.052346,-0.641736,0.042711,0.183964,-0.346316) * L4_1 + mat4(-0.027468,0.517862,0.030010,-0.087847,0.017926,-0.538832,0.380191,-0.530828,0.020984,-0.221322,-0.250891,-0.317468,-0.231313,-0.414446,0.185063,-0.351003) * L4_2 + mat4(-0.511622,0.247988,0.346462,0.569497,-0.166727,0.672490,0.363761,0.249034,0.419284,-0.363930,0.529819,0.162769,-0.415757,-0.245683,-0.550723,0.299243) * L4_3 + mat4(0.222573,0.265738,-0.291051,0.135423,-0.028594,0.585216,0.184418,-0.386724,0.061618,-0.108815,-0.149880,0.485306,0.133900,0.456319,0.130339,-0.000739) * L4_4 + mat4(0.018392,0.052584,0.612703,0.478246,0.157234,0.403103,0.353534,-0.040264,0.407206,0.131726,0.245184,-0.149185,0.174243,0.013625,-0.544139,0.213459) * L4_5 + mat4(-0.054756,0.136336,0.302719,-0.233913,0.217354,-0.373784,0.570561,-0.027528,-0.287689,-0.673487,0.354286,0.347071,-0.177759,0.270102,-0.105970,0.083345) * L4_6 + mat4(-0.133664,0.184015,-0.240890,-0.195793,-0.010775,0.407438,0.024066,0.262920,-0.251777,-0.150902,-0.130618,-0.230802,0.346884,-0.195611,0.515378,-0.137238) * L4_7 + mat4(0.163453,-0.202044,0.335466,0.349082,0.077050,-0.184832,0.230799,0.099889,0.008855,0.194479,0.132729,0.319360,-0.119899,0.599509,0.226235,-0.055189) * L4_8 + mat4(0.185710,-0.276347,0.581464,0.053243,0.068129,0.570842,0.411392,-0.069254,0.527279,-0.559589,0.144193,-0.209415,0.312712,-0.150335,0.007576,-0.286124) * L4_9 + mat4(-0.018099,0.005873,-0.519176,-0.004445,0.077414,-0.126884,-0.103376,0.032234,-0.301331,-0.085045,0.155033,-0.258046,-0.003724,0.119905,0.091877,-0.356211) * L4_10 + mat4(0.337336,0.156481,-0.306514,-0.060018,0.445756,-0.451434,0.104299,0.058948,-0.077470,-0.024168,0.437507,-0.284923,-0.128753,0.075619,-0.139026,0.240163) * L4_11 + mat4(-0.290390,0.187820,-0.056662,0.030616,0.098726,-0.334716,-0.125037,0.352089,-0.347703,0.351127,-0.106773,-0.060649,-0.122555,0.017931,0.280797,-0.480951) * L4_12 + mat4(-0.024837,0.144135,-0.036637,-0.307556,-0.298089,0.288106,-0.062941,0.310399,-0.050635,-0.439489,0.189969,-0.013276,0.304830,0.172160,0.340089,0.229356) * L4_13 + mat4(-0.195139,0.026035,0.074067,-0.148472,0.028673,0.162493,-0.336509,0.093023,-0.285328,0.074373,0.213516,0.126204,-0.320327,0.302305,0.302961,-0.369834) * L4_14 + mat4(0.021623,-0.466642,-0.256284,0.319533,0.406367,-0.029081,-0.362441,-0.389387,-0.303724,0.135602,0.431207,-0.484731,-0.285703,0.014907,0.032884,-0.385110) * L4_15 + vec4(-0.011519,-0.101206,-0.158197,-0.355355)));\nvec4 L5_1 = sin((mat4(-0.380282,0.234729,0.054881,-0.026000,-0.444917,0.148502,-0.293555,0.184988,0.073715,-0.086970,-0.586427,-0.162749,0.277550,0.265064,0.159781,-0.230858) * L4_0 + mat4(-0.117992,-0.050353,0.161135,-0.200253,-0.062569,-0.250279,0.033338,0.163138,0.212005,0.366577,0.483778,0.213246,0.548663,-0.191722,-0.241489,-0.000071) * L4_1 + mat4(0.236611,-0.221106,0.448596,-0.307505,0.113969,-0.352878,0.221313,0.020907,0.325694,-0.119533,-0.468604,-0.237370,-0.065124,-0.328613,-0.165265,0.347244) * L4_2 + mat4(-0.462864,-0.278298,-0.454072,-0.035487,0.168308,0.357805,0.163183,-0.226099,-0.155048,0.353513,-0.038602,-0.199026,-0.047057,-0.741043,-0.238813,0.198808) * L4_3 + mat4(0.116978,-0.034438,-0.516180,-0.303187,-0.113738,0.062821,-0.118688,-0.138200,-0.092401,-0.377674,0.006181,0.311512,0.281895,0.677122,-0.148628,0.342120) * L4_4 + mat4(0.154102,0.503069,-0.444084,0.121897,0.268326,0.568551,0.312646,-0.142823,0.376685,-0.374686,-0.170982,-0.115003,-0.387477,-0.612998,0.387345,0.016977) * L4_5 + mat4(-0.312138,-0.613592,0.247052,0.273969,0.053965,0.239762,-0.303081,-0.365668,0.026898,0.130774,-0.211570,-0.137616,0.280139,0.163393,0.579750,-0.394092) * L4_6 + mat4(0.689790,0.341595,-0.272613,-0.502938,0.317300,-0.162794,-0.331378,0.316554,0.267545,0.439534,-0.023442,-0.244827,0.210720,0.690199,-0.075421,-0.036805) * L4_7 + mat4(0.135869,-0.136051,0.361983,-0.196704,-0.459898,-0.562089,0.424064,0.186375,-0.432383,-0.068046,0.141382,-0.445381,-0.039336,0.085624,0.364443,-0.361333) * L4_8 + mat4(-0.068878,-0.309970,-0.026427,-0.278441,0.228803,-0.292660,-0.142561,0.335558,0.346707,0.075457,-0.028308,0.354048,0.601528,0.278160,0.376247,0.009232) * L4_9 + mat4(-0.493830,0.328960,-0.051501,-0.292304,-0.264356,-0.146175,-0.129657,-0.316844,0.116359,0.160705,0.012552,0.424783,-0.459455,-0.044201,-0.003842,0.218615) * L4_10 + mat4(-0.152273,-0.454956,-0.236246,-0.365543,0.083776,-0.757763,0.067647,0.039206,0.144165,-0.019694,-0.126424,-0.149567,0.022678,-0.620145,-0.276071,0.075810) * L4_11 + mat4(0.289768,-0.275092,0.079003,-0.119473,-0.204423,0.233743,0.555596,-0.402193,0.325264,0.137897,0.582605,-0.441920,0.052955,0.496688,0.311970,0.005634) * L4_12 + mat4(-0.111277,0.212744,-0.408231,-0.225530,0.062224,-0.466813,-0.125529,0.375248,-0.422420,0.272540,-0.183394,-0.192699,0.528773,-0.273338,0.283899,-0.258157) * L4_13 + mat4(-0.141605,0.568228,-0.038324,-0.221468,0.125874,-0.094621,0.090682,-0.193446,-0.272329,0.347871,0.120890,0.032829,0.266386,0.284802,0.208253,-0.411101) * L4_14 + mat4(0.159693,-0.543093,0.217430,0.166479,-0.519820,0.714897,0.211043,-0.096758,0.159840,-0.092916,0.209056,-0.509624,-0.546469,-0.011781,0.228955,-0.209534) * L4_15 + vec4(0.195643,0.075922,-0.153049,0.335837)));\nvec4 L5_2 = sin((mat4(-0.088992,0.032211,-0.125005,0.068378,-0.221238,0.397722,-0.200524,-0.154132,0.332270,0.011445,0.336826,-0.171886,0.121332,-0.106326,0.428651,0.394225) * L4_0 + mat4(-0.475625,-0.324643,0.142959,-0.033618,0.229233,0.060369,0.084461,-0.027776,0.050420,-0.095089,-0.129829,-0.377417,-0.231841,-0.161585,-0.557032,0.099699) * L4_1 + mat4(-0.195074,-0.268511,-0.083152,0.295196,0.394863,-0.588635,0.185986,-0.307214,-0.337852,0.363253,0.050225,-0.335703,0.216586,-0.738818,0.365068,0.326190) * L4_2 + mat4(0.561128,-0.046510,-0.235596,-0.255139,0.136088,-0.103734,0.327013,-0.087972,-0.304000,0.043351,0.102469,-0.397629,-0.550256,0.197909,0.176236,-0.307713) * L4_3 + mat4(-0.156119,-0.217573,0.010577,-0.238142,0.059781,0.088744,0.134125,-0.311706,-0.333122,0.250312,0.091988,-0.055584,0.124338,0.312537,-0.155722,0.144060) * L4_4 + mat4(0.051406,0.117643,0.011705,-0.077994,-0.651334,-0.404944,-0.031345,-0.224418,-0.402097,0.361322,0.308340,-0.315817,0.128003,0.274833,-0.341740,0.513085) * L4_5 + mat4(0.353688,0.098609,0.059988,0.397559,0.013169,-0.028093,-0.078704,-0.366968,0.144502,0.063401,0.150867,-0.073032,-0.467948,-0.454077,-0.278037,0.173533) * L4_6 + mat4(-0.069225,-0.001711,-0.205595,0.167747,0.023329,-0.120141,-0.521048,0.375329,0.148014,-0.440004,0.328536,-0.066361,-0.136026,0.213794,-0.415399,0.355966) * L4_7 + mat4(0.144662,0.026582,0.342913,0.030644,0.172586,-0.178121,-0.200038,0.106574,0.116992,-0.341222,0.210919,0.438431,0.224770,-0.042314,-0.353837,0.066656) * L4_8 + mat4(0.080210,0.388614,-0.187727,-0.318524,-0.278706,-0.087908,-0.317740,0.249753,-0.125573,0.220099,-0.077764,-0.352712,-0.300589,0.003712,-0.133927,-0.068004) * L4_9 + mat4(-0.138641,0.099840,-0.037059,0.094097,0.290153,0.273261,-0.378073,0.348758,-0.252286,0.192402,0.394406,-0.107973,0.136474,-0.211851,-0.241453,-0.124019) * L4_10 + mat4(-0.007084,-0.353027,-0.209919,0.459098,0.394968,0.142474,0.286848,0.158553,0.036906,0.371866,-0.248661,0.110701,-0.097811,-0.328887,-0.358997,0.511496) * L4_11 + mat4(-0.536272,-0.109299,-0.522462,0.563460,-0.133380,0.458873,-0.014924,-0.334678,0.491042,0.181799,-0.000664,0.232653,-0.409177,-0.203057,-0.136771,0.018860) * L4_12 + mat4(-0.270645,0.282925,-0.071721,-0.409232,0.454738,0.179716,-0.266391,0.455165,0.085995,-0.115263,0.304811,-0.197622,0.042463,0.014646,-0.202832,-0.273451) * L4_13 + mat4(0.220610,-0.096317,0.025193,-0.019939,0.484704,-0.321653,0.271744,0.169724,-0.028994,-0.054317,0.042203,0.185517,-0.004459,-0.226851,0.104533,-0.345612) * L4_14 + mat4(-0.137596,0.114956,-0.082487,0.180601,0.164378,-0.325766,-0.021396,0.336041,-0.187672,-0.060335,0.002254,-0.245208,-0.191782,-0.197627,-0.516044,0.513271) * L4_15 + vec4(-0.232355,-0.115297,-0.147748,0.095580)));\nvec4 L5_3 = sin((mat4(-0.030693,-0.626647,0.156670,-0.385320,-0.272033,-0.476351,0.276036,-0.121754,-0.172309,0.010607,-0.095800,0.062364,-0.220638,0.000520,-0.202600,0.282799) * L4_0 + mat4(-0.215155,-0.200178,-0.103821,-0.243671,-0.508295,0.038735,0.024468,0.063100,0.021873,-0.418613,0.250424,-0.269625,0.242729,0.282053,-0.504408,-0.150024) * L4_1 + mat4(0.247763,0.191677,-0.488222,-0.396240,0.222351,0.387574,0.362026,-0.303988,0.186940,-0.092575,0.105111,-0.232012,-0.168519,-0.119113,-0.441380,-0.207238) * L4_2 + mat4(0.142021,-0.341032,0.030372,-0.089493,-0.120799,-0.114055,0.079597,0.005544,-0.185502,0.290133,0.270675,-0.031037,-0.001296,-0.128257,-0.029892,-0.067531) * L4_3 + mat4(0.164150,-0.342861,-0.056238,-0.038664,-0.394437,0.054664,-0.073962,0.125911,0.048022,0.062040,-0.284380,0.190056,-0.192541,-0.377552,0.171846,0.324943) * L4_4 + mat4(0.523142,-0.287528,-0.131632,-0.234912,0.178250,-0.460024,0.434823,-0.036808,-0.350547,-0.259556,-0.126471,0.046721,-0.033670,-0.544240,0.136564,0.263654) * L4_5 + mat4(0.191529,0.147773,0.641925,-0.444683,-0.205516,-0.531867,-0.442898,-0.101771,-0.315228,0.412543,0.192750,-0.261568,0.240035,-0.121054,0.035591,-0.151883) * L4_6 + mat4(-0.055726,-0.421553,0.062577,0.074607,-0.446153,0.402880,-0.150741,-0.145670,0.194562,0.535718,0.650889,-0.069729,0.148947,0.251415,-0.043940,-0.069003) * L4_7 + mat4(-0.111273,-0.174016,0.090687,0.261695,0.219577,0.266766,-0.033579,0.315263,0.004477,0.032238,-0.172704,-0.089863,0.006636,0.483265,0.315265,0.236354) * L4_8 + mat4(0.250341,-0.628423,0.349222,0.225494,0.108627,-0.217019,0.180106,0.147109,-0.396260,-0.333367,-0.522898,-0.200991,0.054268,0.048973,-0.013757,-0.038862) * L4_9 + mat4(-0.313104,0.421294,-0.346978,-0.168484,0.015530,-0.419044,-0.191186,0.251714,0.570109,0.173017,0.054886,-0.128907,-0.343933,0.195172,0.243938,0.429048) * L4_10 + mat4(0.384426,-0.026794,0.303472,-0.084038,-0.016172,0.090170,-0.294720,-0.160117,0.030110,-0.303839,0.024880,-0.257492,0.674879,0.053263,0.259882,-0.159654) * L4_11 + mat4(0.167501,-0.753876,0.289143,-0.025408,0.022949,0.210370,0.160396,-0.347458,-0.416987,0.090674,0.365718,0.204292,0.287215,0.110609,-0.272186,0.240487) * L4_12 + mat4(0.112076,-0.242419,-0.277268,0.091063,0.346576,-0.257211,0.010131,-0.128234,-0.231126,-0.502287,0.196484,0.187694,-0.010093,-0.270995,-0.218464,-0.114411) * L4_13 + mat4(0.276305,-0.085163,-0.242471,0.297189,-0.079718,0.538087,0.032535,0.396497,0.237930,-0.565653,0.096589,-0.144558,-0.266621,0.075412,0.007905,-0.018769) * L4_14 + mat4(0.026465,-0.258328,0.159183,0.089092,-0.426838,-0.037454,0.051640,0.008615,0.241061,-0.074397,0.307871,-0.251724,0.306869,-0.332945,-0.297849,-0.287141) * L4_15 + vec4(-0.166893,0.095448,-0.580407,-0.335236)));\nvec4 L5_4 = sin((mat4(-0.347773,-0.553262,0.286634,-0.128978,-0.239839,0.190325,0.394293,-0.273088,-0.197777,-0.019984,0.220264,-0.037113,-0.123561,0.005998,0.460066,0.405660) * L4_0 + mat4(-0.250175,0.334449,-0.227180,0.393183,0.404518,-0.051020,-0.312930,0.253765,-0.332967,-0.190422,0.523497,-0.007789,0.023335,0.343539,0.426523,0.122909) * L4_1 + mat4(0.027512,-0.223721,-0.253260,-0.067100,0.183557,0.168704,-0.134935,0.428849,0.088240,-0.099859,-0.129893,0.327090,-0.183032,-0.350996,0.116754,-0.327391) * L4_2 + mat4(0.134381,-0.359301,0.044254,0.098913,0.330402,0.256046,0.298111,-0.580100,0.303961,0.326322,-0.174392,0.042302,-0.266880,0.397915,0.124571,0.176823) * L4_3 + mat4(0.302215,-0.240427,0.038670,-0.000233,0.154037,0.222829,0.263127,0.261297,-0.211155,-0.472328,-0.263176,-0.378148,0.013816,-0.132667,0.065465,0.035705) * L4_4 + mat4(-0.277299,-0.320275,0.241173,0.085510,0.439101,-0.156767,-0.328358,-0.456706,-0.043287,-0.084517,-0.228793,-0.055235,0.438063,-0.219180,-0.022649,-0.003096) * L4_5 + mat4(0.060173,-0.162508,0.034288,-0.233284,0.487152,0.056935,0.172462,-0.341932,0.188284,0.213671,-0.487280,-0.080514,-0.044869,-0.128973,0.109435,-0.325753) * L4_6 + mat4(0.422639,-0.183368,0.346737,0.361679,-0.362621,0.479637,-0.171049,-0.239267,0.043084,-0.129806,0.636265,0.160013,0.074249,0.265782,0.184709,0.128822) * L4_7 + mat4(-0.197413,0.256901,-0.035167,-0.080545,0.069734,-0.174668,0.074958,-0.221557,-0.311903,0.076170,-0.238467,0.323081,-0.300967,0.105510,0.088946,-0.170405) * L4_8 + mat4(-0.233497,-0.161602,-0.125044,0.206524,0.111942,0.341089,-0.145057,0.219103,-0.148333,-0.001013,-0.309891,-0.214602,0.221245,0.035378,-0.400018,0.220907) * L4_9 + mat4(-0.183813,-0.335640,0.186729,-0.012360,-0.346764,0.037458,0.061072,-0.201023,-0.290275,-0.155816,-0.133534,0.349389,-0.100421,-0.315966,-0.193988,-0.165833) * L4_10 + mat4(0.326087,-0.096781,0.583722,0.076612,0.071635,-0.373822,0.194610,-0.078821,0.122221,0.338009,0.349688,0.234668,-0.229463,-0.014536,-0.703517,0.042565) * L4_11 + mat4(-0.202202,-0.324181,0.257377,-0.112190,0.096200,0.445296,0.398168,0.297378,-0.269399,-0.067152,-0.067410,-0.136488,0.014878,0.037643,0.233967,-0.185978) * L4_12 + mat4(-0.088211,0.189065,-0.516214,-0.063615,0.164566,-0.161088,0.402580,-0.323137,-0.128559,-0.099409,-0.245097,0.088700,0.222000,-0.004859,0.076453,-0.138260) * L4_13 + mat4(0.060105,0.303666,0.299319,-0.129503,-0.497848,-0.259132,-0.235780,-0.249501,-0.111610,0.010062,0.070345,-0.096581,-0.405729,0.138471,-0.233726,0.100176) * L4_14 + mat4(0.233127,-0.135463,0.283841,-0.103448,0.001778,-0.271698,0.064435,-0.025630,0.139725,0.305194,-0.065602,0.203535,-0.314640,-0.057164,0.702323,-0.060456) * L4_15 + vec4(0.229353,-0.100982,-0.243882,-0.263240)));\nvec4 L5_5 = sin((mat4(0.181527,0.076429,-0.119418,-0.886294,-0.697525,-0.252805,0.027502,0.101473,0.002109,-0.107786,-0.106914,-0.920900,-0.151408,0.130955,-0.157355,-0.374665) * L4_0 + mat4(-0.114420,-0.063689,0.116430,0.708645,0.281003,-0.389294,0.407648,0.546610,0.229671,0.080961,-0.432377,-0.303576,-0.169459,0.390065,-0.247218,-0.065614) * L4_1 + mat4(-0.227930,-0.001585,-0.087171,-0.047650,0.113553,0.291790,-0.215302,-0.030339,-0.280379,-0.097024,-0.211795,0.149713,0.333379,-0.172799,0.609415,-0.108024) * L4_2 + mat4(-0.199017,-0.020380,-0.383293,0.547023,0.359186,-0.002914,0.190512,-0.284636,-0.507990,0.152583,0.060845,-0.140886,0.418242,0.078247,-0.162082,0.000713) * L4_3 + mat4(0.137489,0.526360,-0.041581,-0.603375,0.478633,0.369688,0.011785,0.530336,-0.178608,0.123503,0.064571,-0.215792,0.127525,-0.071809,0.128359,0.412810) * L4_4 + mat4(0.161136,-0.176083,0.032509,0.069318,0.302707,-0.168646,0.152501,0.025457,-0.475958,-0.129736,0.179848,0.392482,-0.231101,0.230071,-0.051039,0.560218) * L4_5 + mat4(-0.048015,-0.483631,-0.090727,0.254259,0.418243,-0.325496,-0.323643,0.000835,-0.161659,0.315372,0.093417,-0.107668,0.411990,0.206952,0.071757,-0.440682) * L4_6 + mat4(-0.302027,-0.099407,-0.141980,0.298278,-0.095010,0.171649,-0.274248,-0.329912,-0.111552,-0.439682,0.198756,0.215848,0.396643,-0.602087,0.061784,-0.018283) * L4_7 + mat4(-0.184711,0.172042,0.251234,-0.043909,-0.310678,0.210559,-0.107966,0.476385,-0.103693,0.177442,-0.209970,-0.279527,-0.114372,-0.130375,-0.144960,0.040252) * L4_8 + mat4(-0.423302,-0.571288,0.189837,0.351830,-0.623367,0.072767,-0.350762,-0.236497,-0.122750,-0.224908,-0.526272,0.376095,0.358823,0.178124,0.170341,-0.405121) * L4_9 + mat4(0.169913,0.230513,-0.189979,-0.362458,0.224340,-0.174238,0.072988,0.404563,0.444723,-0.394342,0.110847,0.115126,-0.344830,-0.129234,-0.478029,-0.008186) * L4_10 + mat4(0.835043,0.568841,-0.038719,0.148499,0.146111,0.013328,0.024383,0.223439,-0.129408,-0.373137,-0.273589,-0.234611,-0.329979,-0.235131,0.303482,0.448996) * L4_11 + mat4(0.226664,0.430896,0.359137,-0.350447,-0.056874,-0.102522,0.391966,0.533291,-0.008305,-0.231168,-0.060247,-0.165475,-0.176177,0.290609,0.326080,0.066514) * L4_12 + mat4(0.312379,-0.282514,0.060395,-0.394283,-0.067431,0.091875,0.106830,-0.063422,0.527130,0.282196,-0.077858,-0.220516,-0.139093,-0.176050,-0.243965,-0.422781) * L4_13 + mat4(-0.323222,-0.329264,0.113133,-0.199974,0.236691,-0.010172,0.248753,0.452902,0.214150,-0.039066,0.302594,-0.237952,-0.101613,-0.120426,-0.077461,-0.382178) * L4_14 + mat4(0.159763,-0.089664,0.421976,0.070772,-0.029221,-0.013805,-0.171193,0.459568,0.005655,0.490261,0.460954,-0.280846,-0.211510,0.045566,0.171893,-0.203575) * L4_15 + vec4(0.201778,0.097388,-0.354646,0.128327)));\nvec4 L5_6 = sin((mat4(0.656235,-0.681153,-0.045883,-0.485257,0.465719,-0.373948,-0.251606,0.050405,-0.174241,-0.531222,-0.295451,0.222258,-0.194501,-0.167224,0.263305,0.130107) * L4_0 + mat4(0.163997,0.465278,0.140533,-0.257188,-0.170608,-0.125196,0.300046,0.107567,-0.607414,0.235829,-0.271877,-0.230465,-0.220154,-0.482574,-0.066446,-0.036067) * L4_1 + mat4(-0.609133,0.302800,-0.148144,-0.280912,0.091136,-0.289750,-0.119494,0.216934,-0.042628,0.114646,-0.294504,0.176618,0.406730,0.077683,0.281266,-0.106470) * L4_2 + mat4(0.060418,0.070377,-0.625005,0.118267,0.194528,-0.338006,-0.289774,-0.191465,0.319410,0.157078,-0.502965,0.323652,-0.176322,0.180452,0.468441,0.754209) * L4_3 + mat4(-0.122262,0.111306,0.184486,0.117817,0.346630,0.111236,-0.237216,-0.422240,0.264213,-0.182004,0.292859,-0.389820,-0.486676,0.090907,0.348267,0.257481) * L4_4 + mat4(0.055169,-0.135289,-0.072911,-0.322381,0.157353,0.143457,0.221233,0.035599,0.075935,0.231357,0.344525,-0.449877,0.217862,0.165453,-0.075207,0.347053) * L4_5 + mat4(-0.226158,0.157137,0.147056,-0.524241,0.388067,0.014425,-0.164856,0.269113,0.473925,0.473302,-0.161432,0.179294,0.096517,-0.303802,0.101614,-0.294153) * L4_6 + mat4(0.485352,0.492343,-0.475508,0.110506,-0.243040,0.255033,0.584574,0.103334,0.317141,0.215238,-0.268921,0.389287,-0.136661,-0.501402,-0.129013,-0.136119) * L4_7 + mat4(0.428253,0.283287,0.259529,-0.464363,0.407940,0.182720,0.003998,-0.114879,-0.090600,-0.390260,-0.074049,0.318515,-0.400417,0.082566,0.024229,0.238684) * L4_8 + mat4(-0.057300,0.424457,-0.019764,-0.108710,0.074684,0.321183,0.474748,-0.069809,-0.332987,0.056852,0.445820,-0.018901,0.226850,-0.141932,-0.381704,0.075501) * L4_9 + mat4(-0.438143,-0.253528,0.110386,0.467467,0.010298,0.087989,-0.196681,-0.320897,0.186500,-0.449413,0.189911,-0.073591,0.411751,0.364778,0.233665,-0.067161) * L4_10 + mat4(-0.209157,-0.240944,-0.160977,0.091159,0.280195,0.201708,0.275897,0.216668,0.422427,-0.370648,0.154461,0.106215,-0.407178,0.134108,0.135074,-0.019692) * L4_11 + mat4(0.186969,0.230135,-0.244556,0.146080,0.450613,-0.075939,0.229166,-0.337469,-0.229280,-0.195093,-0.182412,-0.064335,0.444278,0.305137,0.018183,-0.087934) * L4_12 + mat4(-0.016885,0.005586,0.235599,-0.347285,-0.453468,-0.048313,0.029352,0.072064,0.153321,0.025935,0.458762,-0.350475,0.417045,-0.056927,0.154524,0.092304) * L4_13 + mat4(-0.479052,0.083697,0.294565,0.333764,0.112791,-0.247427,-0.266568,0.060637,-0.367962,0.000337,-0.074962,-0.362256,0.275145,-0.302934,-0.168652,-0.066340) * L4_14 + mat4(0.434358,-0.108351,0.156706,-0.291563,-0.612061,-0.046504,-0.695337,0.128431,-0.197058,0.417977,0.249339,0.154631,-0.149840,0.035026,-0.016376,-0.509606) * L4_15 + vec4(0.099677,-0.448182,0.227101,0.177277)));\nvec4 L5_7 = sin((mat4(-0.374219,0.259237,0.285714,0.234900,-0.319677,-0.125663,0.129756,0.047254,-0.199077,0.143278,0.345483,0.090451,-0.005138,0.259687,-0.139776,-0.436286) * L4_0 + mat4(0.034926,0.246082,-0.361115,-0.173123,-0.177130,0.132576,0.235851,-0.443554,0.143508,-0.034123,0.018997,0.178811,-0.055200,-0.340601,0.265957,0.342760) * L4_1 + mat4(-0.136617,-0.282339,0.495872,-0.537068,0.163890,-0.100409,0.349843,0.177357,0.085337,-0.091550,-0.253916,-0.486476,-0.166769,0.179240,-0.090000,-0.135395) * L4_2 + mat4(-0.163914,-0.158433,-0.301324,0.147968,0.095534,0.003484,-0.211963,-0.377801,-0.042528,0.164692,-0.086604,-0.018723,0.186661,-0.080293,-0.110090,-0.365962) * L4_3 + mat4(-0.329777,0.019972,0.124698,-0.170263,0.063228,0.159421,-0.391915,0.158755,0.113089,0.265182,0.418261,0.137585,0.310722,-0.240116,0.398802,-0.047197) * L4_4 + mat4(-0.424443,-0.351548,0.260798,0.131320,-0.459793,0.147122,-0.235713,-0.009822,0.042486,-0.297080,-0.031646,-0.188597,0.094348,0.039230,0.300317,-0.297716) * L4_5 + mat4(-0.015198,0.128581,-0.263000,0.240848,-0.145973,-0.069654,-0.425146,-0.260089,-0.039345,-0.189968,0.554036,0.290076,0.028119,0.102719,-0.103539,-0.341429) * L4_6 + mat4(-0.045875,-0.060036,-0.310416,-0.011265,-0.401803,-0.284419,-0.273725,0.052165,-0.151596,0.293107,0.288286,0.456686,0.111803,0.710731,-0.233159,0.171460) * L4_7 + mat4(0.076442,0.034609,0.352235,0.178944,-0.203052,0.009759,-0.122674,-0.028250,0.303068,-0.044579,0.505387,-0.007642,0.145436,0.044499,-0.495896,-0.313062) * L4_8 + mat4(0.291579,0.363712,0.204621,0.000949,0.310466,0.324718,-0.283920,-0.166440,0.045054,-0.316730,-0.386189,0.114471,0.108033,-0.099827,0.504405,0.077102) * L4_9 + mat4(0.197785,-0.307152,-0.454824,-0.033707,-0.285209,-0.099146,-0.329387,-0.309346,-0.236341,-0.120987,0.195320,0.294099,-0.089334,-0.280062,0.029661,-0.139896) * L4_10 + mat4(0.112746,0.099754,-0.081159,-0.059356,0.046083,0.105298,-0.308332,0.236237,-0.102681,0.000923,-0.162835,0.216292,0.268637,-0.221055,0.076909,-0.144125) * L4_11 + mat4(0.221605,-0.091560,-0.446482,0.135424,0.189771,-0.416110,-0.483278,0.185096,-0.291551,-0.022925,0.362812,0.086617,0.235903,0.371828,-0.243100,-0.123992) * L4_12 + mat4(-0.201427,0.545349,-0.231579,-0.134160,0.129612,-0.087587,-0.243773,-0.252444,-0.004471,0.019823,-0.209353,-0.128246,0.267221,0.207533,-0.162988,-0.135295) * L4_13 + mat4(-0.253606,0.247361,0.360117,0.322480,-0.338101,0.396230,-0.041083,0.124189,-0.392007,0.280013,0.062108,0.442538,-0.281795,-0.036390,-0.550932,0.013217) * L4_14 + mat4(-0.161446,-0.009476,-0.258040,0.457405,0.043158,-0.145623,0.381868,0.281989,0.078410,0.187165,-0.211591,-0.339923,0.190315,-0.004230,-0.451010,-0.265134) * L4_15 + vec4(0.086154,0.044696,-0.032889,-0.276247)));\nvec4 L5_8 = sin((mat4(0.612043,0.248301,0.516942,0.325284,-0.363511,0.228964,0.214313,-0.295042,0.097800,0.240311,0.148578,0.343968,-0.434037,0.360863,0.157196,-0.291659) * L4_0 + mat4(-0.372849,-0.358674,0.063403,0.168060,0.384996,0.452041,-0.479352,0.077105,-0.015785,0.041059,-0.202787,-0.271875,0.349109,0.537810,0.227325,0.071379) * L4_1 + mat4(-0.348626,0.431092,0.421029,0.017786,-0.081969,0.021628,0.361845,-0.393262,-0.432400,0.126723,-0.609409,0.154921,-0.345526,0.231571,0.145022,0.179950) * L4_2 + mat4(-0.122012,0.224319,0.092615,-0.339381,0.352564,0.164582,-0.506207,0.309523,0.179448,-0.255931,-0.210699,-0.007275,0.113760,0.159847,0.404976,0.419651) * L4_3 + mat4(0.421443,0.310387,0.190755,-0.198594,0.475559,0.274381,-0.007511,0.403378,-0.272387,0.011379,0.341199,-0.139689,0.476654,-0.092423,0.373823,0.362877) * L4_4 + mat4(0.435529,-0.204697,0.222536,0.087070,-0.031960,0.211597,0.207916,0.070918,0.500028,-0.052471,0.335973,0.012781,-0.174438,0.157151,-0.286284,-0.173640) * L4_5 + mat4(0.152250,-0.489475,-0.166591,-0.068041,-0.206892,0.200159,-0.211757,-0.192768,-0.272474,-0.456576,-0.024555,-0.059117,0.573834,-0.230096,-0.033526,0.065176) * L4_6 + mat4(-0.184355,0.036996,-0.020939,-0.023290,0.613595,-0.150978,0.268122,-0.245337,0.536428,-0.289607,-0.377189,0.446919,-0.270391,0.400844,0.350104,-0.001553) * L4_7 + mat4(0.241866,-0.247784,-0.242003,-0.339042,0.371913,0.431098,-0.543528,0.264944,-0.302447,-0.369633,-0.265960,-0.025803,0.147792,0.174891,-0.120691,0.307548) * L4_8 + mat4(0.196348,0.316122,-0.250719,0.337354,-0.086762,0.278971,0.275871,-0.128715,-0.098555,0.054204,0.155247,-0.297929,-0.205942,-0.067950,-0.117084,-0.124558) * L4_9 + mat4(-0.312383,0.549412,0.091276,0.178730,-0.234769,-0.229196,0.401450,-0.149758,0.328554,0.274844,-0.384411,-0.281626,-0.164440,0.385607,0.635792,-0.175137) * L4_10 + mat4(-0.305574,0.483517,0.375435,-0.419919,-0.186082,-0.053331,-0.791944,-0.534548,-0.614438,-0.330265,0.155254,-0.109547,-0.188905,0.019964,-0.687090,0.362779) * L4_11 + mat4(0.099162,-0.475006,-0.195834,-0.183190,0.005182,0.514837,0.541187,0.495905,0.223434,-0.491083,0.390275,-0.163792,-0.278726,0.159654,0.414247,0.139683) * L4_12 + mat4(0.072745,0.342879,0.361998,-0.159240,0.269295,-0.091140,-0.100282,0.018425,-0.154017,-0.342129,0.010504,-0.140884,0.025541,-0.169961,-0.168653,0.068159) * L4_13 + mat4(0.005496,-0.758397,-0.470816,0.296004,-0.387450,-0.403851,0.112920,-0.064286,-0.101321,0.164615,-0.361559,-0.009818,-0.026421,-0.126890,-0.331455,0.156352) * L4_14 + mat4(0.550144,0.208905,-0.378313,-0.377954,-0.438902,0.501853,0.598533,0.407247,-0.218215,-0.087291,-0.275620,-0.402931,0.288405,0.017641,0.384381,0.321204) * L4_15 + vec4(0.077526,0.351621,-0.130592,-0.138162)));\nvec4 L5_9 = sin((mat4(0.366711,0.252544,0.233426,0.156699,-0.221266,-0.115648,0.459107,-0.406873,-0.201233,-0.475888,0.197726,0.001925,0.030784,-0.017887,0.029160,-0.195278) * L4_0 + mat4(-0.101198,-0.150027,-0.128480,0.021132,0.245084,0.148112,-0.375444,0.298350,0.054065,-0.391914,0.321066,0.078639,0.187863,0.066305,-0.137590,0.291653) * L4_1 + mat4(-0.271022,-0.099916,0.226814,-0.128044,0.285845,0.263999,-0.335986,0.174089,0.102435,0.212613,-0.453540,0.650721,0.381373,-0.133183,0.107361,-0.301495) * L4_2 + mat4(-0.277051,0.012143,-0.162096,-0.315964,0.260566,-0.087776,-0.017877,0.115852,0.090618,0.038768,-0.321320,0.255431,0.443933,-0.193470,-0.414187,-0.208380) * L4_3 + mat4(-0.047916,0.033606,-0.250795,0.098764,0.115753,-0.317875,0.459456,-0.083339,0.233863,0.324456,-0.293926,-0.422708,-0.307112,-0.103866,-0.019547,0.176669) * L4_4 + mat4(0.428479,-0.200129,-0.253951,-0.201349,-0.198400,0.232430,0.302729,0.593602,0.019639,0.103615,-0.336187,0.161414,0.088369,0.342063,-0.056988,0.081904) * L4_5 + mat4(0.005772,0.108965,-0.306085,0.248017,-0.578500,-0.161291,0.153657,0.061505,-0.020967,0.249553,-0.146619,-0.076171,-0.063781,-0.049799,0.430485,0.358790) * L4_6 + mat4(0.064418,0.316572,0.079792,0.634695,-0.184698,0.043852,-0.172753,0.000414,-0.122923,0.037567,0.268682,0.331357,0.301429,-0.196425,-0.203739,-0.391741) * L4_7 + mat4(-0.257500,-0.438338,0.166897,0.221625,-0.133937,0.329261,0.034434,-0.056049,-0.122755,-0.077976,0.110852,0.041498,0.212184,-0.043351,0.077440,-0.135423) * L4_8 + mat4(0.024084,0.188616,-0.257691,0.147983,0.215373,0.086804,0.074526,0.657690,-0.123311,0.172945,0.021722,-0.276698,0.249722,-0.065249,0.141128,-0.322470) * L4_9 + mat4(0.440254,-0.082231,0.258282,-0.589950,-0.285176,0.189176,-0.297119,0.369071,0.169942,-0.106129,-0.143611,0.108872,-0.042754,-0.035573,-0.464332,-0.113007) * L4_10 + mat4(0.061159,0.108637,-0.078782,-0.333037,-0.104831,0.025791,0.194398,-0.697074,-0.272075,0.277627,0.156306,0.306686,0.535842,0.252629,0.016291,-0.182677) * L4_11 + mat4(0.185276,-0.164678,0.384744,0.464652,0.240083,-0.187427,-0.531221,0.399672,-0.218199,-0.354607,-0.223320,0.263980,-0.330669,0.153024,-0.348410,-0.581214) * L4_12 + mat4(-0.180204,0.018836,-0.124068,0.166882,0.162937,-0.186851,0.518051,0.384851,0.472569,0.215868,0.180584,-0.568947,-0.209911,0.304913,0.073018,0.477133) * L4_13 + mat4(-0.434725,0.528030,0.437984,0.396188,-0.076302,-0.226660,0.023383,0.242997,0.058989,0.072840,0.121739,0.533579,0.280380,-0.176309,-0.091830,0.119837) * L4_14 + mat4(0.170025,-0.232481,0.262640,-0.294590,-0.135824,-0.184826,0.161267,-0.318568,0.311795,-0.195035,-0.233692,0.371294,0.190454,0.206463,0.591484,-0.308286) * L4_15 + vec4(0.133977,0.191084,0.001931,-0.261225)));\nvec4 L5_10 = sin((mat4(0.431122,0.254999,0.197671,0.140836,0.148862,0.123341,0.710430,-0.330940,-0.242183,0.033185,-0.054113,0.334812,-0.005846,0.098371,0.069648,-0.020575) * L4_0 + mat4(-0.360780,-0.202254,0.022833,0.190646,0.157801,-0.064510,0.034813,-0.246476,-0.050131,0.105100,-0.154733,-0.446337,0.159514,0.154164,0.057541,0.099345) * L4_1 + mat4(-0.368720,-0.133046,-0.486552,-0.094239,0.042391,0.064853,-0.005958,-0.332031,-0.091108,0.068590,-0.372385,0.124057,-0.028455,-0.387478,0.029037,0.174144) * L4_2 + mat4(0.028330,0.045513,-0.413334,-0.149705,0.155296,-0.438065,-0.035691,0.230985,0.400044,-0.031171,0.547761,0.003797,-0.355947,0.201460,-0.442813,0.052218) * L4_3 + mat4(0.184635,-0.319336,0.405759,-0.071573,-0.517224,0.181288,-0.317298,-0.253659,-0.054719,-0.166601,-0.175944,0.096443,0.170378,-0.269834,-0.094185,-0.083536) * L4_4 + mat4(0.743833,0.187908,0.132948,-0.008324,0.200367,0.237383,0.229997,-0.239517,-0.100960,-0.167931,-0.308132,-0.176098,0.161780,-0.122834,-0.104074,0.367458) * L4_5 + mat4(-0.231990,0.378341,0.239558,0.160816,0.270741,-0.139459,0.074906,-0.389591,0.075908,-0.090101,0.563995,-0.393368,0.389983,-0.132338,0.151407,-0.451577) * L4_6 + mat4(-0.638159,-0.570796,0.264654,-0.421603,-0.109709,-0.606566,-0.348704,0.125652,-0.063541,-0.256130,-0.177496,0.239557,-0.033088,0.182090,-0.325480,-0.065104) * L4_7 + mat4(-0.174765,0.061696,0.191141,0.212942,-0.296914,0.312558,-0.141650,0.015342,-0.367439,-0.206442,-0.144214,-0.060490,0.173291,0.138663,0.144027,-0.164613) * L4_8 + mat4(0.148391,0.062448,-0.210883,-0.350651,0.075744,-0.558891,-0.043530,0.085129,0.591691,0.585203,-0.235430,-0.331996,0.505539,-0.300230,0.281382,0.343850) * L4_9 + mat4(0.402003,-0.023179,0.234381,0.279577,0.019556,0.069055,0.423759,0.107013,-0.353121,-0.068913,-0.102346,-0.224513,0.353776,-0.148602,-0.305793,-0.025269) * L4_10 + mat4(0.023350,0.191669,-0.261103,0.092454,-0.259413,-0.249496,0.284754,-0.343086,-0.508265,-0.466387,0.257515,-0.051009,-0.492359,-0.351060,-0.193507,-0.114384) * L4_11 + mat4(-0.176837,0.054821,0.110030,-0.115272,0.063148,-0.074269,-0.038046,-0.325111,0.215044,-0.270773,-0.025729,0.105818,0.309075,0.323396,0.274810,-0.078131) * L4_12 + mat4(-0.081951,0.252901,-0.189809,-0.165167,0.047112,-0.347116,0.095665,-0.169580,0.228085,0.275313,0.115011,-0.234539,0.462443,0.047967,0.133391,0.132435) * L4_13 + mat4(0.079077,-0.343914,0.451856,0.315076,-0.077494,0.148770,-0.332902,0.311391,0.526397,0.252909,0.509195,0.055365,-0.459465,0.292426,-0.339106,0.210485) * L4_14 + mat4(0.419299,0.019849,-0.153647,-0.205182,-0.234661,0.155140,-0.003004,-0.209209,0.503182,-0.086354,-0.426937,-0.467695,0.144126,-0.351524,-0.309104,0.051940) * L4_15 + vec4(-0.273188,0.243232,0.548421,-0.004623)));\nvec4 L5_11 = sin((mat4(-0.201990,0.081347,-0.220770,0.418450,0.559211,0.302622,-0.020231,-0.113465,-0.474719,-0.366479,-0.133292,0.557490,-0.042368,0.154470,0.072882,0.058484) * L4_0 + mat4(-0.119630,0.261997,0.123542,-0.039180,-0.304194,-0.153553,-0.008619,-0.342080,-0.173412,-0.136040,0.021713,-0.711740,-0.191955,0.083199,0.100403,-0.394063) * L4_1 + mat4(0.506500,-0.221151,-0.171895,-0.500652,-0.304339,-0.054174,-0.354755,0.571158,0.003064,0.190903,0.007770,-0.508752,-0.317892,-0.218748,0.558364,0.036996) * L4_2 + mat4(-0.397846,0.316546,-0.429842,-0.128573,0.342544,-0.442906,-0.127661,0.554157,-0.392879,-0.036699,0.129100,0.195218,0.349209,-0.098422,-0.302625,0.103664) * L4_3 + mat4(0.380248,-0.235195,0.053834,-0.036230,0.096905,0.276980,-0.032081,-0.446129,-0.214382,0.070401,0.353050,0.141455,0.341829,0.229631,0.084113,0.285023) * L4_4 + mat4(0.178976,0.255480,-0.014080,-0.337710,-0.335659,-0.189746,0.230390,0.023894,0.409312,0.116847,0.086540,-0.165712,-0.009784,-0.233469,0.294475,0.059647) * L4_5 + mat4(-0.092899,-0.077286,-0.009889,0.390518,0.448386,0.204849,-0.813876,-0.013536,0.190737,0.271146,0.118581,-0.036159,-0.507863,-0.354125,0.046173,0.069578) * L4_6 + mat4(0.309177,-0.148676,-0.217247,-0.267969,-0.362211,0.491321,0.216094,0.231216,-0.280950,-0.015406,-0.717244,0.179496,-0.160024,-0.079063,-0.482044,0.038683) * L4_7 + mat4(-0.340609,-0.153916,-0.438942,-0.092005,0.001506,-0.259365,0.209974,-0.144071,0.123623,-0.054382,-0.025361,-0.097737,0.123659,0.142451,0.185581,0.401791) * L4_8 + mat4(0.348454,-0.030474,-0.502427,-0.062386,0.320157,0.242538,0.156849,0.104879,-0.147469,0.038680,-0.341623,-0.091263,-0.612784,0.118105,0.182596,0.246694) * L4_9 + mat4(-0.068065,-0.334918,0.080359,-0.417328,0.066050,-0.036153,0.143719,0.006600,0.307258,0.429225,-0.006043,-0.125694,-0.042417,-0.002882,0.201122,-0.331464) * L4_10 + mat4(0.248659,-0.258978,0.191761,0.018587,-0.171570,-0.102609,0.105762,0.089862,-0.569574,-0.094201,0.239869,0.071312,0.211472,0.587657,0.151120,-0.486137) * L4_11 + mat4(-0.559565,0.594650,-0.392257,-0.393105,-0.151043,0.012200,-0.052949,0.142707,-0.258058,-0.261511,0.031679,0.116337,-0.133737,0.170135,-0.339819,0.183167) * L4_12 + mat4(0.048970,-0.048686,-0.126700,0.080857,0.225677,-0.065869,0.326624,0.153518,-0.418370,-0.086297,0.177319,-0.196042,-0.108230,-0.432874,0.458478,0.278062) * L4_13 + mat4(-0.177756,-0.447838,-0.257542,0.251549,0.342232,-0.329900,-0.026850,0.336264,0.019387,0.075686,0.036881,-0.121390,0.416018,0.565366,-0.122430,-0.264257) * L4_14 + mat4(0.100788,0.172461,0.256638,0.474120,0.014408,-0.003736,0.091194,-0.477018,0.181727,-0.158412,-0.321876,-0.220749,-0.219281,0.025244,0.076452,-0.508351) * L4_15 + vec4(0.253968,0.557286,0.301435,-0.178005)));\nvec4 L5_12 = sin((mat4(-0.269208,-0.405908,-0.001927,-0.032190,-0.035747,0.263847,0.068246,0.138745,0.056191,0.830069,0.185219,-0.151749,0.065566,0.489110,-0.219412,0.312186) * L4_0 + mat4(0.148371,0.148866,0.024156,-0.313885,-0.102220,-0.320334,-0.173597,0.407363,-0.395866,0.304862,0.090572,0.026216,-0.517924,0.618597,0.169235,-0.063896) * L4_1 + mat4(-0.085700,0.030453,0.102127,-0.111448,-0.164989,0.268965,0.012000,-0.270154,0.133325,0.516048,-0.288480,0.191680,0.064676,0.251517,-0.151542,0.290720) * L4_2 + mat4(-0.280216,0.382304,0.192660,0.180372,0.153956,-0.302623,-0.304698,-0.280819,0.388304,0.125931,-0.057750,-0.284269,-0.076310,-0.090279,0.138945,-0.104791) * L4_3 + mat4(-0.009921,0.005428,0.032039,-0.393247,0.179317,-0.348703,-0.079451,0.158049,-0.084341,0.153719,0.255942,-0.012917,0.518969,-0.277519,0.352150,0.377241) * L4_4 + mat4(0.286614,0.132193,0.243941,-0.275843,0.022475,-0.521110,0.033208,0.291574,0.314460,0.516490,-0.398822,0.501779,-0.089741,-0.757767,0.230672,-0.163187) * L4_5 + mat4(0.115306,-0.607894,-0.284026,0.025610,-0.104915,0.276765,0.021627,0.093216,0.031599,-0.168367,-0.103591,-0.324454,-0.059694,0.079430,0.031788,0.035028) * L4_6 + mat4(-0.117870,0.100572,0.169660,0.195361,0.334409,-0.135475,-0.202868,0.069792,-0.395761,-0.033081,-0.088474,-0.230079,-0.009395,-0.060688,-0.102354,0.232352) * L4_7 + mat4(-0.279594,0.292583,-0.019252,-0.078002,0.394713,-0.429507,0.196115,0.084986,-0.034045,0.023267,-0.331645,-0.209892,0.068098,0.180164,0.430225,0.536631) * L4_8 + mat4(0.070519,-0.203227,-0.368546,-0.006390,-0.147074,0.329472,0.188085,-0.034333,0.015757,-0.128867,0.127217,0.370235,0.298810,-0.131532,-0.036807,0.271964) * L4_9 + mat4(0.023377,-0.213007,0.334154,-0.046360,0.013692,-0.066913,0.172735,0.087719,0.145960,-0.358783,-0.104472,0.527243,-0.098869,-0.006709,-0.214037,-0.221489) * L4_10 + mat4(0.185513,-0.031676,-0.007558,-0.262521,0.439735,-0.692817,0.044521,-0.011147,-0.231488,0.260048,0.025473,-0.404029,-0.154867,-0.315717,-0.368519,0.074113) * L4_11 + mat4(0.100579,0.268461,0.081012,0.362625,-0.163579,-0.330540,-0.116758,0.025254,-0.224029,0.055908,-0.138085,-0.016281,-0.295186,-0.397238,0.248538,-0.505180) * L4_12 + mat4(0.088498,0.369302,-0.133840,-0.249875,0.296561,0.287122,-0.333928,-0.002999,-0.104784,0.168432,-0.116601,0.007872,-0.460646,-0.198586,-0.228982,-0.381123) * L4_13 + mat4(-0.115729,0.831883,-0.295261,0.233833,0.033339,-0.105793,0.155175,0.368096,-0.129175,0.288217,-0.203880,0.200769,0.320185,0.353644,-0.268538,0.071628) * L4_14 + mat4(0.032317,0.379969,0.364032,0.292914,-0.269166,-0.414269,0.042993,0.121509,-0.144851,0.116923,0.031999,0.276350,-0.513988,0.593654,0.211131,0.120379) * L4_15 + vec4(-0.310289,0.190865,0.289763,0.166052)));\nvec4 L5_13 = sin((mat4(-0.164800,0.252205,-0.447655,0.079621,-0.250069,-0.198056,-0.249918,-0.066995,-0.546625,-0.184848,0.098581,-0.049399,-0.083677,0.126881,0.229787,-0.401985) * L4_0 + mat4(-0.199445,0.079795,0.543294,0.033516,0.303051,-0.479736,0.092778,0.156462,-0.329568,0.107026,-0.026294,-0.008428,0.010175,0.394099,0.011727,0.049859) * L4_1 + mat4(0.208337,-0.289389,-0.098620,0.296304,0.086483,-0.112175,0.440626,0.131254,0.281945,-0.391745,0.044091,0.013189,0.350909,-0.416566,0.433605,-0.597948) * L4_2 + mat4(-0.679923,-0.300779,0.259722,-0.053586,0.702099,0.091314,0.313787,-0.000958,0.028124,0.082776,0.060791,0.099340,-0.418516,-0.345297,-0.199911,0.004565) * L4_3 + mat4(0.367262,-0.091787,-0.126720,-0.229204,0.071175,-0.011236,0.287463,-0.019660,0.345886,-0.333081,-0.050611,-0.002021,-0.129647,-0.054064,-0.305050,0.201323) * L4_4 + mat4(0.193573,-0.145730,0.284407,-0.196114,0.163816,0.188826,-0.011140,-0.294564,-0.229171,0.284099,0.396566,-0.305798,-0.248291,0.040077,0.117912,-0.305446) * L4_5 + mat4(0.277351,0.286852,0.182515,0.051793,-0.470611,0.327028,0.141243,-0.092136,-0.236721,0.116225,0.028866,-0.026312,0.063883,0.012803,-0.240101,0.284476) * L4_6 + mat4(-0.100885,0.014582,0.325931,0.030953,0.005949,0.273354,-0.312038,0.294605,-0.248625,0.296739,-0.470449,-0.032080,-0.515870,0.226857,0.152864,-0.023825) * L4_7 + mat4(-0.568080,0.234381,-0.076850,0.273102,-0.289956,-0.055462,0.405246,0.095950,-0.423664,-0.309544,0.280958,0.253272,-0.182546,-0.123680,-0.013134,0.079401) * L4_8 + mat4(0.227257,-0.041634,-0.343224,0.235170,0.360158,-0.493212,-0.275863,-0.261044,-0.511427,-0.200529,0.181228,0.580622,0.277882,0.307708,-0.076945,0.220900) * L4_9 + mat4(0.443408,-0.121070,-0.369888,-0.136402,-0.099749,-0.155198,-0.014903,0.161198,0.544103,-0.132176,-0.274445,-0.033016,-0.436536,0.062315,-0.028904,-0.357164) * L4_10 + mat4(-0.073259,0.145941,-0.206493,0.347701,-0.160353,0.197833,0.038167,0.070529,-0.422211,-0.345830,0.301069,-0.064756,-0.171662,0.267151,-0.057039,0.061733) * L4_11 + mat4(-0.279126,0.193684,-0.093027,-0.200444,0.199024,-0.256549,0.239568,-0.000181,-0.345099,-0.168872,-0.109854,0.074367,0.139916,0.243381,-0.483867,-0.040014) * L4_12 + mat4(-0.215121,0.071452,-0.082324,0.122119,-0.086428,-0.257508,-0.228827,-0.254412,0.295242,0.213550,0.304340,-0.090074,0.419422,-0.397839,-0.261537,0.221034) * L4_13 + mat4(-0.278050,0.131345,-0.244405,0.165635,0.460997,-0.014949,0.049726,0.069929,-0.614302,0.050973,0.078143,0.409936,0.329576,-0.035297,-0.148277,-0.084433) * L4_14 + mat4(-0.199951,0.311594,0.117217,-0.098294,0.273262,-0.353074,0.272160,-0.441196,-0.031854,0.057677,0.285549,-0.329701,0.094620,0.291629,-0.055856,0.044666) * L4_15 + vec4(0.174107,0.445794,-0.208862,0.115647)));\nvec4 L5_14 = sin((mat4(0.130166,0.222035,0.348307,-0.048791,-0.013862,-0.518413,-0.308970,0.007883,0.252171,-0.464589,0.177068,-0.072093,-0.264737,-0.087338,0.596589,-0.176382) * L4_0 + mat4(0.045248,0.410111,-0.557120,-0.426563,0.173503,0.183979,0.217146,-0.107679,-0.212228,-0.391352,-0.270837,-0.107992,0.153497,-0.072055,-0.122181,-0.014510) * L4_1 + mat4(0.389882,0.245865,-0.202651,-0.063746,0.361839,-0.338245,0.420392,-0.098587,0.356126,0.620373,-0.030166,0.175797,0.349878,-0.185859,-0.150635,0.138735) * L4_2 + mat4(-0.452545,-0.222282,0.142516,-0.181619,0.468519,0.259395,0.046328,-0.426592,-0.191254,0.312539,0.116931,0.045361,0.135404,0.547979,-0.537556,0.073410) * L4_3 + mat4(0.314663,-0.094915,-0.113470,-0.254749,0.217812,0.143940,0.404141,-0.194121,0.345975,-0.177211,-0.256594,-0.371543,0.335317,-0.233235,0.264932,-0.229905) * L4_4 + mat4(0.019902,0.337040,0.192254,0.016800,-0.309892,-0.591948,-0.099027,-0.429517,-0.625465,-0.085214,-0.159067,-0.098428,-0.199427,-0.361214,-0.282573,-0.529658) * L4_5 + mat4(-0.288243,-0.030178,0.463359,-0.056317,0.184196,-0.578695,-0.471540,-0.092562,0.272734,0.403784,-0.087370,-0.240103,-0.076501,-0.012966,-0.260084,-0.274677) * L4_6 + mat4(0.003809,-0.565153,-0.171363,-0.158584,-0.788230,0.027164,-0.561367,0.008761,-0.063731,0.257608,-0.023772,0.261669,-0.160117,-0.445232,-0.042453,-0.021182) * L4_7 + mat4(0.237896,0.135159,0.535632,0.056462,-0.305807,0.022194,-0.403510,0.002079,-0.350267,0.343802,0.069768,-0.022128,-0.457098,0.257325,-0.216262,-0.314590) * L4_8 + mat4(-0.016921,0.005775,-0.078740,0.046593,-0.057524,0.195951,-0.123187,-0.510685,-0.000650,0.169967,0.011176,-0.285827,-0.236450,0.170152,-0.437940,-0.169752) * L4_9 + mat4(-0.182807,-0.020060,-0.215212,0.423995,-0.034250,-0.313046,0.189309,-0.236533,0.505857,-0.111893,0.018558,-0.110704,0.186772,-0.099919,-0.190170,0.216687) * L4_10 + mat4(0.520377,-0.234615,0.291585,0.085997,-0.283392,0.146800,-0.073145,0.083013,-0.484236,0.154378,0.041141,0.103805,-0.164393,0.323042,0.204465,0.184020) * L4_11 + mat4(0.215162,-0.109091,-0.050652,0.028102,0.279980,0.198908,-0.213573,-0.026290,-0.086306,-0.151547,-0.048486,-0.010274,0.015652,0.183964,-0.484856,0.104420) * L4_12 + mat4(-0.297288,-0.186334,-0.248995,-0.031919,0.156793,0.005916,-0.033711,-0.415836,0.428143,0.626951,0.278052,0.171452,-0.023360,0.000427,-0.398238,-0.082976) * L4_13 + mat4(0.190677,0.453273,-0.123504,0.467663,-0.153318,-0.117180,0.573915,-0.045047,-0.009693,0.279248,0.065461,-0.223980,-0.086818,-0.046401,0.413114,0.266458) * L4_14 + mat4(-0.555734,-0.162544,0.159226,0.207966,-0.133226,-0.262797,0.507284,0.216235,0.146104,0.566465,-0.213847,0.169379,-0.140582,0.420231,0.163231,-0.228116) * L4_15 + vec4(0.050905,0.259021,0.357811,-0.238069)));\nvec4 L5_15 = sin((mat4(-0.191463,-0.040486,-0.036244,0.201254,0.051880,0.220538,-0.543458,0.188456,0.483194,0.290063,-0.080432,0.097404,0.627167,0.221364,-0.109009,0.185649) * L4_0 + mat4(-0.228841,0.305374,0.403512,0.122807,-0.226405,-0.043642,-0.221732,0.032514,0.097563,0.363795,-0.330842,-0.322090,-0.083243,-0.149605,0.652558,0.062854) * L4_1 + mat4(0.075768,-0.137475,0.402147,-0.130379,-0.071454,0.520019,0.023271,0.417163,-0.532261,0.453879,-0.057099,0.346164,-0.250623,0.250204,-0.040205,0.043678) * L4_2 + mat4(-0.143074,-0.439461,0.321275,0.415412,-0.165471,-0.014912,-0.023889,0.051442,0.149802,0.168886,0.058622,-0.014033,-0.530217,-0.127017,0.034605,0.027262) * L4_3 + mat4(-0.004453,-0.038369,0.168570,-0.320422,-0.137901,0.011676,-0.565697,-0.363724,-0.516589,-0.051279,-0.136748,-0.019672,0.382325,-0.180827,-0.070183,-0.002026) * L4_4 + mat4(-0.366281,0.252746,-0.160180,-0.329723,-0.050241,0.303090,-0.361092,-0.034297,-0.191402,0.129897,0.388705,0.323215,-0.260157,0.403591,0.381109,0.399574) * L4_5 + mat4(-0.295583,0.164960,-0.214805,-0.428566,0.109623,0.086085,0.053584,0.524876,-0.419904,-0.073290,-0.123793,-0.438759,-0.641958,0.351119,-0.498269,0.263237) * L4_6 + mat4(0.040513,0.287514,0.191533,-0.239406,-0.433633,-0.074329,0.210819,0.118298,0.148591,0.191761,-0.374035,-0.482526,-0.262238,-0.080845,0.677545,0.291060) * L4_7 + mat4(0.300335,0.380024,0.262856,-0.506464,0.204598,0.282997,-0.146440,-0.244221,0.049495,0.165208,0.220032,-0.221126,-0.339674,-0.077762,-0.340485,-0.117917) * L4_8 + mat4(-0.378731,-0.144508,0.373234,-0.082173,-0.062055,0.133372,0.562064,0.174793,0.287169,-0.157463,0.022842,-0.701347,0.081868,-0.170547,-0.255011,-0.135907) * L4_9 + mat4(-0.060622,0.077345,-0.188869,0.483661,0.144508,0.085488,0.062089,0.140240,-0.023542,0.117545,0.555838,0.159655,0.227458,-0.012970,-0.255745,-0.236927) * L4_10 + mat4(0.134913,0.038398,0.190642,-0.265782,-0.149061,-0.064384,-0.189513,-0.108838,-0.130641,-0.293586,-0.152985,0.186760,0.124125,-0.280298,0.267720,-0.244746) * L4_11 + mat4(0.325933,0.280152,0.353213,-0.581502,-0.006326,-0.040499,-0.524612,-0.304639,0.253093,0.288754,-0.359877,0.153440,-0.308124,-0.034132,0.253409,0.344690) * L4_12 + mat4(0.030363,0.187303,0.277089,0.374151,0.004759,-0.055952,-0.194071,-0.300224,0.252340,-0.225150,0.019355,-0.165268,-0.635687,0.127262,-0.363022,0.230376) * L4_13 + mat4(0.223501,-0.037543,0.199528,-0.143882,-0.013898,0.035095,0.379329,0.378313,-0.306536,0.232851,-0.074602,-0.107157,0.577024,0.079636,-0.354465,0.343864) * L4_14 + mat4(0.095677,0.084371,-0.048654,0.347278,0.160735,0.325255,0.042878,-0.004842,-0.177468,0.523234,-0.300199,-0.316015,0.133987,-0.238527,-0.195490,0.615589) * L4_15 + vec4(0.349531,0.244727,0.258959,0.150311)));\nvec4 L6_0 = sin((mat4(0.037681,0.495169,0.146493,0.450783,-0.247170,-0.060773,-0.175787,0.200649,0.119464,0.326641,0.231891,-0.086219,0.031691,-0.278869,-0.023571,-0.097091) * L5_0 + mat4(0.110315,0.127666,0.142948,0.387142,0.035642,0.044824,-0.095286,-0.289587,-0.069856,0.356846,0.180697,-0.298853,0.062677,0.163103,0.376200,-0.070956) * L5_1 + mat4(0.444232,0.483015,0.115742,-0.255474,-0.068800,0.134310,-0.146757,-0.201434,-0.579321,-0.281375,0.750823,-0.028105,-0.136143,-0.148977,-0.188785,0.032329) * L5_2 + mat4(-0.105268,-0.031903,-0.457690,-0.216248,-0.332025,-0.545021,0.552448,-0.370749,-0.402367,-0.041172,-0.242435,0.242968,0.171711,0.209556,0.492139,0.287540) * L5_3 + mat4(-0.114478,0.298095,-0.613786,-0.293500,0.304580,-0.074130,0.202325,0.037243,0.064434,-0.140689,0.116197,-0.006212,-0.255276,-0.326095,0.075698,0.460535) * L5_4 + mat4(0.083443,0.114194,-0.419624,0.448715,-0.295096,-0.214397,0.225086,0.218184,-0.105422,0.192431,0.837362,0.097681,0.266315,-0.126299,0.004992,0.435518) * L5_5 + mat4(0.058234,-0.136803,0.224486,0.464306,0.391423,-0.054484,0.120903,0.029262,-0.044731,-0.238205,-0.048733,-0.038500,0.035166,-0.246866,-0.398941,-0.033832) * L5_6 + mat4(0.046052,0.021039,0.735516,0.198175,0.225309,0.445582,-0.199465,0.069940,-0.190771,0.331591,0.456985,-0.098281,0.129892,0.437976,0.450413,0.270841) * L5_7 + mat4(-0.052156,-0.310762,0.101852,0.042409,0.037970,-0.079361,0.367047,-0.115301,0.476945,-0.218824,-0.252506,0.405141,-0.151979,0.008396,-0.435670,0.659274) * L5_8 + mat4(-0.082282,-0.269829,-0.231304,-0.018799,0.068597,-0.307144,-0.191061,0.524808,-0.181817,0.278365,-0.113614,-0.289888,0.086225,-0.052885,0.181682,0.020349) * L5_9 + mat4(0.111873,0.002724,-0.191513,-0.178428,-0.253337,0.035495,0.224130,-0.512344,0.156903,0.102677,0.287458,0.192593,0.500181,0.129069,0.223289,0.046784) * L5_10 + mat4(-0.241803,-0.312739,-0.059699,-0.478442,-0.024634,-0.407846,0.243294,0.361010,-0.069680,0.025703,-0.115565,0.212316,0.125619,-0.091898,-0.434887,-0.394950) * L5_11 + mat4(0.141789,-0.308954,0.659973,-0.264005,-0.003370,0.462385,-0.163254,-0.208529,-0.034511,-0.075692,0.424364,0.252074,-0.127243,0.054989,-0.664915,0.008968) * L5_12 + mat4(-0.058466,-0.024650,-0.295557,0.229582,0.691399,0.007154,0.664500,-0.488270,0.174159,0.476278,-0.443287,-0.214124,-0.195593,0.304876,-0.270987,-0.014792) * L5_13 + mat4(-0.096494,-0.137279,-0.050817,0.480032,-0.122712,-0.006342,-0.452667,-0.542323,-0.188545,-0.229147,0.162620,-0.452909,0.319275,-0.355432,0.330766,0.100139) * L5_14 + mat4(-0.326726,-0.500620,0.209634,0.055174,0.175923,0.126512,0.066652,0.020959,0.028790,0.353431,-0.307557,0.063927,-0.057319,0.051814,0.104050,-0.106468) * L5_15 + vec4(-0.236265,-0.404765,-0.128193,0.473931)));\nvec4 L6_1 = sin((mat4(-0.074775,0.252555,-0.290639,-0.778359,-0.443188,0.227676,0.045946,-0.411994,-0.096652,0.027889,-0.128068,0.803643,-0.071358,-0.197629,-0.473745,0.204849) * L5_0 + mat4(0.177768,0.021673,0.012286,0.103239,-0.000455,-0.023599,0.286788,-0.269021,0.646889,-0.037409,0.177837,-0.132738,-0.161285,-0.195224,0.222254,0.279047) * L5_1 + mat4(-0.294809,0.030537,0.103386,-0.170321,0.218911,-0.125743,-0.208842,0.833856,-0.120930,-0.160613,-0.162445,0.513897,0.103001,0.062864,0.410177,0.227539) * L5_2 + mat4(-0.006596,0.086770,0.284507,0.478599,0.309685,-0.333892,0.454767,-0.776153,-0.172609,0.063582,-0.412199,0.637820,-0.425138,0.276078,-0.185820,-0.004868) * L5_3 + mat4(0.214383,0.070260,-0.280471,-0.343823,0.178057,-0.038454,0.273408,-0.129228,-0.111159,0.174462,-0.056200,-0.462373,0.104240,-0.170852,-0.058143,0.471975) * L5_4 + mat4(-0.111784,-0.234257,-0.255742,0.431557,0.092750,-0.087760,0.149165,-0.318179,-0.265137,0.035382,-0.154964,0.467269,0.188464,0.145145,-0.095619,0.561677) * L5_5 + mat4(-0.022946,0.229042,-0.032145,0.611685,0.221922,0.124882,-0.191846,0.309132,0.247238,0.088272,0.285930,0.335669,-0.087204,-0.165480,-0.041680,-0.686874) * L5_6 + mat4(0.389195,0.326075,0.125555,-0.205098,0.296093,-0.031234,0.291559,0.143004,0.133962,0.121109,0.203265,0.165377,0.169738,0.300096,-0.361931,-0.397367) * L5_7 + mat4(0.298066,-0.159275,-0.350941,0.800162,0.204074,0.140607,0.127340,-0.833475,-0.095809,0.312912,-0.029113,-0.134137,-0.048159,0.229690,-0.284758,0.165196) * L5_8 + mat4(0.511896,-0.182400,0.033273,-0.185037,0.089820,0.065323,0.464349,0.645942,-0.084643,0.110619,0.350570,-0.287219,-0.121210,0.301164,0.008250,-0.263696) * L5_9 + mat4(0.235278,0.040551,-0.001501,0.394120,0.014732,0.137791,-0.126096,-0.436043,-0.055890,-0.102281,0.108257,0.436050,-0.410844,0.175459,-0.260937,-0.059672) * L5_10 + mat4(-0.243060,0.196068,-0.055395,-0.566702,-0.542919,-0.202866,-0.146319,0.543788,0.099936,-0.196129,-0.445376,-0.294436,0.390775,-0.012895,0.161429,-0.047178) * L5_11 + mat4(0.228310,-0.084111,0.383616,-0.162953,-0.341593,-0.260297,0.359312,-0.495595,-0.242313,0.169848,0.245946,-0.044515,-0.308604,-0.352362,-0.171827,0.533358) * L5_12 + mat4(0.365680,0.151998,-0.140929,-0.732185,0.467483,0.328020,-0.313202,-0.256731,0.202637,-0.088223,-0.125034,-0.193187,-0.375721,0.694418,-0.500479,-0.037855) * L5_13 + mat4(0.057364,-0.069032,0.070648,0.165403,-0.113808,0.088907,-0.021714,-0.071416,0.394392,0.006435,-0.354654,-0.372721,0.079327,0.109167,0.074111,0.544002) * L5_14 + mat4(0.014065,0.371093,-0.213646,-0.752687,-0.418076,0.121614,-0.482428,-0.003739,-0.309108,-0.261921,-0.063990,0.388081,0.108294,-0.373320,0.012168,-0.289318) * L5_15 + vec4(-0.128457,0.218624,0.082650,-0.140562)));\nvec4 L6_2 = sin((mat4(0.201927,0.318862,0.095383,-0.105197,0.127950,-0.010420,0.017265,0.010747,0.031598,0.105867,-0.185944,0.193609,0.001656,-0.245288,-0.259274,0.212399) * L5_0 + mat4(-0.070915,-0.251435,-0.089083,-0.029271,-0.127394,-0.430955,0.100577,-0.008622,0.060512,-0.113931,-0.278160,-0.285948,0.053412,0.375282,-0.079215,-0.200238) * L5_1 + mat4(0.245335,0.282929,0.235212,0.064046,-0.121498,-0.163914,0.200942,-0.043718,0.044801,0.227029,-0.292669,0.054054,-0.073596,0.358004,-0.248320,0.069190) * L5_2 + mat4(0.033612,-0.129244,0.044125,-0.155385,-0.033243,-0.206927,-0.157882,-0.070943,0.060466,0.178333,-0.267174,0.108070,-0.012663,0.026709,0.296336,-0.074113) * L5_3 + mat4(0.068469,-0.232323,-0.109778,-0.006018,-0.228569,0.037352,-0.161466,-0.252150,0.075082,0.489894,-0.078920,-0.192785,0.313491,-0.659819,-0.385619,0.138131) * L5_4 + mat4(0.138589,0.428023,0.052769,-0.035536,-0.037804,-0.091806,-0.027022,-0.170372,-0.064093,0.131486,0.020277,-0.262975,-0.027467,-0.009151,-0.122922,-0.088996) * L5_5 + mat4(0.042691,-0.256193,0.356988,-0.072099,0.023359,0.217834,0.462102,0.093908,-0.116903,0.088952,-0.172755,-0.176493,0.262674,-0.138092,0.220554,0.001092) * L5_6 + mat4(0.133127,-0.239548,0.326707,0.054864,0.093330,-0.013586,-0.034990,-0.183805,0.122131,-0.118241,-0.193976,0.039301,0.197357,0.134280,-0.163418,0.222513) * L5_7 + mat4(0.033939,0.030520,-0.522753,-0.081688,-0.122973,-0.285441,0.030385,0.016367,0.238615,0.198922,0.290892,0.014904,0.160413,0.248798,-0.394325,0.071422) * L5_8 + mat4(-0.114604,-0.000529,-0.106752,-0.175218,0.417235,0.374529,-0.059027,0.142832,0.186844,-0.003977,-0.131276,-0.160240,-0.032018,0.365120,0.007001,-0.256355) * L5_9 + mat4(0.090700,-0.121481,0.166210,-0.067326,-0.113066,0.242443,-0.028913,0.102211,-0.174847,-0.167132,-0.059369,-0.060735,0.051337,0.423496,0.439790,-0.037689) * L5_10 + mat4(-0.132072,-0.147629,0.461176,0.282606,0.100265,-0.085250,0.173065,0.189211,0.219556,-0.166340,-0.108468,0.039158,-0.131619,-0.048626,-0.293631,0.121393) * L5_11 + mat4(-0.060508,-0.029595,0.379829,0.032164,-0.087114,-0.062427,0.037635,0.118677,0.037009,0.147146,0.189983,0.228950,0.028332,-0.519032,0.063186,0.050862) * L5_12 + mat4(-0.026715,0.234652,-0.472746,0.041958,0.029413,-0.407585,0.023928,-0.026164,-0.032182,0.222484,-0.118964,0.254513,-0.296917,-0.084879,0.528570,0.049921) * L5_13 + mat4(0.045284,0.295948,-0.006503,-0.116012,-0.106797,0.029886,-0.086329,-0.150226,0.021629,0.113571,0.130343,-0.005022,-0.091976,0.137410,-0.142524,0.382139) * L5_14 + mat4(-0.001911,0.011379,0.116094,0.046382,-0.261986,-0.290663,0.066676,0.055749,-0.139307,0.138834,0.081817,0.209263,0.080743,-0.246448,-0.096772,0.053918) * L5_15 + vec4(-0.160548,0.003270,-0.056678,-0.598379)));\nvec4 L6_3 = sin((mat4(-0.321872,0.556472,0.117890,-0.383732,-0.012977,0.728175,0.154583,-0.108698,0.503917,-0.286620,0.173416,-0.207799,0.003228,0.558321,-0.030756,0.216270) * L5_0 + mat4(0.403708,-0.099400,0.020536,0.103822,0.121570,-0.365872,0.002813,0.123501,0.380366,-0.483748,-0.392269,-0.026421,-0.435192,0.081951,0.428169,0.529490) * L5_1 + mat4(0.636268,0.410500,0.058731,-0.118465,-0.026178,0.039315,0.118792,-0.130397,0.229741,0.416713,-0.086715,0.054604,-0.612627,0.210655,0.115217,0.062646) * L5_2 + mat4(-0.363061,-0.204617,0.053737,0.031576,0.417910,0.365096,-0.247002,-0.031927,-0.589499,-0.117093,0.055950,-0.234168,-0.063036,0.141540,0.140016,0.601028) * L5_3 + mat4(0.573959,-0.580674,-0.130659,-0.468702,-0.106982,0.000025,-0.232850,-0.118425,-0.584412,-0.384301,0.167105,-0.057138,0.162433,0.042779,-0.364498,-0.428002) * L5_4 + mat4(-0.613967,-0.121169,-0.112268,-0.103207,0.267846,-0.214502,-0.002467,-0.534378,0.240872,0.205286,-0.020840,-0.208062,0.758495,-0.483285,0.071173,-0.066813) * L5_5 + mat4(-0.781980,-0.409069,-0.004391,0.303345,-0.281655,0.474416,0.263797,0.125016,-0.374805,0.755692,-0.119606,-0.228741,0.563289,0.254732,0.097315,0.081898) * L5_6 + mat4(0.365215,0.016282,0.002655,0.253856,0.453181,-0.484750,0.370502,-0.034892,-0.022217,0.081756,0.497256,-0.012630,-0.000743,0.587078,0.317475,0.199127) * L5_7 + mat4(-0.679128,0.222102,-0.030816,0.150371,0.140995,-0.156647,-0.210042,-0.114265,-0.407410,-0.380625,-0.130035,-0.245967,0.017412,0.077691,0.058123,0.301893) * L5_8 + mat4(-0.397175,0.219848,-0.518824,0.274348,0.380312,-0.092990,0.052538,0.293319,-0.655005,-0.776066,-0.119900,-0.109672,0.506990,-0.585456,-0.059366,0.085065) * L5_9 + mat4(-0.649536,0.867498,-0.100743,0.297418,-0.258783,0.393649,-0.090420,0.151239,-0.723587,0.016606,0.249487,0.266887,-0.353238,-0.657576,-0.242253,-0.340368) * L5_10 + mat4(-0.124352,0.282055,-0.310702,-0.267103,0.203242,-0.436018,-0.072107,-0.319840,0.709013,0.349274,-0.185099,-0.452768,-0.511309,0.460155,-0.506235,0.016048) * L5_11 + mat4(0.401024,-0.016913,-0.226045,-0.238872,0.275598,-0.525506,0.221265,0.021167,-0.307623,-0.142251,0.400599,-0.304168,-0.027755,0.296604,0.043519,-0.043733) * L5_12 + mat4(0.059674,0.394447,-0.184994,0.322526,-0.074022,-0.188554,-0.058834,0.558730,-0.550622,-0.107299,0.486271,-0.534337,0.514657,0.281727,0.217342,-0.233309) * L5_13 + mat4(-0.669876,0.086313,-0.059224,0.177699,-0.223539,-0.461280,-0.204397,-0.168116,0.504414,0.109149,-0.028903,0.103318,-0.276198,-0.383009,0.307992,0.211115) * L5_14 + mat4(0.056261,-0.051667,0.168401,0.463971,0.646395,0.008827,-0.274890,-0.449143,0.632388,0.924259,-0.015286,-0.138882,0.515202,-0.087122,-0.246742,0.061532) * L5_15 + vec4(-0.368548,0.317763,-0.211410,0.011820)));\nvec4 L6_4 = sin((mat4(0.312120,0.058168,-0.101009,0.457307,0.788324,-0.089517,-0.397901,0.222857,-0.177080,0.119232,-0.173872,0.447789,0.214337,0.274873,-0.013720,-0.181884) * L5_0 + mat4(-0.456503,-0.184231,0.325266,0.210576,-0.308529,0.164648,-0.889421,0.759807,0.436694,-0.679272,-0.084883,-0.840633,0.379896,-0.475017,0.080905,-0.314144) * L5_1 + mat4(0.584505,0.308137,0.308298,-0.821155,-0.061766,0.230641,0.378010,0.118384,0.469912,-0.188524,-0.265937,-0.579514,0.439417,-0.021006,-0.593361,-0.479725) * L5_2 + mat4(0.241962,0.255683,0.377229,-0.528610,-0.517990,-0.273053,0.442254,0.664918,0.026284,-0.253322,0.021140,-0.394915,-0.189647,0.094425,0.021376,-0.637980) * L5_3 + mat4(0.490788,0.175635,-0.077923,-0.486695,-0.037115,0.218414,0.090600,0.591391,-0.651415,-0.295106,-0.695184,0.648336,-0.326206,0.282551,0.605922,0.212090) * L5_4 + mat4(0.049283,-0.019980,-0.176886,-0.134107,-0.023572,-0.051764,0.614102,-0.379967,0.344679,-0.268048,0.102269,-0.249453,0.037291,0.361482,0.880149,-0.647629) * L5_5 + mat4(-0.428410,0.087014,0.430762,0.151635,0.129291,-0.274172,-0.505716,0.321053,0.188633,-0.104315,0.405051,0.125370,-0.096894,0.282503,0.065963,0.153731) * L5_6 + mat4(0.353715,0.280882,-0.597355,0.145462,-0.014578,0.371987,-0.282161,-0.214959,0.590503,0.002055,-0.621977,-0.747968,0.347688,-0.247614,-0.058614,-0.205653) * L5_7 + mat4(0.309592,-0.171444,-0.251702,-0.263869,0.009710,-0.047924,-0.455063,0.556581,-0.103386,-0.027797,0.622470,0.209884,-0.427748,-0.075314,0.437785,-0.532427) * L5_8 + mat4(-0.383959,0.472797,-0.991672,-0.196916,0.011147,-0.254627,0.242052,0.091506,0.400551,-0.064891,-0.132554,-0.753855,0.115468,-0.268533,0.045827,-0.449086) * L5_9 + mat4(-0.465948,0.125012,-0.082525,0.330593,-0.099901,-0.391979,-0.519564,-0.041647,-0.478063,0.239202,-0.349257,0.349605,-0.235411,0.319149,-0.588395,0.100227) * L5_10 + mat4(0.353906,0.204936,0.251730,0.110152,0.008588,-0.171181,-0.555736,0.318796,0.339734,0.473113,-0.298884,0.054794,0.293928,-0.156765,0.492640,0.425088) * L5_11 + mat4(-0.314987,0.030225,-0.255029,0.079337,0.032396,0.014552,0.196592,0.401811,-0.498853,-0.049492,-0.758821,-0.520603,0.357667,-0.147821,-0.212443,-0.236567) * L5_12 + mat4(0.118875,0.361496,0.711465,-0.291203,-0.323310,0.826991,-0.384877,-0.207345,0.612295,-0.128136,-0.672088,0.078321,-0.461063,0.298964,0.425452,0.136367) * L5_13 + mat4(0.074834,0.147517,0.394305,-0.729486,-0.064095,-0.005282,-0.030822,-0.115130,0.756506,-0.538049,0.524264,-0.301086,0.017792,0.081864,-0.566263,-0.236568) * L5_14 + mat4(-0.347504,-0.088684,-0.538885,0.613253,0.248809,-0.204543,0.099276,-0.184980,0.448623,-0.231678,-0.285910,0.243183,0.092544,-0.123950,0.366119,-0.075665) * L5_15 + vec4(-0.582951,-0.200125,0.344579,0.052698)));\nvec4 L6_5 = sin((mat4(0.209645,-0.216988,0.217600,-0.248601,0.005199,-0.481787,-0.286901,-0.320670,-0.033802,-0.223715,-0.164467,-0.148425,-0.087922,0.309362,-0.138117,-0.032867) * L5_0 + mat4(0.007834,0.695858,-0.183742,-0.407678,0.130687,1.123041,0.108587,-1.018570,-0.546612,0.345057,-0.168444,-0.149426,-0.206514,-0.506710,0.134560,0.374073) * L5_1 + mat4(0.508401,-0.498653,-0.362691,-0.085157,-0.330341,0.155332,0.250566,0.355495,0.231652,0.371589,-0.438212,0.033874,0.229126,-0.463194,-0.347136,0.179217) * L5_2 + mat4(0.327108,-0.659885,-0.432422,0.461537,-0.511303,-0.396435,-0.336396,0.080537,0.675321,-0.802614,-0.034421,-0.049804,0.061798,-0.492522,-0.389461,0.148533) * L5_3 + mat4(0.308367,0.035960,0.165983,-0.236334,0.444053,-0.116629,0.036586,0.407112,-0.205458,-0.136029,-0.220088,-0.451822,-0.025810,0.291698,0.286413,-0.002150) * L5_4 + mat4(0.194194,-0.968841,-0.042890,-0.218887,-0.380791,0.047850,0.360651,0.562052,0.131559,0.125568,0.111456,0.681518,0.217883,-0.780619,-0.092700,0.388690) * L5_5 + mat4(0.217050,0.518528,0.145899,-0.114911,-0.176434,-0.016190,0.104537,0.697495,-0.203504,0.752801,0.289698,0.174534,0.195726,0.096033,0.325994,-0.185711) * L5_6 + mat4(0.118956,0.067662,-0.481053,0.166699,-0.016373,0.426708,0.286593,-0.017305,-0.214435,-0.445373,0.154485,-0.043505,0.293871,0.016562,0.433842,0.089841) * L5_7 + mat4(-0.027113,-0.855511,0.231969,0.199279,-0.132602,0.353636,-0.007812,-0.614911,-0.368394,0.713526,-0.406733,0.012710,0.096484,0.165807,-0.071106,0.316062) * L5_8 + mat4(-0.173439,-0.171279,0.191783,-0.319935,-0.214530,0.218756,0.370342,-0.136318,0.657048,-0.247649,-0.213652,0.237875,-0.008228,0.735463,0.103647,-0.157296) * L5_9 + mat4(0.359153,-0.034984,0.538927,-0.130651,0.333721,0.162660,0.042790,-0.079839,0.402949,0.726613,0.177861,-0.005899,-0.360346,-0.237731,0.239401,0.154317) * L5_10 + mat4(0.053948,-0.484307,-0.198639,0.163056,-0.349839,-0.306393,0.282568,0.309358,0.105465,0.492556,-0.232506,0.208577,-0.086200,0.388938,-0.037100,0.068515) * L5_11 + mat4(-0.153029,0.354716,-0.282810,-0.284865,0.431354,0.626062,0.100927,-0.406224,0.293535,0.729026,-0.229486,-0.011759,-0.562695,-0.176360,-0.354742,-0.168997) * L5_12 + mat4(-0.158959,-0.222257,0.248276,-0.258928,0.074406,-0.247692,-0.108098,0.001737,0.237969,-0.372614,0.354872,-0.501334,0.296769,-0.436549,-0.296302,-0.152086) * L5_13 + mat4(-0.500050,-0.441157,0.141034,-0.005085,-0.301035,0.816212,0.179659,-0.479793,0.167530,0.022729,-0.022050,-0.178130,-0.089434,0.032056,0.091013,0.386834) * L5_14 + mat4(-0.232805,-0.350311,-0.058272,-0.315750,-0.022603,-0.502144,0.047013,-0.548242,0.058051,0.052950,-0.203697,0.318000,-0.255260,0.328388,-0.514912,-0.430666) * L5_15 + vec4(0.257834,-0.126320,0.167838,0.011162)));\nvec4 L6_6 = sin((mat4(-0.010629,0.150102,0.648998,0.041433,0.194254,-0.016997,0.357109,-0.070113,-0.068648,0.113622,-0.137974,-0.097983,0.186289,0.049874,0.307529,-0.087956) * L5_0 + mat4(-0.055593,-0.326642,-0.447463,-0.417306,0.052724,0.068428,0.787340,0.352748,0.077524,0.100618,-0.252993,-0.067071,-0.500354,0.034230,-0.474803,-0.118252) * L5_1 + mat4(-0.004692,0.257194,0.406391,-0.243731,-0.116425,0.125828,-0.079142,-0.320379,0.084891,0.052786,-0.696437,-0.608618,-0.042793,0.179438,0.536594,0.451232) * L5_2 + mat4(0.104406,-0.034460,0.148468,-0.407928,-0.066775,0.446831,-0.184186,0.192619,0.203040,-0.351351,0.469017,0.114820,0.282385,0.106991,0.360637,0.229820) * L5_3 + mat4(-0.049946,-0.262472,-0.242651,-0.451444,0.286050,0.435821,-0.529006,-0.145573,-0.112912,0.051496,-0.079781,0.182269,-0.089294,0.305332,0.082991,-0.213823) * L5_4 + mat4(-0.072020,0.359088,-0.203999,0.211636,-0.054749,0.003715,0.285022,0.114953,0.144963,0.579697,-0.409372,-0.320849,-0.060767,-0.247098,0.972731,-0.499914) * L5_5 + mat4(0.199269,-0.289516,0.574464,0.118158,0.093691,-0.098660,-0.658709,-0.550471,-0.284281,-0.290533,-0.262893,-0.216337,0.110755,-0.292191,0.622073,0.135068) * L5_6 + mat4(-0.022012,0.216223,0.043842,-0.120270,0.156964,0.030932,-0.481779,-0.087027,0.280659,0.267195,0.452990,0.190895,-0.221924,-0.462395,-0.162797,-0.066829) * L5_7 + mat4(-0.077575,-0.052570,-0.326649,-0.005922,0.159172,-0.149960,-0.138277,-0.209598,0.084369,-0.074392,0.873326,0.233162,-0.059188,0.351433,0.074214,-0.035327) * L5_8 + mat4(0.038980,-0.109180,-0.044631,-0.252632,0.103383,-0.271054,-0.273652,-0.174187,0.160140,-0.042763,0.067792,0.340841,-0.075446,-0.115662,-0.967616,0.075666) * L5_9 + mat4(0.130633,0.389224,-0.210583,-0.099300,-0.029171,0.233102,-0.613340,-0.055113,0.137042,0.101106,0.156664,0.173155,0.148115,0.243448,-0.374782,-0.199352) * L5_10 + mat4(0.117780,-0.119509,-0.468858,-0.133393,-0.142295,0.233488,-0.358057,-0.306022,-0.080275,0.340190,0.366116,0.241641,-0.034904,0.198183,-0.825976,-0.038928) * L5_11 + mat4(0.132229,0.097754,0.034241,0.043723,0.075344,-0.148902,0.773705,0.191005,-0.144815,0.221724,-0.499995,-0.185038,0.163114,0.343633,-0.394027,-0.096770) * L5_12 + mat4(0.060418,-0.046153,-0.921432,0.031368,0.099194,-0.201828,-0.362678,0.507120,-0.147806,-0.106781,0.317778,-0.039853,-0.287311,0.097418,0.119161,-0.427131) * L5_13 + mat4(-0.051682,-0.010359,-0.684633,0.070896,-0.006457,-0.137785,-0.134196,-0.322582,0.031626,0.445183,-0.317591,0.241057,-0.145290,0.030584,-0.828881,0.268426) * L5_14 + mat4(0.004340,0.143110,0.262135,0.362831,0.188272,0.188658,0.298499,-0.252800,0.098914,0.269168,-0.447877,-0.320353,0.185892,-0.116846,0.726317,-0.319838) * L5_15 + vec4(-0.057489,0.140912,0.132170,-0.159490)));\nvec4 L6_7 = sin((mat4(0.097425,-0.502226,-0.083658,0.001763,-0.180489,0.242203,0.880953,0.268245,0.164613,-0.162426,0.275697,0.422573,0.394228,-0.098821,0.168563,0.028455) * L5_0 + mat4(0.002386,0.451670,0.966959,0.484350,0.014564,0.540247,0.428827,0.469699,-0.105288,-0.353312,-0.571057,0.085552,-0.204643,-0.307787,0.501158,-0.102162) * L5_1 + mat4(-0.296302,0.389662,-0.284809,-0.669246,0.100586,-0.161984,-0.167319,0.064509,-0.136398,0.318579,0.490782,-0.040614,0.069741,0.122292,-0.182578,-0.138255) * L5_2 + mat4(0.199986,-0.332341,0.143052,0.049113,-0.036141,0.011676,0.340637,0.132832,-0.643274,-0.329842,-0.386402,0.120615,-0.449509,0.347135,-0.290220,-0.356938) * L5_3 + mat4(0.140405,-0.095756,-0.778056,-0.509135,0.343940,0.043059,0.701164,0.323837,-0.087059,0.391412,0.110148,0.704614,0.623507,-0.476390,0.293226,0.423609) * L5_4 + mat4(-0.323695,-0.904046,0.497652,0.162320,0.262738,0.002534,0.043116,-0.330799,-0.161899,0.433660,-0.651195,-0.195108,0.238764,-0.417703,-1.017711,0.137657) * L5_5 + mat4(-0.359126,-0.400453,0.638749,-0.294692,0.494912,0.533838,0.452821,-0.929935,0.121798,0.311838,0.581392,-0.458306,-0.210478,0.104810,0.290427,0.747841) * L5_6 + mat4(-0.394516,-0.322493,-0.972208,-0.374874,-0.079258,0.017189,-0.491671,-0.182814,-0.048490,-0.038360,-0.098150,0.510934,0.087299,0.513951,0.497909,-0.290822) * L5_7 + mat4(-0.325908,-0.481036,0.306545,0.083785,-0.271526,0.313393,-1.057732,0.538263,-0.345929,0.097768,-0.318695,-0.284918,0.057154,0.248258,0.071798,0.183092) * L5_8 + mat4(0.369199,0.693129,-0.777605,0.213971,0.545155,-0.214195,0.057802,0.094866,0.331054,0.101223,0.314462,0.149765,0.164915,0.654720,0.573634,0.787164) * L5_9 + mat4(0.001312,0.383678,0.008475,-0.693456,-0.277521,-0.007303,-0.171077,-0.159879,-0.245631,0.158201,0.117127,-0.341276,0.280462,-0.669077,-0.054016,0.462239) * L5_10 + mat4(-0.102833,0.326409,-0.252874,-0.382538,-0.002530,0.275964,-0.585330,-0.388228,0.003369,-0.083016,-0.014270,-0.044323,-0.167491,-0.634067,0.646966,-0.170563) * L5_11 + mat4(-0.224268,0.148125,0.286615,0.111557,-0.018063,0.180234,-0.523020,-0.899160,-0.123473,0.008669,0.002363,-0.281527,-0.239110,-0.303857,-0.564088,-0.438708) * L5_12 + mat4(0.334872,-0.033781,0.392286,0.356425,0.004434,-0.393047,0.052173,0.067806,0.283279,0.175687,0.245618,0.415102,0.129447,0.470378,0.478136,0.405848) * L5_13 + mat4(-0.077586,0.143918,0.709300,0.526531,0.102412,0.273567,0.111766,-0.661012,-0.081019,0.101694,0.021885,0.208999,-0.332553,-0.469260,-0.253278,-0.031905) * L5_14 + mat4(0.020505,0.010654,0.520672,0.085625,-0.008510,-0.434333,0.574856,-0.516353,0.151198,-0.227690,0.327260,-0.758718,-0.315640,0.770633,0.354663,0.105447) * L5_15 + vec4(-0.436451,0.497873,-0.451454,-0.017136)));\nvec4 L6_8 = sin((mat4(0.348713,-0.143165,-0.008802,0.097186,-0.151946,0.004005,-0.022988,-0.009933,-0.135740,-0.223678,0.043035,-0.160350,-0.366482,0.301553,-0.179069,-0.157110) * L5_0 + mat4(0.333809,-0.269812,0.064785,-0.034069,0.146791,-0.056210,0.206206,0.133201,0.493865,0.020380,-0.028891,0.025684,0.000696,-0.022913,0.230438,0.118932) * L5_1 + mat4(-0.106341,0.128302,-0.128121,0.107922,0.184821,-0.042813,0.186890,-0.005759,0.045363,0.320094,-0.162811,-0.217131,-0.079820,0.345670,-0.132808,-0.150793) * L5_2 + mat4(0.184940,0.080278,0.027558,0.029999,0.429652,-0.074741,-0.045073,-0.127671,-0.015527,0.201361,-0.133359,-0.225773,0.066676,-0.225705,-0.141882,0.219403) * L5_3 + mat4(-0.177971,0.197246,-0.214327,0.002136,-0.558328,-0.008473,-0.047304,0.123212,-0.072939,0.044696,-0.438067,-0.134512,-0.433019,0.061277,-0.057984,-0.258560) * L5_4 + mat4(-0.040883,0.352592,-0.031182,-0.185192,0.132062,-0.146625,0.052149,0.069565,-0.190555,0.220656,-0.084893,-0.078233,-0.147269,0.187731,-0.008712,-0.277988) * L5_5 + mat4(0.483132,-0.234146,-0.090148,0.058758,0.013915,-0.135478,0.298523,0.083918,-0.190724,-0.185008,0.115489,-0.170250,-0.115739,0.063513,0.103882,-0.014395) * L5_6 + mat4(-0.100598,-0.224536,0.479395,0.321632,0.161131,-0.147005,0.273283,-0.072437,-0.338603,0.227170,0.003675,-0.102636,0.393750,-0.189045,0.008759,0.126516) * L5_7 + mat4(-0.082925,0.294710,0.051436,0.027959,-0.330838,-0.087869,0.026527,0.093089,0.144269,0.094826,0.163709,0.151205,-0.222681,0.202737,-0.019293,0.054325) * L5_8 + mat4(-0.367261,0.147752,0.011008,-0.118339,0.454150,-0.076718,-0.039393,-0.368508,-0.167737,0.240069,-0.158172,0.027630,0.145206,-0.031321,0.148827,0.056972) * L5_9 + mat4(-0.172973,-0.234077,0.092421,0.051466,-0.090178,0.029357,0.214991,0.007650,0.166218,0.280262,0.351196,0.187409,0.099858,-0.058399,-0.249229,0.201886) * L5_10 + mat4(-0.166677,0.026895,0.062082,0.098411,0.149015,0.004930,0.026723,-0.161990,0.264216,-0.088187,0.112147,-0.157708,-0.182462,-0.040542,-0.170333,0.029118) * L5_11 + mat4(0.108615,-0.231771,-0.143184,0.285226,-0.142832,0.290996,-0.000315,0.009227,-0.336581,0.018522,0.381843,0.285405,-0.008988,0.217431,0.101197,0.291891) * L5_12 + mat4(0.278571,0.004991,-0.249700,-0.055541,-0.303264,0.165780,0.336606,-0.120849,0.155783,0.248541,-0.058134,-0.288583,0.004151,-0.237366,0.424259,0.064355) * L5_13 + mat4(-0.066826,-0.129478,0.187452,-0.028653,0.045771,-0.158152,0.042768,0.023638,-0.316760,-0.031078,-0.144404,-0.049231,-0.079806,0.068918,0.282862,-0.224426) * L5_14 + mat4(0.226906,-0.406098,-0.419213,-0.077425,0.569958,0.250044,0.239796,0.165445,0.257295,0.074491,0.098129,0.161689,0.195792,0.153569,-0.302142,-0.050146) * L5_15 + vec4(-0.261957,0.207641,-0.323432,-0.259665)));\nvec4 L6_9 = sin((mat4(0.162981,0.092627,0.115028,-0.255991,0.224709,0.819359,-0.000587,0.044753,-0.393939,0.047361,-0.467690,0.441611,0.226057,0.284835,-0.004889,-0.181063) * L5_0 + mat4(-0.642085,0.539939,0.277299,-0.198154,0.060095,0.260592,0.420566,0.235027,0.095109,-0.267307,-0.325105,-0.100211,0.121599,-0.052462,-0.262680,-0.014059) * L5_1 + mat4(-0.256207,0.520859,0.156617,-0.147115,0.820079,0.012195,-0.147842,0.072496,0.463986,0.075589,-0.196989,0.216550,0.275446,-0.369182,0.078681,0.327533) * L5_2 + mat4(0.102081,0.161284,0.372712,-0.118317,-0.379078,0.171732,0.088103,-0.292448,0.613495,0.050065,-0.020417,-0.083227,-0.375350,0.434219,-0.212043,-0.057892) * L5_3 + mat4(0.155367,0.389959,0.241960,0.343636,-0.101113,0.214357,-0.134626,-0.007536,-0.232075,0.407176,-0.067980,-0.032821,0.382760,-0.286660,0.061719,0.170494) * L5_4 + mat4(-0.255441,0.179703,-0.016370,-0.161404,0.009977,0.253434,-0.023967,-0.073764,-0.086027,-0.123722,-0.521350,0.138724,0.278830,-0.460370,-0.186879,-0.267919) * L5_5 + mat4(0.319284,-0.176122,-0.154148,0.079174,0.338010,0.032228,0.009374,0.111667,0.427389,0.262788,0.336616,0.037570,-0.258047,-0.208366,0.244424,0.090139) * L5_6 + mat4(-0.024319,-0.618031,-0.022523,0.177836,-0.531620,-0.134170,-0.427680,0.096039,-0.131101,0.352303,-0.578943,-0.206364,-0.139518,0.267338,-0.197223,0.001481) * L5_7 + mat4(0.381263,-0.125684,-0.277211,-0.036530,-0.046982,0.054012,-0.630036,-0.264120,-0.279630,0.100187,-0.083135,0.024568,0.106851,-0.050099,0.207184,-0.014698) * L5_8 + mat4(0.488453,-0.057937,0.235296,-0.074204,0.116036,0.098621,0.562784,-0.117409,-0.026713,-0.173458,-0.226156,-0.181073,0.107295,-0.532645,0.432557,-0.449482) * L5_9 + mat4(-0.281597,0.582142,0.269041,0.372590,0.324188,0.082986,0.341707,-0.227324,-0.163757,0.001773,0.494741,-0.362179,0.124657,0.047885,0.221011,0.155358) * L5_10 + mat4(0.202896,0.357776,0.533474,-0.418321,0.582308,-0.237526,0.312007,-0.085240,0.237776,-0.188322,-0.070197,-0.424078,-0.088247,0.553818,0.327798,-0.195355) * L5_11 + mat4(0.219563,-0.294022,-0.260987,-0.209847,-0.500318,-0.025463,-0.188392,-0.350990,0.021142,-0.308907,0.459038,-0.453228,0.357483,0.113332,0.190512,-0.217830) * L5_12 + mat4(-0.165847,0.142173,-0.001190,-0.276448,-0.667189,-0.259244,-0.062770,-0.108677,-0.248147,0.100019,0.412418,0.077117,-0.358830,0.178195,0.244969,-0.438753) * L5_13 + mat4(0.308713,-0.149160,-0.114479,0.115164,0.240490,0.114421,-0.036055,-0.218930,-0.558530,0.586620,-0.123737,-0.043223,-0.313388,0.070150,-0.338408,-0.192647) * L5_14 + mat4(0.207101,0.380542,0.324990,0.000013,-0.695643,0.091180,0.368251,-0.009190,0.196174,0.269042,-0.104759,0.210473,-0.209802,-0.230763,0.050662,-0.238289) * L5_15 + vec4(0.092138,-0.309049,-0.142558,-0.215350)));\nvec4 L6_10 = sin((mat4(-0.096316,-0.359699,-0.140409,0.207612,0.136152,-0.006020,-0.110316,-0.054222,-0.129648,0.465860,0.027441,0.260105,-0.572279,-0.075877,0.156283,0.026566) * L5_0 + mat4(-0.278007,-0.152099,-0.192239,0.094856,-0.349820,0.170665,0.142107,-0.025952,-0.075643,0.343042,-0.249699,0.019639,0.438262,-0.228432,-0.230154,-0.162179) * L5_1 + mat4(-0.017929,0.323568,-0.158650,0.315354,0.153839,-0.028786,-0.351126,0.080945,-0.137194,-0.186770,-0.034337,0.244658,-0.045779,-0.232483,-0.098554,0.100880) * L5_2 + mat4(0.749703,0.124298,0.372868,-0.206075,0.219109,-0.139032,-0.143892,0.036032,0.100873,0.338631,-0.141009,0.200184,0.221968,-0.395118,0.281316,-0.297253) * L5_3 + mat4(-0.245174,-0.267652,0.161980,-0.170781,-0.030869,0.121836,-0.073801,0.011803,0.060358,0.177004,-0.101039,0.077658,0.506429,-0.192368,-0.193151,-0.609163) * L5_4 + mat4(-0.312635,-0.036665,0.154672,-0.351013,0.037542,-0.120431,-0.156018,-0.111359,0.179265,0.260090,0.068246,0.110714,0.396292,-0.099744,-0.087816,-0.298516) * L5_5 + mat4(-0.370653,-0.250566,0.001134,0.115905,-0.148715,0.090787,-0.034856,0.050175,-0.384860,-0.100423,0.058344,-0.029710,-0.668692,-0.116770,0.118328,0.101064) * L5_6 + mat4(-0.461845,0.049271,0.036830,0.206666,-0.063070,-0.147453,0.319632,-0.203176,-0.103728,-0.488158,-0.117456,0.072004,0.302492,-0.510782,0.143311,0.179310) * L5_7 + mat4(-0.205381,-0.131162,-0.161985,-0.005075,0.502064,0.502426,0.082101,-0.101397,-0.276270,0.006550,-0.162916,0.085476,0.086501,0.116685,-0.065689,-0.107750) * L5_8 + mat4(0.538176,0.320635,-0.044804,0.281373,-0.058361,-0.225532,-0.223912,-0.108799,0.472571,0.228023,-0.009261,0.061643,0.155639,-0.197094,0.493120,-0.144429) * L5_9 + mat4(0.638695,0.447869,0.177621,0.075515,-0.345103,-0.087665,-0.284348,0.015906,-0.210582,-0.105753,-0.032127,0.216581,-0.159812,-0.225419,-0.362267,0.381439) * L5_10 + mat4(0.169876,0.286288,0.256968,0.021003,0.003962,0.035801,-0.323673,0.260176,0.600878,0.454661,0.243014,0.077767,-0.290260,0.012502,-0.322616,0.188552) * L5_11 + mat4(0.041771,-0.132168,-0.128098,0.033149,-0.068035,0.037249,-0.188847,-0.116063,0.083308,0.537532,-0.373078,0.013763,0.500912,0.035351,0.188529,0.184210) * L5_12 + mat4(-0.329568,0.388672,-0.167606,-0.021960,0.206471,-0.121592,-0.139524,0.098755,-0.131771,-0.122838,-0.057676,0.361672,-0.415118,-0.168776,-0.275062,0.034817) * L5_13 + mat4(-0.031443,0.149138,-0.464134,0.105102,0.363278,0.123123,-0.255374,0.115288,-0.123179,0.251540,0.080358,0.154860,0.315937,-0.154226,0.129567,-0.074618) * L5_14 + mat4(-0.045656,-0.159836,0.031370,-0.089028,0.193207,-0.181864,0.146178,0.111670,0.285275,0.272277,-0.224864,0.027853,0.315017,0.307965,-0.268885,0.196737) * L5_15 + vec4(0.091157,0.231040,-0.546712,-0.193084)));\nvec4 L6_11 = sin((mat4(-0.666914,0.203453,0.078050,0.099327,0.043677,-0.175462,0.169053,0.568680,-0.612029,0.029504,-0.022421,-0.465373,0.225287,0.098630,0.028831,-0.073633) * L5_0 + mat4(-0.090279,-0.329617,-0.044842,-0.364957,0.479531,0.332046,0.071272,0.694180,0.311291,-0.086744,-0.055745,0.228694,-0.400344,-0.018763,0.052224,0.039020) * L5_1 + mat4(-0.912020,-0.042773,0.230579,0.095268,-0.524043,-0.042060,-0.201131,-0.134419,0.340439,-0.079862,-0.025509,-0.446794,0.507066,0.192601,0.288625,-0.759154) * L5_2 + mat4(0.251567,-0.163718,-0.158458,0.295644,0.738567,-0.067925,0.164895,-0.261749,-0.145383,0.224536,0.038692,-0.099655,0.326228,0.190950,-0.004115,-0.703349) * L5_3 + mat4(-0.578489,-0.242328,-0.217413,0.065049,0.004778,-0.155925,-0.211091,-0.478752,0.765173,-0.233119,0.202807,-0.113870,0.297713,0.068320,0.464982,-0.319152) * L5_4 + mat4(-0.445848,-0.190964,0.214380,-0.170492,0.498717,-0.359362,-0.012727,0.130514,0.120238,-0.036185,0.559722,-0.288030,0.914246,0.038722,0.054219,0.095710) * L5_5 + mat4(0.008557,-0.221815,-0.110425,-0.332833,-0.544315,-0.012460,-0.395282,-0.299254,0.508163,-0.021853,-0.241751,-0.727307,0.620010,-0.140007,-0.145778,0.102388) * L5_6 + mat4(0.020391,-0.525149,0.102165,0.432583,0.413828,-0.037846,-0.519335,-0.365278,-0.142337,-0.134296,0.052880,-0.432180,-0.216694,0.065751,-0.391025,-0.491914) * L5_7 + mat4(-0.576460,0.019362,-0.201250,-0.092793,0.121368,0.011277,-0.187926,0.775906,-0.512152,0.081909,0.241842,0.552495,-0.348804,0.123244,-0.272246,0.494710) * L5_8 + mat4(0.824765,-0.321766,-0.107572,0.191216,-0.690784,-0.279286,-0.084917,0.260573,0.512456,0.187643,0.076383,-0.038510,0.557086,-0.053993,-0.126983,-0.493818) * L5_9 + mat4(-0.145377,-0.150924,-0.281492,-0.429641,-0.389044,-0.116239,-0.415025,-0.453249,-0.501383,-0.163041,-0.298250,0.150717,-0.236067,0.014980,0.343094,-0.122253) * L5_10 + mat4(-0.029677,0.177243,-0.148040,0.465652,0.238457,-0.369868,-0.059641,-0.274560,-0.006388,0.196449,-0.526873,0.104848,0.777793,0.232074,0.175069,-0.577492) * L5_11 + mat4(-0.322158,-0.052924,-0.088023,0.045687,0.363660,-0.042823,-0.034293,0.270232,-0.176120,0.061799,0.155435,-0.321829,0.296056,0.225717,-0.005632,0.080416) * L5_12 + mat4(-0.828246,0.241807,-0.184931,0.477446,0.344853,-0.119713,-0.133477,0.257654,-0.352246,-0.121978,-0.284426,0.221479,-0.344077,-0.060886,0.002377,-0.445953) * L5_13 + mat4(-0.191480,0.047282,-0.197215,0.123190,0.333085,0.089872,-0.000563,-0.063194,-0.351391,-0.124495,-0.001401,0.344237,-0.255360,-0.141311,0.100268,0.359455) * L5_14 + mat4(-0.305379,0.056833,0.216376,-0.401808,-0.178586,0.038495,0.060039,0.663230,-0.509378,-0.007161,0.192162,0.502570,-1.048730,-0.003735,0.406001,-0.257052) * L5_15 + vec4(-0.129238,-0.257837,-0.343513,-0.025235)));\nvec4 L6_12 = sin((mat4(0.282277,-0.540121,0.260929,0.004530,0.136917,-0.056420,-0.244522,-0.061298,-0.136969,-0.034321,-0.077043,0.057820,0.631359,0.427061,0.376424,-0.006125) * L5_0 + mat4(-0.363400,0.066699,0.146450,-0.030666,0.369730,-0.059472,-0.156932,0.131442,-0.561170,0.191368,-0.423609,-0.129049,-0.309201,0.332670,-0.080066,-0.154872) * L5_1 + mat4(-0.186937,-0.303722,-0.226265,-0.276138,-0.177345,-0.050926,-0.303796,0.084684,0.262392,0.223829,-0.214925,-0.022559,-0.090932,-0.311032,-0.143704,0.094153) * L5_2 + mat4(-0.117016,0.216985,-0.201491,-0.174943,0.555300,0.070642,-0.167253,-0.077656,-0.495456,0.329807,-0.116144,0.106532,-0.123413,-0.286489,0.096158,0.138052) * L5_3 + mat4(-0.299631,-0.099895,-0.361871,-0.205217,-0.018228,0.028207,-0.365849,0.067510,0.413950,0.092357,0.366386,-0.091254,-0.226403,-0.026082,0.022283,-0.065027) * L5_4 + mat4(0.040839,0.003046,-0.102062,-0.022229,0.057645,0.110927,0.126263,-0.032801,0.000287,-0.038755,-0.168440,-0.083017,-0.443479,-0.127768,0.053640,0.106573) * L5_5 + mat4(-0.016253,-0.046950,0.189225,-0.068332,0.021874,-0.355899,-0.127625,-0.062142,0.378013,0.270897,0.289251,0.021759,0.166242,0.037407,-0.006836,-0.203755) * L5_6 + mat4(-0.398163,-0.054936,-0.123237,-0.176468,0.250913,-0.095645,0.208569,0.050523,-0.056404,0.343523,0.133171,-0.141282,-0.275792,-0.226950,-0.496291,-0.164522) * L5_7 + mat4(-0.289678,0.322230,0.015024,-0.041565,-0.024976,-0.022244,0.207111,0.153480,0.066312,-0.236701,-0.182879,-0.230061,0.195945,0.161185,-0.295463,0.050188) * L5_8 + mat4(-0.019681,0.390304,0.099425,-0.113266,-0.013747,0.141624,-0.662184,-0.148080,0.220252,-0.210779,-0.155927,-0.051484,-0.423157,0.157501,-0.071020,-0.050202) * L5_9 + mat4(-0.091012,0.382921,-0.358576,-0.098457,-0.256130,0.149957,0.165422,-0.043015,0.216023,0.255023,-0.056869,0.027853,-0.124487,-0.223459,-0.345662,0.026096) * L5_10 + mat4(0.147854,-0.191420,-0.122771,0.048230,-0.021909,-0.020898,0.160493,-0.152666,-0.090224,-0.284802,0.226633,-0.124793,0.292348,0.153593,-0.487254,0.115010) * L5_11 + mat4(-0.122114,0.392626,0.024395,0.089017,-0.343759,-0.405165,-0.237042,0.109551,0.284342,-0.228669,-0.431339,-0.028390,-0.059892,-0.158742,0.203775,0.105433) * L5_12 + mat4(-0.530399,-0.063675,0.274367,0.088822,-0.437399,0.228413,0.235927,-0.106158,0.042459,-0.169570,-0.166823,-0.158117,-0.290650,0.121836,0.084267,0.151609) * L5_13 + mat4(0.326440,-0.068566,-0.087852,0.005943,0.218152,-0.053728,0.035112,0.085777,0.005051,0.017948,-0.278290,-0.074736,0.264742,-0.237503,0.269245,0.132043) * L5_14 + mat4(-0.314817,-0.073759,0.520148,0.135498,-0.256160,0.195488,-0.281924,0.053470,-0.030975,-0.199135,0.518800,0.081384,0.420473,-0.002713,0.508959,-0.088010) * L5_15 + vec4(-0.187395,0.223523,-0.029425,0.205983)));\nvec4 L6_13 = sin((mat4(0.134197,-0.092852,-0.268558,0.005180,-0.122361,-0.157417,0.201456,-0.026853,0.122422,-0.235391,0.082341,-0.537607,0.283720,0.057434,-0.483395,-0.189765) * L5_0 + mat4(0.182894,-0.089522,0.363856,-0.227666,-0.163915,-0.088025,-0.006696,-0.126118,0.201015,0.223028,0.265177,0.243477,0.156187,0.131175,-0.083110,0.261269) * L5_1 + mat4(-0.037102,0.234038,-0.084892,0.163806,-0.333429,-0.043750,-0.052481,0.183257,-0.285111,0.148701,0.065568,-0.104137,-0.689356,-0.246053,-0.154492,0.179615) * L5_2 + mat4(-0.130526,-0.480890,-0.325909,-0.580420,-0.196819,-0.136240,-0.187093,-0.411144,0.116111,0.047898,0.190639,-0.262745,0.018197,-0.461058,-0.286221,-0.218434) * L5_3 + mat4(-0.276451,-0.042061,-0.089408,-0.320897,0.001537,-0.082408,0.011081,-0.156910,-0.225033,0.371972,0.554145,-0.112252,0.240533,0.393234,-0.475381,-0.038206) * L5_4 + mat4(0.315636,0.414516,-0.156500,-0.374597,0.042771,-0.097528,0.475021,0.149960,-0.250238,0.382070,0.484386,-0.475580,0.213831,-0.132704,-0.180210,-0.199686) * L5_5 + mat4(0.108824,0.125060,0.328704,-0.085988,0.142989,0.117742,0.207946,0.370858,-0.134204,0.224920,-0.279287,0.318545,0.435638,-0.193333,0.319432,0.268635) * L5_6 + mat4(0.066052,0.011857,-0.265927,0.157393,0.163244,0.419491,-0.492471,-0.138589,-0.217017,-0.045543,0.218706,0.090897,-0.288667,-0.257879,-0.061327,-0.474789) * L5_7 + mat4(-0.357358,0.148000,0.053600,-0.352296,0.476641,0.114713,0.036454,-0.157095,-0.207422,-0.132745,0.067292,-0.253259,-0.132332,0.108957,-0.189358,0.049412) * L5_8 + mat4(-0.106158,0.039050,0.328939,-0.295735,-0.162211,-0.161060,0.422619,-0.293510,0.190277,-0.268575,-0.024894,0.162630,-0.265873,0.166305,-0.353736,0.006203) * L5_9 + mat4(-0.158128,-0.064067,-0.290017,0.226631,-0.019233,-0.071842,-0.019560,-0.102533,-0.257833,-0.126399,-0.206880,0.007148,0.472598,0.131477,0.371394,0.307219) * L5_10 + mat4(0.114645,-0.193570,-0.492745,0.309568,0.401464,-0.164069,0.048210,-0.194476,0.143056,-0.174766,-0.167315,-0.284340,0.161555,-0.067013,-0.315039,0.005511) * L5_11 + mat4(0.014356,-0.375535,-0.065186,-0.001033,0.087382,0.278021,0.005249,0.126846,-0.599797,-0.271271,-0.188812,-0.322322,0.025170,-0.219067,0.366585,-0.530869) * L5_12 + mat4(-0.176045,-0.056416,0.150879,-0.088603,-0.293427,-0.204483,-0.097233,0.240346,0.306064,0.026868,-0.171541,0.297576,0.048063,-0.264117,-0.195684,-0.020468) * L5_13 + mat4(0.258567,0.044480,0.392153,0.170439,0.263563,0.147508,0.202426,0.001836,0.482749,0.127479,-0.143859,0.345320,-0.085540,0.242737,0.247626,-0.132757) * L5_14 + mat4(-0.172783,0.023010,0.077603,0.485217,-0.085961,0.210602,0.013387,0.109027,0.057881,0.117880,0.037228,0.098928,0.019874,0.007444,-0.041388,-0.016609) * L5_15 + vec4(0.402747,-0.309372,-0.176434,0.138539)));\nvec4 L6_14 = sin((mat4(-0.223171,0.002069,-0.138545,0.015132,0.040495,-0.249590,0.186641,0.136665,-0.355634,-0.005440,-0.065426,-0.096045,0.181244,0.234692,0.248226,-0.272211) * L5_0 + mat4(-0.164944,0.457977,0.471909,0.086646,-0.133878,0.179322,-0.040191,-0.152720,0.095721,-0.113092,0.009259,-0.109382,-0.057448,-0.470114,-0.516764,-0.108403) * L5_1 + mat4(-0.278369,0.030123,0.277539,-0.212639,-0.026491,0.276477,0.228725,-0.073200,-0.186741,0.179709,-0.107987,0.146366,-0.060032,-0.259155,-0.063460,-0.208752) * L5_2 + mat4(0.255115,-0.013250,-0.355651,0.108634,0.088601,0.038187,0.033991,0.229023,-0.191060,-0.048628,-0.094697,-0.141321,-0.083982,0.144615,-0.182421,0.314022) * L5_3 + mat4(-0.297400,-0.423194,0.017209,0.277750,-0.093983,0.295100,0.283841,0.220170,-0.007996,0.044607,0.318213,-0.459844,0.193186,0.347690,-0.301111,0.052724) * L5_4 + mat4(0.149209,-0.034760,0.702045,-0.024903,0.103017,-0.123325,0.219887,-0.049685,0.060599,-0.582105,0.115124,-0.080444,0.120114,-0.100016,0.383697,-0.059816) * L5_5 + mat4(-0.130109,0.298712,0.566365,0.129100,-0.136047,0.338341,0.167187,-0.039630,0.027522,-0.293491,-0.147493,-0.100010,-0.172658,0.095964,-0.446721,0.476059) * L5_6 + mat4(0.131140,0.026665,-0.149355,-0.224143,0.046948,-0.193666,0.570176,0.260391,-0.276723,-0.410565,-0.036609,0.184780,0.042388,0.011283,0.132999,0.112152) * L5_7 + mat4(0.295597,0.177709,0.103330,-0.354974,-0.080430,0.349589,-0.439947,-0.459814,0.258454,0.001500,-0.229347,0.205481,-0.229793,0.030034,-0.026080,-0.230294) * L5_8 + mat4(-0.076267,0.018238,-0.296836,0.102928,0.502753,0.174136,-0.084897,0.492321,-0.098388,-0.124149,0.406143,0.042839,-0.385988,-0.150936,0.540552,-0.198606) * L5_9 + mat4(-0.491217,0.027558,0.204369,-0.197439,0.098563,0.075542,-0.264757,0.419165,0.263262,-0.073766,0.190990,-0.372539,0.321059,-0.328342,0.217038,-0.136215) * L5_10 + mat4(0.032826,0.070589,-0.576136,-0.155080,0.063202,0.031257,0.149411,0.096907,-0.130905,0.162805,0.090225,0.385102,-0.049141,-0.004993,0.000784,0.023588) * L5_11 + mat4(-0.495040,-0.131153,-0.532558,0.167696,-0.030129,-0.425276,-0.463211,-0.126463,-0.047705,-0.098828,0.130115,0.257400,-0.405731,0.012065,0.207743,0.266960) * L5_12 + mat4(0.040815,0.152908,-0.247234,-0.165752,-0.250136,-0.002769,0.088719,-0.149136,-0.486505,-0.328016,0.369284,-0.117880,0.204189,-0.378615,0.159539,0.361345) * L5_13 + mat4(0.139993,-0.018449,-0.471049,-0.294111,-0.160446,0.183107,0.103157,0.090561,0.196208,-0.302555,-0.081301,-0.112871,-0.263626,-0.434243,0.172583,0.278392) * L5_14 + mat4(0.189646,0.040611,0.140629,-0.211319,-0.235365,-0.030093,-0.257821,-0.027179,-0.139843,0.109398,-0.104900,-0.123614,-0.085677,0.364881,-0.147683,0.056881) * L5_15 + vec4(0.333160,0.138778,-0.122421,0.182916)));\nvec4 L6_15 = sin((mat4(-0.219388,0.126680,-0.016127,0.265315,0.109194,-0.161066,0.310581,0.089565,-0.082424,0.011133,-0.172724,0.164931,0.209333,-0.550396,-0.034923,0.014613) * L5_0 + mat4(0.003168,0.297976,0.114760,0.079644,-0.029139,0.179091,0.053211,0.011732,-0.008995,-0.047172,-0.611894,-0.041235,-0.148972,0.330441,-0.052374,0.030493) * L5_1 + mat4(0.010983,-0.014176,0.265929,-0.172971,-0.128343,0.071363,-0.160228,-0.488854,-0.106003,-0.104941,-0.174096,-0.056444,-0.086145,-0.237981,-0.437309,0.228580) * L5_2 + mat4(0.079762,-0.339591,0.106250,0.024414,0.086863,0.050055,-0.057753,-0.089474,0.106592,-0.036428,0.220963,0.137100,0.287904,-0.096256,0.056734,-0.264940) * L5_3 + mat4(0.240725,-0.285862,-0.088366,-0.099959,0.237952,0.234778,0.577881,-0.050680,-0.182926,0.072204,0.200054,0.157183,0.278279,-0.082902,-0.082882,-0.009867) * L5_4 + mat4(-0.035437,-0.051723,0.464521,-0.172905,-0.187957,0.150188,-0.044324,0.117278,-0.178147,0.002401,-0.239152,0.368084,-0.022922,-0.099743,-0.026515,-0.289189) * L5_5 + mat4(0.004726,0.110213,-0.408116,-0.279311,0.437830,0.293414,-0.223568,-0.474402,-0.262587,0.100955,0.166695,0.442183,-0.288657,0.024060,0.308789,-0.063683) * L5_6 + mat4(-0.214564,0.428371,-0.166965,-0.200089,-0.331489,-0.084065,0.256881,-0.095222,0.035174,-0.245510,0.179081,0.397540,-0.171716,-0.083318,0.620410,-0.177361) * L5_7 + mat4(-0.108011,0.080392,0.017347,0.205108,0.023163,0.033433,-0.136993,0.192454,0.048093,0.138781,-0.029781,0.120280,-0.095631,0.368560,0.129678,0.055118) * L5_8 + mat4(-0.086838,0.016100,-0.027858,-0.232464,0.026548,0.206877,-0.010519,-0.276799,0.043197,0.201303,0.052223,0.281628,-0.148349,0.189403,-0.032130,-0.129685) * L5_9 + mat4(0.051381,-0.110750,-0.151888,-0.047250,0.104588,0.188340,-0.081680,-0.435190,-0.024457,0.287614,-0.239812,-0.239879,0.025649,0.528978,-0.259103,0.432650) * L5_10 + mat4(0.145798,-0.288515,-0.122137,-0.216712,-0.060064,-0.076921,0.451022,0.250445,-0.072490,0.012694,-0.005287,-0.008509,0.034895,-0.242330,0.263823,0.145460) * L5_11 + mat4(-0.044280,-0.392836,0.225435,0.333629,0.038925,0.105765,0.384084,-0.045406,-0.095711,0.155875,-0.028097,-0.540133,0.125591,0.431318,0.047010,0.363733) * L5_12 + mat4(0.126534,-0.175713,-0.073245,0.145547,0.082359,0.236613,-0.425648,-0.581465,0.242780,-0.091761,-0.227704,-0.089148,-0.085225,-0.184385,-0.024458,0.010962) * L5_13 + mat4(-0.135376,-0.077743,-0.173115,-0.052416,-0.195528,0.080414,-0.469133,0.134269,0.097543,-0.031515,0.444171,-0.224299,0.208347,0.206927,-0.059191,-0.131081) * L5_14 + mat4(0.147786,-0.168746,-0.371862,-0.000861,0.062879,0.208885,-0.648814,-0.146212,0.287523,0.036770,-0.080722,-0.060879,0.054326,-0.219351,0.121082,0.071314) * L5_15 + vec4(-0.220959,-0.075107,-0.058707,-0.177685)));\nvec3 output_0 = (mat4x3(-0.126105,0.066528,0.091632,-0.098742,-0.101952,-0.131373,0.074573,0.097459,0.106294,-0.161531,-0.037439,-0.017965) * L6_0 + mat4x3(-0.167401,0.022281,0.016032,0.163700,0.002656,-0.056111,0.011638,0.122891,0.099364,-0.246790,-0.144134,-0.135703) * L6_1 + mat4x3(-0.063412,0.209850,-0.125049,0.051502,-0.119544,-0.100094,-0.118223,-0.181638,-0.171994,0.024444,-0.128676,0.089789) * L6_2 + mat4x3(0.234667,0.128813,0.125540,-0.151520,-0.097483,-0.092464,-0.030279,0.160148,0.147882,0.040515,-0.078453,-0.029061) * L6_3 + mat4x3(-0.098103,-0.094468,-0.082670,0.112925,-0.057812,-0.056507,-0.090854,-0.048008,-0.037174,0.199159,0.099498,0.088191) * L6_4 + mat4x3(-0.077103,0.055435,0.069864,0.217711,0.109873,0.098937,-0.033444,0.094270,0.088361,0.159792,0.099322,0.110185) * L6_5 + mat4x3(-0.048145,-0.080632,0.120235,0.205432,0.126837,0.111927,-0.246978,-0.132028,-0.131891,-0.129365,-0.153686,-0.145745) * L6_6 + mat4x3(-0.103650,-0.085631,-0.039456,-0.103692,-0.051164,-0.032736,-0.213605,-0.104751,-0.100974,-0.145075,-0.069527,-0.072353) * L6_7 + mat4x3(0.104355,-0.086520,-0.078255,0.008140,-0.162219,-0.212278,-0.117496,0.105899,-0.009945,0.197737,0.227913,0.083215) * L6_8 + mat4x3(-0.116485,-0.090406,-0.103784,-0.177967,-0.093836,-0.088574,0.188892,0.084853,0.067075,-0.006067,-0.120928,-0.102455) * L6_9 + mat4x3(-0.180697,-0.078101,-0.064984,-0.005694,0.110250,0.128233,-0.117956,0.138502,0.121188,-0.089076,0.119720,-0.040267) * L6_10 + mat4x3(-0.174882,-0.087054,-0.084724,-0.017888,-0.111916,-0.005447,-0.147714,0.082881,0.100404,0.170201,0.100333,0.095550) * L6_11 + mat4x3(-0.083757,-0.059260,-0.076861,-0.034678,-0.186563,-0.166984,-0.112884,0.071242,0.051817,-0.030493,0.207517,-0.230251) * L6_12 + mat4x3(0.224156,-0.002422,0.011369,-0.194662,0.045498,0.072184,0.134813,0.126932,0.093658,0.142177,0.080354,0.077933) * L6_13 + mat4x3(-0.076839,0.114310,0.108467,0.003190,-0.091686,-0.137725,0.092635,0.096922,0.104331,-0.073666,0.112757,0.131295) * L6_14 + mat4x3(-0.075422,0.165301,-0.027359,0.052783,-0.102888,0.007384,0.180271,0.088720,0.045126,0.059229,-0.114447,-0.086904) * L6_15 + vec3(0.851218,0.027786,0.053589));\noutput_0 = tanh(output_0);\nreturn output_0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(1.0-uv.y,uv.x);\n    vec3 QiqiWave = ColorField(uv);\n    vec3 col = QiqiWave.zyx;//\n    col = clamp(col*0.5+0.5,0.0,1.0);\n    col = pow(col,vec3(1.0/2.0));\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(pow(col,vec3(2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2yzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 72, 72, 268290], [268292, 268292, 268349, 268349, 268639]], "test": "untested"}
{"id": "NtByRK", "name": "Subdivision Thing 895934", "author": "SnoopethDuckDuck", "description": "im not sure if this looks really bad or really good", "tags": ["e"], "likes": 12, "viewed": 299, "published": 3, "date": "1649899491", "time_retrieved": "2024-07-30T16:54:03.483125", "image_code": "float bum(float sc, vec2 ipos) {\n    return 0.5 * mod(pi * (ipos.y * cos(sc * ipos.x) \n                         + ipos.x * cos(sc * ipos.y)), 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;   \n    uv += vec2(30., 10.);\n\n    float sc = pi;\n    \n    float si = 0.1 * uv.x;\n    vec2 ipos;\n    \n    float b = 1.;\n    float n = 10.;\n    for (float i = 0.; i < n; i++) {\n        float io = 2. * pi * i / n;\n        uv *= 1. + 0.009 * cos(io + 0.1 * iTime + 4. * pi * b);\n       // uv *= Rot(1. * b * pi);\n        ipos = floor(si * uv);\n        b = mix(b, bum(sc, ipos), 0.5);\n    }\n             \n    vec3 e = vec3(0.5);\n    vec3 col = vec3(b);\n    col = (0.5 + 0.5 * cos(200. * pi * b)) - pal(5. * pow(4. * b * (1.-b),2.), e, e, e, 0.5 * vec3(0,1,2)/3.); \n    col = sqrt(0.4 - col) + 0.1;\n    col = mix(col, abs(b-col), h21(ipos));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtByRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 148], [150, 150, 207, 207, 942]], "test": "untested"}
{"id": "sl2czy", "name": "carrito", "author": "jorge2017a2", "description": "carrito", "tags": ["car", "carrito"], "likes": 6, "viewed": 195, "published": 3, "date": "1649898789", "time_retrieved": "2024-07-30T16:54:04.692891", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 90.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n\n\n\n\n//----carrito--13-abril-2022\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n//iq\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n\nvec2 Monito01(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float d0Cabeza= sdBox(p-vec3(0.025,1.1,0.0), vec3(0.3,0.25,0.125) );\n    p.x=abs(p.x)-0.08;\n    float d0Ojo= sdBox(p-vec3(0.02,1.2,0.0), vec3(0.08,0.05,0.125) );\n    p=p0;\n    float d1cuerpo= sdBox(p, vec3(0.5,0.8,0.125) );\n    p.x=abs(p.x)-0.6;\n    float d1brazo= sdBox(p, vec3(0.15,0.7,0.125) );\n    res =opU2(res, vec2(d1cuerpo,1.0));\n    res =opU2(res, vec2(d1brazo,2.0));\n    res =opU2(res, vec2(d0Cabeza,1.0));\n    res =opU2(res, vec2(d0Ojo,0.0));\n    return res;\n}\n\nvec2 Conof00(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float h=30.0;\n    float r1=30.0;\n    float r2=10.0;\n    float d1= sdCappedCone(p, h,r1, r2 );\n    h=12.5; r1=30.0; r2=20.0;\n    float d2= sdCappedCone(p, h,r1, r2 );\n    float t=iTime;\n    float ang=radians(mod(t*20.0,360.));\n    p.xz*=Rot(ang);\n    float d3a= sdBox( p-vec3(0.0,13.5,-18.5), vec3(2.0,0.5,2.0) ); //carro 1\n    float d3b= sdBox( p-vec3(0.0,13.5,18.5), vec3(2.0,0.5,2.0) );  //carro 2\n    float d4a= sdCylinderXY(p-vec3(-1.0,13.0,-18.5), vec2(0.5,2.0) );\n    float d4b= sdCylinderXY(p-vec3( 1.0,13.0,-18.5), vec2(0.5,2.0) );\n    float d5a= sdCylinderXY(p-vec3(-1.0,13.0,18.5), vec2(0.5,2.2) );\n    float d5b= sdCylinderXY(p-vec3( 1.0,13.0,18.5), vec2(0.5,2.2) );\n    float  d6=sdTunnel(p0.xy-vec2(0.0,16.0), vec2(2.5,4.0) );\n    d1=Difference(d1, d6);\n    \n    vec2 re2= Monito01( p-vec3(0.0,15.0,19.0));\n    vec2 re3= Monito01( p-vec3(0.0,15.,-19.0));\n    res =opU2(res, vec2(d1,101.0));\n    res =opU2(res, vec2(d2,100.0));\n    res =opU2(res, vec2(d3a,2.0));\n    res =opU2(res, vec2(d3b,3.0));\n    res =opU2(res, vec2(d4a,4.0));\n    res =opU2(res, vec2(d4b,4.0));\n    res =opU2(res, vec2(d5a,4.0));\n    res =opU2(res, vec2(d5b,4.0));\n    res =opU2(res, re2);\n    res =opU2(res, re3);\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,100.0));\n    p.y=p.y-5.0;    \n    p.x= opRep1D(p.x, 50.0);\n    p.z= opRep1D(p.z, 50.0);\n    vec2 re1= Conof00(p);\n    res =opU2(res, re1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 ) { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 render_sky_color(vec3 rd)\n{ float t = (rd.x + 1.0) / 2.0;\n  vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n  return   mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{ vec3 colobj; \n  if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        float t=3.5*sin(iTime);\n        if(t>0.0)\n           col.xyz=vec3((col.x+col.y+col.z)/3.0);\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd, vec3 posp)\n{\n    float t=iTime;\n   float r=27.0+3.0*(sin(t*0.5));\n   float veltime=10.0;  \n    float tt = radians( -t*veltime);\n    vec3  pos=posp;\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    float t1=iTime;\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 40.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n    \n   vec3 ro=vec3(0.0,15.0+5.0,-30.0+5.0*cos(t1));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   Ray ray= RotarEnCirculo(ro,rd,-vec3(ro.x, 0.0, ro.z));\n    ro=ray.ro;\n    rd=ray.rd;\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1)   //4\n\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i]; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2czy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 580, 580, 664], [665, 665, 704, 704, 799], [800, 800, 839, 839, 934], [935, 935, 974, 974, 1069], [1071, 1071, 1115, 1115, 1142], [1143, 1143, 1183, 1183, 1210], [1211, 1211, 1256, 1256, 1284], [1285, 1323, 1359, 1359, 1404], [1406, 1406, 1440, 1440, 1536], [1537, 1537, 1571, 1571, 1662], [1664, 1664, 1698, 1698, 1789], [1791, 1791, 1816, 1816, 1835], [1836, 1836, 1861, 1861, 1880], [1881, 1881, 1917, 1917, 1945], [1949, 1949, 2008, 2008, 2321], [2323, 2328, 2369, 2369, 2638], [2641, 2641, 2664, 2664, 3182], [3184, 3184, 3206, 3206, 4470], [4472, 4472, 4497, 4497, 4772], [4774, 4774, 4798, 4798, 4960], [4962, 4962, 5010, 5010, 5289], [5292, 5292, 5336, 5336, 5657], [5659, 5659, 5696, 5696, 5953], [5955, 5955, 6045, 6045, 7004], [7006, 7006, 7055, 7055, 7184], [7186, 7186, 7218, 7218, 7393], [7395, 7395, 7465, 7465, 7633], [7635, 7635, 7662, 7662, 7751], [7753, 7753, 7811, 7811, 7859], [7861, 7861, 7884, 7884, 7996], [7998, 7998, 8029, 8029, 8749], [8751, 8751, 8799, 8799, 9087], [9089, 9089, 9146, 9146, 9712]], "test": "untested"}
{"id": "stSczy", "name": "Crystal Computer III AA version", "author": "byt3_m3chanic", "description": "Crystal Computer III AA version - Thank you @tdhooper for help on eeking out perf and adding AA/Blur. ", "tags": ["raymarching", "retro", "refraction", "glass", "computer", "design", "drive", "tape"], "likes": 5, "viewed": 212, "published": 3, "date": "1649893771", "time_retrieved": "2024-07-30T16:54:05.552592", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    4/13/22 @byt3_m3chanic \n    Crystal Computers III\n\n    Thank you @tdhooper - AA/Motion Blur goodness from @iq \n    Re-visit of my last shader with some AA options. I also tried\n    to eek out some performance and precal some vars and vecs\n    \n    (previous version https://www.shadertoy.com/view/Ns3XR4)\n\n    IF SLOW COMMENT OUT #define AA BELOW\n*/\n\n#define R iResolution\n#define M iMouse\n#define T time\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\nfloat time;\n\nmat2 rot (float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nfloat lsp(float begin, float end, float t) {return clamp((t-begin)/(end-begin),0.,1.);}\nfloat eoc(float t) {return (t=t-1.)*t*t+1.;}\n\n// http://mercury.sexy/hg_sdf/\n    const float angle = 2.*PI/3.;\nfloat modPolar(inout vec2 p) {\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (3./2.)) ? abs(c) : c;\n} \n\n// The Folds\nvoid tet(inout vec4 p) {\n\tp = abs(p);\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n}\n\n//@iq thanks for the sdf's!\nfloat cap( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat sdbox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.))+min(max(p.x,max(q.y,q.z)),0.),\n      length(max(vec3(q.x,p.y,q.z),0.))+min(max(q.x,max(p.y,q.z)),0.)),\n      length(max(vec3(q.x,q.y,p.z),0.))+min(max(q.x,max(q.y,p.z)),0.));\n}\n\n//globals\nmat2 tprot,rx,ry,mmt1,mmt2,mmt3;\nfloat tmod,ga1,ga2,ga3,ga4,tt;\nfloat ttx,tta;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n\n    p.xz*=ry;\n    vec4 P = vec4(p.xyz,1.);\n    tet(P);\n\n    vec3 q = P.xyz; \n    q-=vec3(.5,1.5,.5);\n    \n    q.yz*=mmt1;\n    q.x=abs(q.x)-ttx;\n    q.zx*=mmt2;\n    q.z=abs(q.z)-tta;\n    q.yx*=mmt3;\n\n    float mainbox = sdbox(q-vec3(0,1.1,0),vec3(1.5,3,.75));\n    float cutbox =  sdbox(q-vec3(.45,1.25,.775),vec3(.85,2.5,1.1));\n    mainbox = max(mainbox, -cutbox);\n\n    float frame2 = sdframe(q-vec3(0,1.1,0),vec3(1.6,3.1,.82),.075)-.0125;\n    if(frame2<res.x) res = vec2(frame2,4.);\n    float frame = sdbox(q-vec3(-.3,1.3,.7),vec3(.445,1.35,.05));\n    float tapeB = cap(vec3(q.y,q.z,abs(q.x))-vec3(2.8,.55,.65),.225,.1);\n    tapeB = min(  cap(vec3(q.y,q.z,abs(q.x))-vec3(1.95,.5,.65),.100,.1),tapeB);\n\n    vec3 tq1 = q.yzx-vec3(2.9,.25,.55);\n    tq1.x=abs(abs(tq1.x+1.65)-1.2)-.6;\n    frame = min(cap(tq1+vec3(0,.35,0),.25,.5),frame);\n    vec3 pq1 = tq1;\n    pq1.xz *= tprot;\n\n    modPolar(pq1.xz);\n    float tcbx = sdbox(pq1-vec3(.4,0,0),vec3(.09,.09,.075));\n    \n    float tape1 = cap(tq1,.575,.05);\n    tape1=max(tape1,-tcbx);\n    if(tape1<res.x) res = vec2(tape1,3.);\n\n    vec3 bq = q-vec3(-.9,3,.65);\n    bq.y=abs(abs(abs(bq.y)-.4)-.2)-.1;\n    bq.x=abs(bq.x)-.2;\n    float btn1 = sdbox(bq,vec3(.15,.05,.25))-.0125;\n    btn1 = min(sdbox(q-vec3(-.5,1.25,.85),vec3(.45,.3,.06))-.0125,btn1);\n    if(btn1<res.x) res = vec2(btn1,2.);\n    \n    mainbox = min(mainbox, frame);\n    if(mainbox<res.x) res = vec2(mainbox,1.);\n\n    res.x/=P.w;\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist) {\n    t*=mindist;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n) \n{\n    \n    n = normal(p,d,1.);\n    vec3 lpos =  vec3(5.,10,8.);\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),0.,1.);\n\n    vec3 h = vec3(.3);\n    \n    if(m==1.) {\n        vec3 h2 =mix(vec3(.05),vec3(.4),clamp((p.y+1.)*.25,0.,1.));\n        h=mix(h2,vec3(.1),clamp((p.z+4.)*.1,0.,1.));\n    }\n\n    if(m==2.) {\n        vec3 h2=mix(vec3(.596,.110,.690),vec3(.961,.000,.094),clamp((p.x+2.)*.07,0.,1.));\n        h=mix(vec3(.600,0.525,0.039),h2,clamp((p.z+2.)*.07,0.,1.));\n    }\n    if(m==3.) {\n        vec3 h2 =mix(vec3(.000,.639,.514),vec3(.698,.608,.165),clamp((p.x+4.)*.1,0.,1.));\n        h=mix(h2,vec3(.871,.169,.847),clamp((p.y+3.)*.1,0.,1.));\n    }\n    if(m==4.) {\n        vec3 h2 =mix(vec3(.5),vec3(.1),clamp((p.y+1.)*.25,0.,1.));\n        h=mix(h2,vec3(.01),clamp((p.z+4.)*.1,0.,1.));\n    }\n    return diff*h;\n}\n\n// AA Setting\n#define AA 2\n\nvec3 renderFull( vec2 uv )\n{\n\n    float alpha = 1.;\n    vec3 C = vec3(.00);\n    \n    // precal\n    float time = T;\n    tprot=rot(T*2.);\n    tmod = mod(time,24.);\n    float t1 = lsp(1.,5.,tmod);\n    float t2 = lsp(8.,10.,tmod);\n    float t3 = lsp(4.,7.,tmod);\n    float t4 = lsp(14.,22.,tmod);\n    float t6 = lsp(8.,10.,tmod);\n    float t7 = lsp(3.,12.,tmod);\n\n    ga1 = eoc(t1-t2);ga1 = ga1*ga1*ga1;\n    ga2 = eoc(t3-t4);ga2 = ga2*ga2*ga2;  \n    ga3 = eoc(t3-t6);ga3 = ga3*ga3*ga3;  \n    ga4 = eoc(t7-t4);ga4 = ga4*ga4*ga4;\n\n    tt = time*.137;\n    mmt1=rot(ga1*PI-tt);\n    mmt2=rot((ga1+ga2)*PI);\n    mmt3=rot(ga3*PI+tt);\n\n    ttx=(2.5+(2.5*ga3)+ga4);\n    tta=(1.25+(2.*ga1));\n\n    //perspective camera \n    vec3 ro = vec3(0,0,25);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    rx =rot(.78);\n    ry =rot(T*.12);\n    ro.yz *= rx; \n    rd.yz *= rx; \n\n    vec3  p = ro + rd;\n    float atten = 1.;\n    float k = 1.;\n    float d = 0.;\n    float iv = 1.;\n    int bounce = 0;\n\n    #ifdef AA\n        int steps = 75;\n        int thresh = 3;\n    #else\n        int steps = 185;\n        int thresh = 5;\n    #endif\n\n    for(int i=0;i<steps;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<32 ? ray.x*.4 : ray.x;\n        p += rd * d *k;\n\n        if (d*d < 1e-8) {\n\n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n\n            alpha *= d;\n            atten *= .58;\n            p += rd*.025;\n\n            k = sign(map(p).x);\n\n            if(m== 3.) {\n                rd=reflect(-rd,n);\n            } else {\n                vec3 rf=refract(rd,n,iv > 0. ? .85 : .1);\n                iv *= -1.;\n                if(length(rf) == 0.) rf = reflect(rd,n);\n                rd=rf;\n            }\n            p+=-n*.1;\n            bounce += 1;\n        } \n\n        if (bounce > thresh) { break; }\n\n        if(distance(p,rd)>125.) { break; }\n    }\n\n    // draw art\n    float px = 1./R.x;\n    float d1 = length(uv)-.4;\n    d1=abs(abs(abs(d1)-.05)-.025)-.01;\n    d1=smoothstep(px,-px,d1);\n    C = mix(C,C+hash21(uv)*.1,min(d1,alpha));\n    \n    return vec3(C);\n}\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n\n    vec3 col = vec3(.00); \n    // to make thigns fun faster and being\n    // clipping the center\n    vec2 dv = (2.*fragCoord.xy-R.xy)/max(R.x,R.y);\n    if(dv.x<.65&&dv.x>-.65)\n    {\n\n    float mTime = iTime;\n    \n    //mTime = .38;\n    time = mTime;    \n    \n    vec2 o = vec2(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    // set AA above renderFull\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    \ttime = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\t\t\n        //time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.x;\n    \tcol += renderFull(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    }\n\n    float px = 1./R.x;\n    \n    float d1 = sdbox(dv+vec2(-.95,.515),vec2(.015))-.005;\n    d1=smoothstep(px,-px,d1);\n    col=mix(col,vec3(.000,.639,.514),d1);\n    \n    d1 = sdbox(dv+vec2(-.90,.515),vec2(.015))-.005;\n    d1=smoothstep(px,-px,d1);\n    col=mix(col,vec3(.698,.608,.165),d1);\n    \n    d1 = sdbox(dv+vec2(-.85,.515),vec2(.015))-.005;\n    d1=smoothstep(px,-px,d1);\n    col=mix(col,vec3(.871,.169,.847),d1);\n    \n    d1 = sdbox(dv-vec2(-.95,.515),vec2(.015))-.005;\n    d1 = min(sdbox(dv-vec2(-.90,.515),vec2(.015))-.005,d1);\n    d1 = min(sdbox(dv-vec2(-.85,.515),vec2(.015))-.005,d1);\n    \n    d1 = abs(d1)-.002;\n    d1=smoothstep(px,-px,d1);\n    col=mix(col,vec3(.12),d1);\n    \n    if(col.r<.01&&col.g<.01&&col.b<.01) col = hash21(dv)>.5 ? col+.0065 : col;    \n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSczy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[574, 574, 594, 594, 637], [638, 638, 662, 662, 717], [718, 718, 762, 762, 805], [806, 806, 826, 826, 850], [917, 917, 947, 947, 1138], [1141, 1154, 1178, 1178, 1357], [1359, 1387, 1426, 1426, 1531], [1532, 1532, 1563, 1563, 1648], [1649, 1649, 1685, 1685, 1763], [1765, 1765, 1807, 1807, 2081], [2173, 2173, 2191, 2191, 3674], [3676, 3676, 3721, 3721, 3913], [3915, 3915, 3987, 3987, 4813], [4843, 4843, 4871, 4871, 6927], [6929, 6929, 6949, 6949, 6973]], "test": "untested"}
{"id": "ssBfz3", "name": "Infrastructure", "author": "R3N", "description": "A raymarching scene with a simple greeble technique to add details to surfaces, although there's still some artifacts and aliasing issues resulting from this technique.", "tags": ["procedural", "3d", "architecture", "greeble"], "likes": 24, "viewed": 456, "published": 3, "date": "1649884041", "time_retrieved": "2024-07-30T16:54:06.463158", "image_code": "#define MAX_STEPS 100.0\n#define MIN_DIST 0.001\n#define MAX_DIST 75.0\n#define pi 3.14159\n#define oz vec2(0.01,0)\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define c1 mix(2.0*vec4(0.3, 0.25, 0.2, 0), vec4(0.5), 0.75)\n#define c2 mix(2.0*vec4(0.2, 0.25, 0.3, 1.0), vec4(0.5), 0.75)\n#define sat(t) clamp(t, 0.0, 1.0)\n\n// Ray marching result struct\nstruct RayMarch {\n    float dist;     // Raymarch distance\n    float steps;    // Raymarch steps\n    vec3 pos;       // Surface position\n    vec3 normal;    // Surface normal\n    vec4 col;       // Surface color\n};\n\n// Random [0,1]\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\n// 3D Box SDF by iq\nfloat box(vec2 p, vec2 r) {\n    vec2 d = abs(p) - r;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Greeble surface detail\nfloat greeble(vec3 p) {\n    float r = 0.0;\n    for (int i = 0; i < 4; i++) {\n        p += 2.*rand(floor(p.xz));\n        r += sign(sin(p.x)*sin(p.y)*sin(p.z));\n        p *= 2.0;\n    }\n    return r;\n}\n\n// Scene distance function\nfloat scene(vec3 p) {\n    float gr = 0.01*greeble(0.5*p);\n    vec3 pc = p;\n    pc.z = mod(pc.z,40.0)-20.0;\n    p.xy = abs(p.xy);\n    p.x = mod(p.x,2.0)-1.0;\n    p.z = mod(p.z,2.0)-1.0;\n    p.y = mod(p.y,2.0)-.0;\n    float r = 1.0-p.y;\n    r = max(r, -box(pc.yz, vec2(2.5,10.)));\n    r = min(r, box(p.xz, vec2(0.1)));\n    r = min(r, box(p.xy-vec2(0,1), vec2(0.1)));\n    r = min(r, box(p.zy-vec2(0,1), vec2(0.1)));\n    return 0.9*r+gr;\n}\n\n// Texturing\nvec4 textureColor(vec3 p, vec3 n) {\n    int axis = (abs(n.y)>=0.9 ? 0 : (abs(n.z)>=0.9 ? 1 : 2));\n    vec2 tc = (axis==0 ? p.xz : (axis==1 ? p.xy : p.yz));\n    tc *= 0.5;\n    tc += 0.1*p.z;\n    tc += 0.25*p.y;\n    vec4 col = texture(iChannel0, tc);\n    col *= col*col;\n    col = vec4(3.0*col.r);\n    return sat(col);\n}\n\n// Ray marching\nRayMarch march(vec3 cam, vec3 ray) {\n    float dist = 0.0;\n    float d = 0.0;\n    float steps = 0.0;\n    vec3 p;\n    while (steps < MAX_STEPS) {\n        p = cam + ray * dist;\n        d = scene(p);\n        dist += 0.75*d;\n        if (d < MIN_DIST || dist > MAX_DIST) break;\n        steps++;\n    }\n    vec3 n = normalize(d-vec3(scene(p-oz.xyy), scene(p-oz.yxy), scene(p-oz.yyx)));\n    vec4 col = textureColor(p,n);\n    return RayMarch(dist, steps, p, n, col);\n\n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= iResolution.xy/iResolution.y/2.0;\n    // Camera setup\n    vec3 cam = vec3(0);\n    cam.z += 0.5*iTime;\n    vec3 ray = normalize(vec3(uv.x, uv.y, 0.8));\n    float rx = (iMouse.z >= 0.5 ? iMouse.x/iResolution.x*2.0*pi-pi\n                : 0.25*sin(0.2*iTime));\n    float ry = (iMouse.z >= 0.5 ? iMouse.y/iResolution.y*pi-pi/2.0\n                : sin(0.3*iTime)*smoothstep(-1.0, 1.0, sin(0.6*iTime)));\n    ray.yz *= rot(ry);\n    ray.xz *= rot(rx);\n    ray.xy *= rot(pi/2.0);\n    // Ray march\n    RayMarch rm = march(cam, ray);\n    // Lighting\n    float l1 = max(dot(rm.normal, normalize(vec3(1, -1.0, 0))), 0.0);\n    float l2 = max(dot(rm.normal, normalize(vec3(1, 1.0, 0))), 0.0);\n    float l3 = max(dot(rm.normal, normalize(vec3(0, 0, -1))), 0.0);\n    float l4 = max(dot(rm.normal, normalize(vec3(-1, 0, 0))), 0.0);\n    float l5 = max(dot(rm.normal, normalize(vec3(0, 0, 1))), 0.0);\n    vec4 l = rm.col*2.0*c1*((l1+l2)+0.3*(l3+l5)+0.2*l4);\n    float drk = sat(rm.pos.x/15.0+1.0);\n    drk *= drk*drk;\n    float lght = sat(rm.pos.x/20.0-0.1);\n    float d = 1.0-rm.dist/MAX_DIST;\n    d *= d*d*d;\n    // Final composition\n    fragColor = drk*l*d+2.5*c1*lght;\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[570, 586, 606, 606, 666], [668, 688, 715, 715, 800], [802, 828, 851, 851, 1026], [1028, 1055, 1076, 1076, 1490], [1492, 1505, 1540, 1540, 1823], [1825, 1841, 1877, 1877, 2301], [2303, 2311, 2366, 2366, 3570]], "test": "untested"}
{"id": "sljcRG", "name": "Little patterns 2423425", "author": "SnoopethDuckDuck", "description": "right side is buggy + could use fract instead of mod\n\njust got this from messing around, I quite like the left side", "tags": ["e"], "likes": 5, "viewed": 200, "published": 3, "date": "1649878949", "time_retrieved": "2024-07-30T16:54:07.789611", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float si = 54.;\n    vec2 ipos = floor(si * (vec2(1,5) + uv));\n   \n    float sc = pi * floor(2.5 + 0.25 * (ipos.x - ipos.y)/si + 0.5 * iTime);\n    \n    // sc2 = 1. gives noise pattern\n    // sc2 = pi gives repeated pattern\n    float sc2 = mix(1., pi, step(0., uv.x)); // gives a noise-like pattern\n    \n    float m = 0.5 * mod(sc * (ipos.y * cos(sc2 * ipos.x) \n                            + ipos.x * cos(sc2 * ipos.y)), 2.);\n                           \n    // do 0.5 * cos(...) for a cool effect\n    m = 0.5 + 0.5 * step(0.5 + 0. * cos(ipos.x/si + iTime), m);\n\n    vec3 e = vec3(0.5);\n    vec3 col = vec3(m);\n    col *= pal(0.25 * (uv.y + uv.x), e, e, e, 0.5 * vec3(0,1,2)/3.); \n    col *= 1. - pow(4. * uv.y * uv.y, 4.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 891]], "test": "untested"}
{"id": "ftjczy", "name": "Simple unbounded cut triangle", "author": "mrange", "description": "CC0: Simple unbounded cut triangle\n  Nothing special but another distance field can't hurt?", "tags": ["2d"], "likes": 1, "viewed": 200, "published": 3, "date": "1649872884", "time_retrieved": "2024-07-30T16:54:08.971451", "image_code": "// CC0: Simple unbounded cut triangle\n//  Nothing special but another distance field can't hurt?\n\nfloat cutslice(vec2 p, vec2 off) {\n  // A bit like this but unbounded\n  // https://www.shadertoy.com/view/MlycD3\n  p.x = abs(p.x);\n  off.x *= 0.5; \n\n  vec2 nn = normalize(vec2(off));\n  vec2 n  = vec2(nn.y, -nn.x);\n\n  float d0 = length(p-off);\n  float d1 = -(p.y-off.y);\n  float d2 = dot(n, p);\n  \n  bool b = p.x > off.x && (dot(nn, p)-dot(nn, off)) < 0.0;\n  \n  return b ? d0 : max(d1, d2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  float aa = 2.0/iResolution.y;\n  \n  vec2 off = 0.8*(vec2(0.5)+0.5*sin(iTime*vec2(sqrt(0.5), 1.0)));\n  float d = cutslice(p, off);\n  vec3 col = vec3(0.1);\n  \n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  col.x += (0.5+0.5*cos(100.0*d))*0.5;\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 132, 210, 489], [491, 491, 546, 546, 931]], "test": "untested"}
{"id": "fl2yRy", "name": "automata 6906160463", "author": "SnoopethDuckDuck", "description": "not a huge fan of this but has some interesting properties \n\npress r to reset", "tags": ["cellularautomata"], "likes": 2, "viewed": 210, "published": 3, "date": "1649871673", "time_retrieved": "2024-07-30T16:54:09.819185", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 1.;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float x = texelFetch( iChannel0, ivec2(a * fragCoord), 0 ).x;\n    \n    vec3 col = vec3(x);\n    vec3 f =  exp(-10. * length(uv)) * vec3(0,0,0);\n    vec3 e = vec3(0.5);\n    col *= pal(uv.y * 0.32 + 1.5, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    col = clamp(col, 0., 1.);\n    \n    col = smoothstep(0., 1., col) + 0.15;\n    //col = mix(col + f, col * f, smoothstep(0., 1., x));\n    \n   \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n//#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nfloat inv(float y) {\n    return 0.5 - sin(asin(1.0-2.0*y)/3.0);\n}\n\nfloat Cell(in ivec2 p) {\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).x;\n}\n\n\nfloat hash1(float n) {\n    return fract(sin(n)*138.5453123);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 px = ivec2( fragCoord );\n    \n    if (key_down(KEY_RESET) || iFrame==0) \n    {    \n        float d = length((fragCoord -.5* iResolution.xy ) / iResolution.y);\n        float g = hash1(fragCoord.x * 13.0  + 10.131 * iTime + 100.19414 + hash1(fragCoord.y*73.1 + 1931.1));\n        g = step(0.99, g);\n        //g *= 1.-step(d, 10./iResolution.y);\n        fragColor = vec4(g, 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n    // center cell\n    float e = Cell(px); \n    \n    // neighbour cells\n    float t = Cell(px + ivec2(0,-1));\n    float b = Cell(px + ivec2(0,1));\n    float l = Cell(px + ivec2(-1,0));\n    float r = Cell(px + ivec2(1,0));   \n    \n    // \"average\" of neighbours\n    float k = 0.5 * max(t + b, l + r);\n    \n    // difference between \"average\" and center\n    float j = abs(e - k);\n    \n   // e += 0.3 * j - 0.06;\n     float a = 0.0;\n    if (e > k - 0.35)\n        e = 0.02 + 0.89 * k - 0.5 * j * k * k;\n   // else\n     //   e *= 1.5 * k;\n    \n    if (e <= k * 2.0 * j)// && e <= 1. / 20.)\n        e = k * 1.545;\n    else if (k >= 0.9)\n        e = k + 0.1 - 0.5 * (1.-e);\n    //else if (e >= 1.)\n      //  e = 0.;\n \n    e = clamp(e,0.,1.);\n     \n    fragColor = vec4( e, 0.0, 0.0, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2yRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 566]], "test": "untested"}
{"id": "fljczG", "name": "stars - PSF + saturation (gauss)", "author": "FabriceNeyret2", "description": "Gauss approx variant of https://shadertoy.com/view/Xty3zc\nstar = 0-size point\nstar appear on sensor as Airy disk smoothed by pixel resol. Here, (huge) approx as Gaussian for close form integrals.\ntop: lum = 10⁵ ^ x\nbottom: star dist * x for lum 10¹ & 10²", "tags": ["star", "psf", "sensor"], "likes": 8, "viewed": 264, "published": 3, "date": "1649871507", "time_retrieved": "2024-07-30T16:54:10.629019", "image_code": "// Fork of \"stars - PSF + saturation\" https://shadertoy.com/view/Xty3zc\n// instead of the true Bessel, here we use Gaussian for close form integration\n\n\n#define rnd(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float S = 20.;                 // cell size\n    vec2 R = iResolution.xy,\n         I = floor(u/S)*S,         // grid cell\n         U = u/R,\n         P,d;\n    float x = U.x,\n          lum =                    // apparent luminosity * exposition / saturation threshold\n                U.y>.66 ? pow(1e5, x )  // top: luminosity = 10⁵ ^x\n              : U.y>.33 ? 1e1 / (x*x)   // start dist * x for lum = 10¹\n                        : 1e2 / (x*x);  //                          10²\n                        \n    for (int k=0; k<9; k++) {\n        d = S*vec2(k%3-1,k/3-1),   // offset to neighborh cell\n        P = I+d + S* rnd(I+d);     // random point in cell\n                // starPos, sigma=1pix,  grid cell = 1 pix    \n        O += intgauss2( P,       1.,          u-.5,1.) \n            * vec4(1,.5,.2,1)* lum; //  source intensity RGB\n    }\n    \n    if ( int(u.y)%int(R.y/3.) == 0 ) O = vec4(0,1,0,1);\n// O = vec4(intgauss0( 3.2*U.x ) < P.y );\n}", "image_inputs": [], "common_code": "/******************************************************\\\n**                                                    **\n**      Stats.glsl           Fabrice NEYRET 30/06/11  **\n**                                                    **\n\\******************************************************/\n\n// gauss(u)     Normal(0,1)\n//                  use uniform as seed\n// intgauss(x)  cumulative distr func of Normal(0,1)\n//                  use x = (x-xm)/s for N(xm,s^2)\n\n// seq(fsolve(1/2*(1+erf(x/sqrt(2)))=i/255.,x), i = 0..255);\nfloat invgauss[256] = float[](\n  -13.50858432, -2.658748992, -2.416134297, -2.264727419,   -2.152315053, -2.061916502, -1.985770403, -1.919651290,   -1.860993476, -1.808117371, -1.759861028, -1.715385840,   -1.674065908, -1.635421185, -1.599075078, -1.564726471,   -1.532130657, -1.501085946, -1.471424060, -1.443003065,   -1.415702094, -1.389417334, -1.364058929, -1.339548561,   -1.315817530, -1.292805229, -1.270457904, -1.248727645,   -1.227571561, -1.206951090, -1.186831433, -1.167181068,   -1.147971348, -1.129176158, -1.110771617, -1.092735829,   -1.075048664, -1.057691573, -1.040647418, -1.023900333,   -1.007435601, -0.9912395403, -0.9752994069, -0.9596033111,   -0.9441401408, -0.9288994918, -0.9138716087, -0.8990473298,   -0.8844180399, -0.8699756243, -0.8557124305, -0.8416212336,   -0.8276952018, -0.8139278686, -0.8003131056, -0.7868450995,   -0.7735183280, -0.7603275409, -0.7472677410, -0.7343341688,   -0.7215222841, -0.7088277541, -0.6962464387, -0.6837743800,   -0.6714077892, -0.6591430371, -0.6469766453, -0.6349052758,   -0.6229257234, -0.6110349080, -0.5992298682, -0.5875077530,   -0.5758658170, -0.5643014135, -0.5528119909, -0.5413950853,   -0.5300483169, -0.5187693864, -0.5075560692, -0.4964062122,   -0.4853177302, -0.4742886030, -0.4633168707, -0.4524006317,   -0.4415380391, -0.4307272994, -0.4199666679, -0.4092544476,   -0.3985889860, -0.3879686745, -0.3773919440, -0.3668572645,   -0.3563631432, -0.3459081219, -0.3354907758, -0.3251097114,   -0.3147635664, -0.3044510061, -0.2941707233, -0.2839214366,   -0.2737018897, -0.2635108491, -0.2533471031, -0.2432094621,   -0.2330967553, -0.2230078312, -0.2129415555, -0.2028968119,   -0.1928724988, -0.1828675299, -0.1728808328, -0.1629113487,   -0.1529580307, -0.1430198431, -0.1330957617, -0.1231847716,   -0.1132858673, -0.1033980512, -0.09352033436, -0.08365173407,   -0.07379127404, -0.06393798335, -0.05409089672, -0.04424905235,   -0.03441149226, -0.02457726114, -0.01474540668,   -0.004914977406, 0.004914977155, 0.01474540642, 0.02457726089,   0.03441149176, 0.04424905210, 0.05409089646, 0.06393798310,   0.07379127354, 0.08365173382, 0.09352033411, 0.1033980509,   0.1132858670, 0.1231847714, 0.1330957614, 0.1430198428,   0.1529580304, 0.1629113485, 0.1728808325, 0.1828675294,   0.1928724985, 0.2028968116, 0.2129415553, 0.2230078306,   0.2330967551, 0.2432094618, 0.2533471029, 0.2635108488,   0.2737018895, 0.2839214363, 0.2941707228, 0.3044510058,   0.3147635661, 0.3251097112, 0.3354907753, 0.3459081217,   0.3563631430, 0.3668572642, 0.3773919437, 0.3879686742,   0.3985889858, 0.4092544470, 0.4199666676, 0.4307272991,   0.4415380388, 0.4524006311, 0.4633168704, 0.4742886028,   0.4853177300, 0.4964062120, 0.5075560689, 0.5187693861,   0.5300483166, 0.5413950850, 0.5528119906, 0.5643014132,   0.5758658164, 0.5875077527, 0.5992298679, 0.6110349077,   0.6229257228, 0.6349052755, 0.6469766450, 0.6591430368,   0.6714077889, 0.6837743797, 0.6962464383, 0.7088277535,   0.7215222838, 0.7343341684, 0.7472677407, 0.7603275402,   0.7735183276, 0.7868450991, 0.8003131052, 0.8139278682,   0.8276952014, 0.8416212332, 0.8557124301, 0.8699756239,   0.8844180395, 0.8990473294, 0.9138716079, 0.9288994914,   0.9441401404, 0.9596033107, 0.9752994065, 0.9912395399,   1.007435601, 1.023900332, 1.040647417, 1.057691573,   1.075048664, 1.092735828, 1.110771616, 1.129176157,   1.147971347, 1.167181067, 1.186831432, 1.206951090,   1.227571560, 1.248727645, 1.270457904, 1.292805229,   1.315817529, 1.339548560, 1.364058929, 1.389417333,   1.415702093, 1.443003064, 1.471424059, 1.501085945,   1.532130656, 1.564726471, 1.599075077, 1.635421184,   1.674065907, 1.715385839, 1.759861026, 1.808117368,   1.860993475, 1.919651288, 1.985770401, 2.061916499,   2.152315051, 2.264727416, 2.416134292, 2.658748984, 13.50858432\n);\n\n//seq(evalf(1/2*(1+erf(((2*i/255-1)*3.2)/sqrt(2)))), i = 0..255);\nfloat Intgauss[256] = float[](\n0.6871380e-3, 0.7494356e-3, 0.8169004e-3, 0.8899146e-3, 0.9688851e-3, 0.10542440e-2, 0.11464499e-2, 0.12459894e-2, 0.13533781e-2, 0.14691620e-2, 0.15939188e-2, 0.17282592e-2, 0.18728282e-2, 0.20283069e-2, 0.21954132e-2, 0.23749034e-2, 0.25675740e-2, 0.27742627e-2, 0.29958497e-2, 0.32332593e-2, 0.34874612e-2, 0.37594717e-2, 0.40503552e-2, 0.43612252e-2, 0.46932459e-2, 0.50476330e-2, 0.54256549e-2, 0.58286340e-2, 0.62579476e-2, 0.67150286e-2, 0.72013666e-2, 0.77185082e-2, 0.82680583e-2, 0.88516803e-2, 0.94710962e-2, 0.101280874e-1, 0.108244945e-1, 0.115622174e-1, 0.123432152e-1, 0.131695056e-1, 0.140431650e-1, 0.149663273e-1, 0.159411831e-1, 0.169699787e-1, 0.180550152e-1, 0.191986463e-1, 0.204032774e-1, 0.216713632e-1, 0.230054056e-1, 0.244079514e-1, 0.258815900e-1, 0.274289497e-1, 0.290526957e-1, 0.307555258e-1, 0.325401674e-1, 0.344093732e-1, 0.363659176e-1, 0.384125920e-1, 0.405521998e-1, 0.427875528e-1, 0.451214648e-1, 0.475567470e-1, 0.500962022e-1, 0.527426190e-1, 0.554987662e-1, 0.583673862e-1, 0.613511885e-1, 0.644528440e-1, 0.676749772e-1, 0.710201601e-1, 0.744909052e-1, 0.780896580e-1, 0.818187898e-1, 0.856805910e-1, 0.896772632e-1, 0.938109124e-1, 0.980835408e-1, .1024970404, .1070531852, .1117536236, .1165998722, .1215933076, .1267351604, .1320265080, .1374682681, .1430611923, .1488058602, .1547026733, .1607518498, .1669534188, .1733072163, .1798128798, .1864698448, .1932773408, .2002343882, .2073397956, .2145921572, .2219898512, .2295310383, .2372136614, .2450354446, .2529938944, .2610862998, .2693097340, .2776610567, .2861369163, .2947337533, .3034478039, .3122751044, .3212114960, .3302526301, .3393939748, .3486308209, .3579582890, .3673713374, .3768647696, .3864332432, .3960712786, .4057732686, .4155334878, .4253461032, .4352051838, .4451047123, .4550385955, .4650006759, .4749847425, .4849845435, .4949937969, .5050062031, .5150154565, .5250152575, .5349993241, .5449614045, .5548952877, .5647948162, .5746538968, .5844665122, .5942267314, .6039287214, .6135667568, .6231352304, .6326286626, .6420417110, .6513691791, .6606060252, .6697473699, .6787885040, .6877248956, .6965521961, .7052662467, .7138630837, .7223389433, .7306902660, .7389137002, .7470061056, .7549645554, .7627863386, .7704689617, .7780101488, .7854078428, .7926602044, .7997656118, .8067226592, .8135301552, .8201871202, .8266927837, .8330465812, .8392481502, .8452973267, .8511941398, .8569388077, .8625317319, .8679734920, .8732648396, .8784066924, .8834001278, .8882463764, .8929468148, .8975029596, .9019164592, .9061890876, .9103227368, .9143194090, .9181812102, .9219103420, .9255090948, .9289798399, .9323250228, .9355471560, .9386488115, .9416326138, .9445012338, .9472573810, .9499037978, .9524432530, .9548785352, .9572124472, .9594478002, .9615874080, .9636340824, .9655906268, .9674598326, .9692444742, .9709473043, .9725710503, .9741184100, .9755920486, .9769945944, .9783286368, .9795967226, .9808013537, .9819449848, .9830300213, .9840588169, .9850336727, .9859568350, .9868304944, .9876567848, .9884377826, .9891755055, .9898719126, .9905289038, .9911483197, .9917319417, .9922814918, .9927986334, .9932849714, .9937420524, .9941713660, .9945743451, .9949523670, .9953067541, .9956387748, .9959496448, .9962405283, .9965125388, .9967667407, .9970041503, .9972257373, .9974324260, .9976250966, .9978045868, .9979716931, .9981271718, .9982717408, .9984060812, .9985308380, .9986466219, .9987540106, .9988535501, .9989457560, .9990311149, .9991100854, .9991830996, .9992505644, .9993128620\n);\n\nfloat gauss(float u) { // takes u = rand_uniform()\n    // return 4*(2*u-1);\n    u*=256.;\n    if (u>=255.) return invgauss[255];\n    int iu = int(u);\n    float fu = u-float(iu);\n    return (1.-fu)*invgauss[iu]+fu*invgauss[iu+1];\n}\n\n\n// erf: approxs there https://en.wikipedia.org/wiki/Error_function\n//          and there https://github.com/libretro/glsl-shaders/blob/master/blurs/blur9fast-vertical.glsl\n//#define erf(x) tanh(1.202760580 * (x))\nfloat erf(float x) {\n   float sign_x = sign(x),\n\t    t = 1./(1. + .47047*abs(x));\n\treturn sign(x) \n          * ( 1. - t* (.3480242 + t*(-.0958798 + t*.7478556)) * exp(-x*x) );\n}\n#define intgauss(x)  ( .5 + .5*erf((x)/sqrt(2.) )  )  // use analytic version\n//#define intgauss intgauss0                          // use tabuled version\nfloat intgauss0(float x) { // use (x-xm)/s for N(m,s^2)\n    x = (x/3.2)*128.+128.;\n    if (x<0.) return Intgauss[0];\n    if (x>255.) return Intgauss[255];\n    int ix = int(x);\n    float fx = x-float(ix);\n    return (1.-fx)*Intgauss[ix]+fx*Intgauss[ix+1];\n}\n\n\n\n// spot = gauss(xP,yP,s) pixel = grid [I,I+l[\nfloat intgauss2(vec2 P, float s, vec2 I, float l) {\n    float r = l*.5, \n          d = length(I-P+r);\n    // dist > 3.2*sigma →  < 0.5% intensity\n // if (d >  3.2*s+r) return 0.; // spot \"totally\" out of pixel\n // if (d < -3.2*s+r) return 1.; // spot \"totally\" inside pixel\n // else   // spot partly covers the pixel\n      {    vec2 A = (I-P)/s, B = (I+l-P)/s;\n           return  (intgauss(B.x)-intgauss(A.x))\n                  *(intgauss(B.y)-intgauss(A.y));\n                }\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 269, 269, 1224]], "test": "untested"}
{"id": "slByDW", "name": "Packed Rectangle Spiral Tunnel", "author": "Shane", "description": "Generating a smooth packed rectangle distance field texture and corresponding position map, then applying it to the walls of a spiral tunnel.", "tags": ["procedural", "tunnel", "texture", "spiral", "rectangle", "bump", "tessellation", "packing", "partition", "gilbert"], "likes": 47, "viewed": 772, "published": 3, "date": "1649857035", "time_retrieved": "2024-07-30T16:54:11.960460", "image_code": "/*\n\n    Packed Rectangle Spiral Tunnel\n    ------------------------------\n    \n    There are two ways to code a packed rectangle texture. There is a relatively \n    simple way involving lines on a backbuffer, and an excrutiatingly annoying way \n    that involves rendering each rectangle's distance field. The line version, which \n    you can find a couple of examples of on Shadertoy looks pretty cool in its own \n    right. However, it's not useful for a lot of the things that I'd imagine people \n    would want them for, like individual rectangle coloring, height maps, bump \n    mapping, etc.\n\n\tI wouldn't say randomly packed rectangle textures are easy to code outside a \n    pixelshader environment, but it's a lot easier when you're not restricted by pixel \n    access order, that's for sure. There's also wrapping, linear interpolation, screen \n    size changes, etc, to consider, so you're probably wondering why anyone would bother.\n    \n    The simple answer is, they look cool, plus they're a pretty useful pattern to have\n    in your toolkit. Don't quote me on it, but I think I've heard this particular \n    arrangement referred to as an axis parallel Gilbert tessellation variant. This scene \n    doesn't quite do the pattern justice, but gives the general idea. I'm also hoping it \n    demonstrates that you're not restricted to in-house textures, or distance patterns \n    that you can code in realtime.\n    \n    The packed rectangle texture constuction is all you'll need to understand this, and\n    that's contained in the \"Cube A\" tab. To see the standalone texture, uncomment the\n    DISPLACEMENT_MAP define. Everything else involves simple, but lengthy, applications \n    of well known techniques, like bump mapping, coloring, lighting, etc.\n     \n    Anyway, this is yet another proof of concept, just to show that it's possible. I \n    have a couple of more interesting examples involving this. There are a few defines\n    to play around with in the \"Common\" and \"Image\" tabs for anyone interested. \n     \n\n\n\n\tRelated exmaples:\n    \n\t// Fabrice's worm textures are great if you haven't seen them.\n    // This is one of my favorite ones.\n    maze worms / graffitis 4  - FabriceNeyret2 \n    https://www.shadertoy.com/view/lsjyzw\n    \n    // A cheap trick I came up with ages ago to emulated\n    // random packed rectangle textrues.\n    Asymmetric Blocks - Shane\n    https://www.shadertoy.com/view/Ws3GRs\n    \n    // Another packed texture based on a common subdivision\n    // scheme. This one has rectangle information.\n    Box Divide ID - Shane\n    https://www.shadertoy.com/view/WlsSRs\n\n\n*/\n \n\n// Just the displacement map on its own. Actually, this is a bump mapped\n// version.\n//#define DISPLACEMENT_MAP\n\n// Color scheme - SPECTRUM PASTEL: 0, BROWN: 1, PURPLE: 2.\n#define COLOR 0\n\n// Put a bit of specular sheen on things. I've also raised the tiles\n// to show that there is a distance field involved.\n#define SHINY\n\n// Border demarcation scheme.\n// 0: No edges, 1: Side rails, 2: Squares, 3: Rails and squares. \n#define EDGES 1\n\n\n// Max ray distance.\n#define FAR 7.\n\n// No forced unroll.\n#define ZERO min(0, iFrame)\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Smooth cube map face 2D texture blend.\nfloat getTex1(samplerCube iCh, vec3 q){\n    \n    // Scaling.\n    vec2 p = q.xy/1.;\n    \n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    \n    // 2D neighboring texels stored in each of the four texture channels.\n    vec4 p4 = texture(iCh, vec3(.5, uv.y, -uv.x)); \n    \n    // Linearly interpolate.\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n\n}\n\nvec2 getUV(vec3 q){\n\n    // Scaling.\n    vec2 p = q.xy/1.;\n    \n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    vec2 ip = floor(p); //p -= ip;\n    vec2 uv = ((ip + .5)/cubemapRes);\n    \n    return uv;\n \n}\n\n\nfloat getDF(vec2 uv, vec4 rect){\n    \n    return max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n} \n\n/* \n// Smooth cube map face 2D texture blend.\nvec3 hm(vec3 q){\n    \n    // Smooth distance field.\n    float df = getTex1(iChannel2, q);\n    \n    // Rectangle center and dimensions.\n    vec2 uv = getUV(q);\n    vec4 tx = texture(iChannel2, vec3(-.5, fract(uv.yx) - .5)); \n\n    // Cube map wrapping.   \n    tx.zw = convert(tx.zw);\n    // Random color, used for the height.\n    float rnd = hash21(tx.xy + .5);\n    vec3 col = .5 + .45*cos(6.2831*rnd/1. + vec3(0, 1., 2));\n    \n    // Applying height information to the 2D distance field.\n    float sf = 16./1024.;\n    float rDf = df + sf/2.;\n    col = mix(vec3(0), col - rDf*4.*1., 1. - smoothstep(0., sf, rDf));\n    \n    return col;\n}\n*/\n\nmat2 twist(float y){\n   return rot2(y*.8);\n}\n\n// The extruded image.\nfloat map(vec3 p){\n\n    \n    // Twisting the scene along the Y direction.\n    p.xz *= twist(p.y);\n    \n    // The tunnel center... It's not offset, so this is kind of\n    // redundant, but it's usually helpful.\n    vec3 cntr = p;\n    \n    const float ew = 1./14.;\n    float sq = max(abs(cntr.x), abs(cntr.z)) - .5;// + 1.;\n    \n    // Inside of the square tube for the tunnel.\n    float tun = -sq;\n    \n    \n    #if EDGES > 0\n        // Divider.\n        float div = max(abs(sq + ew/2. + ew/8.) - (ew/2.), abs(mod(p.y, 1.) - 1./2.) - ew/2.);\n\n        // Moving the rails to the corners, then moving them in slightly.\n        vec2 q = abs(abs(p.xz) - .5 + ew/2. + ew/8.);\n        float rails = max(q.x, q.y) - (ew/2. - .006); \n        #if EDGES == 1\n        div = rails;//min(div, rails);\n        #elif EDGES >= 3\n        div = min(div, rails);\n        #endif\n    #else\n        float div = 1e5;\n    #endif\n    \n    // Doubling up.\n    //div = abs(div) - ew;\n    \n    // Wall UV direction. \n    vec3 uvw = abs(cntr.x)>abs(cntr.z)*1.? vec3(-1, 1, 1)*cntr.zyx : cntr;\n    \n    /*\n    // Distance field height application.\n    vec3 col = hm(uvw);\n    float val = dot(col, vec3(.299, .587, .114));\n    tun -= val*.02;\n    */\n \n    // Encasing boxes inside the rails: I hacked this together in a hurry, but\n    // it seems to work. It definitely needs a tidy up.\n    const float sc = 14.;\n    float dOffs = ew/8.*2./sc;\n    vec3 offs = vec3(0, .5/sc, 0); // The edge XZ has been moved in by .25/sc.\n    p = abs(mod(p + offs, 1./sc - vec3(dOffs, 0, dOffs)) - (1./sc - vec3(dOffs, 0, dOffs))/2.);\n    float cb = max(max(p.x, p.y), p.z) - .5/sc + .006;\n    div = min(div + .015, max(div, cb));\n \n    // Overall object ID. Either the tunnel or the repeat boxes.\n    objID = tun<div? 0. : 1.;\n    \n    // Just the floor.\n    return min(tun, div);\n \n}\n\n \n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;//max(.5-ro.z/rd.z, 0.)\n    \n    for(int i = min(iFrame, 0); i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.75; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = ZERO; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(d>1e8) break; // Fake break.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the height values that are further away, which can sometimes tone down annoying\n// Moire artifacts.\n//float gT;\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n    \n     \n    \n    vec3 txP = p;\n    // The objects have been rotated in the distance function,\n    // so the normal needs to match... If I had a dollar for every time\n    // I've forgotten that... :)\n    vec3 txN = n;\n    txP.xz *= twist(txP.y);\n    txN.xz *= rot2(txN.y);\n\n    //vec2 uv = abs(txN.x)>.5? txP.zy : abs(txN.y)>.5? txP.xz : txP.xy;\n    //float faceID = abs(txN.x)>.5? 0. : abs(txN.y)>.5? 1. : 2.;\n    \n    vec3 uvw = abs(txP.x)>abs(txP.z)*1.? vec3(-1, 1, 1)*txP.zyx : txP;\n    \n    float df = getTex1(iChannel2, uvw);\n \n    float sf = 16./cubemapRes.x;\n   \n    #ifdef SHINY\n    float maxVal = max(1. - df/.1, 0.);\n    #else\n    const float maxVal = 1.;\n    #endif\n    float val = mix(0., maxVal, 1. - smoothstep(0., sf, (df + sf*.5)));//tx.x\n    \n    return val;///(1. + gT*gT*.5);\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(1./cubemapRes.x, 0);  \n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    vec4 b4;\n    for(int i = ZERO; i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\n\n// IQ's signed distance to a 2D triangle with a few lines\n// taken out to make a wedge... It's a less-than-clever \n// hack, but I'll find a better solution later.\nfloat wedge(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d =min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       \n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// A quick hacky loading screen routine: I got a bit carried away. For \n// whatever reason, I decided that I wanted something that matched the \n// scene we were leading into... I probably should have stuck to \n// something simpler and more elegant.\nvec3 loadingScreen(vec2 uv, vec3 scBgnd){\n\n    // Cube map face two, which contains the smooth information.\n    //vec4 ldTex = texture(iChannel2, vec3(-.5, uv2.yx));\n    //float df = getTex1(iChannel2, vec3((uv), 0)); //ldTex.x>0.? 0. : 1.\n    //vec3 bgCol = vec3(df);\n\n    // Grid partitioning.\n    vec2 ldSc = vec2(24);\n    float sf = ldSc.x/iResolution.y;\n    vec2 ldP = uv*ldSc;\n    vec2 ldIP = floor(ldP);\n    ldP -= ldIP + .5;\n\n    \n    // Shape samples.\n    float ldSq = max(abs(ldP.x), abs(ldP.y)) - .5;\n    //float ldSq = length(ldP) - .48;\n    vec2 ld = normalize(vec2(-1, -2));\n    float ldSq2 = max(abs(ldP.x - ld.x*.001), abs(ldP.y - ld.y*.001)) - .5;\n    //float ldSq2 = length(ldP - ld.x*.001) - .48;\n    \n    //ldSq = abs(ldSq + .2) - .2;\n    //ldSq2 = abs(ldSq2 + .2) - .2;\n\n    // Bumped highlight value.\n    float b = max(ldSq2 - ldSq, 0.)/.001;\n    \n    \n\n    // Load time factor.\n    float ldTf = float(iFrame)/float(maxFrames);\n\n    if(abs(ldIP.x + .5)>ldSc.x/2.*iResolution.x/iResolution.y - 1.) ldSq = 1e5;\n    //if(abs(ldIP.x + .5)>ldSc.x/2. - 1.) ldSq = 1e5;\n    if(abs(ldIP.y + .5)>ldSc.y/2. - 1.) ldSq = 1e5;\n\n    //if(mod(ldIP.y - (ldSc.y - 1.), ldSc.y*2.)/(ldSc.y*2.)<ldSh) ldSq = 1e5;\n    float x = mod(ldIP.x*2. - (ldSc.x - 1.), ldSc.x*2.);\n    float y = mod(ldIP.y*2. - (ldSc.y - 1.), ldSc.y*2.);\n    float pos = y*ldSc.y + x;\n\n \n    //if(pos/(ldSc.y*ldSc.x*2.)<ldTf) ldSq = 1e5;\n    //if(pos/(ldSc.y*ldSc.x*2.)<-hash21B(ldIP) + ldTf*2.) ldSq = 1e5;\n    if(hash21B(ldIP + .45)<ldTf) ldSq = 1e5;\n    \n\n    vec3 ldSqCol = .5 + .45*cos(6.2831*hash21B(ldIP) + vec3(0, 1, 2));\n    ldSqCol = mix(ldSqCol, vec3(1), .1)*max(1.25 - dot(uv, uv), 0.);\n    \n  \n    // Background texture.\n    vec3 tx = texture(iChannel0, uv*2. + hash21B(ldIP + .35)).xyz; tx *= tx;\n    tx = .8 + tx*.4;\n    \n    vec3 ldCol = scBgnd;\n    //ldCol = mix(ldCol, ldCol*8., 1. - bgCol);\n\n    //ldCol = bgCol;\n    ldCol = mix(ldCol, vec3(0), (1. - smoothstep(0., sf*6., ldSq))*.25);\n    //ldCol = mix(ldCol, ldSqCol*1.5, 1. - smoothstep(0., sf, ldSq));\n    //ldCol = mix(ldCol, vec3(0), 1. - smoothstep(0., sf, ldSq + .075));\n    ldCol = mix(ldCol, ldSqCol*(.8 + b*.5), 1. - smoothstep(0., sf, ldSq + .1));\n    \n    \n    // Texture application.\n    ldCol *= tx;\n        \n\n    // Time arc calculations.\n    float arc = abs(length(uv) - .1) - .03;\n    //arc = abs(arc + .0125) - .0125;\n    // Loading angle.\n    float a = 6.2831*ldTf;\n    vec2[3] v; v[0] = vec2(0), v[1] = vec2(0, 1), v[2] = vec2(sin(a), cos(a));\n\n    // Cutting a wege from the arc. Terrible -- I should be using IQ's arc function. \n    float d = a>0.? wedge(uv, v[0], v[1], v[2]) : 1e5;\n    if(a>3.14159) d = min(-d, -uv.x);\n    arc = max(arc, -d);\n\n    //ldCol = scBgnd;\n \n \n    // Rendering the timing arc overlay.\n    sf /= ldSc.x;\n    vec3 svCol = ldCol;\n    ldCol = mix(ldCol, vec3(0), (1. - smoothstep(0., sf*12., arc))*.5);\n    ldCol = mix(ldCol, vec3(0), (1. - smoothstep(0., sf, arc))*.9);\n    ldCol = mix(ldCol, svCol*.5 + .5, (1. - smoothstep(0., sf, arc + .006)));\n    ldCol = mix(ldCol, ldCol*1.5, (1. - smoothstep(0., sf, arc + .0275)));\n    \n    // Loading screen color.\n    return ldCol;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Aspect correct screen coordinates. Translation and scale is all that\n    // \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // People get bored very quickly, so it's customary to show a loading\n    // screen during precalculations. You can make it as simple or as\n    // complicated as you want... I honestly don't know what I was going\n    // for when I started coding it, but a rushed ten minutes later there\n    // was a rotating bar sitting over a weird bumped pixel dissolve. At\n    // least it'll keep people amused. :)\n    vec3 scBgnd = vec3(.8, .6, 1)*.03*max(1.25 - dot(uv, uv), 0.);\n    if(iFrame<=maxFrames){\n\n        vec3 ldCol = loadingScreen(uv, scBgnd);\n        \n        fragColor = vec4(sqrt(max(ldCol, 0.)), 1.);\n        \n        return;\n    }\n\t\n    \n\t// Camera Setup.\n    float tm = iTime/2.;\n\tvec3 ro = vec3(.235, tm/1.5, .25); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.02, .15, 0); // \"Look At\" position.\n    vec3 lp = ro + vec3(0, 1.25, .1);// Put it a bit in front of the camera. \n    #if EDGES > 1\n    lp.xz -= .1;\n    #endif\n    \n    ro.xz *= twist(-(ro.y + 2.*0.));\n    lk.xz *= twist(-(lk.y + 2.*0.));\n \tlp.xz *= twist(-(lk.y + 2.*0.));\n \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    //if(dot(fwd, vec3(fwd.z, 0, -fwd.x))==0.) fwd = normalize(fwd - vec3(0, 0, .00001));\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd));// Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n    \n    // rd - Ray direction.\n    vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV - dot(uv, uv)*.25));\n    // Equivalent to:\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \n    // Slight agitation of the camera about the XZ-plane.\n\t//rd.xz *= rot2(-cos(tm/2.)/2.);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n\n    // Object ID.\n    float svObjID = objID;\n    \n   \n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n        \n        if(svObjID<.5) sn = doBumpMap(sp, sn, .02);///(1. + t/FAR*1.)\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n        \n        vec3 txP = sp;\n        vec3 txN = sn;\n\n        txP.xz *= twist(txP.y);\n        txN.xz *= twist(txP.y);\n        vec3 cntr = vec3(txP.xy, txP.z);\n        \n        vec3 tx = tex3D(iChannel0, txP*2., txN);\n        //vec3 tx = texture(iChannel0, txPat.xy).xyz; tx *= tx;\n        // Texture application.\n        tx = .75 + tx*.5;\n    \n\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n           vec3 uvw = abs(cntr.x)>abs(cntr.z)*1.? vec3(-1, 1, 1)*cntr.zyx : cntr;\n    \n            vec2 uv2 = fract(getUV(uvw)) - .5;\n            // Cube map face one, which contains the rectangle center and\n            // dimension information.\n            vec4 txPat = texture(iChannel2, vec3(-.5, uv2.yx));\n            // Cube map face two, which contains the smooth rectangle distance\n            // field information.\n            vec4 txPat2 = texture(iChannel2, vec3(.5, uv2.y, -uv2.x));\n            \n            // Taking care of cube map wrapping issues... It's one of the annoying\n            // downsides of using cube map faces.\n            txPat.zw = fract((floor(txPat.zw*cubemapRes) + .5)/cubemapRes);\n            vec2 cntr = txPat.zw; // Rectangle center.\n            \n            \n            float rnd = hash21(txPat.zw + .1);\n            float rnd2 = hash21(txPat.zw + .2);\n                \n            // Blinking light variable.    \n            float bl = smoothstep(.9, .95, sin(rnd2*6.2831 + iTime/2.)*.5 + .5);\n        \n            // Rectangle coloring.\n            #if COLOR == 0\n            vec3 tCol = .5 + .45*cos(6.2831*hash21(cntr) + vec3(0, 1, 2));\n            #elif COLOR == 1\n            vec3 tCol = .5 + .45*cos(6.2831*hash21(cntr)/4. + vec3(0, 1, 2)/1.5 + .5);\n            tCol = mix(tCol, tCol.zyx, step(.75, hash21(cntr + .51)));\n            #else\n            vec3 tCol = vec3(.15, .015, 1)*(hash21(cntr + .31) + .5);\n            tCol = mix(tCol, tCol.yxz, hash21(cntr + .51)*.25);\n            tCol = mix(tCol, tCol*4., bl);\n            #endif\n            \n            // Fine tuning then applying the texture.\n            tCol = mix(tCol*2., vec3(1), .25);\n            texCol = tCol*tx;//*(rnd*.8 + .2);//*(rnd*1.95 + .05);//tx*2.\n            \n            //if(svObjID>.5) texCol = mix(texCol, tx*2., .5);\n             \n            vec3 svCol = texCol;\n           \n            // Smooth rectangle distance field value.\n            //float val = bumpSurf3D(sp, sn);\n            float val = getTex1(iChannel2, uvw);\n            \n            // Smoothing factor.\n            float sf = 2./cubemapRes.x;\n            //float df = mix(0., 1., smoothstep(0., sf, (val + sf)));//tx.x\n\n            // Texture coloring overide, just to show it works with those too.\n            //texCol = texture(iChannel1, cntr).xyz; texCol *= texCol*3.;\n\n            texCol = mix(vec3(0), texCol, 1. - smoothstep(0., sf, val + sf));//.25-txPat.x/.1\n\n            /*\n            if(iFrame<maxFrames){\n\n                float df = getTex1(iChannel2, uvw); //ldTex.x>0.? 0. : 1.\n                vec3 bgCol = mix(vec3(.1), vec3(.5), df);\n                texCol = bgCol;\n\n            }\n            */\n            \n\n\n        }\n        else {\n \n             // Repeat cube objects along the rails, partitions, etc.\n            \n            // Repeat calculations. Not pretty, so they'll need a tidy up at some stage.\n            const float sc = 14.;\n            float ew = 1./sc;\n            float dOffs = ew/8.*2./sc;\n            vec3 offs = vec3(.0/sc, .5/sc, .0/sc); // The edge XZ has been moved in by .25/sc.\n            vec3 ip = txP;\n            ip = floor((ip + offs)/(1./sc - vec3(dOffs, 0, dOffs)));\n            txP = abs(mod(txP + offs, 1./sc - vec3(dOffs, 0, dOffs)) - (1./sc - vec3(dOffs, 0, dOffs))/2.);\n            \n            // Cube field.\n            float cb = min(min(max(txP.x, txP.y), max(txP.x, txP.z)), max(txP.y, txP.z));\n            cb -= (.5/sc);\n            \n            // Unique rand IDs for coloring, blinking, etc.\n            float rnd = hash31(ip);\n            float rnd2 = hash31(ip + .7);\n            \n            // Blinking.\n            float bl = smoothstep(.9, .95, sin(rnd2*6.2831 + iTime)*.5 + .5);\n            \n            // ID based colors.\n            #if COLOR == 0\n            vec3 tCol = .5 + .45*cos(6.2831*rnd + vec3(0, 1., 2));\n            #elif COLOR == 1\n            vec3 tCol = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 1, 2)/1.5 + .5);\n            #else\n            vec3 tCol = vec3(.15, .015, 1);\n            tCol = mix(tCol, tCol.yxz, step(.75, hash31(ip + .51)));\n            tCol = mix(tCol, tCol*8., bl);//step(.8, hash21(txPat.xy + .5))\n            #endif\n            \n            // Color refinement and mild texturing.\n            tCol = mix(tCol*1., vec3(1), .25);\n            texCol = tCol*tx*2.;\n            \n            // Applying the colors to the cubes.\n            vec3 svCol = texCol;\n            #if COLOR < 2\n            vec3 cubeCol = tx*2.;\n            #else\n            vec3 cubeCol = tx/6.;\n            #endif\n            //\n            texCol = mix(vec3(0), cubeCol, 1. - smoothstep(0., .001, abs(cb) - .016));\n            texCol = mix(texCol, tCol, 1. - smoothstep(0., .001, (cb + .016 + .007)));\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.25);\n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n        \n   \n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n      \n        // Half vector.\n        vec3 hv = normalize(rd + ld);\n        // Specular Blinn Phong. The last term is highlight power related.\n        float specBF = pow(max(dot(hv, sn), 0.), 4.);\n        \n        // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 32.);\n \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Feel free to look up\n        // the \"science,\" but it essentially takes that annoying central shine out. How\n        // much you take out depends on the material, which is controlled by the material\n        // constant.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .15);\n         \n        #ifdef SHINY\n        // If shininess is flagged, include the specular term.\n        col += spec*freS*8.*sh/(1. + t*t*.5); \n        #endif\n        \n        // Cube map reflection. When I first learned to code graphics, I loved shiny\n        // stuff and went really overboard with it. I still do, but thanks to maturity, \n        // I've learned to hold back on ocassion. :)\n        // Requires a cube map in \"iChannel3\".\n        //vec3 refCol = texture(iChannel3, reflect(rd, sn)).xyz; refCol *= refCol;\n        //col += col*refCol*sh*1.;\n\n        \n        // Shading.\n        col *= ao*atten;\n        \n        // Greyscale value, just in case people switch to the Britney video, etc.\n        // Stylistically, the example works better with color. The Britney video\n        // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n        #ifdef GRAYSCALE\n        col = vec3(1)*dot(col, vec3(.299, .587, .114));\n        #endif\n        \n        #ifdef MAP_DETAIL\n        // Also used for debugging purposes.\n        col = vec3(crv*(sh*.9 + .1)); // ao, sh, etc.\n        #endif\n          \n\t\n\t}\n    \n    \n    // Applying fog.\n    vec3 fogCol = vec3(0);//mix(vec3(.4, .7, 1.2), vec3(.4, .7, 1.2).yxz, rd.y*.5 + .5)*4.;\n    col = mix(col, fogCol, smoothstep(0., .99, t/FAR));\n    \n\n    // Just the displacement map on its own. Actually, this is a bump mapped\n    // version. The texture map itself is quite mundane, which you can see \n    // if you set \"b2\" to 1.\n    #ifdef DISPLACEMENT_MAP\n \n    \n    // Scaling.\n    vec2 p2 = ((fragCoord)/iResolution.y) + iTime/24.;\n  \n    \n    // Cube map texture coordinate conversion.\n    p2 *= cubemapRes;\n    vec2 ip2 = floor(p2); p2 -= ip2;\n    vec2 uv2 = fract((ip2 + .5)/cubemapRes);\n\n            \n    // 2D neighboring texels stored in each of the four texture channels.\n    vec4 tx2 = texture(iChannel2, vec3(-.5, uv2.yx - .5)); \n    vec4 tx3 = texture(iChannel2, vec3(.5, uv.y - .5, -uv.x - .5)); \n   \n    if(iFrame<maxFrames){\n        // Line formation -- Not applicable when using a loading screen.\n        if(tx2.x>.001) col = vec3(.5);\n        else col = vec3(.1);\n    }\n    else { \n \n        vec4 rect = vec4(uv2 - tx2.zw, tx2.xy);//getRect(uv2, tx2);//\n\n        // Taking care of wrapping issues by snapping to the cube map face\n        // pixel positions... I get wrapping issues all the time simply \n        // because I forget to do this.\n        tx2.zw = fract((floor(tx2.zw*cubemapRes) + .5)/cubemapRes);\n\n        // Random rectangle coloring.\n        col = .5 + .45*cos(6.2831*(hash21(tx2.xy)) + vec3(0, 1, 2));\n        col = mix(col, vec3(1), .1);\n        // Background texture.\n        vec3 tx = texture(iChannel0, uv2*4.).xyz; tx *= tx;\n        tx = .8 + tx*.4;\n        col *= tx;\n        vec2 u = fragCoord/iResolution.xy;\n        col *= (pow(16.*u.x*u.y*(1.-u.x)*(1.-u.y), 0.125) + .1);\n        \n        // Texture coloring.\n        //col = texture(iChannel1, tx2.zw).xyz; col *= col*2.;\n        \n        float sf = 1./iResolution.y;\n       \n        // Rectangle distance evaluation. \n        float dff = max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n        vec2 lgt = normalize(vec2(1, 2))/450.;\n        // Offset rectangle calculation for highlighting purposes.\n        rect.xy += lgt;\n        float dff2 = max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n\n        // Bump calculation.\n        float b = max(dff2 - dff, 0.)*450.;//max(.25 - dff/.05, 0.);\n        \n        \n        // Rendering.\n        col = mix(vec3(0), col*(.5 + b*.8), 1. - smoothstep(0., sf, (dff + .003)));\n       \n        // Center circle.\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, length(uv2 - tx2.zw) - .005));\n  \n    }\n    \n   \n     \n    #endif      \n\n\n    // 1.5 second fade-in (assuming 60 FPS) after precalculation.\n    if(iFrame>maxFrames) col = mix(col, scBgnd, max(float(maxFrames + 90 - iFrame), 0.)/90.);\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n\n\nfloat getDF(vec2 uv, vec4 rect){\n    \n    // Rectangle.\n    return sBoxS(rect.xy, rect.zw/2., .0);\n    //return max(abs(rect.x) - rect.z/2., abs(rect.y) - rect.w/2.);\n    \n    // Circles -- One per rectangle.\n     //return length(rect.xy) - min(rect.z, rect.w)/2.;\n    \n    /*\n    // Circles -- Split into two amongst rectangles with more than\n    // a 2:1 ratio.\n    float d = 1e5;;\n    if(rect.z<rect.w){\n    \n       if(rect.z/rect.w<.5){\n       \n          d = length(rect.xy - vec2(0, -rect.w/4.)) - rect.z/2.;\n          d = min(d, length(rect.xy - vec2(0, rect.w/4.)) - rect.z/2.);\n       }\n       else d = length(rect.xy) - rect.z/2.;\n    }\n    else {\n    \n       if(rect.w/rect.z<.5){\n       \n          d = length(rect.xy - vec2(-rect.z/4., 0)) - rect.w/2.;\n          d = min(d, length(rect.xy - vec2(rect.z/4., 0)) - rect.w/2.);\n       }\n       else d = length(rect.xy) - rect.w/2.;\n    }\n    return d;\n    */\n    \n\n}\n \n\n\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace1(vec3 q3){\n   \n    \n    vec4 col = vec4(0);\n    \n    vec2 p;\n    \n    for(int i = 0; i<4; i++){\n        \n        // Texture coordinates for this iteration.\n        p = mod(floor(q3.xy*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n        \n        float df = 0.;\n        \n        if(iFrame == maxFrames){\n            \n            // Rectangle distance field.\n            vec4 tx = tx0(iChannel0, p);\n            tx = vec4(p - tx.zw, tx.xy);\n            df = getDF(p, tx);\n        }\n        /*\n        else {\n            // Lines only.\n            vec2 px = 1./cubemapRes;//iResolution.yy;\n            vec4 cTex = tx0(iChannel0, p);\n            df = 1.;\n            // One pixel width.\n            df = cTex.x>0.? 0. : df;\n            \n            // 2 pixel width... It's better to use the final\n            // field above to get lines only.\n            vec4 cTexL = tx0(iChannel0, (p - vec2(-px.x, 0)));\n            vec4 cTexR = tx0(iChannel0, (p - vec2(px.x, 0)));\n            vec4 cTexB = tx0(iChannel0, (p - vec2(0, -px.y)));\n            vec4 cTexT = tx0(iChannel0, (p - vec2(0, px.y)));\n            df = cTexL.x>0.?  0. : df;\n            df = cTexR.x>0.?  0. : df;\n            df = cTexB.x>0.?  0. : df;\n            df = cTexT.x>0.?  0. : df;\n             \n        }\n        */\n        \n        // Cyberjax's tip to avoid array related compiler annoyances.\n        col.x = df;\n        col = col.yzwx;\n        // The above is equivalent to the following:\n        //col[i] = df;\n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n// Snapping to cube map face 1024x1024 pixel position.\nvec2 conv(vec2 p){ return (floor(p*cubemapRes) + .5)/cubemapRes; }\n\n// The packed rectangle routine: Draw some random dots on the first frame,\n// which are flagged to move either horizontally or vertically. On the \n// next few frames, move them until they hit one of the other lines. After\n// that you'll have a texture full of rectangle borders, so for each pixel\n// not on the line, find the distance to all four rectangle boundaries, and\n// use that information to determine the rectangle center and dimensions.\n//\n// Kind of simple in theory, and annoying to implement, but all doable.\nvec4 funcFace0(vec3 q3){\n    \n      \n   \n    // Coordinates.\n    vec2 p = q3.xy; \n       \n    \n    // Texture samples, and neighboring samples to check for boundary conditions.\n    vec2 px = 1./cubemapRes; \n    vec4 cTex = tx0(iChannel0, p);\n    vec4 cTexL = tx0(iChannel0, (p - vec2(-px.x, 0)));\n    vec4 cTexR = tx0(iChannel0, (p - vec2(px.x, 0)));\n    vec4 cTexB = tx0(iChannel0, (p - vec2(0, -px.y)));\n    vec4 cTexT = tx0(iChannel0, (p - vec2(0, px.y)));\n    \n    vec4 rect = cTex;\n  \n   \n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n      \n        // On the first frame or before the texture has loaded, \n        //plot some random points.\n         \n        vec2 sc = gSc.xy; \n        \n       \n\n        float tOff = 0.;//hash21(fract(iDate.w)*vec2(1.87, 113.53));\n        vec2 ip = floor((p*sc)) + .5;\n        vec2 offs = vec2(hash21(ip + tOff + 3.), hash21(ip + tOff + 7.)) - .5;\n        \n        \n        // Random or heuristic direction:\n        // Direction: 0 (none), 1 (horizontal), or 2 (vertical).\n        // Modulo direction.\n        float rd = mod(floor(ip.x) + floor(ip.y), 2.)<.1? 2. : 1.;\n        #ifdef PSEUDO_RANDOM\n        // Pseudo-pandom direction.\n        if(hash21(ip + .27)<.5) rd = hash21(ip + .17)<.5? 2. : 1.; \n        #endif\n        \n        \n        //ip += offs*.75;\n        ip += floor(offs*5.999*.7)/5.;\n\n        vec2 pp = conv(p - (ip/sc));\n        \n        //float rn = step(.999, rnd3.z);\n        // For accuracy, it's important to have one pixel with lines...\n        // I think this is how you do it. Due to partitioning, this is \n        // necessary, but if you didn't have to worring about that, you'd\n        // simply flag a pixel as on or off.\n        float sq = (max(abs(pp.x), abs(pp.y))< px.y*.501)? 1. : 0.;\n     \n        // Direction: If we've hit an active pixel (see above), flag its\n        // direction as either horzontal or vertical. If not, flag it as\n        // inactive (set it to zero).\n        float dr = sq*rd;\n        \n        // Line ID. Either it's a line, or it's not.\n        float ln = -sq*2.;\n        \n        // Line direction and line ID.\n        rect.xy = vec2(dr, ln);\n       \n \n    }\n    else if(iFrame<maxFrames - 1){\n        \n        float dr = cTex.x; // Direction: 0 (none), 1 (horizontal), or 2 (vertical).\n        float ln = cTex.y; // Line point: Rendered or not.\n\n        // If the pixel has not been rendered, check to the left and right to see if there's\n        // a rendered horizontal pixel, and if so, mark it as a horizontal line pixel.\n        if(dr<.001 && (abs(cTexL.x - 1.)<.001 || abs(cTexR.x - 1.)<.001)){ dr = 1.; ln = -2.; }\n        // Same as above, but for the vertical.\n        if(dr<.001 && (abs(cTexB.x - 2.)<.001 || abs(cTexT.x - 2.)<.001)){ dr = 2.; ln = -2.; }\n        \n        rect.xy = vec2(dr, ln);\n    \n    }\n    else if(iFrame == maxFrames - 1){\n    \n        // If this is not a line pixel, calculate how far it is to the left\n        // and right borders, and also the top and bottom border distances.\n        // Use that information to calculate the rectangle center and dimensions.\n        \n        // Pixels with no line information are flagged as \"-2\" in the Y channel.\n        // I can't remember why I decided that, but it doesn't matter.\n        if(cTex.y>-1.){ \n\n            /////////////////////   \n            float dimL = 0.;\n            float dimR = 0.;\n            float dimB = 0.;\n            float dimT = 0.;\n           \n            // \"While\" loops would ensure that these run to completion,\n            // but I'd imagine the compiler would like these more. I \n            // doubt a rectangle would be larger than a quarter of the\n            // entire 1024 by 1024 texture size, so we should be OK.\n            #ifdef PSEUDO_RANDOM\n            // Longer rectangles are possible with this arrangement.\n            const int n = 384; \n            #else\n            const int n = 280;\n            #endif\n            \n            #define ONE min(1, iFrame)\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexL2 = tx0(iChannel0, p - vec2(-px.x, 0)*fk);\n                if(cTexL2.y>-1.) dimL += 1.;\n                else break;            \n            }\n\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexR2 = tx0(iChannel0, p - vec2(px.x, 0)*fk);\n                if(cTexR2.y>-1.) dimR += 1.;\n                else break;            \n            }\n\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexT2 = tx0(iChannel0, p - vec2(0, px.y)*fk);\n                if(cTexT2.y>-1.) dimT += 1.;\n                else break;\n\n            }            \n\n            for(int k = ONE; k<n; k++){            \n                float fk = float(k);\n                vec4 cTexB2 = tx0(iChannel0, p - vec2(0, -px.y)*fk);\n                if(cTexB2.y>-1.) dimB += 1.;\n                else break;\n            }\n\n\n            // Rectangle width and height.\n            float w = ((dimR + dimL + 1.)/cubemapRes.x);\n            float h = ((dimB + dimT + 1.)/cubemapRes.y);\n\n            // Rectangle center coordinates. And yes, I should have\n            // put these in the X and Y channels... I'll fix that\n            // later.\n            rect.z = p.x - (dimR/cubemapRes.x - w/2.);\n            rect.w = p.y + (dimB/cubemapRes.y - h/2.);\n            \n            //rect.z = conv(dim);\n            //rect.w = conv(df);\n \n            // Rectangle width and height.\n            rect.x = w;\n            rect.y = h;\n            \n            \n        }\n \n    } \n \n    // Rectangle dimenions (in XY) and center position (in ZW).\n    return rect; \n\n\n}\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    // We're only using one cube map face, so don't calculate any others...\n    // or give the annoying compiler a chance to calculate others.\n    if(faceID > 1) return;\n  \n  \n    // Pixel storage.\n    vec4 col = vec4(0);\n    \n    \n    \n    // Precalculation flag: GPUs are annoying. Sometimes, they'll will calculate\n    // both the \"if\" and \"else\" statements every time. The \"if\" part here is extremely\n    // expensive, so we don't want that. The solution is to not have an \"if-else\"\n    // statement at all.\n    int preCalc = 0;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<=maxFrames){\n        \n \n        \n        if(iFrame>maxFrames) return;\n        \n \n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==0){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace0(p);\n            //col = mix(col, 1.-funcFace0(p*2.), 1./16.);\n            \n            preCalc = 1;\n           \n        }\n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==1){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace1(p);\n            //col = mix(col, 1.-funcFace0(p*2.), 1./16.);\n            \n            preCalc = 1;\n           \n        }\n        \n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    \n   \n   \n    if(preCalc == 0 && faceID == 1){\n\n       col = tx1(iChannel0, uv);\n       //col = texture(iChannel0, vec3(-.5, uv.yx - .5));\n       //col = tx(iChannel0, uv, faceID);\n    }    \n    \n    if(preCalc == 0 && faceID == 0){\n\n       col = tx0(iChannel0, uv);\n       //col = texture(iChannel0, vec3(-.5, uv.yx - .5));\n       //col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Make the random horizontal and vertical line direction more random, \n// but not too much. Requires a reset -- Ie. Hit the back button.\n//#define PSEUDO_RANDOM\n\n\n// If you want things to wrap, you need a wrapping scale.  Wrapping is not much \n// different to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash \n// function for anything that's procedurally generated with random numbers. If you're \n// using a repeat texture, then that'll have to wrap too.\nvec3 gSc = vec3(16);\n\n// Maximum frames to perform the precalculation.\n#ifdef PSEUDO_RANDOM\nint maxFrames = 400;\n#else\nint maxFrames = 300;\n#endif\n\n// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n\n/* \n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube iCh, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(iCh, fcP[id]);\n}\n*/\n\nvec2 convert(in vec2 p){\n    \n    /*\n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    return fract((ip + .5)/cubemapRes) - .5;\n    */\n\n    return fract((floor(p*cubemapRes) + .5)/cubemapRes) - .5;\n}\n\nvec4 tx0(samplerCube iCh, vec2 p){\n\n    //p = fract(p);\n    //return texture(iCh, vec3(-.5, p.yx - .5));\n\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(-.5, uv.yx));\n \n}\n\nvec4 tx1(samplerCube iCh, vec2 p){\n\n    vec2 uv = convert(p);\n    return texture(iCh, vec3(.5, uv.y, -uv.x));\n \n}\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// 3x1 hash function.\n//float hash31(vec3 p){ return fract(sin(dot(p, vec3(21.471, 157.897, 113.243)))*45758.5453); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    p = mod(p, gSc.xy);\n    return fract(sin(mod(dot(p, vec2(27.609, 157.583)), 6.2831589))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash21B(vec2 p){\n    \n    return fract(sin(mod(dot(p, vec2(27.609, 157.583)), 6.2831589))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){\n    p = mod(p, gSc);\n    return fract(sin(mod(dot(p, vec3(27.609, 137.583, 57.781)), 6.2831589))*43758.5453); \n}\n\n// IQ's vec2 to float hash.\nvec2 hash22(vec2 p){\n    p = mod(p, gSc.xy);\n    p = vec2(dot(p, vec2(27.609, 157.583)), dot(p, vec2(58.827, 17.443)));\n    return fract(sin(mod(p, 6.2831589))*43758.5453); \n} \n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n   \n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slByDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3227, 3307, 3353, 3353, 4265], [4267, 4309, 4348, 4369, 4778], [4780, 4780, 4799, 4816, 5008], [5011, 5011, 5043, 5043, 5116], [5804, 5804, 5824, 5824, 5848], [5850, 5873, 5891, 5946, 7710], [7717, 7738, 7774, 7823, 8319], [9122, 9313, 9365, 9482, 10802], [10805, 10957, 10993, 10993, 11292], [11511, 11538, 11577, 11577, 12378], [12383, 12574, 12629, 12730, 13993], [13996, 14159, 14218, 14218, 14683], [18108, 18108, 18164, 18254, 31721]], "test": "untested"}
{"id": "stSyzG", "name": "polar coords", "author": "greeffer", "description": "polar coordinates tutorial based on Art of code tutorial\nhttps://youtu.be/r1UOB8NVE8I", "tags": ["2d", "polarcoordinates"], "likes": 0, "viewed": 265, "published": 3, "date": "1649844527", "time_retrieved": "2024-07-30T16:54:12.940838", "image_code": "#define PI 3.14159265359\n#define PI_2 6.2831\n// LEARN \n// Computer graphics use radians instead of degrees for their internal angle calculations.  If you want a refresher on Radians follow the 2 tutorials below\n// https://youtu.be/cgPYLJ-s5II?list=PLbNp-C84uJJVdtYc3yeQhlhv6cCvBBqz8\n// https://youtu.be/yBw67Fb31Cs?list=PLbNp-C84uJJVdtYc3yeQhlhv6cCvBBqz8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //#define PI 3.14159265359\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =   fragCoord / iResolution.xy;\n    \n    // origin starts from bottom left corner.So we have to offset by -0.5 to bring it to the center\n    // e.g https://thebookofshaders.com/glossary/?search=sqrt\n    uv.x -=0.5 ;\n    uv.y -=0.5 ;\n    \n    // but we have an oval instead of a circle ! i.e stretched in x\n    // therefore we need to multiply our x values by the aspect of the image\n    \n    uv.x = uv.x * ( iResolution.x / iResolution.y);\n    \n    // This code would have done everything in one line\n    //vec2 uv =  ( fragCoord -0.5 * iResolution.xy )/ iResolution.y;\n      \n    \n    // Find the pixel distance and angle from the center\n    float pixel_angle = atan(uv.x,uv.y) ;\n    float pixel_distance =  length(uv)* 2.0 ;\n    \n    //alternate way to get pixel distance\n    //float pixel_distance = sqrt(dot(uv,uv) ) * 2.0;\n    vec2 st = vec2(pixel_angle , pixel_distance);//pack the pixel_angle & pixel_distance into a 2 vector for convenience\n    //vec2 st_anim = 1.0 + cos(iGlobalTime );\n\n    // Output to screen using st.y will give us a black -> white radial gradient\n    // which is the distance of each pixel from the center\n    //fragColor = vec4(st.y ); \n    \n    // Output to screen using st.x will give a sweep gradient which is the \n    // Angle of each pixel relative to the center \n    fragColor = vec4(st.x);\n    \n    // but the above does not give us a full Radial sweep.\n    // First we need to calculate angles in radians since our pixel values go from o-1\n    // Instead of 0 - 360 degrees.\n    // We need to remap the values in the 0 - 1 space using radians 6.2831 or 2*PI which is 360 degrees  \n    // Input will be a number from 0 - 360 / 360 i.e we normalize the input by dividing it by 360 \n    // therefore maing the value go from 0 - 1 \n    fragColor = vec4(st.x / PI_2 );\n    \n    //The above will only give you results from 0 to 0.5 (180 degrees) so we add another half 0.5 \n    // Watch this tutorial to understand the range of the atan function\n    // coding math episode 5: https://youtu.be/LHzgW9aQUV8?t=482\n    fragColor = vec4(st.x / PI_2 + 0.5 );// PI_2 is defined to be 6.2831\n    \n    // assing the polar cordinate system mapping to UV mapping \n    vec2 uv2 = st * 0.5;\n    // Introduce a texture using polar cordinate uv's\n    vec3 texColor = texture(iChannel0,uv2).xyz;\n     //Experiment here fragColor = vec4(st.x / PI_2 + 0.5);\n    \n    fragColor = vec4(texColor,1.0); // <- Final color switch // \n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 413, 499, 2956]], "test": "untested"}
{"id": "NtByzG", "name": "Jiggly plasma", "author": "jarble", "description": "A shiny wobbly plasma fractal thing.", "tags": ["fractal", "plasma"], "likes": 1, "viewed": 237, "published": 3, "date": "1649829979", "time_retrieved": "2024-07-30T16:54:13.832454", "image_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c)*v;\n}\n\nvec2 triangle_wave(vec2 a,float num,int iters){\n    a = rotate(a,num*radians(180.));\n    vec2 to_return = abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n    return to_return;\n    //return to_return/(1.5+(iters > 0?1.:0.)*(a.x+a.y)/4.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    float p1 = 1.;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    vec2 t4 = vec2(0.);\n    float rotation_number = 0.;\n    for(int k = 0; k < 12; k++){\n        rotation_number = float(1+k)*1.5;\n        //rotation_number += float(int(uv.x+uv.y)+1+k)*.5;\n\n        uv += t2.yx;\n        t2 = -p1*triangle_wave(uv-.5,rotation_number,k);\n        t3 = p1*triangle_wave(uv.yx,rotation_number,k);\n        t4 = t2-p1*triangle_wave(uv-.5-iTime,rotation_number,k)/8.;\n        uv = t4.y*t2-t4.x*t3;\n        p1 *= -1.;\n        float multiplier = 1.5;\n        col.x = max(uv.y+uv.x-col.x,col.x)/multiplier;\n        //col.x = max(((uv.y+uv.x)-col.x)/multiplier,col.x*multiplier);\n        //col.x = max(uv.y*(1.25)+uv.x/(1.25)-col.x,col.x);\n        //col.x = max(uv.y+uv.x-col.x,col.x*multiplier)/multiplier;\n\n        col = abs(col.yzx-vec3(1.-col.x))/multiplier;\n        uv /= scale;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtByzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 99], [101, 101, 148, 148, 328], [330, 330, 387, 387, 1552]], "test": "untested"}
{"id": "wsdfDn", "name": "earthbound shader 1", "author": "itblursby", "description": "A shader in the earthbound style", "tags": ["earthbound"], "likes": 3, "viewed": 257, "published": 3, "date": "1649825398", "time_retrieved": "2024-07-30T16:54:14.684177", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    vec2 uv = fragCoord-vec2(iResolution.xy/2.0);\n    uv = 2.0*uv/iResolution.y;\n   \tfloat magnitude = length(uv);\n\n\n    uv = uv/(1.0+length(uv));\n    float pixel;\n    if (mod(fragCoord.x,2.0)<1.0){\n        uv.x = uv.x+(0.1*sin(uv.y*10.0))*sin(iTime);\n    \tpixel = sign((mod(uv.y+iTime*0.04,0.2)-0.1))*sign((mod(uv.x+(iTime*0.12),0.2)-0.1));\n    }else{\n        uv.x = uv.x+(-0.1*sin(uv.y*10.0))*sin(iTime);\n\t\tpixel = sign((mod(uv.y+iTime*-0.05,0.2)-0.1))*sign((mod(uv.x+(iTime*-0.2),0.2)-0.1));\n\n    }\n    fragColor = vec4(0.4,0.2,0.5,1.0);\n    if (pixel == 1.0){\n    \tfragColor=vec4(0.0,0.5,0.5,1.0);\n        //fragColor = vec4(texture(iChannel1,p).xyz,1.0);\n    }\n    //vec3 color = texture(iChannel1,p).xyz;\n    //fragColor = vec4(texture(iChannel1,p).xyz,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 875]], "test": "untested"}
{"id": "7ljcDw", "name": "Hexagon Hole Thing", "author": "SnoopethDuckDuck", "description": "very messy code", "tags": ["e"], "likes": 18, "viewed": 245, "published": 3, "date": "1649813220", "time_retrieved": "2024-07-30T16:54:15.516950", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float d = length(p + 0.*thc(2., (p.x + p.y + p.z) + iTime)) - 1.5;\n    \n    float pd =min( abs(p.x-p.y), abs(p.z - p.x));\n    pd = min(pd, abs(p.y-p.z));\n    \n    p = erot(p, normalize(vec3(1)), -0.8 * iTime);\n    float e = 2. * pi / 3.;\n    p = erot(p, normalize(2. - cos(iTime + (0.5 + 0.5 * thc(4.,0.25 * iTime)) * vec3(0,e,-e))*p), pi + 0. * iTime);\n    //p *= 1.5 + 0.5 * cos(iTime);\n    pd = abs(p.x + p.y + p.z)-0.1;\n    float a = 2. * pi / 6.;\n  //  p.xy *= Rot(a);\n   // p.yz *= Rot(a);\n   // p.zx *= Rot(a);\n    \n    float sc = 16.;\n    float o = 1. * (p.y + p.x + p.z);\n    float d2 = cos(sc * (p.x - p.y) + o)\n             + cos(sc * (p.y - p.z) + o)\n             + cos(sc * (p.z - p.x) + o);\n    //d += 0.1 * d2;\n    //d = 0.1 * d2 + pd;//0.1* pd * pd;\n    d = max(pd + smoothstep(0.,1., 3.5-dot(p,p)) * 0.12 * d2, length(p) - 2.);\n    return 0.1 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        vec3 e = vec3(0.5);\n        col *= pal(length(p) * 0.25 + 1.2,e,e,e,0.5*vec3(0,1,2)/3.);\n        \n        col += 0.01 * (n-1.);\n        \n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col += fresnel;\n        float fresnel2 = pow(1.+dot(rd, n), 5.); \n       // col *= 0.5 + 0.5 * fresnel2;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 716], [718, 718, 741, 741, 1612], [1614, 1614, 1657, 1657, 1964], [1966, 1966, 1990, 1990, 2180], [2182, 2182, 2232, 2232, 2423], [2425, 2425, 2482, 2482, 3561]], "test": "untested"}
{"id": "7tjcDw", "name": "ahogado n2", "author": "jorge2017a2", "description": "ahogado n2", "tags": ["ahogadon2"], "likes": 4, "viewed": 235, "published": 3, "date": "1649809952", "time_retrieved": "2024-07-30T16:54:16.394604", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///ahogado n2--12-abril-2022\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.5),b,d)\n//#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{ p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n   float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n\nfloat onda1(vec2 p)\n{   float t=iTime*5.0;\n    float d1=p.y+ sin(p.x*0.5+0.8*(cos(t-p.x+p.y/2.0)));\n    t=2.0;\n    float d2=p.y+ sin(p.x*0.5+0.8*(cos(t-p.x+p.y/2.0)));\n    return d1+d2;\n}\n\nfloat onda2(vec2 p)\n{   float t=iTime*5.0;\n    float d1=p.y+ sin(p.x*0.5+0.8*(cos(t-p.x+p.y/2.0)));\n    t=2.0;\n    float d2=p.y+ 4.0*sin(p.x*0.5+0.8+d1);\n    return d1+d2;\n}\n\n\nfloat onda3(vec2 p)\n{   float t=iTime*5.0;\n    float d1=p.y+ sin(p.x*0.5+0.8*(cos(t-p.x+p.y/2.0)));\n    t=2.0;\n    float d2=p.y+ 4.0*sin(-p.x+0.4*d1);\n    return d1+d2;\n}\n\nfloat onda(vec2 p)\n{   float t=iTime*5.0;\n    float d1=p.y+ sin(p.x*0.5+t);\n    t=2.0;\n    float d2=p.y+ 4.0*sin(-p.x+2.4*d1*cos(t));\n    return d1+d2;\n}\n\n\n\nvec3 Rostro(vec2 p, vec3 colOut)\n{\n   vec2 p0=p;\n   float d1=onda(vec2(-p.x,-p.y)*2.0);\n   float d2rostro=sdCircle( p,4.0 );\n   float dinter=intersectSDF(d2rostro,d1);\n   \n   float t=iTime;\n   float movx=sin(t);\n   vec2 pmov=vec2(movx,0.0);\n   float d3ojoa= sdTunnel(p+pmov-vec2(-1.2,0.0), vec2(1.0,1.5) );\n   float d3ojob= sdTunnel(p+pmov-vec2( 1.2,0.0), vec2(1.0,1.5) );\n   float d4pupilaa=sdCircle(p+pmov-vec2(-1.5,-1.0),0.5 );\n   float d4pupilab=sdCircle(p+pmov-vec2(1.5,-1.0),0.5 );\n   p=p0;\n   \n   vec2 a=vec2(0.0,0.0);\n   vec2 b=vec2(2.0,0.0);\n   \n   float d5boca= sdSegment(p+pmov-vec2(-1.0,-2.4),a, b );\n   \n   vec3 col;\n   col= DrawFigBorde(vec3(0.7,0.5,0.3), colOut, d2rostro);\n   col= DrawFigBorde(vec3(1.0), col, d3ojoa);\n   col= DrawFigBorde(vec3(1.0), col, d3ojob);\n   col= DrawFigBorde(vec3(0.0), col, d4pupilaa);\n   col= DrawFigBorde(vec3(0.0), col, d4pupilab);\n   col= DrawFigBorde(vec3(0.2), col, dinter);\n   col= DrawFigBorde(vec3(1.0,0.2,0.2), col, d5boca-0.2);\n   return col; \n}\n\nvec3 olas001(vec2 p, vec3 colOut)\n{  float d1= onda1(p);\n   vec3 col= DrawFigBorde(vec3(0.2,0.1,1.0), colOut, d1);\n   return col; \n}\n\nvec3 olas002(vec2 p, vec3 colOut)\n{  float d2=onda( p-vec2(0.0,3.0));\n   vec3 col= DrawFigBorde(vec3(0.2,0.1,0.8), colOut, d2);\n   return col; \n}\n\nvec3 olas003(vec2 p, vec3 colOut)\n{  float d2=onda2( p-vec2(0.0,4.0));\n   vec3 col= DrawFigBorde(vec3(0.3,0.2,0.8), colOut, d2);\n   return col; \n}\n\nvec3 olas004(vec2 p, vec3 colOut)\n{  float d2=onda3( p-vec2(0.0,5.5));\n   vec3 col= DrawFigBorde(vec3(0.1,0.2,0.8), colOut, d2);\n   return col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=8.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    //vec3 col=vec3(0.0,0.1,0.8);\n    vec3 col=vec3(0.0,0.0,0.8)*(1.0-(uv.y/esc)*0.45);\n \n    float t=5.0*sin(iTime);\n    col= olas004(uv,col);\n    col= olas003(uv, col);\n    col= olas002(uv, col);\n    \n    col= Rostro(uv-vec2(0.0,2.8), col);\n    col= olas001(uv-vec2(0.5+t,0.0), col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//// fork --Colored noise (sound)----Created by athibaul in 2021-02-11\n//https://www.shadertoy.com/view/tttfRj\n#define TAU (2.*3.1415926)\n\n#define PI acos(-1.)\n#define PIH (PI * .5)\n///#define TAU (PI * 2.)\n#define osc_sin(x) sin((x) * TAU)\n#define osc_saw(x) (1. - fract(x) * 2.)\n#define osc_sqr(x) sign(.5 - fract(x))\n#define osc_tri(x) (asin(sin((x) * PI)) / PIH)\n \n \nfloat rand(float p)\n{   // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    //sf = sf*sf*sf*(sf*(sf*6.0-15.0)+10.0); // quintic curve\n    // see https://iquilezles.org/articles/texture\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    // Modulate df-wide noise by an fc-frequency sinusoid\n    float f0a=TAU*fc*fract(t);\n    float f0=sin(f0a+cos(f0a*2.0));\n    float f1=noise(t*df);\n    float f2=osc_saw(t*df*2.0);   \n    return 2.0*f2+f0;  //trumpeta\n    \n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    float v = 0.;\n    float t = time;\n    float fc = 50.*pow(100.,rand(floor(t)));\n    \n    float df = rand(floor(t)+0.5)*fc;\n    v += 0.1*coloredNoise(t, fc, df);\n    v *= smoothstep(0.,0.1,fract(t)) * smoothstep(1.0,0.9,fract(t));\n    return vec2(v);\n}", "sound_code": "// See Common tab", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 328, 364, 364, 409], [415, 415, 462, 462, 489], [490, 490, 533, 533, 560], [561, 561, 609, 609, 637], [639, 639, 701, 701, 831], [833, 833, 870, 870, 944], [946, 946, 981, 981, 1004], [1006, 1006, 1058, 1058, 1174], [1176, 1176, 1201, 1201, 1220], [1221, 1221, 1246, 1246, 1265], [1266, 1266, 1302, 1302, 1330], [1333, 1333, 1374, 1374, 1632], [1635, 1635, 1656, 1656, 1822], [1824, 1824, 1845, 1845, 1997], [2000, 2000, 2021, 2021, 2170], [2172, 2172, 2192, 2192, 2325], [2329, 2329, 2363, 2363, 3329], [3331, 3331, 3366, 3366, 3463], [3465, 3465, 3500, 3500, 3610], [3612, 3612, 3647, 3647, 3758], [3760, 3760, 3795, 3795, 3906], [3908, 3908, 3965, 3965, 4488]], "test": "untested"}
{"id": "sljcDw", "name": "smokey shizzle", "author": "xenn", "description": "I just love Florien's advection. Teertering around the threshold of transition with this cool custom mandelbox.\nThe effect appears to break down at higher resolutions, but that could just the (lack of) grunt in my GPU.", "tags": ["fractal", "gi", "dof", "bloom", "depthoffield", "ao", "mandelbox"], "likes": 19, "viewed": 856, "published": 3, "date": "1649809698", "time_retrieved": "2024-07-30T16:54:17.724050", "image_code": "\n// Fork of \"Weird mandelbox\" by loicvdb. https://shadertoy.com/view/3t3GWH\n// 2021-06-06 02:02:38\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    \n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\n// Fork of \"Psynthetika\" by xenn. https://shadertoy.com/view/fdKGDy\n// 2021-09-29 06:32:00\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm2(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 0.0 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n    \n    \n    float noise = .9 + randomFloat()*.15;\n//  \tfragColor = vec4(ACESFilm(color*noise), 1.0);\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 frogColor;\n    vec4 frigColor;\n    vec3 col = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.1 * iResolution.y, .9, fragCoord) * .2\n        \t\t  + bloom(.2 * iResolution.y, .5, fragCoord) * .2;\n//    frogColor = vec4(ACESFilm(color*noise), 1.0);\n//    frigColor = mix(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0),(1.0 * abs(sin(iTime * .50))));\n        frogColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n        frigColor = min(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n\nfragColor = mix(frigColor,frogColor,1.0-(0.999*(cos(iTime/3.14159265359))));\n// fragColor = max(vec4(ACESFilm(col + bloomSum), 1.0),vec4(ACESFilm2(color*noise), 1.0));\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MaxSteps 64\n#define MaxShadowSteps 32\n#define AmbientLightSteps 14\n#define MaxDist 2.0\n#define MinDist .015\n#define GIStrength .93\n#define AOStrength .3\n\nvec3 CamPos = vec3(0, 0, -17.);\nvec3 CamRot = vec3(0);\nfloat CamFocalLength = 1.5;\n\nvec3 LightDir;\nvec3 LightColor = vec3(.7, .5, .3) * 10.;\nfloat LightRadius = .05;\n\nfloat Scale = 2.25;\nfloat Radius = .5;\nint Iterations = 9;\nmat3 Rotation;\n\nfloat distanceEstimation(vec3 position){\n    position *= Rotation;\n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 2) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec3 normalEstimation(vec3 pos, float dist){\n  vec2 k = vec2(dist, 0);\n  return normalize(vec3(distanceEstimation(pos + k.xyy),\n\t  \t\t\t\t\tdistanceEstimation(pos + k.yxy),\n  \t\t\t\t\t\tdistanceEstimation(pos + k.yyx))\n\t\t\t\t - vec3(dist));\n}\nvec3 normalEstimation(vec3 pos){\n  float dist = distanceEstimation(pos);\n  return normalEstimation(pos, dist);\n}\n\nvec3 backgroundColor(vec3 dir){\n    return texture(iChannel0, dir).rgb;\n}\n\n//blurred cubemap for ambient lighting\nvec3 backgroundColorHemi(vec3 dir){\n    return textureLod(iChannel0, dir, 9.5).rgb;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\nvec3 ambientLight(vec3 pos){\n    vec3 pos0 = pos;\n    float dist0 = distanceEstimation(pos);\n    vec3 normal = normalEstimation(pos).xyz, gi, al = vec3(0.0);\n    float ao = 1., dist = dist0;\n    for(int i = 0; i < AmbientLightSteps; i++){\n        float expectedDist = dist * (1. + .8);\n        dist = distanceEstimation(pos);\n        float weight = AOStrength*(1.-float(i)/float(AmbientLightSteps));\t//more weight to first samples\n        ao *= pow(clamp(dist/expectedDist, 0., 1.0), weight);\n        normal = normalize(normalEstimation(pos, dist)+1.5*normal); //\"smoothed\" normal to avoid artifacts\n        pos += normal * .8*dist; //slightly shorter to avoid artifacts\n        al += backgroundColorHemi(normal);\n        if(i == 6 || i == 13) gi += ao*directLight(pos, normal); // two GI samples\n    }\n    gi *= GIStrength/2.0;\n    return gi + al/float(AmbientLightSteps) * ao;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 n){\n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            n = normalEstimation(pos);\n            for(int j = 0; j < 3; j++){\n                dist = distanceEstimation(pos) - 2.*MinDist;\n        \t\tpos += dist * dir;\n            }\n            return true;\n        }\n        pos += dir * dist;\n    }\n    return false;\n}\n\n\nvec4 rayTrace(vec3 pos, vec3 dir){\n    for(int i = 0; i < 5; i++){ //to get to a distance inferior to MaxDist\n        float dist = distanceEstimation(pos);\n        pos += dist * dir;\n        if(dist < MaxDist) break;\n    }\n    vec3 n;\n    if(!trace(pos, dir, n))\n        return vec4(backgroundColor(dir), 20.0);\n    return vec4(directLight(pos, n)+ambientLight(pos), length(CamPos - pos));\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime + 43.;\n    \n    //fractal animation\n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n    //light animation\n    LightDir = normalize(vec3(sin(time*.6), -1, cos(time*.6)));\n    \n    //camera animation\n    CamRot.z = sin(time*.4)*.2;\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n\n    fragColor = rayTrace(CamPos, rayDir);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//extremely basic atmosphere\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 col = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor + vec3(1.2) * (1.0-factor);\n    fragColor = vec4(col, 1.0);\n//}\n// float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;\n\tvec3 coloro = vec3(.5 + (-0.5 * cos(iTime)), .5 + (0.5 * sin(iTime)), .5 + (0.5 * cos(iTime))) * factor * vec3(1.2) * (1.0+factor);\n//    fragColor = vec4(col, 1.0);\n//void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n//{\n    vec3 skyCol = vec3(80,180,255)/ 255.0;\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n//    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    vec3 groundCol = coloro;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 colo = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//first DoF pass\n\n#define Aperture .025\n#define DoFClamping .35\n#define DoFSamples 64\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//second DoF pass\n\n#define Aperture .025\n#define DoFClamping .35\n#define DoFSamples 64\n\n#define dir normalize(vec2(1.0, -1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //autofocus\n    float focalDistance = texture(iChannel0, vec2(.5), 5.0).a;\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        dr = min(abs(p.a-focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Pi  3.14159265359\n\n#define FocalDistance 1.4\n#define LensRatio 3.5\n#define Margins .0\n\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * .05;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * .5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n", "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  col = clamp(col, 0., 1.);\n  col2 = clamp(col2, 0., 1.);\n  col3 = clamp(col3, 0., 1.);\n//  col = max(col,col2);\n//  col2= min(col,col2);\n  vec4 blend = mix(col,col2,0.025+(0.025*sin(iTime/2.)));\n  blend = mix(blend,col3,0.025+(0.025*cos(iTime/3.)));\n // blend = (blend*0.5)* ((max(col,blend))*0.5)+ ((min(col,blend))*0.5);\n  blend = clamp(blend, 0., 1.);\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 123, 123, 263], [265, 265, 322, 322, 627], [792, 792, 812, 812, 891], [893, 893, 917, 917, 1057], [1059, 1059, 1116, 1116, 2583]], "test": "untested"}
{"id": "7tScDm", "name": "Messy Thing 8349242", "author": "SnoopethDuckDuck", "description": "the code is a mess, and full of theft, read at your own risk", "tags": ["e"], "likes": 3, "viewed": 236, "published": 3, "date": "1649793463", "time_retrieved": "2024-07-30T16:54:18.563804", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0.01, -6);\n   // ro.yz *= Rot(-m.y*3.14+1.);\n  // ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat test(vec3 p, float sc) {\n   //sc /= 2. * pi;\n    float f = thc(1.5, sc * p.x) \n            + thc(1.5, sc * p.y)\n            + thc(1.5, sc * p.z);\n    f = 0.5 + 0.5 * f;\n    return 0.1 * pow(4. * f * (1.-f), 3.);\n}\nfloat GetDist(vec3 p) {\n  \n//    float v = simplex3d_fractal(p + vec3(0. * iTime,0,0));\n    p.xz *= Rot(0.2 * iTime);// + 0.5 * pi * cos(0.5 * p.y + 0.4 * iTime));\n\n\n    float  d = length(p + 1. * vec3(thc(3.,0.1 * p.y + iTime),0,ths(3.,0.1*p.y+iTime))) - 0.8;\n    float d2;\n    \n    float m = 2.;\n    float v = 1.5 + 0.5 * cos(0.2 * iTime);\n    for (float i = 0.; i < 7.; i++) {\n        d2 += (1./m) * test(p, m);\n        m *= v ;\n    }\n    \n    d += 0.05 * d2;\n    \n    return 0.1 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n            vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float t = 0.4 * iTime;\n        vec3 lp = vec3(cos(t), 2, sin(t));\n        float dif = 0.3 + 0.7 * dot(n, normalize(lp));//*.5+.5;\n        col = vec3(dif);\n        float v = simplex3d_fractal(p);\n        \n       // v = texture(\n       \n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col += fresnel;\n        float fresnel2 = pow(1.+dot(rd, n), 3.); \n        //col += 20. * fresnel2;\n        col = 1. - col;\n        col = clamp(col,0.,1.);\n        //col *= 1000. * fresnel2;\n        col *= 0.5 + 0.5 * v;\n        col = 1. - col;\n        col += fresnel2;\n        col *= 0.5 + 0.5 * n.y;\n    }\n    vec3 e = vec3(0.5);\n\n    col += pal(exp(-0.2 * length(p.xz)),e,e,e,0.5*vec3(0,1,2)/3.);\n    col *= 4. * exp(-0. * abs(p.y) - 2.5 * abs(thc(4.,-iTime + 4. * p.y)));\n    col *= exp(-0.1 * length(p));\n    col += vec3(0.2,0.2,0.5) * step(10., length(p.xz)) * exp(1.-0.1 * abs(p.y));\t// gamma correction  \n    col = pow(col, vec3(.4545)); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tScDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 141, 163, 163, 336], [443, 466, 491, 744, 1661], [1931, 1998, 2031, 2031, 2178], [2236, 2236, 2266, 2266, 2342], [2344, 2344, 2382, 2382, 2447], [2449, 2449, 2468, 2468, 2551], [2553, 2553, 2582, 2582, 2663], [2665, 2665, 2679, 2679, 2835], [2837, 2837, 2867, 2887, 3056], [3057, 3057, 3080, 3144, 3546], [3548, 3548, 3591, 3591, 3898], [3900, 3900, 3924, 3924, 4114], [4116, 4116, 4166, 4166, 4357], [4359, 4359, 4416, 4416, 5978]], "test": "untested"}
{"id": "Nl2yWm", "name": "Shadef**k", "author": "tungster24", "description": "Crappy attempt at an esoteric shader... Those loops certainly need some work.\nAnyways, the default code makes a 10 by 10 (each \"block\" is 10 by 10 pixels) square because I literally cannot make anything more complicated with it :) enjoy.", "tags": ["language", "esoteric"], "likes": 0, "viewed": 195, "published": 3, "date": "1649791312", "time_retrieved": "2024-07-30T16:54:19.567121", "image_code": "/*\nSHADEF**K\n\na (barely) esoteric language for shaders\n\nYou're given a few basic commands, a pointer, and a single memory.\n\nU,D,L,R: Moves pointer by one pixel up,down,left,right respetively.\n\nINC,DEC: Increment/Decrement cell by one.\nRED: Read value at current cell.\n\nMEM: shortcut for the memory value.\nMS: sets memory to a specific value.\n\nC(a): will only work if the given value is equal to the memory\n\nRE: will repeat as much as the value in memory, you can use I if you want.\n\nB: will exit the repeat.\n\ngood luck :)\n*/\n\n#define U ptr.y++;\n#define D ptr.y--;\n#define R ptr.x++;\n#define L ptr.x--;\n#define INC if(ivec2(POS) == ptr) {COL += vec4(vec3(1.0/255.0),0.0);}\n#define DEC if(ivec2(POS) == ptr) {COL -= vec4(vec3(1.0/255.0),0.0);}\n#define RED memory = int(COL.r*255.0);\n#define MEM memory\n#define MS(a) memory = a;\n#define C(a) if(memory == a)\n#define RE for(int i = 0;i<memory;i++)\n#define B break;\n\nvoid mainImage( out vec4 COL, in vec2 POS )\n{\n    int memory;\n    POS /= 10.0;\n    ivec2 ptr = ivec2(iResolution.xy)/20;\n    COL = vec4(0.0);\n    \n    //CODE GOES HERE:\n    \n    MS(10) RE{\n        MS(10) RE{\n            MS(255)\n            RE { INC }\n            D\n            MS(10)\n        }\n        RE { U }\n        L\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2yWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtjcWw", "name": "FireGenerative", "author": "deni_de", "description": "stylized fire animation", "tags": ["noise", "fire", "generative"], "likes": 4, "viewed": 264, "published": 3, "date": "1649790901", "time_retrieved": "2024-07-30T16:54:20.371969", "image_code": "#define PI 3.14159265359\n#define Amplitude 0.21\n#define Wavelength 4.0\n#define Speed 0.31\n#define Warm_c vec3(1.0,0.21,0.07)\n#define Hot_c vec3(0.9,1.0,0.1)\n\nfloat random (vec2 uv) \n{\n    return fract(sin(dot(uv.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy,\n          ps = 1. / iResolution.xy;\n    \n              \n    uv.xy += vec2(-0.5, 0.3);\n    uv = abs(uv);\n    uv.x *= 5.;\n    \n    float K = 14. * PI / Wavelength;\n    uv.x += cos(uv.y + iTime + abs(random(uv) * 0.09)) * 0.6;\n    \n    uv.x -=  Amplitude                         * sin(K * (uv.y  - Speed * (iTime * 4.1)));\n    uv.y += (Amplitude     *(random(uv) * 0.6))  * cos(K * (uv.x  + Speed * (iTime * 8.1)));\n    uv.x -= (Amplitude * 1. *(random(uv) * 0.7))  * sin(K * (uv.y  - Speed * (iTime * 2.1)));\n    uv.x *= uv.y;   \n    \n    float d = 0.0;                \n    d = length(abs(uv)-.5);\n    float corner = 1. - floor(d * 7.) * d;\n    d = fract(d * 7.);\n    \n    vec3 color = mix(Warm_c,Hot_c,corner);\n    \n    fragColor =  vec4(color + corner , 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 183, 183, 255], [257, 257, 314, 314, 1119]], "test": "untested"}
{"id": "fl2yDw", "name": "Peephole", "author": "kbx", "description": "spying on claude...", "tags": ["video", "effect", "vingette"], "likes": 1, "viewed": 198, "published": 3, "date": "1649784714", "time_retrieved": "2024-07-30T16:54:21.457068", "image_code": "#define VIG 0.4\n#define IPO 0.1\n\nvec3 tex2D(sampler2D _tex, vec2 _p) {\n  vec3 col = texture(_tex, _p).xyz;\n  if (0.5 < abs(_p.x - 0.5)) {\n    col = vec3(0.1);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = fragCoord / iResolution.xy;\n  vec3 col = tex2D(iChannel0, uv);\n  vec3 vig = vec3(1);\n\n  float b = 1. - VIG;\n  \n  vig -= vec3(smoothstep(VIG,0.0, uv.x) + IPO);\n  vig -= vec3(smoothstep(b,1.0, uv.x) + IPO);\n\n  vig -= vec3(smoothstep(VIG,0.0, uv.y) + IPO);\n  vig -= vec3(smoothstep(b,1.0, uv.y) + IPO);\n  \n  col *= vig;\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2yDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 70, 70, 178], [180, 180, 235, 235, 597]], "test": "untested"}
{"id": "NljyWw", "name": "Ferns and Other Fun Shapes", "author": "DJDoomz", "description": "hello", "tags": ["2d", "fractal", "feedback", "buffer", "barnsleyfern"], "likes": 2, "viewed": 201, "published": 3, "date": "1649780266", "time_retrieved": "2024-07-30T16:54:22.262914", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265\n\nmat2 rot(in float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec4 last = texture(iChannel0, fragCoord/iResolution.xy);\n    //draw a stupid point somewhere\n    vec2 seed = vec2(0);\n    vec4 new = vec4(smoothstep(1.5/iResolution.y, 0., length(uv - seed)));\n    //4 copies\n    //1 - squished to line in center\n    vec2 cuv = uv;\n    cuv *= vec2(40., 3. );\n    cuv += vec2(0, .75);\n    new += texture(iChannel0, cuv);\n    \n    //2 - rotated left and shifted left\n    cuv = uv;\n    cuv *= rot(-PI/2.0);\n    cuv *= 2.8;\n    cuv += .5;\n    cuv += vec2(0.8, -.5);\n    new += texture(iChannel0, cuv);\n    \n    //3 - shfifted up and rotated a bit right, scaled down\n    cuv = uv;\n    cuv *= rot(.1 + sin(.1*iTime));\n    cuv *= 1.2;\n    cuv += .5;\n    cuv += vec2(-0.04, -.05);\n    new += texture(iChannel0, cuv);\n    \n    //4 - rotated right and shifted right\n    cuv = uv;\n    cuv *= rot(PI/2.0);\n    cuv *= 2.8;\n    cuv += .5;\n    cuv += vec2(-1., -.3);\n    new += texture(iChannel0, cuv);\n\n    fragColor = clamp(.4*last + new, 0., 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 122]], "test": "untested"}
{"id": "NtjyWw", "name": "Integer Hash - II - vec3→vec3", "author": "FabriceNeyret2", "description": "convenient trivial variant of IQ's https://shadertoy.com/view/XlXcW4  eating vec3.\nAny scalings and signing work. padding 0 as extra seeds is ok.\n\nsee also: vec2→float https://www.shadertoy.com/view/fsKBzw", "tags": ["2d", "hash"], "likes": 16, "viewed": 871, "published": 3, "date": "1649779909", "time_retrieved": "2024-07-30T16:54:23.044823", "image_code": "// Fork of \"Integer Hash - II\" by iq. https://shadertoy.com/view/XlXcW4\n\n// 2017 Inigo Quilez\n\n// Based on https://www.shadertoy.com/view/4tfyW4, but simpler and faster\n//\n// See these too: \n//\n// - https://www.shadertoy.com/view/llGSzw\n// - https://www.shadertoy.com/view/XlXcW4\n// - https://www.shadertoy.com/view/4tXyWN\n//\n// Not testes for uniformity, stratification, periodicity or whatever. Use (or not!) at your own risk\n\n\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 uhash3( uvec3 x )         // iq version\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)/float(0xffffffffU);\n}\n\n\nvec3 hash( vec3 f )            // $FaN: vec3 to vec3. any scaling. f.z=0 seed is ok.\n{ \n    return uhash3( floatBitsToUint(f) );\n // return uhash3( uvec3( floatBitsToUint(f.x),\n //                       floatBitsToUint(f.y),\n //                       floatBitsToUint(f.z) ) );\n}\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy/2.,\n         U = ( 2.* u - R ) / R.y;\n         \n    O.rgb = hash(1e-5*vec3(U,iTime));  // histograms are ok whatever the scaling\n // O.rgb = hash(1e 5*vec3(U,iTime));\n // O.rgb = hash(     vec3(U,iTime));\n // O = vec4( hash(vec3(U,0)).r );     // 0 extra seed is ok\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 676, 722, 722, 849], [852, 852, 938, 938, 1130], [1131, 1131, 1169, 1169, 1470]], "test": "untested"}
{"id": "7lBcWm", "name": "Stitched Stars", "author": "eiffie", "description": "Pushing floats to do more spiral thingies.", "tags": ["eulerspirals"], "likes": 13, "viewed": 317, "published": 3, "date": "1649775245", "time_retrieved": "2024-07-30T16:54:23.806787", "image_code": "//stitched stars by eiffie, using emulated doubles still had some drift\n//so I carefully (ok hamfistedly) reduced most of the math using mods\n//to stop precision loss with floats. It has to calculate 7500^3 + a fraction.\n//Of course each point of the star is the same so I could have just done 1/5\n//and rotate 2pi/5 but then where is the challenge?\nvoid mainImage(out vec4 O, in vec2 U){\n  O=sqrt(texture(iChannel0,U/iResolution.xy)*2.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//1498 unique stars made of 7500 stitches, well 4/5ths of 1498 anyway\n#define DIV 1499.\n//50 stitches per frame\n#define PTS 50.\n#define R iResolution\n\nconst float pi2=6.283185;\nfloat rand(vec2 U){return fract(sin(dot(U,vec2(113.,117.)))*412.143);}\nvec4 shad(vec2 U){U/=R.xy;vec2 su=sin(U*5.);return vec4(.8)+vec4(.4,.2,.1,0.)*sin((U.x+U.y*1.6)*5.+pi2*su.x*su.y);}\nvec4 BG(vec2 U){//background texture\n  vec4 c=vec4(0.01,.03,.06,.0)*(sin(mod(U.x,pi2))*sin(mod(U.y,pi2))+1.)*(0.5+0.5*rand(U));\n  return c*shad(U);\n}\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),.25,.75));}\nvec3 cmap(float a){return abs(vec3(sin(a),sin(a+1.),sin(a+1.7)));}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 u=floor(U);\n  bool bLogic=(u.y<1. && u.x<3.);u=U;//3 state pixels\n  float iF=max(0.,float(iFrame)-1.);//setup figure, start step\n  float steps=ceil(DIV*5./PTS)*PTS,start=iF*PTS,fig=1.+floor(start/steps);\n  start=mod(start,steps);\n  //L0,L1 mnx,mxx,mny,mxy for centering and scaling, 2 xyxy last positions\n  vec4 L0=texture(iChannel0,vec2(.5)/R.xy);//load logic\n  vec4 L1=texture(iChannel0,vec2(1.5,.5)/R.xy);\n  vec4 L2=texture(iChannel0,vec2(2.5,.5)/R.xy);\n  if(iF==0.){//first frame\n    O=BG(U);L0=vec4(-23,23,-23,23);L1=vec4(0);L2=vec4(0.,R.y*.2,0.,0.);\n  }else if(start==0.){//new figure\n    float s=-.5*R.y/(L1.w-L1.z);\n    L2=vec4((L1.y+L1.x)*s,(L1.w+L1.z)*s,0.,0.);L0=L1;L1=vec4(0);\n    O=((U.x>R.x/2.)&&(mod(fig,5.)!=1.)?texture(iChannel0,U/R.xy-vec2(.5,0.)):BG(U));\n  }else O=texture(iChannel0,U/R.xy);\n  if(mod(fig,5.)>.5){if(U.x>R.x/2.)return;U-=R.xy*vec2(.25,.5);}\n  else U=(U-R.xy*.5)*1.5;\n  float scl=.45*R.x/(L0.w-L0.z),a,b,b2;//scale the star to the screen\n  vec2 oL=L2.xy;//previous point for line drawing\n  for(float i=start;i<start+PTS;i+=1.){//formula: 2*pi*fig/DIV*(i*i*i+i/5)\n    a=mod(i,DIV);  //since this is an angle multiple of 2pi\n    a=mod(mod(i,DIV)*a,DIV);//you can use mod by the divisor to toss big values early\n    a=mod(mod(i,DIV)*a,DIV);b2=a;//save for offscreen calc of next fig center, extents\n    a=mod(fig*a,DIV);b=mod(fig*i,DIV*5.);\n    b=pi2*fract((a+b*.2)/DIV);//now a+b (i*i*i+i/5) are not so far apart\n    //b=pi2*fig*i/DIV*(i*i+.2);//uncomment to see how quickly floats break\n    //b=pi2*fract(i*fract(fig*fract((i*i+.2)/DIV)));//still way off!\n    L2.xy+=vec2(cos(b),sin(b))*scl;//now I want to integrate this sum but so far\n    float d=tube(U-L2.xy,oL-L2.xy);//I can only get a spiral\n    if(!bLogic)O.rgb=max(O.rgb*smoothstep(0.,2.5,d),cmap(pi2*i/DIV)*smoothstep(1.,0.,d)*shad(u).rgb);\n    oL=L2.xy;//save last point\n    if(bLogic){//next fig run offscreen to capture the center and extents\n      b=mod((fig+1.)*i,DIV*5.);\n      a=mod((fig+1.)*b2,DIV);\n      a=pi2*fract((a+b*.2)/DIV);\n      L2.zw+=vec2(cos(a),sin(a));\n      L1.xz=min(L1.xz,L2.zw);\n      L1.yw=max(L1.yw,L2.zw);\n    }\n  }\n  if(bLogic){if(u.x==0.5)O=L0;else if(u.x==1.5)O=L1;else if(u.x==2.5)O=L2;}//save logic\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define bps 4.\n#define pi 3.14159\nint N[16]=int[16](0,5,4,7,7,2,4,0,7,5,4,2,7,5,4,0);\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.);\n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;\n return note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n}\nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t, vec3 p, vec4 e, vec4 d){\n  float bt=t,t2,t3,t4,f=ntof(n);\n  if(f==0.)return vec2(0);\n  t-=t*d.y*sin((d.w*pi+t)*pi*d.z);t3=t*d.x;\n  t2=fract(t*p.y*f);t4=fract(t3*p.y*f);\n  t=fract(t*f);t3=fract(t3*f);\n  float amp=abs(1.+cos(bt*e.z*pi)*e.w)*exp(-bt*e.y)*(1.0-exp(-bt*e.x))*min(1.,100.-bt*100.);\n  return amp*rot(vec2(sin(pow(t,p.x)*pi*2.+pi*2.*p.z*sin(pow(t2,p.x)*pi*2.)),\n    sin(pow(t3,p.x)*pi*2.+pi*2.*p.z*sin(pow(t4,p.x)*pi*2.))),float(n)+bt*pi*2.);\n}\nint pat(float bt){return int(bt)%(mod(bt,32.)<16.?8:16);}\nvec2 mainSound(int samp, float time){\n  float tim=time*bps;if(tim>128. && tim<256.)tim=tim-128.;\n  float bt=floor(tim),t=fract(tim);t+=0.01*sin(pi*pow(t,15.));\n  int n64=N[pat(bt/64.)]-(mod(bt/128.,2.)<1.?0:7);\n  int n8=n64+N[pat(bt/8.)],n1=n8+N[pat(bt)],n2=n8+N[pat(bt/2.)];\n  float fo=pow(1.-t,20.0);\n  vec2 v=I(n1+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,1.0,6.,t*.8),vec4(1.014,0.005,1.,.5))*.5;\n  t=fract(tim/2.);\n  fo=pow(1.-t,20.0);\n  v+=I(n2+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,1.,12.,t*.8),vec4(1.014,0.005,1.,.5));\n  v+=I(n2+54,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,3.,18.1,t*.8),vec4(1.008,0.0051,1.,.5));\n  t=fract(tim/8.);\n  fo=pow(1.-t,20.0);\n  v+=I(n8+48,t,vec3(1.-fo*.5,.5,fo),vec4(10.,1.0,24.,t*.4),vec4(1.004,0.005,1.,.5));\n  v+=.5*I(n8+63,t,vec3(1.-fo*.5,.5,fo),vec4(10.,1.0,24.,t*.8),vec4(1.014,0.005,1.,.5));\n  return v*.05;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 350, 388, 388, 440]], "test": "untested"}
{"id": "7sd3z8", "name": "test gaussian blur", "author": "jcyuan", "description": "test gaussian blur", "tags": ["gaussian"], "likes": 1, "viewed": 133, "published": 3, "date": "1649772487", "time_retrieved": "2024-07-30T16:54:24.572738", "image_code": "const int kSize = 20;\nconst float sigma = float(kSize) * .25;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 stepWidth = 1. / iChannelResolution[0].xy;\n    \n    float w = 0.;\n    vec3 wc = vec3(0.);\n    \n    for (int y = -kSize; y <= kSize; y++) {\n         for (int x = -kSize; x < kSize; x++) {\n             float g = float(x * x + y * y) / (2. * (sigma * sigma));\n             g = exp(-g);\n             \n             wc += texture(iChannel0, uv + vec2(x, y) * stepWidth).rgb * g;\n             w += g;\n             \n         }\n    }\n\n    vec3 col = wc / w;\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sd3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 118, 118, 657]], "test": "untested"}
{"id": "NtscW2", "name": "futurama", "author": "celyk", "description": "can't wait for this show to return in 2023 :)", "tags": ["recreation", "futurama"], "likes": 29, "viewed": 898, "published": 3, "date": "1649769208", "time_retrieved": "2024-07-30T16:54:25.343676", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rot(float c){\n    float s=sin(c);\n    return mat2(c=cos(c),s,-s,c);\n}\n\nfloat line(vec2 p,vec2 a,vec2 b){\n    return length(clamp(dot(b-=a,p-=a)/dot(b,b),0.,1.)*b-p);\n}\n\nfloat sector(vec2 p,float r,float h){\n    p = vec2(p.y,-p.x);\n    float a = clamp(atan(p.y,p.x),-h,h);\n    return line(p, vec2(0), vec2(cos(a),sin(a))*r );\n}\n\nvoid mainImage(out vec4 O,vec2 U){\n    vec2 uv = (2.*U-iResolution.xy)/iResolution.y;\n    uv.y++; \n    \n    float t = iTime-.8;\n    float a = atan(-uv.x,uv.y)+sin(t)*.1;\n    \n    \n    O = vec4(0);\n    float h = clamp(t*2.7-1.3,0.,1.);\n    float f = 0.;\n    if(t>.5) a /= h;\n    float b = smoothstep(.2,1.2,texture(iChannel0, vec2(a*.2,a*.1+t*.05)).x);        \n    \n    f = sector(uv,t*12., .02 + h*3.1415926*.5);\n    \n    f = min(.002/(f*f),1.);\n    \n    if(t>.5) b *= f;\n    b = .12+b*.7;\n    \n    if(t>0.) {\n        f = mix(f,mix(.8,b,smoothstep(0.,1.,length(uv))),h*h*h);\n    }\n    else f = 0.;\n    \n    if(t<.5) f += smoothstep(max(sin((t+.3)*5.)*.1,0.),0.,b*dot(uv,uv*vec2(1,.3)));\n    \n    O.xyz = palette(clamp(f,0.,1.),vec3(-1,.55,0),vec3(2,.55,1.7),vec3(.5,.4,.1),vec3(.5,.5,.75));\n    O = pow(O,vec4(1./2.2));\n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28764, "src": "https://soundcloud.com/futuramaplanetexpress/futurama-theme-song", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtscW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 115], [117, 117, 135, 135, 191], [193, 193, 226, 226, 289], [291, 291, 328, 328, 448], [450, 450, 484, 484, 1271]], "test": "untested"}
{"id": "7lScWW", "name": "Edge statistics", "author": "vtimonen", "description": "Edge detection", "tags": ["edges"], "likes": 1, "viewed": 377, "published": 3, "date": "1649764971", "time_retrieved": "2024-07-30T16:54:26.146530", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n#define THIS_CHANNEL     iChannel1\n#define CAMERA_CHANNEL   iChannel0\n\n#define CALC_MARGINAL  0.05\n#define PRINT_MARGINAL 0.15\n\n/* Frame variables */\n#define EDGE    0\n#define AVERAGE 1\n#define RADIUS  2\n\n/* Frame varible macros */\n#define SAVE(value)        fragColor = vec4(0.0, 0.0, 0.0, (value))\n#define LOAD(variable, x)  texelFetch(THIS_CHANNEL, ivec2((x), variable), 0).a\n\n/* Colors */\n#define LINE_COLOR  vec4(1.0, 0.0, 0.0, 0.2)\n#define GRAPH_COLOR vec4(0.0, 0.0, 1.0, 0.4)\n\n\n#define MATRIX_SIZE 5\nvec4 camera_value(float x, float y)\n{\n    int dx ,dy;\n    vec4 sum = vec4(0.0);\n    int count = 0;\n\n    for (dx = 0; dx < MATRIX_SIZE; dx++) {\n        for (dy = 0; dy < MATRIX_SIZE; dy++) {\n            sum += texture(CAMERA_CHANNEL, vec2(x + (float(dx) + 0.5) / iResolution.x, y + (float(dy) + 0.5) / iResolution.y));\n            count++;\n        }\n    }\n    \n\n    return sum / float(count);\n}\n\n#define EDGE_WINDOW_SIZE 8\nfloat find_edge(int x_int)\n{\n    float diff;\n    float x, y;\n    int i;\n\n    float pre_y;\n    float post_y;\n\n    vec3 pre_color_sum;\n    vec3 post_color_sum;\n\n\n    /* Calculate initial calues for sums */\n    x = float(x_int) / iResolution.x;\n   \n    /* Calculate initial sums */\n    pre_color_sum  = vec3(0.0);\n    post_color_sum = vec3(0.0);\n    for (i = EDGE_WINDOW_SIZE; i < EDGE_WINDOW_SIZE + EDGE_WINDOW_SIZE; i++) {\n        vec4 color;\n\n        /* Calculate pre average */\n        pre_y = 1.0 - float(i + 1) / iResolution.y;\n        color = camera_value(x, pre_y);\n        pre_color_sum += color.rgb;\n\n        /* Calculate post average */\n        post_y = 1.0 + float(i) / iResolution.y;\n        color = camera_value(x, post_y);\n        post_color_sum += color.rgb;\n    }\n\n    /* Find out edge */\n    int y_int;\n    for (y_int = int(iResolution.y) - (EDGE_WINDOW_SIZE + 1); y_int >= 0 ; y_int--) {\n        x = float(x_int) / iResolution.x;\n        y = float(y_int) / iResolution.y;\n\n        float edge_value;\n        vec4 color;\n        \n        /* Update pre/post sums */ \n        pre_y = float(y_int) / iResolution.y;\n        color = camera_value(x, pre_y);\n        pre_color_sum  -= color.rgb;\n        post_color_sum += color.rgb;\n\n        pre_y = float(y_int) / iResolution.y - float(EDGE_WINDOW_SIZE) / iResolution.y;\n        color = camera_value(x, pre_y);\n        pre_color_sum += color.rgb;\n\n        post_y = float(y_int) / iResolution.y + float(EDGE_WINDOW_SIZE) / iResolution.y;\n        color = camera_value(x, post_y);\n        post_color_sum -= color.rgb;\n\n\n#if 0\n        vec3 color_diff = abs(pre_color_sum - post_color_sum);\n        float diff = color_diff.r + color_diff.g + color_diff.b;\n#define DIFF_TRESHOLD (float(EDGE_WINDOW_SIZE) / 8.0)\n        if (diff > DIFF_TRESHOLD) {\n//            break;\n        }\n\n        if (color_diff.r > DIFF_TRESHOLD) {\n            break;\n        }\n        if (color_diff.g > DIFF_TRESHOLD) {\n            break;\n        }\n        if (color_diff.b > DIFF_TRESHOLD) {\n            break;\n        }\n#else\n        float pre_luma  = dot(pre_color_sum.rgb,  vec3(0.299, 0.587, 0.114));\n        float post_luma = dot(post_color_sum.rgb, vec3(0.299, 0.587, 0.114));\n        vec3 color_diff = abs(pre_color_sum - post_color_sum);\n        float diff = abs(pre_luma - post_luma);\n\n        if (diff > float(EDGE_WINDOW_SIZE) / 8.0) {\n            break;\n        }\n#endif\n    }\n\n    return float(y_int);\n}\n\n#define AVERAGE_WINDOW int(iResolution.x / 8.0)\n//#define AVERAGE_WINDOW 1\nfloat calc_average(int x)\n{\n    int i;\n    float sum = 0.0;\n    int count  = 0;\n    for (i = 0; i < AVERAGE_WINDOW; i += 1) {\n        sum += LOAD(EDGE, x + (i - AVERAGE_WINDOW/2));\n        count++;\n    }\n\n    /* Return average value */\n    return sum / float(count);\n}\n\n\n#define RADIUS_WINDOW   int(iResolution.x / 12.0)\n#define RADIUS_SPACING  int(iResolution.x / 40.0)\n#define RADIUS_SCALE    2.0\nfloat calc_radius(int x)\n{\n    vec2 first = vec2(float(x - RADIUS_WINDOW), LOAD(AVERAGE, x - RADIUS_WINDOW));\n    vec2 mid   = vec2(float(x),                 LOAD(AVERAGE, x));\n    vec2 last  = vec2(float(x + RADIUS_WINDOW), LOAD(AVERAGE, x + RADIUS_WINDOW));\n\n    float result = 0.0;\n    result += (first.y - mid.y) / (mid.x  - first.x);\n    result += (last.y  - mid.y) / (last.x - mid.x);\n\n    result = (last.x - first.x) / (result * 2.0);\n\n    if (result < 0.0) {\n        return -result * RADIUS_SCALE / iResolution.y;\n    }\n\n    return 10000.0;\n}\n\n\n#define CALC_FRAME_RATE 3\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    ivec2 ifragCoord = ivec2(fragCoord - 0.5);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float mouse_x = iMouse.x/iResolution.x;\n    if (mouse_x > 0.5) {\n        /* Keep unchanged */\n        fragColor = texture(THIS_CHANNEL, uv);\n        return;\n    }\n\n    if (uv.x > CALC_MARGINAL && uv.x < 1.0 - CALC_MARGINAL) {\n\n        if (iFrame % CALC_FRAME_RATE == 0) {\n            /* Findout border place */\n            if (ifragCoord.y == EDGE) {\n                float y;\n\n                /* Detect border */\n                y = find_edge(ifragCoord.x);\n\n                /* Save border value */\n                SAVE(y);\n\n                return;\n            } \n\n            /* Calculate averages */\n            if (ifragCoord.y == AVERAGE) {\n                float average;\n\n                average = calc_average(ifragCoord.x);\n\n                /* Save average value */\n                SAVE(average);\n\n                return;\n            }\n\n            /* Calculate radius */\n            if (ifragCoord.y == RADIUS && (ifragCoord.x % RADIUS_SPACING) == 0) {\n                #define RADIUS_AVERAGE_WINDOW int(iResolution.x / 80.0)\n//                #define RADIUS_AVERAGE_WINDOW 1\n                int i;\n\n                float radius_sum = 0.0;\n                for (i = 0; i < RADIUS_AVERAGE_WINDOW; i++) {\n                    radius_sum += calc_radius(ifragCoord.x + (i - RADIUS_AVERAGE_WINDOW/2));\n                }\n\n                float radius;\n                radius = radius_sum / float(RADIUS_AVERAGE_WINDOW);\n                \n                /* Save average value */\n                SAVE(radius);\n\n                return;\n            }\n        }\n\n        if (ifragCoord.y == EDGE) {\n            /* Keep unchanged */\n            fragColor = texture(THIS_CHANNEL, uv);\n            return;\n        }\n        if (ifragCoord.y == AVERAGE) {\n            /* Keep unchanged */\n            fragColor = texture(THIS_CHANNEL, uv);\n            return;\n        }\n        if (ifragCoord.y == RADIUS && (ifragCoord.x % RADIUS_SPACING) == 0) {\n            /* Keep unchanged */\n            fragColor = texture(THIS_CHANNEL, uv);\n            return;\n        }\n\n        if (uv.x > PRINT_MARGINAL && uv.x < 1.0 - PRINT_MARGINAL) {\n            /* Print radius */\n            if ((ifragCoord.x % RADIUS_SPACING) == 0) {\n                /* Get border value */\n                int radius_y = int(LOAD(RADIUS, ifragCoord.x));\n                if (radius_y > ifragCoord.y) {\n                    fragColor = mix(GRAPH_COLOR, texture(CAMERA_CHANNEL, uv), GRAPH_COLOR.a);\n                    return;\n                }\n            }\n\n            /* Print edge */\n            int average_y = int(LOAD(AVERAGE, ifragCoord.x));\n            if (average_y > ifragCoord.y) {\n                if (average_y - ifragCoord.y > 7) {\n                    fragColor = texture(CAMERA_CHANNEL, uv);\n                } else {\n                    fragColor = mix(LINE_COLOR, texture(CAMERA_CHANNEL, uv), LINE_COLOR.a);\n                }\n                return;\n            }\n        }\n\n        fragColor = texture(CAMERA_CHANNEL, uv);\n    } else {\n        fragColor = texture(CAMERA_CHANNEL, uv);\n    }\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lScWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 144]], "test": "untested"}
{"id": "sljcWW", "name": "instant flood fill", "author": "ArmandB", "description": "need to find way to follow the edge of the picked color from the edge_point to the click_edge_point (buffer a)", "tags": ["fill"], "likes": 2, "viewed": 367, "published": 3, "date": "1649752596", "time_retrieved": "2024-07-30T16:54:26.939410", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord),0 ).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord),0 ).xyz;\n    vec3 picked_col = texelFetch( iChannel0, ivec2(iMouse.xy),0 ).xyz;\n    if (col == picked_col){\n        vec2 edge_point = floor(fragCoord); //a point on the edge of the same area as this pixel\n        vec2 click_edge_point = floor(iMouse.xy); //a point on the edge of the same area as the last click\n        //trace from the coord of this pixel to the edge of the color\n        //count edge of screen as edge\n        while (texelFetch( iChannel0, ivec2(edge_point) + ivec2(0,1),0 ).xyz == col){\n            if (edge_point.y + 1.0 < iResolution.y) {\n                edge_point += vec2(0,1);\n            } else {\n                break;\n            }\n        }\n        //trace from the coord of the last click to the edge of the color\n        //count edge of screen as edge\n        while (texelFetch( iChannel0, ivec2(click_edge_point) + ivec2(0,1),0 ).xyz == col){\n            if (click_edge_point.y + 1.0 < iResolution.y) {\n                click_edge_point += vec2(0,1);\n            } else {\n                break;\n            }\n        }\n        //follow edge from edge_point to click_edge_point\n        //if it reaches click_edge_point change col\n        //if it wraps back to edge_point exit\n        //treat screen edge as edge\n    }\n    \n    //outline (for testing)\n    if (col == picked_col){\n        vec3 x_pos_col = texelFetch( iChannel0, ivec2(fragCoord) + ivec2(1,0),0 ).xyz;\n        vec3 x_neg_col = texelFetch( iChannel0, ivec2(fragCoord) + ivec2(-1,0),0 ).xyz;\n        vec3 y_pos_col = texelFetch( iChannel0, ivec2(fragCoord) + ivec2(0,1),0 ).xyz;\n        vec3 y_neg_col = texelFetch( iChannel0, ivec2(fragCoord) + ivec2(0,-1),0 ).xyz;\n        if (x_pos_col + x_neg_col + y_pos_col + y_neg_col != picked_col*4.0){\n            col = vec3(0);\n        }\n        //follow edge\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 155]], "test": "untested"}
{"id": "sljyDW", "name": "room tunnel", "author": "jorge2017a2", "description": "room tunnel", "tags": ["roomtunnel"], "likes": 11, "viewed": 243, "published": 3, "date": "1649727368", "time_retrieved": "2024-07-30T16:54:27.691400", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//room tunnel---11-abril-2022\n//gracias a la comunidad de Shadertoy por su Informacion \n//y a IQ por compartir su conocimieto :)\n//cambios por Shane!!!\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat Intersect(float distA, float distB) { return max(distA, distB);}\nfloat Union(float distA, float distB)  { return min(distA, distB);}\nfloat Difference(float distA, float distB) { return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{ vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); \n    vec3 p0=p;\n\n\t p.y=p.y-11.0;\n    vec3 prep1=p;\n    vec3 prep2=p;\n    vec3 prep3=p;\n    prep1.z= opRep1D(prep1.z,24.0 );\n    prep2.z= opRep1D(prep2.z,55.0 );\n    prep3.z= opRep1D(prep3.z,30.0 );\n    \n    \n    vec3 pos;\n    float d0= sdBox( prep2, vec3(35.0,25.0,9.0) ); //bloque 1\n    //---plataforma\n    float d0a= sdBox( prep1-vec3(0.0,-12.5,-8.0), vec3(30.,2.5,20.0) ); //bloque 1\n    float d0b= sdBox( prep1-vec3(0.0,-11.5,-8.0), vec3(10.,2.0,21.0) ); //bloque 2\n    d0a=Difference(d0a, d0b);\n    \n    float d1a= sdCylinderXY(prep2, vec2(10.0,10.0) );  //tubo ext\n    float d1b= sdCylinderXY(prep2, vec2(9.0,11.0) );  //tubo int\n    float dif1=Difference(d1a, d1b);\n    d0=Difference(d0, d1a);\n    pos=vec3(0.0,0.0,10.0);\n    float d2a= sdCylinderXY(prep2-pos, vec2(10.0,1.0) ); //tubo ch,ext\n    float d2b= sdCylinderXY(prep2-pos, vec2(8.0,1.5) ); // tubo ch,int\n    float dif2=Difference(d2a, d2b);\n    //float d3=sdTriPrism(prep3-vec3(0.0,-12.0,5.0), vec2(5.0,20.0) );\n//shane\n// Repeat on either side of the X-axis to make two pipes.\nprep3.x = abs(prep3.x) - 4.;\n// Do it again to make four.\nprep3.x = abs(prep3.x) - 2.;\n// Round pipes.\nfloat d3 = sdCylinderXY(prep3 - vec3(0, -12, 5), vec2(1.125, 20) );\n\n\n    \n    res =opU2(res, vec2(dif1,100.0));\n    res =opU2(res, vec2(dif2,100.0));\n    res =opU2(res, vec2(d0,100.0));\n    res =opU2(res, vec2(d0a,100.0));\n    res =opU2(res, vec2(d3,101.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)+0.2; }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        //if(5.0*sin(1.0-iTime)>0.0)\n        //{ float sum=(col.x+col.y+col.z)/3.0; col=vec3(sum);} //grises\n        //if(hit.y!=101.0)\n        { float sum=col.x*0.299+col.y*0.587+col.z*0.11; col=vec3(sum);} //grises\n        //Y'=0.299R'+0.587G'+0.114B'\n    }\n    //else if(hit.x>MAX_DIST)\n    //col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t,t0;t0=iTime;\n    t=mod(t0*10.0,1000.0);\n \tlight_pos1= vec3(-40.0, 80.0, -20.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3( 40.0, 80.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 );\n   vec3 ro=vec3(0.0+4.0*sin(t0),10.0,t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   float ang=0.58*cos(180.-t0*0.5);\n   rd= rotate_y(rd, ang);\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[614, 614, 646, 646, 730], [731, 731, 770, 770, 865], [867, 867, 910, 910, 937], [938, 938, 978, 978, 1005], [1006, 1006, 1050, 1050, 1078], [1080, 1105, 1139, 1139, 1235], [1236, 1236, 1270, 1270, 1361], [1362, 1362, 1396, 1396, 1487], [1490, 1490, 1526, 1526, 1571], [1573, 1573, 1609, 1609, 1690], [1692, 1692, 1717, 1717, 3173], [3175, 3175, 3199, 3199, 3361], [3363, 3363, 3411, 3411, 3690], [3693, 3693, 3737, 3737, 4058], [4060, 4060, 4097, 4097, 4354], [4356, 4356, 4446, 4446, 5406], [5408, 5408, 5457, 5457, 5594], [5596, 5596, 5628, 5628, 5828], [5831, 5831, 5901, 5901, 5989], [5991, 5991, 6018, 6018, 6107], [6109, 6109, 6167, 6167, 6215], [6217, 6217, 6240, 6240, 6352], [6354, 6354, 6385, 6385, 7263], [7265, 7265, 7322, 7322, 7831]], "test": "untested"}
{"id": "ftjyWD", "name": "Little Wave 34234209384", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 3, "viewed": 243, "published": 3, "date": "1649723818", "time_retrieved": "2024-07-30T16:54:28.470317", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float d = p.y;\n    d += 0.3 * thc(1., p.z-p.x + iTime);\n    d = max(d, mlength(p.xz) - 1.8); \n    vec2 fpos = 0.5 * cos(4. * p.xz * pi);\n    d -= 0.4 * smoothstep(-1., 1., -length(fpos) + 0.1);\n    \n    float e = 0.9 + 0.05 * thc(40., 10. * p.x + 4. * p.z + iTime);\n    p.y += 0.4;\n    d = -smin(-d, length(p) - e - 0.03);\n    d = min(d, length(p) - e);\n    return 0.4 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(1);\n        \n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col += fresnel;\n        float fresnel2 = pow(1.+dot(rd, n), 5.); \n        //col += fresnel2;\n        \n        vec2 fpos = fract(4. * p.xz) - 0.5;\n        col *= step(1., length(p.xz)) * smoothstep(-0.01, 0.01, -length(fpos) + 0.1);\n        \n    }\n    vec3 e = vec3(0.5);\n   \n    col += exp(-10. * (0.4-p.y));\n    col *= exp(-length(p));\n    col *= 2. * pal(0.4 + 0.1 * (p.x - p.z), e, e, e, 0.5 * vec3(0,1,2)/3.);\n    col = clamp(col, 0., 1.);\n    if (col == vec3(1))\n        col = vec3(0);\n    col = pow(col, vec3(.4545)) + vec3(0.05,0.05,0.12);\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 716], [718, 718, 741, 741, 1121], [1123, 1123, 1166, 1166, 1473], [1475, 1475, 1499, 1499, 1689], [1691, 1691, 1741, 1741, 1932], [1934, 1934, 1991, 1991, 3326]], "test": "untested"}
{"id": "Nl2yDD", "name": "Metal branch mosaic 2", "author": "jarble", "description": "Another ornate mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 3, "viewed": 230, "published": 3, "date": "1649714087", "time_retrieved": "2024-07-30T16:54:29.298104", "image_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c)*v;\n}\n\nvec2 triangle_wave(vec2 a,float num,int iters){\n    a = rotate(a,num*radians(180.));\n    vec2 to_return = abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n    return to_return/1.5;\n    //return to_return/(1.5+(iters > 0?1.:0.)*(a.x+a.y)/4.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    float p1 = 1.;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    float rotation_number = 0.;\n    for(int k = 0; k < 12; k++){\n        rotation_number = float(int(uv.x+uv.y)+1+k)/2.;\n        //rotation_number += float(int(uv.x+uv.y)+1+k)*.5;\n\n        uv += t2;\n        t2 = -p1*triangle_wave(uv-1.5,rotation_number,k);\n        t3 = p1*triangle_wave(uv.yx,rotation_number,k);\n        uv = t2-t3;\n        p1 *= -1.;\n        float multiplier = 1.25;\n        col.x = max(uv.y+uv.x-col.x,col.x);\n        //col.x = max(((uv.y+uv.x)-col.x)/multiplier,col.x*multiplier);\n        //col.x = max(uv.y*(1.25)+uv.x/(1.25)-col.x,col.x);\n        //col.x = max(uv.y+uv.x-col.x,col.x*multiplier)/multiplier;\n\n        col = abs(col.yzx-vec3(1.-col.x))/multiplier;\n        uv /= scale;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2yDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 99], [101, 101, 148, 148, 332], [334, 334, 391, 391, 1456]], "test": "untested"}
{"id": "fl2yWW", "name": "Color aberrated stars.", "author": "fyisic123", "description": "Could better, could be worse :) ", "tags": ["aberration", "hue", "starfield", "aberrated"], "likes": 14, "viewed": 626, "published": 3, "date": "1649696216", "time_retrieved": "2024-07-30T16:54:30.208669", "image_code": "\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\n\n\n// Settings\n#define LAYER_COUNT 5.\n#define ABERRATION 0.25\n#define ABERRATION_SIZE 0.3\n#define DOT_SIZE 0.05\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 dotLayer(vec2 uv, vec2 uvNorm, float uvLength, float fade, float layerID)\n{\n    vec2 gv = fract(uv) -.5;\n    vec2 ID = floor(uv);\n    vec3 col = vec3(0);\n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)        \n        {\n            vec2 offs = vec2(x,y);            \n            float rnID = hash12(ID + offs + layerID);\n            float variantID = 123.123 * rnID ;            \n            vec2 rndOffs = vec2(sin(variantID), cos(variantID)) ;\n            vec2 pos = gv - offs + rndOffs;\n            \n            float starScale = 0.5 + (0.5 * rnID);\n            float dotScale = DOT_SIZE * starScale * fade;\n            float abbrsize = 0.01 + (ABERRATION_SIZE * uvLength) * fade * starScale;\n            float p =smoothstep(dotScale,dotScale*.5   ,length(pos));\n            col += p;\n            \n            float aberr = ABERRATION * starScale * fade;\n            float fC = 0.;\n            for(int i = 0; i < 3; i++)\n            {                  \n                fC += 0.33333;\n                float cDist =   (fC * uvLength * aberr);\n                \n                col[i] += pow(smoothstep(abbrsize   , 0., length(pos + (uvNorm * cDist))), 2.);\n                \n                \n            }\n            \n        }\n        return col * fade;\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y;\n    float uvLength = length(uv);\n    uv *= Rot(iTime*0.1);\n    vec2 uvNorm = normalize(uv);\n    \n    \n    \n        \n    vec3 col = vec3(0);            \n    \n    float speed = iTime * 0.2;\n    for(float i=0.; i < 1.; i+=1./LAYER_COUNT)\n    {\n        float depth = fract(speed+i) ;\n        col += dotLayer(uv * (20. - (19. * depth)) , uvNorm, uvLength , smoothstep(1.,0.8, depth), i)  * depth;\n    }\n                                \n    vec3 bgCol = abs(dot(uvNorm.x * uvLength, uvNorm.y))* (hue(uvLength + (iTime* 0.2)) * 0.1); \n    col += bgCol;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2yWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 234, 234, 353], [354, 354, 434, 434, 1639], [1642, 1642, 1661, 1661, 1723], [1724, 1724, 1781, 1781, 2433]], "test": "untested"}
{"id": "NtcSD4", "name": "Hitomezashi", "author": "AJFarmar", "description": "Hitomezashi is a kind of sashiko stitching, used to reinforce and patch together cloth in a simple but aesthetically pleasing way. Here I present a few patterns which I like.", "tags": ["2d", "simple", "pattern", "stitching", "hitomezashi", "2colorable", "sashiko", "threadwork"], "likes": 3, "viewed": 188, "published": 3, "date": "1649689747", "time_retrieved": "2024-07-30T16:54:31.067373", "image_code": "#define MAX_PATTERN_LENGTH 10\n\n\n// We define the patterns here\n// This version of GL doesn't allow for lists of lists, so we have to do it this way.\nconst int[] v_edges_0 = int[](1, 1, 0, 1, 0, 0, 1, 0);\nconst int[] h_edges_0 = int[](1, 0, 0, 1, 0, 1);\n\nconst int[] v_edges_1 = int[](1, 1, 0, 0);\nconst int[] h_edges_1 = int[](1, 1, 0);\n\nconst int[] v_edges_2 = int[](1, 1, 0, 0, 1, 0, 0);\nconst int[] h_edges_2 = int[](1, 1, 0, 0, 1, 0, 0);\n\nconst int[] v_edges_3 = int[](1, 1, 1, 0, 0, 0);\nconst int[] h_edges_3 = int[](1, 1, 0);\n\n// Integer modulo (%) in glsl is a joke! This one works properly.\nint intmod(int a, int m) {\n\tint res = a - (a/m)*m;\n\treturn res < 0 ? res + m : res;\n}\n\n// Is the low vertical edge on the cell (x,y) on?\nbool hitomezashi_edge_v(int x, int y, int pattern)\n{\n\t// Fetch the right pattern. Default 0.\n\tint v_edge = v_edges_0[intmod(x, v_edges_0.length())];\n\tif (pattern == 1) v_edge = v_edges_1[intmod(x, v_edges_1.length())];\n    if (pattern == 2) v_edge = v_edges_2[intmod(x, v_edges_2.length())];\n    if (pattern == 3) v_edge = v_edges_3[intmod(x, v_edges_3.length())];\n    return intmod(v_edge + y, 2) != 1;\n}\n\n// Is the low horizontal edge on the cell (x,y) on?\nbool hitomezashi_edge_h(int x, int y, int pattern)\n{\n\t// Fetch the right pattern. Default 0.\n\tint h_edge = h_edges_0[intmod(y, h_edges_0.length())];\n\tif (pattern == 1) h_edge = h_edges_1[intmod(y, h_edges_1.length())];\n    if (pattern == 2) h_edge = h_edges_2[intmod(y, h_edges_2.length())];\n    if (pattern == 3) h_edge = h_edges_3[intmod(y, h_edges_3.length())];\n    return intmod(h_edge + x, 2) != 1;\n}\n\n// The SDF for a hitomezashi pattern with a given cell size.\nfloat hitomezashi_SDF(float cell_size, vec2 coord, int pattern)\n{\n// Work out what cell we're in, and whereabouts in it we are.\n    vec2 coord_ = coord/cell_size,\n         cell_f = fract(coord_);\n\tint  cell_x = int(floor(coord_.x)),\n\t\t cell_y = int(floor(coord_.y));\n    \n    // Every corner is populated, so the distance is bounded above\n    // by the distances to each of the corners. We will reduce it from here.\n    float dist = min(\n        min( length(vec2(0.0, 0.0) - cell_f), length(vec2(0.0, 1.0) - cell_f) ),\n        min( length(vec2(1.0, 0.0) - cell_f), length(vec2(1.0, 1.0) - cell_f) )  );\n    \n    // Fetch +ve or -ve for every vertical/horizontal edge:\n    if (hitomezashi_edge_v(cell_x + 0, cell_y + 0, pattern)) dist = min(dist,       cell_f.x);\n    if (hitomezashi_edge_v(cell_x + 1, cell_y + 0, pattern)) dist = min(dist, 1.0 - cell_f.x);\n    if (hitomezashi_edge_h(cell_x + 0, cell_y + 0, pattern)) dist = min(dist,       cell_f.y);\n    if (hitomezashi_edge_h(cell_x + 0, cell_y + 1, pattern)) dist = min(dist, 1.0 - cell_f.y);\n\t\n\t// We're done!\n    return dist * cell_size;\n}\n\n// Check if a given square has the same color as the (0,0) square.\nbool hitomezashi_color(float cell_size, vec2 coord, int pattern)\n{\n\t// Fetch the right pattern's measurements. Default 0.\n\tint v_edges = v_edges_0.length();\n\tint h_edges = h_edges_0.length();\n\tif (pattern == 1)\n\t{\n\t\tv_edges = v_edges_1.length();\n\t\th_edges = h_edges_1.length();\n\t}\n    if (pattern == 2)\n\t{\n\t\tv_edges = v_edges_2.length();\n\t\th_edges = h_edges_2.length();\n\t}\n    if (pattern == 3)\n\t{\n\t\tv_edges = v_edges_3.length();\n\t\th_edges = h_edges_3.length();\n\t}\n\t\n    // Some hitomezashi patterns need to be repeated to tile the colors correctly.\n\t# define X_REPEATS 2\n    # define Y_REPEATS 2\n\tvec2 coord_ = coord/cell_size;\n\tint cell_x = intmod(int(floor(coord_.x)), X_REPEATS * v_edges),\n\t\tcell_y = intmod(int(floor(coord_.y)), Y_REPEATS * h_edges);\n\t\n\tbool same = true;\n\t\n    // We count the number of bold edges we cross going right\n\tint i;\n\tfor (i = 0; i < X_REPEATS * MAX_PATTERN_LENGTH; i++)\n\t{\n\t\tif (i == cell_x) break;\n\t\tif (hitomezashi_edge_v(i+1, 0, pattern)) same = !same;\n\t}\n\n\t// We count the number of bold edges we cross going up\n\tfor (int j = 0; j < Y_REPEATS * MAX_PATTERN_LENGTH; j++)\n\t{\n\t\tif (j == cell_y) break;\n\t\tif (hitomezashi_edge_h(i, j+1, pattern)) same = !same;\n\t}\n\t\n\treturn same;\n}\n\t\nvec3 hitomezashi_image(float cell_size, vec2 coord, int pattern,\n                       vec3 tile1, vec3 tile2, vec3 grouting)\n{\n    vec3 color = hitomezashi_color(cell_size, coord, pattern) ? tile1 : tile2;\n    float b = smoothstep(1.5, 2.5, hitomezashi_SDF(cell_size, coord, pattern));\n    color = mix(color, grouting, 1.0 - b);\n    return color;\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// I've chosen some colours I think are nice :)\n    vec3 p0 = hitomezashi_image(25.0, fragCoord + 40.0*iTime*vec2(1.0, 1.0), 0,\n        vec3(0.75, 0.7, 1.0), vec3(1.0), vec3(0.0));\n    vec3 p1 = hitomezashi_image(90.0, fragCoord + 80.0*iTime*vec2(1.0,-1.0), 1,\n        vec3(1.0, 0.8, 0.8), vec3(0, 0.3, 0.85), vec3(1.0));\n    vec3 p2 = hitomezashi_image(50.0, fragCoord + 50.0*iTime*vec2(1.25,0.5), 2,\n        vec3(fragCoord.x/iResolution.x), vec3(1.0 - fragCoord.x/iResolution.x), vec3(1.0));\n    float wobble = sin(5.0*fragCoord.x/iResolution.x);\n    vec3 p3 = hitomezashi_image(45.0, fragCoord + 20.0*iTime*vec2(0.5,-1.5), 3,\n        vec3(0.95, 0.95, 0.9), vec3(0.8, 0.7, 0.5-0.1*wobble), vec3(0.4 - 0.2*wobble));\n    vec3 pattern_img[] = vec3[](p0, p1, p2, p3);\n    \n    \n    // Cycle every 8 seconds\n    float transition_timing = iTime/8.0;\n    int cycle = intmod(int(transition_timing), pattern_img.length());\n    int next_cycle = intmod(cycle + 1, pattern_img.length());\n    float f = fract(transition_timing);\n    \n    vec3 color = mix(pattern_img[cycle], pattern_img[next_cycle], smoothstep(0.9, 1.0, f));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 599, 625, 625, 684], [686, 736, 788, 828, 1141], [1143, 1195, 1247, 1287, 1600], [1602, 1663, 1728, 1790, 2759], [2761, 2828, 2894, 2949, 4041], [4044, 4044, 4172, 4172, 4394]], "test": "untested"}
{"id": "7tScDW", "name": "Liquid Crystal Labyrinth", "author": "tomachi", "description": "Fluid-like continuous cellular automata by  cornusammonis in 2016:  [url]https://shadertoy.com/view/Xst3Dj[/url]\nWebGL2 cleansing by FabriceNeyret2 in 2019:  [url] https://www.shadertoy.com/view/ttjXzR[/url]\nin 2022 I add colour and crystalisation.", "tags": ["diffusion", "feedback", "reaction"], "likes": 10, "viewed": 399, "published": 3, "date": "1649687885", "time_retrieved": "2024-07-30T16:54:31.820360", "image_code": "// WebGL2 cleaned-up version of \"Viscous Fingering\" by cornusammonis. https://shadertoy.com/view/Xst3Dj\n\nvoid mainImage(out vec4 O, vec2 u) {\n        vec2 U = u;\n        O =  normalize(T()); \n        \n        // Before Fabrice suggestion I had chosen values:\n        //O =  O/vec4(2,4,4,1) + .5*O.z;\n   \n        // now I boost the blue and dial back the red and green\n        O =  O/vec4(1.3,1.3,0.75,1) + 0.4 *O.z; // 28.1 fps \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 O, vec2 U )\n{\nfloat _K0 = -20./6., // center weight\n      _K1 =   4./6., // edge-neighbors\n      _K2 =   1./6., // vertex-neighbors\n       cs =  .12052 + (U.x*0.0000051),    // curl scale\n       ls =  .12052 + (U.x*0.0000051),    // laplacian scale\n       ps = -.06,    // laplacian of divergence scale\n       ds = -.08,    // divergence scale\n      pwr =  .2,     // power when deriving rotation angle from curl\n      amp = 0.999+(U.y*0.000051),      // self-amplification\n      sq2 =  .7;     // diagonal weight\n\n// 3x3 neighborhood coordinates\n    vec4 uv = T( ),\n          n = T(vec2( 0,  1 )),\n          e = T(vec2( 1,  0 )),\n          s = T(vec2( 0, -1 )),\n          w = T(vec2(-1,  0 )),\n         nw = T(vec2(-1,  1 )),\n         sw = T(vec2(-1     )),\n         ne = T(vec2( 1     )),\n         se = T(vec2( 1, -1 ));\n    \n    // uv.x and uv.y are our x and y components, uv.z is divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(n + e + w + s) \n                        + _K2*(nw + sw + ne + se);\n    float sp = ps * lapl.z;\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = n.x - s.x - e.y + w.y \n        + sq2 * (nw.x + nw.y + ne.x - ne.y + sw.y - sw.x - se.y - se.x);\n    \n    // compute angle of rotation from curl\n    float a = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = s.y - n.y - e.x + w.x \n        + sq2 * (nw.x - nw.y - ne.x - ne.y + sw.x + sw.y + se.y - se.x);\n    float sd = ds * div;\n\n    vec2 norm = normalize(uv.xy);\n    \n    // temp values for the update rule\n     vec2 t = (amp * uv + ls * lapl + uv * sd).xy + norm * sp;\n     float red = sd;\n     float green = div;\n     float blue = t.x;\n     //O = vec4(red,green, blue, 1.0);\n     //O = clamp(vec4(t,div,0), -1., 1.);\n     \n     t *= mat2(cos(a), -sin(a), sin(a), cos(a) );\n    if(iFrame<10)\n        O = -.5 + texture(iChannel1, U/R), O.a=0.;\n     else \n        O = clamp(vec4(t,div,0), -1., 1.);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(d) texelFetch(iChannel0, ivec2(d+U)%ivec2(R),0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tScDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 141, 141, 430]], "test": "untested"}
{"id": "NlScDz", "name": "Space particles", "author": "morimea", "description": "[b]Very Slow effect, look at least for 1 min.[/b]\nThis shader just move particles on position, thats all.\n", "tags": ["space", "particles", "art"], "likes": 13, "viewed": 645, "published": 3, "date": "1649685801", "time_retrieved": "2024-07-30T16:54:32.770819", "image_code": "\n// Created by Danil (2022+) https://cohost.org/arugl\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Particles, art shader\n// self https://www.shadertoy.com/view/NlScDz\n\n\n// particle logic from https://www.shadertoy.com/view/tstSz7\n// if you need particle logic look linked above shader (and read comments there)\n// this is just \"art shader\", there just few comments\n\n\n// BufA - particles (particle movement logic in particle_data() function)\n// BufB - particles render + motion blur\n// BufC - TAA + motion blur\n\n\nvec3 ACESFitted(vec3 color);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel2, fragCoord.xy/iResolution.xy).rgb, 1.0);\n    //fragColor=(fragColor*fragColor*01.6+sqrt(fragColor)*0.8);\n    \n    //fragColor=clamp(fragColor,0.,1.)*1.905;\n    fragColor=0.55*fragColor*fragColor+vec4(pow(ACESFitted(clamp(fragColor.rgb*0.65,0.,1.)),vec3(0.45)),1.)*1.32;\n    \n    \n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = (fragCoord.xy) / iResolution.xy - 0.5;\n    vec2 tp = pow(abs(uv*2.), vec2(3.0));\n    float d = 1.-dot(tp,tp);\n    \n    fragColor*=d;\n    fragColor.a=1.;\n    \n}\n\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// data\n// in [x,y,z,w]\n\n// (remember that 32 bit float may be 31 bit float on some GPUs)\n// x pos 0xfffff data 0xfff (uint)\n// y pos 0xfffff data 0xfff (uint)\n// z speed 0xfffff f data 0xff (uint)\n// w speed 0xfffff f data 0xff (uint)\n\n// data 0xf color id 0xfffff id \n// 0xffff timer (unused, used only to fade start particles)\n\n\n//particle movement logic in particle_data() function\n\n\nint max_lines;\nint max_particles; // per line because id 0xfffff max\n\nbool is_reset();\nvec4 particle_data(ivec2 ipx);\nfloat noise3( in vec3 x );\nfloat noise2( in vec2 p);\nvec4 loadval(ivec2 io) {return loadvalg(io, iResolution.xy);}\n\nvec4 getV(in vec2 p,float max_pos,float max_posy){\n    if (p.x < 0.001 || p.y < 0.001) return vec4(0);\n    if(ivec2(p)==ivec2(iResolution.xy)-1) return vec4(0);\n    vec4 tval=texelFetch( iChannel0, ivec2(p), 0 );\n    float p1=decodeval_pos(floatBitsToUint(tval.x))*max_pos;\n    float p2=decodeval_pos(floatBitsToUint(tval.y))*max_posy;\n    float v1=decodeval_vel(floatBitsToUint(tval.z));\n    float v2=decodeval_vel(floatBitsToUint(tval.w));\n    return vec4(p1,p2,v1,v2);\n}\n\nuvec2 extra_dat_pos(vec2 p){\n    vec4 tval=texelFetch( iChannel0, ivec2(p), 0 );\n    return uvec2(floatBitsToUint(tval.x)&0xfffu,floatBitsToUint(tval.y)&0xfffu);\n}\n\nuvec2 extra_dat_vel(vec2 p){\n    vec4 tval=texelFetch( iChannel0, ivec2(p), 0 );\n    return uvec2(floatBitsToUint(tval.z)&0xffu,floatBitsToUint(tval.w)&0xffu);\n}\n\n// get saved unique ID\nuvec2 get_id(vec2 p){\n    uvec2 v1=extra_dat_pos(p);\n    uint iret=(v1[0]<<12)|(v1[1]<<0);\n    return uvec2(iret&0xfffffu,iret>>20);\n}\n\nuint get_timer(vec2 p){\n    uvec2 v1=extra_dat_vel(p);\n    uint iret=(v1[0]<<8)|(v1[1]<<0);\n    return iret;\n}\n\nuvec2 save_id(uint id, uint color_id){\n    id=id&0xfffffu;\n    id+=color_id<<20;\n    uint a=(id>>12)&0xfffu;\n    uint b=(id>>0)&0xfffu;\n    return uvec2(a,b);\n}\n\nuvec2 save_timer(uint timer){\n    uint a=(timer>>8)&0xffu;\n    uint b=(timer>>0)&0xffu;\n    return uvec2(a,b);\n}\n\nbool destr(int id, int max_pos){\n    int sx=id%max_pos;\n    int sy=id/max_pos;\n    return particle_data(ivec2(sx,sy)).w<-0.5;\n}\n\nvec2 pack_pos(vec2 pos,uvec2 extra_val, float max_pos, float max_posy){\n    uint p1=uint((pos.x/max_pos)*float(0xfffff));\n    uint p2=uint((pos.y/max_posy)*float(0xfffff));\n    float px=uintBitsToFloat(encodeval_pos(uvec2(p1,extra_val.x)));\n    float py=uintBitsToFloat(encodeval_pos(uvec2(p2,extra_val.y)));\n    return vec2(px,py);\n}\n\nvec2 pack_vel(vec2 vel,uvec2 extra_val){\n    float vx=uintBitsToFloat(encodeval_vel(vel.x,extra_val.x));\n    float vy=uintBitsToFloat(encodeval_vel(vel.y,extra_val.y));\n    return vec2(vx,vy);\n}\n\n// save everything to pixel color\nvec4 save_all(vec2 pos, vec2 vel, uint id, uint timer, uint color_id){\n    uvec2 extra_data_pos_tid=save_id(id, color_id);\n    uvec2 extra_data_vel_tid=save_timer(timer);\n    float max_pos=iResolution.x;\n    float max_posy=iResolution.y;\n    vec2 pos_ret=pack_pos(pos,extra_data_pos_tid,max_pos,max_posy);\n    vec2 vel_ret=pack_vel(vel,extra_data_vel_tid);\n    return vec4(pos_ret,vel_ret);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nbool is_reset(){\n    ivec2 tres = ivec2(texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).xy);\n    if(tres==ivec2(iResolution.xy))return false;\n    return true;\n}\n\nvec2 get_target_pos(int id, int rsz){\n    int sx=id%rsz;\n    int sy=id/rsz;\n    return particle_data(ivec2(sx,sy)).xy;\n}\n\nvoid sim_step( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    vec2 middle = fragCoord;\n    uint self_id=0u;\n    uint color_id=0u;\n    uint timer=0u;\n    int fade_frame = max(iFrame-abs(int(texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).w))-fade_time/100,0);\n    int timer_spn_l = timer_spn+max((fade_time*4-fade_frame)*100,0);\n    float max_pos=iResolution.x;\n    float max_posy=iResolution.y;\n    int sz = int(min(max_posy,max_pos)*0.25); // use 0.25 of screen square size\n    int rsz = min(sz,max_particles); // limit max id of texture because 0xfffff max id\n    if (iFrame < 1 || is_reset()) \n    {\n        ivec2 ipx = ivec2(fragCoord);\n        if ((ipx.x + ipx.y) %2 == 0 && ipx.y % 2 == 0){\n            \n            //init\n            \n            ivec2 mid = (ipx-ivec2(iResolution.xy/2.)+ivec2(iResolution.xy/2.)%2)/2;\n            int ix = 0;int iy = 0;\n            if(mid.x<0&&mid.y>0){\n                ix=1;iy=(((max_lines))%2);\n                mid.x=abs(mid.x);\n                mid.y=(max_lines/2+0)-mid.y-iy+(((max_lines))%2);\n            }\n            \n            if(mid.x>=0&&mid.y>=0&&mid.x<rsz&&mid.y<max_lines/2+(((max_lines))%2)){\n                mid.y+=ix*(max_lines/2)+iy;\n                uint id=uint(mid.x+mid.y*rsz);\n                ivec2 tidp=ivec2(int(id)%rsz,int(id)/rsz);\n                vec2 pos=middle;\n                vec2 vel=vec2(0.);\n                timer=uint(particle_data(tidp).z);\n                color_id=0x0u;\n                fragColor = save_all(pos,vel,id,timer,color_id);\n                return;\n            }\n        }\n    } else {\n        vec4 v = vec4(0.); \n        vec2 lp=vec2(-10.);\n        bool br=false;\n        for (int x=-1; x<=1; x++) {\n            if(br)break;\n            for (int y=-1; y<=1; y++) {\n                vec2 np = fragCoord + vec2(x,y);\n                vec4 p = getV(np,max_pos,max_posy);\n                //found ball for transition\n                if(trunc(middle) == trunc(p.xy)){\n                    v = p;\n                    lp=np;\n                    br=true;\n                    break;\n                }\n            }\n        }\n        \n        \n        // movement calculations\n        if (br){\n            uvec2 tmpid = get_id(trunc(lp.xy));\n            self_id=tmpid.x;\n            color_id=tmpid.y;\n            if(destr(int(self_id),rsz)){fragColor = vec4(0.);return;}\n            \n            timer=get_timer(trunc(lp.xy));\n            //if(timer>=uint(fade_time)){fragColor=vec4(0.);return;}\n            timer+=1u;\n            vec2 dr = vec2(0);\n\n            // collision checks\n            float stress = 0.0;\n            for (int x=-2; x<=2; x++) {\n                for (int y=-2; y<=2; y++) {\n                    if (x !=0 || y != 0) \n                    {\n                        vec4 p = getV(fragCoord + vec2(x,y),max_pos,max_posy);\n                        if (p.x > 0.0) {\n                            vec2 d2 = v.xy - p.xy;\n                            float l = length(d2);\n                            float f = BALL_D - l;\n                            if (l >= 0.001* BALL_SIZE &&  f > 0.0) {\n                                float f2 = f / (BALL_D);\n                                f2 *= BALL_D;\n                                vec2 force_part = E_FORCE * normalize(d2)*f2;\n                                stress += abs(force_part.x)+abs(force_part.y);\n                                dr += force_part;\n                            }\n                        }\n                    }\n                }\n            }\n\n            dr += M *max(stress, 1.0) * vec2(0.008) * VEL_LIMIT; // bad fix for jittering\n            \n            // movement calculation\n            vec2 pos = v.xy;\n            float damp_k = length(dr)>0.001? DAMP_K : 1.0; // don't apply damping to freely flying balls\n            vec2 gravity = loadval(ivec2(0,1)).xy*maxG;\n            dr += gravity * M; // gravity\n            \n            vec2 tdir = -pos+get_target_pos(int(self_id),rsz)*loadval(ivec2(1,0)).xy;\n            tdir = tdir/loadval(ivec2(1,0)).xy;\n            if(length(tdir)>0.0001)tdir=normalize(tdir);else tdir=vec2(0.);\n            vec2 dr2 = clamp(length(tdir),0.,1.)*tdir * maxPf * M; // target pos\n            \n            \n            vec2 vel = damp_k * v.zw + dr / M + dr2 / M ;\n            vel = clamp(vel, vec2(-1.0), vec2(1.0));\n            \n            vec2 dpos = vel * VEL_LIMIT;\n            pos += dpos;\n            v.xy = pos;\n            v.xy = clamp(v.xy,vec2(BALL_SIZE *(1.0 + sin(pos.y)*0.1),BALL_SIZE),iResolution.xy-vec2(BALL_SIZE));\n            \n            if(iFrame%timer_spn_l==0){self_id+=1u;}\n            if((self_id%uint(rsz))==0u){fragColor = vec4(0.);return;}\n            \n            v=save_all(v.xy,vel,self_id,timer,color_id);\n            fragColor = v; \n        } else {\n        ivec2 ipx = ivec2(fragCoord);\n        if ((iFrame%(timer_spn_l/1)==0)&&(ipx.x + ipx.y) %2 == 0 && ipx.y % 2 == 0){\n        \n            ivec2 mid = (ipx-ivec2(iResolution.xy/2.)+ivec2(iResolution.xy/2.)%2)/2;\n            if(max_lines>11){mid.x+=(ipx.y%3)*((iFrame%2));mid.y+=max_lines/4;}\n            int ix = 0;int iy = 0;\n            if(mid.x<0&&mid.y>0){\n                ix=1;iy=(((max_lines))%2);\n                mid.x=abs(mid.x);\n                mid.y=(max_lines/2+0)-mid.y-iy+(((max_lines))%2);\n            }\n            if(max_lines>11){mid.y+=(iFrame%4);}\n            mid.x+=-int(0.25*radius*min(iResolution.y,iResolution.x));\n            \n            if(mid.x==1&&mid.y>=0&&mid.x<rsz&&mid.y<max_lines/2+(((max_lines))%2)){\n                mid.y+=ix*(max_lines/2)+iy;\n                uint id=uint(mid.x+mid.y*rsz);\n                ivec2 tidp=ivec2(int(id)%rsz,int(id)/rsz);\n                vec2 pos=middle;\n                vec2 vel=vec2(0.);\n                timer=uint(fade_time);\n                color_id = uint((iFrame/(timer_spn_l*20))%0xf);\n                fragColor = save_all(pos,vel,id,timer,color_id);\n                return;\n            }\n        } else fragColor = vec4(0.);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef set_max_lines\n    max_lines = set_max_lines;\n#else\n    max_lines = int(2.+sqrt(min(iResolution.x,iResolution.y)));\n#endif\n    max_particles= 0xfffff/max_lines;\n    ivec2 ipx = ivec2(fragCoord);\n    if(ipx==ivec2(iResolution.xy)-1){\n        float lc = texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).z;\n        float imz=iMouse.z;\n        //imz=-1.;\n        float c=is_reset()?iTime:(imz>0.?(lc>=0.?-iTime:lc):abs(lc));\n        float ld = abs(texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).w);\n        float d=is_reset()?float(iFrame):min(-1.*ld,-1.);\n        fragColor=vec4(iResolution.xy,c,d);\n        return;\n    }\n    sim_step(fragColor, fragCoord);\n}\n\n\n// return vec4(a,b,c,d)\n// a b - target pos\n// c - init timer (max 0xffff)\n// d - destroy -1 (to fix real time ID resize)\n\n// in ivec2 ipx is particle id in vec2(column,row)\n\nvec4 particle_data(ivec2 ipx){\n\n    float max_pos=iResolution.x;\n    float max_posy=iResolution.y;\n    int sz1 = int(min(max_posy,max_pos)*0.25);\n    int rsz = min(sz1,max_particles);\n    \n    \n    if(ipx.x>=rsz||ipx.y>=rsz)return vec4(-1.);\n    \n    int self_id = ipx.x+ipx.y*rsz;\n    vec2 pos = vec2(0.);\n    float timer_save = 0.; //used only on init particles\n    \n    vec2 tuv = vec2(ipx)/float(rsz)-0.5;\n    \n    self_id = (ipx.x+ipx.y*rsz);\n    \n    \n    vec2 ttuv = toPolar(tuv*2.);\n    ivec2 ipfx = ivec2((ttuv+vec2(0.5,0.))*float(rsz));\n    \n    float d=float(self_id);\n    \n    float amount = float(max_lines);\n    float len = float(rsz);\n    float fsize = float((len)*(amount));\n    \n    float res = iResolution.x/iResolution.y;\n    \n    float segt = floor(float(self_id)/len);\n    if(segt<amount){\n    float ts = 0.1285*len;\n    \n    //float segId = ts+mod(mod(float(self_id),len)+float(iFrame/30),len);\n    float segId = ts+mod(float(self_id),len);//self_id+iFrame/30\n    \n    float dlen = mod(float(self_id),len)/len;\n    \n    // do not multiply timers in code, change here (because fract)\n    float timer2 = fract(max(iTime-15.,0.)*0.018);\n    //timer2=0.6;\n    float timer0 = fract(iTime*0.02);\n    float timer01 = fract(iTime*0.0435);\n    //timer0=0.0;\n    //timer01=0.0;\n    float timer3 = fract(iTime*0.01);\n    float timer4 = fract(iTime*0.007);\n    float timer5 = fract(iTime*0.015);\n    //timer3=0.0;\n    //timer4=0.0;\n    //timer5=0.0;\n    \n    float s = (0.1+0.33*pow( 4.0*timer2*(1.0-timer2), 100.))*noise2(vec2(1., 12.*(1.+segId)/len));\n    vec3 p = vec3(40.*float(self_id)/fsize , 1.,  2.*segId/len);\n    float tfl = mix((2.*dlen),1.*noise3(p),0.5*pow(4.0*timer5*(1.0-timer5),2.));\n    vec2 tpos = vec2(cos(float(self_id)/fsize * PI * 2.)*(radius+(0.5665-0.13*pow(dlen,2.))*dlen),\n                     sin(float(self_id)/fsize * PI * 2.)*(radius+(0.5665-0.13*pow(dlen,2.))*1./res*dlen)*res);\n    \n    float mouse_timer = texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).z;\n    if(mouse_timer<0.)\n    {\n        mouse_timer=iTime-abs(mouse_timer);\n        float mouse_timer2=smoothstep(7.,10.,mouse_timer);\n        mouse_timer=1.-smoothstep(0.,1.,mouse_timer);\n        float ttmr = clamp((dlen-(radius*4.))*1000.,0.,1.);\n        tpos*=0.135+(0.865*ttmr)*mouse_timer+(0.865*(1.-ttmr));\n        vec2 iml =(iMouse.xy/iResolution.xy-0.5);\n        float lim = length(iml);\n        iml+=0.0001*(1.-abs(sign(iml)));\n        tpos+=ttmr*mouse_timer2*(1.-mouse_timer)*min(lim,0.45)*normalize(iml);\n    }\n    \n    tpos += vec2(cos((tfl+timer01) * PI*4.) * (1.-0.7313*pow(dlen,2.)) , sin((tfl+timer01) * PI*4.) * (1.-0.7313*pow(dlen,2.)) *res) * segId/len * s;\n    \n    \n    float tt = pow( 4.0*timer3*(1.0-timer3), 3.);\n    tpos += 0.09*(max(pow( 4.0*timer4*(1.0-timer4), 2.)-tt*10.,0.))*vec2(cos((float(self_id)/fsize+timer0) * PI*4.) * (1.-0.87313*pow(dlen,2.)) , sin((float(self_id)/fsize+timer0) * PI*4.) * (1.-0.87313*pow(dlen,2.)) *res)*(-0.062+segId/len);\n\n    \n    tpos += tt*.5*tpos*vec2(cos(5.*PI*segId/len),sin(5.*PI*segId/len));\n    pos=(vec2(tpos)+0.5);\n    \n    }\n    if(segt>=amount)d=-1.;\n    \n    vec4 ret=vec4(pos,timer_save,d);\n    return ret;\n}\n\nfloat hash3(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat hash2(vec2 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return -1.+2.*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise3( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash3(i+vec3(0,0,0)), \n                        hash3(i+vec3(1,0,0)),f.x),\n                   mix( hash3(i+vec3(0,1,0)), \n                        hash3(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash3(i+vec3(0,0,1)), \n                        hash3(i+vec3(1,0,1)),f.x),\n                   mix( hash3(i+vec3(0,1,1)), \n                        hash3(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nfloat noise2( in vec2 p)\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash2( i + vec2(0.0,0.0) ), \n                     hash2( i + vec2(1.0,0.0) ), u.x),\n                mix( hash2( i + vec2(0.0,1.0) ), \n                     hash2( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\n// render particles and motion blur\n\n\n//2 channel motion blur\n\n#define SAMPLES_LOCK 14\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord , vec4 newc)\n{\n    //vec4 newc = texture(iChannel2, fragCoord.xy / iResolution.xy);\n    vec4 xsample = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    newc*=1.65;\n    \n    float next = xsample.w + float(1.f);\n    float prev = xsample.w;\n    float divisor = prev / next;\n    xsample.xyz = xsample.xyz * vec3(divisor) + newc.xyz * (1.0f - divisor);\n    xsample.w = min(next, float(SAMPLES_LOCK-1));\n    \n    fragColor = xsample;\n}\n\n\nint max_lines;\nint max_particles; // per line because id 0xfffff max\n\nvec4 loadval(ivec2 io) {return loadvalg(io, iResolution.xy);}\n\n\nvec4 ballD(in vec2 ipos, in vec2 ballp)\n{\n    float d = distance(ipos, ballp)/BALL_SIZE;\n    return vec4(clamp(sign(1.0-d), 0.0, 1.0)*(1.-d) * float(ballp.x > 0.0)) ;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvec4 getV(in ivec2 p,float max_pos,float max_posy){\n    vec4 tval=texelFetch( iChannel0, ivec2(p), 0 );\n    if(p==ivec2(iResolution.xy)-1) return vec4(0);\n    float p1=decodeval_pos(floatBitsToUint(tval.x))*max_pos;\n    float p2=decodeval_pos(floatBitsToUint(tval.y))*max_posy;\n    float v1=decodeval_vel(floatBitsToUint(tval.z));\n    float v2=decodeval_vel(floatBitsToUint(tval.w));\n    return vec4(p1,p2,v1,v2);\n}\nuvec2 extra_dat_pos(ivec2 p){\n    vec4 tval=texelFetch( iChannel0, ivec2(p), 0 );\n    return uvec2(floatBitsToUint(tval.x)&0xfffu,floatBitsToUint(tval.y)&0xfffu);\n}\n\nuvec2 extra_dat_vel(ivec2 p){\n    vec4 tval=texelFetch( iChannel0, ivec2(p), 0 );\n    return uvec2(floatBitsToUint(tval.z)&0xffu,floatBitsToUint(tval.w)&0xffu);\n}\n\nuvec2 get_id(ivec2 p){\n    uvec2 v1=extra_dat_pos(p);\n    uint iret=(v1[0]<<12)|(v1[1]<<0);\n    return uvec2(iret&0xfffffu,iret>>20);\n}\n\nuint get_timer(ivec2 p){\n    uvec2 v1=extra_dat_vel(p);\n    uint iret=(v1[0]<<8)|(v1[1]<<0);\n    return iret;\n}\n\nbool is_reset(){\n    if(texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).w<-.05)return false;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef set_max_lines\n        max_lines = set_max_lines;\n#else\n        max_lines = int(2.+sqrt(min(iResolution.x,iResolution.y)));\n#endif\n        max_particles= 0xfffff/max_lines;\n        float max_pos=iResolution.x;\n        float max_posy=iResolution.y;\n        int sz = int(min(max_posy,max_pos)*0.25);\n        int rsz = min(sz,max_particles);\n        int fade_frame = max(iFrame-abs(int(texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).w))-fade_time/100,0);\n        if(is_reset()){fragColor=vec4(0.);return;}\n        float scpx=loadval(ivec2(0,0)).z-0.015;\n        float scpy=loadval(ivec2(0,0)).w-0.015;\n        float mn=1.;\n        if(loadval(ivec2(0,0)).x>0.95)mn=0.;\n        vec2 fc=fragCoord;\n        fc+=mn*iResolution.y*vec2(scpx,scpy); //real scale\n\n\n\n        ivec2 cellIndex = ivec2(fc );\n\n        vec4 res = vec4(0.0, 0.0, 0.0, 1.0);\n        vec2 worldPos = fc ;\n        for (int x=-1; x<=1; x++) {\n            for (int y=-1; y<=1; y++) {\n\n                ivec2 tp = max(cellIndex+ivec2(x,y), ivec2(0));\t\t\t\n\n                vec4 ball  = getV(tp,max_pos,max_posy);\n                vec2 p = ball.xy;\n                vec2 vel = ball.zw;\n\n                float d=sdBox((worldPos-p.xy),vec2(BALL_SIZE)*.799);\n                d=1.-smoothstep(0.15,0.95,d);\n                //d=1.-smoothstep(-0.5,0.5,d);\n                d=d * float(ball.x > 0.0) ;\n                \n                \n                uvec2 tmpid = get_id(tp);\n                int self_id=int(tmpid.x);\n                int color_id=int(tmpid.y);\n                int self_timer=int(get_timer(tp));\n                \n                vec4 shade=vec4(0.,0.,0.,1.);\n                shade.rgb=get_pal(color_id);\n                shade*=d;\n                \n                //to make loop gif\n/*\n                float ttimer = mod(iTime+6.,44.)-6.;\n                shade*=float(clamp((self_id%rsz)+1-int((ttimer-19.)*10.),0,1));\n                shade*=float(clamp(rsz-(self_id%rsz)-int((9.-ttimer)*10.),0,1));\n*/\n                shade*=clamp((float(fade_frame)-float(fade_time)*float(self_id%rsz)/float(rsz))/float(fade_time),0.,1.);\n                //res=max(res, shade);\n                //res=res+ shade;\n                if(length(shade)>0.1)res=res*shade + shade+res*0.5;\n\n            }\n        }\n    fragColor = res;\n    //fragColor=clamp(fragColor,0.,1.);\n    mainImage2(fragColor, fragCoord , fragColor);\n\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n\n// Mix of two\n// mainImage TAA\n// mainImage2 motion blur\n\n\n\nbool is_reset(){\n    if(texelFetch(iChannel0,ivec2(iResolution.xy)-1,0).w<-.5)return false;\n    return true;\n}\n\n//2 channel motion blur\n\n#define SAMPLES_LOCK 17\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord, vec4 newc)\n{\n    if(is_reset()){fragColor=vec4(0.);return;}\n    //vec4 newc = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    vec4 xsample = texture(iChannel2, fragCoord.xy / iResolution.xy);\n    newc*=1.15;\n\n    float next = xsample.w + float(1.f);\n    float prev = xsample.w;\n    float divisor = prev / next;\n    xsample.xyz = xsample.xyz * vec3(divisor) + newc.xyz * (1.0f - divisor);\n    xsample.w = min(next, float(SAMPLES_LOCK-1));\n    \n    fragColor = xsample;\n}\n\n\n\n\n\n\n/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\n#define TEXTURE_CURRENT iChannel1\n#define TEXTURE_PREV iChannel2\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 currentBuffer = RGBToYCoCg(textureLod(TEXTURE_CURRENT, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(TEXTURE_PREV, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(TEXTURE_CURRENT, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n    \n    mainImage2(fragColor, fragCoord , fragColor);\n}\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n\n// Configurable (Edit this)\n\n// max particle lines, uncomment to use, else it depends of iResolution\n//#define set_max_lines 7\n\nconst float radius = 0.027; //middle radius\n\n\nconst int timer_spn = 23; //timer to respawn particles (frames, each X frames)\n\n\nconst int fade_time = 350; // frames>0 (1 min)\n\n\n// particle config, change VEL_LIMIT for speedup and M to make jutter less\n// example VEL_LIMIT = 0.7 * BALL_SIZE; M = 0.8 * BALL_SIZE;\n// (will speedup but particle wil destroe ach other oncollision way too oftern)\n// particles jitter because I use uint as pos and speed so there huge precision loss\n\nconst float BALL_SIZE = 0.9; // should be between sqrt(2)/2 and 1\nconst float BALL_D = 2. * BALL_SIZE; \nconst float VEL_LIMIT = 0.453 * BALL_SIZE;\nconst float maxG = 0.004; // max gravity\nconst float maxPf = 0.0604; // max pos mov \nconst float E_FORCE = 1.9;\nconst float M = 0.54 * BALL_SIZE;\nconst float DAMP_K = 0.98;\nconst float MOUSE_F = 5.38;\n\nfloat decodeval_pos(uint varz) {\n    varz=varz>>12;\n    return float(varz)/float(0xfffff);\n}\n\nuint encodeval_pos(uvec2 colz) {\n    return uint(((colz[0]&0xfffffu)<< 12)|((colz[1]&0xfffu)<< 0));\n}\n\n\nfloat decodeval_vel(uint varz) {\n    varz=varz>>8;\n    int s=int(varz&0xfu);\n    float si=s>0?-1.:1.;\n    varz=varz>>4;\n    return si*float(varz)/float(0xfffff);\n}\n\nuint encodeval_vel(float vel, uint ev) {\n    uint v = uint(clamp(abs(vel),0.,1.)*float(0xfffff))<<4u;\n    if(vel<0.)v+=0xfu;\n    return uint((v<< 8)|((ev&0xffu)<< 0));\n}\n\nvec4 loadvalg(ivec2 io, vec2 ires) {\n        if(io==ivec2(0,0)){\n        float z=1.; //0.5\n        float s=.864;\n        float px=((ires.xy/ires.y)*0.5).x/2.;\n        float py=0.01;\n        return vec4(z,s,px,py);\n    }\n    if(io==ivec2(1,0)){\n        float irx=ires.x; //size of board //bug float\n        float iry=ires.y; //only for init/reset\n        float a=-1.;\n        float b=-1.;\n        return vec4(irx,iry,a,b);\n    }\n    if(io==ivec2(1,1)){\n        float fpx=0.;\n        float fpy=0.;\n        float a=-1.;\n        float b=0.;\n        return vec4(fpx,fpy,a,b);\n    }\n    if(io==ivec2(0,1)){\n        float gx=0.0;\n        float gy=-0.0; //grav dir y\n        float a=0.;\n        float b=0.;\n        return vec4(gx,gy,a,b);\n    }\t\n    return vec4(0.);\n}\n\n// https://www.shadertoy.com/view/ll2GD3\n// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 get_pal(int cid){\n    //return vec3(1.);\n    float ix = fract(float(cid)/float(0xf)+1./16.);\n    vec3 ret = vec3(0.051);\n    //vec3 tpal=pal( ix, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    vec3 tpal=pal( ix, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    tpal=clamp(tpal,0.,1.);\n    vec3 s = sign(max(tpal-0.1,vec3(0.)));\n    ret+=tpal+vec3(0.127)*s+vec3(0.127)*(1.-s);\n    return 1.85*ret;\n}\n\n#define PI 3.141592653589793\nvec2 toPolar(vec2 v)\n{\n    v.y+=0.001*(1.-abs(sign(v.y)));\n    return vec2(atan(v.y, v.x)/PI, length(v));\n}\n\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlScDz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[588, 588, 645, 645, 1180], [1449, 1449, 1476, 1476, 1600], [1602, 1602, 1631, 1631, 1789]], "test": "untested"}
{"id": "ftByDD", "name": "voronoi experiments", "author": "skal", "description": "experimenting with Voronoi distances and smoothing", "tags": ["voronoismooth"], "likes": 9, "viewed": 218, "published": 3, "date": "1649669166", "time_retrieved": "2024-07-30T16:54:33.593619", "image_code": "//\n// Playing with Voronoi smooth distance\n//\n//  (basically redoing https://www.shadertoy.com/view/ldl3W8 on my own)\n//\n////////////////////////////////////////////////////////////////////////\n\n#define ISO_PHASE 5.    // to animate the iso-lines\n#define SMOOTH_MIN_PHASE 5.\n\n// see https://www.shadertoy.com/view/4djSRW\nvec2 hash2(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1021, .1013, .0977));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n////////////////////////////////////////////////////////////////////////\n// distance from origin to segment [p1, p2]\nfloat SegmentDistance(vec2 p1, vec2 p2) {\n  vec2 dir = p2 - p1;\n  float norm = 1. / dot(dir, dir);\n  float frac = clamp(norm * dot(dir, -p1), 0.0, 1.0);\n  return length(p1 + frac * dir);\n}\n\n// distance from origin to (p1+p2)/2 along (p1->p2)\nfloat CellDistance(vec2 p1, vec2 p2) {\n  vec2 mid = 0.5 * (p1 + p2);\n  vec2 dir = normalize(p2 - p1);\n  return dot(mid, dir);\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvec2 GetCenter(vec2 id, float theta) {\n  vec2 phi = 6.283185 * hash2(id) + theta;\n  return 0.5 + 0.5 * sin(phi);\n}\n\nfloat VoronoiDistance(vec2 p, float t, int n, out vec2 p1) {\n  vec2 cell = floor(p);\n  vec2 sub_pos = fract(p);\n  float d1 = 1.e6, d2 = 1.e7;\n  vec2 p2;\n  for (int j = -n; j <= n; ++j) {\n    for (int i = -n; i <= n; ++i) {\n      vec2 offset = vec2(float(i), float(j));\n      vec2 center = offset + GetCenter(cell + offset, t) - sub_pos;\n      float d = dot(center, center);\n      if (d < d1) {\n        d2 = d1;\n        d1 = d;\n        p2 = p1;\n        p1 = center;\n      } else if (d < d2) {\n        d2 = d;\n        p2 = center;\n      }\n    }\n  }\n  return SegmentDistance(p1, p2);\n}\n\n// polynomial smooth min\nfloat smin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * k * 0.25;\n}\n\nfloat VoronoiMin(vec2 p, float t, int n, vec2 p1, float k) {\n  vec2 cell = floor(p);\n  vec2 sub_pos = fract(p);\n  float d_min = 1.e6;\n  for (int j = -n; j <= n; ++j) {\n    for (int i = -n; i <= n; ++i) {\n      vec2 offset = vec2(float(i), float(j));\n      vec2 p = offset + GetCenter(cell + offset, t) - sub_pos;\n      if (dot(p - p1, p - p1) > 0.001) {  // not the immediate center?  \n        d_min = smin(CellDistance(p1, p), d_min, k);\n      }\n    }\n  }\n  return d_min;\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = 6. * fragCoord / iResolution.y;\n  float theta = iTime * 1.2;\n  float blend =\n      mix(0.01, 0.38, 0.5 + 0.5 * sin(SMOOTH_MIN_PHASE * theta));\n  vec2 p1;\n  float d12 = VoronoiDistance(uv, theta, 1, p1);\n  float d = VoronoiMin(uv, theta, 2, p1, blend);\n\n  vec3 col = vec3(0.);\n  if (true) {  // draw a line p2 -> p1\n    col = mix(vec3(0.2, 0.2, 0.7), col, smoothstep(0.00, 0.06, d12));\n  }\n  if (true) {  // draw iso-lines\n    float iso_d = d * (0.5 + 0.5 * sin(60. * d + iTime * ISO_PHASE));\n    float amp = 0.5 + 0.5 * sin(2. * theta * 0.5);\n    col = mix(col, amp*vec3(0.76, 0.45, 0.96), smoothstep(0.0, 0.3, iso_d));\n  }\n  if (true) {  // draw cell borders\n    col = mix(vec3(0.35, 0.65, 0.20), col, smoothstep(0.00, 0.02, d));\n  }\n  if (true) {  // draw centers\n    float d = dot(p1, p1);\n    col = mix(vec3(0.97, 0.8, 0.3), col, smoothstep(0.002, 0.005, d));\n  }\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftByDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 321, 341, 341, 477], [479, 596, 637, 637, 784], [786, 838, 876, 876, 965], [1041, 1041, 1079, 1079, 1155], [1157, 1157, 1217, 1217, 1739], [1741, 1766, 1805, 1805, 1888], [1890, 1890, 1950, 1950, 2364], [2440, 2440, 2495, 2495, 3407]], "test": "untested"}
{"id": "tlGBzm", "name": "Gas Giant Animation Almas", "author": "almeynman", "description": "How to build a gas giant, step by step.", "tags": ["animation", "gas"], "likes": 5, "viewed": 205, "published": 3, "date": "1649664861", "time_retrieved": "2024-07-30T16:54:34.396472", "image_code": "// Caosdoar 2017 (caosdoar@gmail.com)\n\n#define PI          (3.1415926535897932384626433832795)\n#define HALF_PI     (1.5707963267948966192313216916398)\n#define TWO_PI      (6.283185307179586476925286766559)\n\n\n// Spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p)\n{\n    vec2 s = sin(p);\n    vec2 c = cos(p);\n    return vec3(c.x*s.y, c.y, s.x*s.y);\n}\n\nvec2 cart2sphe(vec3 p)\n{\n    p *= inversesqrt(dot(p, p));\n    return vec2(atan(p.z, p.x), acos(p.y));\n}\n\n// Ray-sphere intersection\nfloat sphere(vec3 o, vec3 l, vec3 c, float r2)\n{\n    const float eps = 0.0001;\n    \n    float a_ = dot(l,l);\n\tvec3 p = o - c;\n    float b_ = 2.0 * dot(l,p);\n    float c_ = dot(p,p) - r2;\n    \n    float a = b_*b_-4.0*a_*c_;\n    if (a < 0.0) return -1.0;\n    a = sqrt(a);\n    float t2 = -b_ + a;\n    if (t2 < eps) return -1.0;\n    float t1 = -b_ - a;\n    float result = (t1 > eps && t1 < t2) ? t1 : t2;\n    return result * 0.5 / a_;\n}\n\nint rotl17(int v) { return (v << 17) | (v >> 15); }\n\nint hash(int x, int y, int z, int seed)\n{\n    int h = seed * 374761393;\n    h = (x ^ h) * 374761393;\n    h = (y ^ h) * 374761393;\n    h = (z ^ h) * 374761393;\n    h = (h ^ rotl17(h)) * 2246822519;\n    return h;\n}\n\nfloat noise(vec3 p, int seed)\n{\n    return float(hash(int(p.x), int(p.y), int(p.z), seed)) / 4294967296.0;\n}\n\nfloat vnoise(vec3 p, int seed)\n{\n    vec3 p0 = floor(p);\n    vec3 s = p - p0;\n    //s = s * s * (3.0 - 2.0 * s);\n    s = s * s * s * (s * (s * 6.0 - 15.0) + 10.0);\n    \n    return mix(\n        mix(\n        \tmix(noise(p0, seed), noise(p0 + vec3(1.0, 0.0, 0.0), seed), s.x),\n        \tmix(noise(p0 + vec3(0.0, 1.0, 0.0), seed), noise(p0 + vec3(1.0, 1.0, 0.0), seed), s.x),\n        \ts.y),\n        mix(\n        \tmix(noise(p0 + vec3(0.0, 0.0, 1.0), seed), noise(p0 + vec3(1.0, 0.0, 1.0), seed), s.x),\n        \tmix(noise(p0 + vec3(0.0, 1.0, 1.0), seed), noise(p0 + vec3(1.0), seed), s.x),\n        \ts.y),\n        s.z);\n}\n\nvec3 grad(vec3 p, int seed)\n{\n    return vec3(noise(p, seed), noise(p, seed + 1), noise(p, seed + 2));\n}\n\n// by: Iñigo Quilez (with small modifications for custom hash)\n// https://www.shadertoy.com/view/4dffRH\nfloat gnoise(in vec3 x, int seed)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 iu = 1.0 - u;\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = grad( p+vec3(0.0,0.0,0.0), seed );\n    vec3 gb = grad( p+vec3(1.0,0.0,0.0), seed );\n    vec3 gc = grad( p+vec3(0.0,1.0,0.0), seed );\n    vec3 gd = grad( p+vec3(1.0,1.0,0.0), seed );\n    vec3 ge = grad( p+vec3(0.0,0.0,1.0), seed );\n\tvec3 gf = grad( p+vec3(1.0,0.0,1.0), seed );\n    vec3 gg = grad( p+vec3(0.0,1.0,1.0), seed );\n    vec3 gh = grad( p+vec3(1.0,1.0,1.0), seed );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return \n        va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + \n        u.x*u.y*(va-vb-vc+vd) + \n        u.y*u.z*(va-vc-ve+vg) + \n        u.z*u.x*(va-vb-ve+vf) + \n        (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n// by: Iñigo Quilez (with small modifications for custom hash)\n// https://www.shadertoy.com/view/4dffRH\nvec4 gnoised(in vec3 x, int seed)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 iu = 1.0 - u;\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = grad( p+vec3(0.0,0.0,0.0), seed );\n    vec3 gb = grad( p+vec3(1.0,0.0,0.0), seed );\n    vec3 gc = grad( p+vec3(0.0,1.0,0.0), seed );\n    vec3 gd = grad( p+vec3(1.0,1.0,0.0), seed );\n    vec3 ge = grad( p+vec3(0.0,0.0,1.0), seed );\n\tvec3 gf = grad( p+vec3(1.0,0.0,1.0), seed );\n    vec3 gg = grad( p+vec3(0.0,1.0,1.0), seed );\n    vec3 gh = grad( p+vec3(1.0,1.0,1.0), seed );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n// Curl-noise \n// Reference\n// https://www.cct.lsu.edu/~fharhad/ganbatte/siggraph2007/CD2/content/papers/046-bridson.pdf\nvec3 curlnoise(in vec3 p, int seed)\n{\n    vec4 x = gnoised(p, seed);\n    vec4 y = gnoised(p, seed+3);\n    vec4 z = gnoised(p, seed+6);\n    return vec3(z.z - x.w, x.w - z.y, y.y - x.z);\n}\n\nvec3 noise_offset(vec3 p, float f, float s)\n{\n    p += curlnoise(p * f, 1) * s;\n    p += curlnoise(p * f, 1) * s;\n    p += curlnoise(p * f, 1) * s;\n    return p;\n}\n\n\nfloat y_equator(float y)\n{\n    return pow(abs(y), 1.0) * sign(y);\n}\n\nfloat y_noise(float y)\n{\n    y += texture(iChannel0, vec2(y * 0.05, 0.0)).x * 0.08;\n    y += texture(iChannel0, vec2(y * 0.1, 0.0)).x * 0.04;\n    y += texture(iChannel0, vec2(y * 0.2, 0.0)).x * 0.02;\n    return y;\n}\n\nvec4 swirl(vec3 p, vec3 sc, float sr)\n{\n    float t = max(0.0, 1.0 - distance(p, sc) / sr);\n    float t2 = smoothstep(0.0, 1.0, t);\n    float theta = t2 * 10.0;\n    vec4 q1 = vec4(0.0, p.x, p.y, p.z);\n    float theta_half = theta * 0.5;\n    float s = sin(theta_half);\n    float c = cos(theta_half);\n    vec4 q2 = vec4(c, s * sc.x, s * sc.y, s * sc.z);\n    vec4 q2i = vec4(q2.x, -q2.y, -q2.z, -q2.w);\n    vec4 qa = vec4(\n        q1.x*q2.x-q1.y*q2.y-q1.z*q2.z-q1.w*q2.w,\n        q1.x*q2.y+q1.y*q2.x-q1.z*q2.w+q1.w*q2.z,\n        q1.x*q2.z+q1.y*q2.w+q1.z*q2.x-q1.w*q2.y,\n        q1.x*q2.w-q1.y*q2.z+q1.z*q2.y+q1.w*q2.x);\n    vec4 q3 = vec4(\n        q2i.x*qa.x-q2i.y*qa.y-q2i.z*qa.z-q2i.w*qa.w,\n        q2i.x*qa.y+q2i.y*qa.x-q2i.z*qa.w+q2i.w*qa.z,\n        q2i.x*qa.z+q2i.y*qa.w+q2i.z*qa.x-q2i.w*qa.y,\n        q2i.x*qa.w-q2i.y*qa.z+q2i.z*qa.y+q2i.w*qa.x);\n    return vec4(q3.yzw, t2);\n    //return vec3(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n#if 1\n    vec3 cc = vec3(0.0,0.0,3.6);\n    float cam_speed = 0.1;\n    vec3 co = 3.6 * sphe2cart(vec2(cam_speed*iTime, 3.14159*0.5+0.5*sin(cam_speed*iTime))) + cc;\n    vec3 cf = normalize(cc-co);\n    vec3 cr = normalize(cross(cf, vec3(0.0,1.0,0.0)));\n    vec3 cu = normalize(cross(cr, cf));\n#else\n    vec3 cc = vec3(0.0,0.0,3.6);\n    vec3 co = vec3(0.0,2.6,3.6);\n    vec3 cf = normalize(cc-co);\n    vec3 cr = normalize(cross(cf, vec3(0.0,0.0,1.0)));\n    vec3 cu = normalize(cross(cr, cf));\n#endif\n    uv *= 3.14159 * 0.25;\n    \n    vec3 rd = normalize(cr*uv.x + cu*uv.y + cf);\n    \n    vec3 so = vec3(0.0,0.0,3.6);\n    float r = 1.0;\n    float r2 = r*r;\n    float t = sphere(co, rd, so, r2);\n    if (t > 0.0)\n    {\n        vec3 p = co + t * rd;\n        vec3 pc = p - so;\n        \n        // Bands\n        vec2 scoord_clean = cart2sphe(pc);\n        float y_clean = scoord_clean.y / PI * 2.0 - 1.0;\n        y_clean = y_equator(y_clean);\n        y_clean = y_noise(y_clean);\n        float w0_clean = sin((y_clean * HALF_PI + HALF_PI / 4.0) * 12.0f);\n        \n        // Swirls\n        float row_count = 2.0;\n        float row = round(scoord_clean.y * row_count);\n        vec3 row_rand = texture(iChannel0, vec2(row / row_count, 0.35)).rgb;\n        float swirl_size = 0.3 + 0.7 * row_rand.y;\n        float swirl_start = fract(row_rand.x * 10.0f);\n        float swirl_offset = fract(iTime * (row_rand.z * 0.9 + 0.1) * 0.03);\n        vec2 swirlc_sph = vec2((swirl_start + swirl_offset) * TWO_PI, (row + 0.5 * (1.0 - swirl_size) * (row_rand.z * 2.0 - 1.0)) / row_count);\n        vec3 swirlc = sphe2cart(swirlc_sph);\n        vec4 swirl_data = swirl(pc, swirlc, 0.9 * swirl_size * 0.5 / row_count);\n        //float h = texture(iChannel0, cart2sphe(pc + swirl_data.xyz) / PI).r;\n        float swirl_out = 1.0 - swirl_data.w;\n        pc = swirl_data.xyz;\n        \n        vec3 pc1 = noise_offset(pc, 50.0, 0.002);\n        vec3 pc2 = noise_offset(pc, 5.0, 0.02);\n        pc1 += (pc2 - pc) * 0.2;\n        pc2 += (pc1 - pc) * 0.5;\n        \n        pc2 = mix(pc2, swirl_data.xyz, swirl_data.w);\n        \n        vec2 scoord = cart2sphe(pc1);\n        float y = scoord.y / PI * 2.0 - 1.0;\n        y = y_equator(y);\n        y = y_noise(y);\n        \n        float band = (y * HALF_PI + HALF_PI / 4.0) * 12.0f;\n        float w0 = sin(band);\n        float w1 = smoothstep(-1.0, 1.0, w0) * 2.0 - 1.0;\n        float w2 = smoothstep(-1.0, 1.0, w1) * 2.0 - 1.0;\n        \n        // band force\n        float a = sin((scoord.x + w0 * 0.25) * 10.0);\n        vec3 pn = pc2 * 7.0;\n        pn += swirl_out * gnoise(pc * 20.0, 1) * 0.2;\n        vec3 ptan = cross(vec3(0.0,1.0,0.0), normalize(pc));\n        pn += swirl_out * ptan * w0_clean * 2.0;\n        \n        //pn *= 4.0;\n        float b = gnoise(pn, 1) + 0.6 * gnoise(pn * 2.0, 2) + 0.5 * gnoise(pn * 4.0, 3) + 0.4 * gnoise(pn * 8.0, 4);\n        //float c = mix(w2, 0.75 * w0_clean + 0.4 * b, abs(w0_clean));\n        float c = w2 - w0_clean * (b * 0.5 + 0.5);\n        \n        float swirl_height_dir = sign(row_rand.z - 0.5);\n        c += 0.5 * swirl_data.w * swirl_height_dir;\n        //c = clamp(c, -1.0, 1.0) - 0.2 * swirl_data.w * swirl_height_dir * b;\n        float swirl_inner = max(0.0, swirl_data.w);\n        //swirl_inner = pow(swirl_inner, 0.5);\n        c = mix(c, swirl_height_dir * b, swirl_inner);\n        //float a = gnoise(pc * 10.0, 1);\n        \n        \n        \n        fragColor = vec4(vec3(c * 0.5 + 0.5), 1.0);\n        //fragColor = vec4(vec3(swirl_data.w), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(vec3(0.1), 1.0);\n    }\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 246, 270, 270, 354], [356, 356, 380, 380, 459], [461, 488, 536, 536, 920], [922, 922, 941, 941, 973], [975, 975, 1016, 1016, 1187], [1189, 1189, 1220, 1220, 1297], [1299, 1299, 1331, 1331, 1911], [1913, 1913, 1942, 1942, 2017], [2019, 2124, 2159, 2171, 3525], [3527, 3632, 3667, 3679, 5388], [5390, 5511, 5548, 5548, 5697], [5699, 5699, 5744, 5744, 5862], [5865, 5865, 5891, 5891, 5932], [5934, 5934, 5958, 5958, 6149], [6151, 6151, 6190, 6190, 7053], [7055, 7055, 7112, 7112, 10801]], "test": "untested"}
{"id": "7l2yWh", "name": "column opRevolution", "author": "jorge2017a2", "description": "column opRevolution", "tags": ["columnoprevolution"], "likes": 4, "viewed": 185, "published": 3, "date": "1649643897", "time_retrieved": "2024-07-30T16:54:35.355907", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//column opRevolution--10-abril-2022\n//referencia de informacion Iq,Shane,FabriceNeyret2, oneshade,ocb,dr2....muchos\n//https://iquilezles.org/articles/distfunctions2d\n//https://iquilezles.org/articles/distfunctions\n//https://thebookofshaders.com/glossary/?search=clamp\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n// iq formula\nvec2 opRevolution( in vec3 p, float w )\n{  return vec2( length(p.xz) - w, p.y ); }\n\nfloat figuraSimple(vec2 p)\n{   float d1= sdBox( p,vec2(0.5,3.0) );\n    float d2= sdBox(p-vec2(-2.5,-1.),vec2(2.0,1.5) );\n    float d3= sdCircle(p-vec2(-1.0,1.2), 1. );\n    float d4= sdCircle(p-vec2(-2.0,0.0), 1.5 );\n    float duni= Union(d1, d2);\n    duni= Union(duni, d3);\n    duni= Union(duni, d4);\n    return duni;\n}\n\nvec2 FiguraConRevolucion(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n    p.y-=10.0;\n    p.xyz=vec3(p.x, -p.z, p.y);\n    vec2 qrev=opRevolution(p,10.0);\n    float d1= figuraSimple(qrev);\n    float d2= sdBox(p-vec3(0.0,0.0,-5.0), vec3(15.0,5.0,6.0) );\n    float dif= Difference(d1,d2);\n    res =opU2(res, vec2(dif,100.0));\n    return res;\n}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat figuraFlor(vec2 p)\n{  float res=9999.9;\n    float num=6.0;\n    float ang=radians(360.0/num);\n    for(float i=0.0;i<num;i++)\n    {   float angnew=ang*i;\n        vec2 pnew= Rotate(p, vec2(1.5,0.0) , angnew);\n        float d1= sdCircle(pnew, 0.7 );\n        res= Union(res,d1);\n    }  return res;\n}\n\nvec2 resFlor(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n    vec3 p0=p;\n    p.xyz=p.xzy;\n    float d1= figuraFlor(p.xy);\n    float d2=sdBox( p0-vec3(1.0,5.0,0.0), vec3(3.0,10.0,3.0) );\n    float dInte= Intersect(d1, d2);\n    res =opU2(res, vec2(dInte,101.0)); \n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,57.0));\n    p.y=p.y-5.0;\n    p.z= opRep1D(p.z, 20.0 );\n\n    vec2 re1= FiguraConRevolucion(p);\n    p.x=abs(p.x)-8.0;\n    p.y+=2.0;\n    vec2 re2= resFlor(p);\n    res =opU2(res, re1);\n    res =opU2(res, re2);\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor)+0.2; }\n\t\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==57) {return pattern( p.xz );}\n   if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,10.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   float g=sin(iTime*0.6);\n   float y = clamp(g,-0.4,0.2); \n   rd= rotate_x(rd,y);\n\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1)  //6 \n\n);\n\nvec3 getColor(int i)\n{  if (i>-1 )  return Arrcolores[i];}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2yWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[733, 733, 765, 765, 849], [851, 851, 895, 895, 922], [923, 923, 963, 963, 990], [991, 991, 1036, 1036, 1064], [1066, 1066, 1102, 1102, 1147], [1149, 1149, 1183, 1183, 1279], [1280, 1280, 1314, 1314, 1405], [1406, 1406, 1440, 1440, 1531], [1533, 1533, 1570, 1570, 1644], [1646, 1646, 1681, 1681, 1704], [1706, 1720, 1761, 1761, 1802], [1804, 1804, 1832, 1832, 2123], [2125, 2125, 2159, 2159, 2461], [2463, 2479, 2527, 2527, 2605], [2607, 2607, 2633, 2633, 2907], [2909, 2909, 2931, 2931, 3185], [3187, 3187, 3212, 3212, 3558], [3560, 3560, 3584, 3584, 3746], [3748, 3748, 3796, 3796, 4075], [4077, 4077, 4121, 4121, 4442], [4444, 4444, 4481, 4481, 4738], [4740, 4740, 4830, 4830, 5790], [5792, 5792, 5841, 5841, 5980], [5982, 5982, 6014, 6014, 6211], [6213, 6261, 6289, 6289, 6477], [6479, 6479, 6549, 6549, 6758], [6760, 6760, 6787, 6787, 6876], [6878, 6878, 6936, 6936, 6984], [6986, 6986, 7009, 7009, 7121], [7123, 7123, 7154, 7154, 7774], [7776, 7776, 7833, 7833, 8348]], "test": "untested"}
{"id": "Nl2yDh", "name": "fake sphere", "author": "vnvthedark", "description": "sphere", "tags": ["sphere"], "likes": 0, "viewed": 189, "published": 3, "date": "1649634230", "time_retrieved": "2024-07-30T16:54:36.365208", "image_code": "vec4 sphere(vec4 data, vec4 color, vec3 camOrigin, float camScale, vec2 centerCoord, vec4 lightPos, float ambient)\n{\n    vec3 ro = camOrigin + vec3(camScale*(centerCoord).xy,0);\n    vec3 rd = vec3(0.0,0.0,-1.0);\n    if(length(ro.xy - data.xy) > data.w){\n        return vec4(0);\n    }\n    \n    vec3 toCenter = data.xyz - ro;\n    float t0 = dot(rd, toCenter);\n    \n    float d = pow(-pow(length(toCenter),2.0)+pow(t0,2.0), .5);\n    \n    if(t0<0.0){\n        return vec4(0);\n    \n    }\n    \n    float thc = pow(pow(d,2.0)+pow(data.w,2.0), .5);\n    \n    vec3 point = (t0 - thc)*rd+ro;\n    \n    vec3 normal = (data.xyz - point);\n    normal = normal/length(normal);\n    \n    vec3 lr = point - lightPos.xyz;\n    \n    float lightDist = length(lr)*.1;\n    \n    lr = lr/(lightDist*lightDist+1.0);\n    \n    float light = dot(lr, normal)*lightPos.w/lightDist;\n    light = max(light, 0.0);\n    \n    \n    return vec4((light)*color.xyz + ambient * color.xyz,1.0);\n\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ambient = .03;\n    \n    vec4 sp = vec4(0.0,0.0,-60.0,iResolution.x/5.0);\n    vec4 color = vec4(0.1,.70,1.0,1.0);\n    vec3 camOrigin = vec3(0.0);\n    float camscale = 1.0;\n    vec2 center = fragCoord - iResolution.xy/2.0;\n    vec4 light = vec4(4500.0,4500.0,-300.0,100000.0);\n    \n    float lr = 10000.0;\n    float lightSpeed = .5;\n    \n    \n    vec3 lightPos = vec3(0, sin(iTime*lightSpeed)*lr, cos(iTime*lightSpeed)*lr);\n    lightPos += sp.xyz;\n    light = vec4(lightPos, light.w);\n    \n    fragColor = sphere(sp,color,camOrigin,camscale,center,light, ambient);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2yDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 116, 116, 952], [955, 955, 1012, 1012, 1587]], "test": "untested"}
{"id": "ftjyR1", "name": "hexrosa", "author": "ufffd", "description": "aperiodic hexrosa tiling as shown by markus rissanen\nhttps://archive.bridgesmathart.org/2016/bridges2016-209.pdf\nmodified from a p5js sketch I made some years back", "tags": ["tiling", "aperiodic", "hexrosa"], "likes": 4, "viewed": 98, "published": 3, "date": "1649633740", "time_retrieved": "2024-07-30T16:54:37.301704", "image_code": "// naive implementation of the 'hexrosa' aperiodic tiling\n// see shane's radial tiling truchet for a better implementation:\n//   https://www.shadertoy.com/view/NlcBRs\n\n#define PI 3.141592653589793\nconst int nfold = 7;\nconst float hexH = 1.;\nconst int hexL = 7;\nvec2 center = vec2(0.);\nfloat initR = 0.;\nconst float angle1 = 1. / float(nfold) * PI * 2.;\nconst float angle2 = PI * 0.5 - angle1 / 2.;\nconst float sidelength = hexH / (2. * cos(0.5 * angle1) + 1.);\nconst float hexW = 2. * sidelength * sin(0.5 * angle1);\nconst float offX = hexW / 2.;\nconst float offY = sidelength + ((hexH - sidelength) / 2.);\n\n\nfloat hexSDF(in vec2 position) {\n    position /= vec2(sqrt(3.0), 1.5); // magic numbers\n    position.y -= 0.5;\n    position.x -= fract(floor(position.y) * 0.5);\n    position = abs(fract(position) - 0.5);\n    return abs(1. - max(position.x * tan(angle2) * 1.15 + position.y, position.x / hexW * 1.15)) * sqrt(3.) * 0.5; // magic numbers\n}\n\nfloat drawHex(in vec2 position, in float size) {\n    // position *= vec2(hexH,hexW)/hexH;\n    float sdf = hexSDF(position);\n    if (position.x < -0.5) sdf = 0.;\n    if (position.x > 0.5) sdf = 0.;\n    if (position.y < -0.5) sdf = 0.;\n    if (position.y > 0.5) sdf = 0.;\n    return smoothstep(size-0.002,size+0.002,sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec3 color = vec3(0.);\n    float dt = iTime * 0.5;\n    \n    #define LOOP_METHOD 0\n    #define GRID_METHOD 1\n    #define USE_METHOD LOOP_METHOD\n    #if USE_METHOD == LOOP_METHOD    \n    //the hex rosa is made of 2 sets of nfold# of what I call 'branches'. a branch is a single triangular array of 'seeds' drawn as 'hexes' (base hexagons shapes)\n    //this loop doubles the process for each set of branches\n    for(int outset=0;outset<2;outset++){    \n        vec2 ouv = uv;\n        ouv *= Rot(float(outset) * PI / float(nfold));\n        //this loop divides the circle by nfold# and draws that many branches, evenly spaced\n        for (int branch=0;branch<nfold;branch++){\n            vec2 buv = ouv;\n            buv *= Rot(angle1 * float(branch));\n            buv.y -= .08 / float(nfold); // magic numbers\n            buv.y += sidelength * float(outset) * 0.41; // magic numbers\n            //this loop sets and positions the row being drawn in the current branch\n            for (int row=0;row<hexL;row++) { // the hexagonal loop could probably be optimized\n                //this loop sets and positions the individual seed being drawn in the current row\n                for (int col = row * -1; col <= row; col += 2) {\n                    vec2 huv = buv;\n                    float camera_shutter = 0.;\n                    huv += camera_shutter; // shutter\n                    vec2 hexcenter = vec2(float(col)*offX,float(row)*offY) * 0.41;\n                    huv += hexcenter; // magic numbers\n                    huv.y += offY/PI;\n                    float mainhex = drawHex(huv, 0.749); // magic numbers\n                    color += mainhex * 0.8;\n                    vec3 hexcol = 0.1*vec3(outset*4,branch*1,row+col)*drawHex(huv, 0.76); // magic numbers\n                    color -= hexcol;\n                }            \n            }            \n        }\n    }\n    #elif USE_METHOD == GRID_METHOD\n    \n    #endif\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\n\n\n// from shane's radial tiling truchet:\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Signed distance to a line passing through \"a\" and \"b\".\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\nconst vec2 s = vec2(2. + 1.7320508, 1);\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n \n    // Generalized elongated hexagon function, based on the \n    // partitioning rectangle above.\n    //\n    // I did this in a hurry. There'd be better ways to go \n    // about it, but it'll do for now.\n    float x = (s.x - s.y)/2.;//(1. + 1.7320508)/2.;\n    float ln;\n    p = abs(p);\n    ln =  distLineS(p, vec2(-.5, .5), vec2(.5, .5));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln, distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    return ln;\n    \n    /*    \n    float x = (1. + 1.7320508)/2.;\n    float ln =  distLineS(p, vec2(-.5, -.5), vec2(-x, 0));\n    ln =  max(ln, distLineS(p, vec2(-x, 0), vec2(-.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(-.5, .5), vec2(.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln,distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    ln =  max(ln, distLineS(p, vec2(.5, -.5), vec2(-.5, -.5)));\n    return ln;\n*/\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n  \n    \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    //return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + offs);\n    return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n} ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjyR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[609, 609, 641, 641, 946], [948, 948, 996, 1037, 1269], [1271, 1271, 1328, 1328, 3385]], "test": "untested"}
{"id": "Ns3XR4", "name": "Crystal Computers II", "author": "byt3_m3chanic", "description": "Crystal Computers II  // Splitting space and folding it - moving a pseudo retro tape drive in that space - then unfold to view. \n\n", "tags": ["crystalcomputers"], "likes": 24, "viewed": 413, "published": 3, "date": "1649633096", "time_retrieved": "2024-07-30T16:54:38.345913", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    4/10/22 @byt3_m3chanic\n    Crystal Computers II\n\n    I like the whole glass/transparent thing a lot - rocking \n    my refraction loop (thanks @blackle). I love those little\n    plastic boxes / transparent containers - project boxes. so\n    thats where this kind of comes from - more just playing\n    visually.\n    \n    Technically its just a of folds and a version of a retro \n    pseudo tape drive [IBM style]\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\nmat2 rot (float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\nfloat lsp(float begin, float end, float t) {return clamp((t-begin)/(end-begin),0.,1.);}\nfloat eoc(float t) {return (t=t-1.)*t*t+1.;}\n\n// http://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p) {\n    const float angle = 2.*PI/3.;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (3./2.)) ? abs(c) : c;\n} \n\n// The Folds\nvoid tet(inout vec4 p) {\n\tp = abs(p);\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n}\nvoid sep(inout vec4 p){\n\tif (p.x + p.y<0.) p.xy = -p.yx;\n\tif (p.x + p.z<0.) p.xz = -p.zx;\n\tif (p.y + p.z<0.) p.zy = -p.yz;\n}\n//@iq thanks for the sdf's!\nfloat cap( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat sdbox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.))+min(max(p.x,max(q.y,q.z)),0.),\n      length(max(vec3(q.x,p.y,q.z),0.))+min(max(q.x,max(p.y,q.z)),0.)),\n      length(max(vec3(q.x,q.y,p.z),0.))+min(max(q.x,max(q.y,p.z)),0.));\n}\n\n//globals\nmat2 tprot,rx,ry,mmt1,mmt2,mmt3,gr;\nvec3 hit=vec3(0);vec3 hitPoint=vec3(0);\nfloat tmod,ga1,ga2,ga3,ga4,ga5,tt;\n\nconst float size = 35.;\nconst float hlf = size/2.;\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n    \n    p.xz*=gr;\n    vec4 P = vec4(p.xyz,1.);\n    tet(P);\n\n    vec3 q = P.xyz; \n    q.y-=3.;\n    q.yz*=mmt1;\n    q.x=abs(q.x)-(2.75+(3.*ga3)+ga4);\n    q.zx*=mmt2;\n    q.z=abs(q.z)-(2.-(2.25*ga1));\n    q.yx*=mmt3;\n\n    float mainbox = sdbox(q-vec3(0,1.1,0),vec3(1.5,3,.75));\n    float cutbox =  sdbox(q-vec3(.45,1.25,.775),vec3(.85,2.5,1.1));\n    mainbox = max(mainbox, -cutbox);\n\n    float frame2 = sdframe(q-vec3(0,1.1,0),vec3(1.6,3.1,.82),.075)-.0125;\n    if(frame2<res.x) res = vec2(frame2,4.);\n    float frame = sdbox(q-vec3(-.3,1.3,.7),vec3(.445,1.35,.05));\n    float tapeB = cap(vec3(q.y,q.z,abs(q.x))-vec3(2.8,.55,.65),.225,.1);\n    tapeB = min(  cap(vec3(q.y,q.z,abs(q.x))-vec3(1.95,.5,.65),.100,.1),tapeB);\n\n    vec3 tq1 = q.yzx-vec3(2.9,.25,.55);\n    tq1.x=abs(abs(tq1.x+1.65)-1.2)-.6;\n    frame = min(cap(tq1+vec3(0,.35,0),.25,.5),frame);\n    vec3 pq1 = tq1;\n    pq1.xz*=tprot;\n    modPolar(pq1.xz);\n    float tcbx = sdbox(pq1-vec3(.4,0,0),vec3(.09,.09,.075));\n    \n    float tape1 = cap(tq1,.575,.05);\n    tape1=max(tape1,-tcbx);\n    if(tape1<res.x) res = vec2(tape1,3.);\n\n    vec3 bq = q-vec3(-.9,3,.65);\n    bq.y=abs(abs(abs(bq.y)-.4)-.2)-.1;\n    bq.x=abs(bq.x)-.2;\n    float btn1 = sdbox(bq,vec3(.15,.05,.25))-.0125;\n    btn1 = min(sdbox(q-vec3(-.5,1.25,.85),vec3(.45,.3,.06))-.0125,btn1);\n    if(btn1<res.x) res = vec2(btn1,2.);\n    \n    mainbox = min(mainbox, frame);\n    if(mainbox<res.x) res = vec2(mainbox,1.);\n\n    res.x/=P.w;\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist) {\n    t*=mindist;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n) \n{\n    \n    n = normal(p,d,1.);\n    vec3 lpos =  vec3(3,10,-8);\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),0.,1.);\n\n    vec3 h = vec3(.3);\n    \n    if(m==1.) {\n        vec3 h2 =mix(vec3(.05),vec3(.4),clamp((p.y+1.)*.25,0.,1.));\n        h=mix(h2,vec3(.1),clamp((p.z+4.)*.1,0.,1.));\n    }\n\n    if(m==2.) {\n        vec3 h2=mix(vec3(.596,.110,.690),vec3(.961,.000,.094),clamp((p.x+2.)*.07,0.,1.));\n        h=mix(vec3(.600,0.525,0.039),h2,clamp((p.z+2.)*.07,0.,1.));\n    }\n    if(m==3.) {\n        vec3 h2 =mix(vec3(.000,.639,.514),vec3(.698,.608,.165),clamp((p.x+4.)*.1,0.,1.));\n        h=mix(h2,vec3(.871,.169,.847),clamp((p.y+3.)*.1,0.,1.));\n    }\n    if(m==4.) {\n        vec3 h2 =mix(vec3(.5),vec3(.1),clamp((p.y+1.)*.25,0.,1.));\n        h=mix(h2,vec3(.01),clamp((p.z+4.)*.1,0.,1.));\n    }\n    return diff*h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n    tprot=rot(T*3.);\n    tmod = mod(time,24.);\n\n    float t1 = lsp(1.,4.,tmod);\n    float t2 = lsp(8.,10.,tmod);\n    float t3 = lsp(4.,7.,tmod);\n    float t4 = lsp(12.,16.,tmod);\n    float t5 = lsp(4.,6.,tmod);\n    float t6 = lsp(8.,10.,tmod);\n    float t7 = lsp(3.,12.,tmod);\n    float t8 = lsp(15.,16.,tmod);\n    \n    ga1 = eoc(t1-t2);ga1 = ga1*ga1*ga1;\n    ga2 = eoc(t3-t4);ga2 = ga2*ga2*ga2;  \n    ga3 = eoc(t5-t6);ga3 = ga3*ga3*ga3;  \n    ga4 = eoc(t7-t8);ga4 = ga4*ga4*ga4;\n\n    tt = time*.167;\n    mmt1=rot(ga1*PI-tt);\n    mmt2=rot((ga1+ga2)*PI);\n    mmt3=rot(ga3*PI+tt);\n    gr=rot(ga1+ga2+ga3+ga4+T*.125);\n    \n    // set UV's\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(.0075);\n    \n    // to make thigns fun faster and being\n    // isometric and all - clipping the center\n    if(uv.x<.65&&uv.x>-.65){\n\n        //orthographic camera\n        const float zoom = 17.;\n        vec3 ro = vec3(uv*zoom,-zoom);\n        vec3 rd = vec3(0,0,1.);\n\n        rx = rot(-.78);\n        ry = rot( .78*sin(tt*.5));\n\n        ro.yz *= rx; ro.xz *= ry;\n        rd.yz *= rx; rd.xz *= ry;\n\n        vec3  p = ro + rd;\n        float atten = 1.;\n        float k = 1.;\n        float d = 0.;\n        float iv = 1.;\n        for(int i=0;i<128;i++)\n        {\n            vec2 ray = map(p);\n            vec3 n=vec3(0);\n            float m = ray.y;\n\n            d = i<32 ? ray.x*.5 : ray.x;\n            p += rd * d *k;\n    \n            if (d*d < 1e-7) {\n\n                C+=render(p,rd,ro,d,ray.y,n)*atten;\n\n                atten *= .575;\n                p += rd*.025;\n                k = sign(map(p).x);\n\n                if(m== 3.) {\n                    rd=reflect(-rd,n);\n                    p+=n*.01;\n                } else {\n                    vec3 rf=refract(rd,n,iv > 0. ? .85 : .1);\n                    iv *= -1.;\n                    if(length(rf) == 0.) rf = reflect(rd,n);\n                    rd=rf;\n                    p+=-n*.1;\n                }\n            } \n\n            if(distance(p,rd)>125.) { break; }\n        }\n\n    }\n \n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.5 ? C+.005 : C;\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3XR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[627, 627, 647, 647, 690], [691, 691, 715, 715, 770], [771, 771, 815, 815, 858], [859, 859, 879, 879, 903], [905, 936, 966, 966, 1191], [1194, 1207, 1231, 1231, 1410], [1411, 1411, 1434, 1434, 1535], [1536, 1564, 1603, 1603, 1708], [1709, 1709, 1740, 1740, 1825], [1826, 1826, 1868, 1868, 2144], [2320, 2320, 2338, 2338, 3834], [3836, 3836, 3881, 3881, 4073], [4075, 4075, 4147, 4147, 4972], [4974, 4974, 5015, 5029, 7203]], "test": "untested"}
{"id": "NtjcDh", "name": "Noise Test 43894242", "author": "SnoopethDuckDuck", "description": "just adding noise to a plane, first time doing it + a bit laggy on my machine", "tags": ["e"], "likes": 30, "viewed": 629, "published": 3, "date": "1649624887", "time_retrieved": "2024-07-30T16:54:39.335267", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat n2(vec2 uv) {\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\t\n\treturn 0.5 + 0.5*f;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = 0.12 * iTime;\n    vec3 ro = vec3(3. * cos(t), 0.8, 3. * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    vec2 uv = vec2(p.x + 0.1 * iTime, p.z);\n    float n = n2(uv);\n    p.y += -pow(n, 8.);\n    p.y += 0.1 * cos(length(p) * 1.5 + 100. * pow(n,16.) - iTime);\n    float d = p.y;\n    return 0.3 * d; // <- noise creates lots of artifacts / thin regions\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 3. );\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n            vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        float fresnel = pow(1.+dot(rdIn, nExit), 5.);\n        //col *= (0.5 - 0.5 * sin(100. * exp(-length(p)) - iTime)) * fresnel;\n        float fresnel2 = pow(1.+dot(rd, n), 3.); \n        \n        col = 1. - col;\n        \n        n = 0.5 + 0.5 * n;\n        //col *= exp(20. * p.x);\n        vec3 e = vec3(0.5);\n        col *= pal(atan(n.x,n.z) * 2. / pi + 0.5, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        col += fresnel2;\n        col += 0.35 * thc(6., 100. * exp(-length(p)) - iTime);\n    }\n   // col *= exp(-0.5 * length(p.xz));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [441, 441, 498, 498, 613], [615, 615, 641, 641, 1120], [1122, 1122, 1141, 1141, 1364], [1366, 1366, 1395, 1395, 1476], [1478, 1478, 1492, 1492, 1694], [1696, 1696, 1719, 1719, 1970], [1972, 1972, 2015, 2015, 2322], [2324, 2324, 2348, 2348, 2538], [2540, 2540, 2590, 2590, 2781], [2783, 2783, 2840, 2840, 4127]], "test": "untested"}
{"id": "NlScWh", "name": "Automata Test 098920842", "author": "SnoopethDuckDuck", "description": "just testing automata + effects, very messy code\n\npress r to reset", "tags": ["cellularautomata"], "likes": 2, "viewed": 274, "published": 3, "date": "1649614115", "time_retrieved": "2024-07-30T16:54:40.377481", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 1.;0.25;1.;\n    float x = texelFetch( iChannel0, ivec2(a * fragCoord), 0 ).x;\n   // x = 1.-step(x,0.99);\n    \n    \n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec3 e = vec3(0.5);\n    vec3 col = x * pal(x + 0.5 + uv.y, e ,e, e, 0.5 * vec3(0,1,2)/3.);  \n    \n    float sc = 0.98 * iResolution.y;\n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    x = texelFetch( iChannel0, ivec2(ipos), 0 ).x;\n   // float k = 0.5 * sc / iResolution.y;\n    //col = x * vec3(1.) * smoothstep(-k,k, 0.2-mlength(fpos) + 0.48 * x);\n    if (fragCoord.x > 0.5 * iResolution.x)\n        col *= x; pal (x + 0.5 + uv.y, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    col = sqrt(col) + 0.1;\n    \n    float k = 3./iResolution.y;\n    col += 0.65 * smoothstep(-k, k, -abs(uv.x - 0.5 * iResolution.x/iResolution.y)+ 0.004);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n//#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nfloat inv(float y) {\n    return 0.5 - sin(asin(1.0-2.0*y)/3.0);\n}\n\nfloat Cell(in ivec2 p) {\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).x;\n}\n\n\nfloat hash1(float n) {\n    return fract(sin(n)*138.5453123);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 px = ivec2( fragCoord );\n    \n    if (key_down(KEY_RESET) || iFrame==0) \n    {    \n        float d = mlength((fragCoord -.5* iResolution.xy ) / iResolution.y);\n        float g = hash1(fragCoord.x * 13.0  + 10.131 * iTime + 100.19414 + hash1(fragCoord.y*73.1 + 1931.1));\n       // g += exp(-10. * d);\n      //  g *= step(fragCoord.x, 2.) * step(fragCoord.y, 2.);\n        g = step(0.999, g);\n       // g = step(abs(fragCoord.x - 0.5 * iResolution.x), 0.5);\n       // g *= step(abs(fragCoord.y - 0.5 * iResolution.y), 0.5);\n        fragColor = vec4(g, 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n    // center cell\n    float e = Cell(px); \n    \n    // neighbour cells\n    float t = Cell(px + ivec2(0,-1));\n    float b = Cell(px + ivec2(0,1));\n    float l = Cell(px + ivec2(-1,0));\n    float r = Cell(px + ivec2(1,0));   \n    \n    // \"average\" of neighbours\n    float k = 0.5 * max(t + b, l + r);\n    \n    // difference between \"average\" and center\n    float j = abs(e - k);\n    \n   // e += 0.3 * j - 0.06;\n     float a = 0.0;\n    if (e > k - 0.1)\n        e = 0.98 * k + 0.15 * j * k;\n    else\n        e *= 1.5 * k;\n    \n    if (e <= j && e <= 0.12)\n        e = 4. * k;\n    else if (e >= 1.)\n        e = 0.8;\n    \n    if (e > 0.7)\n        e -= 0.01;\n        \n    e = clamp(e,0.,1.);\n     \n    fragColor = vec4( e, 0.0, 0.0, 0.0 );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "buffer_b_code": "float Cell(in ivec2 p) {\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel0, p, 0 ).x;\n}\n\nfloat Cell2(in ivec2 p) {\n    // do wrapping\n    ivec2 r = ivec2(textureSize(iChannel1, 0));\n    p = (p+r) % r;\n    \n    // fetch texel\n    return texelFetch(iChannel1, p, 0 ).x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n   \n    float e = Cell(px);\n    float e2 = Cell2(px);\n   \n    e = mix(e, e2, 0.9);\n    //e *= 0.99;\n    e = clamp(e,0.,1.);\n     \n    fragColor = vec4( e, 0.0, 0.0, 0.0 );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlScWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 918]], "test": "untested"}
{"id": "NljyWh", "name": "Raymarching Distance Field", "author": "Decycle", "description": "A raymarching distance field render", "tags": ["raymarching"], "likes": 3, "viewed": 259, "published": 3, "date": "1649610322", "time_retrieved": "2024-07-30T16:54:41.187315", "image_code": "float sphereSDF(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.) / k;\n    return min(a, b) - h * h * h * k * 1. / 6.;\n}\n\nfloat worldSDF(vec3 p)\n{\n    const float sqrt3d2 = 0.8660254;\n    float sphere1 = sphereSDF(p, vec3(0.), 1.);\n    float sphere2 = sphereSDF(p, vec3(0., 1.2, 1.), 1.);\n    float sphere3 = sphereSDF(p, vec3(sqrt3d2, 1.2, -0.5), 1.);\n    float sphere4 = sphereSDF(p, vec3(-sqrt3d2, 1.2, -0.5), 1.);\n    \n    float smoothFactor = sin(iTime / 3.) * 2. + 3.;\n\n    float spheres = smin(smin(smin(sphere1, sphere3, smoothFactor), sphere2, smoothFactor), sphere4, smoothFactor);\n\n    float plane = p.y - (-0.5);\n    return smin(spheres, plane, smoothFactor);\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 small_step = vec2(0.001, 0.0);\n    float gradient_x = worldSDF(p + small_step.xyy) - worldSDF(p - small_step.xyy);\n    float gradient_y = worldSDF(p + small_step.yxy) - worldSDF(p - small_step.yxy);\n    float gradient_z = worldSDF(p + small_step.yyx) - worldSDF(p - small_step.yyx);\n\n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nvec3 ray_march(vec3 ro, vec3 rd)\n{\n    float total_distance_traveled = 0.;\n    const int NUMBER_OF_STEPS = 100;\n    const float MIN_DISTANCE = 0.0001;\n    const float MAX_DISTANCE = 1000.;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; i++)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n        float closest_distance = worldSDF(current_position);\n        if (closest_distance < MIN_DISTANCE)\n        {\n          vec3 light_position = vec3(2., -4., 3.);\n          vec3 light_direction = normalize(current_position - light_position);\n          float diffuse_factor = max(0.0, dot(light_direction, normal(current_position)));\n          return vec3(1.) * float(i) / 100.;\n        }\n        if (closest_distance > MAX_DISTANCE)\n        {\n          return vec3(1.) * float(i) / 100.;\n        }\n        total_distance_traveled += closest_distance;\n    }\n\n    return vec3(1.);\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n    mat3 ry = mat3(\n      cos(angle), 0., sin(angle),\n      0., 1., 0.,\n      -sin(angle), 0, cos(angle)\n    );\n    \n    return ry * p;\n}\n\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    float theta = iTime / 2.;\n    \n    vec3 ro = vec3(4. * sin(theta), 0.5, -4. * cos(theta));\n    vec3 rd = vec3(uv.x * iResolution.x / iResolution.y, uv.y, 1.);\n    rd = rotateY(rd, theta);\n    \n    vec3 color = ray_march(ro, rd);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 74], [76, 76, 115, 115, 208], [210, 210, 234, 234, 761], [763, 763, 784, 784, 1149], [1151, 1151, 1185, 1185, 2044], [2046, 2046, 2081, 2081, 2219], [2228, 2228, 2285, 2285, 2603]], "test": "untested"}
{"id": "NtScD1", "name": "Dog God's path tracer", "author": "dog_god", "description": "Simple Cornell box scene, so far I've implemented diffuse reflection, glossy reflection, refraction, and emission.\nworking on DOF rn\n\nMove your mouse around to change the camera orientation, wait for the picture to clear up.", "tags": ["reflection", "refraction", "cornellbox", "pathtracing"], "likes": 5, "viewed": 305, "published": 3, "date": "1649605292", "time_retrieved": "2024-07-30T16:54:42.134782", "image_code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), -1.0f, 1.0f);\n}\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float exposure = 1.;\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color *= exposure;\n    color = ACESFilm(color);\n    color = LinearToSRGB(color);\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float fresnel(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}\n\nvec3 rot(in vec3 inp, in vec3 rot){\n    float s1 = sin(rot.x);\n    float c1 = cos(rot.x);\n    float s2 = sin(rot.y);\n    float c2 = cos(rot.y);\n    float s3 = sin(rot.z);\n    float c3 = cos(rot.z);\n    \n    float a = c2 * c3 * inp.x;\n    float b = (s1*s2*c3 - c1*s3)*inp.y;\n    float g = (c1*s2*c3 + s1*s3)*inp.z;\n    \n    float a1 = c2 * s3 * inp.x;\n    float b1 = (s1*s2*s3 + c1*c3)*inp.y;\n    float g1 = (c1*s2*s3 - s1*c3)*inp.z;\n    \n    float a2 = -s2*inp.x;\n    float b2 = s1*c2*inp.y;\n    float g2 = c1*c2*inp.z;\n    \n    \n    return vec3((a+b+g),(a1+b1+g1),(a2+b2+g2));\n}\n\n\n\nvec3 torNormal( in vec3 pos, vec2 tor )\n{\n    return normalize( pos*(dot(pos,pos)-tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nstruct HitInfo\n{\n    vec3 normal;\n    float distance;\n    bool inside;\n\n};\n\nstruct Material{\n    vec3 emission;\n    vec3 albedo;\n    float roughness;\n    float specularity;\n    vec3 specularColor;\n    float IOR;\n    float refChance;\n    float refRoughness;\n    vec3 refColor;\n};\n\nMaterial stock(){\n    Material mat;\n    mat.emission = vec3(0.);\n    mat.albedo = vec3(1.);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    mat.IOR = 1.33;\n    mat.refChance = 0.;\n    mat.refRoughness = 0.;\n    mat.refColor = vec3(1.);\n    return mat;\n}\n\n\n\nfloat c_twopi = 6.28318530718;\n\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\nvec3 RUV(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat BIG = 100000.;\n\n// axis aligned box centered at the origin, with size boxSize\nvec3 box( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    bool i = true;\n    if ( tN>tF || tF<0.0) i = false;\n    if( tN>tF || tF<0.0) return vec3(vec2(BIG),i); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    if (tN < 0.){\n    tN = BIG;\n    }\n    return vec3( tN, tF,i);\n}\n\n// plane degined by p (p.xyz must be normalized)\nvec2 plane( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    float m = -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n    bool i = false;\n    if (m > 0.){i = true;}\n    if (m < 0.){\n    return vec2(BIG,i);}\n    return vec2(m,i);\n}\nfloat torus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        if (t < .01){\n        t = BIG;\n        }\n        return t;\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return BIG;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n}\n\n\n\n\n// sphere of size ra centered at point ce\nvec4 Sphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    if(b > 0.){\n    return vec4( BIG );\n    }\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(BIG); // no intersection\n    h = sqrt( h );\n    if( h==0.0 ) return vec4(BIG);\n    vec3 hit = (ro + (rd*(-b-h)));\n    vec3 ohit = (ro + (rd*(-b+h)));\n    vec3 normal = normalize((hit - ce)/ra);\n    float d = -b-h;\n    if(distance(ro,ce)<ra){\n        d = -b+h;\n        //normal = normalize((ohit - ce)/ra);\n    }\n    return vec4(normal, d );\n}\n\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 Scene(in vec3 pos, in vec3 ray, inout HitInfo hit, out Material mat){\n    vec3 BoxSize = vec3(2,.5,2);\n    vec4 PlaneNormal = vec4(0.,1.,0.,0.);\n    vec2 TorusSettings = vec2(2.,.5);\n    vec3 BoxNormal1;\n    vec3 BoxNormal2;\n    vec3 BoxNormal3;\n    vec3 BoxNormal4;\n    vec3 BoxNormal5;\n    vec3 BoxNormal6;\n    vec3 BoxNormal7;\n    vec3 BoxNormal8;\n    vec3 BoxNormal9;\n    vec3 BoxOrigin1 = vec3(0.,13.5,0.);//light\n    vec3 BoxOrigin2 = vec3(10.,0.1,10.);//floor\n    vec3 BoxOrigin3 = vec3(3.,1.2,-3.);//tiny cube on the right\n    vec3 BoxOrigin4 = vec3(-3,8.,6.);//back wall mirror\n    vec3 BoxOrigin5 = vec3(7.,10.,0.);//red wall\n    vec3 BoxOrigin6 = vec3(-7.,10.,0.);//green wall\n    vec3 BoxOrigin7 = vec3(0.,10.,10.);//z wall\n    vec3 BoxOrigin8 = vec3(0.,14.,0.);//ceiling\n    vec3 BoxOrigin9 = vec3(-4.,2.,-3.);//tiny cube\n    vec3 TorOrigin = vec3(-4,4.,0.);\n    vec3 R = vec3(0.2,.5,0.2);\n    vec3 R1 = vec3(0.,0.2,0.);\n    vec3 R2 = vec3(1.5,-0.6,0.);\n    vec3 R3 = vec3(0.,-0.2,0.);\n    vec3 SphereOrigin = vec3(2.,4.,4.);\n    vec3 SphereOrigin2 = vec3(4.,8,2.);\n    vec3 BoxIntersect1 = box(pos-BoxOrigin1,ray,BoxSize,BoxNormal1);\n    vec3 BoxIntersect2 = box(pos,ray,BoxOrigin2,BoxNormal2);\n    vec3 BoxIntersect3 = box(rot(pos-BoxOrigin3,R3),rot(ray,R3),vec3(1.,1.2,1.),BoxNormal3);\n    vec3 BoxIntersect4 = box(rot(pos-BoxOrigin4,R),rot(ray,R),vec3(3.,4.,.2),BoxNormal4);\n    vec3 BoxIntersect5 = box(pos-BoxOrigin5,ray,vec3(.5,10.,10.),BoxNormal5);\n    vec3 BoxIntersect6 = box(pos-BoxOrigin6,ray,vec3(.5,10.,10.),BoxNormal6);\n    vec3 BoxIntersect7 = box(pos-BoxOrigin7,ray,vec3(10.,10.,.5),BoxNormal7);\n    vec3 BoxIntersect8 = box(pos-BoxOrigin8,ray,vec3(10.,.5,10.),BoxNormal8);\n    vec3 BoxIntersect9 = box(rot(pos-BoxOrigin9,R1),rot(ray,R1),vec3(1,2,1),BoxNormal9);\n    float TorusIntersect = torus(rot(pos-TorOrigin,R2),rot(ray,R2),TorusSettings);\n    vec3 TorusNormals = torNormal(rot(pos+ray*TorusIntersect-TorOrigin,R2),TorusSettings);\n    vec4 SphereIntersect = Sphere(pos,ray,SphereOrigin,2.);\n    vec4 SphereIntersect2 = Sphere(pos,ray,SphereOrigin2,1.2);\n    \n    BoxNormal9 = rot(BoxNormal9,-R1);\n    TorusNormals = rot(TorusNormals,-R2);\n    BoxNormal3 = rot(BoxNormal3,-R3);\n    \n    float SceneDepth = min(min(BoxIntersect1.x,BoxIntersect2.x),TorusIntersect);\n    SceneDepth = min(SceneDepth,BoxIntersect3.x);\n    SceneDepth = min(min(SceneDepth,BoxIntersect4.x),BoxIntersect5.x);\n    SceneDepth = min(SceneDepth, BoxIntersect6.x);\n    SceneDepth = min(SceneDepth, SphereIntersect.w);\n    SceneDepth = min(min(SceneDepth, SphereIntersect2.w),BoxIntersect7.x);\n    SceneDepth = min(SceneDepth,BoxIntersect7.x);\n    SceneDepth = min(SceneDepth,BoxIntersect8.x);\n    SceneDepth = min(SceneDepth,BoxIntersect9.x);\n    //decide all the object parameters\n    if (TorusIntersect == SceneDepth){\n    mat.albedo = vec3(1.);\n    mat.emission = vec3(0.);\n    hit.normal = TorusNormals;\n    mat.specularity = 1.;\n    mat.specularColor = vec3(1.);\n    mat.roughness = 0.6;\n    }\n    if (BoxIntersect1.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,0.8,0);\n    mat.emission = vec3(10.,4.,3.);\n    hit.normal = normalize(BoxNormal1);\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect2.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.);\n    mat.emission = vec3(0.);\n    hit.normal = normalize(BoxNormal2);\n    mat.roughness = 1.;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect3.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal3);\n    mat.roughness = 0.1;\n    mat.specularity = .2;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect4.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,0.3,0.2);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(rot(BoxNormal4,-R));\n    mat.roughness = 0.1;\n    mat.specularity = 1.;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect5.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,0.3,0.2);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal5);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect6.x == SceneDepth){\n    mat.albedo = vec3(.3,1.,0.2);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal6);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }    \n\n    if (SphereIntersect.w == SceneDepth){\n    mat.albedo = vec3(1.);\n    mat.emission = vec3(0.);\n    hit.normal = vec3(SphereIntersect.xyz);\n    mat.specularity = 1.;\n    mat.roughness = 0.5;\n    mat.specularColor = vec3(1.);\n    }\n    if (SphereIntersect2.w == SceneDepth){\n    mat = stock();\n    mat.refChance = 1.;\n    hit.normal = vec3(SphereIntersect2.xyz);\n    mat.IOR = (1.2);\n    mat.specularity = 0.1;\n    mat.roughness = 0.1;\n    mat.refRoughness = 0.1;\n    }\n    \n    if (BoxIntersect7.x == SceneDepth){\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal7);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }  \n    if (BoxIntersect8.x == SceneDepth){\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal8);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    } \n    if (BoxIntersect9.x == SceneDepth){\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal9);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }  \n    hit.distance = SceneDepth;\n    hit.normal = normalize(hit.normal);\n    return hit.normal;\n}\nvec3 PathTrace(in vec3 pos, in vec3 ray, inout uint rngstate, out HitInfo Hit){\n    vec3 StartNormal;\n    vec3 T = vec3(1.);\n    vec3 R = vec3(0.);\n    \n    Material Mat;\n    for(int i = 0; i <= 10; i++){\n    \n    Mat = stock();\n    Hit.distance = BIG;\n    Hit.inside = false;\n    Scene(pos,ray,Hit,Mat);\n    //if(Hit.distance < -1.){\n    //    break;\n    //}\n    //for(int j = 0; j < 20; j++){\n    //if(Hit.distance == BIG){\n    \n    //R += SRGBToLinear((texture(iChannel1, ray).rgb * T)*0.7);\n    //Scene(pos,ray,Hit,Mat);\n     \n    //break;\n    \n    //}\n    //}\n    \n    if(Hit.inside){\n    T *= exp(-Mat.refColor*Hit.distance);\n    \n    }\n    \n    float specChance = Mat.specularity;\n    float refChance = Mat.refChance;\n    float rayProb = 1.;\n    \n    if(specChance > 0.){\n        specChance = fresnel(\n        Hit.inside ? Mat.IOR : 1.0,\n        !Hit.inside ? Mat.IOR : 1.0,\n        ray, Hit.normal, Mat.specularity, 1.0);  \n        float chanceMult = (1.-specChance)/(1.-Mat.specularity);\n        refChance *= chanceMult;\n    }\n    \n    // calculate whether we are going to do a diffuse, specular, or refractive ray\n    float doSpec = 0.;\n    float doRef = 0.;\n    float raySelRoll = RandomFloat01(rngstate);\n    \n    if(specChance > 0. && raySelRoll < specChance){\n        doSpec = 1.;\n        rayProb = specChance;\n    }\n    else if (refChance > 0. && raySelRoll < specChance + refChance)\n    \n    {\n        doRef = 1.;\n        rayProb = refChance;\n    }\n    \n    else \n    \n    {\n        rayProb = 1.0-(specChance + refChance);\n    }\n    \n    rayProb = max(rayProb,0.001);\n    \n    if(doRef == 1.)\n    \n    {\n        pos = (pos+ray * Hit.distance) - Hit.normal * 0.01;\n    }\n    \n    else \n    \n    {\n        pos = (pos+ray * Hit.distance) + Hit.normal * 0.01;\n    }\n    \n    float spec = (RandomFloat01(rngstate) < specChance) ? 1.0f : 0.0f;\n    \n    // avoid numerical issues causing a divide by zero\n    rayProb = max(rayProb, 0.001f);  \n    \n    \n    \n    vec3 dif = normalize(Hit.normal + RUV(rngstate));\n    \n    \n    \n    vec3 glos = reflect(ray,Hit.normal);\n    glos = normalize(mix(glos, dif, Mat.roughness * Mat.roughness));\n    \n    \n    vec3 ref = refract(ray, Hit.normal,Hit.inside ? Mat.IOR : 1. / Mat.IOR );\n    ref = normalize(mix(ref,normalize(-Hit.normal+RUV(rngstate)),Mat.refRoughness * Mat.refRoughness));\n    \n    \n    ray = mix(dif, glos, doSpec);\n    \n    ray = mix(ray, ref, doRef);\n    \n    R += Mat.emission * T;\n    \n    \n    if(doRef == 0.){\n    \n    T *= mix(Mat.albedo,Mat.specularColor,doSpec);\n    \n    }\n    \n    \n    \n    T /= rayProb;\n    \n    \n    //roulette \n    float p = max(T.r, max(T.g, T.b));\n    if (RandomFloat01(rngstate) > p)\n        break;\n \n    // Add the energy we 'lose' by randomly terminating paths\n    \n    T *= 1.0f / p;\n    \n    }\n    return R;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float mx = iMouse.x/iResolution.x;//normalized mouse xy\n    float my = iMouse.y/iResolution.y;\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 angle;\n    float fov = 150.;\n    float cameraDistance = 1.0f / tan(fov * 0.5f * 3.14159 / 180.0); \n    angle = -(vec2(mx,my)-.5)*3.14*2.;//get angle for the camera rotation\n    vec3 pos = vec3(0.,0.,0.);//camera coord position, change z for distance\n    vec3 ray = vec3((fragCoord+jitter-iResolution.xy*.5)/iResolution.x,cameraDistance);//normalize shit\n    Rotate(pos,angle);//Rotate position, remove for fps camera\n    Rotate(ray,angle);//Rotate the ray angle\n    ray = normalize(ray);\n    pos = pos + vec3(0.,5.,-10.0);\n    HitInfo M;\n    Material M2;\n    Scene(pos,ray,M,M2);\n    HitInfo J; \n    vec3 color = PathTrace(pos,ray,rngState,J);\n    //bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    bool mouseDown = iMouse.z > 0.0;\n    // average the frames together\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || mouseDown) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n    fragColor = vec4(color, blend);\n    //fragColor = vec4(J.normal,0.);\n    \n    \n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtScD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 196], [197, 197, 233, 233, 364], [367, 367, 396, 396, 572], [575, 575, 604, 604, 775], [777, 777, 834, 834, 1050]], "test": "untested"}
{"id": "stBcW1", "name": "Stars and galaxy", "author": "mrange", "description": "License CC0: Stars and galaxy\nBit of sunday tinkering lead to stars and a galaxy\nDidn't turn out as I envisioned but it turned out to something\nthat I liked so sharing it.", "tags": ["2d"], "likes": 188, "viewed": 10509, "published": 3, "date": "1649601106", "time_retrieved": "2024-07-30T16:54:42.888766", "image_code": "// License CC0: Stars and galaxy\n// Bit of sunday tinkering lead to stars and a galaxy\n// Didn't turn out as I envisioned but it turned out to something\n// that I liked so sharing it.\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              mod(iTime, 30.0)\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec2 shash2(vec2 p) {\n  return -1.0+2.0*hash2(p);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)/255.;\n  if (Temp < 1000.) col *= Temp/1000.;\n  return col;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat noise(vec2 p) {\n  // Found at https://www.shadertoy.com/view/sdlXWX\n  // Which then redirected to IQ shader\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f*f*(3.-2.*f);\n  \n  float n =\n         mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)), \n                   dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),\n              mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)), \n                   dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);\n\n  return 2.0*n;              \n}\n\nfloat fbm(vec2 p, float o, float s, int iters) {\n  p *= s;\n  p += o;\n\n  const float aa = 0.5;\n  const mat2 pp = 2.04*ROT(1.0);\n\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < iters; ++i) {\n    d += a;\n    h += a*noise(p);\n    p += vec2(10.7, 8.3);\n    p *= pp;\n    a *= aa;\n  }\n  h /= d;\n  \n  return h;\n}\n\nfloat height(vec2 p) {\n  float h = fbm(p, 0.0, 5.0, 5);\n  h *= 0.3;\n  h += 0.0;\n  return (h);\n}\n\nvec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {\n  vec2 mi = raySphere(ro, rd, md);\n  \n  vec3 p    = ro + mi.x*rd;\n  vec3 n    = normalize(p-md.xyz);\n  vec3 r    = reflect(rd, n);\n  vec3 ld   = normalize(lp - p);\n  float fre = dot(n, rd)+1.0;\n  fre = pow(fre, 15.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 8.0);\n  float i = 0.5*tanh_approx(20.0*fre*spe+0.05*dif);\n  vec3 col = blackbody(1500.0)*i+hsv2rgb(vec3(0.6, mix(0.6, 0.0, i), i));\n\n  float t = tanh_approx(0.25*(mi.y-mi.x));\n \n  return vec4(vec3(col), t);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y); \n  vec3 yellow = blackbody(1500.0)*ci;\n  cf = ci;\n  return blue+yellow;\n}\n\nvec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {\n  vec2 gp = sp;\n  gp *= ROT(0.67);\n  gp += vec2(-1.0, 0.5);\n  float h1 = height(2.0*sp);\n  float gcc = dot(gp, gp);\n  float gcx = exp(-(abs(3.0*(gp.x))));\n  float gcy = exp(-abs(10.0*(gp.y)));\n  float gh = gcy*gcx;\n  float cf = smoothstep(0.05, -0.2, -h1);\n  vec3 col = vec3(0.0);\n  col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;\n  col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));\n  col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);\n  sf = gh*cf;\n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd, vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(sp.x);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 lp, vec4 md) {\n  vec2 sp = toSpherical(rd.xzy).yz;\n\n  float sf = 0.0;\n  float cf = 0.0;\n  vec3 col = vec3(0.0);\n\n  vec4 mcol = moon(ro, rd, sp, lp, md);\n\n  col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(2.0*cf));\n  col += galaxy(ro, rd, sp, sf);\n  col = mix(col, mcol.xyz, mcol.w);\n  col += sky(ro, rd, sp, lp, cf);\n  col += grid(ro, rd, sp);\n\n  if (rd.y < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);\n  vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);\n  vec3 la = vec3(1.0, 0.5, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  la.xz *= ROT(TTIME/60.0-PI/2.0);\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col= color(ro, rd, lp, md);\n  \n  col *= smoothstep(0.0, 4.0, TIME)*smoothstep(30.0, 26.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBcW1.jpg", "access": "api", "license": "cc0-1.0", "functions": [[509, 609, 630, 630, 703], [704, 804, 826, 826, 875], [877, 984, 1010, 1010, 1194], [1196, 1256, 1284, 1350, 1426], [1581, 1581, 1603, 1603, 1749], [1751, 1837, 1873, 1873, 1967], [1969, 2029, 2049, 2049, 2161], [2163, 2163, 2184, 2184, 2214], [2216, 2216, 2242, 2242, 2351], [2354, 2492, 2520, 2520, 2832], [2835, 2919, 2940, 3032, 3436], [3438, 3438, 3486, 3486, 3768], [3770, 3770, 3792, 3792, 3865], [3867, 3867, 3916, 3916, 4643], [4645, 4739, 4783, 4783, 4981], [4984, 4984, 5040, 5040, 5543], [5545, 5545, 5605, 5605, 5922], [5924, 5924, 5978, 5978, 6441], [6443, 6443, 6481, 6481, 6809], [6811, 6811, 6859, 6859, 7251], [7253, 7253, 7308, 7308, 7971]], "test": "ok"}
{"id": "NlSyD1", "name": "log polar polka", "author": "takahiroando", "description": "See these sites.  https://www.osar.fr/notes/logspherical/, https://github.com/pac-dev/notes/blob/master/content/logspherical/logpolar_polka.glsl", "tags": ["fold", "logpolar"], "likes": 7, "viewed": 248, "published": 3, "date": "1649580367", "time_retrieved": "2024-07-30T16:54:44.093545", "image_code": "#define PI 3.14151692\n\n#define rho_offset fract(0.5 + 0.5 * iTime) //dspnote param: 0 - 1\n#define theta_offset fract(0.5 + 0.5 * iTime) //dspnote param: 0 - 1\n\nfloat scale = 6.0/PI;\nvec3 diskColor = vec3(0.4, 0.4, 0.3);\nvec3 hBarColor = vec3(0.2, 1.0, 0.2);\nvec3 vBarColor = vec3(1.0, 0.2, 0.2);\n\nvec2 logPolar(vec2 p) {\n\tp = vec2(log(length(p)), atan(p.y, p.x));\n\treturn p;\n}\n\nfloat line(float pos, float aaSize) {\n\treturn smoothstep(-1.3*aaSize, -0.5*aaSize, pos) - \n\t\tsmoothstep(0.5*aaSize, 1.3*aaSize, pos);\n}\n\nfloat disk(vec2 pos, float aaSize) {\n\treturn 1.0-smoothstep(0.3-aaSize, 0.3+aaSize, length(pos));\n}\n\nvec3 polka(vec2 p, float aaSize) {\n\tp *= scale;\n\tvec2 diskP = p - vec2(rho_offset, theta_offset)*3.0;\n\tdiskP = fract(diskP) * 2.0 - 1.0;\n\tvec3 ret = vec3(1.0);\n\tret = mix(ret, diskColor, disk(diskP, aaSize));\n\tret = mix(ret, hBarColor, line(p.x, aaSize));\n\tret = mix(ret, vBarColor, line(p.y, aaSize));\n\treturn ret;\n}\n\nvec3 cartesianPolka(vec2 p) {\n\tp *= 4.0;\n\tfloat aaSize = length(1.0/iResolution.xy) * 7.0;\n\tvec3 ret = polka(p, aaSize);\n    \n    // <darken outside>\n\tif (p.y < -PI || p.y > PI)\n\t\tret *= 0.6;\n    // </darken outside>\n    // <darken negative area>\n\telse if (p.x < -0.0)\n\t\tret *= 0.8;\n    // </darken negative area>\n    \n    return ret;\n}\n\nvec3 logPolarPolka(vec2 p) {\n\tp *= 4.0;\n    vec2 lpp = logPolar(p);\n\tfloat aaSize = length(lpp - logPolar(p+1.0/iResolution.xy)) * 7.0;\n\tvec3 ret = polka(lpp, aaSize);\n\n    // <darken outside> (no meaning)\n\tif (lpp.y < -PI || lpp.y > PI)\n\t\tret *= 0.6;\n    // </darken outside>\n    // <darken negative area>\n\tif (lpp.x < -0.0)\n\t\tret *= 0.8;\n    // </darken negative area>\n\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 quarter = vec2(1.0, 0.0);\n\tvec3 ret;\n\tif (p.x < 0.0)\n\t\tret = cartesianPolka(p + quarter);\n\telse\n\t\tret = logPolarPolka(p - quarter);\n\tfragColor = vec4(ret, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 320, 320, 376], [378, 378, 415, 415, 513], [515, 515, 551, 551, 614], [616, 616, 650, 650, 933], [935, 935, 964, 964, 1271], [1273, 1273, 1301, 1301, 1662], [1664, 1664, 1721, 1721, 1961]], "test": "untested"}
{"id": "NlBcW1", "name": "10-2 Simple RayMarching", "author": "ccc9527", "description": "Ray Marching,Sphere Tracing", "tags": ["raymarching", "mouse", "spheretracing"], "likes": 1, "viewed": 243, "published": 3, "date": "1649579360", "time_retrieved": "2024-07-30T16:54:44.874457", "image_code": "#define MAX_STEPS 100   //光线前进最大步数\n#define MAX_DIST 100.0  //最大距离100\n#define SURF_DIST 0.01  //点到物体最近的表面距离小于这个距离即理解为击中表面\n\n//球体sdf,sphere前三个参数是球心位置坐标,最后一个参数是半径\nfloat SphereSDF(vec3 p,vec4 sphere)\n{\n    return length(p-sphere.xyz)-sphere.w;\n}\n\n//胶囊体sdf,a/b是胶囊体两端半球的球心,r是半球的半径\nfloat CapsuleSDF(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    \n    //ap在ab方向上的投影除以ab的长度,并截止到(0,1)之间,\n    //所以点a上面部分是c=a,点b下面的是c=b\n    //上面的部分离胶囊体最近距离是ap的距离减半径,下面同理\n    float t = dot(ab,ap)/dot(ab,ab);\n    t = clamp(t,0.0,1.0);\n    vec3 c = a+t*ab;\n    \n    return length(p-c)-r;\n}\n\n//环面sdf,a表示换面中心点位置,r.x表示大半径,r.y表示小半径\nfloat TorusSDF(vec3 p,vec3 a,vec2 r)\n{\n    //点p在xz平面内到中心点的距离减去大半径\n    float x = length(p.xz-a.xz)-r.x;\n    \n    //根据 点p在xz平面内到中心点的距离和y方向的距离 \n    //计算p到外环中间的距离,然后减去外环的半径\n    //得到点p距物体表面的最小值\n    return length(vec2(x,p.y-a.y))-r.y;\n}\n\n//box,盒子sdf(立方体或长方体),a表示盒子中心点坐标,size表示长宽高\nfloat BoxSDF(vec3 ap,vec3 size)\n{\n    return length(max(abs(ap)-size,0.0));\n}\n\n//Cylinder,圆柱sdf,类似胶囊体\nfloat CylinderSDF(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    \n    float t = dot(ap,ab)/dot(ab,ab);   \n    vec3 c = a+t*ab;\n    \n    float d = length(p-c)-r;\n    float y = abs(t-0.5)-0.5;\n    y *= length(ab);\n    \n    float dist = length(max(vec2(d,y),0.0));\n    \n    return dist+min(max(d,y),0.0);\n}\n//输入角度,返回某个平面的旋转矩阵\nmat2 Rot(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c,-s,s,c);\n}\n\n//获得每一步的距离,场景中只有一个平面和一个球\nfloat GetDist(vec3 p)\n{   \n    //Sphere,球,前三个参数是圆心位置,第四个是半径\n    vec4 sphere = vec4(-6,1,10,1);\n    \n    //胶囊体参数\n    vec3 a = vec3(-3.0,2.0,10.0);//胶囊体上半球的球心\n    vec3 b = vec3(-3.0,0.5,10.0);//胶囊体下半球的球心\n    float t = 0.5;    //两个球的半径\n    \n    //环面参数\n    vec3 a1 = vec3(0,1.0,10.0);//环面中心点位置坐标\n    vec2 r = vec2(1.0,0.3);//x表示大半径,y表示小半径\n    \n    //盒子参数\n    vec3 a2 = vec3(3.0,1.0,10.0);//立方体中心坐标\n    vec3 a2p = a2-p;\n    //a2p.xz *= Rot(iTime);\n    //a2p -= vec3(2,-1,0); //平移,translation\n    vec3 size = vec3(1);\n    \n    //圆柱体参数\n    vec3 a3 = vec3(6.0,2.0,10.0);\n    vec3 b3 = vec3(6.0,0.0,10.0);\n    float r3 = 0.5;\n    \n    //点p距离场景中各个物体的距离\n    float sphereDist = SphereSDF(p,sphere);//点p到球体的最小距离\n    float planeDist = p.y;//点p到屏幕的距离,片面位于y=0\n    float capsuleDist = CapsuleSDF(p,a,b,t);\n    float torusDist = TorusSDF(p,a1,r);\n    float boxDist = BoxSDF(a2p,size);\n    float cylinderDist = CylinderSDF(p,a3,b3,r3);\n    \n    //选出最小的距离,即每次前进的安全距离\n    float d = min(sphereDist,planeDist);\n    d = min(d,capsuleDist);\n    d = min(d,torusDist);\n    d = min(d,boxDist);\n    d = min(d,cylinderDist);\n    \n    return d;\n}\n//光线前进,计算每个方向上光线前进多少距离击中表面,即到物体表面的距离\nfloat RayMarching(vec3 ro,vec3 rd)\n{\n    float d0 = 0.0;\n    \n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro+rd*d0;\n        float ds = GetDist(p);//获得每一次前进的距离\n        d0 += ds;\n        //前进总距离大于MAX_DIST认为是该方向击中不了物体,\n        //前进的距离小于SURF_DIST认为是击中物体表面\n        if(d0>MAX_DIST || ds<SURF_DIST) break;\n    }\n    \n    return d0;\n}\n//获得点p的法向量\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.001,0);\n    \n    vec3 normal = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(normal);\n}\n\nfloat CalcAO(vec3 p,vec3 n)\n{\n    float res = 0.;\n    float scale = 1.;\n    for (int i=0;i<5;i++)\n    {\n        float h = 0.01+0.03*float(i);\n        float d = GetDist(p+n*h);\n        res += (h-d)*scale;\n        scale *= 0.95;\n        if (res > 0.35) break;\n    }\n    return clamp(1.-3.*res,0.,1.);\n}\n\n//获得点p的颜色,blinn-phong模型\nvec3 GetLight(vec3 p,vec3 ro)\n{\n    vec3 lightPos = vec3(3,5,5);//光源位置\n    vec3 lightCol = vec3(1.0);//光源颜色\n    lightPos.xz += vec2(sin(2.0*iTime),cos(2.0*iTime));\n    \n    //红宝石材质属性\n    vec3 k_a = vec3(0.1745,0.01175,0.01175);//环境反射率\n    vec3 k_d = vec3(0.61424,0.041362,0.04136);//漫反射率\n    vec3 k_s = vec3(0.727811,0.626959,0.626959);//镜面反射率\n    float shininess = 76.8;//高光指数\n    \n    vec3 lightDir = normalize(lightPos-p);//光向量\n    vec3 normal = GetNormal(p);//获得点p的法向量\n    \n    //环境光\n    vec3 ambient = k_a*0.5;\n    \n    //漫反射\n    float dif = clamp(dot(lightDir,normal),0.0,1.0);\n    vec3 diffuse = lightCol*k_d*dif;\n    \n    //高光\n    vec3 viewDir = normalize(ro-p);//视向量\n    vec3 halfDir = normalize(viewDir+lightDir);//半程向量\n    float spec = pow(max(dot(halfDir,normal),0.0),shininess);//高光系数\n    vec3 specular = lightCol*k_s*spec;//高光\n    \n    //阴影,将点p沿法线外移两个SURF_DIST的距离,然后在向光源的\n    //方向RayMarching计算距离,若距离小于光源点到p的距离\n    //那么说明点p到光源之间有物体遮挡,是阴影部位\n    vec3 p2 = p + normal*SURF_DIST*2.0;\n    float d = RayMarching(p2,lightDir);\n    if(d<length(lightPos-p)) return ambient;\n    \n    vec3 color = ambient+diffuse+specular;\n    \n    //计算ao\n    float ao = CalcAO(p,normal);\n    \n    return color*ao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    float time = iTime;\n    \n    vec3 ro = vec3(0.0,3.0,1.0);\n    //射线原点随鼠标移动距离进行旋转\n    ro.yz *= Rot(-mo.y+.4);\n    ro.xz *= Rot(-mo.x*6.2831);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));//射线方向\n    \n    float d = RayMarching(ro,rd);//获得每个rd方向上需要前进的距离\n    vec3 p = ro+rd*d;//根据前进距离和rd求得射线击中物体的点\n    \n    //blinn-phong光照模型\n    col = GetLight(p,ro);    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 279, 316, 316, 360], [362, 434, 482, 482, 853], [855, 934, 972, 1033, 1300], [1302, 1390, 1423, 1423, 1467], [1469, 1506, 1555, 1555, 1836], [1837, 1886, 1905, 1905, 1978], [1980, 2047, 2070, 2140, 3436], [3437, 3538, 3574, 3574, 3966], [3967, 3992, 4016, 4016, 4222], [4224, 4224, 4253, 4253, 4524], [4526, 4566, 4597, 4597, 6018], [6020, 6020, 6077, 6077, 6712]], "test": "untested"}
{"id": "NtSyW1", "name": "Shadow pillars", "author": "vnvthedark", "description": "simple shadows using stepped racast", "tags": ["shadow"], "likes": 1, "viewed": 219, "published": 3, "date": "1649571793", "time_retrieved": "2024-07-30T16:54:47.166331", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat getClosest( vec3[12] a, int n, vec2 point )\n{\n    float distance = length(a[0].xy - point) - a[0].z;\n    for(int i = 1; i<n; i++){\n        float tmp = length(a[i].xy - point)-a[i].z;\n        if(tmp<distance)\n        {\n            distance = tmp;\n        }\n    }\n    return distance;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float threshhold = 1.0;\n    const int maxSteps = 50;\n    vec2 center = iMouse.xy;\n    \n    vec3 planets[12];\n    for(int i = 0; i<planets.length(); i++)\n    {\n        planets[i] = vec3((i%3+1)*int(iResolution.x)/4,(1+i/3)*int(iResolution.y)/5, 15);\n    }\n    \n    vec2 diff = center - fragCoord;\n    \n    int i = 0;\n    \n    vec2 point = fragCoord;\n    bool collision = true;\n    \n    float progress = 0.0;\n    float lightContribution = 1.0;\n    \n    for(i = 0; i < maxSteps; i++){\n        \n        float dist = length(center - point);\n        \n        float close = getClosest(planets, 12, point)*.5*(1.0-.2*rand(fragCoord));\n        \n        progress += close;\n        lightContribution = min(lightContribution, 10.0*(close)/progress);\n        \n        \n        \n        if(length(progress - diff) < threshhold){\n            collision = false;\n            break;\n        }\n        point = (diff*close/length(diff)) + point;\n        //collision = true;\n        \n    }\n    \n    \n    \n    \n    float bright = lightContribution;\n    \n    if(length(diff) - progress > .1 &&  collision){\n    \n        bright = 0.0;\n    \n    }\n    \n    float d = length(diff);\n    d /= 1000.0;\n    float light = 1.0/(d*d+1.0);\n    bright*=.5*light;\n    fragColor = vec4(bright);\n    \n    \n    \n    \n    vec4 column = vec4(0.0);\n    for(int j = 0; j<planets.length(); j++)\n    {\n         float add = step(length(fragCoord - planets[j].xy), planets[j].z);\n         vec2 normal = ((fragCoord - planets[j].xy)/length(fragCoord - planets[j].xy));\n         vec2 normalDiff = diff.xy/length(diff.xy);\n         float dotp = normal.x*normalDiff.x+normal.y*normalDiff.y;\n         add *= pow(dotp,1.0);\n         column+=add;\n         \n            \n    }\n    \n    fragColor *= 1.0;\n    //fragColor+=column*light*.5;\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 90], [385, 385, 442, 442, 2236]], "test": "untested"}
{"id": "ftByDh", "name": "basic ship", "author": "jorge2017a2", "description": "basic ship", "tags": ["basicship"], "likes": 4, "viewed": 209, "published": 3, "date": "1649558399", "time_retrieved": "2024-07-30T16:54:48.171641", "image_code": "//----------image\n//por jorge2017a2- ///-----basic ship  ---9-abril-2022\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\nvec3 fog = vec3(0.35, 0.38, 0.42);\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    float planeDist2 = 60.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    //float planeDist5 = -p.z+40.0;  //pared frente\n    //float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU2(res, vec2(planeDist1,100.0));\n    res =opU2(res, vec2(planeDist2,100.0)); \n    res =opU2(res, vec2(planeDist3,100.0)); \n    res =opU2(res, vec2(planeDist4,100.0)); \n    \n    //----nave\n    p=p0;\n    float t=iTime;\n    float py=10.0+5.0*cos(t);\n    p.y-=py;\n        p.x+=0.7*py*sin(t);\n        p.z= opRep1D(p.z, 100.0 );\n        p= rotate_y(p, radians(180.0));\n    float d1= sdRoundBox(p-vec3(0.0,0.0,0.0), vec3(0.5,0.7,2.0), 0.25 );\n    float d2= sdTriPrism( p.xzy, vec2(3.0,0.5) );\n     float posz=mod(iTime*20.0,50.0);\n    float d3= sdRoundBox(p-vec3(0.0,0.0,posz), vec3(0.5,0.27,1.0), 0.25 );\n    float posz2=mod(iTime*20.0,50.0);\n    float d4= sdRoundBox(p-vec3(0.0,0.0,posz2+50.0), vec3(0.5,0.27,1.0), 0.25 );\n    \n    res =opU2(res, vec2(d1,2.0));\n    res =opU2(res, vec2(d2,1.0));\n    res =opU2(res, vec2(d3,8.0));\n    res =opU2(res, vec2(d4,9.0));\n    \n    ///postes superior\n    p=p0;\n    p.z= opRep1D(p.z, 50.0 );\n    py= opRep1D(-iTime*10.0, 35.0 );\n    float d1b= sdBox(p- vec3(0.0,45.0+py,25.0), vec3(2.0,8.0,2.0) );\n    res =opU2(res, vec2(d1b,101.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.001 || dist > 20.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    \n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 ){ vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; } \n    if (i==101 ){ \n        float py= opRep1D(-iTime*10.0, 35.0 );\n        p=p- vec3(0.0,45.0+py,25.0);\n        vec3 col=tex3D(iChannel1, p/32., nor); return col*2.0; \n    } \n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50) { colobj=getColor(int( id_color));  return colobj; }\n   \n   if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    ///shane\n    col = mix(col, render_sky_color(rd), smoothstep(.25, .99, hit.x/(MAX_DIST+10.0) ));\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  float t=mod(iTime*10.0,500.0);\n \tlight_pos1= vec3(0.0, 0.+45.0, 10.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(0.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n    vec3 ro=vec3(5.0,7.0,-25.0+t);\n  \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(-20.0));\n   rd= rotate_y(rd, radians(-20.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5)  //9\n \n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftByDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 535, 567, 567, 651], [652, 652, 698, 698, 785], [787, 787, 831, 831, 858], [859, 859, 899, 899, 926], [927, 927, 972, 972, 1000], [1002, 1002, 1038, 1038, 1083], [1084, 1084, 1118, 1118, 1214], [1215, 1215, 1249, 1249, 1340], [1341, 1341, 1375, 1375, 1466], [1468, 1468, 1504, 1504, 1587], [1590, 1590, 1615, 1615, 3040], [3042, 3042, 3066, 3066, 3228], [3230, 3230, 3278, 3278, 3557], [3560, 3560, 3604, 3604, 3924], [3926, 3926, 3963, 3963, 4220], [4222, 4222, 4312, 4312, 5277], [5279, 5279, 5328, 5328, 5576], [5578, 5578, 5610, 5610, 5807], [5809, 5809, 5879, 5879, 6045], [6047, 6047, 6074, 6074, 6163], [6165, 6165, 6223, 6223, 6271], [6273, 6273, 6296, 6296, 6408], [6410, 6410, 6441, 6441, 7104], [7106, 7106, 7163, 7163, 7661]], "test": "untested"}
{"id": "NtBcWh", "name": "09 polar coordinates", "author": "ccc9527", "description": "polar coordinates", "tags": ["polarcoordinates"], "likes": 2, "viewed": 213, "published": 3, "date": "1649555249", "time_retrieved": "2024-07-30T16:54:49.144042", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec2 st = vec2(atan(uv.x,uv.y),length(uv));//笛卡尔坐标系转变为极坐标系\n    \n    //极坐标的x表示角度,一周取值范围是(-3.14,3.14),将他变换到(0,1)之间\n    uv = vec2(st.x/6.2831+0.5,st.y);\n    uv.x += iTime*0.3;//角度一直在变化,表现为旋转效果\n    //uv.x += uv.y;//可以通过各种方法扭曲角度,得到一些意想不到的结果\n    \n    float x= uv.x*5.0;//横坐标放大n倍,在这表示将角度放大n倍\n    float m = fract(x);//取余,得到n个角度为(0,1)的区域\n    m = min(m,1.0-m);//角度从(0,1)变成为(0,0.5)和(0.5,0)两个区域\n    \n    float n = m*0.3+0.2;\n    //uv.y表示的是离原点的距离,距离大于n的时候为0,\n    //小于n-0.1的时候是(0,1),大于n-0.1的时候是1\n    float d = smoothstep(0.0,0.05,n-uv.y);\n    \n    vec3 col = d*vec3(1.0,0.2,0.2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1032]], "test": "untested"}
{"id": "7l2yWR", "name": "Raymarched Quaternion Mandelbrot", "author": "Fraktoler", "description": "4-dimensional version of Mandelbrot set\nThis shader shows the 3d \"slices\" (real-i-j components) of the 4D quaternion Mandelbrot while rotating XY.", "tags": ["fractal", "raymarch", "mandelbrot", "quaternion"], "likes": 1, "viewed": 369, "published": 3, "date": "1649523476", "time_retrieved": "2024-07-30T16:54:50.011721", "image_code": "#define MAX_ITER 10\n#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define MIN_DIST .001\n#define EPSILON .0001\n\n//3 dimensional rotations\n\nvec3 rotate(vec3 p, vec3 rot) {\n    vec2 v = mulComplex(p.yz, cis(rot.x));\n    vec3 p_prime = vec3(p.x, v.xy);\n    v = mulComplex(p_prime.xz, cis(rot.y));\n    p_prime = vec3(v.x, p_prime.y, v.y);\n    v = mulComplex(p_prime.xy, cis(rot.z));\n    p_prime = vec3(v.xy, p_prime.z);\n    return p_prime;\n}\n\n//4 dimensional rotations\n\nvec4 rotateXY(vec4 p, float rot) {\n    mat4 rotXY = mat4(\n    cos(rot), -sin(rot), 0.0, 0.0,\n    sin(rot), cos(rot), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n    );\n    return rotXY * p;\n}\n\nvec4 rotateXZ(vec4 p, float rot) {\n    mat4 rotXZ = mat4(\n    cos(rot), 0.0, -sin(rot), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    sin(rot), 0.0, cos(rot), 0.0,\n    0.0, 0.0, 0.0, 1.0\n    );\n    return rotXZ * p;\n}\n\nvec4 rotateZW(vec4 p, float rot) {\n    mat4 rotZW = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, cos(rot), -sin(rot),\n    0.0, 0.0, sin(rot), cos(rot)\n    );\n    return rotZW * p;\n}\n\nfloat DE(vec3 v) {\n    vec4 c = vec4(v, sin(iTime * 0.2) * 1.25);\n    vec4 q = c;\n    float power = 2.0;\n    float bailout = 2.0;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int k = 0; k < MAX_ITER; k++) {\n        r = length(q);\n\t\tif (r > bailout) break;\n\t\tdr = power * pow(r, power - 1.0) * dr + 1.0;\t\t\n\t\tq = powQuat(q, power) + c;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.0;    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = DE(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<MIN_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normalVector(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat lighting(vec3 p) {\n    vec3 lightPos = rotate(vec3(0.0, -5.0, 5.0), vec3(-0.5, 0., -iTime / 5.));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normalVector(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p + n * MIN_DIST * 2.0, l);\n    if(d < length(lightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.0;\n    vec2 uv = zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    vec3 rot = vec3(-0.5, 0.0, -iTime / 5.);\n    vec3 ro = rotate(vec3(0.0, -3.0, 0.0), rot);\n    vec3 rd = normalize(rotate(vec3(uv.x, 1.0, uv.y), rot));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = lighting(p);\n    vec3 col = vec3(dif);\n    \n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "//Complex (C) functions\nvec2 cis(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 mulComplex(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\n//Quaternion (H) functions\n//https://en.wikipedia.org/wiki/Quaternion\nvec4 conjQuat(vec4 q) {\n    return vec4(q.x, -q.yzw);\n}\n\nvec4 mulQuat(vec4 p, vec4 q) {\n    //Quaternion multiplication (Order matters)\n    return vec4(p.x * q.x - dot(p.yzw, q.yzw), p.x * q.yzw + q.x * p.yzw + cross(p.yzw, q.yzw));\n}\n\nvec4 sqrQuat(vec4 q) {\n    return vec4(q.x * q.x - dot(q.yzw, q.yzw), (q.x + q.x) * q.yzw);\n}\n\nvec4 cubeQuat(vec4 q) {\n    float r2 = q.x * q.x;\n    float v2 = dot(q.yzw, q.yzw);\n    return q * vec4(r2 - 3. * v2, vec3(3. * r2 - v2));\n}\n\nvec4 recipQuat(vec4 q) {\n    //Quaternion reciprocal\n    return vec4(q.x, -q.yzw) / dot(q, q);\n}\n\nvec4 sqrtQuat(vec4 q) {\n    return vec4(sqrt(0.5 * (length(q) + q.x)), normalize(q.yzw) * sqrt(0.5 * (length(q) - q.x)));\n}\n\nvec4 expQuat(vec4 q) {\n    float r = length(q.yzw);\n    return exp(q.x) * vec4(cos(r), normalize(q.yzw) * sin(r));\n}\n\nvec4 logQuat(vec4 q) {\n    return vec4(0.5 * log(dot(q, q)), normalize(q.yzw) * acos(q.x / length(q)));\n}\n\nvec4 powQuat(vec4 q, float x) {\n    float r = length(q);\n    float phi = acos(q.x / r);\n    return pow(r, x) * vec4(cos(x * phi), normalize(q.yzw) * sin(x * phi));\n}\n\nvec4 powerQuat(vec4 p, vec4 q) {\n    return expQuat(mulQuat(logQuat(p), q));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2yWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 165, 165, 432], [461, 461, 495, 495, 665], [667, 667, 701, 701, 871], [873, 873, 907, 907, 1077], [1079, 1079, 1097, 1097, 1457], [1459, 1459, 1493, 1493, 1693], [1695, 1695, 1722, 1722, 1895], [1897, 1897, 1921, 1921, 2235], [2237, 2237, 2294, 2294, 2749]], "test": "untested"}
{"id": "fl2cDz", "name": "magic carpet", "author": "yasuo", "description": "magic carpet", "tags": ["carpet"], "likes": 7, "viewed": 252, "published": 3, "date": "1649516319", "time_retrieved": "2024-07-30T16:54:50.814575", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n#define MATERIAL1 1\n\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n    p = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n    return sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 GetDist(vec3 p) {\n    p*=0.8;\n    vec3 prevP = p;\n    \n    p = prevP;\n    p.x+=iTime*2.1;\n    \n    float n = perlin_noise(p.xz*0.3)*3.0;\n    \n    p = prevP;\n    \n    p.y+=n-0.5;\n    p.x+=sin(n*0.1)*0.6;\n    float d = length(p)-0.5;\n    d = sdBox(p,vec3(1.2,0.01,0.9));\n    p = prevP;\n    float f = (p.y+n)+0.5;\n    p = prevP;\n    vec2 model = vec2(f*0.6,MATERIAL);\n    vec2 model1 = vec2(d*0.6,MATERIAL1);\n    \n    return combine(model,model1);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\nfloat pattern(vec2 p, float rot) {\n    p*=Rot(radians(rot));\n    float size = 0.1;\n\n    float d = B(p,vec2(size));\n    for (int i = 0; i < 3; i++) {\n        vec2 q = abs(p);\n        q-=0.15;\n\n        d = min(d,  B(q,vec2(size)));\n    }\n    return abs(d)-0.02;\n}\n\nfloat pattern2(vec2 p, float rot) {\n    p*=Rot(radians(rot));\n    float size = 0.1;\n    \n    p.x*=2.0;\n    float d = B(p,vec2(size));\n    for (int i = 0; i < 3; i++) {\n        vec2 q = abs(p);\n        q-=0.15;\n        q.x*=2.0;\n        d = min(d,  B(q,vec2(size)));\n    }\n    return abs(d)-0.05;\n}\n\nfloat pattern3(vec2 p, float rot) {\n    p*=Rot(radians(rot));\n    float size = 0.1;\n    \n    float d = length(p)-size;\n    for (int i = 0; i < 3; i++) {\n        vec2 q = abs(p);\n        q-=0.15;\n        d = min(d,  length(p)-size);\n    }\n    return abs(d)-0.02;\n}\n\nvec3 magicCarpetTex(vec3 p){\n    vec2 uv = p.xz;\n    uv.x*=0.85;\n    uv.y*=0.8;\n    vec2 prevUV = uv;\n\n    vec3 col = vec3(0.5,0.0,0.1);\n    \n    uv = abs(uv)-0.15;\n    uv = abs(uv)-0.15;\n    float d =pattern(uv,35.0);\n    \n    float d2 = pattern3(uv,40.0);\n    d = min(d,d2);\n    \n    uv.x = abs(uv.x)-0.6;\n    d2 = pattern2(uv,-30.0);\n    d = min(d,d2);\n    \n    \n    uv = prevUV;\n    \n    col = mix(col,vec3(0.2,0.5,0.8),S(d,0.0));\n    \n    \n    d = B(uv,vec2(1.2,0.8));\n    d = abs(d)-0.02;\n    col = mix(col,vec3(0.9,0.5,0.2),S(d,0.0));\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n\n        col = diffuseMaterial(n,rd,p,vec3(0.9,0.9,0.3));\n    } else if(mat == MATERIAL1){\n        col = diffuseMaterial(n,rd,p,magicCarpetTex(p));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 6, -3.)*.6;\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.y = max(-0.9,ro.y);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    ro.xz *= Rot(radians(-5.0+iTime*20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(0.6);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n\n        col *= exp( 0.001*d.x*d.x );//fog\n    } else {\n \n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    uv.x+=iTime*2.0;\n    col.x+=hash22(uv).x*3.0*hash22(uv).y*3.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2cDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 425, 461, 461, 503], [505, 505, 526, 526, 644], [646, 646, 674, 674, 1272], [1274, 1274, 1305, 1305, 1392], [1394, 1394, 1416, 1416, 1845], [1847, 1847, 1905, 1905, 2172], [2174, 2174, 2198, 2198, 2399], [2401, 2401, 2443, 2443, 2638], [2641, 2641, 2698, 2698, 3267], [3269, 3269, 3303, 3303, 3530], [3532, 3532, 3567, 3567, 3829], [3831, 3831, 3866, 3866, 4094], [4096, 4096, 4124, 4124, 4660], [4662, 4662, 4721, 4721, 4918], [4920, 4920, 4977, 4977, 5873]], "test": "untested"}
{"id": "ftjcWR", "name": "Nebula I", "author": "itishappy", "description": "first pass at a nebula", "tags": ["nebula"], "likes": 1, "viewed": 212, "published": 3, "date": "1649479360", "time_retrieved": "2024-07-30T16:54:51.659316", "image_code": "mat2 rot(float a)\n{\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat noise(vec2 p)\n{\n    return fract(634171.9852*sin(dot(p,vec2(394.915,594.337))));\n}\n\nvec2 noise2(vec2 p)\n{\n    float x = fract(619723.6489*sin(dot(p,vec2(467.294,357.517))));\n    float y = fract(693118.1384*sin(dot(p,vec2(572.221,492.997))));\n    return vec2(x,y);\n}\n\nfloat smoothnoise(vec2 p)\n{\n    vec2 c = floor(p);\n    vec2 d = fract(p);\n    float n = 0.;\n    for (float x=-0.; x<=1.; x++)\n    {\n        for (float y=-0.; y<=1.; y++)\n        {\n            vec2 xy = vec2(x,y);\n            vec2 v = abs(1.-xy-d);\n            n += noise(xy+c) * v.x * v.y;\n        }\n    }\n    n *= 0.5;\n    return n;\n}\n\nfloat fractalnoise(vec2 p)\n{\n    float n = 0.;\n    for (float i=0.; i<9.; i++)\n    {\n        n += smoothnoise(pow(1.5,i)*rot(.1*i)*p)*pow(.8,i);\n    }\n    n *= 0.65;\n    return n;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    uv *= rot(0.01 * iTime);\n    uv *= 16.;\n    \n    float n0 = max(0.,fractalnoise(rot(.14)*uv+vec2(7.12,5.31))-0.65);\n    float nr = max(0.,fractalnoise(rot(.48)*uv+vec2(5.19,4.56))-0.3);\n    float nb = max(0.,fractalnoise(rot(.69)*uv+vec2(3.21,8.67))-0.3);\n    \n    float den = 15.*pow(n0,2.3);\n    float red = sqrt(1.5*nr);\n    float blu = sqrt(1.5*nb);\n    \n    vec3 col = vec3(0.);\n\n    col += 0.8*den*vec3(.9*red,red*blu+.08*(red+blu),blu);\n    \n    uv *= 8.;\n    for (float x=-1.; x<=1.; x++)\n    {\n        for (float y=-1.; y<=1.; y++)\n        {\n            vec2 xy = vec2(x,y);\n            vec2 id = floor(uv) - xy;\n            vec2 p = fract(uv) + xy;\n            float d = distance(p, noise2(id));\n            vec3 c = vec3(.6);\n            c.rb += 0.4*noise2(id + 20.);\n            col += c * (0.5 + 0.5*sin(1.5*iTime + 6.283*noise(id-30.))) * (0.4 + 0.6*noise(id + 30.)) * smoothstep(1.,0.,8.*d);\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 68], [70, 70, 91, 91, 158], [160, 160, 181, 181, 341], [343, 343, 370, 370, 678], [680, 680, 708, 708, 861], [863, 863, 918, 918, 1939]], "test": "untested"}
{"id": "slScWz", "name": "creepy tunnel thing", "author": "SnoopethDuckDuck", "description": "not sure what this is", "tags": ["e"], "likes": 10, "viewed": 329, "published": 3, "date": "1649476539", "time_retrieved": "2024-07-30T16:54:52.449204", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec2 hash( vec2 p ) // modified from iq's too\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\tp = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return p;\n    //return normalize(p); // more uniform (thanks Fabrice)\n}\n\n// slightly modified version of iq's simplex noise shader: https://www.shadertoy.com/view/Msf3WH\nvec3 snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return 1e2*n; //return full vector\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(iTime, 8, iTime);\n   // ro.yz *= Rot(-m.y*3.14+1.);\n   // ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    p.x += tanh(0.1 * iTime) * cos(0.5 * p.z + iTime);\n    float a = 4.;\n    float b = 0.;\n    float e = exp(-0.5 * (cos(4. * p.x + 0. * iTime) + cos(4. * p.z)));\n    float d = -0.1 * p.y * abs(p.x-p.z) + p.y + 0.1 * e * cos(10. * e);\n    d += -0.2+ 0.1 * thc(1., pi * mod(floor(2. * p.z/pi), 2.) + iTime)\n              + 0.1 * ths(1., pi * mod(floor(2. * p.x/pi), 2.) + iTime);\n   // d -= 0. + 0.2 * cos(iTime + 200. * exp(-2. * length(p.xz)));\n   d -= -0.2 + 0.05 * length(p);\n    return 0.1 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,5. * tanh(0.1 * iTime),0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) { \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float a = atan(p.x, p.z);\n        float t = iTime;\n        col = 0.6 + 0.4 * vec3(1) * clamp(dot(n, vec3(0.2,1,0.2)),0.,1.);//0.5 + 0.5 * n;\n       // col *= pal(\n        //col *= exp(-2.8 * p.y);\n        vec3 e = vec3(0.5);\n        \n        col *= 3.5 * pal(n.y, e, e,e, 0.32 * vec3(0,1,2)/3.);\n        //col *= 0.5 + 0.5 * thc(4., 0.1 * length(p.xz) - iTime);\n    }\n    vec2 ipos = floor(p.xz + vec2(iTime/pi,0)) + 0.5;\n    col *= 0.45 + exp(-20. * p.y);\n    //col *= 0.45 + 2. * exp(- 10.5 * length(mod(ipos,2.)));\n    float mx = 1. * clamp(exp(-0.1 * length(p)),0.,1.);\n    vec3 col2 = 0. * vec3(0.02 + 0.02 * cos(0.01 * p.x + iTime),1,1);\n    col = mix(1.-col, col, clamp(4. * mx,0.,1.)) * mx;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slScWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 115, 115, 301], [303, 400, 426, 426, 911], [968, 968, 998, 998, 1074], [1076, 1076, 1114, 1114, 1179], [1181, 1181, 1200, 1200, 1283], [1285, 1285, 1314, 1314, 1395], [1397, 1397, 1411, 1411, 1572], [1574, 1574, 1597, 1597, 2098], [2100, 2100, 2143, 2143, 2450], [2452, 2452, 2476, 2476, 2666], [2668, 2668, 2718, 2718, 2909], [2911, 2911, 2968, 2968, 4112]], "test": "untested"}
{"id": "7tBcWR", "name": "Spiral 2039482352", "author": "SnoopethDuckDuck", "description": "The white is a bit jarring but colored bits look quite fluid", "tags": ["e"], "likes": 4, "viewed": 241, "published": 3, "date": "1649442432", "time_retrieved": "2024-07-30T16:54:53.289957", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //uv *= tanh(iTime);\n    \n    uv *= 2.;\n    \n    float a = atan(uv.x,uv.y);\n    float r = log(length(uv));\n    \n    float v = 1.;\n    float m = 1.;\n    for (float i = 0.; i < 8.; i++) {\n        float io = 2. * mod(i, 2.) - 1.;\n        v = v * cc(0.01, m * iTime + v + (1. + i) * a + 10. * exp(-4. * length(uv)));\n        \n        m *= 1.1;\n    }\n    v = clamp(v, 0., 1.);\n    v = pow(4. * v * (1.-v),1.5);\n    \n    \n    v *= 2.;\n    vec3 col = vec3(v);\n    vec3 e = vec3(0.5);\n    col = v * pal(a/pi, e ,e ,e , vec3(0,1,2)/3.);\n    // * pal(exp(-length(uv)) + a/pi + iTime, e, e ,e, vec3(0,1,2)/3.);\n    col += exp(-cos(length(uv) * 10. - 0.5 * iTime) * 40.) * exp(-10. * v);\n    col = clamp(col, 0., 1.);\n    //col = pow(4. * col * (1.-col), vec3(1.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 919]], "test": "untested"}
{"id": "flSyWz", "name": "Smoother gamut clipping", "author": "bjornornorn", "description": "Comparing gamut clipping allowing hue distortions, top, and gamut clipping without hue distortions on the bottom. With some hue distortions the result can be made smoother and is cheaper to compute.", "tags": ["gamut"], "likes": 2, "viewed": 358, "published": 3, "date": "1649428187", "time_retrieved": "2024-07-30T16:54:54.035962", "image_code": "#define F1 float\n#define F3 vec3\n\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\n\nvec2 approximateShape(float a, float b)\n{\n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1qQA3xhBX3iB8FT8558e5QQnmVZ5Jh1Fb?usp=sharing\n    return vec2(\n        1.63804674 + -0.08431713*a +  0.27624179*b +  0.08737741*a2 +  0.13917503*b2 + 0.03691021*a3 +  0.03060615*b3,\n        0.23438507 + 0.05736278*a  +  -0.09674117*b +  0.024447*a2 + 0.00469441*b2 + 0.01253234*a3 + 0.00741058*b3\n    );\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float middle = 0.2;\n    \n    vec3 x = color-middle;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-middle);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return middle + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = (fragCoord.x / iResolution.x)* 3.141592 * 2.;\n    float L = 3.0*fragCoord.y / iResolution.y;\n    L = L - floor(L);\n    float C = -0.25*log(0.55+0.45*sin(iTime));\n    float a = cos(h);\n    float b = sin(h);\n    float C_max = find_gamut_intersection(a,b,L,1.0,L);\n    \n    vec3 rgb;\n    \n    if (fragCoord.y / iResolution.y > 2.0/3.0)\n    {   \n        // this is an smooth approximation of the sRGB gamut, that is larger than the sRGB gamut everywhere.\n        vec2 ST = approximateShape(a, b);\n        float C_smooth = (1.0/((ST.x/L) + (ST.y/(1.0-L))));\n        \n        // Clip to a smooth gamut larger than the sRGB gamut\n        rgb = oklab_to_linear_srgb(vec3(L, a*min(C,C_smooth), b*min(C,C_smooth)));\n        \n        // soft clipping all colors, if at least one of them is out of gamut:\n        rgb = softClipColorOutsideGamutOnly(rgb);\n        \n    }\n    else if (fragCoord.y / iResolution.y > 1.0/3.0)\n    {\n        rgb = oklab_to_linear_srgb(vec3(L, a*min(C,C_max), b*min(C,C_max)));\n    }\n    else\n    {\n        rgb = oklab_to_linear_srgb(vec3(L, a*C, b*C));\n    }\n    \n    //if (C > C_max)\n    //    rgb = vec3(0.0);\n    \n    rgb = clamp(rgb,0.0,1.0);\n    \n    fragColor.rgb = Srgb3(vec3(rgb));\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "// Copyright(c) 2021 Björn Ottosson\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this softwareand associated documentation files(the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies\n// of the Software, and to permit persons to whom the Software is furnished to do\n// so, subject to the following conditions :\n// The above copyright noticeand this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 55, 55, 111], [112, 112, 131, 131, 176], [179, 179, 220, 220, 799], [801, 801, 836, 836, 976], [978, 978, 1026, 1111, 1552], [1554, 1554, 1611, 1611, 2855]], "test": "untested"}
{"id": "flSyDR", "name": "Mirrored tiles pattern", "author": "fyisic123", "description": ":)", "tags": ["hue", "pattern", "mirrored", "tiles", "psy"], "likes": 4, "viewed": 254, "published": 3, "date": "1649420496", "time_retrieved": "2024-07-30T16:54:54.874719", "image_code": "#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat getRect(in vec2 uv, in float size, in float innerSize)\n{\n    return (-1. * (sign(length(max(abs(uv)-vec2(size),0.0)))) + sign(length(max(abs(uv)-vec2(innerSize),0.0))));\n}\n\nfloat getErect(in vec2 uv, in float size, in float thickness)\n{\n    float p = getRect(uv, size, size - thickness);\n    float s = size * 0.5;    \n    float s2 = s - thickness;\n    \n    p += getRect(uv-size, s, s2);    \n    p += getRect(uv+size, s, s2);\n    p += getRect(uv+vec2(-size,size), s, s2);\n    p += getRect(uv+vec2(size , -size), s, s2);\n    return p;\n    \n}\n\nfloat getCircle(in vec2 uv, in float size, in float thickness)\n{\n    return smoothstep(thickness, 0., abs(length(uv)-size));\n\n}\nfloat getECircle(in vec2 uv, in float size, in float thickness)\n{\n    float p = getCircle(uv, size, thickness);\n    float s = size * 0.5;            \n    p += getCircle(uv-size, s, thickness);    \n    p += getCircle(uv+size, s, thickness);\n    p += getCircle(uv+vec2(-size,size), s, thickness);\n    p += getCircle(uv+vec2(size , -size), s, thickness);\n    return p;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float T = iTime;\n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) /iResolution.y;\n    \n    \n    vec2 screenUV = uv;\n\n    uv *= 8. + (2. * sin(T*0.1)); // zoom   \n    uv *= Rot(length(screenUV )* .2); // twist\n    uv *= Rot(T * -.05); // general rot\n    uv *= pow(length(screenUV), -.2); // \"fov\"    \n    \n    vec2 ID = floor(uv);\n    vec2 gv = fract(uv) -.5;    \n    vec3 col = vec3(0);  \n    \n    \n    if (mod(ID.x, 2.) == 0.)  // mirrors grid\n        gv.x *= -1.;\n    if (mod(ID.y, 2.) == 0.)\n        gv.y *= -1.;\n    \n    \n    // pattern\n    float p = 0.; \n    float p2 =0.;\n    float posSpeed = T * 0.5;\n    vec2 posRot = vec2(cos(posSpeed + sin(posSpeed)), sin(posSpeed + cos(posSpeed*.5))); // center position of pattern\n    vec2 pos = gv + (posRot * (0.6 + (0.3 * sin(T * .5))));\n    mat2 RotMatrix = Rot(asin(sin(T * 0.2)));\n    float thickness = 22. / iResolution.y;\n    for(float i=1.; i > 0.01; i *= .8 + (.1 * sin(T * .9)))\n    {\n        float scale = 0.75 * i;\n        float darkness = pow(i, 2.);\n        p += (getErect(pos, scale, thickness) * darkness);\n        p2 += (getECircle(pos, scale, thickness) * darkness);\n        pos *= RotMatrix;\n    }\n      \n    p = mix(p, p2,0.6 * abs(asin(sin(T * .1))));\n    vec3 pCol = (hue((p * .7) + (T * .1) + length(screenUV *.5)) *p);\n    \n    \n    // background \n    uv *= 3.;\n    uv *= Rot(T);    \n    gv *= Rot(abs(dot(uv.x + uv.y * sin(T), length(gv))) + T);    \n    float bg = pow(length(gv + 3. * .5) * .3, 4.);                    \n    vec3 bgCol = hue(bg * 24.) *bg * .25; \n    float bgLum = (bgCol.r + bgCol.g + bgCol.b) / 3.;    \n    bgCol = mix(bgCol, vec3(bgLum), 0.15);\n      \n      \n      \n    col +=  bgCol+ pCol;           \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 119, 119, 181], [182, 182, 244, 244, 359], [361, 361, 424, 424, 727], [729, 729, 793, 793, 856], [857, 857, 922, 922, 1229], [1230, 1230, 1287, 1287, 3024]], "test": "untested"}
{"id": "7ljczw", "name": "Reproject Web Mercator", "author": "venus", "description": "Reproject Web Mercator to Geographic。Web Mercator 投影的特点是靠近极地地方占比大，靠近赤道的地方占比小，所以高纬度的地方看起来就显得面积比较大，比如格陵兰岛和南极洲，或者导致俄罗斯看起来比非洲还大。所以，为了把 Web Mercator 转换为 Geographic（Equirectangular projection），在输入是均匀的 UV 情况下，就需要反过来，导致结果看起来是靠近极地地方占比小，靠近赤道的地方占比大", "tags": ["webmercator"], "likes": 0, "viewed": 222, "published": 3, "date": "1649403927", "time_retrieved": "2024-07-30T16:54:55.680565", "image_code": "#define north 1.4844222297453322\n#define south -1.4844222297453322\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 geographicUV = uv;\n\n\n    float sinLatitude = sin(south);\n    float southMercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    sinLatitude = sin(north);\n    float northMercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    float oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n\n\n      float fraction = geographicUV.y;\n      float latitude = mix(south, north, fraction);\n      sinLatitude = sin(latitude);\n      float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n      float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\n      float webMercatorT = mercatorFraction;\n      vec2 webMercatorUV = vec2(geographicUV.x, webMercatorT);\n\n\n    // Output to screen\n    vec2 click = iMouse.xy / iResolution.xy;\n    uv = uv.x > click.x\n      ? webMercatorUV\n      : geographicUV;\n    float r = texture(iChannel0, uv).r;\n\n    fragColor.rgb = vec3(r);\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 125, 175, 1191]], "test": "untested"}
{"id": "st2yRw", "name": "Metal branch mosaic", "author": "jarble", "description": "Another ornate mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 4, "viewed": 320, "published": 3, "date": "1649390702", "time_retrieved": "2024-07-30T16:54:56.520320", "image_code": "#define fmod(x,y) mod(floor(x),y)\n\nvec2 fract1(vec2 a){\n    return\n        fract(a)\n        //fract(a-fract(a*4.)/2.)\n    ;\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c)*v;\n}\n\nvec2 triangle_wave(vec2 a,float num){\n    a = rotate(a,num*radians(180.));\n    return abs(fract1((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    float p1 = 1.;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    vec3 col1 = col;\n    for(int k = 0; k < 9; k++){\n        //uv.y -= fmod(uv.y,1.5); //lace pattern\n        float rotation_number = 0.;\n        //rotation_number -= (floor(uv.x+uv.y)*2.+float(k))*1.5;\n\n        //rotation_number += p1/2.;\n        //rotation_number = floor(uv.x+uv.y-2.)/2.;\n\n        uv += t2;\n        uv /= scale;\n        //uv = abs(uv);\n        //uv.x += sign(uv.x)/2.;\n        //uv.y += sign(uv.y)/2.;\n\n        t2 = p1*triangle_wave(uv-.5+floor(t2.y+t2.x),rotation_number);\n        t3 = -p1*triangle_wave(uv.yx+floor(t2.y+t2.x),rotation_number);\n        //t3 -= dot(t3,t3)/4.; //makes another interesting pattern\n\n        uv = t2-t3;\n        p1 *= -1.;\n        //p1 *= sign(uv.y+.5);\n\n        float multiplier = 1.25;\n        //col.x += (-col.x)/4.;\n\n        //col.x /= multiplier;\n        col.x = max(uv.y+uv.x-col.x*2.,col.x*(multiplier));\n        //col.x = max(uv.y+uv.x-col.x*(2.*(2.-uv.y)-(uv.x+uv.y)/2.),col.x*(multiplier));\n        //col.x = abs(.5-col.x);\n        col = abs(col.yzx-vec3(1.-col.x))/multiplier;\n        col1 = abs(col-col1);\n    }\n    fragColor =\n        vec4(col*2.,1.0);\n        //vec4(col1*2.,1.0);\n}\n\n/*\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c)*v;\n}\n\nvec2 triangle_wave(vec2 a,float num){\n    a = rotate(a,num*radians(180.));\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    float p1 = 1.;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    for(int k = 0; k < 12; k++){\n        float rotation_number = 0.;\n        //rotation_number -= (floor(uv.x+uv.y)*2.+float(k))*1.5;\n\n        //rotation_number += p1/2.;\n        //rotation_number = floor(uv.x+uv.y-2.)/2.;\n\n        uv += t2;\n        //uv /= scale;\n        //uv.x += sign(uv.x)/2.;\n        //uv.y += sign(uv.y)/2.;\n\n        t2 = -p1*triangle_wave(uv-.5,rotation_number)/3.;\n        t3 = p1*triangle_wave(uv.yx,rotation_number);\n        uv = t2-t3;\n        p1 *= -1.;\n        //p1 *= sign(uv.y+.5);\n\n        float multiplier = 1.25;\n        //col.x += (-col.x)/4.;\n\n        //col.x /= multiplier;\n        col.x = max(uv.y+uv.x-col.x*2.,col.x*(multiplier));\n        //col.x = max(uv.y+uv.x-col.x*(2.*(2.-uv.y)-(uv.x+uv.y)/2.),col.x*(multiplier));\n        //col.x = abs(.5-col.x);\n        col = abs(col.yzx-vec3(1.-col.x))/multiplier;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2yRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 55, 55, 125], [127, 127, 157, 157, 226], [228, 228, 265, 265, 353], [355, 355, 412, 412, 1877]], "test": "untested"}
{"id": "stjyRw", "name": "Mandelbrot Set - distance", "author": "iq", "description": "Two distance estimators for the Mandelbrot Set. ESTIMATOR 0 is the one most people use to raymarch quaternionic quadratic sets (like Mandelbrot or Julia set). ESTIMATOR 1 is however a MUCH better estimator and no much more expensive.", "tags": ["2d", "fractal", "distance", "manderbor"], "likes": 29, "viewed": 1345, "published": 3, "date": "1649390182", "time_retrieved": "2024-07-30T16:54:57.267323", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Two different distance esimators for the Mandelbrot Set (M).\n// The first one (ESTIMATOR 0 below) is the one most people use to\n// raymarch quaternionic quadratic sets (like Mandelbrot or Julia\n// set), but only works well when very close to M. The second one\n// (ESTIMATOR 1) is a better estimator, especially far from M,\n// that is basically not much more expensive although does suffer\n// form precision when close to M.\n//\n// More info:\n//\n// https://iquilezles.org/articles/distancefractals\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// 0 : traditional estimator\n// 1 : much better estimator\n#define ESTIMATOR 0\n\nfloat sdMandelbrot( vec2 c )\n{\n    vec2 z = vec2(0.0,0.0);\n    vec2 dz = vec2(0.0,0.0);\n    bool exterior = false;\n    float r2;\n    float n = 0.0;\n    for( int i = 0; i<256; i++ )\n    {\n        // dz -> 2·z·dz + 1\n        dz = 2.0*vec2(z.x*dz.x - z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n        // z -> z² + c\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        \n        n += 1.0;\n        r2 = dot(z,z);\n        if( r2>65536.0 )\n        {\n            exterior = true;\n            break;\n        }\n    }\n    \n    #if ESTIMATOR==0\n\t float d = 0.5*sqrt(r2/dot(dz,dz))*log(r2);\n    #else\n     float en = exp2(n);\n     float d = 0.5*sqrt(r2/dot(dz,dz))*en*(1.0-pow(r2,-1.0/en));\n    #endif\n    return (exterior) ? d : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate\n    bool zoom = sin(iTime*0.6)<-0.4;\n\n    // transform\n    vec3 tx = zoom ? vec3(-0.745,0.186, 0.05 ) : vec3(-0.5,0.0, 1.2 );\n    p = tx.xy + p*tx.z;\n    m = tx.xy + m*tx.z;\n    float px = tx.z*2.0/iResolution.y;\n\n    // if not mouse\n    if( iMouse.z<0.001 )\n    {\n        if( zoom )\n        {\n            m = vec2(-0.775,0.2);\n            m += vec2(0.015,0.02)*vec2(cos(iTime),sin(iTime));\n        }\n        else\n        {\n            float time = iTime*0.5;\n            m  = vec2(-0.75,0.0);\n            m += vec2(1.6,1.3)*vec2(cos(time*1.1),sin(time*1.1));\n            m += vec2(0.4,0.4)*vec2(cos(time*3.1),sin(time*3.1));\n        }\n    }\n    \n    // distance\n    float d = sdMandelbrot(p);\n    \n    // coloring\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-5.0*abs(d/tx.z));\n\tcol *= 0.8 + 0.2*cos(100.0*abs(d/tx.z));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,1.4*px,abs(d)) );\n\n    //if( iMouse.z>0.001 )\n    {\n    d = sdMandelbrot(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, px, abs(length(p-m)-abs(d))-px));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, px, length(p-m)-px*4.0));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjyRw.jpg", "access": "api", "license": "mit", "functions": [[1787, 1787, 1817, 1817, 2528], [2530, 2530, 2587, 2623, 3948]], "test": "ok"}
{"id": "7lByzw", "name": "Mandelbrot distance estimator", "author": "Fraktoler", "description": "https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Distance_estimates\nHold the mouse in the canvas (Outside the Mandelbrot set) to estimate the distance from the mouse (Red circle).", "tags": ["fractal", "mandelbrot", "distanceestimator"], "likes": 2, "viewed": 275, "published": 3, "date": "1649385149", "time_retrieved": "2024-07-30T16:54:58.129018", "image_code": "#define MAX_ITER 256.\n\nvec2 mandelbrotDE(vec2 c) {\n    vec2 p = vec2(2.0, 0.0);\n    vec2 z = c;\n    float k = 0.0;\n    vec2 dz = one;\n    float r;\n    while (k < MAX_ITER) {\n        r = length(z);\n        if (r > 256.0) break;\n        dz = mul(p, mul(powervec2(z, p - one), dz)) + one;\n        z = powervec2(z, p) + c;\n        k += 1.0;\n    }\n    return vec2(k, 0.5 * log(r) * r / length(dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.0;\n    vec2 uv = zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n\n    vec2 n = mandelbrotDE(uv);\n    vec3 col;\n    if (n.x == MAX_ITER) {\n        col = vec3(0.0);\n    } else {\n        float sinlogdist = sin(log(n.y));\n        col = vec3(sinlogdist * sinlogdist);\n        //col = vec3(0.1 * sqrt(n.x));\n    }\n\n    float thickness = 0.01;\n    vec2 mouse = zoom * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.x;\n    float d = mandelbrotDE(mouse).y;\n    float l = length(uv - mouse);\n    if (d - thickness < l && l < d + thickness) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(col,1.0);\n    }\n}", "image_inputs": [], "common_code": "/*\nConstants\n\n one = vec2(1., 0.)\n i = vec2(0., 1.)\n pi = 3.14159265358979\n e = 2.718281828459045\n\nComplex functions\n\n mag2(z) = |z|^2 = dot(z, z)\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n normalizesqr(z) = normalize(z^2)\n cube(z) = z^3\n power5(z) = z^5\n power7(z) = z^7\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n powerfv(x, z) = x^z (Complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n cbrt(z) = z^(1/3) (Principal cube root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n*/\n#define one vec2(1., 0.)\n#define two vec2(2., 0.)\n#define i vec2(0., 1.)\n#define pi 3.14159265358979\n#define e 2.718281828459045\n//const float[] B = float[](1., .5, 1./6., 0., -1./30., 0., 1./42., 0., -1./30., 0., 5./66., 0., -691./2730., 0., 7./6.);\n\nfloat mag2(in vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(in vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(in vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 rabs(in vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(in vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(in float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(in vec2 z, in vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(in vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvec2 recip(in vec2 z) {\n    return conj(z) / dot(z, z);\n}\n\nvec2 sqr(in vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 normalizesqr(in vec2 z) {\n    return one - conj(z.yx) * (z.y + z.y) / dot(z, z);\n}\n\nvec2 cube(in vec2 z) {\n    vec2 z2 = z * z;\n    return z * (vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx);\n}\n\nvec2 power5(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power7(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z6 = z2 * z2 * z2;\n    return conj(z) * (z6 - 7. * z6.yx - z2.x * z2.y * (21. * z2 - 35. * z2.yx));\n}\n\nvec2 power(in vec2 z, in float p) {\n    return pow(dot(z, z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(in vec2 z, in vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(dot(z, z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 powerfv(in float x, in vec2 z) {\n    float lnr = log(x);\n    return exp(z.x * lnr) * cis(z.y * lnr);\n}\n\nvec2 sqrtp(in vec2 z) {\n    float r = length(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 cbrt(in vec2 z) {\n    return power(z, .333333333333);\n}\n\nvec2 powexp(in vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(in vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(in vec2 z, in vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(in vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(in vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) + one) - i;\n}\n\nvec2 tangent(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) - one) + i;\n}\n\nvec2 cot(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(in vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(in vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(in vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(in vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(in vec2 z) {\n    return -0.5 * mulI(ln(div(i - z, i + z)));\n}\n\nvec2 arccot(in vec2 z) {\n    return -0.5 * mulI(ln(div(z + i, z - i)));\n}\n\nvec2 arcsec(in vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(in vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(in vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(in vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(in vec2 z) {\n    return one - div(two, powexp(z + z) + one);\n}\n\nvec2 tanhyp(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(in vec2 z) {\n    return one + div(two, powexp(z + z) - one);\n}\n\nvec2 coth(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(in vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(in vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(in vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(in vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(in vec2 z) {\n    return .5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(in vec2 z) {\n    return .5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(in vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(in vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(in vec2 z, in vec2 a, in vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(in vec2 z, in vec2 a, in vec2 b, in vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lByzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 50, 50, 395], [397, 397, 454, 454, 1120]], "test": "untested"}
{"id": "ftjcRm", "name": "08 Car Light ", "author": "ccc9527", "description": "Car Light,you can click and move mouse", "tags": ["carlight"], "likes": 5, "viewed": 266, "published": 3, "date": "1649379874", "time_retrieved": "2024-07-30T16:54:58.877018", "image_code": "//I learn from:https://www.youtube.com/watch?v=eKtsY7hYTPg\nstruct Ray   //射线结构体\n{\n    vec3 origin;//射线原点origin\n    vec3 direction;//射线方向direction\n};\n\n//伪随机,t乘以一个大的数,使得sin值伪随机,再乘以一个大的数,然后取小数部分,得到伪随机的小数部分\nfloat Noise(float t)\n{\n    return fract(sin(t*3456.0)*6547.0);\n}\n//输入一个数，返回一个伪随机的vec4\nvec4 Noise14(float t)\n{\n    return fract(sin(t*vec4(123.0,1024.0,3456.0,9821.0))*vec4(6547.0,345.0,9123.0,2431.0));\n}\n\n//设置摄像机的三个基向量以及摄像机点到屏幕上每个像素点的方向\nRay SetCamera(vec2 uv,vec3 camPos,vec3 lookat,float zoom)\n{\n    Ray ray;\n    ray.origin = camPos;\n    //摄像机的三个基向量\n    vec3 forward = normalize(lookat-camPos);\n    vec3 right = cross(vec3(0.0,1.0,0.0),forward);\n    vec3 up = cross(forward,right);\n    \n    vec3 center = ray.origin+forward*zoom;//屏幕中心点坐标\n    vec3 i = center+right*uv.x+up*uv.y;//屏幕上的每个点坐标\n    ray.direction = normalize(i-ray.origin);//摄像机点到屏幕每个像素点的方向\n    \n    return ray;\n}\n\n//求点p到射线的距离\nfloat GetDistance(Ray ray,vec3 p)\n{\n    return length(cross(p-ray.origin,ray.direction));\n}\n\n//绘制圆效果,size为圆的大小,blur是模糊程度,百分比\nfloat Bokeh(Ray ray,vec3 p,float size,float blur)\n{\n    float d = GetDistance(ray,p);//求点p到每条射线(每个像素点-射线原点)的距离\n    size *= length(p);//点p距离越近,大小乘以距离,使得圆在靠近摄像机时大小不变\n    float c = smoothstep(size,size-blur*size,d);//绘制小圆\n    c *= mix(0.6,1.0,smoothstep(0.8*size,size,d));//边缘过度效果(0.8,1.0)的时候\n    \n    return c;\n}\n\n//绘制一系列圆，组成一个移动的效果\nvec3 Light(Ray ray,float t)\n{\n    float side = step(ray.direction.x,0.0);//在左半边是为1\n    ray.direction.x = abs(ray.direction.x);//关于y对称\n    float s = 1.0/10.0;//for循环间隔\n    float mask = 0.0;\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        float ti = fract(t+i+side*s*0.5);//fract取小数部分的函数,左半边比右半边快一些\n        vec3 p = vec3(2.0,2.0,100.0-ti*100.0);//10个深度不同的圆\n        mask += Bokeh(ray,p,0.05,0.1)*ti*ti*ti;//乘以t^3减少初始地区圆的数量\n    }\n    \n    return vec3(1.0,0.7,0.3)*mask;\n}\n\n//环境光\nvec3 EnvLight(Ray ray,float t)\n{\n    float side = step(ray.direction.x,0.0);//在左半边是为1\n    ray.direction.x = abs(ray.direction.x);//关于y对称\n    float s = 1.0/10.0;//for循环间隔\n    vec3 col = vec3(0.0);\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        vec4 n = Noise14(i+side*100.0);//+side*100可以使得左右两边颜色不同\n        float ti = fract(t+i+side*s*0.5);//fract取小数部分的函数,左半边比右半边快一些\n        float fade = ti*ti*ti;//乘以t^3减少初始地区圆的数量\n        \n        float occlusion = sin(ti*6.28*10.0*n.x)*0.5+0.5;//结果为(0,1),乘以n.x达到随机某个圆消失\n        fade = occlusion;\n        \n        float x = mix(2.5,10.0,n.x);\n        float y = mix(0.1,1.0,n.y);\n        vec3 p = vec3(x,y,50.0-ti*50.0);//10个深度不同的圆\n        \n        col += Bokeh(ray,p,0.05,0.1)*fade*n.wzy*0.5;\n    }\n    \n    return col;\n}\n\n//与Light类似,没有对称边,头灯\nvec3 HeadLight(Ray ray,float t)\n{\n    t *= 2.0;\n    vec3 w1 = vec3(0.25,0.0,0.0);\n    vec3 w2 = w1*1.2;\n    float s = 1.0/10.0;//for循环间隔\n    float mask = 0.0;\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        float n = Noise(i);\n        if(n>0.1) continue;//去掉一些随机值小于0.1的部分，达到一个随机效果\n        \n        float ti = fract(t+i);//fract取小数部分的函数,左半边比右半边快一些\n        float focus = smoothstep(0.9,1.0,ti);\n        float size = mix(0.05,0.04,focus);\n        \n        float fade = ti*ti*ti*ti*ti;\n        vec3 p = vec3(-1.0,0.15,100.0-ti*100.0);//10个深度不同的圆\n        mask += Bokeh(ray,p-w1,size,0.1)*fade;//乘以t^n减少初始地区圆的数量\n        mask += Bokeh(ray,p+w1,size,0.1)*fade;\n        \n        mask += Bokeh(ray,p-w2,size,0.1)*fade;\n        mask += Bokeh(ray,p+w2,size,0.1)*fade;\n        \n        float ref = 0.0;//反射,y取相反,然后模糊百分比是1,size大一些\n        ref += Bokeh(ray,(p-w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade;\n        ref += Bokeh(ray,(p+w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade;\n        \n        mask += ref*focus;\n    }\n    \n    return vec3(0.9,0.9,1.0)*mask;\n}\n\n//尾灯\nvec3 TailLight(Ray ray,float t)\n{\n    t *= 0.25;\n    vec3 w1 = vec3(0.25,0.0,0.0);\n    vec3 w2 = w1*1.2;\n    float s = 1.0/15.0;//for循环间隔\n    float mask = 0.0;\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        float n = Noise(i);\n        if(n>0.5) continue;//去掉一些随机值小于0.1的部分，达到一个随机效果\n        \n        float lane = step(0.25,n)+0.4;//用于红色偏移\n        \n        float ti = fract(t+i);//fract取小数部分的函数,左半边比右半边快一些\n        float focus = smoothstep(0.8,1.0,ti);\n        float size = mix(0.05,0.04,focus);\n        \n        float laneShift = smoothstep(1.0,0.96,ti);//部分红色转弯\n        \n        float fade = ti*ti*ti*ti*ti;\n        float z = 100.0-ti*100.0;\n        vec3 p = vec3(1.5-lane*laneShift,0.15,z);//10个深度不同的圆\n        mask += Bokeh(ray,p-w1,size,0.1)*fade;//乘以t^n减少初始地区圆的数量\n        mask += Bokeh(ray,p+w1,size,0.1)*fade;\n        \n        float blink = step(0.,sin(1000.0*t))*7.0*step(0.25,n)*step(0.96,ti);//乘以step(0.96,ti)让红色转弯时才闪烁\n        mask += Bokeh(ray,p-w2,size,0.1)*fade;\n        mask += Bokeh(ray,p+w2,size,0.1)*fade*(1.0+blink);\n        \n        float ref = 0.0;//反射,y取相反,然后模糊百分比是1,size大一些\n        ref += Bokeh(ray,(p-w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade;\n        ref += Bokeh(ray,(p+w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade*(1.0+blink*0.1);\n        \n        mask += ref*focus;\n    }\n    \n    return vec3(1.0,0.1,0.03)*mask;\n}\n\n//rain雨,在挡风玻璃前的雨\nvec2 Rain(vec2 uv,float t)\n{\n    t *= 40.0;\n    vec2 a = vec2(3.0,1.0);//分出多行多列\n    vec2 st = uv*a;\n    \n    vec2 id = floor(st);//获得每个雨滴是第几行第几列\n    st.y += t*0.22;   //网格下降,和雨滴上升抵消,达到雨滴先下落后暂停的循环\n    \n    float n = fract(sin(id.x*716.34)*768.34);//根据不同的列获得不同的随机数\n    //对y进行偏移,使得不同列起始位置不同\n    st.y += n;\n    uv.y += n;\n    \n    id = floor(st);//根据偏移后的坐标重新计算行数和列数\n    st = fract(st)-0.5;//st范围变为(-0.5,-0.5)-(0.5,0.5)\n    \n    //根据不同行,不同列队t进行偏移,使得不同雨滴下落时间不同\n    t += fract(sin(id.x*76.34+id.y*1453.7)*768.34)*6.283;\n    float offsetY = -sin(t+sin(t+sin(t)*0.5))*0.43;\n    vec2 offset = vec2(0.0,offsetY);//大雨滴的滑落偏移\n    \n    vec2 o1 = (st-offset)/a;//除以横纵比,不再是椭圆\n    float d = length(o1);\n    float m1 = smoothstep(0.07,0.0,d);\n    \n    //大雨滴后面的小雨滴\n    vec2 o2 = (fract(uv*a.x*vec2(1.0,2.0))-0.5)/vec2(1.0,2.0);\n    d = length(o2);//除以横纵比,将x,y方向间距相同\n    \n    float mask = smoothstep(-0.1,0.1,st.y-offset.y);//去除大雨滴下面的小雨滴\n    \n    //模拟大雨滴划过之后留在原地的小雨滴\n    float m2 = smoothstep(0.2*(0.6-st.y),0.0,d)*mask;//距离大雨滴越远的水滴越小\n    \n    //if(st.x>0.46 || st.y>0.49) m1=1.0;//边界线\n    \n    return vec2(m1*o1*5.0+m2*o2*5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;//鼠标点击位置\n    \n    //虚拟摄像机\n    vec3 camPos = vec3(0.0,0.2,0.0);\n    vec3 lookat = vec3(0.0,0.2,1.0);\n    float zoom = 2.0;//可以调整摄像机与屏幕的距离\n    \n    float t = iTime*0.1+m.x;//时间和鼠标点击位置的x值共同决定\n    \n    vec2 rainDistort = Rain(uv*7.0,t)*0.5;//扭曲的uv\n    rainDistort += Rain(uv*9.0,t)*0.5;\n    \n    //对uv的xy进行小幅度的偏移,让圆不那么规则\n    uv.x += sin(uv.y*70.0)*0.005;\n    uv.y += sin(uv.x*170.0)*0.003;\n    \n    //uv.x -= 0.5;\n    Ray ray = SetCamera(uv-rainDistort,camPos,lookat,zoom);\n    \n    vec3 col = vec3(0.0);\n    col += Light(ray,t);//黄色部分\n    col += HeadLight(ray,t);//白色部分\n    col += TailLight(ray,t);//红色部分\n    col += EnvLight(ray,t);//随机颜色部分\n    \n    col += (ray.direction.y+0.15)*vec3(0.3,0.4,0.7);//渐变天空\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 311, 333, 333, 375], [376, 425, 448, 448, 542], [544, 634, 693, 693, 1152], [1154, 1182, 1217, 1217, 1273], [1275, 1343, 1394, 1394, 1767], [1769, 1820, 1849, 1849, 2387], [2389, 2401, 2433, 2433, 3309], [3311, 3351, 3384, 3384, 4547], [4549, 4558, 4591, 4591, 6092], [6094, 6129, 6157, 6157, 7640], [7642, 7642, 7699, 7699, 8704]], "test": "untested"}
{"id": "7tBcRm", "name": "precision", "author": "iq", "description": "Shows when variables start losing precision as they grow to be around 11 to 21 bits large. When you'll start seeing the staircase (lose of precision) depends on your GPU and screen resolution. Anything between 14 and 16 bits is probably normal.", "tags": ["glsl", "precision", "bits"], "likes": 37, "viewed": 1277, "published": 3, "date": "1649358625", "time_retrieved": "2024-07-30T16:54:59.615045", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// This shader shows when variables start losing precision as\n// they grow to be in the order of 11, 12, ... 21 bits large.\n//\n// In an ideal world, the blue line would be a perfect ramp.\n// But when you start seeing the staircase (lose of precision)\n// at some point that depends on your GPU and screen resolution.\n// Anything between 14 and 16 bits is normal.\n//\n// The yellow signal is the difference between the ramp we get\n// and the ramp we would ideally get.\n//\n// If the blue signal was time, you could safely expect about one\n// hour of smooth animation. So, make sure you compute time always\n// in some 64 bit type and that you only convert it to event-relative\n// float32 (for sound synthesis or animation) AFTER subtracting the \n// 64 bit global time from the event's trigger time which is also in\n// 64 bit precision.\n\n\nconst int kBitsA = 11;\nconst int kBitsB = 22;\n\nfloat printDigit( in int n, in vec2 p )\n{\t\t\n    // digit bitmap by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    const int lut[10] = int[10](480599,139810,476951,476999,71028,464711,464727,476228,481111,481095);\n    // extract bit\n\tivec2 q = ivec2(p*vec2(4,5));\n    if( q.x<0 || q.x>3 || q.y<0 || q.y>4 ) return 0.0;\n\tint id = 4*q.y + q.x;\n    return float( (lut[n]>>id) & 1 );\n}\n\n#define ZERO(v) (min(iTime*v,0.0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords\n    vec2 p = vec2(fragCoord)/iResolution.xy;\n    float px = 2.0/iResolution.y;\n\n    // number of bits \n    float wct  = float(kBitsB-kBitsA)*p.x;\n    float wcf  = fract(wct);\n    int   bits = kBitsA + int(floor(wct));\n    \n    // offset value\n    float t = p.x + exp2(float(bits));\n\n    const float sep = 0.12;\n\n    // background \n    vec3 col = vec3( 0.15 );\n\n    // plot t\n    {\n        float y = t - exp2(float(bits)+ZERO(1.0));\n        y = sep + (1.0-sep)*(0.1+0.8*y);\n        float dy = (1.0-sep)*0.8;\n        float d  = abs(p.y-y)/sqrt(1.0+dy*dy);\n        col = mix( col, vec3(0.0,0.8,1.0), smoothstep(px,0.0,d) );\n    }\n    // plot error\n    {\n        float v1  = t - exp2(float(bits)+ZERO(2.0));\n        float v2 = p.x;\n        float y = v1-v2;\n        y = sep + (1.0-sep)*(0.1+0.8*y);\n        float dy = (1.0-sep)*0.8;\n        float d  = abs(p.y-y)/sqrt(1.0+dy*dy);\n        col = mix( col, vec3(0.9,0.6,0.2), smoothstep(px,0.0,d) );\n    }\n    // plot vertical lines\n    {\n        col += smoothstep(1.0-px*6.0,1.0,2.0*abs(wcf-0.5));\n    }\n    // plot horizontal lines\n    {\n        float d = min( 2.0*abs(p.y-sep), abs(abs(p.y-0.5)-0.5) );\n        col += smoothstep(px,0.0,d);\n    }\n    // plot digits\n    {\n        float wi = 1.0/float(kBitsB-kBitsA);\n        vec2 p = vec2(wcf,float(kBitsB-kBitsA)*fragCoord.y/iResolution.x);\n        p.x -= 3.0*wi;\n        p.y -= 3.0*wi;\n        col += printDigit( bits/10, 5.0*p );\n        p.x -= 4.0*wi;\n        col += printDigit( bits%10, 5.0*p );\n    }\n    \n    // output color\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBcRm.jpg", "access": "api", "license": "mit", "functions": [[2025, 2025, 2066, 2139, 2410], [2448, 2448, 2505, 2519, 4081]], "test": "ok"}
{"id": "7lScRm", "name": "Simple Circle 0985394583", "author": "SnoopethDuckDuck", "description": "playing with things ", "tags": ["e"], "likes": 5, "viewed": 229, "published": 3, "date": "1649355533", "time_retrieved": "2024-07-30T16:55:00.389973", "image_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(float n, float spd, float t) {      \n    //float t = iTime; //floor(spd * time) / spd;\n    float f = fract(t);//fract(spd * time);\n\n    vec2 p = vec2(cos(t), sin(t));\n    t += n/spd;\n    vec2 p2 = vec2(cos(t), sin(t));\n    t -= n/spd;\n    vec2 p3 = vec2(cos(t), sin(t));\n    \n    f = 1. - pow(1.-f,4.);\n    f = smoothstep(0.,1.,f);\n    \n    float m = clamp(2. * f, 0., 1.);\n    float m2 = clamp(2. * f, 1., 2.) - 1.;\n    return 0.45 * mix(mix(p,p2,m), p3, m2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float spd = 4.;\n\n    float s = 0.;\n\n    float k = 1. / iResolution.y;\n    float n = spd * 4.;\n    for (float i = 0.; i < n; i++) {\n        float io = 2. * pi * i / n;\n        vec2 p = pnt(1., spd, 0.5 * iTime + io);\n        p *= (0.75 + 0.25 * thc(4., 4. * io + 0.5 * iTime));\n        float o2 = 1./n;\n        vec2 p2 = pnt(1., spd, 0.5 * iTime + io + o2);       \n        p2 *= (0.75 + 0.25 * thc(4., 0.5 * iTime));\n        \n        float d = seg(uv, p, p2);// length(uv - p);\n        s = max(s - 0.5 * s * cos(i * pi / n + iTime), smoothstep(-k, k, -d + 0.015));\n        \n    }\n  \n    vec3 col = vec3(s);\n    col += 0.22 * exp(-1. * (uv.y + 0.5)); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lScRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 105, 105, 224], [226, 226, 265, 321, 697], [699, 699, 756, 756, 1510]], "test": "untested"}
{"id": "slByRw", "name": "Raymarched Mandelbulb renderer", "author": "Fraktoler", "description": "https://en.wikipedia.org/wiki/Mandelbulb", "tags": ["fractal", "raymarch", "mandelbulb"], "likes": 3, "viewed": 315, "published": 3, "date": "1649342836", "time_retrieved": "2024-07-30T16:55:01.317494", "image_code": "#define MAX_ITER 10\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define MIN_DIST .001\n#define EPSILON .0001\n\nvec2 cis(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 mul(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec3 rotate(vec3 p, vec3 rot) {\n    vec2 v = mul(p.yz, cis(rot.x));\n    vec3 p_prime = vec3(p.x, v);\n    v = mul(p_prime.xz, cis(rot.y));\n    p_prime = vec3(v.x, p_prime.y, v.y);\n    v = mul(p_prime.xy, cis(rot.z));\n    p_prime = vec3(v, p_prime.z);\n    return p_prime;\n}\n\nfloat DE(vec3 c) {\n    vec3 z = c;\n    float power = 8.0;\n    float bailout = 2.0;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int k = 0; k < MAX_ITER; k++) {\n        r = length(z);\n\t\tif (r > bailout) break;\n\t\t\n\t\tfloat theta = power * acos(z.z/r);\n\t\tfloat phi = power * atan(z.y, z.x);\n\t\tdr =  pow(r, power-1.0) * power * dr + 1.0;\t\t\n\t\tr = pow(r,power);\n\t\t\n\t\tz = r * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta)) + c;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = DE(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<MIN_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normalVector(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat lighting(vec3 p) {\n    vec3 lightPos = rotate(vec3(0.0, -5.0, 5.0), vec3(-0.5, 0., iTime / 5.));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normalVector(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p + n * MIN_DIST * 2.0, l);\n    if(d < length(lightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.0;\n    vec2 uv = zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    vec3 rot = vec3(-0.5, 0.0, iTime / 5.);\n    vec3 ro = rotate(vec3(0.0, -3.0, 0.0), rot);\n    vec3 rd = normalize(rotate(vec3(uv.x, 1.0, uv.y), rot));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = lighting(p);\n    vec3 col = vec3(dif);\n    \n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slByRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 131, 131, 174], [176, 176, 202, 202, 248], [250, 250, 281, 281, 521], [523, 523, 541, 541, 997], [999, 999, 1033, 1033, 1233], [1235, 1235, 1262, 1262, 1435], [1437, 1437, 1461, 1461, 1774], [1776, 1776, 1833, 1833, 2287]], "test": "untested"}
{"id": "flSyzm", "name": "Things and colors.", "author": "fyisic123", "description": "Trying to throw random math at the screen in hope i  might learn something :)\n", "tags": ["grid", "colors", "orbit", "psy", "atoms"], "likes": 6, "viewed": 323, "published": 3, "date": "1649341771", "time_retrieved": "2024-07-30T16:55:02.251995", "image_code": "#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\n#define RIPPLE_COUNT 5.\n#define TILE_COUNT 5.\n\n    \n    mat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r)\n{\n\tvec2 g = B - A;\n    float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getWaves(vec2 uv, float size, float speed)\n{\n    float l = length(uv);\n    return abs(sin(l * 100. + speed)) * smoothstep(size, 0.,l) * (0.5 + (0.5 *  (smoothstep(0.2*size, 0.0*size, abs(length(uv) - (size   * abs(sin(iTime))))))));\n}\n\n\nvec2 getOrbitPos(float v, float dist)\n{\n    return vec2(cos(v), sin(v)) * dist;\n}\nfloat getRings(vec2 uv, float r)\n{\n    float Speed = iTime * .2;\n    float P = 0.;\n    for(float i=0.; i <= RIPPLE_COUNT; i++)\n    {\n        float per = i / RIPPLE_COUNT;\n        float stage = fract(per + Speed);\n        float radius = r * stage;\n        \n        P += smoothstep(0.015,0., abs(length(uv)-radius)) * pow((1. - stage),3.5) * .5;\n    }\n    return P;\n}\nfloat getBall(vec2 uv, float scale, float orbitSpeed)\n{\n    \n    float P = smoothstep(0.1*scale, 0.01 * scale, abs(length(uv)-scale));    \n    float orbitScale =  scale  * .5;    \n    for(float i=0.; i <= 1.; i++)    \n        P += smoothstep(orbitScale, -0.6 * scale, length(uv - getOrbitPos(orbitSpeed + radians(180. * i), scale))) * 2.;        \n    orbitScale *= .5;    \n       \n    return P;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime;\n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) /iResolution.y;        \n    uv *= Rot(dot(uv.x, uv.y) + T );\n    uv += vec2(sin(T * 0.1), 0);\n    uv *= TILE_COUNT + (TILE_COUNT * 0.1 * sin(T * 0.5));        \n    \n    vec2 gv = fract(uv) - .5;    \n    vec2 ID = floor(uv);          \n    vec3 col = vec3(0);                \n    float BG1 = pow(mod(fract(abs(gv.x) + T), abs(gv.y)), 1.8);\n    float BG2 = pow(abs(dot(sin(uv.x * 1.), cos(gv.y * 6.) * length(uv) * .075) ), 1.7);\n    float BG = mix(BG1, BG2, abs(sin(T * .2)));\n    float BGHue = pow(BG, .5) + (T * .1);\n    vec3 bgCol = hue(BGHue) * BG;  \n    col = mix(vec3(BG), bgCol, 0.6);  //  Desaturate        \n    float lines = 0.;\n    float orbitSpeed = T * 5.;\n    float P = 0.;\n    vec3 ballCol = vec3(0);\n    float w = 0.;\n    float waveSpeed = T *  34.;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 offs = vec2(x,y);\n            vec2 oID = ID + offs;\n            float nID = hash12(oID); \n            \n            vec2 pos = gv -offs;\n            float Size = (mod(oID.x + oID.y, 2.) == 0.) ? .2 : 0.075;\n            float orbSpeed = (mod(floor(nID * 10000.), 2.) == 0.) ? orbitSpeed : -orbitSpeed;\n    \n            float nP = getBall(pos, Size, orbSpeed);\n            \n            ballCol += hue(nID) * nP;\n            P += nP;            \n            w += getWaves(pos, Size, waveSpeed);                                   \n            ballCol += hue(nID + 0.1) * getRings(pos, Size * 4.5);\n            lines += line(gv + 1., pos + 1.5  , vec2(1.), 0.03);\n\n            \n            \n        }\n    }\n    \n    col = mix(col , hue(BGHue + .001), lines * .1);\n    col = mix(col, vec3(1.), min(1. , max(0. , P- 1.)) );\n    col += ballCol;\n    col += (hue(length(gv)) * w);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSyzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 175, 175, 237], [239, 239, 284, 284, 395], [397, 397, 419, 419, 538], [540, 540, 590, 590, 780], [783, 783, 822, 822, 864], [865, 865, 899, 899, 1230], [1231, 1231, 1286, 1286, 1627], [1629, 1629, 1686, 1686, 3538]], "test": "untested"}
{"id": "flSczm", "name": "Spiral 190489", "author": "SnoopethDuckDuck", "description": "Just testing different effects", "tags": ["e"], "likes": 5, "viewed": 220, "published": 3, "date": "1649339431", "time_retrieved": "2024-07-30T16:55:03.081776", "image_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float sc = iResolution.y / 3.;\n    \n    float v = abs(fract(sc * (uv.x + uv.y))-0.5) \n            + abs(fract(sc * (uv.x - uv.y))-0.5);\n   \n    vec3 e = vec3(0.5);\n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    \n    float val = exp(-0.5 * thc(4., a + 4. * log(r)) * cos(4. * log(r) + iTime));\n    float hatch = 0.2 * h21(vec2(v,0.01 * floor(7. * iTime)));\n    \n    vec3 col = pal(0.12 + hatch + v + val, e, e, e, 0.5 * vec3(0,1,2)/3.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 127, 127, 170], [172, 172, 191, 191, 266], [268, 268, 325, 325, 889]], "test": "untested"}
{"id": "flByzm", "name": "Pyramid and glowing 3D ", "author": "electralite", "description": "Pyramid with glooing alinmation", "tags": ["glow", "pyramid"], "likes": 8, "viewed": 239, "published": 3, "date": "1649336846", "time_retrieved": "2024-07-30T16:55:03.893606", "image_code": "//SOURCES :\n//Pyramid base : https://www.shadertoy.com/view/3lcGWn\n//Daugnut Tutorial base : https://www.shadertoy.com/view/7stGWj\n\nconst float PI = 3.14159265;\nconst int MAX_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 1e-6;\n\n\n//----------------------------- Pyramid ------------------------------\n//fonction barry crée les \"faces\" triangles multicolores + gamma\nvec3 bary(vec3 a, vec3 b, vec3 c, vec2 p) {\n    vec2 v0 = b.xy - a.xy, v1 = c.xy - a.xy, v2 = p - a.xy;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    vec3 bc = abs(vec3(u,v,w));\n    return bc * clamp(1.1 - floor(bc.x + bc.y + bc.z - 0.0001), 0.0, 1.0);\n}\n\n\n\n//----------------------------- Daugnut & glow ------------------------------\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, EPSILON), intensity);\t\n}\n\n//----------------------------- Camera ------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, float yAddition, float size) {\n    vec2 xy = (fragCoord - iResolution.xy / 2.0);\n    xy.y = xy.y + yAddition;\n    float z = (size * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n    vec3 zaxis = normalize(targetDir);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    return mat3(xaxis, yaxis, -zaxis);\n}\n\n\n//-------------------------- SDF and scene ---------------------------\n//Donut rotation fonction\nvec3 rotate(vec3 p, vec4 q){\n  return (2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p + 1.0-abs(cos(iTime)/2.0));\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat torusSDF( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat getSDF(vec3 position) {\n\t//rotation avec iTime | set l'angle du donut pour le faire \"tourner\" - ca change l'angle du cercle de base sur leques les glow sont posés\n   \tfloat angle = iTime;\n    vec3 axis = normalize(vec3(1.0, 1.0, 1.0));\n    position = rotate(position, vec4(axis * sin(-angle*0.5), cos(-angle*0.5))); \n    return torusSDF(position, vec2(0.4, 0.1));\n\n}\n\n\n//---------------------------- Raymarching ----------------------------\n\n// Glow variable is passed in by reference using the keyword inout. The result written in this\n// function can be read afterwards from where it was called.\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, inout float glow, int steps, float glowIntensity) {\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = 0; i < steps; i++) {\n        \n        // Get the SDF value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir);\n        \n        // Calculate the glow at the current distance using the distance based glow function\n        // Accumulate this value over the whole view ray\n        // The smaller the step size, the smoother the final result\n        glow += getGlow(dist, 1e-3, glowIntensity);\n        \n        // If the distance is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if(dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += dist;\n        \n        // Test if we have left the scene\n        if(depth >= end){\n            return end;\n        }\n    }\n    \n    // Return max value if we hit nothing but remain in the scene after max steps\n    return end;\n}\n\n\n//----------------------- Tonemapping and render ------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(60.0, fragCoord, 50.0, 0.5);\n    vec3 rayDir2 = rayDirection(60.0, fragCoord, 15.0, 2.5);\n    \n    //----------------- Define a camera -----------------\n\n    vec3 cameraPos = vec3(2.0);\n    \n    vec3 target = -normalize(cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, target, up);\n    \n    //---------------------------------------------------\n\n    // Transform the ray to point in the correct direction\n    rayDir = viewMatrix * rayDir;\n    rayDir2 = viewMatrix * rayDir2;\n\n    // Initialize glow to 0\n    float glow = 0.00;\n    \n    // Find the distance to where the ray stops, pass in the glow variable to be accumulated\n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, glow, 64, 0.555);\n    float dist2 = distanceToScene(cameraPos, rayDir2, MIN_DIST, MAX_DIST, glow, 2, 1.0);\n    \n    // Dist can now be used to render surfaces in the scene. We will only render the glow\n  \n    vec3 glowColour = vec3(0.9, 0.1, 0.2);\n    \n    // Glow now holds the value from the ray marching\n    vec3 col = glow * glowColour;\n\n    // Tonemapping\n    col = ACESFilm(col);\n\n    // Gamma\n    col = pow(col, vec3(0.4545));\n        \n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //auto rotate pyramid with sin to right/left mouvment\n    float rotateX = 3.5 * cos(iTime/2.0) - iResolution.x;\n    \n    //Define pyramid points, moving with the obj.x val\n    vec3 p1 = vec3(0.5 + sin(rotateX)       *0.25, 0.2 + cos(rotateX+PI)    *0.1, 0.5 + sin(rotateX));\n    vec3 p3 = vec3(0.5 + sin(rotateX+PI)    *0.25, 0.2 + cos(rotateX)       *0.1, 0.5 + sin(rotateX+PI));\n    vec3 p2 = vec3(0.5 + sin(rotateX+PI/2.0)*0.25, 0.2 + cos(rotateX-0.5*PI)*0.1, 0.5 + sin(rotateX+PI/2.0)*0.2);\n    vec3 p4 = vec3(0.5 + sin(rotateX-PI/2.0)*0.25, 0.2 + cos(rotateX+0.5*PI)*0.1, 0.5 + sin(rotateX-PI/2.0)*0.2);\n    vec3 p5 = vec3(0.5 , 0.8+abs((sin(iTime)/8.0)), 0.0);\n\n    //creating \"faces\" with color & gamma betweeb*n points\n    vec3 bc1 = bary(p1, p2, p5, uv);\n    vec3 bc2 = bary(p2, p3, p5, uv);\n    vec3 bc3 = bary(p3, p4, p5, uv);\n    vec3 bc4 = bary(p4, p1, p5, uv);\n    //bc5 & bc6 makes the base with 2 triangles\n    vec3 bc5 = bary(p1, p2, p3, uv);\n    vec3 bc6 = bary(p1, p4, p3, uv);\n    \n    //adding everything in fragColor to implement this into shadertoy\n\tfragColor = vec4(bc1 + bc2 + bc3 + bc4 + bc5 + bc6 + col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flByzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 412, 455, 455, 818], [901, 941, 998, 998, 1054], [1127, 1127, 1210, 1210, 1399], [1401, 1490, 1540, 1540, 1709], [1712, 1809, 1837, 1837, 1927], [1929, 1977, 2010, 2010, 2080], [2082, 2082, 2111, 2251, 2455], [2531, 2687, 2813, 2890, 4095], [4173, 4251, 4273, 4273, 4361], [4363, 4363, 4419, 4497, 6964]], "test": "untested"}
{"id": "NlByRw", "name": "07 Camera", "author": "ccc9527", "description": "Camera,3D", "tags": ["3d", "camera"], "likes": 0, "viewed": 191, "published": 3, "date": "1649323679", "time_retrieved": "2024-07-30T16:55:04.803174", "image_code": "struct Ray   //射线结构体\n{\n    vec3 origin;//射线原点origin\n    vec3 direction;//射线方向direction\n};\n//设置摄像机的三个基向量并返回射线\nRay GetRay(vec2 uv,vec3 camPos,vec3 lookat,float zoom)\n{\n    Ray ray;\n    ray.origin = camPos;\n    //摄像机的三个基向量\n    vec3 forward = normalize(lookat-camPos);\n    vec3 right = cross(vec3(0.0,1.0,0.0),forward);\n    vec3 up = cross(forward,right);\n    \n    vec3 center = ray.origin+forward*zoom;\n    vec3 i = center+right*uv.x+up*uv.y;\n    ray.direction = normalize(i-ray.origin);\n    \n    return ray;\n}\n//获得点p到射线ray上最近的点,通过射线原点加上射线方向乘以(p-ro和rd的点乘)\n//点乘表示中的rd是归一化的所以点乘结果就是点p在rd方向上的投影长度\nvec3 GetClosestPoint(Ray ray,vec3 p)\n{\n    return ray.origin+max(0.0,dot(p-ray.origin,ray.direction))*ray.direction;\n}\n//求最近到到p的距离\nfloat GetDistance(Ray ray,vec3 p)\n{\n    return length(p-GetClosestPoint(ray,p));\n}\n//绘制背景虚化效果\nfloat Bokeh(Ray ray,vec3 p,float size,float blur)\n{\n    float d = GetDistance(ray,p);\n    float c = smoothstep(size,size-blur*size,d);\n    c *= mix(0.6,1.0,smoothstep(0.8*size,size,d));\n    \n    return c;\n}\n//获取一个伪随机的(0,1)的数\nfloat Noise(float t)\n{\n    return fract(sin(t*564.0)*3389.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //虚拟摄像机\n    vec3 camPos = vec3(0.0,0.0,0.0);\n    vec3 lookat = vec3(0.0,0.0,1.0);\n    float zoom = 2.0;\n    Ray ray = GetRay(uv,camPos,lookat,zoom);\n    \n    float z = 50.0-fract(iTime/2.0)*50.0;\n    vec3 p0 = vec3(1.0,1.0,1.2*z);//中间\n    \n    float d = Bokeh(ray,p0,0.3,0.1);\n    float i = Noise(floor(iTime/2.0));\n    for(;i<20.0;i+=1.0)\n    {\n        vec3 offset = vec3(Noise(i)*2.0-1.0,Noise(i+0.5)*2.0-1.0,0.0);\n        vec3 p = p0-offset*10.0;\n        p.z *= i/10.0;\n        d += Bokeh(ray,p,0.3,0.1);\n    }\n    \n    vec3 col = vec3(1.0,0.7,0.3)*d;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlByRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 167, 223, 223, 583], [584, 782, 820, 820, 900], [901, 929, 964, 964, 1011], [1012, 1039, 1090, 1090, 1245], [1246, 1284, 1306, 1306, 1347], [1349, 1349, 1406, 1406, 2082]], "test": "untested"}
{"id": "ftjczD", "name": "Pyramid Spin", "author": "jorge2017a2", "description": "Pyramid Spin", "tags": ["pyramidspin"], "likes": 3, "viewed": 197, "published": 3, "date": "1649296594", "time_retrieved": "2024-07-30T16:55:05.653899", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n//Pyramid Spin--6-abril-2022\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec2 CubosBx(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0); \n    vec3 p0=p;\n    float py=2.0;\n    p= rotate_z(p-vec3(-8.5,py,0.0),radians(45.0));\n    float d3a= sdBox( p-vec3(0.0,0.0,0.0),   vec3(5.0,0.5,5.0) );\n    p=p0;\n    p= rotate_z(p-vec3(8.5,py,0.0),radians(-45.0));\n    float d3b= sdBox( p-vec3(0.0,0.0,0.0),   vec3(5.0,0.5,5.0) );\n    p=p0;\n    p= rotate_x(p-vec3(8.5,py,0.0),radians(-45.0));\n    float d3c= sdBox( p-vec3(-8.0,-6.0,-6.0),vec3(5.0,0.5,5.0) );\n    p=p0;\n    p= rotate_x(p-vec3(8.5,py,0.0),radians(45.0));\n    float d3d= sdBox( p-vec3(-8.0,-6.0, 6.0),vec3(5.0,0.5,5.0) );\n    \n    res =opU2(res, vec2(d3a,100.0));\n    res =opU2(res, vec2(d3b,100.0));\n    res =opU2(res, vec2(d3c,100.0));\n    res =opU2(res, vec2(d3d,100.0));\n    return res;\n}\n\nvec2 PiramideBase(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0); \n    float d1a=sdTriangleIsosceles( vec2(p.x,-p.y)-vec2(0.0,-26.0), vec2(5.0,30));\n    float d1b=sdTriangleIsosceles( vec2(p.z,-p.y)-vec2(0.0,-26.0), vec2(5.0,30));\n    float d2=sdBox( p-vec3(0.0,10.0,0.0), vec3(10.0,22.0,10.0) );\n    float d1=  Intersect(d1a, d2);\n    d1=  Intersect(d1, d1b);\n    res =opU2(res, vec2(d1,100.0));\n   return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); \n    //p= rotate_y(p,radians(iTime*10.0));\n    vec3 p0=p;\n    float small=0.045;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,101.0));\n    p.y=p.y-5.0;\n    vec2 p1= PiramideBase(p-vec3(-20.0,0.0,0.0));\n    //p1-= small*texture(iChannel0,p.xy).r;\n    //float h= tex3D(iChannel1, p/16., vec3(0.0,1.0,0.0)).r;\n    //p1-=small*h;\n    vec2 p2= PiramideBase(p);\n    vec2 p3= PiramideBase(p-vec3(20.0,0.0,0.0));\n    res =opU2(res, p1);\n    res =opU2(res, p2);\n    res =opU2(res, p3);\n    \n    vec2 res2=CubosBx(p);\n    res =opU2(res, res2);\n\n    vec2 res4=CubosBx(p-vec3(0.0,10.0,0.0));\n    res =opU2(res, res4);\n    \n    res.x +=  small*texture(iChannel0,p.xy).r; \n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos=p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { \n    //float h= tex3D(iChannel1, p/16., vec3(0.0,1.0,0.0)).r;\n    ///vec3 col=tex3D(iChannel0, p/16.+h, nor); return col*2.0; \n    vec3 col=tex3D(iChannel0, p/16., nor); return col*2.0; \n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor)+0.2; }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     //if (id_color<50) { colobj=getColor(int( id_color));  return colobj; }\n   if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));        \n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=28.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,35.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,8.0+6.0*sin(t),-35.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   Ray rt=RotarEnCirculo(ro,rd);\n   ro=rt.ro;\n   rd=rt.rd;\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 523, 523, 607], [608, 608, 652, 652, 679], [680, 680, 720, 720, 747], [748, 748, 793, 793, 821], [823, 823, 859, 859, 904], [906, 906, 940, 940, 1036], [1037, 1037, 1071, 1071, 1162], [1163, 1163, 1197, 1197, 1288], [1289, 1289, 1323, 1323, 1414], [1417, 1417, 1468, 1468, 1774], [1776, 1776, 1798, 1798, 2536], [2538, 2538, 2565, 2565, 2945], [2947, 2947, 2972, 2972, 3715], [3717, 3717, 3741, 3741, 3903], [3905, 3905, 3953, 3953, 4232], [4234, 4234, 4278, 4278, 4599], [4601, 4601, 4638, 4638, 4895], [4897, 4897, 4987, 4987, 5945], [5947, 5947, 5996, 5996, 6269], [6271, 6271, 6303, 6303, 6500], [6503, 6503, 6573, 6573, 6737], [6739, 6739, 6766, 6766, 6855], [6857, 6857, 6915, 6915, 6963], [6965, 6965, 6988, 6988, 7100], [7102, 7102, 7133, 7133, 7772], [7774, 7774, 7811, 7811, 8081], [8084, 8084, 8141, 8141, 8643]], "test": "untested"}
{"id": "ft2yRD", "name": "strange smoke", "author": "xenn", "description": "kinda interesting", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 10, "viewed": 312, "published": 3, "date": "1649282833", "time_retrieved": "2024-07-30T16:55:06.585408", "image_code": "// Fork of a fork of a fork of a fork of a fork of a fork of a fork of a fork of a \n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 0.0 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                //      col = min(col,color);\n                      color = min(col2,col);\n               //       col2 = mix(col,color,0.5);\n             //        col2 = min(col,color);\n                      \n                       \n //     color = mix(col,color,col2);\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (mix(col,color,col2)))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = -.001;\nconst float iFeedbackFadeRate         = .998;\nconst float iFeedbackColorShiftZoom   = .005;\nconst float iFeedbackColorShiftImpact = -0.0001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .025;\nconst float iBlobEdgeSmoothing        = .01;\nconst float iBlob1Radius              = .75;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .024;\nconst float iBlob2Radius              = .65;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .01234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = 0.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb,repeatedTexture(iChannel1, uv - stShift).rgb);\n     vec3 prevColor2 = repeatedTexture(iChannel2, uv - stShift).rgb+repeatedTexture(iChannel3, uv - stShift).rgb * repeatedTexture(iChannel1, uv - stShift).rgb/512.;\n    prevColor +=prevColor2/512.;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n#define iTime iTime / 1.0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 7\n#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  col = max(col,col2);\n//  col2= min(col,col2);\n  vec4 blend = mix(col,col2,col3);\n // blend = (blend*0.5)* ((max(col,blend))*0.5)+ ((min(col,blend))*0.5);\n  blend = clamp(blend, 0., 1.);\n  fragColor=blend,(fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .996;\nconst float iFeedbackColorShiftZoom   = .005;\nconst float iFeedbackColorShiftImpact = 0.0001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .1;\nconst float iBlobEdgeSmoothing        = .1;\nconst float iBlob1Radius              = .85;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = -.04;\nconst float iBlob2Radius              = .78;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .1234;\nconst float iBlob2ColorPulseShift     = 0.0;\nconst float iColorShiftOfRadius       = 0.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb,repeatedTexture(iChannel1, uv - stShift).rgb);\n     vec3 prevColor2 = repeatedTexture(iChannel2, uv - stShift).rgb+repeatedTexture(iChannel3, uv - stShift).rgb * repeatedTexture(iChannel1, uv - stShift).rgb/512.;\n    prevColor +=prevColor2/512.;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 7\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  col = max(col,col2);\n//  col2= min(col,col2);\n  vec4 blend = mix(col,col2,col3);\n // blend = (blend*0.5)* ((max(col,blend))*0.5)+ ((min(col,blend))*0.5);\n  blend = clamp(blend, 0., 1.);\n  fragColor=blend,(fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n  //  fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2yRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 176, 176, 255], [257, 257, 280, 280, 420], [422, 422, 479, 479, 1834]], "test": "untested"}
{"id": "NtjyRD", "name": "Basic Mandelbrot set", "author": "10maurycy10", "description": "A simple mandelbrot set renderer", "tags": ["fractalmandelbrotzoom"], "likes": 2, "viewed": 178, "published": 3, "date": "1649281071", "time_retrieved": "2024-07-30T16:55:07.335403", "image_code": "#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n\n#define ZOOM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    \n    #ifdef ZOOM\n    uv = uv / pow(2.0,mod(iTime*1.0,20.0));\n    \n    #endif\n    \n    vec2 c = uv*1.5 + vec2(-0.06,0.6514);\n    \n    \n    \n    vec2 x = c;\n    \n    for (int i = 0; i < 100; i++) {\n        x = cx_mul(x,x) + c;\n        if (abs(x.x) + abs(x.y) > 2.0) {\n            fragColor = vec4(i/10,i/100,1,  1.0);\n            return;\n        }\n    }\n    fragColor = vec4(0.0,0.0,0.0,  1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 132, 182, 633]], "test": "untested"}
{"id": "NlSyz1", "name": "Rainbow Band Man SDF", "author": "ufffd", "description": "rainbow band man + signed distance fields v1.1b", "tags": ["sdf", "animated", "distance", "field", "signeddistancefield", "signed", "encode", "encoder"], "likes": 0, "viewed": 101, "published": 3, "date": "1649279372", "time_retrieved": "2024-07-30T16:55:08.078417", "image_code": "// A very simplistic approach at rendering 2-dimensional signed distance fields.\n// It is iterative and at most has a O(width > height ? width : height) runtime.\n// Can be used to create outlines, shadows, glow and other things.\n\n// Buffers:\n// A - Shape Input\n// B - Shape Postprocessing\n// C - Signed Distance Field Generator\n// D - Signed Distance Field Postprocessing\n// Image - Final Render\n\nconst vec3 glowOuterColor = vec3(1., 1., 1.);\nconst float glowOuterRadius = 100.0;\n\n// #define DEBUG\nconst float debugRange = 256.0;\n\nfloat drawBar(in float x, in float x0, in float r){\n    float px = 1./iResolution.y;\n    // px*=2.;\n    return smoothstep(.0, px , abs(x-x0)-r/2. );\n}\nfloat drawBar(in float x, in float x0){\n    return drawBar(x,x0,0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    #ifdef DEBUG\n    fragColor = abs(texture(iChannel0, uv).rgba / debugRange);\n    return;\n    #endif\n    \n    float v = texture(iChannel0, uv).r;\n    fragColor.rgb = vec3(0.5, 0.5, 0.5);\n    \n    vec4 bufA = texture(iChannel3, uv);\n    if (bufA.a > 0.0) {\n        fragColor.rgb = bufA.rgb;\n    }\n    \n    float g = v / glowOuterRadius;\n    g = clamp(g, 0., 1.);\n    if (g > 0.)\n        fragColor.rgb = mix(glowOuterColor, fragColor.rgb, g);\n        \n        \n    // Normalized pixel coordinates (from 0 to 1)\n    uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.333;\n    vec3 col = vec3(0.);\n    float b = v/200.;\n    bool inside=false;\n    if (b<0.)inside=true;\n    \n    float draw=1.;\n    float drawcol = 0.;\n    float movespeed = -0.05*SPEED;\n    for (float i=0.0;i<1.;i+=0.1){\n        draw *= drawBar(i,b);\n    }\n    b += mod(iTime*movespeed,0.1);\n    draw = smoothstep(0.0,0.02*length(uv),nsin((b)*20.*PI-0.5*PI));\n    col = vec3(draw);\n    vec3 neon = 1.-col;\n    \n    float grad = 1.-mod(b,0.1)*10.;\n    float timestep = floor(-iTime*10.*SPEED);\n    float band = floor(b*10.+timestep)*0.13;\n    // col += band;\n    col *= hsv2rgb_smooth(vec3(band,1.,1.));\n    // col += grad*0.3;\n    // col /= .8+grad;\n    // col *= 1.2-grad;\n    // col = vec3(grad*grad+(1.-grad));\n    \n    // deboog\n    // if (uv.x<sin(iTime*0.33)) col = vec3(b);\n    \n    if (BUZZ) {\n        col *= 0.3;\n        col -= grad*grad * (1.-grad) * 3.;\n        neon *= hsv2rgb_smooth(vec3(band,1.,1.));\n        neon *= neon;\n        col += neon*5.;\n        float filament;\n        for (int i=1;i<3;i++){\n            filament = smoothstep(0.0,0.003*length(uv),nsin((b)*20.*PI-0.5*PI));\n            col += vec3(1.-filament)*float(i)/2.;\n            b += (noise(vec3(float(i)+uv*20.*float(i+1),iTime))*0.02-0.01) * (0.2+length(uv));\n        }\n    }\n    \n    if (inside) col*=0.;\n    if (inside) col=texture(iChannel3,fragCoord/iResolution.xy).rgb;\n    \n    if (!inside) col *= nclamp(iTime*0.25);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define INPUT_VIDEO\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    // greenscreen\n    vec4 pickcol = vec4(0.051,0.639,0.145,1.);\n    float dist = distance(col, pickcol) * 2.;\n    const float distMin = 0.3;\n    const float distRange = 0.1;\n    dist -= distMin;\n    dist /= distRange;\n    dist = clamp(dist, 0., 1.);\n    col.rgb -= 1.0 - dist;\n\n    fragColor.rgb = col.rgb;\n    fragColor.a = (dist > 0.1 ? 1.0 : 0.0);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Improved iterative Signed Distance Field encoder based on V1:\n//  https://www.shadertoy.com/view/XlfBDl\n//\n// It's a really simple approach at doing this and most likely\n//  can be done much faster by splitting horizontal and vertical\n//  passes and by using loops for testing for distances. There is\n//  also a UV channel stored within the blue and alpha of the\n//  result, allowing higher precision if necessary.\n//\n// Output definition:\n// .r  = Positive Distance\n// .g  = Negative Distance\n// .ba = UV of nearest edge\n\n// Parameters\nconst float threshold = 0.1;\n\n#define POSSIBLY_INFINITE 18446744073709551616.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame == 0) {\n        fragColor = vec4(POSSIBLY_INFINITE);\n        return;\n    }\n    \n    vec2 uvStep = 1.0 / iResolution.xy;\n    vec3 uvStep0 = vec3(uvStep.x, uvStep.y, 0.);\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    bool inside = false;\n    \n    // Test if we are in- or outside of the shape.\n    float alpha = texture(iChannel1, uv).a;\n    if (alpha > threshold) {\n        inside = true;\n        fragColor.r = 0.0;\n        fragColor.ba = uv;\n    } else {\n        inside = false;\n        fragColor.g = 0.0;\n        fragColor.ba = uv;\n    }\n    \n    if (inside) { // Negative Values\n        vec3 test = vec3(POSSIBLY_INFINITE, POSSIBLY_INFINITE, POSSIBLY_INFINITE);\n        vec3 iU, iD, iL, iR;\n        iU = texture(iChannel0, uv - uvStep0.zy).gba;\n        iD = texture(iChannel0, uv + uvStep0.zy).gba;\n        iL = texture(iChannel0, uv - uvStep0.xz).gba;\n        iR = texture(iChannel0, uv + uvStep0.xz).gba;        \n    \tif (iU.r < test.r) { test = iU; }\n    \tif (iD.r < test.r) { test = iD; }\n    \tif (iL.r < test.r) { test = iL; }\n    \tif (iR.r < test.r) { test = iR; }\n        \n        vec3 m = vec3(0.4142135623730950488016887242097, 0, 0);\n        iU = texture(iChannel0, uv - uvStep0.xy).gba;\n        iD = texture(iChannel0, uv - vec2(-uvStep0.x, uvStep0.y)).gba;\n        iL = texture(iChannel0, uv + uvStep0.xy).gba;\n        iR = texture(iChannel0, uv + vec2(uvStep0.x, -uvStep0.y)).gba;\n    \tif (iU.r < test.r) { test = iU + m; }\n    \tif (iD.r < test.r) { test = iD + m; }\n    \tif (iL.r < test.r) { test = iL + m; }\n    \tif (iR.r < test.r) { test = iR + m; }\n        \n        if (test.r < POSSIBLY_INFINITE) {\n            fragColor.g = test.r + 1.;//distance(fragCoord, test.gb / uvStep) + 0.5;\n            fragColor.ba = test.gb;\n        }\n    } else { // Positive Values\n        vec3 test = vec3(POSSIBLY_INFINITE, POSSIBLY_INFINITE, POSSIBLY_INFINITE);\n        vec3 iU, iD, iL, iR;\n        iU = texture(iChannel0, uv - uvStep0.zy).rba;\n        iD = texture(iChannel0, uv + uvStep0.zy).rba;\n        iL = texture(iChannel0, uv - uvStep0.xz).rba;\n        iR = texture(iChannel0, uv + uvStep0.xz).rba;\n        \n    \tif (iU.r < test.r) { test = iU; }\n    \tif (iD.r < test.r) { test = iD; }\n    \tif (iL.r < test.r) { test = iL; }\n    \tif (iR.r < test.r) { test = iR; }\n        \n        vec3 m = vec3(0.4142135623730950488016887242097, 0, 0);\n        iU = texture(iChannel0, uv - uvStep0.xy).rba;\n        iD = texture(iChannel0, uv - vec2(-uvStep0.x, uvStep0.y)).rba;\n        iL = texture(iChannel0, uv + uvStep0.xy).rba;\n        iR = texture(iChannel0, uv + vec2(uvStep0.x, -uvStep0.y)).rba;\n    \tif (iU.r < test.r) { test = iU + m; }\n    \tif (iD.r < test.r) { test = iD + m; }\n    \tif (iL.r < test.r) { test = iL + m; }\n    \tif (iR.r < test.r) { test = iR + m; }\n        \n        if (test.r < POSSIBLY_INFINITE) {\n            fragColor.r = test.r + 1.;//distance(fragCoord, test.gb / uvStep) + 0.5;\n            fragColor.ba = test.gb;\n        }\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.r - col.g);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BUZZ false\n#define PI 3.14159265359\n#define SPEED 0.5\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat nsin(in float x){\n    return sin(x)*0.5+0.5;\n}\n\nfloat nclamp(in float x){\n    return clamp(0.,1.,x);\n}\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[531, 531, 582, 582, 681], [682, 682, 721, 721, 754], [756, 756, 813, 813, 2900]], "test": "untested"}
{"id": "7tBczW", "name": "Colourful atoms. (Voronoi)", "author": "fyisic123", "description": "I am obviously a beginner, but i am thankful if you point out things i could have done differently , i am sure there is a ton that can be optimized :)\n\nMostly made this after following BigWIngs tutorials (Art of code on youtube).", "tags": ["voronoi", "hue", "atom", "atoms"], "likes": 8, "viewed": 369, "published": 3, "date": "1649262062", "time_retrieved": "2024-07-30T16:55:08.826416", "image_code": "#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n#define PI 3.14159265359\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat getBall(vec2 p, float size, float Pulse)\n{\n    float c = smoothstep(size * 0.2, 0. , length(p)) ; // inner\n    c += smoothstep(size, 0. , length(p)) * Pulse;\n    c += pow(smoothstep(size,  0. , length(p)), 3.);\n    c += smoothstep(0.1 * size, 0.0 * size , abs(length(p)-(size))) ; // Ring\n    return c;\n}\n\nvec2 getCosSin(float p)\n{\n    return vec2(cos(p), sin(p));\n    \n}\n\nvec2 getOrbitOffset(float orbSpeed, float orbPhase, float dist)\n{\n    float o = orbSpeed + orbPhase;\n    return vec2(cos(o), sin(o)) * dist; \n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy)/iResolution.y;\n    float uvDist = length(uv);\n    uv *= pow(length(uv), -0.2);\n    uv *= 4. + (1.25 * sin(iTime * 0.5));\n    uv *= Rot(iTime*0.4);\n    uv += vec2(iTime*0.75,0.0);\n    vec2 gv = fract(uv) -.5;\n    vec2 ID = floor(uv);\n        \n    vec3 col = vec3(0);            \n    \n            \n    float nDist = 333.;\n    \n    for(int x=-1; x <= 1; x++)\n    {\n        for(int y=-1; y <= 1; y++)\n        {\n            vec2 offs = vec2(x,y);\n            vec2 cID = hash22(ID + offs);\n            float nID = cID.x + cID.y * 0.5;\n            float nVariant = nID * 10000.;\n            float erratic = abs(sin(iTime * 0.25 + nVariant));\n            float movSpeed = iTime + (PI *erratic);\n            vec2 mov = getCosSin(nVariant + movSpeed);\n            vec2 pos = gv - offs -  mov * .5;\n            \n\n            float orbitPhase =  100. * (nID);\n            \n                \n            float orbitSpeed = iTime * 3.0;\n            if (nID > 0.5)\n                orbitSpeed *= -1.;\n            vec3 h = hue(cID.x + cID.y);\n            float erraticScale = 0.1 + (0.9 * erratic);\n            float orbitScale = 0.1 * erraticScale;\n            \n            \n\n            float p = 0.;\n            float orbitDist = 0.2 * erraticScale;\n            p += getBall(pos + getOrbitOffset(orbitSpeed, orbitPhase, orbitDist), orbitScale, 0.);                                    \n            p += getBall(pos + getOrbitOffset(orbitSpeed, orbitPhase + radians(180.), orbitDist), orbitScale, 0.);                                    \n            p += getBall(pos + getOrbitOffset(-orbitSpeed, orbitPhase, 0.2*erraticScale), orbitScale,0.);                                    \n            p += getBall(pos + getOrbitOffset(-orbitSpeed, orbitPhase + radians(180.), orbitDist), orbitScale,0.);                                                \n            p += getBall(pos + getOrbitOffset(orbitSpeed * 2., orbitPhase + radians(0.), orbitDist), orbitScale*.75, 0.);                                    \n            p += getBall(pos + getOrbitOffset(-orbitSpeed * 2., orbitPhase + radians(180.), orbitDist), orbitScale*.75, 0.);                                    \n            p += getBall(pos + getOrbitOffset(orbitSpeed * 4., orbitPhase + radians(0.), orbitDist), orbitScale*.5, 0.);                                    \n            p += getBall(pos + getOrbitOffset(-orbitSpeed * 4., orbitPhase + radians(180.), orbitDist), orbitScale*.5, 0.);                                    \n            \n            \n            float centerPulse = smoothstep(0.2, 0., length(sin((iTime * (1.0 + (2.0 *nID)) ) + nVariant)));\n            centerPulse += 0.3 * abs(sin(iTime*4.));\n            \n            p += getBall(pos , 0.2 * erraticScale, centerPulse);\n            col += h * p;\n            col = mix(col, vec3(1.), min(max(0., p - 1.), 1.0)) * pow(erraticScale,0.05);\n            \n            float dist = pow(length(pos), erraticScale );\n          \n            if(dist < nDist)\n            {\n                nDist = dist;\n            }\n        }\n    }\n    \n    \n    col += hue(pow(nDist  , 3.)+ (iTime * 0.5)) * pow(nDist, 8.) * 0.25;\n \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 122, 122, 264], [266, 266, 314, 314, 576], [578, 578, 603, 603, 643], [645, 645, 710, 710, 788], [789, 789, 808, 808, 870], [872, 872, 929, 929, 4136]], "test": "untested"}
{"id": "7tSczW", "name": "textureeeee", "author": "zinedine", "description": "voici differentes texture", "tags": ["zinedine"], "likes": 1, "viewed": 419, "published": 3, "date": "1649256256", "time_retrieved": "2024-07-30T16:55:09.566438", "image_code": "// Texturing\n// Zinedine Zidane\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct V {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct T {\nvec3 c;\nfloat s;\n};\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nV Sphere(vec3 p, vec3 c,float r,int index)\n{\n  return V(length(p-c)-r,index);\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nV Cube(vec3 p,vec3 c,float r,int index)\n{\n   vec3 q = abs(p-c) - vec3(r);\n  return V(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nV Plane(vec3 p, vec3 n, vec3 o,int index)\n{\n    return V(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nV Union(V a,V b)\n{\n    if (a.v<b.v)\n        return V(a.v,a.i);\n    else \n    {\n        return V(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nV Intersection(V a,V b)\n{\n    if (a.v>b.v)\n    {\n        return V(a.v,a.i);\n    }\n    else \n    {\n        return V(b.v,a.i);\n    }\n}\n\n// Dice \n// p : point\n// c : center \n// r : radius\nV Dice(vec3 p,vec3 c,float r,int index)\n{\n  return Intersection(Cube(p,c,r*0.75,index),Sphere(p,c,r,index));\n}\n\n// Potential field of the object\n// p : point\nV object(vec3 p)\n{\n  V u = Plane(p,normalize(vec3(0.0,0.0,1.0)),vec3(0.0,0.0,-4.0),0);\n  \n  u=Union(u,Dice(p,vec3( 0.0, 0.0, 2.0),4.0,1));\n  u=Union(u,Dice(p,vec3( -10.0, 0.0, 2.0),4.0,2));\n  u=Union(u,Dice(p,vec3( 10.0, 0.0, 2.0),4.0,3));\n \n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  V vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p).v;\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.65,0.75,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Direct lighting\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Phong shading\n  float diff = clamp(dot(n, l),0.0,1.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\n\nfloat Turbulance(in vec3 p, in int i, in float puiss, in float res, in float nb)\n{\n    mat3 M = Rz(0.0);\n    float som = 0.0; \n    for(int k=0; k < i; k++)\n        {\n        res = res * pow(puiss, float(-k));\n        nb = nb * pow(puiss, float(-k));\n        M = matrixCompMult(M, M);\n\n        som = som + res * Noise((M*p)/nb);\n        }\n\n    return som; \n}\n\nvec3 Noise3D(vec3 p)\n{\n \treturn vec3(Noise(p), Noise(p + vec3(165.0,126.0,127.0)), Noise(p + vec3(34.0,242.0,342.0)));\n}\n\nfloat decaler(float d)\n{\n    if(d<0.0){\n    return d = d + -1.0;\n    }\n    else{\n    return d;\n    }\n}\n\nint damier  ( float x , float y , float z ) {\nx= decaler(x);\ny=decaler(y);\nz=decaler(z);\nreturn ( int ( x ) + int ( y ) + int ( z ) ) % 2 ;\n}\n\nT Bois(in vec3 p, in vec3 c1, vec3 c2, float t, int octaves, float contrast)\n{\n  vec3 pt = p - (Turbulance(p, octaves, 2., 4.8, 8.8) * (1. / t));  \n  c1 = mix(contrast*c1, \n           (1.-contrast)*c1,\n           Turbulance(vec3(25.0*pt.x,300.0*pt.y,1.0*pt.z),4, 2., .8, 2.5)*(1.-.7*Noise(200.*pt)));\n  c2 = mix(contrast*c2, \n           (1.-contrast)*c2,\n           Turbulance(vec3(25.0*pt.x,300.0*pt.y,1.0*pt.z),4, 2., .8, 2.5)*(1.-.7*Noise(200.*pt)));\n  float check = ((cos(3.1415927 *sqrt(pt.x*pt.x + pt.y*pt.y))) + 1.) / 2.; // stripes\n  \n  return T((1.-check)*c1+ check*c2, 0.1);\n}\n\nfloat Ligne(vec3 p)\n{\n \tvec3 q=p+1.0*Noise3D(p)+0.5*Noise3D(p/0.5);\n    float z=abs(mod(q.z,0.5)-0.5)*3.0*Noise(p);\n    return smoothstep(z,0.0,0.02);\n}\n\nvec3 Zebre(vec3 p,vec3 c1,vec3 c2)\n{\n    float l=Ligne(p);\n    return mix(c1,c2,l);\n}\n\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\nT marbre(vec3 p,float i)\n{\n    \n    p = p + 1.0*Noise3D(p/1.0);\n    float d = length(p.z);\n    float l = Ligne(p);\n    l = min(l, Ligne(p.zxy));\n  \n  p = lerp(vec3(0.8,0.8,0.8),vec3(1,1,1),l);\n  return T(p,i);\n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\nT Noir(in vec3 p)\n{\n  return T(vec3(0.0,0.0,0.0),1.2);   \n}\n\nT Blanc(in vec3 p)\n{\n  return T(vec3(1.0,1.0,1.0),1.0);   \n}\n\nT Rouge(in vec3 p)\n{\n  return T(vec3(1.0,0.0,0.0),1.0);   \n}\n\nT Vert(in vec3 p)\n{\n  return T(vec3(0.0,1.0,0.0),1.0);   \n}\n\nT Bleu(in vec3 p)\n{\n  return T(vec3(0.0,0.0,1.0),1.0);   \n}\n\nT Damier(in vec3 p)\n{\n    \n    return T(vec3(damier (p.x, p.y, p.z),damier (p.x, p.y, p.z),damier (p.x, p.y, p.z)),0.25); \n}\n\nT Bois(in vec3 p)\n{\n    return Bois(p,vec3(0.49, 0.29, 0.13), vec3(0.49, 0.29, 0.13)*1.7, 0.1,3,0.8);\n}\n\nT Marbre(in vec3 p)\n{\n    return marbre(p,1.0);\n}\n\n\n\n// Compute texture \n// p : Point\n// n : Normal\nT Color(in vec3 p,in vec3 n)\n{\n    V vp= object(p);\n    if (vp.i==0){\n        \n        return Blanc(p);\n    }\n    else if (vp.i==1)\n    {\n        return Marbre(p);\n        //return Marbre(p);\n    }\n    else if (vp.i==2)\n    {\n        return Bois(p);\n    }\n    else if (vp.i==3)\n    {\n        return Damier(p);\n    }\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n    bool h;\n    int s;\n    float t = SphereTrace(p,l,100.0,h,s);\n    if (!h)\n    {\n     return 1.0;\n    }\n    return 0.0; \n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p, vec3 n, vec3 e)\n{\n     // Point light\n    const vec3 lp = vec3(5.0, 10.0, 25.0);\n    \n    // Light direction to point light\n    vec3 l = normalize(lp - p);\n\n    T tex=Color(p,n);\n\n    // Ambient color\n    vec3 ambient = 0.5*tex.c;\n        \n    // Shadow computation\n    float s = Shadow(p+0.01*n,n,l);\n\n// Phong diffuse\n    vec3 diffuse = 0.5  * clamp(dot(n, l),0.0,1.0) * tex.c;\n\n    // Specular\n    vec3 r = reflect(e,n);\n    vec3 specular = tex.s * pow(clamp(dot(r,l),0.0,1.0),28.0) * vec3(1.0,1.0,1.0);\n    vec3 c = ambient + s * (diffuse + specular);\n    return c;\n}\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "// Texturing and noise \n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Camera -----------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(35.0,0.0,15.0);\n    ro*=Rz(3.0*3.14*m.x); \n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 481, 525, 525, 560], [562, 613, 654, 654, 759], [761, 829, 872, 872, 908], [910, 998, 1016, 1016, 1111], [1113, 1218, 1243, 1243, 1350], [1352, 1403, 1444, 1444, 1513], [1515, 1561, 1579, 1579, 1816], [1926, 1966, 1997, 1997, 2240], [2242, 2372, 2437, 2437, 2844], [2846, 2887, 2912, 2912, 2988], [2991, 3010, 3038, 3056, 3316], [3319, 3319, 3401, 3401, 3676], [3678, 3678, 3700, 3700, 3798], [3800, 3800, 3824, 3824, 3902], [4047, 4047, 4125, 4125, 4633], [4635, 4635, 4656, 4656, 4787], [4789, 4789, 4825, 4825, 4874], [4876, 4876, 4930, 4930, 4980], [4982, 4982, 5008, 5008, 5193], [5297, 5297, 5316, 5316, 5356], [5358, 5358, 5378, 5378, 5418], [5420, 5420, 5440, 5440, 5480], [5482, 5482, 5501, 5501, 5541], [5543, 5543, 5562, 5562, 5602], [5604, 5604, 5625, 5625, 5728], [5730, 5730, 5749, 5749, 5833], [5835, 5835, 5856, 5856, 5884], [5888, 5935, 5965, 5965, 6252], [6254, 6317, 6353, 6353, 6478], [6480, 6561, 6597, 6617, 7151], [7469, 7564, 7603, 7628, 8052], [8055, 8064, 8111, 8140, 8841]], "test": "untested"}
{"id": "NlByzW", "name": "Day 8 - Lambmeow", "author": "lambmeow", "description": "15 min shader lets gooooo", "tags": ["numbers", "daily", "eight"], "likes": 3, "viewed": 173, "published": 3, "date": "1649228569", "time_retrieved": "2024-07-30T16:55:10.305462", "image_code": "//Daily Shader Day 8\n//Tried making a shader in 15 ish minutes, while still getting the theme of the number in time\n//Lopea (https://github.com/lopea)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv).r * vec4(.5,.4,.9,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Daily Shader Day 8\n//Tried making a shader in 15 ish minutes, while still getting the theme of the number in time\n//Lopea (https://github.com/lopea)\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 r = iResolution.xy, u = (2. * f - r)/r.y;\n    float s = length(u - vec2(-sin(iTime)*cos(iTime), cos(iTime) *.65)) - .05;\n    c.r = step(s, 0.001) + texture(iChannel0, f/r).r *0.992;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlByzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 151, 208, 208, 311]], "test": "untested"}
{"id": "NtByzW", "name": "Fractal mosaic 3", "author": "jarble", "description": "A variant of my \"Banded mosaic\" pattern with a more interesting color palette.", "tags": ["fractal", "mosaic"], "likes": 3, "viewed": 448, "published": 3, "date": "1649225018", "time_retrieved": "2024-07-30T16:55:11.041494", "image_code": "#define fmod(x,y) mod(floor(x),y)\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 triangle_wave(vec2 a,float num){\n    a = rotate(a,num*radians(180.));\n    return abs(fract((a+c1.xy)*1.5)-.5);\n    //return abs(fract((a+c1.xy+num)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = c1.z;\n    float p1 = 1.;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    float num = 0.;\n    for(int k = 0; k < 12; k++){\n        //uv.x += fmod(uv.x,1.5); //lace pattern\n\n        float num = sign((uv.x+uv.y-.5))/2.;\n        //num += p1/2.;\n\n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        uv += t2-float(k)/3.;\n        //uv += t2-float(k)/(3.-abs(uv.x-uv.y)/8.); //this makes an even crazier pattern\n\n        uv /= scale;\n        //float num = float(k)/3.;\n        t2 = -p1*triangle_wave(uv-p1*.5,num);\n        t3 = p1*triangle_wave(uv.yx,num);\n        \n        //t2 = (1.+t2);\n        //t3 = (1.-t3);\n        \n        uv = t2-t3;\n        //uv = max(t2-t3,t2);\n\n        p1 *= -1.;\n        //p1 *= sign(.5+uv.x);\n        //if(uv.x < uv.y) uv /= 1.5;\n\n        float multiplier = 1.125;\n        col.x = max(uv.y+uv.x-p1*col.x/multiplier,col.x/multiplier);\n        //col.x += (.5-col.x)/4.;\n        col = abs(col.yzx-vec3(1.-col.x/multiplier));\n        //uv.x += .5;\n    }\n    fragColor = vec4(col*1.5,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtByzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 94, 94, 178], [180, 180, 217, 217, 346], [348, 348, 405, 405, 1672]], "test": "untested"}
{"id": "st2yz1", "name": "Color Branches", "author": "wyatt", "description": "something for a friend", "tags": ["yann"], "likes": 28, "viewed": 407, "published": 3, "date": "1649210271", "time_retrieved": "2024-07-30T16:55:11.791489", "image_code": "Main {\n    Q = C(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n", "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec4 q) {\n    if (length(U-q.xy)<length(U-Q.xy))Q=q;\n}\n\nMain {\n    Q = A(U);\n    X(Q,U,A(U+vec2(0,1)));\n    X(Q,U,A(U+vec2(1,0)));\n    X(Q,U,A(U-vec2(0,1)));\n    X(Q,U,A(U-vec2(1,0)));\n    vec2 v = mix(Q.xy,U,.000001);\n    vec4 n = B(v+vec2(0,1));\n    vec4 e = B(v+vec2(1,0));\n    vec4 s = B(v-vec2(0,1));\n    vec4 w = B(v-vec2(1,0));\n    Q.xy -= .3*vec2(e.w-w.w,n.w-s.w);\n    if (iFrame < 1) {\n        U = ceil(U/100.)*100.;\n        Q = vec4(U,U);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    vec4 a = A(U);\n    vec4 b = B(U);\n    vec4 m = vec4(0);\n    for (float x = -2.; x <= 2.; x++)\n    for (float y = -2.; y <= 2.; y++)\n    {\n        m += 1./25.*B(U+vec2(x,y));\n    }\n    Q.x = smoothstep(2.,1.,length(U-a.xy));\n    Q.y = max(Q.x,.99*b.y);\n    Q.z = 0.;\n    Q.w = m.w*.99+Q.y;\n    \n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    vec4 b = B(U);\n    vec4 a = A(U);\n    vec4 c = C(U);\n    Q = b.x*D(a.zw);\n    Q = max(c*.99,Q);\n}", "buffer_c_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2yz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7ljcR1", "name": "contour play", "author": "mds2", "description": "playing around with stuff.  Doesn't work the way I'd like.  Too noisy.", "tags": ["experiment", "effect", "contour"], "likes": 4, "viewed": 425, "published": 3, "date": "1649205715", "time_retrieved": "2024-07-30T16:55:12.630246", "image_code": "vec2 uvFromXy(in vec2 xy) {\n  return xy/iResolution.xy;\n}\n\nfloat getVal(in vec2 xy) {\n  return dot(texture(iChannel0, uvFromXy(xy)).rgb, vec3(1.0));\n}\n\nvec2 getGrad(in vec2 xy) {\n  const float h = 3.0;\n  float f = getVal(xy);\n  return vec2(getVal(xy + vec2(h, 0.0)) - f,\n              getVal(xy + vec2(0.0, h)) - f) / h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float stepSize = 0.2;\n    const float lineWidth = 3.0;\n    float f = getVal(fragCoord);\n    vec2 grad = getGrad(fragCoord);\n    float gradMag = length(grad);\n    \n    float nearest = floor((f + 0.5 * stepSize)/stepSize) * stepSize;\n    \n    float pixToLine = abs(f - nearest)/gradMag;\n    \n    float lineNess = 1.0 - max(0.0, min(1.0, pixToLine - lineWidth * 0.5));\n    \n    // lineNess *= min(1.0, max(3.0 - f, 0.0) / 3.0);\n    lineNess *= step(0.0125, gradMag);\n    \n    vec3 col = vec3(1.0 - lineNess);\n    \n    vec3 rgbCol = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    rgbCol = rgbCol + vec3(0.2) - mod(rgbCol, vec3(0.2));\n    \n    rgbCol = 0.4 + 0.6 * rgbCol;\n\n    // Output to screen\n    fragColor = vec4(col * rgbCol,1.0);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 getColor(in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color = 0.2 * ( getColor(fragCoord) +\n    getColor(fragCoord + vec2(1.0, 0.0)) +\n    getColor(fragCoord + vec2(0.0, 1.0)) +\n    getColor(fragCoord - vec2(1.0, 0.0)) +\n    getColor(fragCoord - vec2(0.0, 1.0)));\n    \n  fragColor = vec4(color,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 getColor(in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color = 0.2 * ( getColor(fragCoord) +\n    getColor(fragCoord + vec2(1.0, 0.0)) +\n    getColor(fragCoord + vec2(0.0, 1.0)) +\n    getColor(fragCoord - vec2(1.0, 0.0)) +\n    getColor(fragCoord - vec2(0.0, 1.0)));\n    \n  fragColor = vec4(color,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec3 getColor(in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color = 0.2 * ( getColor(fragCoord) +\n    getColor(fragCoord + vec2(1.0, 0.0)) +\n    getColor(fragCoord + vec2(0.0, 1.0)) +\n    getColor(fragCoord - vec2(1.0, 0.0)) +\n    getColor(fragCoord - vec2(0.0, 1.0)));\n    \n  fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec3 getColor(in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  return texture(iChannel0, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color = 0.2 * ( getColor(fragCoord) +\n    getColor(fragCoord + vec2(1.0, 0.0)) +\n    getColor(fragCoord + vec2(0.0, 1.0)) +\n    getColor(fragCoord - vec2(1.0, 0.0)) +\n    getColor(fragCoord - vec2(0.0, 1.0)));\n    \n  fragColor = vec4(color,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 57], [59, 59, 85, 85, 150], [152, 152, 178, 178, 322], [324, 324, 381, 381, 1133]], "test": "untested"}
{"id": "sl2cRh", "name": "Random Loading screen  02", "author": "Karp", "description": "random test\n", "tags": ["2d"], "likes": 1, "viewed": 85, "published": 3, "date": "1649190954", "time_retrieved": "2024-07-30T16:55:13.432102", "image_code": "#define PI  3.14159265359\n#define TAU 6.28318530717\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n///UV\nvec2 CenterUV(vec2 fragCoord)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 NormalizeUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n    uv = 2.0 * uv.xy / iResolution.xy;\n\t// [-iResolution.x/2, iResolution.x/2] -> [-1.0, 1.0]\n    // [-iResolution.y/2, iResolution.y/2] -> [-1.0, 1.0]\n    \n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n\tuv = 2.0 * uv.xy / iResolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\nvec2 RotateUV(vec2 uv, float angle)\n{\t\n    //angle in degree (TAU = 2PI = 360 degrees)\n\tangle = angle * PI / 180.0;\n    uv * mat2( cos(angle), sin(angle),\n              -sin(angle), cos(angle));\n    return uv;\n}\n\n///COLOR\nvec3 Color255(int R, int G, int B)\n{\n    float rat = 1.0/255.0;\n    return vec3(float(R)*rat, float(G)*rat, float(B)*rat);\n}\nvec3 HSVcolor(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Grayscale \n#define black   vec3(0.0)\n#define grey   vec3(0.5)\n#define white   vec3(1.0)\n//RGB\n#define red     vec3(1.0,0.0,0.0)\n#define green   vec3(0.0,1.0,0.0)\n#define blue    vec3(0.0,0.0,1.0)\n//CMY\n#define cyan    vec3(0.0,1.0,1.0)\n#define yellow  vec3(1.0,1.0,0.0)\n#define magenta vec3(1.0,0.0,1.0)\n\n//HELPER\nfloat Clamp01(float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n//2DShape\nfloat LineHori(vec2 uv, float height, float thickness, float blur) \n{\n    float sdfLine = abs(uv.y - height)- thickness;\n\treturn Clamp01(sdfLine * (10.0/blur));\n}\nfloat LineVert(vec2 uv, float height, float thickness, float blur) \n{\n    float sdfLine = abs(uv.y - height)- thickness;\n\treturn Clamp01(sdfLine * (10.0/blur));\n}\nfloat Disk(vec2 uv, vec2 center, float radius, float blur) \n{\n    float sdfCircle = length(uv-center)-radius;\n\treturn Clamp01(sdfCircle * (10.0/blur));\n}\n\n//TODO => https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat Rectangle(vec2 uv, vec2 center, vec2 size) \n{\n\tfloat ret;\n\tfloat d = 0.005;\n\tret  = smoothstep((center.x + (-size.x*.5))-d,(center.x +( size.x*.5))+d, uv.x);\n\tret *= smoothstep((center.y + ( size.y*.5))-d,(center.y +(-size.y*.5))+d, uv.y);\n\tret *= 1.0 - smoothstep((center.y +(-size.y*.5))-d,(center.y +( size.y*.5))+d, uv.y);\n\tret *= 1.0 - smoothstep((center.x +( size.x*.5))-d,(center.x +(-size.x*.5))+d, uv.x);\n\treturn ret;\n}\n\n//Reminder\n//mix(a, b, t);\n//mod(val, 1.0);\n//step(edge, var);\n//clamp(var, min, max);\n//smoothstep(edge1, edge2, var);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy);\n    uv *= 1.2;\n    \n    //Parameter\n    float t = iTime * 2.0;\n    \n    //Visu\n    vec3 pix = vec3(uv,0);\n    pix = vec3(0.1);\n    for(int i = 0; i < 960; i++)\n    {\n        float t = (iTime * 1.0) + abs(sin(float(i)/9600.0* TAU + iTime));\n        vec2 pos = vec2(cos( float(i)/32.0 * TAU + t),sin(float(i)/32.0* TAU+t)) * sin(float(i)/8.0* TAU+t)\n        + vec2(0.0,0.0);\n        float circleMask = Disk(uv,pos, 0.075, 0.25);\n        pix = mix(HSVcolor(vec3(float(i)/1024.0, 0.95,0.95)), pix, circleMask); \n    }\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2cRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 229, 264, 264, 292], [293, 293, 330, 330, 410], [412, 418, 449, 476, 679], [680, 680, 714, 714, 927], [928, 928, 964, 964, 1205], [1206, 1206, 1243, 1292, 1417], [1419, 1428, 1464, 1464, 1552], [1553, 1553, 1576, 1576, 1741], [2050, 2059, 2087, 2087, 2122], [2124, 2134, 2203, 2203, 2296], [2297, 2297, 2366, 2366, 2459], [2460, 2460, 2521, 2521, 2613], [2615, 2669, 2720, 2720, 3103], [3226, 3226, 3283, 3306, 3899]], "test": "untested"}
{"id": "ft2cz1", "name": "Random Loading screen 01", "author": "Karp", "description": "Random test", "tags": ["2d"], "likes": 3, "viewed": 152, "published": 3, "date": "1649188335", "time_retrieved": "2024-07-30T16:55:14.170129", "image_code": "#define PI  3.14159265359\n#define TAU 6.28318530717\n\n//HELPER\nfloat Clamp01(float value)\n{\n    return clamp(value,0.0,1.0);\n}\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\n///Playlist shadertoy SDF : \n//https://www.shadertoy.com/playlist/MXdSRf&from=36&num=12\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n//2DShape\nfloat Disk(vec2 uv, vec2 center, float radius, float blur) \n{\n    float sdfCircle = length(uv-center)-radius;\n\treturn Clamp01(sdfCircle * (10.0/blur));\n}\n\n///UV\nvec2 CenterUV(vec2 fragCoord)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n\tuv = 2.0 * uv.xy / iResolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\n\n///COLOR\nvec3 HSVcolor(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy);\n    \n    //Visu\n    vec3 pix = vec3(uv,0);\n    pix = vec3(0.1);\n    for(int i = 0; i < 10; i++)\n    {\n        float t = (iTime * 1.0) + abs(sin(float(i)/128.0* TAU + iTime));\n        vec2 pos = vec2(cos( float(i)/2.0 * TAU + t),sin(float(i)/2.0* TAU+t)) * sin(float(i)/2.0* TAU+t)\n        + vec2(0.0,-.5);\n        float circleMask = Disk(uv,pos, 0.1, 0.2);\n        pix = mix(HSVcolor(vec3(float(i)/30.0, 0.95,0.95)), pix, circleMask); \n    }\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2cz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 62, 90, 90, 125], [127, 303, 338, 338, 366], [367, 377, 438, 438, 530], [532, 538, 569, 596, 799], [800, 800, 836, 836, 1077], [1079, 1088, 1111, 1111, 1280], [1283, 1283, 1340, 1363, 1884]], "test": "untested"}
{"id": "NtByRh", "name": "Random Loading screen 00", "author": "Karp", "description": "random test\n", "tags": ["2d"], "likes": 0, "viewed": 79, "published": 3, "date": "1649188005", "time_retrieved": "2024-07-30T16:55:14.907158", "image_code": "#define PI  3.14159265359\n#define TAU 6.28318530717\n\n///Inigo Quilez Signed Distance Field\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat Disk(vec2 uv, vec2 center, float radius, float blur) \n{\n    float sdfCircle = length(uv-center)-radius;\n\treturn clamp(sdfCircle * (10.0/blur),0.0,1.0);\n}\n\n///UV\nvec2 CenterUV(vec2 fragCoord)\n{\n    ///Centering Operation\n\tvec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n    return uv;\n}\nvec2 AspectRatioUV(vec2 fragCoord)\n{\t\n    vec2 uv = CenterUV(fragCoord.xy);\n\tuv = 2.0 * uv.xy / iResolution.y;\n    // AspectRatio = 1920/1080 = 1.778\n    // [-iResolution.x/2, iResolution.x/2] ->[-1.778, 1.778]\n\t// [-iResolution.y/2, iResolution.y/2] ->[-1, 1]\n    return uv;\n}\n\n///COLOR\nvec3 HSVcolor(vec3 RGB)\n{\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(RGB.xxx + K.xyz) * 6.0 - K.www);\n    return RGB.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), RGB.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV manipulation\n    vec2 uv = AspectRatioUV(fragCoord.xy);\n    uv *= 1.2;\n    \n    //Parameter\n    float time = iTime * .8;\n    \n    //Visu\n    vec3 pix = vec3(uv,0);\n    pix = vec3(0.1);\n    for(int i = 0; i < 480; i++)\n    {\n        float t = time + abs(sin(float(i)/4800.0* TAU + time));\n        vec2 pos = vec2(cos( float(i)/32.0 * TAU + t),sin(float(i)/32.0* TAU+t)) * sin(float(i)/6.0* TAU+t)\n        + vec2(0.0,0.0);\n        float circleMask = Disk(uv,pos, 0.08, .33);\n        pix = mix(HSVcolor(vec3(float(i)/1600.0, 0.95,0.95)), pix, circleMask); \n    }\n    \n\tfragColor = vec4(pix, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtByRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 141, 176, 176, 204], [205, 205, 266, 266, 364], [366, 372, 403, 430, 633], [634, 634, 670, 670, 911], [913, 922, 947, 947, 1118], [1120, 1120, 1177, 1200, 1783]], "test": "untested"}
{"id": "NtB3WD", "name": "CristalCube", "author": "Sergeindamix", "description": "Start your raymarching shader with this template", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 236, "published": 3, "date": "1649182949", "time_retrieved": "2024-07-30T16:55:15.703031", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    p.xz *= Rot(iTime*.1);\n    \n    float d = sdBox(p, vec3(1));\n    for(int i = 0; i <2;i++)\n    {\n        vec3 q = p;\n        q.xz=p.xz*Rot(1.5*float(i));\n        d = max(d, -sdBox(q, vec3(.25,.25,1.1)));\n        q.yz=p.yz*Rot(1.5*float(i));\n        d = max(d, -sdBox(q, vec3(.25,1.1,.25)));\n        d = max(d, -sdBox(q, vec3(1.1, .25, .25)));\n\n    }\n    d = max(d, -sdBox(p, vec3(.9)));\n    \n    float c = cos(3.1415/5.0), s = sqrt(.75-c*c);\n    vec3 n = vec3(-0.5, -c, s);\n    \n    p = abs(p);\n    p -= 2.*min(.0, dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(.0, dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(.0, dot(p, n))*n;\n    \n    //d = p.z-1.0;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;//invertir el exterior de la figura\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);//edges smooth\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3)*.7;//zoom\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);//zoom in\n    vec3 col = texture(iChannel0, rd).rgb;//vec3(0.);//\n   \n    float d = RayMarch(ro, rd, 1.0);//outside of the object\n    \n    float IOR = 1.45;//amount of refraction\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);//reflection\n        vec3 rout = texture(iChannel0, r).rgb;//reflection outside\n        \n        vec3 rdIn = refract(rd, n, 1.0/IOR);//refraction entrada\n\n        //float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        //vec3 reflTex = texture(iChannel0, rd - 1.0).rgb;//reflection texture\n        \n        vec3 reflTex = vec3(0);\n        \n        vec3 rdOut = vec3(0);\n        \n        float abb = .01;//chromatic abberation\n\n        \n        vec3 pEnter = p - n*SURF_DIST*3.0;\n        float dIn = RayMarch(pEnter, rdIn, -1.0);//inside of the object\n        \n        vec3 pExit = pEnter + rdIn * dIn;//3d position of exit\n        vec3 nExit = -GetNormal(pExit);\n        \n        rdOut = refract(rdIn, nExit, IOR-abb);//refraction saliendo del objeto\n        if(length(rdOut)==0.0) rdOut = reflect(rdIn, nExit);//correction surface\n        reflTex.g = texture(iChannel0, rdOut).g;//refraction green\n        \n        rdOut = refract(rdIn, nExit, IOR);//refraction saliendo del objeto\n        if(length(rdOut)==0.0) rdOut = reflect(rdIn, nExit);//correction surface\n        reflTex.r = texture(iChannel0, rdOut).r;//refraction red\n        \n        rdOut = refract(rdIn, nExit, IOR+abb);//refraction saliendo del objeto\n        if(length(rdOut)==0.0) rdOut = reflect(rdIn, nExit);//correction surface\n        reflTex.b = texture(iChannel0, rdOut).b;//refraction blue\n        \n        float dens = .1;//density\n        float optDist = exp(-dIn*dens);//optical distance\n        \n        float fresnel = pow(1.0+dot(rd, n),5.);//reflection value\n        \n        reflTex = reflTex*optDist;//*vec3(1,.05,.2);//colorize\n        \n        col = n*.5+.5;//\n        col = mix(reflTex, rout, fresnel);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3WD.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1671, 1671, 1694, 1694, 2388], [2390, 2390, 2436, 2436, 2687], [2689, 2689, 2713, 2713, 2916], [2918, 2918, 2968, 2968, 3159], [3161, 3161, 3218, 3218, 5569]], "test": "untested"}
{"id": "stByz1", "name": "Interstellar wormhole", "author": "michael0884", "description": "Using a hamiltonian based integrator to compute geodesics in the Dneg metric.\nhttps://arxiv.org/pdf/1502.03809.pdf", "tags": ["camera"], "likes": 10, "viewed": 10368, "published": 3, "date": "1649162884", "time_retrieved": "2024-07-30T16:55:16.719313", "image_code": "// Fork of \"Ellis wormhole\" by michael0884. https://shadertoy.com/view/ftSyzh\n// 2022-04-05 12:47:23\n\n// Fork of \"Arbitrary space-time ray tracer\" by michael0884. https://shadertoy.com/view/NtSGWG\n// 2022-04-04 21:07:42\n\n// Fork of \"Schwarzschild black hole\" by michael0884. https://shadertoy.com/view/ftBGWm\n// 2021-06-21 11:20:36\n\nvec3 saturate(vec3 c)\n{\n    return 1.3*pow(c, vec3(1.2));\n}\n\n#define SHARPEN 2.0\n#define LOWSAMPLE_BLUR 1.\nvec4 sample_adaptive(sampler2D ch, vec2 uv)\n{\n    vec3 dx = vec3(0.5/vec2(textureSize(ch, 0)),0.);\n    const float k = SHARPEN;\n    vec4 c = texture(ch, uv);\n    \n    vec4 u = texture(ch, uv + dx.zy);\n    vec4 d = texture(ch, uv - dx.zy);\n    vec4 r = texture(ch, uv + dx.xz);\n    vec4 l = texture(ch, uv - dx.xz);\n    vec4 u1 = texture(ch, uv + dx.xy);\n    vec4 d1 = texture(ch, uv - vec2(1, -1)*dx.xy);\n    vec4 r1 = texture(ch, uv - dx.xy);\n    vec4 l1 = texture(ch, uv + vec2(1, -1)*dx.xy);\n    return (1.+k)*c - k*(u+d+r+l+1.5*(u1+d1+r1+l1)/4.0)/(4.0 +1.5); \n}\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = sample_adaptive(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =130.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(0,1,0))*33.1;\n        ca = aa2q( normalize(vec3(1,0,0.)), PI*3.0/4.0);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.5\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\nmat4 diag(vec4 a)\n{\n    return \n    mat4(a.x,0,0,0,\n         0,a.y,0,0,\n         0,0,a.z,0,\n         0,0,0,a.w);\n}\n\n//optimized inverse of symmetric matrix\nmat4 inverse_sym(mat4 m) {\n\tfloat n11 = m[0][0], n12 = m[1][0], n13 = m[2][0], n14 = m[3][0];\n\tfloat n22 = m[1][1], n23 = m[2][1], n24 = m[3][1];\n\tfloat n33 = m[2][2], n34 = m[3][2];\n\tfloat n44 = m[3][3];\n\n\tfloat t11 = 2.0 * n23 * n34 * n24 - n24 * n33 * n24 - n22 * n34 * n34 - n23 * n23 * n44 + n22 * n33 * n44;\n\tfloat t12 = n14 * n33 * n24 - n13 * n34 * n24 - n14 * n23 * n34 + n12 * n34 * n34 + n13 * n23 * n44 - n12 * n33 * n44;\n\tfloat t13 = n13 * n24 * n24 - n14 * n23 * n24 + n14 * n22 * n34 - n12 * n24 * n34 - n13 * n22 * n44 + n12 * n23 * n44;\n\tfloat t14 = n14 * n23 * n23 - n13 * n24 * n23 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\tfloat det = n11 * t11 + n12 * t12 + n13 * t13 + n14 * t14;\n\tfloat idet = 1.0f / det;\n\n\tmat4 ret;\n\n\tret[0][0] = t11 * idet;\n\tret[0][1] = (n24 * n33 * n14 - n23 * n34 * n14 - n24 * n13 * n34 + n12 * n34 * n34 + n23 * n13 * n44 - n12 * n33 * n44) * idet;\n\tret[0][2] = (n22 * n34 * n14 - n24 * n23 * n14 + n24 * n13 * n24 - n12 * n34 * n24 - n22 * n13 * n44 + n12 * n23 * n44) * idet;\n\tret[0][3] = (n23 * n23 * n14 - n22 * n33 * n14 - n23 * n13 * n24 + n12 * n33 * n24 + n22 * n13 * n34 - n12 * n23 * n34) * idet;\n\n\tret[1][0] = ret[0][1];\n\tret[1][1] = (2.0 * n13 * n34 * n14 - n14 * n33 * n14 - n11 * n34 * n34 - n13 * n13 * n44 + n11 * n33 * n44) * idet;\n\tret[1][2] = (n14 * n23 * n14 - n12 * n34 * n14 - n14 * n13 * n24 + n11 * n34 * n24 + n12 * n13 * n44 - n11 * n23 * n44) * idet;\n\tret[1][3] = (n12 * n33 * n14 - n13 * n23 * n14 + n13 * n13 * n24 - n11 * n33 * n24 - n12 * n13 * n34 + n11 * n23 * n34) * idet;\n\n\tret[2][0] = ret[0][2];\n\tret[2][1] = ret[1][2];\n    ret[2][2] = (2.0 * n12 * n24 * n14 - n14 * n22 * n14 - n11 * n24 * n24 - n12 * n12 * n44 + n11 * n22 * n44) * idet;\n\tret[2][3] = (n13 * n22 * n14 - n12 * n23 * n14 - n13 * n12 * n24 + n11 * n23 * n24 + n12 * n12 * n34 - n11 * n22 * n34) * idet;\n\n\tret[3][0] = ret[0][3];\n\tret[3][1] = ret[1][3];\n\tret[3][2] = ret[2][3];\n\tret[3][3] = (2.0 * n12 * n23 * n13 - n13 * n22 * n13 - n11 * n23 * n23 - n12 * n12 * n33 + n11 * n22 * n33) * idet;\n\n\treturn ret;\n}\n\nfloat sphIntersect(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0)\n        return 1e10;\n    return -b - sqrt(h);\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n\nconst float PI2 = 6.2831853071;\n\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\nvec3 colorTemperatureToRGB(const in float temperature){\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\n\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\n\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \n\t \t\t\t\t\t\t\t\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\n   \t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\n\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), vec3(1.0), smoothstep(1000.0, 0.0, temperature));\n}\n\n", "buffer_b_code": "#define SPP 2\n\n//Note, no time nor polar angle is used here. \n//A wormhole does not have gravity and is spherically symmetric thus such simplifications are applicable\n\nconst float max_distance = 50.0f;\nconst float eps = 0.005;\nconst vec2 dq = vec2(0, eps);\nfloat dt = 0.1;\n\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\n\nfloat EllisR(float l)\n{\n    const float rho = 1.0; //radius\n    const float a = 6.0; //tunnel length \n    const float M = 0.5; //\"mass\"\n    \n    float x = 2.0*(abs(l) - a)/(PI*M);\n    return (abs(l) > a)?(rho + M*(x*atan(x) - 0.5*log(1.0 + x*x))):rho;\n}\n\nvec2 DiagG(vec2 q)\n{\n    return vec2(1.0, sqr(EllisR(q.x)));\n}\n\nvec2 DiagGinv(vec2 q)\n{\n    return vec2(1.0, 1.0/sqr(EllisR(q.x)));\n}\n\nfloat L(vec2 q, vec2 qt)\n{\n    return dot(DiagG(q), qt*qt);\n}\n\nfloat H(vec2 q, vec2 p)\n{\n    return dot(DiagGinv(q), p*p);\n}\n\nvec2 ToMomentum(vec2 q, vec2 qt)\n{\n    return DiagG(q)*qt; \n}\n\nvec2 FromMomentum(vec2 q, vec2 p)\n{\n    return DiagGinv(q)*p; \n}\n\nvoid GeodesicStep(inout vec2 q, inout vec2 p)\n{  \n    vec2 qt = FromMomentum(q, p);\n \n    vec2 dHdq = (vec2(L(q+dq.yx,qt),L(q+dq.xy, qt))-L(q, qt))/eps; \n    \n    float r = EllisR(q.x);\n    dt = mix(0.3, 0.6, clamp(r / 10.0, 0.0, 1.0)); \n    \n    p += dHdq*dt;\n    q += 2.0*qt*dt;\n}\n\nvoid CameraToGeodesic(vec3 ro, vec3 rd, out vec2 q, out vec2 qt, out vec3 ax1, out vec3 ax2)\n{\n    //get spherical coordinate axis\n    ax1 = normalize(ro); // X\n    vec3 ax0 = normalize(cross(rd, ax1)); // Z\n    ax2 = normalize(cross(ax1, ax0)); // Y\n    \n    q = vec2(length(ro)-25.0, 0);\n    qt = vec2(dot(ax1, rd), dot(ax2, rd)/EllisR(q.x)); \n}\n\nvoid GeodesicToCamera(vec2 q, vec2 qt, vec3 ax1, vec3 ax2, out vec3 ro, out vec3 rd)\n{\n    //polar coordinates\n    vec2 s1 = vec2(cos(q.y), sin(q.y));\n    vec2 s2 = vec2(-sin(q.y), cos(q.y));\n    \n\n    vec2 s = s1*qt.x + s2*qt.y*EllisR(q.x);\n    \n    rd = s.x*ax1 + s.y*ax2;\n    ro = abs(q.x)*(s1.x*ax1 + s1.y*ax2);\n}\n\n\nvoid TraceGeodesic(inout vec3 ro, inout vec3 rd, inout float l)\n{\n    float t0 = sphIntersect(ro, rd, vec4(0,0,0,max_distance));\n    if(t0 > 0.0 && t0 < 1e10) ro += rd*t0;\n\n    vec3 ax1, ax2;\n    vec2 q, qt;\n    \n    CameraToGeodesic(ro, rd, q, qt, ax1, ax2);\n\n    vec2 p = ToMomentum(q, qt);\n \n    for(int i = 0; i <128*64; i++)\n    {\n        GeodesicStep(q, p);\n        if(abs(q.x) > max_distance) break;\n    }\n    \n    qt = FromMomentum(q, p);\n    \n    GeodesicToCamera(q, qt, ax1, ax2, ro, rd);\n    \n    l = q.x;\n}\n\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    vec2 apert_cent = -0.*uv;\n    \n    vec2 ap = aperture();\n    \n    if(!(distance(ap, apert_cent) < 1.0)) return false;\n    \n    float apd = length(ap);\n    \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1];\n    \n    ro = get(CamP).xyz + aperture_size*daperture;\n  \n    float focus =2.5 + 0.8*pow(apd,5.0);\n\n   \n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    \n    return true;\n}\n\nvec3 ToHDR(vec4 color)\n{\n    return 1.0*pow(length(color.xyz),1.0)*normalize(color.xyz+1e-4);\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec3 ro = cp;\n    vec3 fcol = vec3(0.0);\n    float l;\n    \n    TraceGeodesic(ro, rd, l);\n   \n    if(abs(l) > 5.0)\n    {\n        if(l > 0.0)\n            fcol = ToHDR(texture(iChannel1, rd));\n        else\n            fcol = ToHDR(texture(iChannel3, rd));\n    }\n    \n    return vec4(fcol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n   \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy)*0.3;\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stByz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 333, 356, 356, 392], [440, 440, 485, 485, 1005], [1010, 1010, 1067, 1067, 1190]], "test": "untested"}
{"id": "7tSyRh", "name": "Day Seven - Lambmeow (Lucky)", "author": "lambmeow", "description": "Drag Your mouse around the screen!!!", "tags": ["2d", "sdf", "number", "70s", "seven"], "likes": 5, "viewed": 204, "published": 3, "date": "1649139607", "time_retrieved": "2024-07-30T16:55:17.474295", "image_code": "//Daily Shader Challenge Day 7\n//Experimenting with more 2D shaders ( Now with mouse support)\n//tried going for that 70s font\n//Lopea (https://github.com/lopea)\n\n\nfloat line(vec2 u, vec2 l)\n{\n    vec2 p = abs(u) - l;\n    \n    return length(max(p, 0.)) + min(max(p.x,p.y), 0.);\n}\nmat2 rot(float a )\n{\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nfloat smoothun(float d1 ,float d2, float k )\n{\n    float h = clamp(.5+ .5*(d2-d1)/k,0., 1.);\n    return mix(d2, d1, h) - k*h*(1.-h);\n}\nfloat sev(vec2 x, float tt)\n{\n    vec2 sx = x;\n    sx.x = sx.x - sx.y*atan(radians(35.));\n    float res = (min(line(sx,vec2(.1,.24)), line(sx + vec2(.15,-0.35),vec2(.25,.1))))-.02;\n    \n    \n    res = max(mod(res, atan(tt) * .02),res);\n    \n    return res;\n}\n\n\nvec4 gc(vec2 u, float a, float tt)\n{\n    float rr = (step(sev(u - vec2(0.,-.15) + vec2(.004)*a, tt), 0.01));\n        float gg = (step(sev(u - vec2(0.,-.15) -vec2(.0004)*a,tt), 0.01));\n        float bb = (step(sev(u - vec2(0.,-.15) - vec2(.004)*a,tt), 0.01));\n        \n    return vec4(rr,gg,bb, 1);\n}\n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = (2.* f -r)/r.y;\n    float tt = iTime;\n    if(iFrame < 5)\n    {\n        tt += 10.;\n    }\n    \n    \n    u *= .65;\n    float a = max(atan (tt - 6.5),0.);\n    float b = atan(smoothstep (0.,0.1, a * 0.1));\n    vec2 m = (2.* iMouse.xy - r)/r.y; \n    u += m*.01;\n    if(b != 0.)\n    {\n        u.x = mod(u.x + b/2., b) -b/2.;\n    \n    \n    for(int i = 0 ; i < 7; i ++)\n    {\n        c += gc(u,a,tt);\n        u *=.99 * a;\n        u += m*.05;\n    }\n        c/=2.;\n    }\n    else\n    {\n        c = gc(u,a,tt);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 191, 191, 278], [279, 279, 299, 299, 371], [372, 372, 418, 418, 506], [507, 507, 536, 536, 765], [768, 768, 804, 804, 1067], [1069, 1069, 1108, 1108, 1648]], "test": "untested"}
{"id": "NtScz1", "name": "Radial gradient base", "author": "zsjasper", "description": "Radial gradient", "tags": ["radialgradient"], "likes": 1, "viewed": 329, "published": 3, "date": "1649124523", "time_retrieved": "2024-07-30T16:55:18.217308", "image_code": "vec2 Position = vec2(0.0,0.0);\nfloat Radius = 0.5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    //Without changing colors\n    //vec4 gradientColor = vec4(1.0 - length(Position - uv),0,1,1);\n\tvec4 gradientColor = vec4(1.0 - length(Position - uv)-(1.-Radius),0.,0,1.0);\n\n\n\tfragColor = gradientColor;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtScz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 110, 383]], "test": "untested"}
{"id": "slSyzz", "name": "Marzipan Froge", "author": "clepirelli", "description": "It is here, finally", "tags": ["froge", "marzipan"], "likes": 8, "viewed": 403, "published": 3, "date": "1649117618", "time_retrieved": "2024-07-30T16:55:19.042103", "image_code": "COLOR(white, white_id,255.0,255.0,255.0)\nCOLOR(pink, pink_id,255.0,120.0,214.0)\nCOLOR(green, green_id, 237.0,255.0,50.0)\nCOLOR(brown, brown_id, 17.5,8.5,2.0)\nCOLOR(purple, purple_id, 128.0,25.0,128.0)\n\nvec3 idToColor(float id)\n{\n    RETURN_COLOR(white, white_id)\n    RETURN_COLOR(pink, pink_id);\n    RETURN_COLOR(green, green_id);\n    RETURN_COLOR(brown, brown_id);\n    return purple;\n}\n\nsdfRet sdf(vec3 point)\n{\n    //body\n    sdfRet belly = sdfRet(sphere(point, vec3(.0, -.95, 1.1), .9), white_id);\n    sdfRet head = sdfRet(sphere(point, vec3(.0), 1.0), green_id);\n    float back = sphere(point, vec3(.0, -.1, -.9), .7);\n    \n    sdfRet allParts = paintUnionSDF(head, belly);\n    allParts = sdfRet(smin(allParts.dist, back, .7), allParts.id);\n    \n    vec3 mirroredX = mirrorX(point); \n    \n    //face\n    sdfRet eyes = sdfRet(sphere(mirroredX, vec3(.4, .3, .68), .3), brown_id);\n    sdfRet mouth = sdfRet(capsule(bend(point, 2.0), vec3(-.22, -.15, 1.0), vec3(.22, -.15, 1.0), .1), brown_id);\n    sdfRet blush = sdfRet(sphere(mirroredX, vec3(.68, -.03, .7), .15), pink_id);\n    \n    allParts = minSDF(allParts, eyes);\n    allParts = minSDF(allParts, mouth);\n    allParts = minSDF(allParts, blush);\n    \n    //back legs\n    float backThighs = sphere(mirroredX, vec3(.6, -.1, -.6), .7);\n    float backFeet = capsule(mirroredX, vec3(.9, -.6, -.6), vec3(1.0, -.6, -.2), .3);\n    sdfRet backLegs = sdfRet(smin(backThighs, backFeet, .1), allParts.id);\n    allParts = minSDF(allParts, backLegs);\n    \n    //front legs\n    float frontThighs = sphere(mirroredX, vec3(.8, -.6, .4), .2);\n    float frontFeet = capsule(mirroredX, vec3(.8, -.7, .4), vec3(.5, -.8, .6), .2);\n    sdfRet frontLegs = sdfRet(smin(frontFeet, frontThighs, .1), green_id);\n    allParts = minSDF(allParts, frontLegs);\n    \n    return allParts;\n}\n\n\n//from iq: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH).dist + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH).dist + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH).dist + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH).dist );\n}\n\n//from: https://www.shadertoy.com/view/lllBDM\nfloat subsurface(vec3 p, vec3 v, vec3 n){\n    //vec3 d = normalize(mix(v, -n, 0.5));\n    // suggested by Shane\n    vec3 d = refract(v, n, 1.0/1.5);\n    vec3 o = p;\n    float a = 0.0;\n    \n    const float max_scatter = 1.5;\n    for(float i = 0.1; i < max_scatter; i += 0.2)\n    {\n        o += i*d;\n        float t = sdf(o).dist;\n        a += t;\n    }\n    float thickness = max(0.0, -a);\n    const float scatter_strength = 16.0;\n\treturn scatter_strength*pow(max_scatter*0.5, 3.0)/thickness;\n}\n\nvec3 light(vec3 point, float id, vec3 viewDir)\n{\n    vec3 norm = calcNormal(point);\n    vec3 baseColor = idToColor(id);\n    vec3 lightDir = normalize(vec3(1.0,1.0,.0));\n    vec3 reflectDir = reflect(lightDir, norm);\n    float lambert = lambertian(norm, lightDir);\n    //from: https://www.shadertoy.com/view/lllBDM\n    float subsurface_scattering = pow(subsurface(point, viewDir, norm), 0.6);\n    lambert = mix(lambert, 1.5*smoothstep(0.1, 6.0, subsurface_scattering), 0.5);\n    \n    vec3 shading = vec3(1.0,.9,.8)*lambert + pow(max(dot(viewDir, reflectDir), 0.0), 2.0);\n    return baseColor * shading;\n}\n\nvec3 Image(vec2 uv)\n{\n    float mousex = 9.0*iMouse.x/iResolution.x;\n    ray currentRay = cameraRay(mousex, uv);\n    \n    vec3 col = sky(currentRay.direction);\n    \n    float currentDistance = .0;\n    \n    for(int i = 0; i < ITERATIONS; i++)\n    {\n        vec3 samplePoint = currentRay.origin + currentRay.direction*currentDistance;\n        sdfRet ret = sdf(samplePoint);\n        if(ret.dist < CLOSE_ENOUGH)\n        {\n            col = light(samplePoint, ret.id, currentRay.direction);\n            break;\n        }\n        currentDistance += ret.dist;\n    }\n    \n    return col;\n}\n\n\n//------------ boilerplate\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n//AA trick from Fabrice Neyret: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/                     \nvoid mainImage0(out vec4 frogColor, in vec2 fragCoord)\n{                                                     \n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);    \n    uv.x *= iResolution.x/iResolution.y;              \n    frogColor = colorCorrect(Image(uv));           \n}                                                     \n                                                      \nvoid mainImage(out vec4 frogColor, in vec2 fragCoord)  \n{                                                     \n    mainImage0(frogColor,fragCoord);                  \n    if ( fwidth(length(frogColor)) > .01 )            \n    {                                                 \n        vec4 col;                                     \n        for (int k=0; k < 9; k+= k==3?2:1 )           \n        {                                             \n            vec2 offset = vec2(k%3-1,k/3-1)/3.;       \n            mainImage0(col,fragCoord+offset);         \n            frogColor += col;\n        }                                             \n        frogColor /= 9.;\n    }                                                 \n}\n//------------", "image_inputs": [], "common_code": "#define CLOSE_ENOUGH 0.0001\n#define ITERATIONS 500\n#define CAMERA_DISTANCE 6.0\n#define CAMERA_HEIGHT .5\n\n#define COLOR(name, id, r,g,b) const vec3 name = vec3(r,g,b)/255.0; const float id = float(__LINE__);\n#define RETURN_COLOR(name, col_id) if(id <= col_id) return name;\n\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct sdfRet\n{\n    float dist;\n    float id;\n};\n\n\n//------------ all from Inigo Quilez: https://iquilezles.org/articles/distfunctions\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sphere(vec3 point, vec3 origin, float radius)\n{\n\treturn distance(point,origin)-radius;\n}\n\nfloat smin(float d1, float d2, float k) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 bend(vec3 point, float amount)\n{\n    float c = cos(amount*point.x);\n    float s = sin(amount*point.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*point.xy,point.z);\n    return q;\n}\n\n//------------ end of iq code\n\n\nvec3 mirrorX(vec3 point)\n{\n    return vec3(abs(point.x), point.y, point.z);\n}\n\nsdfRet minSDF(sdfRet a, sdfRet b)\n{\n    if(a.dist < b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nsdfRet paintUnionSDF(sdfRet a, sdfRet b)\n{\n    sdfRet bPrime = sdfRet(max(a.dist, b.dist), b.id);\n    return minSDF(a, bPrime);\n}\n\n\nfloat lambertian(vec3 n, vec3 l)\n{\n\treturn dot(n,l);\n} \n\nvec3 sky(vec3 direction)\n{\n    return vec3(.2,.4,.9)-vec3(.4,.4,.9)*direction.y;\n}\n\n\nray cameraRay(float mousex, vec2 uv)\n{\n    vec3 target = vec3(.0,.0,.0);\n    vec3 rayOrigin = target + vec3(CAMERA_DISTANCE*sin(mousex),CAMERA_HEIGHT,CAMERA_DISTANCE*cos(mousex));\n    vec3 front = normalize(target - rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    return ray(rayOrigin, normalize(uv.x*right+uv.y*up+1.0*front));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 412, 423, 1809], [1812, 1866, 1894, 1894, 2187], [2189, 2235, 2276, 2345, 2725], [2727, 2727, 2775, 2775, 3330], [3332, 3332, 3353, 3353, 3912], [3943, 3943, 3974, 3974, 4115], [4117, 4240, 4296, 4296, 4513], [4622, 4622, 4679, 4679, 5339]], "test": "untested"}
{"id": "ftSyzh", "name": "Ellis wormhole", "author": "michael0884", "description": "Using a hamiltonian based integrator to compute geodesics in arbitrary metrics.\nBasically the initial mode is a kerr black hole in looped space.\nYou can chage the params of the BH and/or switch to a warp drive metric(need to restart the sim to find it)\n", "tags": ["camera"], "likes": 5, "viewed": 299, "published": 3, "date": "1649109616", "time_retrieved": "2024-07-30T16:55:20.041431", "image_code": "// Fork of \"Arbitrary space-time ray tracer\" by michael0884. https://shadertoy.com/view/NtSGWG\n// 2022-04-04 21:07:42\n\n// Fork of \"Schwarzschild black hole\" by michael0884. https://shadertoy.com/view/ftBGWm\n// 2021-06-21 11:20:36\n\nvec3 saturate(vec3 c)\n{\n    return tanh(c*c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =130.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(1,2,0))*36.1;\n        ca = aa2q( normalize(vec3(1,0,0.)), PI*3.0/4.0);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.5\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\nmat4 diag(vec4 a)\n{\n    return \n    mat4(a.x,0,0,0,\n         0,a.y,0,0,\n         0,0,a.z,0,\n         0,0,0,a.w);\n}\n\n//optimized inverse of symmetric matrix\nmat4 inverse_sym(mat4 m) {\n\tfloat n11 = m[0][0], n12 = m[1][0], n13 = m[2][0], n14 = m[3][0];\n\tfloat n22 = m[1][1], n23 = m[2][1], n24 = m[3][1];\n\tfloat n33 = m[2][2], n34 = m[3][2];\n\tfloat n44 = m[3][3];\n\n\tfloat t11 = 2.0 * n23 * n34 * n24 - n24 * n33 * n24 - n22 * n34 * n34 - n23 * n23 * n44 + n22 * n33 * n44;\n\tfloat t12 = n14 * n33 * n24 - n13 * n34 * n24 - n14 * n23 * n34 + n12 * n34 * n34 + n13 * n23 * n44 - n12 * n33 * n44;\n\tfloat t13 = n13 * n24 * n24 - n14 * n23 * n24 + n14 * n22 * n34 - n12 * n24 * n34 - n13 * n22 * n44 + n12 * n23 * n44;\n\tfloat t14 = n14 * n23 * n23 - n13 * n24 * n23 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\tfloat det = n11 * t11 + n12 * t12 + n13 * t13 + n14 * t14;\n\tfloat idet = 1.0f / det;\n\n\tmat4 ret;\n\n\tret[0][0] = t11 * idet;\n\tret[0][1] = (n24 * n33 * n14 - n23 * n34 * n14 - n24 * n13 * n34 + n12 * n34 * n34 + n23 * n13 * n44 - n12 * n33 * n44) * idet;\n\tret[0][2] = (n22 * n34 * n14 - n24 * n23 * n14 + n24 * n13 * n24 - n12 * n34 * n24 - n22 * n13 * n44 + n12 * n23 * n44) * idet;\n\tret[0][3] = (n23 * n23 * n14 - n22 * n33 * n14 - n23 * n13 * n24 + n12 * n33 * n24 + n22 * n13 * n34 - n12 * n23 * n34) * idet;\n\n\tret[1][0] = ret[0][1];\n\tret[1][1] = (2.0 * n13 * n34 * n14 - n14 * n33 * n14 - n11 * n34 * n34 - n13 * n13 * n44 + n11 * n33 * n44) * idet;\n\tret[1][2] = (n14 * n23 * n14 - n12 * n34 * n14 - n14 * n13 * n24 + n11 * n34 * n24 + n12 * n13 * n44 - n11 * n23 * n44) * idet;\n\tret[1][3] = (n12 * n33 * n14 - n13 * n23 * n14 + n13 * n13 * n24 - n11 * n33 * n24 - n12 * n13 * n34 + n11 * n23 * n34) * idet;\n\n\tret[2][0] = ret[0][2];\n\tret[2][1] = ret[1][2];\n    ret[2][2] = (2.0 * n12 * n24 * n14 - n14 * n22 * n14 - n11 * n24 * n24 - n12 * n12 * n44 + n11 * n22 * n44) * idet;\n\tret[2][3] = (n13 * n22 * n14 - n12 * n23 * n14 - n13 * n12 * n24 + n11 * n23 * n24 + n12 * n12 * n34 - n11 * n22 * n34) * idet;\n\n\tret[3][0] = ret[0][3];\n\tret[3][1] = ret[1][3];\n\tret[3][2] = ret[2][3];\n\tret[3][3] = (2.0 * n12 * n23 * n13 - n13 * n22 * n13 - n11 * n23 * n23 - n12 * n12 * n33 + n11 * n22 * n33) * idet;\n\n\treturn ret;\n}\n\nfloat sphIntersect(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0)\n        return 1e10;\n    return -b - sqrt(h);\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n\nconst float PI2 = 6.2831853071;\n\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\nvec3 colorTemperatureToRGB(const in float temperature){\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\n\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\n\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \n\t \t\t\t\t\t\t\t\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\n   \t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\n\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), vec3(1.0), smoothstep(1000.0, 0.0, temperature));\n}\n\n", "buffer_b_code": "#define SPP 1\n\n//Note, no time nor polar angle is used here. \n//A wormhole does not have gravity and is spherically symmetric thus such simplifications are applicable\n\nconst float max_distance = 50.0f;\nconst float eps = 0.005;\nconst vec2 dq = vec2(0, eps);\nfloat dt = 0.1;\n\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\n\nfloat EllisR(float l)\n{\n    const float rho = 1.0; //radius\n    const float a = 6.0; //tunnel length \n    const float M = 0.5; //\"mass\"\n    \n    float x = 2.0*(abs(l) - a)/(PI*M);\n    return (abs(l) > a)?(rho + M*(x*atan(x) - 0.5*log(1.0 + x*x))):rho;\n}\n\nvec2 DiagG(vec2 q)\n{\n    return vec2(1.0, sqr(EllisR(q.x)));\n}\n\nvec2 DiagGinv(vec2 q)\n{\n    return vec2(1.0, 1.0/sqr(EllisR(q.x)));\n}\n\nfloat L(vec2 q, vec2 qt)\n{\n    return dot(DiagG(q), qt*qt);\n}\n\nfloat H(vec2 q, vec2 p)\n{\n    return dot(DiagGinv(q), p*p);\n}\n\nvec2 ToMomentum(vec2 q, vec2 qt)\n{\n    return DiagG(q)*qt; \n}\n\nvec2 FromMomentum(vec2 q, vec2 p)\n{\n    return DiagGinv(q)*p; \n}\n\nvoid GeodesicStep(inout vec2 q, inout vec2 p)\n{  \n    vec2 qt = FromMomentum(q, p);\n \n    vec2 dHdq = (vec2(L(q+dq.yx,qt),L(q+dq.xy, qt))-L(q, qt))/eps; \n    \n    float r = EllisR(q.x);\n    dt = mix(0.3, 0.6, clamp(r / 10.0, 0.0, 1.0)); \n    \n    p += dHdq*dt;\n    q += 2.0*qt*dt;\n}\n\nvoid CameraToGeodesic(vec3 ro, vec3 rd, out vec2 q, out vec2 qt, out vec3 ax1, out vec3 ax2)\n{\n    //get spherical coordinate axis\n    ax1 = normalize(ro); // X\n    vec3 ax0 = normalize(cross(rd, ax1)); // Z\n    ax2 = normalize(cross(ax1, ax0)); // Y\n    \n    q = vec2(length(ro)-25.0, 0);\n    qt = vec2(dot(ax1, rd), dot(ax2, rd)/EllisR(q.x)); \n}\n\nvoid GeodesicToCamera(vec2 q, vec2 qt, vec3 ax1, vec3 ax2, out vec3 ro, out vec3 rd)\n{\n    //polar coordinates\n    vec2 s1 = vec2(cos(q.y), sin(q.y));\n    vec2 s2 = vec2(-sin(q.y), cos(q.y));\n    \n\n    vec2 s = s1*qt.x + s2*qt.y*EllisR(q.x);\n    \n    rd = s.x*ax1 + s.y*ax2;\n    ro = abs(q.x)*(s1.x*ax1 + s1.y*ax2);\n}\n\n\nvoid TraceGeodesic(inout vec3 ro, inout vec3 rd, inout float l)\n{\n    float t0 = sphIntersect(ro, rd, vec4(0,0,0,max_distance));\n    if(t0 > 0.0 && t0 < 1e10) ro += rd*t0;\n\n    vec3 ax1, ax2;\n    vec2 q, qt;\n    \n    CameraToGeodesic(ro, rd, q, qt, ax1, ax2);\n\n    vec2 p = ToMomentum(q, qt);\n \n    for(int i = 0; i <128*64; i++)\n    {\n        GeodesicStep(q, p);\n        if(abs(q.x) > max_distance) break;\n    }\n    \n    qt = FromMomentum(q, p);\n    \n    GeodesicToCamera(q, qt, ax1, ax2, ro, rd);\n    \n    l = q.x;\n}\n\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    vec2 apert_cent = -0.*uv;\n    \n    vec2 ap = aperture();\n    \n    if(!(distance(ap, apert_cent) < 1.0)) return false;\n    \n    float apd = length(ap);\n    \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1];\n    \n    ro = get(CamP).xyz + aperture_size*daperture;\n  \n    float focus =2.5 + 0.8*pow(apd,5.0);\n\n   \n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    \n    return true;\n}\n\nvec3 ToHDR(vec4 color)\n{\n    return 2.0*pow(length(color.xyz),2.0)*normalize(color.xyz+1e-4);\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(1.0, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec3 ro = cp;\n    vec3 fcol = vec3(0.0);\n    float l;\n    \n    TraceGeodesic(ro, rd, l);\n   \n    if(abs(l) > 5.0)\n    {\n        if(l > 0.0)\n            fcol = ToHDR(texture(iChannel1, rd));\n        else\n            fcol = ToHDR(texture(iChannel3, rd));\n    }\n    \n    return vec4(fcol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n   \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy)*0.1;\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 254, 254, 278], [280, 280, 337, 337, 452]], "test": "untested"}
{"id": "7s2XRt", "name": "Hofstadter's butterfly", "author": "Roninkoi", "description": "[url=https://en.wikipedia.org/wiki/Hofstadter%27s_butterfly]Hofstadter's butterfly[/url] fractal known from the quantum Hall effect. The x-axis is energy, and y is magnetic flux", "tags": ["fractal", "quantum", "butterfly", "hofstadter"], "likes": 5, "viewed": 342, "published": 3, "date": "1649106411", "time_retrieved": "2024-07-30T16:55:20.796413", "image_code": "#define PI 3.14159265\n\n#define V(y, k) (2. * cos(2. * PI * float(k) * (y)))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    \n    float x = uv.x * 6.;\n    float y = (uv.y*1.5+1.)/ 2.;\n    \n    int q = 100 + int(sin(iTime)*100.); // number of iterations\n    \n    float det = 0.;\n    float det2 = 0.;\n    float det1 = 1.;\n    for (int j = 0; j < q; ++j) { // calculate determinant of tridiagonal matrix\n        det = (V(y, j+1) - x) * det1 - det2;\n        det2 = det1;\n        det1 = det;\n    }\n    \n    // Lyapunov exponent\n    float f = log(abs(det)) / float(q);\n    float c = clamp(f, 0., 0.3) * 9.5 - 1.5;\n    \n    vec3 col = vec3(\n        sin(c), sin(c + PI / 3.), sin(c + 2. * (PI / 3.))\n    );\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 132, 132, 805]], "test": "untested"}
{"id": "slSczz", "name": "Cube Stacks 🧊", "author": "byt3_m3chanic", "description": "Mostly a homage to @Shane's techniques for multi-tap and cube mapping. Playing with truchet tiles in bmp+texture in a single layered grid. \nAA = 2 suggested ", "tags": ["raymarching", "cube", "texture", "cubemap"], "likes": 29, "viewed": 520, "published": 3, "date": "1649105697", "time_retrieved": "2024-07-30T16:55:21.532444", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    🧊 Cube Stacks - its really just one layer packed with waves. \n    4/3/22 | @byt3_m3chanic\n    \n    Mostly a homage to @Shane's techniques for multi-tap grids and cube mapping.\n    Was just a fun exercise in playing with cube maps\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    75.\n\n#define ZERO (min(iFrame,0))\n// AA 1 = Off/ 2+ = On\n#define AA 1\n\nmat2 rot(float a) { \n    return mat2(cos(a),sin(a),-sin(a),cos(a)); \n}\nfloat hash21(vec2 a){ \n    return fract(sin(dot(a, vec2(27.609, 57.583)))*43768.5453); \n}\n//@iq ALL THE SDFS\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),.0);\n}\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),.0);\n}\n\n//globals s = saved / g = global\nvec3 s_hit,g_hit;\nvec2 s_id,g_id;\nfloat travelspeed = 0.,s_hash,g_hash;\n\n//scales for all things\nconst float scale = 1./.345;\nconst float scale_h = scale*.5;\nconst vec2 s = vec2(scale)*2.;\n\n//positions and rotations\nconst vec2 pos = vec2(.5,-.5);\nconst vec2[4] ps4 = vec2[4](pos.yx,pos.xx,pos.xy,pos.yy);\nconst vec4 rotations = vec4(0.,1.570,3.141,4.712);\n\n// block map\n// 4 tap technique @Shane\nvec2 map(vec3 q3){\n    vec2 res = vec2(1e5,0.);\n\n    q3.xz += vec2(travelspeed,-travelspeed);\n    \n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    float t=1e5, y=1e5;\n\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2. -  ps4[0]/2.;\n        p = q3.xz - ct*s;\n        ip = floor(p/s) + .5;\n        p -= (ip)*s;\n        vec2 idi = (ip + ct)*s;\n\n        float px = sin(idi.x*2.)*.4;\n        float py = cos(idi.y*2.)*.4;\n        float ah = -floor((px+py)*scale)*scale;\n  \n        vec3 q = vec3(p.x,q3.y+9.-ah,p.y);\n\n        // just a box\n        float b = box(q,vec3(scale*.4645))-.125;\n        if(b<t) {\n            t = b;\n            s_id = idi;\n            s_hit = q;\n            s_hash= px+py;\n        }\n  \n    }\n    \n\tif(t<res.x) res = vec2(t,2.);\n\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p);\n        if(abs(t.x)<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.35:t.x;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 getFace(int face, vec3 p, inout vec3 mask) {\n    vec2 uv = p.xy;\n    float px = fwidth(uv.x)*.5;\n    uv = uv/scale_h;\n\n    vec3 color = vec3(.5);\n\n    \n    vec2 grid_uv = fract(uv)-.5;\n    vec2 grid_id = floor(uv);\n    \n    float rnd = hash21(grid_id+g_id);\n    if(rnd>.5) grid_uv.x*=-1.;\n\n    vec2 d2 = vec2(length(grid_uv-.5),length(grid_uv+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid_uv-.5):vec2(grid_uv+.5);\n\n    float fm = box(uv,vec2(scale_h*.5))-.075;\n    float fx = fm;\n    fm=abs(fm)-.025;\n\n    fm=smoothstep(px,-px,fm);\n    fx=smoothstep(px,-px,fx);\n    color=mix(color,vec3(.05),fx);\n\n    float circle = length(gx)-.5;\n    circle=abs(circle)-.125;\n\n    mask=vec3(circle,fm,fx);\n    circle=smoothstep(px,-px,circle);\n    color = mix(color, vec3(.15),circle);\n\n    return vec3(1.-color);\n}\n\n// based on bmp mapping from @Passion\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face, inout vec3 mask){\n    vec2 e = vec2(per*MIN_DIST, 0);  \n    mat3 m = mat3( \n        getFace(face, p - e.xyy,mask), \n        getFace(face, p - e.yxy,mask), \n        getFace(face, p - e.yyx,mask)\n    );\n    vec3 g = vec3(.299,.587,.114) * m; \n    g = (g-dot(getFace(face, p,mask),vec3(.299,.587,.114)))/e.x; \n    g -= n*dot(n,g);  \n    return normalize(n+g*bf);\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 4.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.0029/.27; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\nconst vec3 FC = vec3(0.059,0.090,0.102);\n\nvec3 hue(float t){ return .54 + .45*cos(PI2*t*(vec3(.95,.97,.98)+vec3(0.471,0.878,0.063))); }\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    bool hit = false;\n\n    vec2 ray = marcher(ro,rd,p, hit, 85);\n    d = ray.x;\n    m = ray.y;\n    g_hit = s_hit;\n    g_id = s_id;\n    g_hash=s_hash;\n    \n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-18.*sin(T*.1),11,8.*cos(T*.1));\n        vec3 l = normalize(lpos);\n        \n        float rhash= hash21(g_id.yx);\n \n        vec3 h = vec3(.45);\n        vec3 clr = hue((rhash*3.44)*.46);\n        \n        vec3 hp = g_hit;\n        vec3 tn = n;\n        \n        vec3 cuv;\n        int face;\n        \n        if(m==2.){\n            tn = n;\n            //@Shane https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n\n            // set coords\n            if(face==0) cuv = hp.yzx;\n            if(face==1) cuv = hp.zxy;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.xzy;\n            if(face==5) cuv = hp.yzx;\n\n            // get bump map surface\n            vec3 mask = vec3(0);\n\n            n=doBumpMap(cuv,n,.5,d,face,mask);\n            vec3 txt = vec3(.7);\n            vec3 dtr = texture(iChannel1,(cuv.xy*.5)-.5).rgb*vec3(.815,.812,.839);\n            vec3 otr = texture(iChannel0,cuv.xy*.5).rgb;\n            vec3 bse = rhash>.8?clr:dtr;\n            vec3 sqr = vec3(.001);\n            vec3 pth = rhash>.8?clr*dtr:vec3(0.902);\n            \n            float mx =abs(mask.x+.05)-.05;\n            mask.x=smoothstep(.011,.01,mask.x);\n            mx=smoothstep(.011,.01,mx);\n            \n            h=mix(otr,bse,mask.z>.5?1.:0.);\n            h=mix(h,pth,mask.x>.5?1.:0.);\n            h=mix(h,sqr,min(1.-mask.x,mask.y)>.5?.8:0.);\n     \n            ref =min(1.-mask.x,mask.z)>.5? h:vec3(.0001);\n        }\n        \n        float diff = clamp(dot(n,l),.25,.95);\n        float ao = calcAO(p,n);\n        float shdw = 1.;\n        //@Shane - softshadows\n        for( float t=.01;t<10.; ) {\n            float h = map(p + l*t).x;\n            if(h<MIN_DIST) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if(shdw<MIN_DIST||t>12.)break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n        \n        float spec = .65 * pow(max(dot(normalize(p-ro),reflect(l,n)),.2),24.);\n\n        RC = (h*diff) + min(spec,shdw)*ao;\n\n        ro = p+n*.05;\n        rd = reflect(rd,n);\n\n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nvec3 render( vec2 uv, in vec2 F ) {\n\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv, -1.));\n\n    // mouse //\n    float x = M.xy==vec2(0)||M.z<0. ? .07+.02*sin(T*.1) : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0)||M.z<0. ? 0. : -(M.x/R.x*2.-1.)*PI;\n    \n    mat2 rx =rot(-.68+x);\n    mat2 ry =rot(.58+y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0),RC=vec3(0),ref=vec3(0),fill=vec3(1),p = ro;\n    float d = 0., fA = 0.;\n    \n    // reflection loop + stop unroll\n    for(int i = 0; i < 2 + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,2-i,d);\n        C = mix(C,clamp(C+RC,vec3(0),vec3(1)),fill);\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    // fog dusting\n    C = mix(C,FC, 1.-exp(-.0000125*fA*fA*fA));\n    return C;\n}\n\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    travelspeed = T;\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n\n        vec3 color = render(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.0);\n}\n//end", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSczz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[616, 616, 635, 635, 686], [687, 687, 708, 708, 776], [777, 796, 822, 822, 907], [908, 908, 934, 934, 1010], [1402, 1441, 1459, 1459, 2237], [2239, 2239, 2312, 2312, 2585], [2587, 2587, 2636, 2636, 3387], [3389, 3468, 3548, 3548, 3892], [3894, 3894, 3924, 3924, 4117], [4119, 4131, 4166, 4166, 4381], [4425, 4425, 4443, 4443, 4518], [4520, 4520, 4603, 4603, 7233], [7235, 7235, 7270, 7270, 8018]], "test": "untested"}
{"id": "flScRh", "name": "2d and 3d wall", "author": "jorge2017a2", "description": "2d and 3d wall", "tags": ["2dand3dwall"], "likes": 11, "viewed": 252, "published": 3, "date": "1649103702", "time_retrieved": "2024-07-30T16:55:22.328317", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,101.0));\n   \n    //float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    //float planeDist4 = 30.0-p.x;  //pared der\n    //float planeDist5 = -p.z+40.0;  //pared frente\n    //float planeDist6 = p.z+40.0;  //pared atras\n    p.z= opRep1D( p.z, 30.0 );\n    float d1= sdBox(p-vec3(-10.0,3.0,0.0), vec3(2.5,3.0,3.0) );\n    res =opU2(res, vec2(d1,2.0)); \n    res =opU2(res, vec2(planeDist3,100.0)); \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    \n    float shadow = getSoftShadow(worldPos, L);// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/64., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\t\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50) { colobj=getColor(int( id_color));  return colobj; }\n    \n    if (id_color==100 )\n   { p=p-vec3(0.0,-30.0,-30.0);\n       return  getColorTextura( p, nor,100); }\n       \n   if (id_color==101 )\n   {  p=rotate_y(p,1.57);return  getColorTextura( p, nor,101); }    \n       \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));        \n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 130.0, 0.0); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 50.0, 0.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0,-30.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(-58.5));\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}", "buffer_a_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n///#define S2(d,b) smoothstep(8.0*antialiasing(10.5),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(8.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nvec3 figuraPasto(vec2 p, vec3 colOut)\n{   p.x= opRep1D(p.x, 4.0 );\n    float d1= sdCircle(p, 2.0 );\n    float d2=sdBox( p-vec2(0.0,-1.5),vec2(3.0,1.0) );\n    d1= differenceSDF(d1, d2);\n    vec3 col= DrawFigBorde(vec3(0.36,0.63,0.24), colOut, d1 );\n    return col;\n}\n\n\nvec3 figuraArbol(vec2 p, vec3 colOut)\n{   p.x= opRep1D(p.x, 8.0 );\n    float d1= sdCircle(p-vec2(0.0,6.0), 2.0 );\n    float d2=sdBox( p-vec2(0.0,2.4),vec2(0.3,2.5) );\n    colOut= DrawFigBorde(vec3(0.6,0.83,0.4), colOut, d1 );\n    colOut= DrawFigBorde(vec3(0.86,0.63,0.24), colOut, d2 );\n    return colOut;\n}\n\n\nvec3 figuraNube(vec2 p, vec3 colOut)\n{   float res=9999.9;\n    p.y-=8.0;\n    p.x+=4.0;\n    \n    for(int i=0;i<4;i++)\n    {   float d1= sdCircle(p+vec2(float(i)*2.0,0.0 ), 2.0 );\n        res=unionSDF(res, d1);\n    }\n    colOut= DrawFigBorde(vec3(1.0), colOut, res );\n    return colOut;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv-=vec2(0.0,0.5);\n    float esc=8.0;\n    uv*=esc;\n \tuv.x *= iResolution.x/iResolution.y;\n     uv*=vec2(1.0,4.0);\n    vec3 col=vec3(0.56,0.83,0.96)*(0.8+0.2*sin(iTime*1.5));\n    uv= rotatev2(uv,radians(90.0));\n    col=figuraNube(uv-vec2(0.0,2.5), col);\n    col=figuraArbol(uv, col);\n    col=figuraPasto(uv, col);\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "//#define PI 3.141592653589793\n//https://www.glslsandbox.com/e#77209.0\nfloat circleWave(float t) {\n\tfloat d=0.5;\n\tfloat st   = sin(d * PI / 2.0);\n \tfloat p    = (mod(t * 4.0, 2.0) - 1.0) * st;\n\tfloat a    = sqrt(1.0 - pow(p,  2.0));\n  \tfloat amax = sqrt(3.0 - pow(st, 2.0));\n  \tfloat b    = sign(mod(t, 1.0)  - 053655.5);\n  \treturn -b * (a - amax) / (2.0 - amax);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 position = ( fragCoord.xy / iResolution.xy );\n    position= rotatev2(position,1.57);\n    \n\tfloat pp = position.y+0.2*circleWave(position.x*3.0);\n\tfloat s = 0.5+0.5*sin(pp*40.0);\n\n\ts=step(0.5,s);\n\tvec3 col;\n    if(s>0.0)\n     col=vec3(0.0,0.5,0.0);\n    else\n     col=vec3(0.0,0.85,0.0);\n   fragColor = vec4(col,1.0);\n}\n", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flScRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 494, 494, 578], [580, 580, 616, 616, 661], [689, 689, 723, 723, 819], [820, 820, 854, 854, 945], [946, 946, 980, 980, 1071], [1074, 1074, 1099, 1099, 1665], [1667, 1667, 1691, 1691, 1853], [1855, 1855, 1903, 1903, 2182], [2184, 2184, 2228, 2228, 2549], [2551, 2551, 2588, 2588, 2845], [2847, 2847, 2937, 2937, 3901], [3904, 3904, 3953, 3953, 4088], [4091, 4091, 4123, 4123, 4320], [4323, 4323, 4393, 4393, 4702], [4704, 4704, 4731, 4731, 4820], [4822, 4822, 4880, 4880, 4928], [4930, 4930, 4953, 4953, 5065], [5067, 5067, 5098, 5098, 5737], [5739, 5739, 5796, 5796, 6264]], "test": "untested"}
{"id": "NtScRh", "name": "Wave thing 293042352", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 14, "viewed": 326, "published": 3, "date": "1649103196", "time_retrieved": "2024-07-30T16:55:23.139149", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(3, 1.5, 3);\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\n\nfloat GetDist(vec3 p) {\n    float m = 1.;\n    float d1 = 10000.;\n    // p.y -= 1.;\n    p.y += 0.05 * (p.x + p.z);\n    for (float i = 0.; i < 5.; i++) {\n        p.xz = abs(p.xz) - m;\n        //p.y += 0.1 * (5.-i) * mlength(p.xz);\n        p.y += 0.05 * cos(10. * p.x) * cos(2. * i * pi / 5. + 24. * length(p.xz) / pi + iTime);\n\n        m *= 0.55;\n        \n        float r1 = 1.25 * m;\n        d1 = -min(d1, length(p.xz) - r1);\n    }\n    \n    float d3 = length(p) - m * 2.;\n    d1 = -min(d1, -d3);\n    \n    return 0.5 * d1;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 3.5);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n       \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(1);vec3(dif);\n        \n        col *= 0.5 + 0.5 * n;\n        \n        float fres = pow(1.+dot(rd, n), 2.); \n        fres = clamp(fres, 0., 1.);\n        col += fres;\n        \n        vec3 e = vec3(0.5);\n        col *= pal(mod(floor(0.25 * p.z + 0.25 * iTime), 2.) + -0. * iTime + 0. * h21(floor(1. * p.xz - 0.1 * iTime)) + mlength(p.xz), e, e, e, 0.5 * vec3(0,1,2)/3.);\n        //col *= col + 0.5;\n        \n    }\n    col = mix(vec3(0.95), col, clamp(4. * exp(-4. * mlength(p.xz)),0.,1.));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtScRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 721], [724, 724, 747, 747, 1246], [1248, 1248, 1291, 1291, 1598], [1600, 1600, 1624, 1624, 1814], [1816, 1816, 1866, 1866, 2057], [2059, 2059, 2116, 2116, 3348]], "test": "untested"}
{"id": "7l2cRz", "name": "paint with swirls 2", "author": "FabriceNeyret2", "description": "paint with mouse. click and drag, or just click.   Shift-click for reverse direction.\nvariant of https://shadertoy.com/fdjyRV\n\nnote that the distortion is done on the uv field.  \nTextures or curves are mapped on  the field afterward.", "tags": ["swirl", "distortion", "vortex", "uvmap", "vorticity", "divergencefree", "viamapping", "viamapping"], "likes": 13, "viewed": 515, "published": 3, "date": "1649092442", "time_retrieved": "2024-07-30T16:55:23.878173", "image_code": "// variant of \"paint with swirls ( div free double-vortex)\" https://shadertoy.com/view/fdjyRV\n// see also \"paint with displacement\" https://www.shadertoy.com/view/sdjyRV\n\n// === applies the uv field to a texture =================\n\n//#define fwidth(v) length(vec2(dFdx(v),dFdy(v)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = T(u).xy;                    // distorted uv field\n    O = texture( iChannel1, u );    // apply map\n    \n    float v = length(u-.5);         // apply circle\n    O = mix( O, vec4(1,0,0,0), smoothstep( 1.5, 0.,  abs(v-.3)/fwidth(v) ) );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === distort the uv field ====================\n\n#define ortho(D)     vec2( -(D).y, (D).x )              // vec ortho to D\n// #define S(D)      ortho(D) / max( dot(D,D) , 1e-3 )  // irrotational swirl\n#define S(D)         ortho(D) / max( length(D)*smoothstep(0.,3.,length(D)) , 1e-3 )  // irrotational swirl\n#define keyDown(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                                           // previous state\n    if ( u== vec2(.5) )                                 // previous mouse pos\n      { if ( T(0).xy != iMouse.xy ) O = vec4(iMouse.xy,T(0).xy); return; } \n      \n    vec2 U = u / R.y,\n         M = iMouse.xy / R.y,\n         V = .01 * S(U-M)                                // swirl field\n             * ( keyDown(16) ? -1. : 1. );              // shift-click = reverse direction\n    if (iMouse.z > 0.)                                  // if click, swirl\n        O = texture( iChannel0, ( U + .1*V/60. ) *R.y/R );\n    \n    if ( iFrame < 1 ) O = vec4(u/R,0,0);                // init uv field\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R      iResolution.xy\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2cRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 320, 320, 564]], "test": "untested"}
{"id": "stjcRz", "name": "Euler Daisies", "author": "eiffie", "description": "Euler daisies", "tags": ["eulerspirals"], "likes": 15, "viewed": 327, "published": 3, "date": "1649089543", "time_retrieved": "2024-07-30T16:55:24.619191", "image_code": "//Euler Daisies by eiffie \n//This is just a tweak of the taxi spirals shader trying to create a totally different feel.\nvoid mainImage(out vec4 O, in vec2 U){O=texture(iChannel0,U/iResolution.xy);}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define rez iResolution.xy\n#define Pi 3.14159263\n#define DIV 500\n#define PER 25\nvec4 load(float x, float y){return texture(iChannel0,vec2(x+.5,y+.5)/rez.xy);}\nvec4 cmap(float a){return abs(vec4(sin(a),sin(a+.4),sin(a+1.4),0.));}\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nvoid mainImage(out vec4 O, in vec2 U){\n  O=texture(iChannel0,U/rez.xy);\n  U=floor(U);\n  vec4 L=load(0.,0.);\n  int mf=DIV*2,f=(PER*iFrame) % mf;\n  float s=floor(float(iFrame*PER)/float(mf)),q=(s+1.)/float(DIV);\n  if(f==0){//setup new doodles\n    if(iFrame==0)O=vec4(0);\n    if(U.x+U.y==0.){\n      if(iFrame==0)O=vec4(-15.,0.,15.,0.);\n      if(length(O.xy)>20.)L.xy=O.xy=vec2(-15.,0.);else L.y=O.y-=.25;\n      if(length(O.zw)>20.)L.zw=O.zw=vec2(15.,0.);else L.z=O.z-=.25;\n    }\n  }\n  vec2 p1=L.xy,p2=L.zw,nv,u=20.*(2.*U-rez.xy)/rez.y;\n  float a,d1=1.,d2=1.,q2=(s+1.)/float(DIV+2);\n  for(int i=0;i<PER;i++){\n    float n=float(f+i+1);\n    a=2.*Pi*fract((n-1.)*fract(q*(n-1./5.)));\n    nv=vec2(cos(a),sin(a));\n    d1=min(d1,tube(u-p1,nv));\n    p1+=nv;\n    a=2.*Pi*fract((n-1.)*fract(q2*(n-2./3.)));\n    nv=vec2(cos(a),sin(a));\n    d2=min(d2,tube(u-p2,nv));\n    p2+=nv;\n  }\n  if(U.x+U.y==0.){O=vec4(p1,p2);}//logic pixel\n  else {//draw\n    O=mix(O,vec4(-.25,0,.25,0),0.005);\n    d1=smoothstep(40./rez.y,0.,d1);d2=smoothstep(40./rez.y,0.,d2);\n    O=mix(O,cmap(s),d1);\n    O=mix(O,cmap(s+.7),d2);\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi 3.14159\nint N[8]=int[8](0,4,5,7,5,2,4,0);\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian +minor 3rd \n return note; \n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n} \nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t, vec3 p, vec4 e, vec4 d){\n  float bt=t,t2,t3,t4,f=ntof(n);\n  if(f==0.)return vec2(0);\n  t-=t*d.y*sin((d.w*pi+t)*pi*d.z);t3=t*d.x;\n  t2=fract(t*p.y*f);t4=fract(t3*p.y*f);\n  t=fract(t*f);t3=fract(t3*f);\n  float amp=abs(1.+sin(bt*e.z*pi)*e.w)*exp(-bt*e.y)*(1.0-exp(-bt*e.x))*min(1.,100.-bt*100.);\n  return amp*rot(vec2(sin(pow(t,p.x)*pi*2.+pi*2.*p.z*sin(pow(t2,p.x)*pi*2.)),\n    sin(pow(t3,p.x)*pi*2.+pi*2.*p.z*sin(pow(t4,p.x)*pi*2.))),float(n)+bt*pi*2.);\n}\nvec2 Sound(float time, float bps){\n//return vec2(sin(time*500.));\n  float tim=mod(time*bps,256.);\n  //float m=pow(fract(fract(tim+.5)*1.125),20.);tim+=sin(m);\n  float bt=floor(tim),t=fract(tim);\n  int n1=N[int(bt/64.)];\n  int n0=n1+N[int(bt/8.)%8],n=n0+N[int(bt)%8],n2=n0+N[int(bt/2.)%8],n4=n0+N[int(bt/4.)%8];\n  vec2 v=I(n+24,t,vec3(1.-t*.5,1.,t),vec4(10.,1.0,12.,t*.3),vec4(1.014,0.005,1.,.5))*.25;\n  t=fract(tim/2.);\n  float fo=pow(1.-t,2.0);\n  v+=I(n2+36,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,24.,t*.8),vec4(1.014,0.005,1.,.5));\n  \n  t=fract(tim/4.);\n  fo=pow(1.-t,2.0);\n  v+=I(n4+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,36.,t*.8),vec4(1.014,0.005,1.,.5))*.75;\n  v+=I(n4+57,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,36.,t*.8),vec4(1.014,0.005,1.,.5))*.5;\n  \n  t=fract(tim/8.);\n  fo=pow(1.-t,2.0);\n  v+=I(n0+36,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,2.0,48.,t*.8),vec4(1.014,0.005,1.,.5))*.25;\n  return v*.1;\n}\nvec2 mainSound(int samp, float time){\n  return Sound(time+0.03125,6.)-Sound(time,12.).yx*.5;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 120, 158, 158, 197]], "test": "untested"}
{"id": "7ljyRz", "name": "Taxi Spirals", "author": "eiffie", "description": "When they want to pad the meter.", "tags": ["taxidistance"], "likes": 11, "viewed": 288, "published": 3, "date": "1649088778", "time_retrieved": "2024-07-30T16:55:25.360210", "image_code": "//Taxi Spirals by eiffie \n//Similar to euler spirals but with taxi rotation and a weird angle formula.\n//So yeah not similar to euler spirals much.\n#define time iTime\n#define rez iResolution.xy\n\nvoid mainImage(out vec4 O, in vec2 U){\n  O=texture(iChannel0,U/rez.xy)\n   +texture(iChannel0,(U/rez.xy)/(.1+iTime*.5)-vec2(sin(iTime)*.1+.5,iTime))*iTime*.002;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//choose a trig based on the definition of length\n#define TAXICAB\n#ifdef EUCLIDEAN\n #define Pi 3.14159263\n #define dSin cos\n#endif\n#ifdef TAXICAB\n #define Pi (2.0*SQRT2)\n #define dSin t_dSin\n#endif\n#ifdef STOPSIGN\n #define Pi 4\n #define dSin o_dSin\n#endif\n//DIV is the divisor of the delta where angle+=delta*step*2pi, the numerator is animated\n#define DIV 500\n//PER is the number of line segments to draw per frame\n#define PER 10\n#define rez iResolution.xy\nconst float SQRT2=sqrt(2.);\n//the derivative of sin is the change in y with respect to the angle\nfloat t_dSin(float a){a=mod(a-.5*Pi,2.*Pi);return (a<Pi?-.5:.5);}\nfloat o_dSin(float a){a=floor(mod(a+.5,2.*Pi));return cos(a*.785398);}\nfloat dCos(float a){return dSin(a-Pi/2.);}//the change in x is just a 1/4 turn\nvec4 load(float x, float y){return texture(iChannel0,vec2(x+.5,y+.5)/rez.xy);}\nvec4 cmap(float a){return abs(vec4(sin(a),sin(a+.4),sin(a+1.4),0.));}\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nvoid mainImage(out vec4 O, in vec2 U){\n  O=texture(iChannel0,U/rez.xy);\n  U=floor(U);\n  vec4 L=load(0.,0.);\n  int mf=DIV*2,f=(PER*iFrame) % mf;\n  float s=floor(float(iFrame*PER)/float(mf)),q=(s+1.)/float(DIV);\n  if(f==0){//setup new doodles\n    if(iFrame==0)O=vec4(0);\n    if(U.x+U.y==0.){\n      if(iFrame==0)O=vec4(-15.,0.,15.,0.);\n      if(length(O.xy)>20.)L.xy=O.xy=vec2(-15.,0.);else L.y=O.y-=.25;\n      if(length(O.zw)>20.)L.zw=O.zw=vec2(15.,0.);else L.z=O.z-=.25;\n    }\n  }\n  vec2 p1=L.xy,p2=L.zw,nv,u=20.*(2.*U-rez.xy)/rez.y;\n  float a,d1=1.,d2=1.,q2=(s+1.)/float(DIV+2);\n  for(int i=0;i<PER;i++){\n    float n=float(f+i+1);\n    a=Pi*q*.5+2.*Pi*fract((n-1.)*fract(q*(n-.5)));\n    nv=vec2(dSin(a),dCos(a));\n    d1=min(d1,tube(u-p1,nv));\n    p1+=nv;\n    a=Pi*q2*.5+2.*Pi*fract((n-1.)*fract(q2*(n-.5)));\n    nv=vec2(dSin(a),dCos(a));\n    d2=min(d2,tube(u-p2,nv));\n    p2+=nv;\n  }\n  if(U.x+U.y==0.){O=vec4(p1,p2);}//logic pixel\n  else {//draw\n    O*=.995;\n    //O=mix(O,vec4(-.25,0,.25,0),0.005);\n    d1=smoothstep(40./rez.y,0.,d1);d2=smoothstep(40./rez.y,0.,d2);\n    O=mix(O,cmap(s),d1);\n    O=mix(O,cmap(s+.7),d2);\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi 3.14159\nint N[8]=int[8](0,3,5,7,5,2,3,0);\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.); \n if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian +minor 3rd \n return note; \n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n} \nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t, vec3 p, vec4 e, vec4 d){\n  float bt=t,t2,t3,t4,f=ntof(n);\n  if(f==0.)return vec2(0);\n  t-=t*d.y*sin((d.w*pi+t)*pi*d.z);t3=t*d.x;\n  t2=fract(t*p.y*f);t4=fract(t3*p.y*f);\n  t=fract(t*f);t3=fract(t3*f);\n  float amp=abs(1.+sin(bt*e.z*pi)*e.w)*exp(-bt*e.y)*(1.0-exp(-bt*e.x))*min(1.,100.-bt*100.);\n  return amp*rot(vec2(sin(pow(t,p.x)*pi*2.+pi*2.*p.z*sin(pow(t2,p.x)*pi*2.)),\n    sin(pow(t3,p.x)*pi*2.+pi*2.*p.z*sin(pow(t4,p.x)*pi*2.))),float(n)+bt*pi*2.);\n}\nvec2 Sound(float time, float bps){\n//return vec2(sin(time*500.));\n  float tim=mod(time*bps,256.);\n  float m=pow(fract(fract(tim+.5)*1.125),20.);tim+=sin(m);\n  float bt=floor(tim),t=fract(tim);\n  int n1=N[int(bt/64.)];\n  int n0=n1+N[int(bt/8.)%8],n=n0+N[int(bt)%8],n2=n0+N[int(bt/2.)%8],n4=n0+N[int(bt/4.)%8];\n  vec2 v=I(n+24,t,vec3(1.-t*.5,1.,t),vec4(10.,1.0,12.,t*.3),vec4(1.014,0.005,1.,.5))*.25;\n  t=fract(tim/2.);\n  float fo=pow(1.-t,2.0);\n  v+=I(n2+36,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,24.,t*.8),vec4(1.014,0.005,1.,.5));\n  \n  t=fract(tim/4.);\n  fo=pow(1.-t,2.0);\n  v+=I(n4+48,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,36.,t*.8),vec4(1.014,0.005,1.,.5))*.75;\n  v+=I(n4+57,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,4.0,36.,t*.8),vec4(1.014,0.005,1.,.5))*.5;\n  \n  t=fract(tim/8.);\n  fo=pow(1.-t,2.0);\n  v+=I(n0+36,t,vec3(1.-fo*.5,1.5,fo),vec4(10.,2.0,0.,t*.8),vec4(1014.014,0.005,1.,.5));\n  return v*.1;\n}\nvec2 mainSound(int samp, float time){\n  return Sound(time+0.03125,4.)-max(sin(pi*time/64.)*.5+time*.006,0.0)*Sound(time,8.).yx;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 233, 233, 356]], "test": "untested"}
{"id": "7ljcRR", "name": "Simple Wave 293402358720", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 11, "viewed": 269, "published": 3, "date": "1649082418", "time_retrieved": "2024-07-30T16:55:26.183010", "image_code": "#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 4.5;\n    uv.x += 0.5 * iTime;\n    float sc = 4.;\n    \n    float ix = floor(sc * uv.x) + 0.;\n    float fx = fract(sc * uv.x) - 0.5;\n    \n    float h = 3. * cos((0.2 * uv.x + 0.8 * ix/sc) - 2. * iTime);\n    //h += 3. * (h21(vec2(-7. * ix, 3. * ix + 101.)) - 0.);\n    \n    float m = mod(ix, 2.) - 0.5;\n    \n    float r = (sc + 1. * h) * m;\n    \n    float k = 4. * sc /  iResolution.y;\n    float s = smoothstep(-1.4, 1.4, -sc * uv.y + r);\n    \n    vec2 uv2 = vec2(fx, sc * uv.y - r);\n    \n    s += 2. * m * smoothstep(-k, k, -length(uv2) + 0.5);\n   \n    \n    vec3 col = vec3(s);\n    vec3 e = vec3(0.5);\n    col += pal(1.1 * ix/sc,e,e,e,vec3(0,1,2)/3.) * exp(-2. * (-0.14 * h + uv.y + 1.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.0001)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.03;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 877]], "test": "untested"}
{"id": "7tfcRj", "name": "Dream like Stylized Sobel Edge", "author": "NakedBowman", "description": "Stylized sobel edge detection, still a work in progress", "tags": ["sobel", "edge", "dream", "styalized"], "likes": 10, "viewed": 485, "published": 3, "date": "1649077452", "time_retrieved": "2024-07-30T16:55:27.009800", "image_code": "float greyScale(vec3 color){\n    return (color.r + color.g + color.b) / 3.0;\n\n\n}\nvec3 post(vec3 color){\n    return floor(color*15.+0.5)/15.;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float[9] Xsobel_kernel =\n    float[](-1.0, 0.0, 1.0,\n            -2.0, 0.0, 2.0,\n            -1.0, 0.0, 1.0);\n            \n    float[9] Ysobel_kernel =\n    float[](-1.0, -2.0, -1.0,\n            0.0, 0.0, 0.0,\n            1.0, 2.0, 1.0);\n            \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 og = texture(iChannel2, uv).rgb;\n    og = pow(og,vec3(1./2.2));\n    og = post(og);\n    vec3 pat = mix(vec3(0.4,0.2,0.4), vec3(0.5,0.7,0.8), uv.x+uv.y);\n    og = mix(pat, og, greyScale(og)*2.2);\n    \n    float threshold = .14;\n    float Xedge = 0.;\n    float Yedge = 0.;\n    float kernelPointer = 0.;\n    for(float x = 0.0; x < 3.0; x++){\n        for(float y = 0.0; y < 3.0; y++){\n            float result = greyScale(texture(iChannel0, uv+vec2(x-1.,y-1.)/iResolution.xy).rgb);\n            Xedge += result * Xsobel_kernel[int(kernelPointer)];\n            kernelPointer++;\n        }\n    }\n    kernelPointer = 0.;\n    for(float x = 0.0; x < 3.0; x++){\n        for(float y = 0.0; y < 3.0; y++){\n            float result = greyScale(texture(iChannel0, uv+vec2(x-1.,y-1.)/iResolution.xy).rgb);\n            Yedge += result  * Ysobel_kernel[int(kernelPointer)];\n            kernelPointer++;\n        }\n    }\n   \n   //remapping values\n  //Xedge += 0.5;\n  //Yedge += 0.5;\n   float finalG = sqrt(Xedge*Xedge + Yedge*Yedge);\n   if(finalG < threshold){\n       finalG = 0.; \n   }\n    \n  \n\n   float edgeOrientation = atan(Yedge/Xedge);\n   float g = edgeOrientation;\n   vec3 col = vec3(finalG);\n    \n    fragColor = vec4(og-col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float kernelSize = 6.;\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < kernelSize; i++){\n        float pointer = i - floor(kernelSize * 0.5);\n        col += texture(iChannel0, uv + vec2(i,0.0)/iResolution.xy ).rgb;\n    }\n    col/= kernelSize;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float kernelSize = 6.;\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < kernelSize; i++){\n        float pointer = i - floor(kernelSize * 0.5);\n        col += texture(iChannel0, uv + vec2(0.0,i)/iResolution.xy ).rgb;\n    }\n    col/= kernelSize;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float kernelSize = 20.;\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < kernelSize; i++){\n        float pointer = i - floor(kernelSize * 0.5);\n        col += textureLod(iChannel0, uv + vec2(i,0.0)/iResolution.xy,3. ).rgb;\n    }\n    col/= kernelSize;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float kernelSize = 20.;\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < kernelSize; i++){\n        float pointer = i - floor(kernelSize * 0.5);\n        col += textureLod(iChannel0, uv + vec2(0.0,i)/iResolution.xy, 3. ).rgb;\n    }\n    col/= kernelSize;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 80], [81, 81, 103, 103, 143]], "test": "untested"}
{"id": "7tsyDs", "name": "nice flowers", "author": "curiouspers", "description": "nice right?\n\nplease teach me how to do this with domain bending and not in cycles\n\nalso code is not cleaned up", "tags": ["procedural", "3d", "raymarching", "sdf", "tutorial", "tutorial", "youtube", "live", "live", "maths", "stream", "livestream"], "likes": 20, "viewed": 544, "published": 3, "date": "1649068077", "time_retrieved": "2024-07-30T16:55:27.762787", "image_code": "// Fork of \"TUT  Sphere Gears\" by iq. https://www.shadertoy.com/view/tt2XzG\n// 2022-04-03 09:00:38\n\n// Created by curiouspers - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part 1: https://www.youtube.com/watch?v=sl9x19EnKng\n// Part 2: https://www.youtube.com/watch?v=bdICU2uvOdU\n\n\n#define AA 1  // Set AA to 2 if you have 3090ti and 720p display\n\n#define TAU 6.283185\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}  \n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad )\n{\n    ro -= cen;\n    float b = dot(rd, ro);\n    float c = dot(ro,ro) - rad*rad;\n    float h = b*b - c;\n    if ( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    \n    return vec2( -b-h, -b+h );\n}\n             \n             \n//----------------------------------\n\n\nvec2 rot( vec2 v )\n{\n    return vec2(v.x-v.y,v.y+v.x)*0.707107;\n}\n\nfloat remap(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec4 flower( in vec3 p, float time, float mat, float segments, vec3 rotation, float ra1, float rb, float h )\n{\n    \n    //p = fract(p*0.02);\n    vec4 d = vec4(1.);\n    float t = time;\n    \n    //float segments = 8.;\n    p.yz *= Rot(rotation.x);\n    p.xz *= Rot(rotation.y);\n    p.xy *= Rot(rotation.z);\n    \n    // please teach me how to do this with domain bending and not in cycles\n    float leafsPeriod = TAU/32.;\n    for (float j = 0.; j < 1.; j += 1./segments){\n        t+=j*0.5;\n        vec3 ppp = p;\n        ppp.xz *= Rot(j*TAU);\n        ppp.x -= 0.2;\n        //float leaf = 0.;\n        for (float i = leafsPeriod*1.; i < TAU/2.6; i += leafsPeriod){\n            //leaf++;\n            vec3 pp = ppp;\n            //pp.yz *= Rot((i+1.) * .1);\n\n            pp.xy *= Rot(i );\n            //pp.xy *= Rot(0.1);\n            pp.xy *= Rot(fract(t)*leafsPeriod);\n\n            float ra = ra1;\n            \n            //ra = sin(t*0.)*ra*0.5 + 0.6*ra;\n            //float tt = abs(fract(t*1.)*2.-1.);\n            //ra += tt*ra*i;\n            //ra += ra*i;\n            \n            pp.x += ra+0.1;\n            //pp.y -= 0.03*i;\n            pp.x += pow(abs(pp.z),1.5); // bend the leaf at center\n            pp.xy *= Rot(0.9);\n\n            //float halfWay = TAU/2.5/2.;\n            //float cur = i / halfWay;\n            //float inc = (i < halfWay) ? ra*0.25 : -ra*0.25;\n            float inc = ra*1.25 ;\n            ra = ra + mix(i*inc, (i+leafsPeriod)*inc, fract(t));\n            //ra = ra<0.08 ? ra : mix(ra, 0.04*(i+leafsPeriod), fract(t)); // try to shrinj last leafs\n            //ra = ra<0.08 ? 0. : ra;\n            \n            //ra = ra + mix(leaf*inc, (leaf+1.)*inc, fract(t)*leafsPeriod);\n            pp.x += mix(i*inc*2., (i+leafsPeriod)*inc*2., fract(t));\n            \n            //pp.y += (1.-i)*0.1;\n\n            //pp.y += fract(t);\n            //pp.x += t;\n            pp.x *= 0.45;\n            \n            //float r1 = 0.003;\n            //float r2 = 0.008;\n            //float rb = r1;//mix(r1, r2, fract(t) * i / TAU);\n            //float h = 0.001;\n            d = min(d, vec4(sdRoundedCylinder(pp, ra, rb, h), vec3(1.)));\n        }\n    }\n    d.w = mat;\n    return d;\n}\nvec4 map( in vec3 p, float time )\n{\n    time *= .75;\n    vec3 p1 = p+vec3(0.18, 0.19, -0.8);\n    vec4 d = flower(p1, time, 1., 8., vec3(0.0,0.2,0.), 0.025, 0.003, 0.001);\n    \n    p1 = p+vec3(0.98,0.35,0.50);\n    vec4 t = flower(p1, 1.-time, 2., 6., vec3(-0.32,0.12,0.2), 0.04, 0.009, 0.001);\n    if( t.x<d.x ) d=t;\n    \n    //p *= 0.7;\n    p1 = p+vec3(-0.83,0.25,0.1);\n    t = flower(p1, 1.-time, 3., 9., vec3(-0.2,-0.10,-0.3), 0.025, 0.01, 0.000);\n    if( t.x<d.x ) d=t;\n    \n\treturn d;\n}\n\n#define ZERO min(iFrame,0)\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float time )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ).x );\n#else\n    // klems's trick to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    vec2 vol = iSphere( ro, rd, vec3(0., 0., 0.), 1.9);\n    if ( vol.y > 0.0)\n    {\n        // raymarch\n        float t = max(0.0,vol.x);\n        for( int i=0; i<128 && t<vol.y; i++ )\n        {\n            vec4 h = map(ro+t*rd,time);\n            if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5+0.5*sin(fragCoord.x*111.0)*sin(fragCoord.y*331.543);\n        float time = iTime - 1.0*(1.0/48.0)*(float(m*AA+n)+d)/float(AA*AA);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n        time *= 0.5;\n        \n\t    // camera\t\n        //float an = 6.2831*time/40.0;\n        //vec3 ta = vec3( 0.0+cos(time*2.12)*0.03, cos(time*2.23)*0.05, cos(time*3.8)*0.03 );\n        //vec3 ro = ta + vec3( 1.3*cos(an), 0.5, 1.2*sin(an) );\n        //vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        //vec3 ro = ta + vec3( 0.00, 0.8, 1.2 );\n        vec3 ta = vec3(0.);//vec3( 0.0+cos(time*2.12)*0.005, cos(time*2.23)*0.005, cos(time*3.8)*0.005 );\n        // good camera angle\n        vec3 ro = ta + vec3( 0.1, 0.8, 1.2 );\n        //vec3 ro = ta + vec3( 0.5, 1.3, 1. );\n        \n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n        \n        // background\n        vec3 col = vec3(.92+rd.y)*0.8;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n            \n            #if 1\n            vec3 te = 0.5*texture( iChannel0, tuvw.yz*2.0 ).xyz+\n                      0.5*texture( iChannel0, tuvw.yw*1.0 ).xyz;\n            vec3 mate = 0.92*te;\n            #else\n            vec3 mate = vec3(1.);\n            #endif\n            \n            if (tuvw.w < 2.){\n                //mate =  tuvw.xyz*1.3-vec3(0.3,0.0,0.0);//tuvw.xyz;//vec3(1.000,1.000,1.000); // vec3(0.996,0.498,0.282);\n                // purple - dark blue\n                mate *= mix (vec3(0.3,0.0,0.0),vec3(1.,1.,0.6), tuvw.xyz-vec3(0.8,0.9,0.)) * 4.;\n            } else if (tuvw.w < 3.){\n                // golden - green\n                mate *= mix (vec3(0.3,0.03,0.0),vec3(1.,1.,0.0), tuvw.xyz-vec3(0.5,0.9,0.)) * 4.5 + .2;\n            } else if (tuvw.w < 4.){\n                // light blue\n                //mate = mix (vec3(0.1,0.03,0.2),vec3(0.0,2.,1.0), tuvw.xyz-vec3(1.0,0.7,0.0)) * 1.9;\n                // red velvet\n                mate *= mix (vec3(1.000,1.000,.0),vec3(1.500,0.1,0.1), tuvw.xyz-vec3(0.0,0.,0.0)) * 4.;\n            }\n            float len = length(pos);\n            // coloring center\n            //mate = mix( mate, vec3(1.0,.4,.2), 1.0-smoothstep(0.12,0.123,len) );\n            \n            \n            vec3 f0 = mate;\n            float ks = 0.5;//clamp(0.5+1.5*te.x, 0.0, 1.0);\n\n            float focc = 1.0;\n            focc = 0.55+0.45*dot( nor, normalize(pos) );\n            focc *= 0.1+0.9*clamp(length(pos)/0.535,0.0,1.0);\n            \n            float occ = calcAO( pos, nor, time ) * focc;\n            \n            #if 0\n                float li1 = 0.5+0.5*nor.y;\n                col = 10.0*li1*mate*occ;\n            #else\n                col = vec3(0.0);\n            #endif\n            \n            // top light\n            {\n                float dif = 0.5+0.5*nor.y;//clamp(\n                //dif *= occ;\n                \n                vec3 ref = reflect(rd, nor);\n                \n                vec3 spe = vec3(1.)*smoothstep(0.5*sqrt(sqrt(focc)),0.9,ref.y);\n                spe *= occ;\n                \n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                spe *= f0 + (1.0-f0)*pow(fre,1.0);\n                spe *= 6.0;\n                \n                //vec3 lcol = vec3(0.7, 0.8, 1.1);\n                vec3 lcol = vec3(1.);\n                \n                col += 0.05*lcol*dif*occ;\n                col += ks*lcol*spe*dif;\n                \n            }\n           \n            // bottom light\n            {\n                float dif = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );\n                col += mate*dif*occ*2.*vec3(3.);//*vec3(0.7, 0.8, 1.1);\n            }\n           \n        }\n        \n        // vignette\n        col *= 1.0 - 0.2*dot(p,p);\n        \n        // gamma        \n\t    tot += pow(col,vec3(0.35) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    // S-curve\n    tot = clamp(tot, 0.0, 1.0);\n    //tot = tot*tot*(3.0-2.0*tot); // same as below\n    tot = smoothstep(0.0,1.0,tot); // make it more contrasty\n    \n    // dither\n    tot += (1.0/512.0)*sin(fragCoord.x*111.0)*sin(fragCoord.y*321.5423);\n    \n    // show banding\n    //tot = floor(tot*255.)/255.;\n    //tot = (abs(dFdy(tot))+abs(dFdx(tot)))*200.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsyDs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[422, 422, 441, 441, 503], [508, 557, 621, 621, 738], [740, 740, 807, 807, 999], [1067, 1067, 1087, 1087, 1132], [1134, 1134, 1208, 1208, 1274], [1276, 1276, 1386, 1416, 3460], [3461, 3461, 3496, 3496, 3951], [3981, 4027, 4074, 4074, 4649], [4651, 4651, 4708, 4708, 4973], [4976, 4976, 5033, 5033, 5418], [5420, 5420, 5472, 5472, 5649]], "test": "untested"}
{"id": "ftjyzR", "name": "Day 6 - Lambmeow (Mixtape)", "author": "lambmeow", "description": "Really liked how this one turned out!", "tags": ["noise", "reflection", "sdf", "cd", "mixtape"], "likes": 13, "viewed": 265, "published": 3, "date": "1649059108", "time_retrieved": "2024-07-30T16:55:28.563645", "image_code": "//Daily Shader Challenge Day 6\n//Ive learned a lot from this one, there are still some issues with the lighting messing with \n//the rotation of the cd but its in a good enough state for now.\n//huge thanks to Alan Zucconi for the CD shader effect (https://www.alanzucconi.com/2017/07/15/the-nature-of-light/)\n//lopea (https://github.com/lopea)\n\n#define CD 0.\n#define BACK -1.\n#define COVER 1.\n\n//#define ALT_COVER\n\n\n#define time iTime\n\n//////////////////////////////////////////////////////////////////////////////\n//a lazy copy-paste from a previous shader i made lmaoooo\n//https://www.shadertoy.com/view/flXGW7\n//////////////////////////////////////////////////////////////////////////////\n\n//IQ's Gradient noise algorithm\n/////////////////////////////////////////////////////////////////////////////\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,331.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec2 a  = random(i);\n    vec2 b = random(i + vec2(1,0));\n    vec2 c = random(i + vec2(0, 1));\n    vec2 d = random(i + vec2(1, 1));\n    \n    vec2 u = f * f * f *(f *(f*6. - 15.)+10.);\n    \n    return mix(mix ( dot( a, f), dot(b, f - vec2(1, 0)), u.x),\n        mix ( dot( c, f-vec2(0,1)), dot(d, f - vec2(1, 1)), u.x), u.y);\n\n}\n/////////////////////////////////////////////////////////////////////////////\n\n//fractal brownian motion\nfloat fbm(vec2 uv)\n{\n    //store the result of the noise texture\n    float result = 0.;\n    \n    //store the current amplitude value\n    float amplitude = 1.;\n    \n    //iterate a few times to give noise a more detailed look\n    for(int i = 0; i < 8; i++)\n    {\n        //add to the result ( with a few modifications\n        result += noise(uv + vec2( time - float(i)  +10., -time/25.- float(i)/2.)) * amplitude;\n        \n        //shrink the noise texture for the next iteration\n        uv *= 2.;\n        \n        //make next noise iteration less potent \n        amplitude *= 0.5;\n    }\n    \n   \n    return result;\n}\n\nvec4 dith(vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n    //set the threshold for color value, will be compared to screen space.\n    float threshold = fbm(vec2(fbm(uv * 10.), fbm(uv * 10. + 3.)));\n    \n    //create the dithering effect by warping the screen coordinates\n    float coord = sin(uv.x * 1000.) * sin(uv.y * 1000.) * .25;\n    \n    //compare warped screen coords to the threshold and create the color value\n    vec3 color = mix(vec3(0, .04, .1), vec3(1,0,.5) , vec3(step(coord, threshold)));\n    \n    //create an outline effect by subracting same algorithm but with a smaller threshold\n    color -= step(clamp(coord, 0., 1.), threshold - .1) * vec3(1);\n    \n    //set the color to the pixel\n    return vec4(color , 1);\n    \n}\n\n//////////////////////////////////////////////////////////////////////////////\n//lazy copy paste ends here\n//////////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////////\n//CD - reflectance equations\n//////////////////////////////////////////////////////////////////////////////\n\n\n//color bump equation\nfloat bump(float x, float a, float o)\n{\n    return -a * (x-o) * (x-o) + 1.;\n}\n\nvec3 spectral(float x)\n{\n    return vec3(\n    bump(x,16., .75),\n    bump(x,8., .5),\n    bump(x,16., .25)\n    );\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//Shape helper functions (thanks iq)\n//////////////////////////////////////////////////////////////////////////////\nfloat cyl(vec3 p,float r , float h)\n{\n    vec2 v = abs(vec2(length(p.xy), p.z)) - vec2(r,h);\n    return length(max(v, 0.)) + min(max(v.x,v.y),0.);\n}\n\nfloat cd(vec3 p)\n{\n    return max(-cyl(p, .1, 0.1), cyl(p, 1., 0.001)) - .01; \n}\nfloat sbx(vec2 p , vec2 o, float r)\n{\n    vec2 v = abs(p) - o;\n    \n    return length(max(v,0.)) + min(max(v.x,v.y),0.) - r;\n}\n\nfloat six(vec2 p)\n{\n    p.x -= .019;\n    float ii = min(sbx(p+vec2(-.11,-0.00), vec2(.016, .02), .002),sbx(p+vec2(-.06,0), vec2(.005, .02), .002));\n    float oo = min(sbx(p+vec2(-.11,-0.03), vec2(.004, .03), .003), min(sbx(p+vec2(-.125,0.045), vec2(.007, .03), .003),\n    sbx(p+vec2(-.095,0.045), vec2(.007, .03), .003)));\n    return abs(max(-oo,ii) * 2.) - 0.001;\n}\n\nfloat cov(vec3 p)\n{\n    p.z -= 0.02;\n    return max(cyl(p, .95, .001), -cyl(p, .2, 0.01)); \n}\n\n//////////////////////////////////////////////////////////////////////////////\n//Rendering functions\n//////////////////////////////////////////////////////////////////////////////\n\nmat2 rot(float a)\n{\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa,sa,ca);\n}\nvec2 ss(vec3 p)\n{\n    p.xz *=  rot(time);\n    p.yz *= rot(radians(35.));\n    \n    //create background \n    vec2 res = vec2(abs(length(p)-50.) -.5, BACK);\n    \n    //add cd\n    float cc = cd(p);\n    res.x = min(cc, res.x);\n    \n    if(cc == res.x) res.y = CD;\n    \n    //add cover\n    float cv = cov(p);\n    \n    res.x = min(res.x, cv);\n    if(res.x == cv)\n        res.y = COVER;\n        \n    return res;\n}\n\n//raytrace\nvec2 rt(vec3 ro, vec3 rd, out vec3 p)\n{\n    vec2 dl = vec2(0);\n    float ll = 0.;\n    for(int i = 0 ; i< 255; i ++)\n    {\n        p = ro + rd * ll;\n        dl = ss(p);\n        ll += dl.x;\n        \n        if(dl.x < 0.001 || ll > 100.)\n            break;\n    }\n    \n    return dl;\n}\n\n//normal\nvec3 nn(vec3 p)\n{\n    vec3 n = vec3(0);\n    for(int i = min(iFrame, 0); i < 4; i ++)\n    {\n        vec3 e = 0.5773* (2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*ss(p +e*0.0001).x;\n    }\n    return normalize(n);\n}\n\nmat3 cam(vec3 p, vec3 la)\n{\n    vec3 ww = normalize(la - p);\n    vec3 uu = normalize(cross(ww, vec3(0,1.,0)));\n    vec3 vv = cross(uu,ww);\n    return mat3(uu,vv,ww);\n    \n}\n\nvec4 gc(vec2 u)\n{\n    //create ray info\n    vec3 ro = vec3(.3, 0, -2.5), rd = normalize(vec3(u, 2.));\n    vec3 rod = ro;\n    \n    rd *= cam(ro, vec3(0,0,0));\n    \n    //ro.yz *= rot(radians(35.));\n    vec3 p;\n    vec3 n = nn(p);\n    //get ray march data\n    vec2 rm = rt(ro,rd, p);\n    vec3 lp = vec3 (.31,1,-6), ld = normalize(lp-p);\n    float spec = pow(max(dot(reflect(ld, n), rd),0.),200.); \n    \n                \n               //get relative uv coords\n#ifdef ALT_COVER\n        vec2 uv = vec2(atan(p.y,p.x)/radians(360.), p.y/.95 + 0.5);\n        uv = uv.xx;\n#else\n        vec3 vp = p;\n            //rotate back\n        vp.yz *= rot(-radians(35.));\n        vp.xz *= -rot(time);\n        //apply uv based on dithering\n        vec2 uv = vec2(vp.xy) + .5;\n        uv /= length(vp - ro) * 2.;\n#endif\n    \n    //get color based on id\n    if(rm.y == CD)\n    {\n        //get tangent\n       vec3 tt = (cross(n,normalize(p.xyz)));\n       vec3 col = vec3(0);\n       \n       //get colors relative to tangent\n       float cthl = dot(ld, tt);\n       float cthv = dot(-rd, tt);\n       float u = abs(cthl - cthv);\n\n            if(u == 0.)\n                return vec4(col,0);\n       //start mimicing wave length effect\n       for(int i = 1; i <= 1; i ++)\n       {\n         float ww = u * length(p- ro) * 6./ float(i);\n         col += spectral(ww);\n       }\n       col/= 8.;\n       col = clamp(col, 0.,1.);\n       vec3 off = texture(iChannel1, uv).rgb;\n       return  vec4(0.93) * texture(iChannel0, reflect(rd + off * .044, n)) + vec4(col, 1) ;\n    }\n    else if (rm.y == COVER)\n    {\n        //create cover with noise effect.\n        return mix(dith(uv), vec4(.2,.5,.9,1) , step(six(uv), 0.001)) * max(dot(-ld, n), 0.) + spec;\n    }\n    //background\n    return vec4(mix(vec4(0.1), vec4(.02),abs(u.y)));\n}\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = (2. * f - r)/r.y;\n    \n    c = gc(u);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[692, 802, 824, 824, 963], [965, 965, 987, 987, 1370], [1450, 1476, 1496, 1540, 2093], [2095, 2095, 2122, 2172, 2880], [3259, 3281, 3320, 3320, 3358], [3360, 3360, 3384, 3384, 3473], [3476, 3671, 3708, 3708, 3819], [3821, 3821, 3839, 3839, 3901], [3902, 3902, 3939, 3939, 4028], [4030, 4030, 4049, 4049, 4396], [4398, 4398, 4417, 4417, 4491], [4674, 4674, 4693, 4693, 4763], [4764, 4764, 4781, 4781, 5169], [5171, 5182, 5221, 5221, 5463], [5465, 5474, 5491, 5491, 5705], [5707, 5707, 5734, 5734, 5879], [5881, 5881, 5898, 5920, 7673], [7674, 7674, 7713, 7713, 7786]], "test": "untested"}
{"id": "fl2yRR", "name": "Fractal mosaic 2 (music)", "author": "jarble", "description": "A variant of my \"Banded mosaic\" pattern with a more interesting color palette.\nClick and drag to move around.", "tags": ["fractal", "mosaic"], "likes": 5, "viewed": 510, "published": 3, "date": "1649045954", "time_retrieved": "2024-07-30T16:55:29.305661", "image_code": "#define fmod(x,y) mod(floor(x),y)\n#define fpow(x,y) pow(y,fmod(x,y))\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a-fract(a*4.)/2.)\n        //fract(a-floor(2.*a.x+1.5)/2.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a,float num){\n    a = rotate(a,num*radians(180.));\n    //a += sign(a.y)/2.;\n    vec2 to_return = abs(f1((a+vec2(1.,0.5))*1.5)-.5);\n    //to_return /= 1.5; // makes another interesting pattern\n    return to_return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*1.5*2.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    float rotation_number = 0.;\n    vec3 col1 = col;\n    for(int k = 0; k < 12; k++){\n        //uv.x -= fmod(uv.x,1.5); //lace pattern\n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        //uv += floor(uv/1.5)/1.5;\n        \n        float offset =\n            //Change this to get lots of interesting patterns\n            0.\n            //.25\n            //float(k)/2.\n        ;\n        \n        float p1 = sign(uv.x);\n        //rotation_number -= p1/2.;\n        //float rotation_number = floor(uv.x)/2.+sign(uv.x-uv.y)/2.;\n\n        //uv.x -= sign(uv.x+.5)/scale;\n        //uv += (abs(fract(uv.yx-vec2(0.,1.5)))+1.)/8.;\n        //t2 = abs(t2*2.);\n        uv +=\n            t2\n            //t2/(1.+fmod(uv.x,2.))\n            //t2+fpow(uv.x,2.)/2.\n            //t2+abs(uv)\n        ;\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        //uv += (distance(floor(uv),round(uv+.5)));\n\n        //uv += t2-float(k)/(4.-(uv.x-uv.y)/(4.-(uv.x-uv.y))); //this makes an even crazier pattern\n\n        //uv -= floor(t2.y+t2.x)/4.;\n        //if(uv.y>uv.x) {uv = -uv.yx;} else uv *= -sign(uv-uv.yx);\n        uv /= scale;\n        //float rotation_number = ceil((float(k)+uv.y)/(3.-uv.x/4.));\n        //float rotation_number = ((float(k)/2.));\n        \n        //uv += floor(t2.x+t2.y);\n        //uv = max(uv,uv*sign(uv.yx-uv));\n        //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n        t2 =\n            -p1*triangle_wave(uv+offset-.5,rotation_number)\n            //-p1*triangle_wave(uv+floor(uv.y*2.)+offset-.5,rotation_number)\n            //-p1*triangle_wave(uv+offset-.5+floor(t2.y-t2.x),rotation_number)\n            //-p1*triangle_wave(uv-.5-fmod(t2.x/1.5,2.),rotation_number)\n        ;\n        \n        t3 = p1*triangle_wave(uv.yx+offset,rotation_number);\n        \n        //t3 += dot(t3,t3)/2.; //makes another interesting pattern\n\n        //t2 -= abs(t2-.5)/8.;\n        //t3 -= abs(t3-.5)/8.;\n        uv = t2-t3;\n        //t2 = mix(t2,uv,.5);\n\n        //col.x = abs(col.x-.5);\n        \n        //if(uv.x>uv.y)\n        col.x =\n            max(uv.y-uv.x*p1-col.x,col.x*2.75)\n            //max(length(uv-t2*(uv.x-uv.y))*p1-col.x,col.x*2.75)\n        ;\n        \n        col = abs(col.yzx-vec3(1.5-col.x))/2.;\n        //if(uv.y>uv.x) col.x = col.x/2.;\n        col1 = abs(col1.yzx-col);\n        //uv = max(uv,t2);\n         \n        //if(uv.x>uv.y) {uv=uv.yx;t2=t2.yx;}\n        //col *= col.yzx;\n        //uv.x -= .25; //flower pattern\n        //uv.x += .5;\n        //else uv *= 1.5;\n        //if(uv.x<uv.y) uv.x += .5;\n        //if(uv.x < .5) uv.x += .5;\n        //if(uv.y < .5) uv.y += .5;\n        \n\n    }\n    fragColor =\n        vec4(col*2.,1.0);\n        //vec4(col1*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod(float a, float b){\n    //a += fmod2(a,4.);\n    \n    //a += pow(2.,mod(floor(a/8./8.),8.));\n    /*\n    for(int i = 0; i < 3; i++){\n        a += floor(a/4.)*4.;\n    }\n    */\n    \n    \n    /*\n    for(int i = 0; i < 3; i++){\n        a += mod(floor(a/4.),4.);\n    }\n    */\n    //a = a + floor(a/b)/b*8.;\n    //a += pow(2.,mod(floor(a/8.),3.));\n\n    /*\n    for(float i = 1.; i < mod(floor(a/b),8.); i++){\n        a += mod(floor(a/b),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    //divide by prime numbers to get interesting rhythms\n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/11.),2.);\n    //a /= 1. + mod(floor(a1/7.),2.);\n    //a /= 1. + mod(floor(a1/5.),2.);\n    //a /= 1. + mod(floor(a1/3.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //floor(mod(floor(a),b)-mod(floor(a),b/2.))\n        //max(mod(floor(a*8./b),b),mod(floor(a/2./b),b))\n        //min(b-mod(floor(a*b/8.),b),mod(floor(a/b),b))\n        //mod(floor(a*8./b/4.) + floor(a*b/8./4.),b)\n        //mod(floor(a)*floor(a*2./b),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n        //max(mod(floor(a/4.),b),mod(floor(a),b))\n    ;\n}\n\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n//#define fmod(x,y) mod(floor(x),y)\n\n//#define fmod(a,b) mod(floor(a) + floor((a)/2.)*2.+floor((a)/4.)*4.+floor((a)/8.)*8.+floor((a)/16.)*16.,b)\n//#define fmod(x,y) mod(floor(x)+floor((x)/8./8.),y)\n//#define fmod(x,y) max(mod(floor((x)/2.),y),mod(floor(x),y))\n\n#define fmod1(x,y) mod(floor(x+floor(t0/y)),y)\n#define fmod2(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))\nvec2 mainSound(int samp, float time){\n float tempo =\n     1.\n     //pow(2.,fmod2(time,2.))\n ;\n time /= tempo;\n \n //crazy awesome remix!\n //time = (time + mod(time*2.,1.+fmod(time/4.,2.))/2.)/2.;\n \n //time /= (1.+fmod(time/2.,2.));\n //time *= (1.+fmod(time*2.,2.));\n \n //time /= 1.5;\n float t0=time, s1 =\n      8.\n      //pow(2.,2.+fmod(time/8.,3.))\n ;\n //time = (time + pow(2.,fmod(time,3.)));\n\n s1 /= pow(2.,fmod(time/s1/2.,2.));\n s1 *= pow(2.,fmod(time/s1/2.,2.))/2.;\n  \n  float f1 = floor(time*s1)/s1;\n  time += f1;\n  //time += floor(time*s1)*fmod(time/s1,s1)/s1;\n  \n  float s2 = 8.,\n  m4 =\n      fmod(time,2.)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      fmod(t,s2)\n      //fmod(floor(t/(1.+m4))*floor(t*s1),s2)\n      //fmod(floor(t/s1)*(floor(t*s1)+floor(t)),s2)\n  ,\n  m3 =\n      fmod(floor(t*s1+m1),s2)\n      //fmod(floor(t*s1+m1),s2+m1)\n  ;\n  //t /= max(m1,m3)+1.;\n  t /=\n      (1.+fmod(t/s1,2.))\n      //(1.+fmod(t/(1.+m1),2.))\n  ;\n  \n  float m2 =\n      1. + fmod(t*s1,s1)\n      //1. + fmod(t/s1*sign(m1-m3),s1)\n      //1. + fmod(t/s1+mod(t/s1,s1/2.),s1)\n  ;\n  \n  //time = time*(1. + fmod(time/s1,2.));\n  \n  float a =\n      //64.*sqrt((1.-sqrt(max(fract(t),fract(t*s1)))))*.2\n      4.*((1.-log(max(fract(t),fract(t*s1)))))\n\n      //(log(1.)-log(max(fract(-t*s1/4.),fract(-t/4.))/s1))\n      //2.*(fract(-t)/2.)\n  ,\n\n  nb = pow(2.,(m3+m2)/5.+6.5)*tempo*time;\n\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      //log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n      log(.125+abs(abs(.5-vec2(fract(nb*.998),fract(nb)))*a/2.))\n   ;\n\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2yRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 100, 100, 184], [186, 186, 202, 202, 312], [314, 314, 351, 351, 553], [555, 555, 612, 612, 3647]], "test": "untested"}
{"id": "7lsczl", "name": "inverting rectangles", "author": "Edward_Wong_Hau_Pepelu_Tivrusk", "description": "that overlapping effect from the dogdog mv\n\nnot finished but I can't be bothered to fix it", "tags": ["meme"], "likes": 2, "viewed": 218, "published": 3, "date": "1649037121", "time_retrieved": "2024-07-30T16:55:30.120483", "image_code": "#define freqStart -1.0\n#define freqInterval 0.1\n#define sampleSize 0.02           // How accurately to sample spectrum, must be a factor of 1.0\n\n\nconst int rectangles = 10;\n\n\nconst float PHI = (1.0 + sqrt(5.0)) / 2.0; // Φ = Golden Ratio \n\nfloat gold_noise(vec2 xy, float seed)\n{\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) \n{\n    float intensity = 0.0;\n\tfor(float s = 0.0; s < freqInterval; s += freqInterval * sampleSize) {\n\t\tintensity += texture(iChannel0, vec2(freqStart + s, 0.0)).r;\n\t}\n    intensity = abs(intensity);\n    intensity = pow((intensity*sampleSize),3.0)*4.0;\n    \n    vec4 invertedSquares;\n    vec4 squares;\n    vec4 blueOutlines;\n    vec4 pinkOutlines;\n    vec2 res = iResolution.xy;\n\n    for (int i = 0; i < rectangles; i++) {\n        vec4 square;\n        vec2 uv = abs((fragCoord - vec2(res.x / 3.0 + float((i % 2) * 2 - 1) * iTime * 10.0 + (res.x / 4.0 * gold_noise(vec2(i, i), float(i))), res.y / 3.0 + res.y / 4.0 * gold_noise(vec2(i, i), float(i)))) / res.y * mat2(sin(iTime / (10.0 * gold_noise(vec2(i, i), float(i))) + radians(float((i % 2) * 2 - 1) * 90.0) * vec4(3, 0, 0, 1))));\n        square = vec4(1.0 * smoothstep(1.0 / res.y, 0.0,  max(uv.x / PHI, uv.y) - 0.1));\n        blueOutlines += vec4(1.0 * smoothstep(2.0 / res.y, 0.0,  max(uv.x / (PHI+0.05*intensity), uv.y) - 0.1));\n        pinkOutlines += vec4(1.0 * smoothstep(2.0 / res.y, 0.0,  max(uv.x / PHI, uv.y / (1.0+0.05*intensity)) - 0.1));\n\n        squares += square;\n        invertedSquares = abs(invertedSquares-square);\n    }\n    \n    blueOutlines -= squares;\n    pinkOutlines -= squares;\n    blueOutlines.r = 0.0;\n    pinkOutlines.g = 0.0;\n    vec4 outlines = pinkOutlines+blueOutlines;\n    fragColor = mix(invertedSquares, outlines, outlines.a);\n    //fragColor = outlines;\n    \n}", "image_inputs": [{"id": 28708, "src": "https://soundcloud.com/pika-lynx582/dogdog-abuse-ft-hatsune-miku", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 280, 280, 337], [340, 340, 393, 393, 1841]], "test": "untested"}
{"id": "slScRz", "name": "tren sin fin", "author": "jorge2017a2", "description": "endless train--usar mouse para mover!!!", "tags": ["endlesstrain"], "likes": 16, "viewed": 260, "published": 3, "date": "1649017210", "time_retrieved": "2024-07-30T16:55:30.935304", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n//tren sin fin ----3-abril-2022\n///Cambios y Correccion por \"ocb\"..... varias correcciones...Gracias\n///https://www.shadertoy.com/user/ocb\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat tau=6.2831853;\nvec3 opAngRep( vec3 p, float a )\n{   vec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nmat2 genRotMat(float val){ \treturn mat2(cos(val),-sin(val),sin(val),cos(val)); }\n\nvec2 Rueda(vec3 p , float s )\n{   vec2 res= vec2(9999.0, -1.0); \n    float tau =6.2832;   // atan(1.0) * 8.0;\n    vec3 pp;\n    float numItem=4.0;\n \n     p.xy *= genRotMat(s*iTime*2.0);// ocb  //p.xy *= genRotMat( sign(p.z) * iTime*2.0); //p.xy *= genRotMat(iTime*2.0);  corregido por ocb\n    float d1= sdCylinderXY(p, vec2(0.5,1.5) ); //eje\n    float d2a= sdCylinderXY(p, vec2(2.5,1.0) ); //llanta ext\n    float d2b= sdCylinderXY(p, vec2(2.0,1.5) ); //llanta int\n    d2a= Difference(d2a,d2b);\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float d3= sdBox(rep2, vec3(2.0,0.2,1.0)); //rayos de rueda\n    res =opU2(res,vec2(d1,2.0));\n    res =opU2(res,vec2(d2a,8.0));\n    res =opU2(res,vec2(d3,1.0));\n    return  res;\n}\n\nvec2 vagon00(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    p.y=p.y-7.0;\n    float d1= sdRoundBox( p-vec3(0.0,3.0,0.0), vec3(15.0,5.0,5.0), 0.5 ); //vagon\n    float d2= sdRoundBox( p-vec3(0.0,3.0,0.0), vec3(14.5,4.5,4.5), 0.5 );//dif vagon\n    float d2a= sdCylinderXZ( p-vec3(3.0,8.0,0.0), vec2(2.0,1.0) );\n    p.x=abs(p.x)-7.0;\n    float d3= sdRoundBox( p-vec3(0.0,4.0,0.0), vec3(5.0,2.0,6.0), 0.5 ); //ventana 1\n    float d3a= sdRoundBox( p-vec3(0.0,4.0,0.0), vec3(5.0,2.0,6.5), 0.5 ); //ventana 2\n    float d3b= sdRoundBox( p-vec3(0.0,4.0,0.0), vec3(5.5,2.25,6.0), 0.5 ); //marco\n    d1= Difference(d1,d2);//vagon\n    d1= Difference(d1,d2a); //orificio\n    d1= Difference(d1,d3);  //ventana\n\n    d3b= Difference(d3b,d3a); //marco 1\n    d3b= Difference(d3b,d2); //marco 2\n    p=p0;\n    p.x=mod(p.x,20.0)-10.; p.x *= sign(p.z); /// ocb-///p.x=abs(p.x)-10.0;  \n    p.z=abs(p.z)-5.0;\n    //vec2 rd1= Rueda(p-vec3(0.0,3.5,0.0));\n    vec2 rd1= Rueda(p-vec3(0.0,3.5,0.0), sign(p0.z));\n    res =opU2(res, vec2(d1,14.0));\n    res =opU2(res, vec2(d3b,2.0));\n    res =opU2(res, rd1);\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float planeDist1 = p.y-1.0; \n    res =opU2(res, vec2(planeDist1,8.0));\n    float t=iTime*10.0;\n    p.x+=t;\n    p.z+=5.0;\n    p.x=  opRep1D(-p.x, 34.0); ///p.x=  opRep1D(p.x, 34.0);\n    vec2 v1= vagon00(p);\n    res =opU2(res, v1);\n    p=p0;\n    p.z+=45.0;p.x-=t;\n    p.x=  opRep1D(p.x, 34.0);\n    vec2 v2= vagon00(p);\n    res =opU2(res, v2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos =p; //vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    //vec3 N = GetNormal(worldPos);\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = 0.5 + 0.5 * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + specular*specular;\n    return colOut;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky*(1.0-rd.y);\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50) { colobj=getColor(int( id_color));  return colobj; }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));        \n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n   light_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(-2.0,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd,1.57);\n    //float vel=0.125;\n    float vel=0.055; //0.065\n   ///rd= rotate_y(rd, radians(360.*cos(iTime*vel*+sin(iTime*vel))));\n   //Camera with mouse control:\n   //rd= rotate_y(rd, iMouse.x/iResolution.x*6.28+radians(360.*cos(iTime*vel*+sin(iTime*vel))));  //radians(360.*cos(iTime*vel*+sin(iTime*vel))));\n\n   \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i]; }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slScRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[573, 573, 605, 605, 689], [690, 690, 736, 736, 823], [824, 824, 863, 863, 958], [959, 959, 998, 998, 1093], [1094, 1094, 1133, 1133, 1228], [1230, 1230, 1274, 1274, 1301], [1302, 1302, 1342, 1342, 1369], [1370, 1370, 1415, 1415, 1443], [1445, 1445, 1481, 1481, 1526], [1528, 1528, 1562, 1562, 1658], [1659, 1659, 1693, 1693, 1784], [1785, 1785, 1819, 1819, 1910], [1933, 1933, 1967, 1967, 2136], [2138, 2138, 2164, 2164, 2218], [2220, 2220, 2251, 2251, 2943], [2945, 2945, 2967, 2967, 4047], [4049, 4049, 4074, 4074, 4479], [4481, 4481, 4505, 4505, 4667], [4669, 4669, 4717, 4717, 4996], [4998, 4998, 5042, 5042, 5363], [5365, 5365, 5402, 5402, 5659], [5661, 5661, 5751, 5751, 6754], [6756, 6756, 6788, 6788, 6996], [6999, 6999, 7069, 7069, 7162], [7164, 7164, 7191, 7191, 7280], [7282, 7282, 7340, 7340, 7388], [7390, 7390, 7413, 7413, 7525], [7527, 7527, 7558, 7558, 8197], [8199, 8199, 8256, 8256, 8994]], "test": "untested"}
{"id": "slBczR", "name": "Pond Ripple", "author": "wyatt", "description": "Caustic render through some schrodinger solutions", "tags": ["caustic"], "likes": 24, "viewed": 500, "published": 3, "date": "1649016477", "time_retrieved": "2024-07-30T16:55:31.686296", "image_code": "// Fork of \"Fleurette\" by wyatt. https://shadertoy.com/view/7lfyDX\n// 2022-04-03 19:20:02\n\nMain{\n    Q = vec4(1.1,1.2,1.3,1.4)*B(U)/float(iFrame);\n    \n    //Q = .5+.5*A(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\nvec4 hash44(vec4 p4)\n{ // Dave H\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "Main{\n    Q = vec4(0);\n    float r; vec2 v;\n    U = 2.*(U-.5*R)/R.y;\n    \n    v = U-vec2(-.1,.2);\n    r = length(v)-.4;\n    Q += exp(-20.*r*r)*sin(40.*r*dot(v,v));\n    \n    v = U-vec2(.3,-.2);\n    r = length(v)-.6;\n    Q += .5*exp(-20.*r*r)*sin(40.*r*dot(v,v));\n    \n    \n    v = U-vec2(-.8,-.3);\n    r = length(v)-.2;\n    Q += exp(-40.*r*r)*cos(140.*r*dot(v,v));\n    \n    v = U-vec2(1.,.5);\n    r = length(v)-1.;\n    Q += .1*exp(-20.*r*r)*sin(20.*r*dot(v,v));\n    \n    v = U-vec2(0,-.5);\n    r = length(v)-1.4;\n    Q += .06*exp(-20.*r*r)*sin(20.*r*dot(v,v));\n}", "buffer_a_inputs": [], "buffer_b_code": "Main {\n    Q = B(U);\n    for (float i = 0.; i < 10.; i++) {\n        vec4 h = hash44(vec4(U,iTime,i));\n        vec2 r = .04*R.x*(h.xy*2.-1.);\n        vec4 n = A(U+r+vec2(0,1)),\n             e = A(U+r+vec2(1,0)),\n             s = A(U+r-vec2(0,1)),\n             w = A(U+r-vec2(1,0));\n        vec2 g = (1.+h.z)*R.x*vec2(e.w-w.w,n.w-s.w);\n\n        Q += .05*R.x*exp(-length(r-g))*vec4(.5-.5*sin(5.*h.z+vec3(1,2,3)),1);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dSBWz", "name": "Cyclides", "author": "mla", "description": "Cyclides raytraced using analytic solution to quartic.\n\nMouse rotates. <up>/<down> to zoom.\n\nClick & drag red blob in crosshairs to change cyclide parameters.\n\n'z' hides controls\n't' texturing\n'r' controls autorotation", "tags": ["quartic", "universe", "descartes", "cyclide"], "likes": 25, "viewed": 461, "published": 3, "date": "1649004475", "time_retrieved": "2024-07-30T16:55:32.431304", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Cyclides, Matthew Arcus, 2022.\n//\n// A Dupin cyclide is essentially an inverted torus and like a torus\n// has an implicit quartic equation. By moving the projection point\n// to be orthogonal to the projection direction, the cubic term in the\n// quartic disappears and we can directly use Descartes method for\n// solving a depressed quartic. As usual this requires solving an\n// auxiliary cubic and we do this with Kahan's semi iterative method -\n// this has the great advantage that we avoid use of potentially\n// inaccurate trigonometry functions.\n// \n// Mouse rotates. <up>/<down> to zoom.\n//\n// Click & drag red blob in crosshairs to change cyclide parameters.\n//\n// 'z' hides controls\n// 't' texturing\n// 'r' controls autorotation\n// 'h' 'horn' cycle (parameter d = c = a²-b²)\n// 's' 'spindle' cyclide (parameter d = 1.0).\n// 'b' show where biquadratic solver is used\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  x1 = C/r;\n  x2 = r/A;\n  res = vec2(x1,x2);\n  return 2;\n}\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nvoid eval(float X, float B, float C, float D,\n          out float Q, out float DQ, out float B1,out float C2) {\n  float q0 = X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  DQ = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\nfloat qcubic(float B, float C, float D) {\n  float X,b1,c2;\n  X = -B/3.0;\n  float t,r,s,q,dq,x0;\n  eval(X,B,C,D,q,dq,b1,c2);\n  t = q; r = pow(abs(t),1.0/3.0); s = sgn(t);\n  t = -dq; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n  x0 = X - s*r;\n  if (x0 != X) {\n    X = x0;\n    for (int i = 0; i < 4; i++) {\n      eval(X,B,C,D,q,dq,b1,c2);\n      if (dq == 0.0) break;\n      X -= q/dq;\n    }\n    if (X*X > abs(D/X)) {\n      c2 = -D/X; b1 = (c2 - C)/X;\n    }\n  }\n  vec2 res;\n  if (quadratic(1.0,b1,c2,res) == 0) return X;\n  X = max(X,res[0]);\n  X = max(X,res[1]);\n  return X;\n}\n\nint biquadratic(float p, float r, out vec4 res) {\n  if (key(CHAR_B)) assert(false);\n  // Solve x^4 + px^2 + r = 0 (ie. a quadratic equation in x^2)\n  vec2 t;\n  if (quadratic(1.0,p,r,t) == 0) return 0;\n  int n = 0;\n  for (int i = 0; i < 2; i++) {\n    if (t[i] >= 0.0) {\n      float x = sqrt(t[i]);\n      res[n++] = -x;\n      res[n++] = x;\n    }\n  }\n  return n;\n}\n\n// Descartes solver for depressed quartics\n// ie. x⁴ + px² + qx + r = 0\nint dquartic(float p, float q, float r, out vec4 res) {\n  if (abs(q) < 0.001) return biquadratic(p,r,res);\n  float A = 2.0*p;\n  float B = p*p-4.0*r;\n  float C = -q*q;\n  float U = qcubic(A,B,C);\n  assert(U >= 0.0);\n  float u = sqrt(U);\n  float s = -u;\n  float t = 0.5*(p+U+q/u);\n  float v = 0.5*(p+U-q/u);\n  int n1 = quadratic(1.0,s,t,res.xy);\n  int n2 = quadratic(1.0,u,v,res.zw);\n  if (n1 == 0) res.xy = res.zw;\n  return n1+n2;\n}\n\nint cyclide(vec4 params, vec3 q, vec3 r, out vec4 roots) {\n  // Cartesian equation for p = (x,y,z), a,b,c,d params:\n  // (p.p+b²-d²)² = 4((ax-cd)²+b²y²)\n  // Solve for p = q+tr, with r.r = 1.0, q.r = 0.0\n  float a = params.x, b = params.y, c = params.z, d = params.w;\n  float K = (b+d)*(b-d); float L = c*d;\n  // t0 = (q+tr).(q+tr) + K = q.q + K + t^2\n  // t0*t0 = (q.q + K + t^2)(q.q + K + t^2) = (q.q + K)^2 + 2t^2(q.q + K) + t^4\n  // (a(q.x+tr.x)-L)² = ((aq.x-L)+tr.x)² = t²(r.x)²+2tr.x(aq.x-L)+(aq.x-L)²\n  float qq = dot(q,q)+K; // Roll K into qq\n  float arx = a*r.x, aqx = a*q.x-L; // Roll L into aqx\n  float bry = b*r.y, bqy = b*q.y;\n  float C = 2.0*qq - 4.0*arx*arx - 4.0*bry*bry;\n  float D = -8.0*(aqx*arx + bqy*bry);\n  float E = qq*qq - 4.0*aqx*aqx - 4.0*bqy*bqy;\n  return dquartic(C,D,E,roots);\n}\n\nvec3 cyclidegrad(vec4 params, vec3 p) {\n  float a = params.x, b = params.y, c = params.z, d = params.w;\n  float x = p.x, y = p.y;\n  float K = (b+d)*(b-d), L = c*d;\n  float t = dot(p,p) + K;\n  float u = a*x-L, v = b*y;\n  return 2.0*(2.0*t*p - 4.0*vec3(u*a,v*b,0));\n}\n\n// Lighting\nvec3 light = vec3(1,1,-1);\nfloat ambient = 0.4;\nfloat diffuse = 0.6;\nfloat specular = 0.8;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nvec3 compute(vec3 color, vec3 q, vec3 r, float tmin) {\n  vec4 res;\n  // a = b: torus\n  // b = 0: tangent spheres\n  float a = 1.0; float b = 0.5;\n  float d = 2.0*sin(iTime);\n  vec2 sel0 = getselection(0);\n  b = min(1.0,abs(1.1*sel0.y));\n  float c = sqrt(a*a-b*b);\n  d = key(CHAR_H) ? c : key (CHAR_S) ? 1.0 : sel0.x;\n  vec4 params = vec4(a,b,c,d);\n  int n = cyclide(params,q,r,res);\n  // Sort results in decreasing order\n  if (n > 1) {\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  if (n > 2) {\n    if (res.y < res.z) res.yz = res.zy;\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  if (n > 3) {\n    if (res.z < res.w) res.zw = res.wz;\n    if (res.y < res.z) res.yz = res.zy;\n    if (res.x < res.y) res.xy = res.yx;\n  }\n  // Process from furthest\n  for (int i = 0; i < n; i++) {\n    float t = res[i];\n    //if (t > tmax) continue; // Not needed here, surface is bounded\n    if (t < tmin) break;\n    vec3 p = q+t*r;\n    float phi = atan(p.y,p.x);\n    float theta = atan(p.z,sqrt(p.x*p.x+p.y*p.y));\n    vec2 uv = 4.0*vec2(phi,theta)/PI;\n    vec3 n = cyclidegrad(params,p);\n    if (dot(r,n) > 0.0) n = -n; // Face forwards\n    n = normalize(n);\n    vec3 basecolor = pow(abs(n),vec3(1.0));\n    if (!key(CHAR_T)) basecolor *= texture(iChannel0,uv).xyz;\n    if (min(abs(p.x),min(abs(p.y),abs(p.z))) < 0.01) basecolor *= vec3(0.5);\n    vec3 c = applylighting(basecolor,p,n,r);\n    color = mix(c,color,0.5);\n  }\n  return color;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  vec2 s = defaultselection();\n  {\n    float theta = s.y*PI;\n    float phi = s.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz, 0.1*iTime);\n    p.zx = rotate(p.zx, 0.222*iTime);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 uv = map(fragCoord);\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0,0,-camera);\n  vec3 r = vec3(uv,2);\n\n  light = transform(light);\n  light = normalize(light);\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  float t = -dot(p,r);\n  vec3 color = vec3(0);\n  if (!key(CHAR_Z)) {\n    float px = fwidth(uv.x);\n    vec2 d = abs(uv-getselection(0));\n    color = mix(vec3(1),color,0.95+0.05*smoothstep(-px,px,min(d.x,d.y)-0.005));\n    color = mix(vec3(1,0,0),color,0.6+0.4*smoothstep(-px,px,length(d)-0.02));\n  }\n  vec3 c = compute(color,p+t*r,r,-t);\n  c = pow(c,vec3(0.4545));\n  if (alert) c.r = 1.0;\n  fragColor = vec4(c,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) t.zw = map(iMouse.xy);\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define map(p) ((2.0*(p) - iResolution.xy)/iResolution.y)\nint nselections = 1;\nfloat scale = 1.0;\nvec2 initselection(int i) {\n  return vec2(0.5);\n}\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1046, 1046, 1066, 1066, 1120], [1122, 1122, 1178, 1178, 1352], [1462, 1462, 1573, 1573, 1658], [1660, 1660, 1701, 1701, 2229], [2231, 2231, 2280, 2280, 2592], [2594, 2669, 2724, 2724, 3099], [3101, 3101, 3159, 3310, 3918], [3920, 3920, 3959, 3959, 4185], [4347, 4347, 4407, 4407, 4597], [4599, 4599, 4653, 4653, 6017], [6019, 6019, 6055, 6055, 6105], [6107, 6107, 6134, 6134, 6398], [6400, 6400, 6452, 6452, 7151]], "test": "untested"}
{"id": "NllyWf", "name": "Voronoi Greeble Displacement", "author": "Shane", "description": "Using a tailored Voronoi algorithm to precalculate a greeble-like displacement map, then raymarching it in realtime -- or in simpler terms, raymarching a custom texture. :)", "tags": ["raymarching", "voronoi", "displacement", "map", "pattern", "block", "greeble"], "likes": 82, "viewed": 1335, "published": 3, "date": "1648994766", "time_retrieved": "2024-07-30T16:55:33.531364", "image_code": "/*\n\n    Voronoi Greeble Displacement\n    ----------------------------\n\n\tUsing a tailored Voronoi algorithm to precalculate a greeble-like displacement \n    map, then raymarching it in realtime -- or in simpler terms, raymarching a custom \n    texture. :)\n    \n    At present, creating a texture on a buffer for usage in a 3D scene is not what I'd \n    call ideal. If you require proof, search Shadertoy and you won't find a great deal \n    of examples, especially those of the wrapped variety. Having said that, considering \n    the benefits involved, I'm still a little surprised that there aren't more \n    precalculated texture examples than there are.\n    \n    Your two choices are either using a buffer with variable rectangular dimensions, or \n    loading in all six faces of the cube map, then rendering to one or more of the six \n    fixed size faces. In my case, I prefer the latter, which is the lesser of the two \n    evils. I've been told that most GPUs aren't affected too much by the cube map memory \n    requirements, so I'll take people's word for it, but my common sense tells me that \n    using just one fixed size 1024 by 1024 buffer would be a way better use of machine \n    resources... However, I'm not an expert on machine architecture, so who knows.\n    \n    Anyway, the obvious benefit is precalculation. The following scene -- if you can\n    call it that -- involves nothing more than a single raymarched texture. Calculating\n    the 2D displacement function in realtime inside the raymarching loop would be \n    prohibitively expensive.\n    \n    In regard to the texture creation itself, it's just a variation on a Voronoi algorithm.\n    Because it was calculated just the once at startup, I was able to tweak things at\n    my leisure. This is just a very basic example to show that it's possible to raymarch\n    more than simple noise and Voronoi. I'm leading up to more interesting scenes. There\n    are a few defines in the \"Common\" and \"Image\" tab to look at, for anyone interested.\n    \n    \n\n    \n\n\tRelated exmaples:\n    \n\t// As mentioned, there aren't too many precalculated displacement\n    // map examples utilizing the cube map, but here's one.\n    Alien Plain - fizzer \n\thttps://www.shadertoy.com/view/wdGXzy \n    \n    // Awesome precalculated texture example. TekF has a few that are\n    // worth looking at.\n    Sedimentary Erosion - TekF\n    https://www.shadertoy.com/view/tt2Szh\n    \n    // Using a variable sized buffer to precalculate a height field.\n    Mucous Membrane HeightField - tholzer\n    https://www.shadertoy.com/view/4l3fWn\n\n\n*/\n\n\n// Show the displacement map in its 3D setting in more detail.\n//#define MAP_DETAIL\n\n// Just the displacement map on its own. Actually, this is a bump mapped\n// version. The texture map itself is quite mundane. The MAP_DETAIL option\n// above will need to be commented out for this to work.\n//#define DISPLACEMENT_MAP\n\n// Gold material... Gold and silver would look nice. Maybe next time. :)\n//#define GOLD\n\n// Grayscale, for that artsy look.\n//#define GRAYSCALE\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// No forced unroll.\n#define ZERO min(0, iFrame)\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Smooth cube map face 2D texture blend.\nfloat getTex(vec3 q){\n    \n    // Scaling.\n    vec2 p = q.xy/4.;\n    \n    // Cube map texture coordinate conversion.\n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)/cubemapRes) - .5;\n    \n    // 2D neighboring texels stored in each of the four texture channels.\n    vec4 p4 = texture(iChannel2, vec3(-.5, uv.yx)); \n    \n    // Linearly interpolate.\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n\n}\n\n\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    // Plane warp.\n    //p.z -= (dot(p.x, p.x))*.0125;\n   \n    // The Voronoi greeble displacement value.\n    float pat = getTex(p);\n    \n    // A second layer. Too much for this example.\n    //float pat2 = getTex(p*2.);\n    //pat = mix(pat, pat2, 1./4.);\n    \n     // Floor.\n    float fl = -p.z;// + 1.;\n    \n    // Applying the displacement map.\n    fl -= pat*.5;\n    \n    \n\n    // Overall object ID. Just the one, so redundant here,\n    // but there are usually more.\n    objID = 0.;\n    \n    // Just the floor.\n    return  fl;\n \n}\n\n \n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<128; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(d>1e8) break; // Fake break.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n// Slightly modified version of Nimitz's curve function. The tetrahedral and normal six\n// tap versions are in there. If four taps gives you what you want, then that'd be the\n// one to use.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\n//\n// spr: sample spread, amp: amplitude, offs: offset.\nfloat curve(in vec3 p, in float spr, in float amp, in float offs){\n\n    float d = map(p);\n    \n    spr /= 450.;\n    \n    #if 0\n    // Tetrahedral.\n    vec2 e = vec2(-spr, spr); // Example: ef = .25;\n    float d1 = map(p + e.yxx), d2 = map(p + e.xxy);\n    float d3 = map(p + e.xyx), d4 = map(p + e.yyy);\n    return clamp((d1 + d2 + d3 + d4 - d*4.)/e.y/2.*amp + offs + .5, 0., 1.);\n    #else  \n    // Cubic.\n    vec2 e = vec2(spr, 0); // Example: ef = .5;\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    return clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*6.)/e.x/2.*amp + offs + .5, 0., 1.);\n    \n    //d *=2.;\n    //return 1. - smoothstep(-.05, .05, (abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d))/e.x/2.*amp + offs + .0);\n    #endif\n\n}\n\n/*\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p){\n    \n    \n    \n    float ns = getTex(p);\n    \n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took far too long before it hit me. :)\n    return ns;///(1. + gT*gT*.015);\n    \n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Aspect correct screen coordinates. Translation and scale is all that\n    // \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(cos(iTime/4.)*1.5, iTime/1.5, -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(cos(iTime/4.)*.05, cos(iTime/2.)*.025  + .1, .25); // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, 1, .75);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); // Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n\n    // rd - Ray direction.\n    vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV - dot(uv, uv)*.05));\n    // Equivalent to:\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2(-sin(iTime/4.)/2. );\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n\n    // Object ID.\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n        \n        //sn = doBumpMap(sp, sn, .05);///(1. + t*t/FAR/FAR*.25)\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n \n            // Surface texture.\n            vec3 txP = sp;\n            txP.xy *= rot2(3.14159/6.);\n            vec3 tx = tex3D(iChannel0, txP, sn);\n            \n            // Texture application.\n            texCol = .025 + tx/2.;\n            \n            #ifdef GOLD\n            // Gold material.\n            texCol *= vec3(1.4, .85, .4);\n            #endif\n             \n            // Extra texture shading. Not used.\n            //float shade = getTex(sp)*.9 + .1;\n            // texCol *= shade;\n\n        }\n        else {\n            \n            // The background. Not used here.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        // Light attenuation, based on the distances above.\n\t    float atten = smoothstep(.1, .5, 1./(1. + lDist*lDist*.35))*1.;\n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n        \n        // spr: sample spread, amp: amplitude, offs: offset.\n\t\tfloat spr = 4., amp = 1.25, offs = -.25;\n        float crv = curve(sp, spr, amp, offs)*.95 + .05;\n\t    \n\t    \n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 32.)*4.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 8.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n        // Half vector.\n        vec3 hv = normalize(rd + ld);\n        // Specular Blinn Phong. The last term is highlight power related.\n        float specBF = pow(max(dot(hv, sn), 0.), 6.);\n   \n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Feel free to look up\n        // the \"science,\" but it essentially takes that annoying central shine out. How\n        // much you take out depends on the material, which is controlled by the material\n        // constant.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Using the curvature to color the texture a bit.\n        //texCol *= mix(vec3(.0, .1, .2), vec3(.9, .8, .8)/2., crv)*2.;//*.125 + .125;\n      \n        //texCol *= clamp(sp.z + .5, 0., 1.);\n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .25);\n        //col *= 2.;\n        // The specular term: Instead of putting in two different colored lights, which\n        // requires two expensive shadow runs, I'm using a cheap trick involving partitioning \n        // the specular color with repect to which side of the ray it's sitting on. Not science, \n        // but no one will notice, and those who do won't care. :)\n        vec3 specCol = mix(vec3(1, .4, .2), vec3(1, .4, .2).xzy, smoothstep(0., .3, -rd.y + .3));\n        specCol = mix(vec3(1, .4, .2), vec3(1, .4, .2).zyx, smoothstep(0., .3, -rd.x*2.));\n        specCol *= texCol*8.;\n        //col += specCol*spec*freS*2.*sh; \n        col += specCol*pow(spec, 8.)*freS*32.*sh; \n \n        // Cube map reflection. Not as cool as a second pass, but it works here.\n        vec3 refCol = texture(iChannel1, reflect(rd, sn)).xyz; refCol *= refCol;\n        col += col*refCol*6.;\n        // Specular Blinn Phong.\n        //col += specBF*refCol*4.;\n        \n        // Shading.\n        col *= ao*atten*crv;\n        \n        // Greyscale value, just in case people switch to the Britney video, etc.\n        // Stylistically, the example works better with color. The Britney video\n        // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n        #ifdef GRAYSCALE\n        col = vec3(1)*dot(col, vec3(.299, .587, .114));\n        #endif\n        \n        #ifdef MAP_DETAIL\n        // Also used for debugging purposes.\n        col = vec3(crv*(sh*.9 + .1)); // ao, sh, etc.\n        #endif\n          \n\t\n\t}\n    \n\n    // Just the displacement map on its own. Actually, this is a bump mapped\n    // version. The texture map itself is quite mundane, which you can see \n    // if you set \"b2\" to 1.\n    #ifdef DISPLACEMENT_MAP\n    float b = getTex(vec3(uv*4. - iTime/4., 0));\n    float b2 = getTex(vec3(uv*4. - iTime/4. - normalize(vec2(1, 2))/cubemapRes.x, 0));\n    b2 = max(b2 - b, 0.)*cubemapRes.x;\n    col = b*vec3(1)*(b2*.85 + .15);\n    #endif      \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace0(vec3 p){\n   \n    \n    vec4 col;\n    \n    vec3 q = p;\n    \n    for(int i = 0; i<4; i++){\n        \n        // Texture coordinates for this iteration.\n        q.xy = mod(floor(p.xy*cubemapRes) + vec2(i&1, i>>1), cubemapRes)/cubemapRes;\n        \n        // Subtle, wrapped noise perturbation. Like everything added to the texture,\n        // texture offsets need to be wrapped as well.\n        gSc = vec3(32);\n        float ns = n3DT(q*gSc);\n        float ns2 = n3DT(q*gSc + .35);\n        gSc = vec3(16.);\n        ns = mix(ns, n3DT(q*gSc), 1./3.);\n        ns2 = mix(ns, n3DT(q*gSc + .35), 1./3.);\n        q.xy += (vec2(ns, ns2) - .5)*.0025;\n\n        \n        // Wrapped multilayer tertiary order Voronoi.\n        gSc = vec3(8);\n        #ifdef RAND_ROT\n        vec3 rotF = vec3(.03); // Rotation factor - Range: [0, 1].\n        #else\n        vec3 rotF = vec3(0);\n        #endif\n        //vec3 sc = vec3(1, 1, 2);\n        vec3 sc = vec3(1, 1, 1);\n        int rowOffset = 0;\n        vec3 v = Voronoi(q*gSc, sc, rotF, 1./1., rowOffset, 1);\n     \n        \n        #if VARIATION == 0\n        float vor = abs(v.x - .05);\n        #elif VARIATION == 1\n        float vor = abs(v.y - .15);\n        #elif VARIATION == 2\n        float vor = abs(v.z - v.y - v.x);\n        #else \n        float vor = abs((v.y - clamp(.15 - v.z - v.x, 0., .25)) - .15);\n        #endif\n   \n        #ifdef CORRUGATE\n        // Adding subtle corrugation. It looks interesting, but not for this example.\n        vor = mix(vor, floor(vor*31.999)/31., .15);\n        #endif\n        \n        vor = min(vor*1.35, 1.); // Increasing the slope and capping for a beveled effect.\n        \n        float sf = .4; // Fine edge smoothing.\n        \n        #ifdef LINES\n        // Adding some cell border detail.\n        vor = mix(vor, smoothstep(-sf, sf, (max(1. - vor*42./gSc.x, 0.) - 1./2.)), .15);//\n        #endif\n        \n        //if(hash33(vIP).x>.5) vor = abs(.5-vor);//abs(fract(v.x) - .5)*2.;   \n\n        \n        col[i] = vor;\n        \n        \n        \n        sf = .1;\n        gSc = vec3(128);//\n        rotF = vec3(.03);\n        //vec3 sc = vec3(1, 1, 2);\n        // Putting the height from above into the Z slot.\n        sc = vec3(1, 1, 1);//vor*.25 + .75\n        rowOffset = 1;\n        v = Voronoi(q*gSc, sc, rotF, 1./4., rowOffset, 1);\n        \n        vor = abs(v.x - .2);\n \n        float v2 = mix(min(vor*1.5, 1.), smoothstep(-sf*1., sf*1., (max(1. - vor*64./gSc.x, 0.) - 1./2.)), .15);\n        col[i] = mix(col[i], vor, 1./96.);// - col[i]\n        //col[i] = ov;\n \n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    // Pixel storage.\n    vec4 col = vec4(0);\n    \n    // Precalculation flag: GPUs are annoying. Sometimes, they'll will calculate\n    // both the \"if\" and \"else\" statements every time. The \"if\" part here is extremely\n    // expensive, so we don't want that. The solution is to not have an \"if-else\"\n    // statement at all.\n    int preCalc = 0;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n        \n        // This is part of an ugly hack that attempts to force the GPU compiler\n        // to not unroll the Voronoi loops. Not sure if it'll work, but I'm \n        // trying it anyway, in the hope to get compiler times down on some\n        // machines. For the record, this takes about 3 seconds to compile on \n        // my machine.\n        frame0 = iFrame;\n        \n \n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==0){\n            \n            //vec3 p = convert2DTo3D(uv);      \n            vec3 p = vec3(uv, 0);      \n            \n            col = funcFace0(p);\n            //col = mix(col, 1.-funcFace0(p*2.), 1./16.);\n            \n            preCalc = 1;\n           \n        }\n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    \n    \n    if(preCalc == 0 && faceID == 0){\n\n        if(faceID == 0) col = texture(iChannel0, vec3(-.5, uv.yx - .5));\n        //col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Displacement texture variations. A reset will be necessary for each change.\n// I.e., you'll need to hit the back button. \n// Variations: 0 through to 2\n#define VARIATION 3\n\n// Random texture object rotation. Hit the back button.\n//#define RAND_ROT\n\n// Add in pattern border line detail. Hit the back button.\n#define LINES\n\n\n// Adding a bit of corrugation. It's interesting, but not on by default.\n// Hit the back button.\n//#define CORRUGATE\n\n\n\n\n// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n// Relates to iFrame.\nint frame0 = 0;\n\n\n\n/* \n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n*/\n\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nvec3 gSc;\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// 3x1 hash function.\n//float hash31(vec3 p){ return fract(sin(dot(p, vec3(21.471, 157.897, 113.243)))*45758.5453); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    p = mod(p, gSc.xy);\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\n\n// Dave Hoskins puts together some pretty reliable hash functions. This is \n// his unsigned integer based vec3 to vec3 version.\nvec3 hash33(vec3 p){\n\n    p = mod(p, gSc);\n    // Addendum: The float values cast to unsigned integers can be quite small,\n    // in this particular case, so I've increased them for greater randomization.\n    p *= vec3(9528.609, 7157.583, 7357.781);\n\tuvec3 q = uvec3(ivec3(p))*uvec3(1597334673U, 3812015801U, 2798796415U);\n\tq = (q.x^q.y^q.z)*uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn -1. + 2.*vec3(q)*(1./float(0xffffffffU));\n}\n\n \n/*\nvec3 hash33(vec3 p){\n\n    \n    //p = mod(p, gSc);\n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    // Dave's hash function. More reliable with large values, but will still eventually break down.\n    //\n    // Hash without Sine.\n    // Creative Commons Attribution-ShareAlike 4.0 International Public License.\n    // Created by David Hoskins.\n    // vec3 to vec3.\n    p = mod(p, gSc);\n\tp = fract(p*vec3(.10313, .10307, .09731));\n    p += dot(p, p.yxz + 19.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n   \n    \n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = rot2(mod(iTime, 6.2831853));\t\n\t//p.xy = m * p.xy;//rotate gradient vector\n    //p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n\n}\n*/\n \n\n// vec4 to vec4 hash.\nvec4 hash41T(vec4 p){\n    p = mod(p, vec4(gSc.x));\n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){    \n    \n    // Square partioning.\n    // Local corner points and local coordinates.\n\tvec3 ip = floor(p); p -= ip;\n    \n    // Smoothing.\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    \n    \n    // Random vector.    \n\tconst vec3 s = vec3(27, 111, 57);\n    // Randomizing corner points.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n    // Interpolate X.\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    // Interpolate Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    // Interpolate Z.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n   \n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n\n\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n// smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)/k;\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n\n\n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n}\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n*/\n\n// This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n//\n//\nvec3 cellID;\nint gIFrame;\n\nivec4 gID2;\n\n// Distance metric: Put whatever you want here.\nfloat distMetric(vec3 p, vec3 b, int id){\n    \n    \n    if(id==0){\n    \treturn (dot(p, p));///2.; // Sphere squared.\n    }\n    else {\n        \n        //float d2 = sBoxS(p.xy, b.xy/1., 0.);\n        //float d2 = sdHexagon(p.xy, min(b.x, b.y));\n        //return opExtrusion(d2, p.z, b.z/1.);\n        \n        //return sBoxS(p, b, .1);\n\n        \n        //return (dot(p, p)) - b.x*b.x;\n        //return length(p) - b.x; // Standard spherical Euclidean distance.\n\n        //return max(max(length(p.xy), length(p.yz)), length(p.xz)); // Cylinder cross.\n\n        //p = max(abs(p)*.8660254 + p.yzx*.5, -p);\n        //return max(max(p.x, p.y), p.z); // Triangular.\n\n        // Uncomment this for all metrics below.\n        p = abs(p) - b;\n        \n        \n        //p = (p + p.yzx)*.7071;\n        //return max(max(p.x, p.y), p.z); // Can't remember -- Diamond related. :)\n\n\n        return max(max(p.x, p.y), p.z); // Cube.\n        //return (p.x + p.y + p.z)*.5;//.57735; // Octahedron.\n        \n        \n        //p = (p - p.yzx);\n        //p = abs(p) - b;\n        //return max(max(p.x, p.y), p.z);\n        \n        \n        // Mixtures.\n        //return mix(max(max(p.x, p.y), p.z), length(p), .15);\n\n        //p = p*.8660254 + p.yzx*.5;\n        //return max(max(p.x, p.y), p.z); // Hex.\n/*\n        p = abs(p) - b;\n        float taper = (p.x + p.y + p.z)/3.*2.*.65 + .35; // Linear gradient of sorts.\n        //float taper = p.y + .5; // Original.\n        //taper = mix(taper, max(taper, .5), .35); // Flattening the sharp edge a bit.\n\n        p = abs(p)*2.;\n        //p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; // Used with triangle.\n\n        float shape = max(max(p.x, p.y), p.z); // Square.\n        //float shape = max(p.x*.866025 - p.y*.5, p.y); // Triangle.\n        //float shape = max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n        //float shape = max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.\n        //float shape = length(p); // Circle.\n        //float shape = dot(p, p); // Circle squared.\n\n\n        //shape = (shape - .125)/(1. - .125);\n        //shape = smoothstep(0., 1., shape);\n\n\n        //return shape;\n        return max(shape, taper);\n        */\n\n    }\n    \n}\n\nvec3 vIP;\n\n// 2D 3rd-order Voronoi: This is just a rehash of Fabrice Neyret's version, which is in\n// turn based on IQ's original. I've simplified it slightly, and tidied up the \"if\" statements.\n//\nvec3 Voronoi(in vec3 q, in vec3 sc, in vec3 rotF, float offsF, int rowOff, int id){\n    \n    \n\t//const vec3 sc = vec3(1, 2, 1);\n    gSc /= sc;\n \tvec3 d = vec3(1e5); // 1.4, etc.\n    \n    float r;\n    \n    const int n = 3;\n    // Widen or tighten the grid coverage, depending on the situation. Note the large \n    // spread. That's to cover the third order distances. In a lot of cases, (3x3x3) is enough,\n    // but in some, 729 taps (9x9x9), or even more, might be necessary.\n    //\n    // Either way, this is fine for static imagery, but needs to be reined in for realtime use.\n    for(int z = -n; z <= n; z++){ \n        for(int y = -n; y <= n; y++){ \n            for(int x =-n; x <= n; x++){\n\n                vec3 cntr = vec3(x, y, z) - floor(float(n)/2. + .001);\n                vec3 p = q;\n    \n                if(rowOff == 1){\n                    // Alternate 3D row offset -- Due to the cube's construction,\n                    // only one slice at a time will work... There might be a more\n                    // interesting way to shuffle things, but this'll do.\n                    if(mod(floor(p.z/sc.x - cntr.z), 2.)>.5){\n                        if(mod(floor(p.x/sc.x - cntr.x), 2.)<.5) p.y += sc.y/2.;\n                    }\n                    else if(mod(floor(p.y/sc.y - cntr.y), 2.)<.5) p.x += sc.x/2.;\n                }\n                \n                 \n\t\t\t\tvec3 ip = floor(p/sc - cntr) + .5; \n                p -= (ip)*sc;\n                //ip += cntr;\n                \n                // Random position and rotation vectors.\n                vec3 rndP = hash33(ip);\n                vec3 rndR = hash33(ip + 3.)*6.2831*rotF;\n\n                // Rotate.\n                p = rot(rndR)*p;\n                //p.xy *= rot2(rndR.x);\n                //p.yz *= rot2(rndR.y);\n                //p.zx *= rot2(rndR.z);\n               \n               \n                //rndP = floor(rndP*16.)/16.;\n                // Postional offset.\n                p -= rndP*offsF*sc;\n                \n                \n                // Scale -- Redundant here.\n\t\t\t\tvec3 b = sc/2.*vec3(1, 1, 1);//*(hash33(ip)*.5 + .5);\n                // Distance metric.\n                r = distMetric(p, b, id);\n                \n                if(r<d.x) vIP = ip;\n\n                // 1st, 2nd and 3rd nearest distance metrics.\n                d.z = max(d.x, max(d.y, min(d.z, r))); // 3rd.\n                d.y = max(d.x, min(d.y, r)); // 2nd.\n                d.x = min(d.x, r);//smin(d.x, r, .2); // Closest.\n                \n                // Redundant break in an attempt to ensure no unrolling.\n                // No idea whether it works or not.\n                if(d.x>1e5) break; \n\n            }\n        }\n    }\n\n    \n    return d;//min(d, 1.);\n    \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3221, 3301, 3347, 3347, 4259], [4262, 4304, 4325, 4346, 4756], [4760, 4783, 4801, 4917, 5346], [5353, 5374, 5410, 5459, 5931], [5934, 6034, 6061, 6404, 6676], [6680, 6871, 6923, 7040, 8359], [8362, 8514, 8550, 8550, 8849], [8851, 9497, 9563, 9563, 10339], [12482, 12482, 12538, 12628, 19226]], "test": "untested"}
{"id": "7tlyDs", "name": "snow crystal", "author": "takahiroando", "description": "based on https://gam0022.net/blog/2017/03/02/raymarching-fold/", "tags": ["fold"], "likes": 3, "viewed": 290, "published": 3, "date": "1648972464", "time_retrieved": "2024-07-30T16:55:34.288339", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI 3.14151692\n#define PI2 (PI * 2.0)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\nvec3 foldX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\nfloat dTree(vec3 p) {\n    // <draw stem>\n    \n    // To see complete shape, just set 0.6 to scale\n    float scale = 0.6;// * saturate(1.5 * sin(0.05 * iTime));\n    float width = mix(0.3 * scale, 0.0, saturate(p.y)); // which means width gradually thin from the origin, from 0.3 * scale to 0.0\n    vec3 size = vec3(width, 1.0, width);\n    // To see how the box looks like, uncomment this line\n    //p.xz *= rot(iTime * 0.1);\n    float d = sdBox(p, size);\n    \n    // </draw stem>\n    \n    // <draw branches>\n    // same idea with tree fold\n    for (int i = 0; i < 10; i++) {\n        vec3 q = p;\n        q = foldX(q);\n        q.y -= 0.5 * size.y;\n        q.xy *= rot(-1.2);\n        d = min(d, sdBox(p, size));\n        p = q;\n        size *= scale;\n    }\n    // </draw branches>\n\n    return d;\n}\n\nfloat dSnowCrystal(inout vec3 p) {\n    // To see the effect of foldRotate, comment this line out. You would see a shape like a tree.\n    p.xy = foldRotate(p.xy, 6.0);\n    return dTree(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0.0,0,-3);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=dSnowCrystal(p));\n    if(d<.001)fragColor+=3./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 166, 166, 262], [264, 305, 345, 345, 466], [468, 468, 488, 488, 524], [526, 526, 547, 623, 1318], [1320, 1320, 1354, 1452, 1509], [1511, 1511, 1568, 1568, 1797]], "test": "untested"}
{"id": "7tscWs", "name": "Blue glaze mosaic 2", "author": "jarble", "description": "A fractal mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 6, "viewed": 251, "published": 3, "date": "1648969573", "time_retrieved": "2024-07-30T16:55:35.025368", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*1.5*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float p1 = 1.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 12; k++){\n            uv += (t2.yx);\n            //uv /= 1.25;\n            //uv -= ceil(t2.x*t2.y+5.)/2.; //mosaic pattern\n\n            //uv += vec2(1.); //this also makes an interesting pattern\n            t2 = -p1*triangle_wave(uv-.5,scale).yx;\n            t3 = p1*triangle_wave(uv.yx,scale).yx;\n            uv.yx = (t2-t3);\n            uv /= 1.5;\n            p1 *= -1.;\n            //col.x = max(uv.y+uv.x-col.x,col.x*2.25);\n            //col = abs(col.yzx-vec3(1.5-col.x))/2.;\n            \n            col.x = max(uv.y+uv.x,col.x*2.75);\n            col = abs(col.yzx-vec3(1.-col.x))/2.;\n        }\n\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tscWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1163]], "test": "untested"}
{"id": "7llcWs", "name": "Blue glaze mosaic", "author": "jarble", "description": "A fractal mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 3, "viewed": 198, "published": 3, "date": "1648967336", "time_retrieved": "2024-07-30T16:55:35.792318", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float p1 = 1.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 12; k++){\n            uv += t2;\n            uv /= scale;\n            uv -= ceil(t2.x*t2.y+5.)/4.; //mosaic pattern\n\n            //uv += vec2(1.); //this also makes an interesting pattern\n            t2 = -p1*triangle_wave(uv-.5,scale);\n            t3 = p1*triangle_wave(uv.yx,scale);\n            uv = (t2-t3);\n            p1 *= -1.;\n            //col.x = max(uv.y+uv.x-col.x,col.x*2.25);\n            //col = abs(col.yzx-vec3(1.5-col.x))/2.;\n            \n            //uv.x -= .5;\n            \n            col.x =\n                max(uv.y+uv.x,col.x*2.75)\n                //max(floor((uv.y+uv.x)*8.)/8.,col.x*2.75)\n            ;\n            col = abs(col.yzx-vec3(1.-col.x))/2.;\n        }\n\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //multiply by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a *= 1. + mod(floor(a1/8.),2.);\n    //a *= 1. + mod(floor(a1/4.),2.);\n    //a *= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\nvec2 mainSound(int samp, float t){\n  t /= 1.5;\n  \n  float s1 =\n      8.;\n  //t = t + floor(t/s1+floor(t*s1))/s1;\n  //t = t + fmod(t*s1,floor(t)+1.)/s1;\n\n  //t = t + floor(floor(t*s1)+floor(t/s1))/s1;\n  \n  float\n  m1 =\n      mod(floor(t)+floor(t*s1)/s1+floor(t)/s1,s1)\n      //fmod(t*s1,s1)\n      //fmod(t+floor(t*s1),s1)\n      //fmod(t+floor(t)*floor(t/s1),s1)\n  ;\n\n  float m3 =\n      fmod(floor(t*s1)+floor(t/s1)/s1,s1)\n      //fmod((t*8.)/(fmod(t*s1,m1+1.)+.5),s1*z1)\n      //fmod((t*8.+m1),s1*z1)\n  ;\n  t *=\n      1.+fmod(floor(t*s1)/s1+m1,2.)\n      //1.+fmod(floor(t*s1/(.5+m1*2.))*floor(t/s1/(.5+m1*4.)+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n      \n  \n  float a=sqrt((1.-sqrt(fract(t))))*.2,\n\n  nb = pow(2.,(m3)/5.+7.);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1246]], "test": "untested"}
{"id": "7tlcWs", "name": "Daily Five - Lambmeow", "author": "lambmeow", "description": "Every day, All day", "tags": ["sdf", "glow", "daily", "v"], "likes": 3, "viewed": 225, "published": 3, "date": "1648965676", "time_retrieved": "2024-07-30T16:55:36.595171", "image_code": "//Daily Shader Day 5\n//lopea\n\n//thank you iq for these sdf functions\n//https://iquilezles.org/articles/distfunctions2d\n\nfloat box(vec2 v, vec2 b)\n{\n    vec2 q = abs(v) - b;\n    return length(max(q,0.)) + min(max(q.x, q.y),0.);\n}\nmat2 rot(float r)\n{\n    float cr = cos(r), sr = sin(r);\n    return mat2(cr, -sr, sr, cr);\n}\nfloat cinco(vec2 p)\n{\n    //offset\n    p.y-= -0.25;\n    \n    //get bounds of the v\n    float bb = box(p, vec2(1));\n    \n    //get \n    p.x = abs(p.x);\n    p *= rot(radians(25.));\n    float res = max(box(p - vec2(0.,0), vec2(0.1,2)), bb);\n    return abs(res);\n}\nfloat ss(vec3 p) \n{\n    p.z = mod(p.z + 7.,14.) - 7.;\n    //get 5\n    float cc = cinco(p.xy);\n    \n    ///extrude it\n    vec2 w = vec2( cc, abs(p.z - .6));\n    return min(max(w.x, w.y), 0.) + length(max(w,0.));\n}\n\nvec3 rt(vec3 ro, vec3 rd, out vec3 p)\n{\n    vec3 dl = vec3(0, 0, 1000.);\n    \n    for(int i = 0; i < 200; i ++)\n    {\n        p = ro + rd * dl.y;\n        dl.x = ss(p);\n        dl.z = min(dl.x, dl.z);\n        dl.y += dl.x;\n        if(dl.x < 0.001 || dl.y > 100.)\n            break;\n    }\n    return dl;\n}\n\nvec4 gc(vec3 ro, vec3 rd)\n{\n    vec3 p;\n    vec3 r = rt(ro, rd, p);\n    float d = r.z;\n    \n    p.z = (mod(p.z + 7.,14.) - 7.);\n    \n    float atten =  1. + d*d * 1.4 + d * 5.;\n    return vec4(1./atten)+ max(vec4(asin(p.x + p.y +p.z)) * 0.2, 0.); \n}\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = (2. * f - r)/r.y;\n    vec3 ro = vec3(0,0,iTime), rd = normalize(vec3(u, 4.)), p;\n    c = gc(ro,rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 147, 147, 228], [229, 229, 248, 248, 320], [321, 321, 342, 355, 581], [582, 582, 601, 601, 794], [796, 796, 835, 835, 1099], [1101, 1101, 1128, 1128, 1350], [1351, 1351, 1390, 1390, 1525]], "test": "untested"}
{"id": "7tscWl", "name": "Aha Moments", "author": "scry", "description": "Almost there, just a little further...", "tags": ["sound", "shepardtone"], "likes": 5, "viewed": 246, "published": 3, "date": "1648941062", "time_retrieved": "2024-07-30T16:55:37.340179", "image_code": "// Fork of \"sHePaRd ToNe\" by scry. https://shadertoy.com/view/ftXyWs\n// 2022-04-02 22:38:28\n\n// Fork of \"note scale fork aabna\" by scry. https://shadertoy.com/view/ftXcRH\n// 2022-04-02 04:47:04\n\n// Fork of \"note scale\" by scry. https://shadertoy.com/view/ftfyRr\n// 2022-03-16 07:23:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime+uv.x*0.1;\n    vec3 s = soundfunc(1,time);\n    vec3 col = vec3(0.);\n    //col += t*uv.y*20.;\n    //col \n    col.rg += 1.*step(s.z/1000.+uv.y,1.)*0.8;\n    //col.rgb += 1.*step(s.z/100.+uv.y,1.)*0.8;\n    col.bg += step(s.x+uv.y*2.,1.)*0.3;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    return soundfreq(samp,time);\n}", "sound_inputs": [], "common_code": "float a = pow(2.,1./12.);\n#define pi 3.14159265\n#define tau pi*2.\n\n//https://www.shadertoy.com/view/ttBXRG\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n\nfloat scale(float t) {\n    t = 440.*pow(a,(staircase(t*2.,0.001)/2.)-5.);\n    //t = 440.*pow(a,floor(abs(fract(t)-0.5)*24.)*2.-12.);\n    return t;\n}\nfloat tone(float t,float tm) {\n    t = sin(6.2831*t*tm);\n    return t;\n}\nfloat wop(float t,float tm,float bps) {\n    t *= pow(exp(-4.*abs(fract(-tm*bps-0.15)-0.5)),13.);\n    return t;\n}\nfloat wop1(float t,float tm,float bps) {\n    t *= pow(exp(-4.*abs(fract(-tm*bps-0.15)-0.5)),5.);\n    return t;\n}\nfloat bong(float t,float tm,float bps) {\n    t*=exp(-4.0*fract(tm*bps));\n    //t *= pow(exp(-4.*abs(fract(-tm*bps-0.15)-0.5)),13.);\n    //t*=exp(-24.0*fract(-tm*bps+0.7));\n    //t *= step(fract(tm*bps+0.03),0.03);\n    //float tc = clamp(sin(tm*tau*bps+4.66)*0.5+0.5,-1.,0.1);\n    //t *= 1.-pow(1.-tc,2.);\n    //t *= 22.;\n    //t *= 0.;\n    return t;\n}\n\nfloat shep(int ste,float time) {\n    float f = 40.;\n    float s = 0.;\n    float bps = 0.5;\n    for (int i=0;i<ste;i++) {\n        //bps *= 2.;\n        s += tone(time,f);\n        s += tone(time,f+bps);\n        bps *= 1.05+sin(time);\n        f *= 1.+fract(time*0.01+float(i*90)/13.);\n        //n += time*0.1;\n        //n = fract(n*12.)/12.;\n        //s += bong(tone(time,scale(n)),time,bps)*am;\n        //am *= 0.88;\n        //s += bong(tone(time,scale(t)),time,float(i));\n    }\n    return s;\n}\n\nvec3 soundfunc( int samp, float time )\n{\n    float t = time*0.1;\n    float ot = t*0.02;\n    vec2 fs = vec2(0.);\n    float s = 0.;\n    float stime = time+1.;\n    s = wop1(tone(scale(fract(stime/2./20.)*4.),time),time,0.1)*0.5;\n    float bps = 0.5;\n    float am = 1.;\n    for (int i=0;i<6;i++) {\n        s += bong(tone(scale(fract(stime/12./2.+float(i))*4.*bps)-24.,time),time,bps)*am;\n        am *= 0.7;\n        bps *= 2.;\n    }\n    bps = 2.;\n    am = 0.7;\n    for (int i=0;i<6;i++) {\n        s += wop(tone(scale(fract(stime/8./2.+float(i))*4.*bps)-2.,time),time,bps)*am;\n        am *= 0.7;\n        bps *= 2.;\n    }\n    fs = vec2(s)*0.5;\n    return vec3( fs.x , fs.y , ot );\n}\nvec2 soundfreq( int samp, float time )\n{\n    return soundfunc(samp,time).xy;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tscWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 343, 393, 750]], "test": "untested"}
{"id": "ftXyWs", "name": "sHePaRd ToNe", "author": "scry", "description": "spooky sounmds", "tags": ["sound", "shepardtone"], "likes": 5, "viewed": 224, "published": 3, "date": "1648934819", "time_retrieved": "2024-07-30T16:55:38.166969", "image_code": "// Fork of \"note scale fork aabna\" by scry. https://shadertoy.com/view/ftXcRH\n// 2022-04-02 04:47:04\n\n// Fork of \"note scale\" by scry. https://shadertoy.com/view/ftfyRr\n// 2022-03-16 07:23:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime+uv.x*0.1;\n    vec3 s = soundfunc(1,time);\n    vec3 col = vec3(0.);\n    //col += t*uv.y*20.;\n    //col \n    col.rg += 1.*step(s.z/1000.+uv.y,1.)*0.8;\n    //col.rgb += 1.*step(s.z/100.+uv.y,1.)*0.8;\n    col.bg += step(s.x+uv.y*2.,1.)*0.3;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    return soundfreq(samp,time);\n}", "sound_inputs": [], "common_code": "float a = pow(2.,1./12.);\n#define pi 3.14159265\n#define tau pi*2.\n\n//https://www.shadertoy.com/view/ttBXRG\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n\nfloat scale(float t) {\n    t = 440.*pow(a,(staircase(t*2.,0.001)/2.)-5.);\n    //t = 440.*pow(a,floor(abs(fract(t)-0.5)*24.)*2.-12.);\n    return t;\n}\nfloat tone(float t,float tm) {\n    t = sin(6.2831*t*tm);\n    return t;\n}\nfloat bong(float t,float tm,float bps) {\n    t*=exp(-4.0*fract(tm*bps));\n    float tc = clamp(sin(tm*tau*bps+4.66)*0.5+0.5,-1.,0.1);\n    t *= 1.-pow(1.-tc,2.);\n    t *= 22.;\n    //t *= 0.;\n    return t;\n}\n\nfloat shep(int ste,float time) {\n    float f = 40.;\n    float s = 0.;\n    float bps = 0.5;\n    for (int i=0;i<ste;i++) {\n        //bps *= 2.;\n        s += tone(time,f);\n        s += tone(time,f+bps);\n        bps *= 1.05+sin(time);\n        f *= 1.+fract(time*0.01+float(i*90)/13.);\n        //n += time*0.1;\n        //n = fract(n*12.)/12.;\n        //s += bong(tone(time,scale(n)),time,bps)*am;\n        //am *= 0.88;\n        //s += bong(tone(time,scale(t)),time,float(i));\n    }\n    return s;\n}\n\nvec3 soundfunc( int samp, float time )\n{\n    float t = time*0.1;\n    float ot = t*0.02;\n    //float s = bong(tone(time,scale(t)),time,5.);\n    float s = 0.;\n    float bps = 1.;\n    float bpm = 40.;\n    bps = bpm/60.;\n    float n = 1.;\n    float am = 1.;\n    float f = 40.;\n    //s += shep(4,time)*shep(4,-time)*0.3;\n    float shu = shep(10,time);\n    float shd = shep(10,-time);\n    float r = 0.02;\n    //shu *= r;\n    //shd *= r;\n    vec2 fs = vec2(shu,shd);\n    fs = mix(fs,vec2(shd,shu),sin(time*4.)*0.5+0.5);\n    fs *= r;\n    //s = mix(shu,shd,sin(time*4.)*0.5+0.5);\n    //s += shep(4,time)+shep(4,-time);\n    //s *= 0.5;\n    /*for (int i=0;i<15;i++) {\n        //bps *= 2.;\n        s += tone(time,f);\n        s += tone(time,f+bps);\n        bps *= 2.;\n        f *= 1.+fract(time*0.01+float(i*90)/13.);\n        //n += time*0.1;\n        //n = fract(n*12.)/12.;\n        //s += bong(tone(time,scale(n)),time,bps)*am;\n        //am *= 0.88;\n        //s += bong(tone(time,scale(t)),time,float(i));\n    }\n    f = 40.;\n    //s = 0.;\n    for (int i=0;i<15;i++) {\n        //bps *= 2.;\n        s += tone(time,f);\n        s += tone(time,f+bps);\n        bps *= 2.;\n        f *= 1.+fract(-time*0.01+float(i*80)/13.);\n        //s += tone(time,f);\n        //s += tone(time,f-bps);\n        //bps *= 1.01;\n        //f *= 1.+fract(-time*0.01+float(i)/13.);\n        //n += time*0.1;\n        //n = fract(n*12.)/12.;\n        //s += bong(tone(time,scale(n)),time,bps)*am;\n        //am *= 0.88;\n        //s += bong(tone(time,scale(t)),time,float(i));\n    }*/\n    //s *= 0.04;\n    return vec3( fs.x , fs.y , ot );\n}\nvec2 soundfreq( int samp, float time )\n{\n    return soundfunc(samp,time).xy;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 250, 300, 657]], "test": "untested"}
{"id": "flscWl", "name": "Waves displacement", "author": "henryco", "description": "Wave interference but no diffraction,\nThis is my first experiment with shaders here, not a glsl expert tbh", "tags": ["2d", "waves", "wave", "displacement", "distortion"], "likes": 1, "viewed": 234, "published": 3, "date": "1648911189", "time_retrieved": "2024-07-30T16:55:38.974809", "image_code": "#define PI 3.141592654\n\nprecision highp float;\n\n// wave frequency, not Hz\nconst float freq = 30.;\n\n// speed of wave propagation\nconst float speed = 5.;\n\n// power of wave suppresion over distance\nconst float diming = 5.;\n\n// maximum thickness of wave \nconst float window = .25;\n\n// maximum texture displacement value\nconst float maximum = .1;\n\n// add more wave sources here\nconst vec2[] points = vec2[](\n    vec2(.1, .1),\n    vec2(.9, .2),\n    vec2(.3, .4)\n);\n\n// just for visualization purpose, remove it later\nfloat deubgColor(float x) {\n    return .5 * (x + 1.);\n}\n\nfloat suppresion(float len, float power) {\n    return 1. / pow(abs(len) + 1., power);\n}\n\nfloat delta(float duration) {\n    if (sin(duration * iTime) <= 0.)\n        return 0.;\n    return fract(duration * iTime / PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float delta = delta(.5);\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.);\n\n    float dAmplitude = 0.;\n    for (int i = 0; i < points.length(); i++) {\n        vec2 center = points[i];\n        vec2 uv = (fragCoord.xy / iResolution.xy) - center;\n        float r = length(uv * ratio);\n\n        float phase = delta * speed;\n        float amplitude = suppresion(r, diming) * cos(freq * (r - phase));        \n        \n        float sx = phase - window;\n        float ex = sx - window;\n\n        if (r > sx || r < ex) {\n            float dist = min(abs(sx - r), abs(ex - r));\n            float sp = 1. - smoothstep(0., window, dist);\n            amplitude *= sp;\n        }\n        dAmplitude += amplitude;\n    }\n\n    \n    float displace_k  = dAmplitude * maximum;\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    vec2 displaced_uv = vec2(uv.xy + displace_k);\n\n    fragColor = texture(iChannel0, displaced_uv);\n    \n    // just for visualization purpose, remove it later\n    if (uv.x < 0.5) fragColor = vec4(vec3(deubgColor(dAmplitude)), 1.);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flscWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[460, 511, 538, 538, 566], [568, 568, 610, 610, 655], [657, 657, 686, 686, 785], [787, 787, 844, 844, 1895]], "test": "untested"}
{"id": "flXcWl", "name": "Day Four - Lambmeow", "author": "lambmeow", "description": "im so brain ded", "tags": ["sdf", "refraction", "daily"], "likes": 1, "viewed": 157, "published": 3, "date": "1648883724", "time_retrieved": "2024-07-30T16:55:39.711838", "image_code": "//Day 4 Lambmeow\n//This one was all over the place, was planning on adding a proper fresnel on the reflection but couldnt get it work\n//so total refraction it is.\n//Lopea 2022\n\n#define time (mod(iTime, 50.))\nfloat cir(vec3 p, float d)\n{\n  \n   p = mod (p + vec3(6.,6.,10.), vec3(12, 12.,20.)) - vec3(6., 6.,10.);\n   p.y += 2.5;\n   p.x = abs(p.x) - 3.;\n   \n   vec3 q = abs(p - vec3(0,5., 0)) - vec3(1,2., 1);\n   float ang = radians(180.);\n   p.xy *= mat2(cos(ang), -sin(ang), sin(ang),cos(ang));\n   p.y *= .78;\n  vec3 qa = abs(p);\n     \n   float tr =  max(qa.z-1.,max(qa.x*0.866025+p.y*0.5,-p.y)-2.*0.5);\n   return min(tr, length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.));\n}\n\nfloat box(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    \n    return length(max(p, 0.)) + min(max(q.x,max(q.y,q.z)), 0.);\n}\n\nfloat four(vec3 p)\n{\n    return length(p) - 1.;\n}\n\nvec2 ss(vec3 p)\n{\n  \n    vec2 res = vec2(100, -1); \n    \n    float a = cir(p, 1.);\n    \n    res.x = min(a, res.x);\n    \n    if(a < 0.01)\n       res.y = 1.;       \n    float b = four(p - vec3(0, 0, time *  10.));\n    res.x = min(res.x, b);\n    \n    if(abs(res.x- b) < 0.01)\n        res.y = 0.;\n    \n    return res;\n        \n}\n\nvec3 nn(vec3 p)\n{\n    vec3 n = vec3(0);\n    for(int i = min(iFrame, 0); i < 4; i ++)\n    {\n        vec3 e = 0.5773* (2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*ss(p +e*0.0001).x;\n    }\n    return normalize(n);\n}\nvec2 rt(vec3 ro, vec3 rd, inout vec3 p)\n{\n    vec2 dd = vec2(0);\n    float ll = 0.;\n    \n    for(int i = 0; i < 200; i ++)\n    {\n       p = ro + rd  * ll;\n       \n       dd = ss(p);\n       \n       ll += dd.x;\n       \n       if(dd.x < 0.001 || ll > 100.)\n           break;\n    }\n    \n    if(dd.x > 0.001)\n        p = vec3(-1);\n    return dd;\n}\n\n\nvec4 rfl( vec3 ro, vec3 rd, inout vec3 p)\n{\n    vec2 dd;\n    \n    for(int i = 0; i < 2; i ++)\n    {\n    dd = rt(p, rd, p); \n    if(dd.x > 0.01)\n        return vec4(rd, -1);\n        vec3 n = nn(p);\n        rd = (refract(n, rd, 0.55));\n       p += rd * 0.001;\n   }\n   return vec4(rd, dd.y);\n}\n\nvec4 bb(vec3 p, vec3 rd, float id,vec3 ro)\n{\n\n  float y = max(.5 - rd.y, 0.);\n  vec4 bg = vec4((1.- y) * vec3(0.5, 0.5,.8), 1.) +  vec4(y * vec3(0.2, 1., 0.8), 1.);\n  if(id == 1.)\n  {\n     vec3 n = nn(p);\n     vec3 ll = normalize(vec3(1, 1 , 1));\n     float ndl = max(dot(ll, n), 0.);\n     float noise = texture(iChannel0, floor(p.xy)/10000. + sin(time + 3.) * .001).r; \n     return mix(vec4(noise * vec3(.2,.5, .5),1.), bg, vec4( ndl * length(ro - p)/100.));\n  }\n  return bg;\n}\n\nvec4 gc(vec3 ro, vec3 rd)\n{\n   vec3 p = ro;\n   vec3 rp = p;\n\n   \n   //first hit\n   vec3 op = p;\n   vec2 dd = rt(ro, rd, op);\n   \n   \n   if(dd.x < 0.001)\n   {\n   if(dd.y == 0.)\n   {\n   vec4 refl = rfl(p,rd, p);\n   vec4 crel = bb(p, refl.xyz, refl.w, ro);\n   vec3 n = nn (p);\n   vec3 ll = normalize(vec3(1,1,1));\n       float spec = dot(reflect(n, ll),-rd); \n       return crel * 0.25 + vec4(.3,0,.9,1) * max(dot(normalize(vec3(1,1,1)), n),0.);\n   }\n   }\n   \n   return bb(op, rd, dd.y, ro);\n}\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 r= iResolution.xy, u = (2. * f - r)/r.y;\n    vec3 ro = vec3(0, 0,time *  10.  - 10.), rd = normalize(vec3(u, 2.));\n    \n\n    c = gc(ro,rd);\n    \n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 236, 236, 678], [680, 680, 716, 716, 812], [814, 814, 834, 834, 863], [865, 865, 882, 882, 1189], [1191, 1191, 1208, 1208, 1422], [1423, 1423, 1464, 1464, 1765], [1768, 1768, 1811, 1811, 2058], [2060, 2060, 2104, 2104, 2538], [2540, 2540, 2567, 2567, 3030], [3031, 3031, 3072, 3122, 3278]], "test": "untested"}
{"id": "flfyDl", "name": "Short bleh song", "author": "scry", "description": "Just messing around", "tags": ["sound"], "likes": 2, "viewed": 227, "published": 3, "date": "1648881725", "time_retrieved": "2024-07-30T16:55:40.448867", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat message(vec2 uv) { // to alter in the icon\n    \n    //uv.y += sin(acos(-1.)*iTime/beat + sin(acos(-1.)*iTime/beat*2.)*float(iTime > msr*2.));\n    \n    uv-=vec2(1.,10.); \n    uv -= vec2(16.,1.5);\n    //uv *= 0.5;\n    //uv.xy *= rot(sin(acos(-1.)*iTime/beat*0.5)*0.1*mod(iTime/beat,2.));\n    \n    //uv += cyclicNoise(vec3(uv*0.2,iTime + sin(iTime)));\n        \n    uv += vec2(16.,1.5);\n    if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\t//tGlobal = iTime*2.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n    /*\n    if(iTime > msr*6.)\n        fragColor = 0.5 + 0.5*sin(fragColor + iTime);\n    */\n}   ", "image_inputs": [], "sound_code": "#define pi 3.14159265\n#define tau pi*2.\n\n//https://www.shadertoy.com/view/ttBXRG\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n\nfloat FtoS(float f,float time) {\n    return sin(f*tau*time);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float f = 140.;\n    float a = FtoS(f,time);\n    f += sin(time*0.1);\n    a += FtoS(f*0.1,time);\n    float ii = 1.;\n    f *= 2.;\n    for (int i=0;i<60;i++) {\n        f += sin(time*0.08*ii)*20.1;\n        a *= 1.7;\n        a *= 0.475;\n        a += FtoS(f+a*0.001,time);\n        ii *= 1.5*0.5;\n    }\n    a = clamp(a*0.003,-1.,1.)/4.;\n    f = 60.;\n    float bpm = 34.;\n    float am = 1.32;\n    float s = staircase(time/4.,0.01)+1.;\n    //int s = int(time/4.);\n    //s = exp(s);\n    //s = int(time)/s;\n    for (int i=0;i<7;i++) {\n        if (i > int(s)) {break;}\n        if (i > 1) {\n            am *= sin(time*((bpm/4.)/60.))*0.5+0.5;\n            //bpm += sin(time*0.1)*f*0.01;\n            //am *= 0.5;\n        }\n        //a = FtoS(f,time);\n        ///a = FtoS(f,time)*sin(time*pi*(bpm/60.))*exp(-3.*fract(time*(bpm/60.)));\n        \n        a += FtoS(f,time)*exp(-3.*(fract(time*(bpm/60.))))*am;\n        //f *= 1.25+sin(time*0.3)*0.5;\n        f *= 1.05;\n        f = fract(f/400.+time*0.1)*100.;\n        f -= fract(time*0.15)*1.;\n        //am *= 0.8+sin(time)*0.2;\n        bpm *= 2.;\n    }\n    a /= 8.;\n    return vec2(a);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 75, 198, 823], [832, 832, 889, 950, 1263]], "test": "untested"}
{"id": "NtXyWs", "name": "Banded mosaic", "author": "jarble", "description": "A simple mosaic pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "mosaic"], "likes": 4, "viewed": 365, "published": 3, "date": "1648875687", "time_retrieved": "2024-07-30T16:55:41.191882", "image_code": "\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 triangle_wave(vec2 a,float num){\n    //a = rotate(a,num*radians(180.));\n    //a += .5;\n    vec2 to_return = abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n    //to_return /= 1.5; //makes another interesting pattern\n    return\n        to_return\n        //to_return + dot(to_return,to_return)/8. //makes another interesting pattern\n\n    ;\n    //return abs(fract((a+vec2(1.,1.5)+num)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    float scale = 1.5;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 12; k++){\n            //k += int(uv.y<uv.x);\n            \n            //uv -= fpow(uv.x,2.); //flower pattern\n\n            //uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n            \n            //A really cool pattern:\n            //uv += floor(uv/1.5)/1.5;\n\n            uv.y += fmod1(uv.y,1.5); //lace pattern\n            //uv += floor(uv+vec2(1.,.5))/1.5;\n            float p1 = sign(uv.x);\n            //uv += ceil(uv.x)/2.;\n            //uv.x -= floor(uv.x)/scale;\n            //t2 = abs(t2*2.);\n            \n            //uv += floor(t2.x-t2.y);\n            \n            uv =\n                //fract(uv + t2+.5)\n                -abs(uv + t2)\n            ;\n            //uv += (distance(floor(uv),round(uv+.5)));\n            //uv = max(-uv,uv*sign(uv.yx-uv));\n            //uv = abs(uv);\n\n            //uv += t2-float(k)/(4.-(uv.x-uv.y)/(4.-(uv.x-uv.y))); //this makes an even crazier pattern\n            \n            //uv.y += fpow(uv.y,2.)/2.;\n            //uv.x += fpow(uv.x+1.,2.)/2.;\n            \n            uv /= scale;\n            //uv -= ceil(t2.x*t2.y+5.)/4.; //mosaic pattern\n\n            //uv += vec2(1.); //this also makes an interesting pattern\n            float num = (1.+(uv.x-uv.y)/8.)*float(k)/(7.);\n            \n            //uv = uv*sign(uv.y-uv.x) + floor(uv.x-uv.y)*floor(t2.y-t2.x);\n            //uv = abs(uv);\n            \n            //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n            t2 =\n                -p1*triangle_wave(uv-.5,num)\n                //-p1*triangle_wave(abs(uv-.5),num)\n                //-p1*triangle_wave(uv-.5,num)/(.5+fmod(t2.x,2.))\n                //-p1*triangle_wave(uv-.5-fmod(t2.x/1.5,2.),num)\n            ;\n            t3 =\n                p1*triangle_wave(uv.yx,num)\n                //p1*triangle_wave(abs(uv.yx),num)\n            ;\n            //t2 -= abs(t2-.5)/8.;\n            //t3 -= abs(t3-.5)/8.;\n            \n            \n            \n            uv = t2-t3;\n            //uv.y -= .5*sign(uv.y);\n            \n            //if(uv.x > uv.y) uv /= 1.5;\n\n            //col.x = abs(col.x-.5);\n            \n            //uv.x -= .5;\n            \n            //if(uv.x>uv.y)\n            col.x =\n                //max(floor((uv.y-uv.x*p1)*8.)/8.-col.x,col.x*2.25)\n                max(uv.y-uv.x*p1-col.x,col.x*2.25)\n            ;\n            col = abs(col.yzx-vec3(1.5-col.x))/2.;\n                            //if(uv.x < uv.y) col = col.yzx;\n            //if(uv.x>uv.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n            \n            //uv.x += .5; //pink flower pattern\n            //col *= col.yzx;\n            //if(uv.x>uv.y) uv *= 2.; else uv -= .5;\n            //if(uv.x<uv.y) uv.y += .5;\n\n        }\n\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  //t /= 1.5;\n  \n  //t *= (1.+mod(floor(t/8.),2.))/2.;\n  //t /= (1.+mod(floor(t*8.),2.));\n  \n  float t0=t, s1 =\n      8.\n      //pow(2.,2.+fmod(t/2.,2.))\n  ,\n  d1 = \n      //floor(t/s1+floor(t*s1))\n      fmod(t*s1,floor(t)+4.)\n  ;\n  float p1 = pow(2.,fmod(t,3.)+1.)/s1;\n  t = t + floor(t/p1)*p1;\n\n  //t = t + floor(floor(t*s1)+floor(t/s1))/s1;\n  \n  float\n  m1 =\n      fmod(t*s1+d1,s1)+1.\n      //fmod(t*s1+d1-mod(t*s1+d1,s1/2.),s1)+1.\n      //fmod(t*s1,s1)\n      //fmod(t+floor(t*s1),s1)\n      //fmod(t+floor(t)*floor(t/s1),s1)\n  ,\n  z1 =\n      (1.+fmod(t+m1,2.))\n      //(1.+fmod(t*sign(d1-m1)+m1,2.))\n      //(1.+fmod(t+m1+mod(t+m1,1.),2.))\n      //(1.+fmod(t/s1+floor(t),2.))\n      //(1.+fmod(t/s1+m1,2.))\n  ;\n  t /=\n      z1\n      //1.+fmod(floor(t*s1+m1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n  float m3 =\n      fmod((t*8.+z1*8.)/(m1*s1+1.+.5),s1)\n      //fmod((t*8.)/(fmod(t*s1,m1+1.)+.5),s1*z1)\n      //fmod((t*8.+m1),s1*z1)\n  ;\n\n      //1.+fmod(floor(t*s1/(.5+m1*2.))*floor(t/s1/(.5+m1*4.)+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n      \n      \n  float a =\n      //2.*sqrt((1.-sqrt(max(fract(t*s1),fract(t/s1)))))*.2\n      log(max(fract(t*s1),fract(t/s1))/2.)/2.\n  ,\n\n  nb = pow(2.,(m3+z1)/5.+8.)*tempo;\n\n  return abs(.5-vec2(fract(t*nb*.998)\n   ,fract(t*nb)))*a;\n\n}", "sound_inputs": [], "common_code": "#define fmod3(a,b) mod(floor(a) + floor((a)/2.)*2.+floor((a)/4.)*4.+floor((a)/8.)*8.+floor((a)/16.)*16.,b)\n#define fmod2(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n#define fmod1(x,y) mod(floor(x),y)\n#define fmod(x,y) max(mod(floor(x+floor(t0/y)),y),fmod1(x,y))\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/3.)),b)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,mod(floor(x),y))\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))", "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 32, 32, 116], [118, 118, 155, 209, 507], [509, 509, 566, 566, 3708]], "test": "untested"}
{"id": "NlfcWl", "name": "Fractal veins", "author": "jarble", "description": "A fractal with vein-like patterns.", "tags": ["fractal", "veins"], "likes": 5, "viewed": 273, "published": 3, "date": "1648868203", "time_retrieved": "2024-07-30T16:55:41.989748", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*4.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float p1 = 1.;\n    for(int i=0;i<1;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 18; k++){\n            //uv.x += ceil(uv.x+float(k))/3.; \n\n            uv += (t2.yx);\n            //uv -= ceil(t2.x*4.)/4.; //mosaic pattern\n\n            uv /= scale;\n            uv += vec2(1.); //this also makes an interesting pattern\n            t2 = -p1*triangle_wave(uv-.5,1.5);\n            t3 = p1*triangle_wave(uv.yx,1.5);\n            //t2 = abs(t2-.5);\n            //t3 = abs(t3-.5);\n            uv.yx = (t2+t3);\n            p1 *= -1.;\n            col.x = max(uv.y-uv.x-col.x,col.x*2.5);\n        //col.x = min(uv.y-uv.x+col.x,col.x*2.);\n        \n        //uv.x *= -1.;\n        \n        //col.x = abs(col.x-.5);\n        col = abs(col.yzx-vec3(1.5-col.x))/2.;\n        //uv.x += .5;\n        //col = abs(col.yzx+vec3(col.x)*2.)/3.;\n        }\n        \n\n        uv.y *= -1.;\n    }\n    fragColor = vec4(col*1.5,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1441]], "test": "untested"}
{"id": "NlfyWl", "name": "  repeat TriPrism", "author": "jorge2017a2", "description": "repeat TriPrism", "tags": ["repeattriprism"], "likes": 6, "viewed": 212, "published": 3, "date": "1648865656", "time_retrieved": "2024-07-30T16:55:42.777641", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 FigurasTriangulos(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n    p.x= opRep1D(p.x, 30.0);\n    p.z= opRep1D(p.z, 30.0);\n    float j;\n    for(float i=0.0;i<5.0;i++)\n    {   float d1= sdTriPrism(p-vec3(0.0*4.0,i,i+0.0*4.0), vec2(8.0,2.0) );\n        float d2= sdTriPrism(p-vec3(1.0*4.0,i,i+1.0*4.0), vec2(8.0,2.0) );\n        float d3= sdTriPrism(p-vec3(2.0*4.0,i,i+2.0*4.0), vec2(8.0,2.0) );\n        res =opU2(res, vec2(d1,100.0));\n        res =opU2(res, vec2(d2,100.0));\n        res =opU2(res, vec2(d3,100.0));\n        j=j+1.0;\n    }\n  return res;\n}   \n\n//https://www.shadertoy.com/view/flfczs....Created by MelisaHot in 2022-03-28\nconst mat2 m2 = mat2(1.6,-1.2,1.2, 1.6);\n\nfloat cosNoise( in vec2 p )\n{ return 0.4*( sin(p.x) + sin(p.y) );}\n\nfloat Tierra( in vec3 pos )\n{  float h = 0.0;\n    vec2 q = pos.xz*0.5;    \n    float s = 0.5;\n    for( int i=0; i<6; i++ )\n    {   h += s*cosNoise( q ); \n        q = m2*q*0.9-iTime; \n        q += vec2(2.,5.);\n        s *= 0.5 + 0.2*h;\n    }\n h *= 2.0;\n return pos.y - h;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0+Tierra(p);  //piso inf\n    res =opU2(res, vec2(planeDist1,100.0));\n    vec2 fig1= FigurasTriangulos(p);\n    vec2 fig2= FigurasTriangulos(p-vec3(15.0,-5.0,0.0));\n    res =opU2(res, fig1);\n    res =opU2(res, fig2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n\n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=8.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    \n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;       \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50) { colobj=getColor(int( id_color));  return colobj; }\n   if (id_color==100 )\n   { return  getColorTextura( p, nor,100); }\n        \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));        \n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*0.5,100.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,14.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x+3.0*sin(t),uv.y,1.0));\n   rd= rotate_x(rd, radians(20.0));\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0)  //5\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i];}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 472, 508, 508, 553], [555, 580, 614, 614, 710], [711, 711, 745, 745, 836], [837, 837, 871, 871, 962], [964, 964, 1000, 1000, 1083], [1085, 1085, 1117, 1117, 1635], [1760, 1760, 1789, 1789, 1826], [1828, 1828, 1857, 1857, 2100], [2102, 2102, 2127, 2127, 2428], [2430, 2430, 2454, 2454, 2616], [2618, 2618, 2666, 2666, 2940], [2942, 2942, 2986, 2986, 3307], [3309, 3309, 3346, 3346, 3603], [3605, 3605, 3695, 3695, 4715], [4717, 4717, 4766, 4766, 4899], [4901, 4901, 4933, 4933, 5130], [5132, 5132, 5202, 5202, 5372], [5374, 5374, 5401, 5401, 5490], [5492, 5492, 5550, 5550, 5598], [5600, 5600, 5623, 5623, 5735], [5737, 5737, 5768, 5768, 6407], [6409, 6409, 6466, 6466, 6946]], "test": "untested"}
{"id": "ftXcWl", "name": "moving objects", "author": "jorge2017a2", "description": "moving objects", "tags": ["movingobjects"], "likes": 2, "viewed": 442, "published": 3, "date": "1648865635", "time_retrieved": "2024-07-30T16:55:43.524644", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 fig002rot(vec3 p)\n{  vec2 res= vec2(9999.0, -1.0);\n    float num=6.0;\n    float ang=360.0/num;\n    vec3 p0= rotate_x(p, radians(90.0)); \n    p0= rotate_y(p0, radians(-iTime*10.0)); \n    \n    for (float i=0.0; i<num;i++)\n    {   vec3 p1= rotate_y(p0, radians(ang*i)); \n        float d1= sdCylinderYZ(p1-vec3(5.0,0.0,0.0), vec2(1.0,4.0) );\n        vec3 p2=rotate_y(p1-vec3(-13.0,0.0,2.4), radians(-30.0));\n        float d2= sdCylinderYZ( p2, vec2(1.0,5.0) );\n        float uni1= opSmoothUnion(d1,d2, 2.5);\n        res=opU2(res,vec2(uni1,100.0));\n        \n    }    \n  return res;\n}\n\nvec2 figtrin(vec3 p)\n{\n  vec2 res= vec2(9999.0, -1.0);\n  float d1= sdCylinderXZ(p-vec3(0.0,0.0,0.0), vec2(0.5,4.0) );\n  float d2= sdCylinderXZ(p-vec3(2.0,-5.0,0.0),vec2(0.5,9.0) );\n  float d3= sdCylinderXZ(p-vec3(4.0,0.0,0.0), vec2(0.5,4.0) );\n  float d4= sdCylinderYZ(p-vec3(2.0,-3.0,0.0), vec2(0.5,3.0) );\n  res=opU2(res,vec2(d1,2.0));\n  res=opU2(res,vec2(d2,2.0));\n  res=opU2(res,vec2(d3,2.0));\n  res=opU2(res,vec2(d4,2.0));\n  \n  return res;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);vec3 p0=p;\n    p.y=p.y-5.0;\n\n    float pt=mod(iTime,7.0);\n    float px1, px2;\n    vec2 rf1,rf2;\n    \n    if(pt<3.5)\n    {    \n     px1=mod(iTime*10.0,70.);\n     px2=0.0;\n      rf1= fig002rot(p-vec3(px1,0.0,0.0));\n      rf2= figtrin(p-vec3(-2.0-px2,0.0,5.0));\n    }\n    else\n    {\n     px1=100.0;\n     px2=mod(iTime*10.,35.0);\n     rf1= fig002rot(p-vec3(px1,0.0,0.0));\n     rf2= figtrin(p-vec3(-2.0-px2,0.0,5.0));\n    }\n    res =opU2(res, rf1);\n    res =opU2(res, rf2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.1, tmax = 40.0;\n    vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n   for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = ro + rd * t;\n    vec3 V = -rd;\n    vec3 N = GetNormal(worldPos);\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, normalize(lightPos));// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient= 0.5*lightColor*clamp(0.5 + 0.5*N.y, 0.0, 1.0)*N.y;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff       = clamp(dot(N, L), 0.0, 1.0);\n    \n    diff = pow(diff, 4.) * 2.;\n    vec3 diffuse =  lightColor * diff;\n    float shininess=4.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);  \n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0);\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.35 +back) + vec3(.7,.9,1)*specular*specular;       \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<50) { colobj=getColor(int( id_color));  return colobj; }\n   if (id_color==100 )\n   { \n       float px1=mod(iTime*10.0,80.);\n       p.x-=px1;\n       return  getColorTextura( p, nor,100); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST) \n       {   p = (ro + rd * hit.x );  \n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));        \n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(3.0,8.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1)   //7\n\n);\n\nvec3 getColor(int i)\n{   if (i>-1 )  return Arrcolores[i]; }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 433, 470, 470, 565], [566, 566, 605, 605, 700], [701, 701, 740, 740, 835], [836, 836, 875, 875, 970], [972, 972, 1025, 1025, 1124], [1130, 1168, 1204, 1204, 1249], [1250, 1250, 1289, 1289, 1333], [1334, 1334, 1373, 1373, 1417], [1418, 1418, 1450, 1450, 1475], [1476, 1541, 1575, 1575, 1671], [1672, 1672, 1706, 1706, 1797], [1798, 1798, 1832, 1832, 1923], [1925, 1925, 1949, 1949, 2508], [2510, 2510, 2532, 2532, 2956], [2959, 2959, 2984, 2984, 3500], [3502, 3502, 3526, 3526, 3688], [3690, 3690, 3738, 3738, 4044], [4047, 4047, 4091, 4091, 4409], [4411, 4411, 4448, 4448, 4705], [4707, 4707, 4797, 4797, 5810], [5812, 5812, 5861, 5861, 5994], [5996, 5996, 6028, 6028, 6225], [6227, 6227, 6297, 6297, 6528], [6530, 6530, 6557, 6557, 6646], [6648, 6648, 6706, 6706, 6754], [6756, 6756, 6779, 6779, 6891], [6893, 6893, 6924, 6924, 7563], [7565, 7565, 7622, 7622, 8054]], "test": "untested"}
{"id": "NtfyWl", "name": "Custom Mandelbrot set", "author": "Fraktoler", "description": "Standard Mandelbrot fractal is iterated by the function z = z^p + c.", "tags": ["fractal", "mandelbrot", "complex"], "likes": 1, "viewed": 222, "published": 3, "date": "1648863560", "time_retrieved": "2024-07-30T16:55:44.354425", "image_code": "precision highp float;\n\nfloat mag(vec2 z) {\n    return length(z);\n}\n\nfloat mag2(vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 swap(vec2 z) {\n    return vec2(z.y, z.x);\n}\n\nvec2 rabs(vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(vec2 z, vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / mag2(w);\n}\n\nvec2 rec(vec2 z) {\n    return conj(z) / mag2(z);\n}\n\nvec2 squ(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n}\n\nvec2 cube(vec2 z) {\n    return z * vec2(z.x * z.x - 3.0 * z.y * z.y, 3.0 * z.x * z.x - z.y * z.y);\n}\n\nvec2 power(vec2 z, float p) {\n    return pow(mag2(z), p * 0.5) * cis(p * arg(z));\n}\n\nvec2 powervec2(vec2 z, vec2 w) {\n    float r = mag2(z);\n    float argz = arg(z);\n    float argzw = w.x * argz + 0.5 * w.y * log(r);\n    return pow(r, w.x * 0.5) * exp(-w.y * argz) * cis(argzw);\n}\n\nvec2 sqrtp(vec2 z) {\n    float r = mag(z);\n    return vec2(1.0, sign(z.y)) * sqrt(0.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 powexp(vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(vec2 z) {\n    return vec2(log(mag2(z)) * 0.5, arg(z));\n}\n\nvec2 logb(vec2 z, vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(squ_exp - vec2(1.0, 0.0), mulI(squ_exp + vec2(1.0, 0.0)));\n}\n\nvec2 tangent(vec2 z) {\n    if (z.y < -21.0) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(mulI(squ_exp + vec2(1.0, 0.0)), squ_exp - vec2(1.0, 0.0));\n}\n\nvec2 cot(vec2 z) {\n    if (z.y < -21.0) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(vec2 z) {\n    return rec(cosine(z));\n}\n\nvec2 csc(vec2 z) {\n    return rec(sine(z));\n}\n\nvec2 arcsin(vec2 z) {\n    return mulI(ln(sqrtp(vec2(1.0, 0) - squ(z)) - mulI(z)));\n}\n\nvec2 arccos(vec2 z) {\n    return -mulI(ln(mulI(sqrtp(vec2(1.0, 0) - squ(z))) + z));\n}\n\nvec2 arctan(vec2 z) {\n    return -0.5 * mulI(ln(div(vec2(0.0, 1.0) - z, vec2(0.0, 1.0) + z)));\n}\n\nvec2 arccot(vec2 z) {\n    return -0.5 * mulI(ln(div(z + vec2(0.0, 1.0), z - vec2(0.0, 1.0))));\n}\n\nvec2 arcsec(vec2 z) {\n    return arccos(rec(z));\n}\n\nvec2 arccsc(vec2 z) {\n    return arcsin(rec(z));\n}\n\nvec2 sinhyp(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp - vec2(1.0, 0.0), squ_exp + vec2(1.0, 0.0));\n}\n\nvec2 tanhyp(vec2 z) {\n    if (z.x > 21.0) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp + vec2(1.0, 0.0), squ_exp - vec2(1.0, 0.0));\n}\n\nvec2 coth(vec2 z) {\n    if (z.x > 21.0) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(vec2 z) {\n    return rec(coshyp(z));\n}\n\nvec2 csch(vec2 z) {\n    return rec(sinhyp(z));\n}\n\nvec2 arcsinh(vec2 z) {\n    return ln(z + sqrtp(squ(z) + vec2(1.0, 0.0)));\n}\n\nvec2 arccosh(vec2 z) {\n    return ln(z + mul(sqrtp(z + vec2(1.0, 0.0)), sqrtp(z - vec2(1.0, 0.0))));\n}\n\nvec2 arctanh(vec2 z) {\n    return 0.5 * ln(div(vec2(1.0, 0.0) + z, vec2(1.0, 0.0) - z));\n}\n\nvec2 acoth(vec2 z) {\n    return 0.5 * ln(div(z + vec2(1.0, 0.0), z - vec2(1.0, 0.0)));\n}\n\nvec2 asech(vec2 z) {\n    return arccosh(rec(z));\n}\n\nvec2 acsch(vec2 z) {\n    return arcsinh(rec(z));\n}\n\nvec2 linear(vec2 z, vec2 a, vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(vec2 z, vec2 a, vec2 b, vec2 c) {\n    return mul(squ(z), a) + mul(z, b) + c;\n}\n\nvec2 cubic(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return mul(cube(z), a) + mul(squ(z), b) + mul(z, c) + d;\n}\n\nvec2 linearroot(vec2 z, vec2 a, vec2 b) {\n    return div(-b, a);\n}\n\nvec4 quadraticroots(vec2 a, vec2 b, vec2 c) {\n    vec2 sqrtdelta = sqrtp(squ(b) - 4.0 * mul(a, c));\n    vec2 twoa = a + a;\n    return vec4(div(sqrtdelta - b, twoa), -div(b + sqrtdelta, twoa));\n}\n\nvec3 HSLtoRGB(vec3 hsl) {\n    float chroma = hsl.y * (1.0 - abs(2.0 * hsl.z - 1.0));\n    float h_prime = hsl.x / 60.0;\n    float x = chroma * (1.0 - abs(mod(h_prime, 2.0) - 1.0));\n    vec3 rgb;\n    if (0.0 <= h_prime && h_prime < 1.0) {\n        rgb = vec3(chroma, x, 0.0);\n    } else if (1.0 <= h_prime && h_prime < 2.0) {\n        rgb = vec3(x, chroma, 0.0);\n    } else if (2.0 <= h_prime && h_prime < 3.0) {\n        rgb = vec3(0.0, chroma, x);\n    } else if (3.0 <= h_prime && h_prime < 4.0) {\n        rgb = vec3(0.0, x, chroma);\n    } else if (4.0 <= h_prime && h_prime < 5.0) {\n        rgb = vec3(x, 0.0, chroma);\n    } else {\n        rgb = vec3(chroma, 0.0, x);\n    }\n    float m = hsl.z - 0.5 * chroma;\n    return rgb + m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 3.0;\n    vec2 center = vec2(0.0);\n    vec2 c = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x * zoom + center;\n    vec2 z = c;\n    float exponent = 1.5 + iTime * 0.2;\n    float r = mag2(z);\n    //float theta;\n    float iter = 0.0;\n    const float max_iter = 256.0;\n    //bool b = true;\n    //float q = z.x - 0.25;\n    //q = q * q + z.y * z.y;\n    //if (q * (q + z.x - 0.25) < 0.25 * z.y * z.y) {\n    //    b = false;\n    //}\n    //if (b) {\n    for (float i = 0.0; i < max_iter; i += 1.0) {\n        if (r > 64.0) {\n            break;\n        }\n\n        z = power(ln(z), exponent) + c;\n\n        r = mag2(z);\n        iter += 1.0;\n    }\n    //}\n\n    if (iter >= max_iter) {// || !b) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        vec3 col = HSLtoRGB(vec3(mod(iter * 4.0, 360.0), 1.0, 0.5));\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 67], [69, 69, 89, 89, 113], [115, 115, 134, 134, 163], [165, 165, 184, 184, 214], [216, 216, 235, 235, 265], [267, 267, 286, 286, 315], [317, 317, 336, 336, 370], [372, 372, 391, 391, 425], [427, 427, 446, 446, 481], [483, 483, 509, 509, 555], [557, 557, 576, 576, 606], [608, 608, 634, 634, 692], [694, 694, 712, 712, 744], [746, 746, 764, 764, 823], [825, 825, 844, 844, 925], [927, 927, 956, 956, 1010], [1012, 1012, 1044, 1044, 1207], [1209, 1209, 1229, 1229, 1323], [1325, 1325, 1346, 1346, 1380], [1382, 1382, 1399, 1399, 1446], [1448, 1448, 1475, 1475, 1507], [1509, 1509, 1528, 1528, 1591], [1593, 1593, 1614, 1614, 1678], [1680, 1680, 1702, 1702, 1818], [1820, 1820, 1842, 1842, 1952], [1954, 1954, 1976, 1976, 2092], [2094, 2094, 2112, 2112, 2222], [2224, 2224, 2242, 2242, 2271], [2273, 2273, 2291, 2291, 2318], [2320, 2320, 2341, 2341, 2404], [2406, 2406, 2427, 2427, 2491], [2493, 2493, 2514, 2514, 2589], [2591, 2591, 2612, 2612, 2687], [2689, 2689, 2710, 2710, 2739], [2741, 2741, 2762, 2762, 2791], [2793, 2793, 2814, 2814, 2877], [2879, 2879, 2900, 2900, 2963], [2965, 2965, 2988, 2988, 3092], [3094, 3094, 3115, 3115, 3226], [3228, 3228, 3251, 3251, 3355], [3357, 3357, 3376, 3376, 3487], [3489, 3489, 3508, 3508, 3537], [3539, 3539, 3558, 3558, 3587], [3589, 3589, 3611, 3611, 3664], [3666, 3666, 3688, 3688, 3768], [3770, 3770, 3792, 3792, 3860], [3862, 3862, 3882, 3882, 3950], [3952, 3952, 3972, 3972, 4002], [4004, 4004, 4024, 4024, 4054], [4056, 4056, 4093, 4093, 4121], [4123, 4123, 4171, 4171, 4216], [4218, 4218, 4270, 4270, 4333], [4335, 4335, 4376, 4376, 4401], [4403, 4403, 4448, 4448, 4597], [4599, 4599, 4624, 4624, 5328], [5330, 5330, 5387, 5387, 6260]], "test": "untested"}
{"id": "7lscWX", "name": "Wang Tiling 2930842", "author": "SnoopethDuckDuck", "description": "I made this a while ago but never uploaded it. Most of it's stolen from Shane's code (can't remember the link), very messily rewritten by me", "tags": ["e"], "likes": 12, "viewed": 275, "published": 3, "date": "1648831962", "time_retrieved": "2024-07-30T16:55:45.354751", "image_code": "float h21 (vec2 uv, float sc) {\n    uv = mod(uv, sc);\n    return fract(sin(dot(uv, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sBox(vec2 p, vec2 b, float r){\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n#define ss(a, b) 1. - smoothstep(0., a, b)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{            \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n\n    const float sc = 8.;\n    \n    uv *= sc;\n    uv -= vec2(1, 0.125) * iTime;\n    \n    vec2 ipos = floor(uv);\n    vec2 fpos = uv - ipos - 0.5;\n\n    // cp = edges we use, eps = all edges   \n    vec2[4] eps = vec2[4](vec2(-.5, .5), vec2(.5, .5), vec2(.5, -.5), vec2(-.5, -.5));\n    vec2[4] cp = eps; \n    \n    float h = h21(ipos, 301.);\n    \n    // Threshold + edge bits\n    float thr = 0.7;\n    vec4 bits;\n    for(int i = 0; i < 4; i++) \n        bits[i] = h21(ipos + eps[i], 301.) > thr ? 1. : 0.;\n      \n    // Number of edges used\n    int iNum = 0;\n    \n    // Count iNum + replace 0-iNum entries of cp with edges used\n    for(int i = 0; i < 4; i++) \n        if(bits[i] == 1.) cp[iNum++] = eps[i];       \n    \n    // Pipes\n    float ln = 1e5;\n    \n    // Width of stuff\n    float lw = 0.15;\n    \n    // Flag tiles with two end points on diagonals as curved\n    int bend = (iNum==2 && length(cp[0] - cp[1]) < sqrt(2.)) ? 1 : 0;\n        \n    // Non-diagonal neighbours (check all 4 sides)\n    for(int i = 0; i < 4; i++){\n        if(bits[i] > 0.5 && bend == 0) {\n            if (h > 0.125)\n                ln = min(ln, sdSegment(fpos, vec2(0), eps[i]) - lw);\n            else\n                ln = min(ln, sdSegment(fpos, 0.5 * eps[i], eps[i]) - lw);\n        }\n    } \n    \n    // Only 2 diagonal neighbours - 2 variations\n    if(bend==1) {\n        if (h > 0.125) {\n            vec2 pnt = 0.5 * (cp[0] + cp[1]);\n            vec2 dif = (fpos - pnt) * Rot(pi/4.);\n            ln = min(ln, abs(sBox(dif, sqrt(2.) * vec2(.25), .125)) - lw);  \n        } else {\n            ln = min(ln, sdSegment(fpos, 0.5 * cp[0], cp[0]) - lw);\n            ln = min(ln, sdSegment(fpos, 0.5 * cp[1], cp[1]) - lw);\n        }         \n    }\n\n    // Overlaps (I think)\n    float ln2 = 1e5;\n    if (bits[2] == 1.) {\n        ln2 = min(ln2, sdSegment(fpos, vec2(1,0), vec2(0,-1)) - lw);\n    }\n    \n    if (bits[0] == 1.) {\n        ln2 = min(ln2, sdSegment(fpos, vec2(-1,0), vec2(0,1)) - lw);\n    }\n\n    vec3 col = vec3(0,0,0.05);\n    \n    float k = sc / iResolution.y;\n    \n    vec3 dcol = vec3(1);\n    vec3 lcol = vec3(0,0,0.1);\n    \n    // The pipes.\n    col = mix(col, dcol, (ss(k, ln - 0.04)));\n    col = mix(col, lcol, ss(k, ln));\n    col = mix(col, dcol, ss(k, ln + .04));\n\n    // Overlapping outlines\n    col = mix(col, lcol, ss(k, ln2));\n    col = mix(col, dcol, ss(k, ln2 + .04));\n   \n    // i dont know\n    vec3 col2 = mix(col, vec3(0.1), ss(k,ln + 0.));\n    col = mix(col, col2, 0.5);\n   \n    // Yellow from the edges\n    float s = exp(-40. * (0.5 - mlength(ouv * vec2(iResolution.y/iResolution.x,1))));\n    vec3 e = vec3(0.5);\n    col *= pal(s + 1.65, e, e, e, 0.4 * vec3(0,1,2)/3.);\n\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Rough gamma correction before presenting to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+0.0001)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.03;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lscWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 124], [126, 126, 162, 162, 249], [251, 251, 301, 301, 420]], "test": "untested"}
{"id": "sllcWX", "name": "blurry drop", "author": "FabriceNeyret2", "description": "answering https://www.facebook.com/groups/shadertoy/posts/1060864384494587/\n\nclick to see the isolines", "tags": ["generalizedline"], "likes": 6, "viewed": 334, "published": 3, "date": "1648830028", "time_retrieved": "2024-07-30T16:55:46.165583", "image_code": "// segment with disc ends: seamless distance to segment. from https://www.shadertoy.com/view/llySRh\nfloat line(vec2 p, vec2 a,vec2 b, out float h) { \n    p -= a, b -= a;\n    h = dot(p, b) / dot(b, b);                          // proj coord on line\n    return length(p - b * clamp(h,0.,1.));              // dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) /R.y;\n         \n    float h, d = line(U, vec2(0,-.4), vec2(0,.6) , h ); // basic line SDF. get d,h\n    h /= 1.;                                            // h = normalized height along line\n    d -= .3*(1.-.5*h);                                  // make dist decrease with height\n    d =   smoothstep( .2, -.2, d )                      // trace the shape\n        * (1.-h);                                       // incorporate the gradient\n    O = vec4( 1. - d );                                 // image\n    \n    if (iMouse.z>0.) O.r = sin(100.*O.r);               // click to see isolines\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 148, 148, 324], [326, 326, 364, 364, 1012]], "test": "untested"}
{"id": "NlscWf", "name": "Filtered Cosine #2", "author": "H4w0", "description": "Comparisons with brute force", "tags": ["procedural", "filtering", "cosine", "harmonic"], "likes": 2, "viewed": 253, "published": 3, "date": "1648822766", "time_retrieved": "2024-07-30T16:55:46.967439", "image_code": "//=======================================================\n//= Pre-Filtered Cosine (with a gaussian filter) \n//=======================================================\n//== Code       : https://www.shadertoy.com/view/NtlcWf\n//== Comparison : https://www.shadertoy.com/view/NlscWf\n//== Details    : https://h4w0.frama.io/pages/posts/2022-04-01-FilteredCosine.html\n//=======================================================\n//== For a box filtered cosine -> see IQ's article :\n//== https://iquilezles.org/articles/bandlimiting\n//== And in action :  https://www.shadertoy.com/view/WtScDt\n//=======================================================\n//== Author  : Arthur Cavalier\n//=======================================================\n\n\n\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 coords = ((2.*(fragCoord.xy)-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    vec3 origin = vec3( 0.5+3.5*cos(6.0*mouse.x), 1.0 + 2.0*mouse.y, -0.5+3.5*sin(6.0*mouse) );\n    vec3 target = vec3( 0.0, -0.8, -0.0 );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Screen Ratio\n    vec2 screen = fragCoord.xy/iResolution.xy;\n    fragColor = vec4(1.);  \n    \n    \n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,3.));\n    if(hit>0.0)\n    {\n        vec3  hit_position = (origin + hit*direction);\n                       \n        vec2  x = hit_position.xz;\n        vec2  F = m_2_pi * F0 * vec2( cos(T0), sin(T0) ); \n        float harmonic = cosine(x,1.0,F);\n        \n       \n        if(screen.x<0.33)\n        {\n            harmonic = prefiltered_cosine(x,1.0,F);\n        }\n        else if(screen.x<0.66)\n        {\n            harmonic = cosine(x,1.0,F);\n        }\n        else \n        {\n            vec4 convergence = texture(iChannel0,screen);\n            vec3 result = convergence.rgb/vec3(convergence.a);  \n            harmonic = result.x;\n        }\n        \n        fragColor = vec4(vec3(harmonic),1.); \n\t}\n    \n    fragColor.rgb *= smoothstep( 0.0, 0.003, abs(screen.x-0.33) );\n    fragColor.rgb *= smoothstep( 0.0, 0.003, abs(screen.x-0.66) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants -----------------------------------------------------------------------\nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n// RayTracing -----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\nfloat plane_intersection(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n// PRNG ----------------------------------------------------------------------------\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//-----------------------------------------------------------------------------------\n// Cosines --------------------------------------------------------------------------\n\nconst float F0 = 2.0;\nconst float T0 = m_pi_2;\n\nfloat cosine(vec2 x, float alpha, vec2 f)\n{\n    return alpha * cos(dot(x,f));\n}\n\nfloat prefiltered_cosine(vec2 x, float alpha, vec2 f)\n{\n    mat2  J = 0.5*mat2(dFdx(x),dFdy(x));\n    mat2  S = J*transpose(J);\n    return alpha * cos(dot(x,f)) * exp(-0.5*dot(f,S*f));\n}", "buffer_a_code": "// Brute force reference\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nfloat g_seed = 0.;\nfloat rand() { return fract(sin(g_seed++)*43758.5453123); } // dummy prng\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 jitter = vec2(rand(),rand());\n    \n    \n    vec2 coords = ((2.*(fragCoord.xy+jitter)-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera controls\n    vec3 origin = vec3( 0.5+3.5*cos(6.0*mouse.x), 1.0 + 2.0*mouse.y, -0.5+3.5*sin(6.0*mouse) );\n    vec3 target = vec3( 0.0, -0.8, -0.0 );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Background Color\n    fragColor = vec4(vec3(1.),1.);\n  \n    // Noise Parameters\n   \n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,3.));\n    if(hit>0.0)\n    {\n        vec3  hit_position = (origin + hit*direction);\n        \n        vec2  x = hit_position.xz;\n        vec2  F = m_2_pi * F0 * vec2( cos(T0), sin(T0) ); \n        float harmonic = cosine(x,1.0,F);\n            \n        fragColor = vec4(vec3(harmonic),1.);    \n    }\n    \n    if(iMouse.z>0.)\n        return;\n    \n    if(iFrame>0)\n           fragColor += texture(iChannel0,fragCoord.xy/iResolution.xy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlscWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[734, 948, 1005, 1005, 2370]], "test": "untested"}
{"id": "ftscWf", "name": "Spring FauxBoxBulbs", "author": "eiffie", "description": "A disastrous distance estimate slathered with fudge.", "tags": ["boxbulbs"], "likes": 20, "viewed": 451, "published": 3, "date": "1648821853", "time_retrieved": "2024-07-30T16:55:47.764309", "image_code": "//Spring FauxBoxBulbs by eiffie\n\n//#define EUCLIDEAN  \n//#define TAXICAB  \n#define CHEBYSHEV  \n  \n#ifdef EUCLIDEAN\n #define Pi 3.14159\n #define Cos cos\n #define Atan atan\n #define Length length\n#endif\n#ifdef TAXICAB\n #define Pi (2.0*sqrt(2.0))\n #define Cos t_cos\n #define Atan t_atan\n #define Length t_length\n#endif\n#ifdef CHEBYSHEV\n #define Pi 4.0\n #define Cos c_cos\n #define Atan c_atan\n #define Length c_length\n#endif\nfloat t_cos(float a){return 2.0*abs(mod(a,2.0*Pi)-Pi)/Pi-1.0;}\nfloat c_cos(float a){return clamp(abs(mod(a,2.0*Pi)-Pi)-Pi/2.0,-1.0,1.0);}\nfloat t_atan(float y, float x){//atan is always complicated by the quadrant (probably a simpler way to write these)  \n float a=x-y,b=x+y,res;\n if(b==0.0)res=(a>0.0?7.0:3.0);\n float d=a/b;\n if(abs(d)<1.0){\n  if(b>0.0)res=1.0-d;\n  else res=5.0-d;\n }else {\n  d=b/a;\n  if(a>0.0)res=7.0+d;\n  else res=3.0+d;\n }\n return res*0.25*Pi;\n}\nfloat c_atan(float y, float x){  \n if(y==0.0)return (x>0.0?0.0:4.0);  \n float a=x/y;  \n if(abs(a)<1.0){  \n  if(y>0.0)return 2.0-a;  \n  else return 6.0-a;  \n }else {  \n  a=y/x;  \n  if(x>0.0)return mod(a,8.0);  \n  else return 4.0+a;  \n }  \n}  \nfloat t_length(vec2 p){return abs(p.x)+abs(p.y);}//==(x^1+y^1)^(1/1) -abs(x & y) is assumed for each  \nfloat t_length(vec3 p){return abs(p.x)+abs(p.y)+abs(p.z);}//==(x^1+y^1)^(1/1) -abs(x & y) is assumed for each  \nfloat c_length(vec2 p){return max(abs(p.x),abs(p.y));}//==(x^inf+y^inf)^(1/inf)  \nfloat c_length(vec3 p){return max(abs(p.x),max(abs(p.y),abs(p.z)));}//==(x^inf+y^inf)^(1/inf)  \n\n\nuniform float u[32];\nfloat Sin(float a){return Cos(a-Pi*.5);}\nvec3 cmap(float a){return fract(vec3(a*13.23,a*1.89,a*3.66));}\nvec3 mcol=vec3(0.0);\nfloat DE(vec3 p){\n  float d=p.z,pr=mod(floor(p.x/3.)*floor(p.y/3.),6.),m=3.+2.*pr,s=m,a,b;\n  p.z+=Cos(pr+iTime+length(p.xy)*.1);p.xy=mod(p.xy,3.0)-1.5;\n  for(int i=0;i<3;i++){\n    a=Atan(p.y,p.x)*s;b=Atan(Length(p.xy),p.z)*s+iTime*1.7+pr;\n    p+=vec3(Cos(b)*vec2(Cos(a),Sin(a)),Sin(b))/s;\n    s*=m;\n  }\n  float r=(Length(p)-(pr==0.?.8:1.))/3.;\n  if(mcol.x>0.){if(d<r)mcol+=cmap(pr);else mcol+=abs(cmap(pr+1.)+.5*Cos((p.y+p.x+p.z)*50.))*.75+.25;}\n  return min(d,r);\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=max(0.1,rd.z)+max(0.1,dot(rd,L));\n  return vec3(d);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,d,px=1.0/iResolution.x;\n  for(int i=0;i<64;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>100.0 || d<px*t)break;\n  }\n  vec3 L=normalize(vec3(0.4,0.25,0.5));\n  vec3 col=sky(rd,L);\n  if(d<px*t*5.0){\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);if(N!=N)N=-rd;if(dot(rd,N)>0.)N=-N;\n    vec3 scol=mcol*0.25;\n    float dif=0.5+0.5*dot(N,L);\n    float vis=clamp(dot(N,-rd),0.05,1.0);\n    float fr=pow(1.-vis,5.0);\n    float shad=ShadAO(so,L);\n    col=mix((scol*dif+shad*fr*sky(reflect(rd,N),L))*shad,col,t*t/10000.);\n  }\n  return col;\n}\nmat3 lookat(vec3 fw){fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0,0,1)));\n  return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*iResolution.xy)/iResolution.x;\n  randomize(U);\n  float t=iTime*.05+5.;\n  vec3 ro=vec3(t_cos(t)*100.+30.,t_cos(t*.3-2.)*150.+74.,10.+7.*t_cos(t));\n  vec3 rd=lookat(vec3(30.,70.,-200.+10.*ro.z)-ro)*normalize(vec3(uv.xy,1.0));\n  O=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 5.0 \nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);} \nvec2 nofs(float n){//the song's \"random\" ring \n  float r=0.5+0.5*rnd(floor(n));//random volume as well \n  n=mod(n,8.0); \n  if(n<1.0)n=0.0; \n  else if(n<2.0)n=2.0; \n  else if(n<3.0)n=5.0; \n  else if(n<4.0)n=-1.0; \n  else if(n<5.0)n=5.0; \n  else if(n<6.0)n=4.0; \n  else if(n<7.0)n=3.0; \n  else n=0.0;\n  return vec2(n,r); \n}\n\nfloat scale(float note){//throws out dissonant tones \n float n2=mod(note,12.);\n //if((n2==1.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//dorky\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor \n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues  \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country \n if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone \n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole \n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian   \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian   \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major \n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian \n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant \n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic \n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor \n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor \n return note; \n} \n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2 \nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;} \nconst float PI=3.14159; \nfloat Cos(float a){return cos(mod(a,PI*2.));} \nfloat Sin(float a){return Cos(a+PI/2.);} \nstruct instr{float att,fo,vibe,vphas,phas,dtun;}; \nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument \n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.; \n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125); \n n+=t;return vec2(f*Sin(n),f*Cos(n));\n} \nvec2 mainSound(int samp, float time){//att,fo,vibe,vphs,phs,dtun\n instr epiano=instr(50.0,0.5,2.5,0.1,1.505,0.001);//silly fm synth instruments \n //instr sitar=instr(30.0,1.,4.0,0.0,0.2525,0.0025); \n //instr bassdrum=instr(500.0,1.0,4.0,0.76,1.0,0.5); \n //instr stick=instr(100.0,30.0,10.5,0.0,2.3131,1000.0); \n //instr pluckbass=instr(500.0,2.0,1.5,0.0,0.125,0.005); \n //instr bass=instr(20.0,0.2,2.0,0.0,0.5,0.005); \n float tim=time*bps,b0,b1,b2,t0,t1,t2; \n vec2 a=vec2(0.0);//accumulator \n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails \n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25); \n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.25)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm \n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0); \n   t0=fract(tim)+i; \n   a+=I(n0.x+84.0,time,t0,epiano)*n0.y*.5;\n   //if(mod(i,1.)<1.)a+=I(n0.x+93.0,time+Sin(t0*272.0),t0,stick)*n0.y;  \n   if(mod(i,2.)<1.){//notes that play every 2 beats \n     t1=fract(tim*0.5)*2.0+i;\n     //a+=I(n1.x+67.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+75.0,time,t1,epiano)*n1.y; \n     a+=I(n1.x+72.0,time,t1,epiano)*n1.y; \n     //a+=I(n1.x+36.0,time,t1,pluckbass)*n1.y*4.0;\n     if(mod(i,4.)<1.){//every 4 \n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+60.0,time,t2,epiano)*n2.y;\n       //a+=I(n2.x+53.0,time,t2,bass)*n2.y*.5; \n       //a+=I(n2.x+32.0,t2/bps+0.008*sin(t2*5.0),t2,bassdrum)*12.0;\n       //a+=I(n2.x+31.0,t2/bps+0.008*sin(t2*6.0),t2,bassdrum)*12.0;\n     } \n   } \n   tim-=1.;//go back in time to find old notes still decaying \n } \n return clamp(a/64.0,-1.,1.); \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftscWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 421, 442, 442, 483], [484, 484, 505, 505, 558], [559, 559, 590, 676, 887], [888, 888, 919, 919, 1127], [1130, 1130, 1153, 1153, 1179], [1179, 1233, 1256, 1256, 1291], [1291, 1345, 1368, 1368, 1399], [1399, 1427, 1450, 1450, 1495], [1546, 1546, 1565, 1565, 1586], [1587, 1587, 1606, 1606, 1649], [1671, 1671, 1688, 1688, 2137], [2138, 2138, 2167, 2177, 2313], [2314, 2314, 2340, 2340, 2404], [2416, 2416, 2442, 2442, 2516], [2518, 2518, 2555, 2555, 2689], [2690, 2690, 2719, 2719, 3282], [3283, 3283, 3304, 3304, 3399], [3400, 3400, 3438, 3438, 3713]], "test": "untested"}
{"id": "NtlcWf", "name": "Filtered Cosine", "author": "H4w0", "description": "Analytic Filtering of Cosine using a gaussian pixel footprint \nDetails here: [url]https://h4w0.frama.io/pages/[/url]", "tags": ["procedural", "filtering", "cosine", "harmonic"], "likes": 8, "viewed": 511, "published": 3, "date": "1648821113", "time_retrieved": "2024-07-30T16:55:48.505327", "image_code": "//=======================================================\n//= Pre-Filtered Cosine (gaussian filter)\n//=======================================================\n//== Code       : https://www.shadertoy.com/view/NtlcWf\n//== Comparison : https://www.shadertoy.com/view/NlscWf\n//== Details    : https://h4w0.frama.io/pages/posts/2022-04-01-FilteredCosine.html\n//=======================================================\n//== For a box filtered cosine -> see IQ's article :\n//== https://iquilezles.org/articles/bandlimiting\n//== And in action :  https://www.shadertoy.com/view/WtScDt\n//=======================================================\n//== Author  : Arthur Cavalier\n//=======================================================\n\n#define REMAP_0_1\n\nfloat cosine(vec2 x, float alpha, vec2 f)\n{\n    return alpha * cos(dot(x,f));\n}\n\nfloat prefiltered_cosine(vec2 x, float alpha, vec2 f)\n{\n    mat2  J = 0.5*mat2(dFdx(x),dFdy(x));\n    mat2  S = J*transpose(J);\n    return alpha * cos(dot(x,f)) * exp(-0.5*dot(f,S*f));\n}\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = ((2.*fragCoord.xy-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera controls\n    vec3 origin = vec3( 0.5+3.5*cos(0.1*iTime + 6.0*mouse.x), 1.0 + 2.0*mouse.y, -0.5+3.5*sin(0.1*iTime + 6.0*mouse) );\n    vec3 target = vec3( 0., -0.4, -0. );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Background Color\n    fragColor = vec4(vec3(1.),1.);\n  \n    // Harmonic Parameters\n    float F0 = 2.0 + sin(0.5*iTime);\n    float T0 = 0.0;\n    vec2  F = m_2_pi * F0 * vec2( cos(T0), sin(T0) ); \n\n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,20.));\n    if(hit>0.0)\n    {\n        vec3 hit_position = (origin + hit*direction);\n        vec2 x = hit_position.xz/5.;\n        float harmonic = 0.; \n        if(coords.x<0.)\n        {\n            harmonic = cosine(x,1.0,F);\n        }\n        else\n        {\n            harmonic = prefiltered_cosine(x,1.0,F);\n        }\n        \n        fragColor.rgb = vec3(harmonic);\n        \n        #ifdef REMAP_0_1\n        fragColor.rgb = vec3(0.5+0.5*harmonic);\n        #endif\n    }\n    fragColor.rgb *= smoothstep( 0.0, 0.01, abs(coords.x) );\n}", "image_inputs": [], "common_code": "const uint  LRPN_GLOBAL_SEED = 0u;\n\n// Constants -----------------------------------------------------------------------\nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n// RayTracing -----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\nfloat plane_intersection(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n// Matrix Maths ------------------------------------------------------------------------------------------\nfloat det2x2(in mat2 m)         {return (m[0][0]*m[1][1] - m[0][1]*m[1][0]);}\nmat2  inv2x2(in mat2 m)         {return (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);}\nmat2  tra2x2(in mat2 m)         {return mat2(m[0][0],m[1][0],m[0][1],m[1][1]);}\n\n// PRNG ----------------------------------------------------------------------------\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 741, 784, 784, 820], [822, 822, 877, 877, 1007], [1010, 1224, 1281, 1281, 2547]], "test": "untested"}
{"id": "fllcWX", "name": "NDF: Beckmann Isotropic", "author": "H4w0", "description": "Engine Ready isotropic Beckmann NDF", "tags": ["microfacet", "beckmann", "isotropy"], "likes": 1, "viewed": 291, "published": 3, "date": "1648807116", "time_retrieved": "2024-07-30T16:55:49.424869", "image_code": "//=======================================================\n//= Normal Distribution Function : GGX Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Shader references:\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//== *- UI courtesy of Good's https://www.shadertoy.com/view/XlG3WD\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_COL  = vec3(0.0);\n\n\n//-----------------------------------------------------------------------------\n//-- UI Functions -------------------------------------------------------------\n/* Access */\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\n/* Sliders */\nfloat slider_roughness() { return(readFloat(1.)); }\nfloat slider_metalness()  { return(readFloat(2.) > 0.5 ? 1. : 0.); }\nfloat slicer_reflectance(){ return(clamp(readFloat(3.),0.35,1.0)); }\n\n//-----------------------------------------------------------------------------\n//-- Beckmann -----------------------------------------------------------------\n\nfloat beckmann_isotropic_ndf(float alpha, float NoH)\n{\n\tfloat cosThetaSqr = NoH*NoH;\n\tfloat alphaSqr = alpha*alpha;\n\tfloat exponent = (1.0-cosThetaSqr)/(alphaSqr*cosThetaSqr);\n\tfloat denom = m_pi * alphaSqr * cosThetaSqr * cosThetaSqr;\n\treturn( exp(-exponent) / denom );\n}\n\nfloat beckmann_isotropic_lambda(float alpha, float NoV)\n{\n    float lambda = 0.f;\n    float cosThetaSqr = NoV*NoV;\n    float sinThetaSqr = 1.f-cosThetaSqr;\n    float tanThetaSqr = sinThetaSqr / cosThetaSqr;\n\n\tfloat nu = \t1.f / sqrt( alpha * sqrt(tanThetaSqr) );\n\tif(nu < 1.6f){\n        lambda = (1.f - 1.259f*nu + 0.396f*nu*nu) / (3.535f*nu + 2.181f*nu*nu); \n\t}\n\treturn(lambda);\n}\n\nfloat beckmann_isotropic_visibility(float alpha, float NoV, float NoL)\n{\n    float lambda_wo = beckmann_isotropic_lambda(alpha,NoV); \n\tfloat lambda_wi = beckmann_isotropic_lambda(alpha,NoL); \n\tfloat denom = (1.f + lambda_wo + lambda_wi)*NoL*NoV*4.f;\n\treturn( 1.f / denom );\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float cosTheta, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - cosTheta, 5.);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_COL; }\n\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n\n    \n    \n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        /* Retrieve Scene data */\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        /* Material Data */\n        \n        /* 1. Perceptual Roughness Mapping \\f$ \\alpha^2 \\f$  */\n        float alpha = slider_roughness() * m_sqrt_2;\n        alpha *= alpha;\n        /* 3. Gold F0 */ \n        vec3 albedo = vec3(1.00, 0.85, 0.57); /* sRGB */\n        vec3 linear_albedo =  pow(albedo,vec3(2.2));\n        /* 4. Metalness */ \n        float metalness = slider_metalness();\n        /* 5. Reflectance */ \n        float reflectance = slicer_reflectance();\n               \n        /* Computing HalfVector */\n        vec3 H = normalize(L+V);\n        \n        /* Computing Dots */\n        /* 1. Distribution dot Terms */\n        float NoH = dot(N,H);\n        /* 2. Visibility dot Terms */\n        float NoV = dot(N,V);\n        float NoL = dot(N,L);\n        \n        /* Computing Normal Distribution Term \\f$ D(\\omega_h) \\f$ */\n        float D   = beckmann_isotropic_ndf( alpha, NoH );\n        \n        /* Computing Visibility Term */\n        /* \\f$ \\frac{G(\\omega_o,\\omega_i,\\alpha_t,\\alpha_b)}{4(\\omega_g\\cdot\\omega_i)(\\omega_g\\cdot\\omega_o)} \\f$ */\n        float Vis = beckmann_isotropic_visibility(alpha, NoV, NoL); \n        \n        /* Computing Fresnel Term */\n        /* Using reflectance mapping as in Filament PBR Pipeline */\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metalness) + linear_albedo*metalness;\n        vec3 F = fresnel_schlick(max(dot(V,H), 0.0), F0);\n        \n        /* Lighting */\n        vec3 specular_microfacet = D * Vis * F;\n        vec3 diffuse_lambert = m_i_pi*(1.-metalness)*linear_albedo;\n        vec3 diffuse_factor  = vec3(1.)-F; \n            \n        /* Final color */\n        color = max(NoL,0.) * get_light_intensity() * ( diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd) , 1.);\n\n\n    // UI\n    vec4 ui = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = mix(fragColor, ui, ui.a);\n    \n    // Tonemapping\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359f; /* MathConstant: PI        */\nconst float m_2_pi      = 6.28318530718f; /* MathConstant: 2 PI      */\nconst float m_i_pi      = 0.31830988618f; /* MathConstant: 1 / PI    */\nconst float m_sqrt_2    = 1.41421356237f; /* MathConstant: sqrt(2)   */\nconst float m_i_sqrt_2  = 0.70710678119f; /* MathConstant: 1/sqrt(2) */\nconst float m_eps_3f    = 0.001f;            \nconst float m_eps_4f    = 0.0001f;    \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        u = vec3(0 , -1, 0);\n        v = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        u = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        v = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(u,v,n) );\n}", "buffer_a_code": "// From  2D Canvas with UI by Good\n// Link : https://www.shadertoy.com/view/XlG3WD\n// \n\n#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(30,220,140,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n        \n    //define sliders    \n    EASYSLIDER(1,.2)  _R O U G H N E S S  \n    EASYSLIDER(2,1.)  _M E T A L N E S S      \n    EASYSLIDER(3,1.)  _R E F L E C T A N C E \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1814, 1987, 2019, 2019, 2108], [2109, 2123, 2149, 2149, 2174], [2175, 2175, 2202, 2202, 2243], [2244, 2244, 2271, 2271, 2312], [2475, 2475, 2529, 2529, 2747], [2749, 2749, 2806, 2806, 3129], [3131, 3131, 3203, 3203, 3406], [3409, 3569, 3622, 3622, 3676], [3679, 3839, 3880, 3880, 3906], [3907, 3907, 3947, 3947, 3973], [3974, 3974, 4014, 4014, 4039], [4042, 4204, 4241, 4241, 6363], [6368, 6368, 6425, 6425, 6998]], "test": "untested"}
{"id": "flsyWX", "name": "NDF: GGX Isotropic", "author": "H4w0", "description": "Engine Ready isotropic GGX NDF", "tags": ["microfacet", "ggx", "isotropy"], "likes": 2, "viewed": 554, "published": 3, "date": "1648806513", "time_retrieved": "2024-07-30T16:55:50.370340", "image_code": "//=======================================================\n//= Normal Distribution Function : GGX Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Shader references:\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//== *- UI courtesy of Good's https://www.shadertoy.com/view/XlG3WD\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_COL  = vec3(0.0);\n\n\n//-----------------------------------------------------------------------------\n//-- UI Functions -------------------------------------------------------------\n/* Access */\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\n/* Sliders */\nfloat slider_roughness() { return(readFloat(1.)); }\nfloat slider_metalness()  { return(readFloat(2.) > 0.5 ? 1. : 0.); }\nfloat slicer_reflectance(){ return(clamp(readFloat(3.),0.35,1.0)); }\n\n//-----------------------------------------------------------------------------\n//-- GGX ----------------------------------------------------------------------\n\nfloat ggx_isotropic_ndf(float NoH, float alpha) \n{\n    float a = NoH * alpha;\n    float k = alpha / (1.0 - NoH * NoH + a * a);\n    return k * k * m_i_pi;\n}\n\nfloat ggx_isotropic_visibility(float NoV, float NoL, float alpha) \n{\n    float a2 = alpha * alpha;\n    float GV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GV + GL);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float cosTheta, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - cosTheta, 5.);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_COL; }\n\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n\n    \n    \n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        /* Retrieve Scene data */\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        /* Material Data */\n        \n        /* 1. Perceptual Roughness Mapping \\f$ \\alpha^2 \\f$  */\n        float alpha = slider_roughness() * slider_roughness();\n        /* 3. Gold F0 */ \n        vec3 albedo = vec3(1.00, 0.85, 0.57); /* sRGB */\n        vec3 linear_albedo =  pow(albedo,vec3(2.2));\n        /* 4. Metalness */ \n        float metalness = slider_metalness();\n        /* 5. Reflectance */ \n        float reflectance = slicer_reflectance();\n        \n               \n        /* Computing HalfVector */\n        vec3 H = normalize(L+V);\n        \n        /* Computing Dots */\n        /* 1. Distribution dot Terms */\n        float NoH = dot(N,H);\n        /* 2. Visibility dot Terms */\n        float NoV = dot(N,V);\n        float NoL = dot(N,L);\n        \n        /* Computing Normal Distribution Term \\f$ D(\\omega_h) \\f$ */\n        float D   = ggx_isotropic_ndf( NoH, alpha );\n        \n        /* Computing Visibility Term */\n        /* \\f$ \\frac{G(\\omega_o,\\omega_i,\\alpha_t,\\alpha_b)}{4(\\omega_g\\cdot\\omega_i)(\\omega_g\\cdot\\omega_o)} \\f$ */\n        float Vis = ggx_isotropic_visibility(NoV, NoL, alpha); \n        \n        /* Computing Fresnel Term */\n        /* Using reflectance mapping as in Filament PBR Pipeline */\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metalness) + linear_albedo*metalness;\n        vec3 F = fresnel_schlick(max(dot(V,H), 0.0), F0);\n        \n        /* Lighting */\n        vec3 specular_microfacet = D * Vis * F;\n        vec3 diffuse_lambert = m_i_pi*(1.-metalness)*linear_albedo;\n        vec3 diffuse_factor  = vec3(1.)-F; \n            \n        /* Final color */\n        color = max(NoL,0.) * get_light_intensity() * ( diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd) , 1.);\n\n\n    // UI\n    vec4 ui = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = mix(fragColor, ui, ui.a);\n    \n    // Tonemapping\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359f; /* MathConstant: PI        */\nconst float m_2_pi      = 6.28318530718f; /* MathConstant: 2 PI      */\nconst float m_i_pi      = 0.31830988618f; /* MathConstant: 1 / PI    */\nconst float m_sqrt_2    = 1.41421356237f; /* MathConstant: sqrt(2)   */\nconst float m_i_sqrt_2  = 0.70710678119f; /* MathConstant: 1/sqrt(2) */\nconst float m_eps_3f    = 0.001f;            \nconst float m_eps_4f    = 0.0001f;    \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        u = vec3(0 , -1, 0);\n        v = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        u = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        v = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(u,v,n) );\n}", "buffer_a_code": "// From  2D Canvas with UI by Good\n// Link : https://www.shadertoy.com/view/XlG3WD\n// \n\n#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(30,220,140,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n        \n    //define sliders    \n    EASYSLIDER(1,.2)  _R O U G H N E S S   \n    EASYSLIDER(2,1.)  _M E T A L N E S S      \n    EASYSLIDER(3,1.)  _R E F L E C T A N C E \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1814, 1987, 2019, 2019, 2108], [2109, 2123, 2149, 2149, 2174], [2175, 2175, 2202, 2202, 2243], [2244, 2244, 2271, 2271, 2312], [2475, 2475, 2525, 2525, 2630], [2632, 2632, 2700, 2700, 2872], [2875, 3035, 3088, 3088, 3142], [3145, 3305, 3346, 3346, 3372], [3373, 3373, 3413, 3413, 3439], [3440, 3440, 3480, 3480, 3505], [3508, 3670, 3707, 3707, 5814], [5819, 5819, 5876, 5876, 6449]], "test": "untested"}
{"id": "ftsyWX", "name": "NDF: Beckmann Anisotropic", "author": "H4w0", "description": "Engine Ready Anisotropic Beckmann NDF ", "tags": ["microfacet", "anisotropy", "beckmann"], "likes": 1, "viewed": 301, "published": 3, "date": "1648805363", "time_retrieved": "2024-07-30T16:55:51.293872", "image_code": "//=======================================================\n//= Normal Distribution Function : Beckmann Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Shader references:\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//== *- UI courtesy of Good's https://www.shadertoy.com/view/XlG3WD\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_COL  = vec3(0.0);\n\n\n//-----------------------------------------------------------------------------\n//-- UI Functions -------------------------------------------------------------\n/* Access */\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\n/* Sliders */\nfloat slider_anisotropy() { return(readFloat(1.)); }\nfloat slider_roughness()  { return(readFloat(2.)); }\nfloat slider_metalness()  { return(readFloat(3.) > 0.5 ? 1. : 0.); }\nfloat slicer_reflectance(){ return(clamp(readFloat(4.),0.35,1.0)); }\n\n\n\n//-----------------------------------------------------------------------------\n//-- Beckmann -----------------------------------------------------------------\n\nfloat beckmann_anisotropic_ndf(\tfloat alpha_t, float alpha_b, \n\t\t\t\t\t\t\t\tfloat ToH, float BoH, float NoH)\n{\n\tfloat cosThetaSqr = NoH*NoH;\n\tfloat exponent = (1.f/cosThetaSqr) * ( (ToH*ToH)/(alpha_t*alpha_t) + (BoH*BoH)/(alpha_b*alpha_b)  );\n\tfloat denom = m_pi * alpha_t * alpha_b * cosThetaSqr * cosThetaSqr;\n\treturn( exp(-exponent) / denom );\n}\n\n\nfloat beckmann_anisotropic_lambda(float alpha_t, float alpha_b, \n\t\t\t float ToV, float BoV, float NoV)\n{\n\tfloat lambda = 0.f;\n\tfloat nu = \tNoV / sqrt( alpha_t*alpha_t*ToV*ToV + alpha_b*alpha_b*BoV*BoV );\n\tif(nu < 1.6f){\n        lambda = (1.f - 1.259f*nu + 0.396f*nu*nu) / (3.535f*nu + 2.181f*nu*nu); \n\t}\n\treturn(lambda);\n}\n\nfloat beckmann_anisotropic_visibility(\tfloat alpha_t, float alpha_b, \n\t\t\t\t\t\t\t\t\t\tfloat ToV, float BoV, float NoV,\n\t\t\t\t\t\t\t\t\t\tfloat ToL, float BoL, float NoL)\n{\n\tfloat lambda_wo = beckmann_anisotropic_lambda(alpha_t,alpha_b,ToV,BoV,NoV); \n\tfloat lambda_wi = beckmann_anisotropic_lambda(alpha_t,alpha_b,ToL,BoL,NoL); \n\tfloat denom = (1.f + lambda_wo + lambda_wi)*NoL*NoV*4.f;\n\treturn( 1.f / denom );\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float cosTheta, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - cosTheta, 5.);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_COL; }\n\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n\n    \n    \n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        /* Retrieve Scene data */\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        /* Material Data */\n        /* 1. Remapped between [-1;1] : negative -> bitangent, positive -> tangent */\n        float anisotropy = slider_anisotropy()*2.-1.;\n        /* 2. Perceptual Roughness Mapping \\f$ \\alpha^2 \\f$  */\n        float alpha = slider_roughness() * m_sqrt_2;\n        float alpha_x = max(alpha * alpha * (1.0 + anisotropy), 0.001);\n        float alpha_y = max(alpha * alpha * (1.0 - anisotropy), 0.001);\n        /* 3. Gold F0 */ \n        vec3 albedo = vec3(1.00, 0.85, 0.57); /* sRGB */\n        vec3 linear_albedo =  pow(albedo,vec3(2.2));\n        /* 4. Metalness */ \n        float metalness = slider_metalness();\n        /* 5. Reflectance */ \n        float reflectance = slicer_reflectance();\n        \n        /* Computing Tangent/Bitangent */\n        vec3 T,B;\n        orthonormal_basis(N, T, B);\n        \n        /* Computing HalfVector */\n        vec3 H = normalize(L+V);\n        \n        /* Computing Dots */\n        /* 1. Distribution dot Terms */\n        float ToH = dot(T,H);\n        float BoH = dot(B,H);\n        float NoH = dot(N,H);\n        /* 2. Visibility dot Terms */\n        float ToV = dot(T,V);\n        float BoV = dot(B,V);\n        float NoV = dot(N,V);\n        float ToL = dot(T,L);\n        float BoL = dot(B,L);\n        float NoL = dot(N,L);\n        \n        /* Computing Normal Distribution Term \\f$ D(\\omega_h) \\f$ */\n        float D   = beckmann_anisotropic_ndf( alpha_x, alpha_y, ToH, BoH, NoH );\n        \n        /* Computing Visibility Term */\n        /* \\f$ \\frac{G(\\omega_o,\\omega_i,\\alpha_t,\\alpha_b)}{4(\\omega_g\\cdot\\omega_i)(\\omega_g\\cdot\\omega_o)} \\f$ */\n        float Vis = beckmann_anisotropic_visibility(\n            alpha_x, alpha_y,\n            ToV, BoV, NoV,\n            ToL, BoL, NoL\n        ); \n        \n        /* Computing Fresnel Term */\n        /* Using reflectance mapping as in Filament PBR Pipeline */\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metalness) + linear_albedo*metalness;\n        vec3 F = fresnel_schlick(max(dot(V,H), 0.0), F0);\n        \n        /* Lighting */\n        vec3 specular_microfacet = D * Vis * F;\n        vec3 diffuse_lambert = m_i_pi*(1.-metalness)*linear_albedo;\n        vec3 diffuse_factor  = vec3(1.)-F; \n            \n        /* Final color */\n        color = max(NoL,0.) * get_light_intensity() * ( diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd) , 1.);\n\n\n    // UI\n    vec4 ui = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = mix(fragColor, ui, ui.a);\n    \n    // Tonemapping\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359f; /* MathConstant: PI        */\nconst float m_2_pi      = 6.28318530718f; /* MathConstant: 2 PI      */\nconst float m_i_pi      = 0.31830988618f; /* MathConstant: 1 / PI    */\nconst float m_sqrt_2    = 1.41421356237f; /* MathConstant: sqrt(2)   */\nconst float m_i_sqrt_2  = 0.70710678119f; /* MathConstant: 1/sqrt(2) */\nconst float m_eps_3f    = 0.001f;            \nconst float m_eps_4f    = 0.0001f;    \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        u = vec3(0 , -1, 0);\n        v = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        u = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        v = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(u,v,n) );\n}", "buffer_a_code": "// From  2D Canvas with UI by Good\n// Link : https://www.shadertoy.com/view/XlG3WD\n// \n\n#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(30,220,140,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n        \n    //define sliders    \n    EASYSLIDER(1,.5)  _A N I S O T R O P Y  \n    EASYSLIDER(2,.2)  _R O U G H N E S S \n    EASYSLIDER(3,1.)  _M E T A L N E S S      \n    EASYSLIDER(4,1.)  _R E F L E C T A N C E    \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1819, 1992, 2024, 2024, 2113], [2114, 2128, 2155, 2155, 2180], [2181, 2181, 2208, 2208, 2233], [2234, 2234, 2261, 2261, 2302], [2303, 2303, 2330, 2330, 2371], [2536, 2536, 2641, 2641, 2879], [2882, 2882, 2985, 2985, 3203], [3205, 3205, 3362, 3362, 3602], [3605, 3765, 3818, 3818, 3872], [3875, 4035, 4076, 4076, 4102], [4103, 4103, 4143, 4143, 4169], [4170, 4170, 4210, 4210, 4235], [4238, 4400, 4437, 4437, 7190], [7195, 7195, 7252, 7252, 7825]], "test": "untested"}
{"id": "NtlyWX", "name": "NDF: GGX Anisotropic", "author": "H4w0", "description": "Engine Ready Anisotropic GGX NDF", "tags": ["microfacet", "anisotropy", "ggx"], "likes": 1, "viewed": 825, "published": 3, "date": "1648804659", "time_retrieved": "2024-07-30T16:55:52.218399", "image_code": "//=======================================================\n//= Normal Distribution Function : GGX Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Shader references:\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//== *- UI courtesy of Good's https://www.shadertoy.com/view/XlG3WD\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_COL  = vec3(0.0);\n\n\n//-----------------------------------------------------------------------------\n//-- UI Functions -------------------------------------------------------------\n/* Access */\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\n/* Sliders */\nfloat slider_anisotropy() { return(readFloat(1.)); }\nfloat slider_roughness()  { return(readFloat(2.)); }\nfloat slider_metalness()  { return(readFloat(3.) > 0.5 ? 1. : 0.); }\nfloat slicer_reflectance(){ return(clamp(readFloat(4.),0.35,1.0)); }\n\n\n//-----------------------------------------------------------------------------\n//-- GGX ----------------------------------------------------------------------\n\n/** \n * @brief GGX Anisotropic Distribution\n * @param alpha_t   Roughness in   tangent direction\n * @param alpha_b   Roughness in bitangent direction\n * @param ToH       Dot product between   tangent vector and halfvector\n * @param BoH       Dot product between bitangent vector and halfvector\n * @param NoH       Dot product between    normal vector and halfvector\n * \n * \\f$ D(h;\\alpha_t,\\alpha_b) = \\frac{1}{\\pi\\alpha_t\\alpha_b}\\frac{1}{ \\big( (n\\cdot h)^2 + \\frac{(t \\cdot h)^2}{\\alpha_t^2} + \\frac{(b\\cdot h)^2}{\\alpha_b^2} \\big)^2 } \\f$\n */\nfloat ggx_anisotropic_ndf(float alpha_t, float alpha_b,\n                          float ToH, float BoH, float NoH) \n{\n\tvec3 v = vec3(alpha_b*ToH,alpha_t*BoH, alpha_t*alpha_b*NoH);\n\tfloat v2 = dot(v,v);\n\tfloat a2 = alpha_t*alpha_b;\n\tfloat w2 = a2/v2;\n\treturn( a2*w2*w2*m_i_pi );\n}\n\n\n/** \n * @brief GGX Anisotropic Visibility Term\n * @param alpha_t   Roughness in   tangent direction\n * @param alpha_b   Roughness in bitangent direction\n * @param ToV       Dot product between   tangent vector and view vector\n * @param BoV       Dot product between bitangent vector and view vector\n * @param NoV       Dot product between    normal vector and view vector\n * @param ToL       Dot product between   tangent vector and light vector\n * @param BoL       Dot product between bitangent vector and light vector\n * @param NoL       Dot product between    normal vector and light vector\n * \n * Visibility term correspond to the following relation :\n * \\f$ V(\\omega_o,\\omega_i,\\alpha_t,\\alpha_b) = \\frac{G(\\omega_o,\\omega_i,\\alpha_t,\\alpha_b)}{4(\\omega_g\\cdot\\omega_i)(\\omega_g\\cdot\\omega_o)} \\f$\n * Yielding :\n * \\f$ V(\\omega_i,\\omega_o,\\alpha_t,\\alpha_b)=\\frac{1}{2}\\frac{1}{((\\omega_g\\cdot\\omega_i)\\hat{\\Lambda}(\\omega_o)+(\\omega_g\\cdot\\omega_o)\\hat{\\Lambda}(\\omega_i))} \\f$\n * Using \\f$\\hat{\\Lambda}(\\omega) &= \\sqrt{\\alpha^2_t(\\omega_t\\cdot\\omega)^2+\\alpha^2_b(\\omega_b\\cdot\\omega)^2+(\\omega_g\\cdot\\omega)^2} \\f$\n * \n */\nfloat ggx_anisotropic_visibility(float alpha_t, float alpha_b,\n\t\t\t\t\t\t\t\t float ToV, float BoV, float NoV,\n    \t\t\t\t\t\t\t float ToL, float BoL, float NoL) \n{  \n    float lambdaV = NoL * length(vec3(alpha_t * ToV, alpha_b * BoV, NoV));\n    float lambdaL = NoV * length(vec3(alpha_t * ToL, alpha_b * BoL, NoL));\n    float v = 0.5f / (lambdaV + lambdaL);\n    return clamp(v,0.0f,1.0f);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float cosTheta, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - cosTheta, 5.);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_COL; }\n\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n\n    \n    \n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        /* Retrieve Scene data */\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        /* Material Data */\n        /* 1. Remapped between [-1;1] : negative -> bitangent, positive -> tangent */\n        float anisotropy = slider_anisotropy()*2.-1.;\n        /* 2. Perceptual Roughness Mapping \\f$ \\alpha^2 \\f$  */\n        float alpha = slider_roughness();\n        float alpha_x = max(alpha * alpha * (1.0 + anisotropy), 0.001);\n        float alpha_y = max(alpha * alpha * (1.0 - anisotropy), 0.001);\n        /* 3. Gold F0 */ \n        vec3 albedo = vec3(1.00, 0.85, 0.57); /* sRGB */\n        vec3 linear_albedo =  pow(albedo,vec3(2.2));\n        /* 4. Metalness */ \n        float metalness = slider_metalness();\n        /* 5. Reflectance */ \n        float reflectance = slicer_reflectance();\n        \n        /* Computing Tangent/Bitangent */\n        vec3 T,B;\n        orthonormal_basis(N, T, B);\n        \n        /* Computing HalfVector */\n        vec3 H = normalize(L+V);\n        \n        /* Computing Dots */\n        /* 1. Distribution dot Terms */\n        float ToH = dot(T,H);\n        float BoH = dot(B,H);\n        float NoH = dot(N,H);\n        /* 2. Visibility dot Terms */\n        float ToV = dot(T,V);\n        float BoV = dot(B,V);\n        float NoV = dot(N,V);\n        float ToL = dot(T,L);\n        float BoL = dot(B,L);\n        float NoL = dot(N,L);\n        \n        /* Computing Normal Distribution Term \\f$ D(\\omega_h) \\f$ */\n        float D   = ggx_anisotropic_ndf( alpha_x, alpha_y, ToH, BoH, NoH );\n        \n        /* Computing Visibility Term */\n        /* \\f$ \\frac{G(\\omega_o,\\omega_i,\\alpha_t,\\alpha_b)}{4(\\omega_g\\cdot\\omega_i)(\\omega_g\\cdot\\omega_o)} \\f$ */\n        float Vis = ggx_anisotropic_visibility(\n            alpha_x, alpha_y,\n            ToV, BoV, NoV,\n            ToL, BoL, NoL\n        ); \n        \n        /* Computing Fresnel Term */\n        /* Using reflectance mapping as in Filament PBR Pipeline */\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metalness) + linear_albedo*metalness;\n        vec3 F = fresnel_schlick(max(dot(V,H), 0.0), F0);\n        \n        /* Lighting */\n        vec3 specular_microfacet = D * Vis * F;\n        vec3 diffuse_lambert = m_i_pi*(1.-metalness)*linear_albedo;\n        vec3 diffuse_factor  = vec3(1.)-F; \n            \n        /* Final color */\n        color = max(NoL,0.) * get_light_intensity() * ( diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd) , 1.);\n\n\n    // UI\n    vec4 ui = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = mix(fragColor, ui, ui.a);\n    \n    // Tonemapping\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359f; /* MathConstant: PI        */\nconst float m_2_pi      = 6.28318530718f; /* MathConstant: 2 PI      */\nconst float m_i_pi      = 0.31830988618f; /* MathConstant: 1 / PI    */\nconst float m_sqrt_2    = 1.41421356237f; /* MathConstant: sqrt(2)   */\nconst float m_i_sqrt_2  = 0.70710678119f; /* MathConstant: 1/sqrt(2) */\nconst float m_eps_3f    = 0.001f;            \nconst float m_eps_4f    = 0.0001f;    \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        u = vec3(0 , -1, 0);\n        v = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        u = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        v = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(u,v,n) );\n}", "buffer_a_code": "// From  2D Canvas with UI by Good\n// Link : https://www.shadertoy.com/view/XlG3WD\n// \n\n#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(30,220,140,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n        \n    //define sliders    \n    EASYSLIDER(1,.5)  _A N I S O T R O P Y  \n    EASYSLIDER(2,.2)  _R O U G H N E S S      \n    EASYSLIDER(3,1.)  _M E T A L N E S S      \n    EASYSLIDER(4,1.)  _R E F L E C T A N C E    \n    \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1811, 1984, 2016, 2016, 2105], [2106, 2120, 2147, 2147, 2172], [2173, 2173, 2200, 2200, 2225], [2226, 2226, 2253, 2253, 2294], [2295, 2295, 2322, 2322, 2363], [2527, 3074, 3191, 3191, 3353], [3356, 4488, 4640, 4640, 4867], [4870, 5030, 5083, 5083, 5137], [5140, 5300, 5341, 5341, 5367], [5368, 5368, 5408, 5408, 5434], [5435, 5435, 5475, 5475, 5500], [5503, 5665, 5702, 5702, 8434], [8439, 8439, 8496, 8496, 9069]], "test": "untested"}
{"id": "slXyDf", "name": "Quick Drawing Style Filter", "author": "NakedBowman", "description": "Simple Cartoon Style made with blur and blending techniques", "tags": ["cartoon", "line", "filter", "edgedetection", "drawing", "art", "comic", "lineart"], "likes": 1, "viewed": 594, "published": 3, "date": "1648798841", "time_retrieved": "2024-07-30T16:55:52.961413", "image_code": "float bw(vec3 color){\n    return (color.r+color.g+color.b)/ 3.;\n\n}\n\nvec3 post(vec3 color){\n    return floor(color*3.+0.5)/4.;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 og = texture(iChannel0, uv).rgb;\n    \n    vec3 inv = vec3(1.) - texture(iChannel1, uv*1.0).rgb;\n\n    float ogBW = (vec3(bw(og))).r;\n    float inBW = (vec3(bw(inv))).r;\n    \n    vec3 doge =  vec3(min(1., inBW /  (1.0 - ogBW)));\n    vec3 linear = vec3(1. - min(1., (1. - doge.r) / ogBW));\n  \n    //add colour\n    vec3 final = mix(vec3(0.5,0.2,0.3), vec3(0.6,0.8,0.9), bw(linear));\n\n    // Output to screen\n    fragColor = vec4(vec3(final),1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float kernelSize = 7.;\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < kernelSize; i++){\n        float pointer = i - floor(kernelSize * 0.5);\n        col += texture(iChannel0, uv + vec2(i,0.0)/iResolution.xy ).rgb;\n    }\n    col/= kernelSize;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float kernelSize = 7.;\n    vec3 col = vec3(0.);\n    for(float i = 0.; i < kernelSize; i++){\n        float pointer = i - floor(kernelSize * 0.5);\n        col += texture(iChannel0, uv + vec2(0.0,i)/iResolution.xy ).rgb;\n    }\n    col/= kernelSize;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 66], [68, 68, 90, 90, 128], [129, 129, 186, 186, 680]], "test": "untested"}
{"id": "stfcWf", "name": "Day Three - Lambmeow", "author": "lambmeow", "description": "forgot to add the three lmao", "tags": ["raymarching", "sdf", "spiral", "three", "purple", "happyaccidents"], "likes": 0, "viewed": 187, "published": 3, "date": "1648795917", "time_retrieved": "2024-07-30T16:55:53.702431", "image_code": "//Day 3 \n//Daily Shader Challenge\n//not my intended goal for this shader, but it looked so cool i had to add it in.\n//the spiral is actually a mistake with a triangle, but it ended up like this instead with some floor() tomfoolery\n//my goal is to come back to this and maybe add some blur to see if i can get those artifacts out\n//lopea (https://github.com/lopea)\n\nfloat tr(vec2 pt)\n{\n\n    const float k = sqrt(3.0);\n    pt.x = abs(pt.x) - 1.0;\n    pt.y = pt.y + 1.0/k;\n    if( pt.x+k*pt.y>0.0 ) \n        pt=vec2(pt.x-k*pt.y,-k*pt.x-pt.y)/2.0;\n    pt.x -= clamp( pt.x, -2.0, 0.0 );\n    return -length(pt)*sign(pt.y);\n}\n\nfloat three(vec2 p)\n{\n    p.y -= 0.26;\n    p.x += 0.12;\n    float norm = min(length(p) - 0.5, length(p- vec2(0, -0.6)) - 0.5);\n    p-= vec2(-.5, 0);\n    float diff = min(length(p) - 0.5, length(p- vec2(0, -0.6)) - 0.5);\n    return max(-max(-diff, norm), max(-diff, norm));\n}\n\n\nfloat ss(vec3 p)\n{\n \n     //turn this one on and it will look cool as hell\n    float ang = iTime + p.z * 6.;\n    \n   // float ang = iTime + floor(p.z * 2.25 - .352622);\n    \n    p.xy *= mat2(cos(ang),-sin(ang), sin(ang),cos(ang));\n    p.z = mod(p.z +3., 6.) -3.;\n    float t = max(-tr(p.xy), tr(p.xy/1.5) *1.5);\n    \n    vec2 w = vec2(t, abs(p.z) -.25);\n    float res = min(max(w.x, w.y),0.) + length(max(w,.0));\n    \n    return res -0.001;\n}\nvec2 rt(vec3 ro, vec3 rd, inout vec3 pp)\n{\n    float ll = 0., dd = 0., cc = 100.;\n    \n    for(int i = 0; i < 255;i ++)\n    {\n        pp = ro + rd * ll;\n        dd = ss(pp);\n        ll += dd;\n        cc = min(dd, cc);\n        if(dd < 0.01 || ll > 300.)\n        break;\n    }\n     \n    return vec2( dd, cc);\n}\n\nvec3 nn (vec3 p)\n{\n    vec3 n = vec3 (0);\n    \n    for(int i = min(iFrame, 0); i < 4; i++)\n    {\n        vec3 e = 0.5773* (2. * vec3((((i+3)>>1)&1), ((i>>1)&1),(i&1)) -1.);\n        n += e* ss(p +e *0.001);\n    }\n    return normalize(n);\n}\nvec4 gc(vec3 ro, vec3 rd)\n{\n    vec3 p = vec3(ro);\n    vec2 dc = rt(ro,rd, p);\n    vec3 n = nn(p);\n    vec3 col = vec3(0.8, 0.1, 1.);\n    \n    if(dc.x <0.01)\n    {\n        return vec4(max((n.b) * col, 0.),1.);\n    }\n    \n    return vec4((1. + 0.23 * dc.y * dc.y) * col, 1.);\n}\n   \n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = (2. *f  -r)/r.y;\n    \n    vec3 ro = vec3(0,0,-33.33/3. + iTime * 6.), rd = vec3(normalize(vec3(u,3. * 10.)));\n    \n    \n    c = max(gc(ro,rd) * (length(u) -0.5), 0.) + step(three((u + texture(iChannel0, vec2(f/r + iTime * .01)).xy * 0.015 )/0.5) * 0.5,0.01) ;\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 384, 384, 618], [620, 620, 641, 641, 894], [897, 897, 915, 971, 1339], [1340, 1340, 1382, 1382, 1647], [1649, 1649, 1667, 1667, 1887], [1888, 1888, 1915, 1915, 2164], [2170, 2170, 2209, 2209, 2504]], "test": "untested"}
{"id": "slscD2", "name": "A Cubic, Osculated By Parabolas", "author": "mla", "description": "Inspired by Dan Bach on Twitter: [url]https://twitter.com/dansmath/status/1508205090561159172[/url]\n\nMouse sets cubic parameter and parabola spacing. 'x' hides the white cubic line.", "tags": ["cubic", "parabola", "loopless", "osculate"], "likes": 23, "viewed": 457, "published": 3, "date": "1648795435", "time_retrieved": "2024-07-30T16:55:54.531216", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// A Cubic, Osculated by Parabolas.\n// Inspired by Dan Bach: https://twitter.com/dansmath/status/1508205090561159172\n//\n// Matthew Arcus, mla, 2022.\n//\n// A cubic curve y = x³+kx has a family of osculating\n// parabolas (osculating at x = t):\n//\n// y = 3tx² + (k-3t²)x + t³\n//\n// Regarding this as a cubic equation in t, for given x,y:\n//\n// t³ - 3xt² + 3x²t + kx - y = 0\n// ∴ (t-x)³ + x³ + kx - y = 0\n// ∴ t = x+∛(y - x³ - kx) is single real root\n//\n// So exactly 1 parabola passes through each point in the plane.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat k = -1.0; // Cubic parameter\nfloat N = 20.0; // Parabola spacing\n\nfloat lwidth = 0.002;\nfloat scale = 1.0;\n\nvec3 map(vec2 p) {\n  return vec3(scale*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\nfloat cuberoot(float x) {\n  float s = sign(x);\n  x = pow(abs(x),1.0/3.0);\n  return s*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 p = map(fragCoord.xy);\n  float px = fwidth(p.x);\n  if (iMouse.x != 0.0) {\n    vec2 m = iMouse.xy/iResolution.xy;\n    k = 5.0*(m.x-0.5);\n    N = 40.0*m.y;\n  }\n  vec3 color = vec3(0);\n  float x = p.x, y = p.y;\n  float x2 = x*x, x3 = x*x2;\n  // Cubic curve is x³+kx = 0\n  // Find osculating parabola at (x,y)\n  float t0 = x+cuberoot(y-x*(x2+k));\n  float t = t0;\n  t *= N;\n  t -= iTime;\n  t = round(t);\n  t += iTime;\n  t /= N;\n  float t2 = t*t, t3 = t*t2;\n  float d = 3.0*t*x2 + (k-3.0*t2)*x + t3 - y;\n  float dx = 6.0*t*x+(k-3.0*t2);\n  d /= sqrt(dx*dx+1.0); // dy = 1\n  vec3 lcol = h2rgb(atan(t0)/PI);\n  color = mix(lcol,color,smoothstep(0.0,px,abs(d)-lwidth));\n  if (!key(CHAR_X)) {\n    d = x3 + k*x - y;\n    dx = 3.0*x2+k;\n    d /= sqrt(dx*dx+1.0);\n    color = mix(vec3(1),color,smoothstep(0.0,max(px,3.0*lwidth),abs(d)));\n  }\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI =  3.141592654;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return rgb;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slscD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[814, 814, 832, 832, 900], [902, 902, 927, 927, 991], [993, 993, 1050, 1050, 1950]], "test": "untested"}
{"id": "stfyWX", "name": "Noise Caverns", "author": "Plento", "description": "fbm stuff.", "tags": ["2d", "noise"], "likes": 10, "viewed": 248, "published": 3, "date": "1648789780", "time_retrieved": "2024-07-30T16:55:55.273232", "image_code": "// Plento (Cole Peterson)\n\n#define ss(a, b, t) smoothstep(a, b, t)\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define R iResolution.xy\n\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gdns(vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = smoothstep(0., 1., f);\n    \n    vec2 a = hash22(i);\n    vec2 b = hash22( i + vec2(1.,0.));\n    vec2 c = hash22( i + vec2(.0,1.));\n    vec2 d = hash22( i + vec2(1));\n    \n    float nse = mix( mix( dot( a, f - vec2(0.0,0.0) ), \n                     dot( b, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( c, f - vec2(0.0,1.0) ), \n                     dot( d, f - vec2(1) ), u.x), u.y);\n    return nse + 0.5;\n}\n\nfloat octnse(vec2 p, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n     \tn += gdns(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    float y = uv.y;\n    uv*=3.5;\n    uv *= rot(-iTime*.1);\n   \n    vec3 col = vec3(0);\n    \n    float scale = 1., N = 25.;\n    for(float i = 0.; i < N; i++){\n        vec2 p = uv * scale;\n\n        p *= rot(i*.01);\n        p += iTime*.52;\n\n        float ns = octnse(p*0.4, 4);\n        float h = 0.5 + (i / N) * 0.75;\n        float ns2 = ss(h, h + .04 , ns);\n        \n        vec3 nc = mix(vec3(0), .5 + .4*cos(vec3(7., 6., 2.)*i*0.08 - iTime*0.4+2.8), ns2);\n        float fog = max(ss(0.0, 0.9, i / N), 0.02);\n        \n        if(i == N - 1.)  nc -= .4*vec3(ss(.3, 4.3, ns*ns*ns));\n           \n        col = mix(col, nc*fog, ns2);\n    \n        scale += 0.03;\n    }\n\n    col *= step(abs(y), .44);\n\n    col = 1.-exp(-col);\n    f = vec4(col, 1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 226, 226, 364], [366, 366, 386, 386, 861], [863, 863, 893, 893, 1052], [1054, 1054, 1094, 1094, 1885]], "test": "untested"}
{"id": "7lfyDX", "name": "Fleurette", "author": "wyatt", "description": "60's style fractal with caustic", "tags": ["fractal", "caustic"], "likes": 24, "viewed": 368, "published": 3, "date": "1648784357", "time_retrieved": "2024-07-30T16:55:56.024224", "image_code": "Main{\n    Q = .05*B(U);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\nvec2 hash23(vec3 p3)\n{  // Dave H\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_a_code": "Main{\n    Q = vec4(0);\n    U = 4.*(U-.5*R)/R.y;\n    for (float i = 0.; i < 8.; i++) {\n        U = vec2(U.x*U.x-U.y*U.y,2.*U.x*U.y)-vec2(-.6,sin(.05*iTime));\n        U /= .5+0.3*dot(U,U);\n        Q += .1*length(U)*vec4(.5+sin(2.*U.x+vec3(1,2,3)),1);\n    }\n\n}", "buffer_a_inputs": [], "buffer_b_code": "Main {\n    Q = .99*B(U);\n    for (int i = 0; i < 30; i++) {\n        vec2 h = 20.*(hash23(vec3(U+R,i+30*iFrame))*2.-1.);\n        vec4 c = A(U+h),\n             n = A(U+h+vec2(0,1)),\n             e = A(U+h+vec2(1,0)),\n             s = A(U+h-vec2(0,1)),\n             w = A(U+h-vec2(1,0));\n\n        vec2 g = 2.*R.x*vec2(e.w-w.w,n.w-s.w);\n\n        Q += exp(-length(h-g))*c;\n   }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dtGDf", "name": "testShader111111", "author": "15198054594", "description": "testShader1111111111", "tags": ["testshader111111111"], "likes": 0, "viewed": 146, "published": 3, "date": "1648779852", "time_retrieved": "2024-07-30T16:55:56.775216", "image_code": "\n\nvec3 color1 = vec3(1.0, 0.0, 0.0);\nvec3 backgoundColor = vec3(0.5, 0.0, 0.0);\n\nvec3 color(vec2 uv){\n\n    vec2 center = vec2(0.5);\n\n   if( length(uv - center) < 0.5 ){\n      return color1;\n   }else{\n      return backgoundColor;\n   }\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * vec2(960.0/540.0, 1.0) + (cos(iTime)/10.0);\n    \n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(color(uv), 1.0);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 101, 101, 235], [242, 242, 299, 351, 599]], "test": "untested"}
{"id": "NlXyWf", "name": "Fractal Function 9340294832", "author": "SnoopethDuckDuck", "description": "Was trying to simplify this function + make it a fractal: https://www.shadertoy.com/view/NlXcD2\n\nnot super happy with the results, not sure what you could use it with", "tags": ["e"], "likes": 3, "viewed": 195, "published": 3, "date": "1648770439", "time_retrieved": "2024-07-30T16:55:57.583056", "image_code": "float fn(float x, float p) {\n    float f = fract(exp2(p) * x + 0.25) - 0.5;\n    return step(f, 0.) / exp2(p);\n}\n\nfloat fn2(float x) {\n    float f = 0.;\n    float n = 2.; //>2. works fine\n    for (float i = 1.; i < 2. * n + 1.; i+=2.) {\n        float f1 = fn(x, i);\n        float f2 = fn(x, i + 1.);\n        f = abs(f - abs(f1 - f2));\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    uv.y *= 2.4;\n    uv.x -= 0.05 * iTime;\n    uv.y += 0.3 * cos(6. * floor(4. * uv.x) + 0.5 * iTime);\n\n    float y = uv.y;\n\n    float k = 4. / iResolution.y;\n    \n    float sgn = 0.125 * sign(uv.y);\n    float a = 0.5 + (0.25) * cos(floor(16. * uv.x) * 3.14159 /3. + iTime);\n    float s = 0.5 * smoothstep(-k, k, -uv.y -a + fn2(uv.x + 0.25));\n    float s2 = 0.5 * smoothstep(-k, k, uv.y-a + fn2(uv.x));\n\n    float c = 0.6 - 1.5* abs(s-s2);\n    c = abs(c - exp(-0.4 - 5. * ouv.y - ouv.x));\n    c = clamp(c, 0., 1.2); //oversaturated but its ok\n    vec3 col = vec3(0.95,0.42,0.15);\n    col = mix(col, 1. - col, 0.5 + 0.5 * cos(-1. * ouv.y + 0.2 * ouv.x + iTime));\n    col *= c;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 111], [113, 113, 133, 133, 355], [357, 357, 414, 414, 1213]], "test": "untested"}
